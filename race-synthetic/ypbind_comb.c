/* Generated by CIL v. 1.3.5 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i486-linux-gnu/4.1.3/include/stddef.h"
typedef unsigned int size_t;
#line 35 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 36 "/usr/include/bits/types.h"
typedef unsigned int __u_int;
#line 37 "/usr/include/bits/types.h"
typedef unsigned long __u_long;
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 137 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 146 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 189 "/usr/include/bits/types.h"
typedef char *__caddr_t;
#line 195 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 36 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 37 "/usr/include/sys/types.h"
typedef __u_int u_int;
#line 38 "/usr/include/sys/types.h"
typedef __u_long u_long;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 117 "/usr/include/sys/types.h"
typedef __caddr_t caddr_t;
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[(int )(1024U / (8U * sizeof(unsigned long )))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 39 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_attr_t_4 {
   char __size[36] ;
   long __align ;
};
#line 39 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_attr_t_4 pthread_attr_t;
#line 46 "/usr/include/bits/pthreadtypes.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 46 "/usr/include/bits/pthreadtypes.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 54 "/usr/include/bits/pthreadtypes.h"
union __anonunion____missing_field_name_6 {
   int __spins ;
   __pthread_slist_t __list ;
};
#line 54 "/usr/include/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   int __kind ;
   unsigned int __nusers ;
   union __anonunion____missing_field_name_6 __annonCompField1 ;
};
#line 54 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_5 {
   struct __pthread_mutex_s __data ;
   char __size[24] ;
   long __align ;
};
#line 54 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_5 pthread_mutex_t;
#line 84 "/usr/include/bits/pthreadtypes.h"
struct __anonstruct___data_9 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
#line 84 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_8 {
   struct __anonstruct___data_9 __data ;
   char __size[48] ;
   long long __align ;
};
#line 84 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_8 pthread_cond_t;
#line 37 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 146 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 87 "/usr/include/sys/socket.h"
struct sockaddr_in;
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 177 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 183 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 268 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(int )((15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t ))] ;
};
#line 141 "/usr/include/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 36 "/usr/include/rpc/types.h"
typedef int bool_t;
#line 37 "/usr/include/rpc/types.h"
typedef int enum_t;
#line 39 "/usr/include/rpc/types.h"
typedef unsigned long rpcprog_t;
#line 40 "/usr/include/rpc/types.h"
typedef unsigned long rpcvers_t;
#line 41 "/usr/include/rpc/types.h"
typedef unsigned long rpcproc_t;
#line 42 "/usr/include/rpc/types.h"
typedef unsigned long rpcprot_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[(int )(((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr ))] ;
};
#line 83 "/usr/include/rpc/xdr.h"
enum xdr_op {
    XDR_ENCODE = 0,
    XDR_DECODE = 1,
    XDR_FREE = 2
} ;
#line 111
struct XDR;
#line 111 "/usr/include/rpc/xdr.h"
typedef struct XDR XDR;
#line 112 "/usr/include/rpc/xdr.h"
struct xdr_ops {
   bool_t (*x_getlong)(XDR *__xdrs , long *__lp ) ;
   bool_t (*x_putlong)(XDR *__xdrs , long const   *__lp ) ;
   bool_t (*x_getbytes)(XDR *__xdrs , caddr_t __addr , u_int __len ) ;
   bool_t (*x_putbytes)(XDR *__xdrs , char const   *__addr , u_int __len ) ;
   u_int (*x_getpostn)(XDR const   *__xdrs ) ;
   bool_t (*x_setpostn)(XDR *__xdrs , u_int __pos ) ;
   int32_t *(*x_inline)(XDR *__xdrs , u_int __len ) ;
   void (*x_destroy)(XDR *__xdrs ) ;
   bool_t (*x_getint32)(XDR *__xdrs , int32_t *__ip ) ;
   bool_t (*x_putint32)(XDR *__xdrs , int32_t const   *__ip ) ;
};
#line 112 "/usr/include/rpc/xdr.h"
struct XDR {
   enum xdr_op x_op ;
   struct xdr_ops *x_ops ;
   caddr_t x_public ;
   caddr_t x_private ;
   caddr_t x_base ;
   u_int x_handy ;
};
#line 55 "/usr/include/rpc/auth.h"
enum auth_stat {
    AUTH_OK = 0,
    AUTH_BADCRED = 1,
    AUTH_REJECTEDCRED = 2,
    AUTH_BADVERF = 3,
    AUTH_REJECTEDVERF = 4,
    AUTH_TOOWEAK = 5,
    AUTH_INVALIDRESP = 6,
    AUTH_FAILED = 7
} ;
#line 85 "/usr/include/rpc/auth.h"
struct opaque_auth {
   enum_t oa_flavor ;
   caddr_t oa_base ;
   u_int oa_length ;
};
#line 58 "/usr/include/rpc/rpc_msg.h"
enum msg_type {
    CALL = 0,
    REPLY = 1
} ;
#line 63
enum reply_stat {
    MSG_ACCEPTED = 0,
    MSG_DENIED = 1
} ;
#line 68
enum accept_stat {
    SUCCESS = 0,
    PROG_UNAVAIL = 1,
    PROG_MISMATCH = 2,
    PROC_UNAVAIL = 3,
    GARBAGE_ARGS = 4,
    SYSTEM_ERR = 5
} ;
#line 77
enum reject_stat {
    RPC_MISMATCH = 0,
    AUTH_ERROR = 1
} ;
#line 91 "/usr/include/rpc/rpc_msg.h"
struct __anonstruct_AR_versions_72 {
   u_long low ;
   u_long high ;
};
#line 91 "/usr/include/rpc/rpc_msg.h"
struct __anonstruct_AR_results_73 {
   caddr_t where ;
   bool_t (*proc)(XDR * , void *  , ...) ;
};
#line 91 "/usr/include/rpc/rpc_msg.h"
union __anonunion_ru_71 {
   struct __anonstruct_AR_versions_72 AR_versions ;
   struct __anonstruct_AR_results_73 AR_results ;
};
#line 91 "/usr/include/rpc/rpc_msg.h"
struct accepted_reply {
   struct opaque_auth ar_verf ;
   enum accept_stat ar_stat ;
   union __anonunion_ru_71 ru ;
};
#line 112 "/usr/include/rpc/rpc_msg.h"
struct __anonstruct_RJ_versions_75 {
   u_long low ;
   u_long high ;
};
#line 112 "/usr/include/rpc/rpc_msg.h"
union __anonunion_ru_74 {
   struct __anonstruct_RJ_versions_75 RJ_versions ;
   enum auth_stat RJ_why ;
};
#line 112 "/usr/include/rpc/rpc_msg.h"
struct rejected_reply {
   enum reject_stat rj_stat ;
   union __anonunion_ru_74 ru ;
};
#line 128 "/usr/include/rpc/rpc_msg.h"
union __anonunion_ru_76 {
   struct accepted_reply RP_ar ;
   struct rejected_reply RP_dr ;
};
#line 128 "/usr/include/rpc/rpc_msg.h"
struct reply_body {
   enum reply_stat rp_stat ;
   union __anonunion_ru_76 ru ;
};
#line 141 "/usr/include/rpc/rpc_msg.h"
struct call_body {
   u_long cb_rpcvers ;
   u_long cb_prog ;
   u_long cb_vers ;
   u_long cb_proc ;
   struct opaque_auth cb_cred ;
   struct opaque_auth cb_verf ;
};
#line 153 "/usr/include/rpc/rpc_msg.h"
union __anonunion_ru_77 {
   struct call_body RM_cmb ;
   struct reply_body RM_rmb ;
};
#line 153 "/usr/include/rpc/rpc_msg.h"
struct rpc_msg {
   u_long rm_xid ;
   enum msg_type rm_direction ;
   union __anonunion_ru_77 ru ;
};
#line 66 "/usr/include/rpc/svc.h"
enum xprt_stat {
    XPRT_DIED = 0,
    XPRT_MOREREQS = 1,
    XPRT_IDLE = 2
} ;
#line 75
struct SVCXPRT;
#line 75 "/usr/include/rpc/svc.h"
typedef struct SVCXPRT SVCXPRT;
#line 76 "/usr/include/rpc/svc.h"
struct xp_ops {
   bool_t (*xp_recv)(SVCXPRT *__xprt , struct rpc_msg *__msg ) ;
   enum xprt_stat (*xp_stat)(SVCXPRT *__xprt ) ;
   bool_t (*xp_getargs)(SVCXPRT *__xprt , bool_t (*__xdr_args)(XDR * , void *  , ...) ,
                        caddr_t args_ptr ) ;
   bool_t (*xp_reply)(SVCXPRT *__xprt , struct rpc_msg *__msg ) ;
   bool_t (*xp_freeargs)(SVCXPRT *__xprt , bool_t (*__xdr_args)(XDR * , void *  , ...) ,
                         caddr_t args_ptr ) ;
   void (*xp_destroy)(SVCXPRT *__xprt ) ;
};
#line 76 "/usr/include/rpc/svc.h"
struct SVCXPRT {
   int xp_sock ;
   u_short xp_port ;
   struct xp_ops  const  *xp_ops ;
   int xp_addrlen ;
   struct sockaddr_in xp_raddr ;
   struct opaque_auth xp_verf ;
   caddr_t xp_p1 ;
   caddr_t xp_p2 ;
   char xp_pad[256] ;
};
#line 149 "/usr/include/rpc/svc.h"
struct svc_req {
   rpcprog_t rq_prog ;
   rpcvers_t rq_vers ;
   rpcproc_t rq_proc ;
   struct opaque_auth rq_cred ;
   caddr_t rq_clntcred ;
   SVCXPRT *rq_xprt ;
};
#line 38 "ypbind.h"
typedef char *domainname;
#line 45
enum ypbind_resptype {
    YPBIND_SUCC_VAL = 1,
    YPBIND_FAIL_VAL = 2
} ;
#line 49 "ypbind.h"
typedef enum ypbind_resptype ypbind_resptype;
#line 51 "ypbind.h"
struct ypbind_binding {
   char ypbind_binding_addr[4] ;
   char ypbind_binding_port[2] ;
};
#line 55 "ypbind.h"
typedef struct ypbind_binding ypbind_binding;
#line 57 "ypbind.h"
union __anonunion_ypbind_resp_u_55 {
   u_int ypbind_error ;
   ypbind_binding ypbind_bindinfo ;
};
#line 57 "ypbind.h"
struct ypbind_resp {
   ypbind_resptype ypbind_status ;
   union __anonunion_ypbind_resp_u_55 ypbind_resp_u ;
};
#line 64 "ypbind.h"
typedef struct ypbind_resp ypbind_resp;
#line 75 "ypbind.h"
struct ypbind_oldsetdom {
   char ypoldsetdom_domain[256] ;
   ypbind_binding ypoldsetdom_binding ;
};
#line 79 "ypbind.h"
typedef struct ypbind_oldsetdom ypbind_oldsetdom;
#line 83 "ypbind.h"
struct ypbind_setdom {
   domainname ypsetdom_domain ;
   ypbind_binding ypsetdom_binding ;
   u_int ypsetdom_vers ;
};
#line 88 "ypbind.h"
typedef struct ypbind_setdom ypbind_setdom;
#line 26 "ypbind_svc.c"
union __anonunion_argument_57 {
   domainname ypbindproc_olddomain_1_arg ;
   ypbind_oldsetdom ypbindproc_oldsetdom_1_arg ;
};
#line 32 "ypbind_svc.c"
union __anonunion_result_58 {
   ypbind_resp ypbindproc_olddomain_1_res ;
};
#line 91 "ypbind_svc.c"
union __anonunion_argument_59 {
   domainname ypbindproc_domain_2_arg ;
   ypbind_setdom ypbindproc_setdom_2_arg ;
};
#line 97 "ypbind_svc.c"
union __anonunion_result_60 {
   ypbind_resp ypbindproc_domain_2_res ;
};
#line 43 "/usr/lib/gcc/i486-linux-gnu/4.1.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i486-linux-gnu/4.1.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 154 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 203 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 44 "/usr/include/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 96 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 72 "/usr/include/rpc/auth.h"
struct __anonstruct_key_46 {
   u_int32_t high ;
   u_int32_t low ;
};
#line 72 "/usr/include/rpc/auth.h"
union des_block {
   struct __anonstruct_key_46 key ;
   char c[8] ;
};
#line 94
struct AUTH;
#line 94 "/usr/include/rpc/auth.h"
typedef struct AUTH AUTH;
#line 95 "/usr/include/rpc/auth.h"
struct auth_ops {
   void (*ah_nextverf)(AUTH * ) ;
   int (*ah_marshal)(AUTH * , XDR * ) ;
   int (*ah_validate)(AUTH * , struct opaque_auth * ) ;
   int (*ah_refresh)(AUTH * ) ;
   void (*ah_destroy)(AUTH * ) ;
};
#line 95 "/usr/include/rpc/auth.h"
struct AUTH {
   struct opaque_auth ah_cred ;
   struct opaque_auth ah_verf ;
   union des_block ah_key ;
   struct auth_ops *ah_ops ;
   caddr_t ah_private ;
};
#line 53 "/usr/include/rpc/clnt.h"
enum clnt_stat {
    RPC_SUCCESS = 0,
    RPC_CANTENCODEARGS = 1,
    RPC_CANTDECODERES = 2,
    RPC_CANTSEND = 3,
    RPC_CANTRECV = 4,
    RPC_TIMEDOUT = 5,
    RPC_VERSMISMATCH = 6,
    RPC_AUTHERROR = 7,
    RPC_PROGUNAVAIL = 8,
    RPC_PROGVERSMISMATCH = 9,
    RPC_PROCUNAVAIL = 10,
    RPC_CANTDECODEARGS = 11,
    RPC_SYSTEMERROR = 12,
    RPC_NOBROADCAST = 21,
    RPC_UNKNOWNHOST = 13,
    RPC_UNKNOWNPROTO = 17,
    RPC_UNKNOWNADDR = 19,
    RPC_RPCBFAILURE = 14,
    RPC_PROGNOTREGISTERED = 15,
    RPC_N2AXLATEFAILURE = 22,
    RPC_FAILED = 16,
    RPC_INTR = 18,
    RPC_TLIERROR = 20,
    RPC_UDERROR = 23,
    RPC_INPROGRESS = 24,
    RPC_STALERACHANDLE = 25
} ;
#line 106 "/usr/include/rpc/clnt.h"
struct __anonstruct_RE_vers_48 {
   u_long low ;
   u_long high ;
};
#line 106 "/usr/include/rpc/clnt.h"
struct __anonstruct_RE_lb_49 {
   long s1 ;
   long s2 ;
};
#line 106 "/usr/include/rpc/clnt.h"
union __anonunion_ru_47 {
   int RE_errno ;
   enum auth_stat RE_why ;
   struct __anonstruct_RE_vers_48 RE_vers ;
   struct __anonstruct_RE_lb_49 RE_lb ;
};
#line 106 "/usr/include/rpc/clnt.h"
struct rpc_err {
   enum clnt_stat re_status ;
   union __anonunion_ru_47 ru ;
};
#line 132
struct CLIENT;
#line 132 "/usr/include/rpc/clnt.h"
typedef struct CLIENT CLIENT;
#line 133 "/usr/include/rpc/clnt.h"
struct clnt_ops {
   enum clnt_stat (*cl_call)(CLIENT * , u_long  , bool_t (*)(XDR * , void *  , ...) ,
                             caddr_t  , bool_t (*)(XDR * , void *  , ...) , caddr_t  ,
                             struct timeval  ) ;
   void (*cl_abort)(void) ;
   void (*cl_geterr)(CLIENT * , struct rpc_err * ) ;
   bool_t (*cl_freeres)(CLIENT * , bool_t (*)(XDR * , void *  , ...) , caddr_t  ) ;
   void (*cl_destroy)(CLIENT * ) ;
   bool_t (*cl_control)(CLIENT * , int  , char * ) ;
};
#line 133 "/usr/include/rpc/clnt.h"
struct CLIENT {
   AUTH *cl_auth ;
   struct clnt_ops *cl_ops ;
   caddr_t cl_private ;
};
#line 390 "/usr/include/rpc/clnt.h"
struct rpc_createerr {
   enum clnt_stat cf_stat ;
   struct rpc_err cf_error ;
};
#line 90 "/usr/include/rpc/pmap_prot.h"
struct pmap {
   unsigned long pm_prog ;
   unsigned long pm_vers ;
   unsigned long pm_prot ;
   unsigned long pm_port ;
};
#line 27 "pthread_np.h"
struct __anonstruct_pthread_rdwr_t_72 {
   int readers ;
   int writers ;
   int wishwrite ;
   pthread_mutex_t mutex ;
   pthread_cond_t lock_free ;
};
#line 27 "pthread_np.h"
typedef struct __anonstruct_pthread_rdwr_t_72 pthread_rdwr_t;
#line 66 "serv_list.c"
struct bound_server {
   char *host ;
   sa_family_t family ;
   struct in_addr addr ;
   u_short port ;
};
#line 74 "serv_list.c"
struct binding {
   char domain[257] ;
   int active ;
   bool_t use_broadcast ;
   struct bound_server server[30] ;
   struct bound_server ypset ;
   CLIENT *client_handle ;
};
#line 717 "serv_list.c"
struct cu_data {
   int cu_sock ;
   bool_t cu_closeit ;
   struct sockaddr_in cu_raddr ;
   int cu_rlen ;
   struct timeval cu_wait ;
   struct timeval cu_total ;
   struct rpc_err cu_error ;
   XDR cu_outxdrs ;
   u_int cu_xdrpos ;
   u_int cu_sendsz ;
   char *cu_outbuf ;
   u_int cu_recvsz ;
   char cu_inbuf[1] ;
};
#line 735 "serv_list.c"
struct findserv_req {
   u_int32_t xid ;
   u_int server_nr ;
   struct sockaddr_in sin ;
};
#line 75 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_7 {
   char __size[4] ;
   long __align ;
};
#line 75 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_7 pthread_mutexattr_t;
#line 101 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_condattr_t_10 {
   char __size[4] ;
   long __align ;
};
#line 101 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_condattr_t_10 pthread_condattr_t;
#line 1 "ypbind-mt.o"
#pragma merger(0,"/tmp/cil-6VCeiQK5.i","-Wall,-g,-O2")
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 110
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  * __restrict  __addr ,
                                              socklen_t __len ) ;
#line 309 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 318
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 399
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;

#line 450 "/usr/include/sys/stat.h"
__inline static int stat__extinline(char const   *__path , struct stat *__statbuf )
{ int tmp ;

  {
#line 453
  tmp = __xstat(3, __path, __statbuf);
#line 453
  return (tmp);
}
}
#line 135 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 150
extern int closedir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 163
extern struct dirent *readdir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 147
extern struct _IO_FILE *stderr ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 331
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format
                   , ...) ;
#line 337
extern int printf(char const   * __restrict  __format  , ...) ;
#line 339
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format
                                                 , ...) ;
#line 361
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format
                                                                             , ...) ;
#line 411
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format
                                                , ...) ;
#line 570
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                            int __delimiter , FILE * __restrict  __stream ) ;
#line 594
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 733
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 111 "/usr/include/bits/stdio.h"
__inline static __ssize_t getline__extinline(char **__lineptr , size_t *__n , FILE *__stream )
{ __ssize_t tmp ;

  {
#line 114
  tmp = __getdelim((char ** __restrict  )__lineptr, (size_t * __restrict  )__n, '\n',
                   (FILE * __restrict  )__stream);
#line 114
  return (tmp);
}
}
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 85
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 290 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 332 "/usr/include/stdlib.h"
__inline static long strtol__extinline(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                       int __base )
{ long tmp ;

  {
#line 336
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
#line 336
  return (tmp);
}
}
#line 401 "/usr/include/stdlib.h"
__inline static int atoi__extinline(char const   *__nptr )
{ int tmp ;

  {
#line 404
  tmp = (int )strtol__extinline((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                                10);
#line 404
  return (tmp);
}
}
#line 603
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 646
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 320 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 457
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 490
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 573
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 642
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 723
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 792
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 943
extern  __attribute__((__nothrow__)) int getdtablesize(void) ;
#line 181 "/usr/include/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 59 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 102
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 194
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 242
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 256
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 216 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 222
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 271
extern int sigwait(sigset_t const   * __restrict  __set , int * __restrict  __sig )  __attribute__((__nonnull__(1,2))) ;
#line 31 "/usr/include/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int pthread_sigmask(int __how , __sigset_t const   * __restrict  __newmask ,
                                                         __sigset_t * __restrict  __oldmask ) ;
#line 125 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 52 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *dcgettext(char const   *__domainname ,
                                                     char const   *__msgid , int __category )  __attribute__((__format_arg__(2))) ;
#line 83
extern  __attribute__((__nothrow__)) char *textdomain(char const   *__domainname ) ;
#line 87
extern  __attribute__((__nothrow__)) char *bindtextdomain(char const   *__domainname ,
                                                          char const   *__dirname ) ;
#line 173 "/usr/include/rpc/svc.h"
extern  __attribute__((__nothrow__)) bool_t svc_register(SVCXPRT *__xprt , rpcprog_t __prog ,
                                                         rpcvers_t __vers , void (*__dispatch)(struct svc_req * ,
                                                                                               SVCXPRT * ) ,
                                                         rpcprot_t __protocol ) ;
#line 277
extern  __attribute__((__nothrow__)) void svc_run(void) ;
#line 296
extern  __attribute__((__nothrow__)) SVCXPRT *svcudp_create(int __sock ) ;
#line 303
extern  __attribute__((__nothrow__)) SVCXPRT *svctcp_create(int __sock , u_int __sendsize ,
                                                            u_int __recvsize ) ;
#line 64 "/usr/include/rpcsvc/ypclnt.h"
extern  __attribute__((__nothrow__)) int yp_get_default_domain(char ** ) ;
#line 74 "/usr/include/rpc/pmap_clnt.h"
extern  __attribute__((__nothrow__)) bool_t pmap_unset(u_long __program , u_long __vers ) ;
#line 222 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t * __restrict  __newthread ,
                                                        pthread_attr_t const   * __restrict  __attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void * __restrict  __arg )  __attribute__((__nonnull__(1,3))) ;
#line 729
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
#line 740
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
#line 936
extern  __attribute__((__nothrow__)) int pthread_cond_broadcast(pthread_cond_t *__cond )  __attribute__((__nonnull__(1))) ;
#line 944
extern int pthread_cond_wait(pthread_cond_t * __restrict  __cond , pthread_mutex_t * __restrict  __mutex )  __attribute__((__nonnull__(1,2))) ;
#line 47 "/usr/include/nss.h"
extern  __attribute__((__nothrow__)) int __nss_configure_lookup(char const   *__dbname ,
                                                                char const   *__string ) ;
#line 36 "ypbind.h"
int ypset ;
#line 6 "log_msg.h"
int debug_flag ;
#line 8
void log_msg(int type , char const   *fmt  , ...) ;
#line 6 "local.h"
int broken_server ;
#line 7
int port ;
#line 8
int ping_interval ;
#line 11
void clear_server(void) ;
#line 12
int add_server(char const   *domain___0 , char const   *host , int check_syntax ) ;
#line 18
void *test_bindings(void *param  __attribute__((__unused__)) ) ;
#line 21
void do_binding(void) ;
#line 23
void ypbindprog_1(struct svc_req *rqstp , SVCXPRT *transp ) ;
#line 24
void ypbindprog_2(struct svc_req *rqstp , SVCXPRT *transp ) ;
#line 69 "ypbind-mt.c"
char *domain  =    (char *)((void *)0);
#line 70 "ypbind-mt.c"
char const   *configfile  =    "/etc/yp.conf";
#line 71 "ypbind-mt.c"
int ypset  =    0;
#line 72 "ypbind-mt.c"
int use_broadcast  =    0;
#line 73 "ypbind-mt.c"
int broken_server  =    0;
#line 74 "ypbind-mt.c"
int ping_interval  =    20;
#line 75 "ypbind-mt.c"
int local_only  =    0;
#line 76 "ypbind-mt.c"
int port  =    -1;
#line 77 "ypbind-mt.c"
static int lock_fd  ;
#line 78 "ypbind-mt.c"
static int pid_is_written  =    0;
#line 79 "ypbind-mt.c"
static union __anonunion_pthread_mutex_t_5 mutex_pid  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 80 "ypbind-mt.c"
static union __anonunion_pthread_cond_t_8 cond_pid  =    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}};
#line 82 "ypbind-mt.c"
static void unlink_bindingdir(void)
{ DIR *dird ;
  char path[4096] ;
  struct dirent *dirp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 90
  dird = opendir("/var/yp/binding");
#line 90
  if ((unsigned int )dird != (unsigned int )((void *)0)) {
#line 92
    while (1) {
#line 92
      dirp = readdir(dird);
#line 92
      if (! ((unsigned int )dirp != (unsigned int )((void *)0))) {
#line 92
        break;
      }
#line 93
      if (0) {
#line 93
        __s1_len = strlen((char const   *)(dirp->d_name));
#line 93
        __s2_len = strlen(".");
#line 93
        if (! ((unsigned int )((void const   *)(dirp->d_name + 1)) - (unsigned int )((void const   *)(dirp->d_name)) == 1U)) {
          goto _L___0;
        } else {
#line 93
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */
#line 93
            if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") == 1U)) {
#line 93
              tmp___8 = 1;
            } else {
#line 93
              if (__s2_len >= 4U) {
#line 93
                tmp___8 = 1;
              } else {
#line 93
                tmp___8 = 0;
              }
            }
          } else {
#line 93
            tmp___8 = 0;
          }
        }
#line 93
        if (tmp___8) {
#line 93
          tmp___4 = __builtin_strcmp((char const   *)(dirp->d_name), ".");
        } else {
#line 93
          tmp___7 = __builtin_strcmp((char const   *)(dirp->d_name), ".");
#line 93
          tmp___4 = tmp___7;
        }
      } else {
#line 93
        tmp___7 = __builtin_strcmp((char const   *)(dirp->d_name), ".");
#line 93
        tmp___4 = tmp___7;
      }
#line 94
      if (tmp___4) {
#line 94
        if (0) {
#line 94
          __s1_len___0 = strlen((char const   *)(dirp->d_name));
#line 94
          __s2_len___0 = strlen("..");
#line 94
          if (! ((unsigned int )((void const   *)(dirp->d_name + 1)) - (unsigned int )((void const   *)(dirp->d_name)) == 1U)) {
            goto _L___2;
          } else {
#line 94
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */
#line 94
              if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") == 1U)) {
#line 94
                tmp___18 = 1;
              } else {
#line 94
                if (__s2_len___0 >= 4U) {
#line 94
                  tmp___18 = 1;
                } else {
#line 94
                  tmp___18 = 0;
                }
              }
            } else {
#line 94
              tmp___18 = 0;
            }
          }
#line 94
          if (tmp___18) {
#line 94
            tmp___14 = __builtin_strcmp((char const   *)(dirp->d_name), "..");
          } else {
#line 94
            tmp___17 = __builtin_strcmp((char const   *)(dirp->d_name), "..");
#line 94
            tmp___14 = tmp___17;
          }
        } else {
#line 94
          tmp___17 = __builtin_strcmp((char const   *)(dirp->d_name), "..");
#line 94
          tmp___14 = tmp___17;
        }
#line 94
        if (tmp___14) {
#line 96
          snprintf((char * __restrict  )(path), 4096U, (char const   * __restrict  )"%s/%s",
                   "/var/yp/binding", dirp->d_name);
#line 97
          unlink((char const   *)(path));
        }
      }
    }
#line 99
    closedir(dird);
  }
#line 101
  return;
}
}
#line 104 "ypbind-mt.c"
static int load_config(int check_syntax )
{ FILE *fp ;
  char *buf ;
  size_t buflen ;
  int have_entries ;
  int bad_entries ;
  char tmpserver[81] ;
  char tmpdomain[257] ;
  int count ;
  char *tmp ;
  char *cp ;
  ssize_t n ;
  ssize_t tmp___0 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int tmp___31 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___37 ;
  int tmp___40 ;
  int tmp___41 ;
  unsigned short const   **tmp___44 ;
  int tmp___58 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___64 ;
  int tmp___67 ;
  int tmp___68 ;
  unsigned short const   **tmp___71 ;
  int tmp___85 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___91 ;
  int tmp___94 ;
  int tmp___95 ;
  unsigned short const   **tmp___98 ;
  char *tmp___99 ;
  char *tmp___100 ;
  int tmp___101 ;
  char *tmp___102 ;
  char *tmp___103 ;
  char *tmp___104 ;

  {
#line 108
  buf = (char *)((void *)0);
#line 109
  buflen = (size_t )0;
#line 110
  have_entries = 0;
#line 111
  bad_entries = 0;
#line 113
  fp = fopen((char const   * __restrict  )configfile, (char const   * __restrict  )"r");
#line 114
  if ((unsigned int )((void *)0) == (unsigned int )fp) {
#line 115
    return (1);
  }
#line 117
  if (debug_flag) {
#line 118
    log_msg(7, "parsing config file");
  }
#line 120
  while (1) {
#line 120
    tmp___101 = feof(fp);
#line 120
    if (tmp___101) {
#line 120
      break;
    }
#line 126
    tmp___0 = getline__extinline(& buf, & buflen, fp);
#line 126
    n = tmp___0;
#line 144
    cp = buf;
#line 146
    if (n < 1) {
#line 147
      break;
    }
#line 149
    tmp___2 = __builtin_strchr(cp, (char )'#');
#line 149
    tmp = tmp___2;
#line 150
    if (tmp) {
#line 151
      (*tmp) = (char )'\000';
    }
#line 152
    while (1) {
#line 152
      tmp___3 = __ctype_b_loc();
#line 152
      if (! ((int const   )(*((*tmp___3) + (int )(*cp))) & 8192)) {
#line 152
        break;
      }
#line 153
      cp ++;
    }
#line 154
    if ((int )(*cp) == 0) {
#line 155
      continue;
    }
#line 157
    tmp___5 = strlen((char const   *)cp);
#line 157
    if ((int )(*(cp + (tmp___5 - 1U))) == 10) {
#line 158
      tmp___4 = strlen((char const   *)cp);
#line 158
      (*(cp + (tmp___4 - 1U))) = (char )'\000';
    }
#line 160
    if (debug_flag) {
#line 161
      tmp___6 = dcgettext((char const   *)((void *)0), "Trying entry:", 5);
#line 161
      log_msg(7, "%s %s", tmp___6, cp);
    }
#line 163
    if (check_syntax) {
#line 164
      tmp___7 = dcgettext((char const   *)((void *)0), "Trying entry:", 5);
#line 164
      printf((char const   * __restrict  )"%s %s\n", tmp___7, cp);
    }
#line 166
    if (0) {
#line 166
      if (0) {
#line 166
        __s1_len___4 = strlen((char const   *)cp);
#line 166
        __s2_len___4 = strlen("domain");
#line 166
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___12;
        } else {
#line 166
          if (__s1_len___4 >= 4U) {
            _L___12: /* CIL Label */
#line 166
            if (! ((unsigned int )((void const   *)("domain" + 1)) - (unsigned int )((void const   *)"domain") == 1U)) {
#line 166
              tmp___95 = 1;
            } else {
#line 166
              if (__s2_len___4 >= 4U) {
#line 166
                tmp___95 = 1;
              } else {
#line 166
                tmp___95 = 0;
              }
            }
          } else {
#line 166
            tmp___95 = 0;
          }
        }
#line 166
        if (tmp___95) {
#line 166
          tmp___91 = __builtin_strcmp((char const   *)cp, "domain");
        } else {
#line 166
          tmp___94 = __builtin_strcmp((char const   *)cp, "domain");
#line 166
          tmp___91 = tmp___94;
        }
      } else {
#line 166
        tmp___94 = __builtin_strcmp((char const   *)cp, "domain");
#line 166
        tmp___91 = tmp___94;
      }
#line 166
      tmp___85 = tmp___91;
    } else {
#line 166
      tmp___85 = strncmp((char const   *)cp, "domain", 6U);
    }
#line 166
    if (tmp___85 == 0) {
#line 166
      tmp___98 = __ctype_b_loc();
#line 166
      if ((int const   )(*((*tmp___98) + (int )(*(cp + 6)))) & 8192) {
#line 176
        tmp___10 = strstr((char const   *)cp, "server");
#line 176
        if ((unsigned int )tmp___10 != (unsigned int )((void *)0)) {
#line 178
          count = sscanf((char const   * __restrict  )cp, (char const   * __restrict  )"domain %64s server %80s",
                         tmpdomain, tmpserver);
#line 180
          if (count == 2) {
#line 182
            if (debug_flag) {
#line 183
              tmp___8 = dcgettext((char const   *)((void *)0), "parsed domain \'%s\' server \'%s\'",
                                  5);
#line 183
              log_msg(7, (char const   *)tmp___8, tmpdomain, tmpserver);
            }
#line 185
            tmp___9 = add_server((char const   *)(tmpdomain), (char const   *)(tmpserver),
                                 check_syntax);
#line 185
            if (tmp___9) {
#line 186
              have_entries ++;
            } else {
#line 188
              bad_entries ++;
            }
#line 190
            continue;
          }
        }
#line 193
        tmp___13 = strstr((char const   *)cp, "broadcast");
#line 193
        if ((unsigned int )tmp___13 != (unsigned int )((void *)0)) {
#line 195
          count = sscanf((char const   * __restrict  )cp, (char const   * __restrict  )"domain %s broadcast",
                         tmpdomain);
#line 196
          if (count == 1) {
#line 198
            if (debug_flag) {
#line 199
              tmp___11 = dcgettext((char const   *)((void *)0), "parsed domain \'%s\' broadcast",
                                   5);
#line 199
              log_msg(7, (char const   *)tmp___11, tmpdomain);
            }
#line 201
            tmp___12 = add_server((char const   *)(tmpdomain), (char const   *)((void *)0),
                                  check_syntax);
#line 201
            if (tmp___12) {
#line 202
              have_entries ++;
            } else {
#line 204
              bad_entries ++;
            }
#line 206
            continue;
          }
        }
      } else {
        goto _L___13;
      }
    } else {
      _L___13: /* CIL Label */
#line 232
      if (0) {
#line 232
        if (0) {
#line 232
          __s1_len___2 = strlen((char const   *)cp);
#line 232
          __s2_len___2 = strlen("ypserver");
#line 232
          if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
            goto _L___7;
          } else {
#line 232
            if (__s1_len___2 >= 4U) {
              _L___7: /* CIL Label */
#line 232
              if (! ((unsigned int )((void const   *)("ypserver" + 1)) - (unsigned int )((void const   *)"ypserver") == 1U)) {
#line 232
                tmp___68 = 1;
              } else {
#line 232
                if (__s2_len___2 >= 4U) {
#line 232
                  tmp___68 = 1;
                } else {
#line 232
                  tmp___68 = 0;
                }
              }
            } else {
#line 232
              tmp___68 = 0;
            }
          }
#line 232
          if (tmp___68) {
#line 232
            tmp___64 = __builtin_strcmp((char const   *)cp, "ypserver");
          } else {
#line 232
            tmp___67 = __builtin_strcmp((char const   *)cp, "ypserver");
#line 232
            tmp___64 = tmp___67;
          }
        } else {
#line 232
          tmp___67 = __builtin_strcmp((char const   *)cp, "ypserver");
#line 232
          tmp___64 = tmp___67;
        }
#line 232
        tmp___58 = tmp___64;
      } else {
#line 232
        tmp___58 = strncmp((char const   *)cp, "ypserver", 8U);
      }
#line 232
      if (tmp___58 == 0) {
#line 232
        tmp___71 = __ctype_b_loc();
#line 232
        if ((int const   )(*((*tmp___71) + (int )(*(cp + 8)))) & 8192) {
#line 237
          count = sscanf((char const   * __restrict  )cp, (char const   * __restrict  )"ypserver %80s",
                         tmpserver);
#line 238
          if (count == 1) {
#line 240
            if (debug_flag) {
#line 241
              tmp___14 = dcgettext((char const   *)((void *)0), "parsed ypserver %s",
                                   5);
#line 241
              log_msg(7, (char const   *)tmp___14, tmpserver);
            }
#line 242
            tmp___15 = add_server((char const   *)domain, (char const   *)(tmpserver),
                                  check_syntax);
#line 242
            if (tmp___15) {
#line 243
              have_entries ++;
            } else {
#line 245
              bad_entries ++;
            }
#line 246
            continue;
          }
        } else {
          goto _L___8;
        }
      } else {
        _L___8: /* CIL Label */
#line 249
        if (0) {
#line 249
          if (0) {
#line 249
            __s1_len___0 = strlen((char const   *)cp);
#line 249
            __s2_len___0 = strlen("broadcast");
#line 249
            if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
              goto _L___2;
            } else {
#line 249
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */
#line 249
                if (! ((unsigned int )((void const   *)("broadcast" + 1)) - (unsigned int )((void const   *)"broadcast") == 1U)) {
#line 249
                  tmp___41 = 1;
                } else {
#line 249
                  if (__s2_len___0 >= 4U) {
#line 249
                    tmp___41 = 1;
                  } else {
#line 249
                    tmp___41 = 0;
                  }
                }
              } else {
#line 249
                tmp___41 = 0;
              }
            }
#line 249
            if (tmp___41) {
#line 249
              tmp___37 = __builtin_strcmp((char const   *)cp, "broadcast");
            } else {
#line 249
              tmp___40 = __builtin_strcmp((char const   *)cp, "broadcast");
#line 249
              tmp___37 = tmp___40;
            }
          } else {
#line 249
            tmp___40 = __builtin_strcmp((char const   *)cp, "broadcast");
#line 249
            tmp___37 = tmp___40;
          }
#line 249
          tmp___31 = tmp___37;
        } else {
#line 249
          tmp___31 = strncmp((char const   *)cp, "broadcast", 9U);
        }
#line 249
        if (tmp___31 == 0) {
#line 249
          tmp___44 = __ctype_b_loc();
#line 249
          if ((int const   )(*((*tmp___44) + (int )(*(cp + 9)))) & 8192) {
            goto _L___3;
          } else {
#line 249
            if ((int )(*(cp + 9)) == 0) {
              _L___3: /* CIL Label */
#line 255
              if (debug_flag) {
#line 256
                tmp___16 = dcgettext((char const   *)((void *)0), "parsed broadcast",
                                     5);
#line 256
                log_msg(7, (char const   *)tmp___16);
              }
#line 257
              tmp___17 = add_server((char const   *)domain, (char const   *)((void *)0),
                                    check_syntax);
#line 257
              if (tmp___17) {
#line 258
                have_entries ++;
              } else {
#line 260
                bad_entries ++;
              }
#line 261
              continue;
            }
          }
        }
      }
    }
#line 263
    if (check_syntax) {
#line 265
      tmp___99 = dcgettext((char const   *)((void *)0), "Entry \"%s\" is not valid!\n",
                           5);
#line 265
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___99,
              cp);
#line 266
      bad_entries ++;
    } else {
#line 269
      tmp___100 = dcgettext((char const   *)((void *)0), "Entry \"%s\" is not valid, ignore it!",
                            5);
#line 269
      log_msg(3, (char const   *)tmp___100, cp);
    }
  }
#line 271
  fclose(fp);
#line 273
  if (buf) {
#line 274
    free((void *)buf);
  }
#line 276
  if (check_syntax) {
#line 278
    if (bad_entries) {
#line 280
      tmp___102 = dcgettext((char const   *)((void *)0), "Bad entries found.\n", 5);
#line 280
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___102);
#line 281
      return (1);
    }
#line 283
    if (! have_entries) {
#line 285
      tmp___103 = dcgettext((char const   *)((void *)0), "No entry found.\n", 5);
#line 285
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___103);
#line 286
      return (1);
    }
  }
#line 290
  if (! have_entries) {
#line 292
    if (debug_flag) {
#line 293
      tmp___104 = dcgettext((char const   *)((void *)0), "No entry found.", 5);
#line 293
      log_msg(7, (char const   *)tmp___104);
    }
#line 294
    return (1);
  }
#line 297
  return (0);
}
}
#line 301 "ypbind-mt.c"
static void create_pidfile(void)
{ struct flock lock ;
  int left ;
  int written ;
  pid_t pid ;
  char pbuf[10] ;
  char *ptr ;
  int flags ;
  char *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  __pid_t tmp___9 ;

  {
#line 310
  lock_fd = open("/var/run/ypbind.pid", 66, 420);
#line 312
  if (lock_fd < 0) {
#line 313
    tmp = dcgettext((char const   *)((void *)0), "cannot create pidfile %s", 5);
#line 313
    log_msg(3, (char const   *)tmp, "/var/run/ypbind.pid");
  }
#line 316
  flags = fcntl(lock_fd, 1, 0);
#line 317
  if (flags == -1) {
#line 320
    close(lock_fd);
#line 321
    return;
  }
#line 323
  flags |= 1;
#line 324
  tmp___0 = fcntl(lock_fd, 2, flags);
#line 324
  if (tmp___0 < 0) {
#line 327
    close(lock_fd);
#line 328
    return;
  }
#line 331
  lock.l_type = (short)1;
#line 332
  lock.l_start = 0L;
#line 333
  lock.l_whence = (short)0;
#line 334
  lock.l_len = 0L;
#line 337
  tmp___5 = fcntl(lock_fd, 5, & lock);
#line 337
  if (tmp___5 < 0) {
#line 339
    tmp___4 = __errno_location();
#line 339
    if ((*tmp___4) != 37) {
#line 341
      tmp___1 = __errno_location();
#line 341
      tmp___2 = strerror((*tmp___1));
#line 341
      tmp___3 = dcgettext((char const   *)((void *)0), "fcntl error: %s", 5);
#line 341
      log_msg(3, (char const   *)tmp___3, tmp___2);
    }
#line 344
    pid = 0;
  } else {
#line 346
    if ((int )lock.l_type == 2) {
#line 347
      pid = 0;
    } else {
#line 349
      pid = lock.l_pid;
    }
  }
#line 351
  if (pid != 0) {
#line 353
    tmp___6 = dcgettext((char const   *)((void *)0), "ypbind-mt already running (pid %d) - exiting",
                        5);
#line 353
    log_msg(3, (char const   *)tmp___6, pid);
#line 355
    exit(1);
  }
#line 359
  lock.l_type = (short)1;
#line 360
  lock.l_start = 0L;
#line 361
  lock.l_whence = (short)0;
#line 362
  lock.l_len = 0L;
#line 363
  tmp___8 = fcntl(lock_fd, 6, & lock);
#line 363
  if (tmp___8 != 0) {
#line 364
    tmp___7 = dcgettext((char const   *)((void *)0), "cannot lock pidfile", 5);
#line 364
    log_msg(3, (char const   *)tmp___7);
  }
#line 365
  tmp___9 = getpid();
#line 365
  sprintf((char * __restrict  )(pbuf), (char const   * __restrict  )"%ld\n", (long )tmp___9);
#line 366
  left = (int )strlen((char const   *)(pbuf));
#line 367
  ptr = pbuf;
#line 368
  while (left > 0) {
#line 370
    written = write(lock_fd, (void const   *)ptr, (unsigned int )left);
#line 370
    if (written <= 0) {
#line 371
      return;
    }
#line 372
    left -= written;
#line 373
    ptr += written;
  }
#line 378
  return;
}
}
#line 382 "ypbind-mt.c"
static void *sig_handler(void *v_param  __attribute__((__unused__)) )
{ struct flock lock ;
  sigset_t sigs_to_catch ;
  int caught ;
  int ret ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 392
  create_pidfile();
#line 397
  pthread_mutex_lock(& mutex_pid);
#line 398
  pid_is_written = 1;
#line 399
  pthread_cond_broadcast(& cond_pid);
#line 400
  pthread_mutex_unlock(& mutex_pid);
#line 402
  sigemptyset(& sigs_to_catch);
#line 403
  sigaddset(& sigs_to_catch, 17);
#line 404
  sigaddset(& sigs_to_catch, 15);
#line 405
  sigaddset(& sigs_to_catch, 2);
#line 406
  sigaddset(& sigs_to_catch, 3);
#line 407
  sigaddset(& sigs_to_catch, 11);
#line 408
  sigaddset(& sigs_to_catch, 1);
#line 410
  while (1) {
#line 412
    tmp = sigwait((sigset_t const   * __restrict  )(& sigs_to_catch), (int * __restrict  )(& caught));
#line 412
    ret = tmp;
#line 413
    if (ret != 0) {
#line 415
      if (ret != 4) {
#line 416
        tmp___0 = dcgettext((char const   *)((void *)0), "sigwait failed: ret=%d.",
                            5);
#line 416
        log_msg(3, (char const   *)tmp___0, ret);
      }
#line 417
      continue;
    }
#line 419
    switch (caught) {
    case 17:
#line 422
    tmp___1 = dcgettext((char const   *)((void *)0), "SIGCHLD arrived, what should I do ?",
                        5);
#line 422
    log_msg(3, (char const   *)tmp___1);
#line 423
    break;
    case 15:
    case 2:
    case 3:
    case 11:
#line 429
    if (debug_flag) {
#line 430
      tmp___2 = dcgettext((char const   *)((void *)0), "Signal (%d) for quitting program arrived.",
                          5);
#line 430
      log_msg(7, (char const   *)tmp___2, caught);
    }
#line 432
    pmap_unset(100007UL, 2UL);
#line 433
    pmap_unset(100007UL, 1UL);
#line 435
    lock.l_type = (short)2;
#line 436
    lock.l_start = 0L;
#line 437
    lock.l_whence = (short)0;
#line 438
    lock.l_len = 0L;
#line 439
    tmp___4 = fcntl(lock_fd, 6, & lock);
#line 439
    if (tmp___4 != 0) {
#line 440
      tmp___3 = dcgettext((char const   *)((void *)0), "cannot unlock pidfile", 5);
#line 440
      log_msg(3, (char const   *)tmp___3);
    }
#line 441
    close(lock_fd);
#line 442
    unlink("/var/run/ypbind.pid");
#line 443
    unlink_bindingdir();
#line 444
    exit(0);
#line 445
    break;
    case 1:
#line 448
    if (debug_flag) {
#line 449
      tmp___5 = dcgettext((char const   *)((void *)0), "SIGHUP arrived, reloading config file.",
                          5);
#line 449
      log_msg(7, (char const   *)tmp___5);
    }
#line 450
    clear_server();
#line 452
    if (use_broadcast) {
#line 453
      add_server((char const   *)domain, (char const   *)((void *)0), 0);
    } else {
#line 455
      load_config(0);
    }
#line 457
    if (ping_interval < 1) {
#line 458
      do_binding();
    }
#line 459
    break;
    default:
#line 461
    tmp___6 = dcgettext((char const   *)((void *)0), "Unknown signal: %d", 5);
#line 461
    log_msg(3, (char const   *)tmp___6, caught);
#line 462
    break;
    }
  }
}
}
#line 467 "ypbind-mt.c"
static void usage(void)
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 470
  tmp = dcgettext((char const   *)((void *)0), "Usage:\n", 5);
#line 470
  fputs((char const   * __restrict  )tmp, (FILE * __restrict  )stderr);
#line 471
  tmp___0 = dcgettext((char const   *)((void *)0), "\typbind [-broadcast | -ypset | -ypsetme] [-p port] [-f configfile]\n\t  [-no-ping] [-broken-server] [-local-only] [-i ping-interval] [-debug]\n",
                      5);
#line 471
  fputs((char const   * __restrict  )tmp___0, (FILE * __restrict  )stderr);
#line 472
  tmp___1 = dcgettext((char const   *)((void *)0), "\typbind -c [-f configfile]\n",
                      5);
#line 472
  fputs((char const   * __restrict  )tmp___1, (FILE * __restrict  )stderr);
#line 473
  tmp___2 = dcgettext((char const   *)((void *)0), "\typbind --version\n", 5);
#line 473
  fputs((char const   * __restrict  )tmp___2, (FILE * __restrict  )stderr);
#line 474
  exit(1);
}
}
#line 477 "ypbind-mt.c"
int main(int argc , char **argv )
{ SVCXPRT *transp ;
  int sock ;
  int result ;
  int i ;
  sigset_t sigs_to_block ;
  struct sockaddr_in socket_address ;
  pthread_t sig_thread ;
  pthread_t ping_thread ;
  struct stat st ;
  int configcheck_only ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___54 ;
  int tmp___57 ;
  int tmp___58 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___64 ;
  int tmp___67 ;
  int tmp___68 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___74 ;
  int tmp___77 ;
  int tmp___78 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___84 ;
  int tmp___87 ;
  int tmp___88 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___94 ;
  int tmp___97 ;
  int tmp___98 ;
  size_t __s1_len___9 ;
  size_t __s2_len___9 ;
  int tmp___104 ;
  int tmp___107 ;
  int tmp___108 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___114 ;
  int tmp___117 ;
  int tmp___118 ;
  size_t __s1_len___11 ;
  size_t __s2_len___11 ;
  int tmp___124 ;
  int tmp___127 ;
  int tmp___128 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___134 ;
  int tmp___137 ;
  int tmp___138 ;
  size_t __s1_len___13 ;
  size_t __s2_len___13 ;
  int tmp___144 ;
  int tmp___147 ;
  int tmp___148 ;
  size_t __s1_len___14 ;
  size_t __s2_len___14 ;
  int tmp___154 ;
  int tmp___157 ;
  int tmp___158 ;
  size_t __s1_len___15 ;
  size_t __s2_len___15 ;
  int tmp___164 ;
  int tmp___167 ;
  int tmp___168 ;
  size_t __s1_len___16 ;
  size_t __s2_len___16 ;
  int tmp___174 ;
  int tmp___177 ;
  int tmp___178 ;
  char *tmp___179 ;
  char *tmp___180 ;
  int tmp___181 ;
  size_t __s1_len___17 ;
  size_t __s2_len___17 ;
  int tmp___187 ;
  int tmp___190 ;
  int tmp___191 ;
  char *tmp___192 ;
  char *tmp___193 ;
  int tmp___194 ;
  char *tmp___195 ;
  __uid_t tmp___196 ;
  int *tmp___197 ;
  char *tmp___198 ;
  char *tmp___199 ;
  int tmp___200 ;
  int tmp___201 ;
  int *tmp___202 ;
  char *tmp___203 ;
  char *tmp___204 ;
  int tmp___205 ;
  int tmp___206 ;
  int *tmp___207 ;
  char *tmp___208 ;
  char *tmp___209 ;
  int tmp___210 ;
  char *tmp___211 ;
  char *tmp___212 ;
  char *tmp___213 ;
  int tmp___214 ;
  int j ;
  int *tmp___215 ;
  char *tmp___216 ;
  int *tmp___217 ;
  char *tmp___218 ;
  __pid_t tmp___219 ;
  int *tmp___220 ;
  char *tmp___221 ;
  int tmp___222 ;
  int *tmp___223 ;
  char *tmp___224 ;
  int tmp___225 ;
  int *tmp___226 ;
  char *tmp___227 ;
  char *tmp___228 ;
  register unsigned int __v ;
  register unsigned int __x ;
  register unsigned int __v___0 ;
  register unsigned int __x___0 ;
  register unsigned short __v___1 ;
  register unsigned short __x___1 ;
  int *tmp___229 ;
  char *tmp___230 ;
  char *tmp___231 ;
  char *tmp___232 ;
  char *tmp___233 ;
  bool_t tmp___234 ;
  char *tmp___235 ;
  bool_t tmp___236 ;
  int *tmp___237 ;
  char *tmp___238 ;
  char *tmp___239 ;
  register unsigned int __v___2 ;
  register unsigned int __x___2 ;
  register unsigned int __v___3 ;
  register unsigned int __x___3 ;
  register unsigned short __v___4 ;
  register unsigned short __x___4 ;
  int *tmp___240 ;
  char *tmp___241 ;
  char *tmp___242 ;
  char *tmp___243 ;
  char *tmp___244 ;
  bool_t tmp___245 ;
  char *tmp___246 ;
  bool_t tmp___247 ;
  char *tmp___248 ;

  {
#line 486
  configcheck_only = 0;
#line 488
  setlocale(5, "");
#line 489
  setlocale(0, "");
#line 490
  bindtextdomain("ypbind-mt", "/usr/share/locale");
#line 491
  textdomain("ypbind-mt");
#line 494
  i = 1;
#line 494
  while (i < argc) {
#line 496
    if (0) {
#line 496
      __s1_len___16 = strlen("--version");
#line 496
      __s2_len___16 = strlen((char const   *)(*(argv + i)));
#line 496
      if (! ((unsigned int )((void const   *)("--version" + 1)) - (unsigned int )((void const   *)"--version") == 1U)) {
        goto _L___35;
      } else {
#line 496
        if (__s1_len___16 >= 4U) {
          _L___35: /* CIL Label */
#line 496
          if (! ((unsigned int )((void const   *)((*(argv + i)) + 1)) - (unsigned int )((void const   *)(*(argv + i))) == 1U)) {
#line 496
            tmp___178 = 1;
          } else {
#line 496
            if (__s2_len___16 >= 4U) {
#line 496
              tmp___178 = 1;
            } else {
#line 496
              tmp___178 = 0;
            }
          }
        } else {
#line 496
          tmp___178 = 0;
        }
      }
#line 496
      if (tmp___178) {
#line 496
        tmp___174 = __builtin_strcmp("--version", (char const   *)(*(argv + i)));
      } else {
#line 496
        tmp___177 = __builtin_strcmp("--version", (char const   *)(*(argv + i)));
#line 496
        tmp___174 = tmp___177;
      }
    } else {
#line 496
      tmp___177 = __builtin_strcmp("--version", (char const   *)(*(argv + i)));
#line 496
      tmp___174 = tmp___177;
    }
#line 496
    if (tmp___174 == 0) {
#line 498
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ypbind (%s) %s\n",
              "ypbind-mt", "1.19.1");
#line 499
      exit(1);
    } else {
#line 501
      if (0) {
#line 501
        __s1_len___15 = strlen("-ypset");
#line 501
        __s2_len___15 = strlen((char const   *)(*(argv + i)));
#line 501
        if (! ((unsigned int )((void const   *)("-ypset" + 1)) - (unsigned int )((void const   *)"-ypset") == 1U)) {
          goto _L___33;
        } else {
#line 501
          if (__s1_len___15 >= 4U) {
            _L___33: /* CIL Label */
#line 501
            if (! ((unsigned int )((void const   *)((*(argv + i)) + 1)) - (unsigned int )((void const   *)(*(argv + i))) == 1U)) {
#line 501
              tmp___168 = 1;
            } else {
#line 501
              if (__s2_len___15 >= 4U) {
#line 501
                tmp___168 = 1;
              } else {
#line 501
                tmp___168 = 0;
              }
            }
          } else {
#line 501
            tmp___168 = 0;
          }
        }
#line 501
        if (tmp___168) {
#line 501
          tmp___164 = __builtin_strcmp("-ypset", (char const   *)(*(argv + i)));
        } else {
#line 501
          tmp___167 = __builtin_strcmp("-ypset", (char const   *)(*(argv + i)));
#line 501
          tmp___164 = tmp___167;
        }
      } else {
#line 501
        tmp___167 = __builtin_strcmp("-ypset", (char const   *)(*(argv + i)));
#line 501
        tmp___164 = tmp___167;
      }
#line 501
      if (tmp___164 == 0) {
#line 502
        ypset = 1;
      } else {
#line 503
        if (0) {
#line 503
          __s1_len___14 = strlen("-ypsetme");
#line 503
          __s2_len___14 = strlen((char const   *)(*(argv + i)));
#line 503
          if (! ((unsigned int )((void const   *)("-ypsetme" + 1)) - (unsigned int )((void const   *)"-ypsetme") == 1U)) {
            goto _L___31;
          } else {
#line 503
            if (__s1_len___14 >= 4U) {
              _L___31: /* CIL Label */
#line 503
              if (! ((unsigned int )((void const   *)((*(argv + i)) + 1)) - (unsigned int )((void const   *)(*(argv + i))) == 1U)) {
#line 503
                tmp___158 = 1;
              } else {
#line 503
                if (__s2_len___14 >= 4U) {
#line 503
                  tmp___158 = 1;
                } else {
#line 503
                  tmp___158 = 0;
                }
              }
            } else {
#line 503
              tmp___158 = 0;
            }
          }
#line 503
          if (tmp___158) {
#line 503
            tmp___154 = __builtin_strcmp("-ypsetme", (char const   *)(*(argv + i)));
          } else {
#line 503
            tmp___157 = __builtin_strcmp("-ypsetme", (char const   *)(*(argv + i)));
#line 503
            tmp___154 = tmp___157;
          }
        } else {
#line 503
          tmp___157 = __builtin_strcmp("-ypsetme", (char const   *)(*(argv + i)));
#line 503
          tmp___154 = tmp___157;
        }
#line 503
        if (tmp___154 == 0) {
#line 504
          ypset = 2;
        } else {
#line 505
          if (0) {
#line 505
            __s1_len___12 = strlen("-d");
#line 505
            __s2_len___12 = strlen((char const   *)(*(argv + i)));
#line 505
            if (! ((unsigned int )((void const   *)("-d" + 1)) - (unsigned int )((void const   *)"-d") == 1U)) {
              goto _L___27;
            } else {
#line 505
              if (__s1_len___12 >= 4U) {
                _L___27: /* CIL Label */
#line 505
                if (! ((unsigned int )((void const   *)((*(argv + i)) + 1)) - (unsigned int )((void const   *)(*(argv + i))) == 1U)) {
#line 505
                  tmp___138 = 1;
                } else {
#line 505
                  if (__s2_len___12 >= 4U) {
#line 505
                    tmp___138 = 1;
                  } else {
#line 505
                    tmp___138 = 0;
                  }
                }
              } else {
#line 505
                tmp___138 = 0;
              }
            }
#line 505
            if (tmp___138) {
#line 505
              tmp___134 = __builtin_strcmp("-d", (char const   *)(*(argv + i)));
            } else {
#line 505
              tmp___137 = __builtin_strcmp("-d", (char const   *)(*(argv + i)));
#line 505
              tmp___134 = tmp___137;
            }
          } else {
#line 505
            tmp___137 = __builtin_strcmp("-d", (char const   *)(*(argv + i)));
#line 505
            tmp___134 = tmp___137;
          }
#line 506
          if (tmp___134 == 0) {
#line 507
            debug_flag = 1;
          } else {
#line 506
            if (0) {
#line 506
              __s1_len___13 = strlen("-debug");
#line 506
              __s2_len___13 = strlen((char const   *)(*(argv + i)));
#line 506
              if (! ((unsigned int )((void const   *)("-debug" + 1)) - (unsigned int )((void const   *)"-debug") == 1U)) {
                goto _L___29;
              } else {
#line 506
                if (__s1_len___13 >= 4U) {
                  _L___29: /* CIL Label */
#line 506
                  if (! ((unsigned int )((void const   *)((*(argv + i)) + 1)) - (unsigned int )((void const   *)(*(argv + i))) == 1U)) {
#line 506
                    tmp___148 = 1;
                  } else {
#line 506
                    if (__s2_len___13 >= 4U) {
#line 506
                      tmp___148 = 1;
                    } else {
#line 506
                      tmp___148 = 0;
                    }
                  }
                } else {
#line 506
                  tmp___148 = 0;
                }
              }
#line 506
              if (tmp___148) {
#line 506
                tmp___144 = __builtin_strcmp("-debug", (char const   *)(*(argv + i)));
              } else {
#line 506
                tmp___147 = __builtin_strcmp("-debug", (char const   *)(*(argv + i)));
#line 506
                tmp___144 = tmp___147;
              }
            } else {
#line 506
              tmp___147 = __builtin_strcmp("-debug", (char const   *)(*(argv + i)));
#line 506
              tmp___144 = tmp___147;
            }
#line 506
            if (tmp___144 == 0) {
#line 507
              debug_flag = 1;
            } else {
#line 508
              if (0) {
#line 508
                __s1_len___10 = strlen("-broken-server");
#line 508
                __s2_len___10 = strlen((char const   *)(*(argv + i)));
#line 508
                if (! ((unsigned int )((void const   *)("-broken-server" + 1)) - (unsigned int )((void const   *)"-broken-server") == 1U)) {
                  goto _L___23;
                } else {
#line 508
                  if (__s1_len___10 >= 4U) {
                    _L___23: /* CIL Label */
#line 508
                    if (! ((unsigned int )((void const   *)((*(argv + i)) + 1)) - (unsigned int )((void const   *)(*(argv + i))) == 1U)) {
#line 508
                      tmp___118 = 1;
                    } else {
#line 508
                      if (__s2_len___10 >= 4U) {
#line 508
                        tmp___118 = 1;
                      } else {
#line 508
                        tmp___118 = 0;
                      }
                    }
                  } else {
#line 508
                    tmp___118 = 0;
                  }
                }
#line 508
                if (tmp___118) {
#line 508
                  tmp___114 = __builtin_strcmp("-broken-server", (char const   *)(*(argv + i)));
                } else {
#line 508
                  tmp___117 = __builtin_strcmp("-broken-server", (char const   *)(*(argv + i)));
#line 508
                  tmp___114 = tmp___117;
                }
              } else {
#line 508
                tmp___117 = __builtin_strcmp("-broken-server", (char const   *)(*(argv + i)));
#line 508
                tmp___114 = tmp___117;
              }
#line 509
              if (tmp___114 == 0) {
#line 510
                broken_server = 1;
              } else {
#line 509
                if (0) {
#line 509
                  __s1_len___11 = strlen("-broken_server");
#line 509
                  __s2_len___11 = strlen((char const   *)(*(argv + i)));
#line 509
                  if (! ((unsigned int )((void const   *)("-broken_server" + 1)) - (unsigned int )((void const   *)"-broken_server") == 1U)) {
                    goto _L___25;
                  } else {
#line 509
                    if (__s1_len___11 >= 4U) {
                      _L___25: /* CIL Label */
#line 509
                      if (! ((unsigned int )((void const   *)((*(argv + i)) + 1)) - (unsigned int )((void const   *)(*(argv + i))) == 1U)) {
#line 509
                        tmp___128 = 1;
                      } else {
#line 509
                        if (__s2_len___11 >= 4U) {
#line 509
                          tmp___128 = 1;
                        } else {
#line 509
                          tmp___128 = 0;
                        }
                      }
                    } else {
#line 509
                      tmp___128 = 0;
                    }
                  }
#line 509
                  if (tmp___128) {
#line 509
                    tmp___124 = __builtin_strcmp("-broken_server", (char const   *)(*(argv + i)));
                  } else {
#line 509
                    tmp___127 = __builtin_strcmp("-broken_server", (char const   *)(*(argv + i)));
#line 509
                    tmp___124 = tmp___127;
                  }
                } else {
#line 509
                  tmp___127 = __builtin_strcmp("-broken_server", (char const   *)(*(argv + i)));
#line 509
                  tmp___124 = tmp___127;
                }
#line 509
                if (tmp___124 == 0) {
#line 510
                  broken_server = 1;
                } else {
#line 511
                  if (0) {
#line 511
                    __s1_len___8 = strlen("-no-ping");
#line 511
                    __s2_len___8 = strlen((char const   *)(*(argv + i)));
#line 511
                    if (! ((unsigned int )((void const   *)("-no-ping" + 1)) - (unsigned int )((void const   *)"-no-ping") == 1U)) {
                      goto _L___19;
                    } else {
#line 511
                      if (__s1_len___8 >= 4U) {
                        _L___19: /* CIL Label */
#line 511
                        if (! ((unsigned int )((void const   *)((*(argv + i)) + 1)) - (unsigned int )((void const   *)(*(argv + i))) == 1U)) {
#line 511
                          tmp___98 = 1;
                        } else {
#line 511
                          if (__s2_len___8 >= 4U) {
#line 511
                            tmp___98 = 1;
                          } else {
#line 511
                            tmp___98 = 0;
                          }
                        }
                      } else {
#line 511
                        tmp___98 = 0;
                      }
                    }
#line 511
                    if (tmp___98) {
#line 511
                      tmp___94 = __builtin_strcmp("-no-ping", (char const   *)(*(argv + i)));
                    } else {
#line 511
                      tmp___97 = __builtin_strcmp("-no-ping", (char const   *)(*(argv + i)));
#line 511
                      tmp___94 = tmp___97;
                    }
                  } else {
#line 511
                    tmp___97 = __builtin_strcmp("-no-ping", (char const   *)(*(argv + i)));
#line 511
                    tmp___94 = tmp___97;
                  }
#line 512
                  if (tmp___94 == 0) {
#line 513
                    ping_interval = 0;
                  } else {
#line 512
                    if (0) {
#line 512
                      __s1_len___9 = strlen("-no_ping");
#line 512
                      __s2_len___9 = strlen((char const   *)(*(argv + i)));
#line 512
                      if (! ((unsigned int )((void const   *)("-no_ping" + 1)) - (unsigned int )((void const   *)"-no_ping") == 1U)) {
                        goto _L___21;
                      } else {
#line 512
                        if (__s1_len___9 >= 4U) {
                          _L___21: /* CIL Label */
#line 512
                          if (! ((unsigned int )((void const   *)((*(argv + i)) + 1)) - (unsigned int )((void const   *)(*(argv + i))) == 1U)) {
#line 512
                            tmp___108 = 1;
                          } else {
#line 512
                            if (__s2_len___9 >= 4U) {
#line 512
                              tmp___108 = 1;
                            } else {
#line 512
                              tmp___108 = 0;
                            }
                          }
                        } else {
#line 512
                          tmp___108 = 0;
                        }
                      }
#line 512
                      if (tmp___108) {
#line 512
                        tmp___104 = __builtin_strcmp("-no_ping", (char const   *)(*(argv + i)));
                      } else {
#line 512
                        tmp___107 = __builtin_strcmp("-no_ping", (char const   *)(*(argv + i)));
#line 512
                        tmp___104 = tmp___107;
                      }
                    } else {
#line 512
                      tmp___107 = __builtin_strcmp("-no_ping", (char const   *)(*(argv + i)));
#line 512
                      tmp___104 = tmp___107;
                    }
#line 512
                    if (tmp___104 == 0) {
#line 513
                      ping_interval = 0;
                    } else {
#line 514
                      if (0) {
#line 514
                        __s1_len___7 = strlen("-broadcast");
#line 514
                        __s2_len___7 = strlen((char const   *)(*(argv + i)));
#line 514
                        if (! ((unsigned int )((void const   *)("-broadcast" + 1)) - (unsigned int )((void const   *)"-broadcast") == 1U)) {
                          goto _L___17;
                        } else {
#line 514
                          if (__s1_len___7 >= 4U) {
                            _L___17: /* CIL Label */
#line 514
                            if (! ((unsigned int )((void const   *)((*(argv + i)) + 1)) - (unsigned int )((void const   *)(*(argv + i))) == 1U)) {
#line 514
                              tmp___88 = 1;
                            } else {
#line 514
                              if (__s2_len___7 >= 4U) {
#line 514
                                tmp___88 = 1;
                              } else {
#line 514
                                tmp___88 = 0;
                              }
                            }
                          } else {
#line 514
                            tmp___88 = 0;
                          }
                        }
#line 514
                        if (tmp___88) {
#line 514
                          tmp___84 = __builtin_strcmp("-broadcast", (char const   *)(*(argv + i)));
                        } else {
#line 514
                          tmp___87 = __builtin_strcmp("-broadcast", (char const   *)(*(argv + i)));
#line 514
                          tmp___84 = tmp___87;
                        }
                      } else {
#line 514
                        tmp___87 = __builtin_strcmp("-broadcast", (char const   *)(*(argv + i)));
#line 514
                        tmp___84 = tmp___87;
                      }
#line 514
                      if (tmp___84 == 0) {
#line 515
                        use_broadcast = 1;
                      } else {
#line 516
                        if (0) {
#line 516
                          __s1_len___5 = strlen("-local-only");
#line 516
                          __s2_len___5 = strlen((char const   *)(*(argv + i)));
#line 516
                          if (! ((unsigned int )((void const   *)("-local-only" + 1)) - (unsigned int )((void const   *)"-local-only") == 1U)) {
                            goto _L___13;
                          } else {
#line 516
                            if (__s1_len___5 >= 4U) {
                              _L___13: /* CIL Label */
#line 516
                              if (! ((unsigned int )((void const   *)((*(argv + i)) + 1)) - (unsigned int )((void const   *)(*(argv + i))) == 1U)) {
#line 516
                                tmp___68 = 1;
                              } else {
#line 516
                                if (__s2_len___5 >= 4U) {
#line 516
                                  tmp___68 = 1;
                                } else {
#line 516
                                  tmp___68 = 0;
                                }
                              }
                            } else {
#line 516
                              tmp___68 = 0;
                            }
                          }
#line 516
                          if (tmp___68) {
#line 516
                            tmp___64 = __builtin_strcmp("-local-only", (char const   *)(*(argv + i)));
                          } else {
#line 516
                            tmp___67 = __builtin_strcmp("-local-only", (char const   *)(*(argv + i)));
#line 516
                            tmp___64 = tmp___67;
                          }
                        } else {
#line 516
                          tmp___67 = __builtin_strcmp("-local-only", (char const   *)(*(argv + i)));
#line 516
                          tmp___64 = tmp___67;
                        }
#line 517
                        if (tmp___64 == 0) {
#line 518
                          local_only = 1;
                        } else {
#line 517
                          if (0) {
#line 517
                            __s1_len___6 = strlen("-local_only");
#line 517
                            __s2_len___6 = strlen((char const   *)(*(argv + i)));
#line 517
                            if (! ((unsigned int )((void const   *)("-local_only" + 1)) - (unsigned int )((void const   *)"-local_only") == 1U)) {
                              goto _L___15;
                            } else {
#line 517
                              if (__s1_len___6 >= 4U) {
                                _L___15: /* CIL Label */
#line 517
                                if (! ((unsigned int )((void const   *)((*(argv + i)) + 1)) - (unsigned int )((void const   *)(*(argv + i))) == 1U)) {
#line 517
                                  tmp___78 = 1;
                                } else {
#line 517
                                  if (__s2_len___6 >= 4U) {
#line 517
                                    tmp___78 = 1;
                                  } else {
#line 517
                                    tmp___78 = 0;
                                  }
                                }
                              } else {
#line 517
                                tmp___78 = 0;
                              }
                            }
#line 517
                            if (tmp___78) {
#line 517
                              tmp___74 = __builtin_strcmp("-local_only", (char const   *)(*(argv + i)));
                            } else {
#line 517
                              tmp___77 = __builtin_strcmp("-local_only", (char const   *)(*(argv + i)));
#line 517
                              tmp___74 = tmp___77;
                            }
                          } else {
#line 517
                            tmp___77 = __builtin_strcmp("-local_only", (char const   *)(*(argv + i)));
#line 517
                            tmp___74 = tmp___77;
                          }
#line 517
                          if (tmp___74 == 0) {
#line 518
                            local_only = 1;
                          } else {
#line 519
                            if (0) {
#line 519
                              __s1_len___4 = strlen("-f");
#line 519
                              __s2_len___4 = strlen((char const   *)(*(argv + i)));
#line 519
                              if (! ((unsigned int )((void const   *)("-f" + 1)) - (unsigned int )((void const   *)"-f") == 1U)) {
                                goto _L___11;
                              } else {
#line 519
                                if (__s1_len___4 >= 4U) {
                                  _L___11: /* CIL Label */
#line 519
                                  if (! ((unsigned int )((void const   *)((*(argv + i)) + 1)) - (unsigned int )((void const   *)(*(argv + i))) == 1U)) {
#line 519
                                    tmp___58 = 1;
                                  } else {
#line 519
                                    if (__s2_len___4 >= 4U) {
#line 519
                                      tmp___58 = 1;
                                    } else {
#line 519
                                      tmp___58 = 0;
                                    }
                                  }
                                } else {
#line 519
                                  tmp___58 = 0;
                                }
                              }
#line 519
                              if (tmp___58) {
#line 519
                                tmp___54 = __builtin_strcmp("-f", (char const   *)(*(argv + i)));
                              } else {
#line 519
                                tmp___57 = __builtin_strcmp("-f", (char const   *)(*(argv + i)));
#line 519
                                tmp___54 = tmp___57;
                              }
                            } else {
#line 519
                              tmp___57 = __builtin_strcmp("-f", (char const   *)(*(argv + i)));
#line 519
                              tmp___54 = tmp___57;
                            }
#line 519
                            if (tmp___54 == 0) {
#line 521
                              if (i + 1 == argc) {
#line 522
                                usage();
                              } else {
#line 521
                                if ((int )(*((*(argv + (i + 1))) + 0)) == 45) {
#line 522
                                  usage();
                                }
                              }
#line 523
                              i ++;
#line 524
                              configfile = (char const   *)(*(argv + i));
                            } else {
#line 526
                              if (0) {
#line 526
                                __s1_len___3 = strlen("-p");
#line 526
                                __s2_len___3 = strlen((char const   *)(*(argv + i)));
#line 526
                                if (! ((unsigned int )((void const   *)("-p" + 1)) - (unsigned int )((void const   *)"-p") == 1U)) {
                                  goto _L___9;
                                } else {
#line 526
                                  if (__s1_len___3 >= 4U) {
                                    _L___9: /* CIL Label */
#line 526
                                    if (! ((unsigned int )((void const   *)((*(argv + i)) + 1)) - (unsigned int )((void const   *)(*(argv + i))) == 1U)) {
#line 526
                                      tmp___48 = 1;
                                    } else {
#line 526
                                      if (__s2_len___3 >= 4U) {
#line 526
                                        tmp___48 = 1;
                                      } else {
#line 526
                                        tmp___48 = 0;
                                      }
                                    }
                                  } else {
#line 526
                                    tmp___48 = 0;
                                  }
                                }
#line 526
                                if (tmp___48) {
#line 526
                                  tmp___44 = __builtin_strcmp("-p", (char const   *)(*(argv + i)));
                                } else {
#line 526
                                  tmp___47 = __builtin_strcmp("-p", (char const   *)(*(argv + i)));
#line 526
                                  tmp___44 = tmp___47;
                                }
                              } else {
#line 526
                                tmp___47 = __builtin_strcmp("-p", (char const   *)(*(argv + i)));
#line 526
                                tmp___44 = tmp___47;
                              }
#line 526
                              if (tmp___44 == 0) {
#line 528
                                if (i + 1 == argc) {
#line 529
                                  usage();
                                } else {
#line 528
                                  if ((int )(*((*(argv + (i + 1))) + 0)) == 45) {
#line 529
                                    usage();
                                  }
                                }
#line 530
                                i ++;
#line 531
                                port = atoi__extinline((char const   *)(*(argv + i)));
                              } else {
#line 533
                                if (0) {
#line 533
                                  __s1_len___0 = strlen("-ping-interval");
#line 533
                                  __s2_len___0 = strlen((char const   *)(*(argv + i)));
#line 533
                                  if (! ((unsigned int )((void const   *)("-ping-interval" + 1)) - (unsigned int )((void const   *)"-ping-interval") == 1U)) {
                                    goto _L___2;
                                  } else {
#line 533
                                    if (__s1_len___0 >= 4U) {
                                      _L___2: /* CIL Label */
#line 533
                                      if (! ((unsigned int )((void const   *)((*(argv + i)) + 1)) - (unsigned int )((void const   *)(*(argv + i))) == 1U)) {
#line 533
                                        tmp___18 = 1;
                                      } else {
#line 533
                                        if (__s2_len___0 >= 4U) {
#line 533
                                          tmp___18 = 1;
                                        } else {
#line 533
                                          tmp___18 = 0;
                                        }
                                      }
                                    } else {
#line 533
                                      tmp___18 = 0;
                                    }
                                  }
#line 533
                                  if (tmp___18) {
#line 533
                                    tmp___14 = __builtin_strcmp("-ping-interval",
                                                                (char const   *)(*(argv + i)));
                                  } else {
#line 533
                                    tmp___17 = __builtin_strcmp("-ping-interval",
                                                                (char const   *)(*(argv + i)));
#line 533
                                    tmp___14 = tmp___17;
                                  }
                                } else {
#line 533
                                  tmp___17 = __builtin_strcmp("-ping-interval", (char const   *)(*(argv + i)));
#line 533
                                  tmp___14 = tmp___17;
                                }
#line 535
                                if (tmp___14 == 0) {
                                  goto _L___7;
                                } else {
#line 534
                                  if (0) {
#line 534
                                    __s1_len___1 = strlen("-ping-interval");
#line 534
                                    __s2_len___1 = strlen((char const   *)(*(argv + i)));
#line 534
                                    if (! ((unsigned int )((void const   *)("-ping-interval" + 1)) - (unsigned int )((void const   *)"-ping-interval") == 1U)) {
                                      goto _L___4;
                                    } else {
#line 534
                                      if (__s1_len___1 >= 4U) {
                                        _L___4: /* CIL Label */
#line 534
                                        if (! ((unsigned int )((void const   *)((*(argv + i)) + 1)) - (unsigned int )((void const   *)(*(argv + i))) == 1U)) {
#line 534
                                          tmp___28 = 1;
                                        } else {
#line 534
                                          if (__s2_len___1 >= 4U) {
#line 534
                                            tmp___28 = 1;
                                          } else {
#line 534
                                            tmp___28 = 0;
                                          }
                                        }
                                      } else {
#line 534
                                        tmp___28 = 0;
                                      }
                                    }
#line 534
                                    if (tmp___28) {
#line 534
                                      tmp___24 = __builtin_strcmp("-ping-interval",
                                                                  (char const   *)(*(argv + i)));
                                    } else {
#line 534
                                      tmp___27 = __builtin_strcmp("-ping-interval",
                                                                  (char const   *)(*(argv + i)));
#line 534
                                      tmp___24 = tmp___27;
                                    }
                                  } else {
#line 534
                                    tmp___27 = __builtin_strcmp("-ping-interval",
                                                                (char const   *)(*(argv + i)));
#line 534
                                    tmp___24 = tmp___27;
                                  }
#line 535
                                  if (tmp___24 == 0) {
                                    goto _L___7;
                                  } else {
#line 535
                                    if (0) {
#line 535
                                      __s1_len___2 = strlen("-i");
#line 535
                                      __s2_len___2 = strlen((char const   *)(*(argv + i)));
#line 535
                                      if (! ((unsigned int )((void const   *)("-i" + 1)) - (unsigned int )((void const   *)"-i") == 1U)) {
                                        goto _L___6;
                                      } else {
#line 535
                                        if (__s1_len___2 >= 4U) {
                                          _L___6: /* CIL Label */
#line 535
                                          if (! ((unsigned int )((void const   *)((*(argv + i)) + 1)) - (unsigned int )((void const   *)(*(argv + i))) == 1U)) {
#line 535
                                            tmp___38 = 1;
                                          } else {
#line 535
                                            if (__s2_len___2 >= 4U) {
#line 535
                                              tmp___38 = 1;
                                            } else {
#line 535
                                              tmp___38 = 0;
                                            }
                                          }
                                        } else {
#line 535
                                          tmp___38 = 0;
                                        }
                                      }
#line 535
                                      if (tmp___38) {
#line 535
                                        tmp___34 = __builtin_strcmp("-i", (char const   *)(*(argv + i)));
                                      } else {
#line 535
                                        tmp___37 = __builtin_strcmp("-i", (char const   *)(*(argv + i)));
#line 535
                                        tmp___34 = tmp___37;
                                      }
                                    } else {
#line 535
                                      tmp___37 = __builtin_strcmp("-i", (char const   *)(*(argv + i)));
#line 535
                                      tmp___34 = tmp___37;
                                    }
#line 535
                                    if (tmp___34 == 0) {
                                      _L___7: /* CIL Label */
#line 537
                                      if (i + 1 == argc) {
#line 538
                                        usage();
                                      } else {
#line 537
                                        if ((int )(*((*(argv + (i + 1))) + 0)) == 45) {
#line 538
                                          usage();
                                        }
                                      }
#line 539
                                      i ++;
#line 540
                                      ping_interval = atoi__extinline((char const   *)(*(argv + i)));
                                    } else {
#line 542
                                      if (0) {
#line 542
                                        __s1_len = strlen("-c");
#line 542
                                        __s2_len = strlen((char const   *)(*(argv + i)));
#line 542
                                        if (! ((unsigned int )((void const   *)("-c" + 1)) - (unsigned int )((void const   *)"-c") == 1U)) {
                                          goto _L___0;
                                        } else {
#line 542
                                          if (__s1_len >= 4U) {
                                            _L___0: /* CIL Label */
#line 542
                                            if (! ((unsigned int )((void const   *)((*(argv + i)) + 1)) - (unsigned int )((void const   *)(*(argv + i))) == 1U)) {
#line 542
                                              tmp___8 = 1;
                                            } else {
#line 542
                                              if (__s2_len >= 4U) {
#line 542
                                                tmp___8 = 1;
                                              } else {
#line 542
                                                tmp___8 = 0;
                                              }
                                            }
                                          } else {
#line 542
                                            tmp___8 = 0;
                                          }
                                        }
#line 542
                                        if (tmp___8) {
#line 542
                                          tmp___4 = __builtin_strcmp("-c", (char const   *)(*(argv + i)));
                                        } else {
#line 542
                                          tmp___7 = __builtin_strcmp("-c", (char const   *)(*(argv + i)));
#line 542
                                          tmp___4 = tmp___7;
                                        }
                                      } else {
#line 542
                                        tmp___7 = __builtin_strcmp("-c", (char const   *)(*(argv + i)));
#line 542
                                        tmp___4 = tmp___7;
                                      }
#line 542
                                      if (tmp___4 == 0) {
#line 543
                                        configcheck_only = 1;
                                      } else {
#line 545
                                        usage();
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 494
    i ++;
  }
#line 548
  tmp___181 = yp_get_default_domain(& domain);
#line 549
  if (tmp___181) {
    goto _L___38;
  } else {
#line 549
    if ((unsigned int )domain == (unsigned int )((void *)0)) {
      goto _L___38;
    } else {
#line 549
      if ((int )(*(domain + 0)) == 0) {
        goto _L___38;
      } else {
#line 549
        if (0) {
#line 549
          __s1_len___17 = strlen((char const   *)domain);
#line 549
          __s2_len___17 = strlen("(none)");
#line 549
          if (! ((unsigned int )((void const   *)(domain + 1)) - (unsigned int )((void const   *)domain) == 1U)) {
            goto _L___37;
          } else {
#line 549
            if (__s1_len___17 >= 4U) {
              _L___37: /* CIL Label */
#line 549
              if (! ((unsigned int )((void const   *)("(none)" + 1)) - (unsigned int )((void const   *)"(none)") == 1U)) {
#line 549
                tmp___191 = 1;
              } else {
#line 549
                if (__s2_len___17 >= 4U) {
#line 549
                  tmp___191 = 1;
                } else {
#line 549
                  tmp___191 = 0;
                }
              }
            } else {
#line 549
              tmp___191 = 0;
            }
          }
#line 549
          if (tmp___191) {
#line 549
            tmp___187 = __builtin_strcmp((char const   *)domain, "(none)");
          } else {
#line 549
            tmp___190 = __builtin_strcmp((char const   *)domain, "(none)");
#line 549
            tmp___187 = tmp___190;
          }
        } else {
#line 549
          tmp___190 = __builtin_strcmp((char const   *)domain, "(none)");
#line 549
          tmp___187 = tmp___190;
        }
#line 549
        if (tmp___187 == 0) {
          _L___38: /* CIL Label */
#line 551
          if (configcheck_only) {
#line 553
            tmp___179 = dcgettext((char const   *)((void *)0), "ERROR: domainname not set.\n",
                                  5);
#line 553
            fputs((char const   * __restrict  )tmp___179, (FILE * __restrict  )stderr);
#line 554
            domain = (char *)"(none)";
          } else {
#line 558
            tmp___180 = dcgettext((char const   *)((void *)0), "domainname not set - aborting.\n",
                                  5);
#line 558
            fputs((char const   * __restrict  )tmp___180, (FILE * __restrict  )stderr);
#line 559
            exit(1);
          }
        }
      }
    }
  }
#line 563
  if (configcheck_only) {
#line 565
    tmp___194 = load_config(1);
#line 565
    if (tmp___194 != 0) {
#line 567
      tmp___192 = dcgettext((char const   *)((void *)0), "Config file %s is not ok.\n",
                            5);
#line 567
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___192,
              configfile);
#line 568
      exit(1);
    } else {
#line 572
      tmp___193 = dcgettext((char const   *)((void *)0), "Config file %s is ok.\n",
                            5);
#line 572
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )tmp___193,
              configfile);
#line 573
      exit(0);
    }
  }
#line 577
  tmp___196 = getuid();
#line 577
  if (tmp___196 != 0U) {
#line 579
    tmp___195 = dcgettext((char const   *)((void *)0), "ypbind must be run as root\n",
                          5);
#line 579
    fputs((char const   * __restrict  )tmp___195, (FILE * __restrict  )stderr);
#line 580
    exit(1);
  }
#line 583
  tmp___201 = stat__extinline("/var/yp", & st);
#line 583
  if (tmp___201 == -1) {
#line 584
    tmp___200 = mkdir("/var/yp", 493U);
#line 584
    if (tmp___200 < 0) {
#line 587
      tmp___197 = __errno_location();
#line 587
      tmp___198 = strerror((*tmp___197));
#line 587
      tmp___199 = dcgettext((char const   *)((void *)0), "Could not create %s: %s\n",
                            5);
#line 587
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___199,
              "/var/yp", tmp___198);
#line 589
      exit(1);
    }
  }
#line 592
  tmp___206 = stat__extinline("/var/yp/binding", & st);
#line 592
  if (tmp___206 == -1) {
#line 593
    tmp___205 = mkdir("/var/yp/binding", 493U);
#line 593
    if (tmp___205 < 0) {
#line 596
      tmp___202 = __errno_location();
#line 596
      tmp___203 = strerror((*tmp___202));
#line 596
      tmp___204 = dcgettext((char const   *)((void *)0), "Could not create %s: %s\n",
                            5);
#line 596
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___204,
              "/var/yp/binding", tmp___203);
#line 598
      exit(1);
    }
  }
#line 601
  tmp___210 = chdir("/var/yp/binding");
#line 601
  if (tmp___210 < 0) {
#line 603
    tmp___207 = __errno_location();
#line 603
    tmp___208 = strerror((*tmp___207));
#line 603
    tmp___209 = dcgettext((char const   *)((void *)0), "Could not change to directory %s: %s\n",
                          5);
#line 603
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___209, "/var/yp/binding",
            tmp___208);
#line 605
    exit(1);
  }
#line 608
  if (! use_broadcast) {
#line 610
    tmp___214 = load_config(0);
#line 610
    if (tmp___214 != 0) {
#line 612
      tmp___211 = dcgettext((char const   *)((void *)0), "No NIS server and no -broadcast option specified.\n",
                            5);
#line 612
      fputs((char const   * __restrict  )tmp___211, (FILE * __restrict  )stderr);
#line 613
      tmp___212 = dcgettext((char const   *)((void *)0), "Add a NIS server to the %s configuration file,\n",
                            5);
#line 613
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___212,
              configfile);
#line 616
      tmp___213 = dcgettext((char const   *)((void *)0), "or start ypbind with the -broadcast option.\n",
                            5);
#line 616
      fputs((char const   * __restrict  )tmp___213, (FILE * __restrict  )stderr);
#line 617
      exit(1);
    }
  } else {
#line 621
    add_server((char const   *)domain, (char const   *)((void *)0), 0);
  }
#line 623
  unlink_bindingdir();
#line 625
  openlog("ypbind", 1, 24);
#line 627
  if (debug_flag) {
#line 629
    log_msg(7, "[Welcome to ypbind-mt, version %s]\n", "1.19.1");
#line 630
    log_msg(7, "ping interval is %d seconds\n", ping_interval);
  } else {
#line 636
    j = fork();
#line 636
    if (j > 0) {
#line 637
      exit(0);
    }
#line 639
    if (j < 0) {
#line 641
      tmp___215 = __errno_location();
#line 641
      tmp___216 = strerror((*tmp___215));
#line 641
      log_msg(3, "Cannot fork: %s\n", tmp___216);
#line 642
      exit(-1);
    }
#line 645
    tmp___219 = setsid();
#line 645
    if (tmp___219 == -1) {
#line 647
      tmp___217 = __errno_location();
#line 647
      tmp___218 = strerror((*tmp___217));
#line 647
      log_msg(3, "Cannot setsid: %s\n", tmp___218);
#line 648
      exit(-1);
    }
#line 651
    j = fork();
#line 651
    if (j > 0) {
#line 652
      exit(0);
    }
#line 654
    if (j < 0) {
#line 656
      tmp___220 = __errno_location();
#line 656
      tmp___221 = strerror((*tmp___220));
#line 656
      log_msg(3, "Cannot fork: %s\n", tmp___221);
#line 657
      exit(-1);
    }
#line 660
    j = 0;
#line 660
    while (1) {
#line 660
      tmp___222 = getdtablesize();
#line 660
      if (! (j < tmp___222)) {
#line 660
        break;
      }
#line 661
      close(j);
#line 660
      j ++;
    }
#line 662
    tmp___223 = __errno_location();
#line 662
    (*tmp___223) = 0;
#line 664
    umask(0U);
#line 665
    j = open("/dev/null", 2);
#line 666
    dup(j);
#line 667
    dup(j);
  }
#line 672
  __nss_configure_lookup("hosts", "files dns");
#line 675
  sigemptyset(& sigs_to_block);
#line 676
  sigaddset(& sigs_to_block, 17);
#line 677
  sigaddset(& sigs_to_block, 15);
#line 678
  sigaddset(& sigs_to_block, 2);
#line 679
  sigaddset(& sigs_to_block, 3);
#line 680
  sigaddset(& sigs_to_block, 11);
#line 681
  sigaddset(& sigs_to_block, 1);
#line 682
  tmp___225 = pthread_sigmask(0, (__sigset_t const   * __restrict  )(& sigs_to_block),
                              (__sigset_t * __restrict  )((void *)0));
#line 682
  if (tmp___225 != 0) {
#line 684
    tmp___224 = dcgettext((char const   *)((void *)0), "Could not block signals.",
                          5);
#line 684
    log_msg(3, (char const   *)tmp___224);
#line 685
    exit(1);
  }
#line 688
  pthread_create((pthread_t * __restrict  )(& sig_thread), (pthread_attr_t const   * __restrict  )((void *)0),
                 & sig_handler, (void * __restrict  )((void *)0));
#line 691
  pthread_mutex_lock(& mutex_pid);
#line 692
  while (pid_is_written < 1) {
#line 694
    pthread_cond_wait((pthread_cond_t * __restrict  )(& cond_pid), (pthread_mutex_t * __restrict  )(& mutex_pid));
  }
#line 696
  pthread_mutex_unlock(& mutex_pid);
#line 698
  pmap_unset(100007UL, 1UL);
#line 699
  pmap_unset(100007UL, 2UL);
#line 701
  if (port >= 0) {
    goto _L___39;
  } else {
#line 701
    if (local_only) {
      _L___39: /* CIL Label */
#line 703
      sock = socket(2, 2, 0);
#line 704
      if (sock < 0) {
#line 706
        tmp___226 = __errno_location();
#line 706
        tmp___227 = strerror((*tmp___226));
#line 706
        tmp___228 = dcgettext((char const   *)((void *)0), "Cannot create UDP: %s",
                              5);
#line 706
        log_msg(3, (char const   *)tmp___228, tmp___227);
#line 707
        exit(1);
      }
#line 710
      memset((void *)((char *)(& socket_address)), 0, sizeof(socket_address));
#line 711
      socket_address.sin_family = (unsigned short)2;
#line 712
      if (local_only) {
#line 713
        __x = 2130706433U;
#line 713
        __asm__  ("bswap %0": "=r" (__v): "0" (__x));
#line 713
        socket_address.sin_addr.s_addr = __v;
      } else {
#line 715
        __x___0 = 0U;
#line 715
        __asm__  ("bswap %0": "=r" (__v___0): "0" (__x___0));
#line 715
        socket_address.sin_addr.s_addr = __v___0;
      }
#line 717
      if (port >= 0) {
#line 718
        __x___1 = (unsigned short )port;
#line 718
        __asm__  ("rorw $8, %w0": "=r" (__v___1): "0" (__x___1): "cc");
#line 718
        socket_address.sin_port = __v___1;
      }
#line 720
      result = bind(sock, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& socket_address)),
                    sizeof(socket_address));
#line 722
      if (result < 0) {
#line 724
        tmp___229 = __errno_location();
#line 724
        tmp___230 = strerror((*tmp___229));
#line 724
        tmp___231 = dcgettext((char const   *)((void *)0), "Cannot bind UDP: %s",
                              5);
#line 724
        log_msg(3, (char const   *)tmp___231, tmp___230);
#line 725
        exit(1);
      }
    } else {
#line 729
      sock = -1;
    }
  }
#line 731
  transp = svcudp_create(sock);
#line 732
  if ((unsigned int )transp == (unsigned int )((void *)0)) {
#line 734
    tmp___232 = dcgettext((char const   *)((void *)0), "Cannot create udp service.",
                          5);
#line 734
    log_msg(3, (char const   *)tmp___232);
#line 735
    exit(1);
  }
#line 738
  tmp___234 = svc_register(transp, 100007UL, 2UL, & ypbindprog_2, 17UL);
#line 738
  if (! tmp___234) {
#line 741
    tmp___233 = dcgettext((char const   *)((void *)0), "Unable to register (YPBINDPROG, YPBINDVERS, udp).",
                          5);
#line 741
    log_msg(3, (char const   *)tmp___233);
#line 743
    exit(1);
  }
#line 746
  tmp___236 = svc_register(transp, 100007UL, 1UL, & ypbindprog_1, 17UL);
#line 746
  if (! tmp___236) {
#line 749
    tmp___235 = dcgettext((char const   *)((void *)0), "Unable to register (YPBINDPROG, YPBINDOLDVERS, udp).",
                          5);
#line 749
    log_msg(3, (char const   *)tmp___235);
#line 751
    exit(1);
  }
#line 754
  if (port >= 0) {
    goto _L___40;
  } else {
#line 754
    if (local_only) {
      _L___40: /* CIL Label */
#line 756
      sock = socket(2, 1, 0);
#line 757
      if (sock < 0) {
#line 759
        tmp___237 = __errno_location();
#line 759
        tmp___238 = strerror((*tmp___237));
#line 759
        tmp___239 = dcgettext((char const   *)((void *)0), "Cannot create TCP: %s",
                              5);
#line 759
        log_msg(3, (char const   *)tmp___239, tmp___238);
#line 760
        exit(1);
      }
#line 763
      memset((void *)(& socket_address), 0, sizeof(socket_address));
#line 764
      socket_address.sin_family = (unsigned short)2;
#line 765
      if (local_only) {
#line 766
        __x___2 = 2130706433U;
#line 766
        __asm__  ("bswap %0": "=r" (__v___2): "0" (__x___2));
#line 766
        socket_address.sin_addr.s_addr = __v___2;
      } else {
#line 768
        __x___3 = 0U;
#line 768
        __asm__  ("bswap %0": "=r" (__v___3): "0" (__x___3));
#line 768
        socket_address.sin_addr.s_addr = __v___3;
      }
#line 770
      if (port >= 0) {
#line 771
        __x___4 = (unsigned short )port;
#line 771
        __asm__  ("rorw $8, %w0": "=r" (__v___4): "0" (__x___4): "cc");
#line 771
        socket_address.sin_port = __v___4;
      }
#line 773
      result = bind(sock, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& socket_address)),
                    sizeof(socket_address));
#line 775
      if (result < 0) {
#line 777
        tmp___240 = __errno_location();
#line 777
        tmp___241 = strerror((*tmp___240));
#line 777
        tmp___242 = dcgettext((char const   *)((void *)0), "Cannot bind TCP: %s",
                              5);
#line 777
        log_msg(3, (char const   *)tmp___242, tmp___241);
#line 778
        exit(1);
      }
    } else {
#line 782
      sock = -1;
    }
  }
#line 784
  transp = svctcp_create(sock, 0U, 0U);
#line 785
  if ((unsigned int )transp == (unsigned int )((void *)0)) {
#line 787
    tmp___243 = dcgettext((char const   *)((void *)0), "Cannot create tcp service.\n",
                          5);
#line 787
    log_msg(3, (char const   *)tmp___243);
#line 788
    exit(1);
  }
#line 791
  tmp___245 = svc_register(transp, 100007UL, 2UL, & ypbindprog_2, 6UL);
#line 791
  if (! tmp___245) {
#line 794
    tmp___244 = dcgettext((char const   *)((void *)0), "Unable to register (YPBINDPROG, YPBINDVERS, tcp).",
                          5);
#line 794
    log_msg(3, (char const   *)tmp___244);
#line 795
    exit(1);
  }
#line 798
  tmp___247 = svc_register(transp, 100007UL, 1UL, & ypbindprog_1, 6UL);
#line 798
  if (! tmp___247) {
#line 801
    tmp___246 = dcgettext((char const   *)((void *)0), "Unable to register (YPBINDPROG, YPBINDOLDVERS, tcp).",
                          5);
#line 801
    log_msg(3, (char const   *)tmp___246);
#line 803
    exit(1);
  }
#line 806
  pthread_create((pthread_t * __restrict  )(& ping_thread), (pthread_attr_t const   * __restrict  )((void *)0),
                 & test_bindings, (void * __restrict  )((void *)0));
#line 808
  svc_run();
#line 809
  tmp___248 = dcgettext((char const   *)((void *)0), "svc_run returned.", 5);
#line 809
  log_msg(3, (char const   *)tmp___248);
#line 810
  unlink("/var/run/ypbind.pid");
#line 811
  exit(1);
}
}
#line 1 "ypbind_xdr.o"
#pragma merger(0,"/tmp/cil-qTzP9RAw.i","-Wall,-g,-O2")
#line 291 "/usr/include/rpc/xdr.h"
extern  __attribute__((__nothrow__)) bool_t xdr_u_int(XDR *__xdrs , u_int *__up ) ;
#line 309
extern  __attribute__((__nothrow__)) bool_t xdr_enum(XDR *__xdrs , enum_t *__ep ) ;
#line 315
extern  __attribute__((__nothrow__)) bool_t xdr_opaque(XDR *__xdrs , caddr_t __cp ,
                                                       u_int __cnt ) ;
#line 316
extern  __attribute__((__nothrow__)) bool_t xdr_string(XDR *__xdrs , char **__cpp ,
                                                       u_int __maxsize ) ;
#line 320
extern  __attribute__((__nothrow__)) bool_t xdr_char(XDR *__xdrs , char *__cp ) ;
#line 322
extern  __attribute__((__nothrow__)) bool_t xdr_vector(XDR *__xdrs , char *__basep ,
                                                       u_int __nelem , u_int __elemsize ,
                                                       bool_t (*__xdr_elem)(XDR * ,
                                                                            void *
                                                                            , ...) ) ;
#line 118 "ypbind.h"
bool_t ypbind_xdr_domainname(XDR *xdrs , domainname *objp ) ;
#line 119
bool_t ypbind_xdr_resptype(XDR *xdrs , ypbind_resptype *objp ) ;
#line 120
bool_t ypbind_xdr_binding(XDR *xdrs , ypbind_binding *objp ) ;
#line 121
bool_t ypbind_xdr_resp(XDR *xdrs , ypbind_resp *objp ) ;
#line 122
bool_t ypbind_xdr_oldsetdom(XDR *xdrs , ypbind_oldsetdom *objp ) ;
#line 123
bool_t ypbind_xdr_setdom(XDR *xdrs , ypbind_setdom *objp ) ;
#line 4 "ypbind_xdr.c"
bool_t ypbind_xdr_domainname(XDR *xdrs , domainname *objp )
{ bool_t tmp ;

  {
#line 7
  tmp = xdr_string(xdrs, objp, 256U);
#line 7
  if (! tmp) {
#line 8
    return (0);
  }
#line 9
  return (1);
}
}
#line 12 "ypbind_xdr.c"
bool_t ypbind_xdr_resptype(XDR *xdrs , ypbind_resptype *objp )
{ bool_t tmp ;

  {
#line 15
  tmp = xdr_enum(xdrs, (enum_t *)objp);
#line 15
  if (! tmp) {
#line 16
    return (0);
  }
#line 17
  return (1);
}
}
#line 20 "ypbind_xdr.c"
bool_t ypbind_xdr_binding(XDR *xdrs , ypbind_binding *objp )
{ bool_t tmp ;
  bool_t tmp___0 ;

  {
#line 23
  tmp = xdr_opaque(xdrs, objp->ypbind_binding_addr, 4U);
#line 23
  if (! tmp) {
#line 24
    return (0);
  }
#line 25
  tmp___0 = xdr_opaque(xdrs, objp->ypbind_binding_port, 2U);
#line 25
  if (! tmp___0) {
#line 26
    return (0);
  }
#line 27
  return (1);
}
}
#line 30 "ypbind_xdr.c"
bool_t ypbind_xdr_resp(XDR *xdrs , ypbind_resp *objp )
{ bool_t tmp ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;

  {
#line 33
  tmp = ypbind_xdr_resptype(xdrs, & objp->ypbind_status);
#line 33
  if (! tmp) {
#line 34
    return (0);
  }
#line 35
  switch ((int )objp->ypbind_status) {
  case 2:
#line 38
  tmp___0 = xdr_u_int(xdrs, & objp->ypbind_resp_u.ypbind_error);
#line 38
  if (! tmp___0) {
#line 39
    return (0);
  }
#line 40
  break;
  case 1:
#line 42
  tmp___1 = ypbind_xdr_binding(xdrs, & objp->ypbind_resp_u.ypbind_bindinfo);
#line 42
  if (! tmp___1) {
#line 43
    return (0);
  }
#line 44
  break;
  default: ;
#line 46
  return (0);
  }
#line 48
  return (1);
}
}
#line 51 "ypbind_xdr.c"
bool_t ypbind_xdr_oldsetdom(XDR *xdrs , ypbind_oldsetdom *objp )
{ bool_t tmp ;
  bool_t tmp___0 ;

  {
#line 54
  tmp = xdr_vector(xdrs, objp->ypoldsetdom_domain, 256U, sizeof(char ), (bool_t (*)(XDR * ,
                                                                                    void *
                                                                                    , ...))(& xdr_char));
#line 54
  if (! tmp) {
#line 56
    return (0);
  }
#line 57
  tmp___0 = ypbind_xdr_binding(xdrs, & objp->ypoldsetdom_binding);
#line 57
  if (! tmp___0) {
#line 58
    return (0);
  }
#line 59
  return (1);
}
}
#line 62 "ypbind_xdr.c"
bool_t ypbind_xdr_setdom(XDR *xdrs , ypbind_setdom *objp )
{ bool_t tmp ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;

  {
#line 65
  tmp = ypbind_xdr_domainname(xdrs, & objp->ypsetdom_domain);
#line 65
  if (! tmp) {
#line 66
    return (0);
  }
#line 67
  tmp___0 = ypbind_xdr_binding(xdrs, & objp->ypsetdom_binding);
#line 67
  if (! tmp___0) {
#line 68
    return (0);
  }
#line 69
  tmp___1 = xdr_u_int(xdrs, & objp->ypsetdom_vers);
#line 69
  if (! tmp___1) {
#line 70
    return (0);
  }
#line 71
  return (1);
}
}
#line 1 "ypbind_svc.o"
#pragma merger(0,"/tmp/cil-c4GTiXrf.i","-Wall,-g,-O2")
#line 287 "/usr/include/rpc/xdr.h"
extern  __attribute__((__nothrow__)) bool_t xdr_void(void) ;
#line 229 "/usr/include/rpc/svc.h"
extern  __attribute__((__nothrow__)) bool_t svc_sendreply(SVCXPRT *xprt , bool_t (*__xdr_results)(XDR * ,
                                                                                                  void *
                                                                                                  , ...) ,
                                                          caddr_t __xdr_location ) ;
#line 232
extern  __attribute__((__nothrow__)) void svcerr_decode(SVCXPRT *__xprt ) ;
#line 236
extern  __attribute__((__nothrow__)) void svcerr_noproc(SVCXPRT *__xprt ) ;
#line 245
extern  __attribute__((__nothrow__)) void svcerr_systemerr(SVCXPRT *__xprt ) ;
#line 100 "ypbind.h"
bool_t ypbindproc_oldnull_1_svc(void *argp  __attribute__((__unused__)) , void *result ,
                                struct svc_req *rqstp  __attribute__((__unused__)) ) ;
#line 102
bool_t ypbindproc_olddomain_1_svc(domainname *argp , ypbind_resp *result , struct svc_req *rqstp ) ;
#line 104
bool_t ypbindproc_oldsetdom_1_svc(ypbind_oldsetdom *argp , void *result , struct svc_req *rqstp ) ;
#line 105
int ypbindprog_1_freeresult(SVCXPRT *transp  __attribute__((__unused__)) , bool_t (*xdr_result)(XDR * ,
                                                                                                void *
                                                                                                , ...) ,
                            caddr_t result ) ;
#line 109
bool_t ypbindproc_null_2_svc(void *argp  __attribute__((__unused__)) , void *result ,
                             struct svc_req *rqstp  __attribute__((__unused__)) ) ;
#line 111
bool_t ypbindproc_domain_2_svc(domainname *argp , ypbind_resp *result , struct svc_req *rqstp ) ;
#line 113
bool_t ypbindproc_setdom_2_svc(ypbind_setdom *argp , void *result , struct svc_req *rqstp ) ;
#line 114
int ypbindprog_2_freeresult(SVCXPRT *transp  __attribute__((__unused__)) , bool_t (*xdr_result)(XDR * ,
                                                                                                void *
                                                                                                , ...) ,
                            caddr_t result ) ;
#line 23 "ypbind_svc.c"
void ypbindprog_1(struct svc_req *rqstp , SVCXPRT *transp )
{ union __anonunion_argument_57 argument ;
  union __anonunion_result_58 result ;
  bool_t retval ;
  bool_t (*xdr_argument)(XDR * , void *  , ...) ;
  bool_t (*xdr_result)(XDR * , void *  , ...) ;
  bool_t (*local)(char * , void * , struct svc_req * ) ;
  bool_t tmp ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;
  char *tmp___2 ;
  bool_t tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 41
  switch ((int )rqstp->rq_proc) {
  case 0:
#line 44
  xdr_argument = (bool_t (*)(XDR * , void *  , ...))(& xdr_void);
#line 45
  xdr_result = (bool_t (*)(XDR * , void *  , ...))(& xdr_void);
#line 46
  local = (bool_t (*)(char * , void * , struct svc_req * ))(& ypbindproc_oldnull_1_svc);
#line 48
  break;
  case 1:
#line 51
  xdr_argument = (bool_t (*)(XDR * , void *  , ...))(& ypbind_xdr_domainname);
#line 52
  xdr_result = (bool_t (*)(XDR * , void *  , ...))(& ypbind_xdr_resp);
#line 53
  local = (bool_t (*)(char * , void * , struct svc_req * ))(& ypbindproc_olddomain_1_svc);
#line 55
  break;
  case 2:
#line 58
  xdr_argument = (bool_t (*)(XDR * , void *  , ...))(& ypbind_xdr_oldsetdom);
#line 59
  xdr_result = (bool_t (*)(XDR * , void *  , ...))(& xdr_void);
#line 60
  local = (bool_t (*)(char * , void * , struct svc_req * ))(& ypbindproc_oldsetdom_1_svc);
#line 62
  break;
  default:
#line 65
  svcerr_noproc(transp);
#line 66
  return;
  }
#line 68
  memset((void *)((char *)(& argument)), 0, sizeof(argument));
#line 69
  tmp = ((*((transp->xp_ops)->xp_getargs)))(transp, xdr_argument, (char *)(& argument));
#line 69
  if (! tmp) {
#line 71
    svcerr_decode(transp);
#line 72
    return;
  }
#line 74
  tmp___0 = ((*local))((char *)(& argument), (void *)(& result), rqstp);
#line 74
  retval = tmp___0;
#line 75
  if (retval > 0) {
#line 75
    tmp___1 = svc_sendreply(transp, xdr_result, (char *)(& result));
#line 75
    if (! tmp___1) {
#line 77
      svcerr_systemerr(transp);
    }
  }
#line 79
  tmp___3 = ((*((transp->xp_ops)->xp_freeargs)))(transp, xdr_argument, (char *)(& argument));
#line 79
  if (! tmp___3) {
#line 80
    tmp___2 = dcgettext((char const   *)((void *)0), "unable to free arguments", 5);
#line 80
    log_msg(3, (char const   *)tmp___2);
  }
#line 82
  tmp___5 = ypbindprog_1_freeresult(transp, xdr_result, (char *)(& result));
#line 82
  if (! tmp___5) {
#line 83
    tmp___4 = dcgettext((char const   *)((void *)0), "unable to free results", 5);
#line 83
    log_msg(3, (char const   *)tmp___4);
  }
#line 85
  return;
}
}
#line 88 "ypbind_svc.c"
void ypbindprog_2(struct svc_req *rqstp , SVCXPRT *transp )
{ union __anonunion_argument_59 argument ;
  union __anonunion_result_60 result ;
  bool_t retval ;
  bool_t (*xdr_argument)(XDR * , void *  , ...) ;
  bool_t (*xdr_result)(XDR * , void *  , ...) ;
  bool_t (*local)(char * , void * , struct svc_req * ) ;
  bool_t tmp ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;
  char *tmp___2 ;
  bool_t tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 106
  switch ((int )rqstp->rq_proc) {
  case 0:
#line 109
  xdr_argument = (bool_t (*)(XDR * , void *  , ...))(& xdr_void);
#line 110
  xdr_result = (bool_t (*)(XDR * , void *  , ...))(& xdr_void);
#line 111
  local = (bool_t (*)(char * , void * , struct svc_req * ))(& ypbindproc_null_2_svc);
#line 113
  break;
  case 1:
#line 116
  xdr_argument = (bool_t (*)(XDR * , void *  , ...))(& ypbind_xdr_domainname);
#line 117
  xdr_result = (bool_t (*)(XDR * , void *  , ...))(& ypbind_xdr_resp);
#line 118
  local = (bool_t (*)(char * , void * , struct svc_req * ))(& ypbindproc_domain_2_svc);
#line 120
  break;
  case 2:
#line 123
  xdr_argument = (bool_t (*)(XDR * , void *  , ...))(& ypbind_xdr_setdom);
#line 124
  xdr_result = (bool_t (*)(XDR * , void *  , ...))(& xdr_void);
#line 125
  local = (bool_t (*)(char * , void * , struct svc_req * ))(& ypbindproc_setdom_2_svc);
#line 127
  break;
  default:
#line 130
  svcerr_noproc(transp);
#line 131
  return;
  }
#line 133
  memset((void *)((char *)(& argument)), 0, sizeof(argument));
#line 134
  tmp = ((*((transp->xp_ops)->xp_getargs)))(transp, xdr_argument, (char *)(& argument));
#line 134
  if (! tmp) {
#line 136
    svcerr_decode(transp);
#line 137
    return;
  }
#line 139
  tmp___0 = ((*local))((char *)(& argument), (void *)(& result), rqstp);
#line 139
  retval = tmp___0;
#line 140
  if (retval > 0) {
#line 140
    tmp___1 = svc_sendreply(transp, xdr_result, (char *)(& result));
#line 140
    if (! tmp___1) {
#line 142
      svcerr_systemerr(transp);
    }
  }
#line 144
  tmp___3 = ((*((transp->xp_ops)->xp_freeargs)))(transp, xdr_argument, (char *)(& argument));
#line 144
  if (! tmp___3) {
#line 145
    tmp___2 = dcgettext((char const   *)((void *)0), "unable to free arguments", 5);
#line 145
    log_msg(3, (char const   *)tmp___2);
  }
#line 147
  tmp___5 = ypbindprog_2_freeresult(transp, xdr_result, (char *)(& result));
#line 147
  if (! tmp___5) {
#line 148
    tmp___4 = dcgettext((char const   *)((void *)0), "unable to free results", 5);
#line 148
    log_msg(3, (char const   *)tmp___4);
  }
#line 150
  return;
}
}
#line 1 "ypbind_server.o"
#pragma merger(0,"/tmp/cil-IqD537Ar.i","-Wall,-g,-O2")
#line 54 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 375 "/usr/include/rpc/xdr.h"
extern  __attribute__((__nothrow__)) void xdr_free(bool_t (*__proc)(XDR * , void *
                                                                    , ...) , char *__objp ) ;
#line 10 "local.h"
void find_domain(char const   *domain___0 , ypbind_resp *result ) ;
#line 14
void change_binding(char const   *domain___0 , ypbind_binding *binding ) ;
#line 19
int test_bindings_once(int lastcheck , char const   *req_domain ) ;
#line 41 "ypbind_server.c"
bool_t ypbindproc_oldnull_1_svc(void *argp  __attribute__((__unused__)) , void *result ,
                                struct svc_req *rqstp  __attribute__((__unused__)) )
{

  {
#line 45
  memset(result, 0, sizeof(char *));
#line 46
  return (1);
}
}
#line 49 "ypbind_server.c"
bool_t ypbindproc_null_2_svc(void *argp  __attribute__((__unused__)) , void *result ,
                             struct svc_req *rqstp  __attribute__((__unused__)) )
{

  {
#line 53
  memset(result, 0, sizeof(char *));
#line 54
  return (1);
}
}
#line 57 "ypbind_server.c"
static bool_t ypbindproc_domain(char *domain___0 , ypbind_resp *result , struct svc_req *rqstp  __attribute__((__unused__)) )
{ char *tmp ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 61
  memset((void *)result, 0, sizeof(ypbind_resp ));
#line 62
  result->ypbind_status = 2;
#line 63
  result->ypbind_resp_u.ypbind_error = 2U;
#line 65
  tmp___1 = __builtin_strchr(domain___0, (char )'/');
#line 65
  if (tmp___1) {
#line 67
    tmp = dcgettext((char const   *)((void *)0), "Domain name \'%s\' has embedded slash -- rejecting.",
                    5);
#line 67
    log_msg(3, (char const   *)tmp, domain___0);
#line 69
    return (1);
  }
#line 72
  test_bindings_once(1, (char const   *)domain___0);
#line 73
  find_domain((char const   *)domain___0, result);
#line 75
  if (debug_flag) {
#line 77
    if ((int )result->ypbind_status == 2) {
#line 78
      tmp___2 = dcgettext((char const   *)((void *)0), "Status: YPBIND_FAIL_VAL",
                          5);
#line 78
      log_msg(7, (char const   *)tmp___2);
    } else {
#line 80
      tmp___3 = dcgettext((char const   *)((void *)0), "Status: YPBIND_SUCC_VAL",
                          5);
#line 80
      log_msg(7, (char const   *)tmp___3);
    }
  }
#line 82
  return (1);
}
}
#line 85 "ypbind_server.c"
bool_t ypbindproc_olddomain_1_svc(domainname *argp , ypbind_resp *result , struct svc_req *rqstp )
{ bool_t tmp ;

  {
#line 89
  if (debug_flag) {
#line 90
    log_msg(7, "ypbindproc_olddomain_1_svc (%s)", (*argp));
  }
#line 92
  tmp = ypbindproc_domain((*argp), result, rqstp);
#line 92
  return (tmp);
}
}
#line 95 "ypbind_server.c"
bool_t ypbindproc_domain_2_svc(domainname *argp , ypbind_resp *result , struct svc_req *rqstp )
{ bool_t tmp ;

  {
#line 99
  if (debug_flag) {
#line 100
    log_msg(7, "ypbindproc_domain_2_svc (%s)", (*argp));
  }
#line 102
  tmp = ypbindproc_domain((*argp), result, rqstp);
#line 102
  return (tmp);
}
}
#line 105 "ypbind_server.c"
static bool_t ypbindproc_setdom(char const   *domain___0 , ypbind_binding *binding ,
                                struct sockaddr_in *fromhost )
{ char *tmp ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  register unsigned int __v ;
  register unsigned int __x ;
  char *tmp___4 ;
  char *tmp___5 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;

  {
#line 109
  tmp___1 = __builtin_strchr((char *)domain___0, (char )'/');
#line 109
  if (tmp___1) {
#line 111
    tmp = dcgettext((char const   *)((void *)0), "Domain name \'%s\' has embedded slash -- rejecting.",
                    5);
#line 111
    log_msg(3, (char const   *)tmp, domain___0);
#line 113
    return (1);
  }
#line 116
  switch (ypset) {
  case 2:
#line 119
  __x = 2130706433U;
#line 119
  __asm__  ("bswap %0": "=r" (__v): "0" (__x));
#line 119
  if (fromhost->sin_addr.s_addr != __v) {
#line 121
    if (debug_flag) {
#line 122
      tmp___2 = inet_ntoa(fromhost->sin_addr);
#line 122
      tmp___3 = dcgettext((char const   *)((void *)0), "User from \'%s\' try\'s to change the binding.",
                          5);
#line 122
      log_msg(7, (char const   *)tmp___3, tmp___2);
    }
#line 125
    return (1);
  }
#line 127
  break;
  case 1:
#line 129
  break;
  case 0:
  default:
#line 132
  tmp___4 = dcgettext((char const   *)((void *)0), "Changing the binding is not allowed.",
                      5);
#line 132
  log_msg(3, (char const   *)tmp___4);
#line 133
  return (1);
  }
#line 135
  __x___0 = fromhost->sin_port;
#line 135
  __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 135
  if ((int )__v___0 >= 1024) {
#line 137
    tmp___5 = dcgettext((char const   *)((void *)0), "SETDOM request doesn\'t come from reserved port.",
                        5);
#line 137
    log_msg(3, (char const   *)tmp___5);
#line 138
    return (1);
  }
#line 141
  change_binding(domain___0, binding);
#line 143
  return (1);
}
}
#line 146 "ypbind_server.c"
bool_t ypbindproc_oldsetdom_1_svc(ypbind_oldsetdom *argp , void *result , struct svc_req *rqstp )
{ bool_t tmp ;

  {
#line 150
  if (debug_flag) {
#line 151
    log_msg(7, "ypbindproc_oldsetdom_1_svc (%s)", argp->ypoldsetdom_domain);
  }
#line 154
  memset(result, 0, sizeof(char *));
#line 156
  tmp = ypbindproc_setdom((char const   *)(argp->ypoldsetdom_domain), & argp->ypoldsetdom_binding,
                          & (rqstp->rq_xprt)->xp_raddr);
#line 156
  return (tmp);
}
}
#line 161 "ypbind_server.c"
bool_t ypbindproc_setdom_2_svc(ypbind_setdom *argp , void *result , struct svc_req *rqstp )
{ bool_t tmp ;

  {
#line 165
  if (debug_flag) {
#line 166
    log_msg(7, "ypbindproc_setdom_2_svc (%s)", argp->ypsetdom_domain);
  }
#line 169
  memset(result, 0, sizeof(char *));
#line 171
  tmp = ypbindproc_setdom((char const   *)argp->ypsetdom_domain, & argp->ypsetdom_binding,
                          & (rqstp->rq_xprt)->xp_raddr);
#line 171
  return (tmp);
}
}
#line 176 "ypbind_server.c"
int ypbindprog_1_freeresult(SVCXPRT *transp  __attribute__((__unused__)) , bool_t (*xdr_result)(XDR * ,
                                                                                                void *
                                                                                                , ...) ,
                            caddr_t result )
{

  {
#line 180
  xdr_free(xdr_result, result);
#line 182
  return (1);
}
}
#line 185 "ypbind_server.c"
int ypbindprog_2_freeresult(SVCXPRT *transp  __attribute__((__unused__)) , bool_t (*xdr_result)(XDR * ,
                                                                                                void *
                                                                                                , ...) ,
                            caddr_t result )
{

  {
#line 189
  xdr_free(xdr_result, result);
#line 191
  return (1);
}
}
#line 1 "log_msg.o"
#pragma merger(0,"/tmp/cil-gqDJgxro.i","-Wall,-g,-O2")
#line 346 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 487
extern int fputc(int __c , FILE *__stream ) ;
#line 200 "/usr/include/sys/syslog.h"
extern void ( /* format attribute */  vsyslog)(int __pri , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 1011 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long syscall(long __sysno  , ...) ;
#line 33 "log_msg.c"
pid_t gettid(void)
{ pid_t tmp ;

  {
#line 36
  tmp = (pid_t )syscall(224L);
#line 36
  return (tmp);
}
}
#line 46 "log_msg.c"
int debug_flag  =    0;
#line 48 "log_msg.c"
void log_msg(int type , char const   *fmt  , ...)
{ va_list ap ;
  pid_t tmp ;

  {
#line 56
  __builtin_va_start(ap, fmt);
#line 58
  if (debug_flag) {
#line 60
    tmp = gettid();
#line 60
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%d: ", tmp);
#line 61
    vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )fmt, ap);
#line 62
    fputc('\n', stderr);
  } else {
#line 70
    vsyslog(type, fmt, ap);
  }
#line 74
  __builtin_va_end(ap);
#line 75
  return;
}
}
#line 1 "serv_list.o"
#pragma merger(0,"/tmp/cil-XubJ6WST.i","-Wall,-g,-O2")
#line 50 "/usr/include/sys/uio.h"
extern ssize_t writev(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 61 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) int *__h_errno_location(void)  __attribute__((__const__)) ;
#line 166
extern int gethostbyaddr_r(void const   * __restrict  __addr , __socklen_t __len ,
                           int __type , struct hostent * __restrict  __result_buf ,
                           char * __restrict  __buf , size_t __buflen , struct hostent ** __restrict  __result ,
                           int * __restrict  __h_errnop ) ;
#line 173
extern int gethostbyname_r(char const   * __restrict  __name , struct hostent * __restrict  __result_buf ,
                           char * __restrict  __buf , size_t __buflen , struct hostent ** __restrict  __result ,
                           int * __restrict  __h_errnop ) ;
#line 405 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 589 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 591
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 600
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
#line 628
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 84
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 1304 "/usr/include/bits/string2.h"
extern  __attribute__((__nothrow__)) char *__strdup(char const   *__string )  __attribute__((__malloc__)) ;
#line 289 "/usr/include/rpc/xdr.h"
extern  __attribute__((__nothrow__)) bool_t xdr_u_short(XDR *__xdrs , u_short *__usp ) ;
#line 308
extern  __attribute__((__nothrow__)) bool_t xdr_bool(XDR *__xdrs , bool_t *__bp ) ;
#line 163 "/usr/include/rpc/auth.h"
extern AUTH *authunix_create_default(void) ;
#line 335 "/usr/include/rpc/clnt.h"
extern  __attribute__((__nothrow__)) CLIENT *clntudp_create(struct sockaddr_in *__raddr ,
                                                            u_long __program , u_long __version ,
                                                            struct timeval __wait_resend ,
                                                            int *__sockp ) ;
#line 338
extern  __attribute__((__nothrow__)) CLIENT *clntudp_bufcreate(struct sockaddr_in *__raddr ,
                                                               u_long __program ,
                                                               u_long __version ,
                                                               struct timeval __wait_resend ,
                                                               int *__sockp , u_int __sendsz ,
                                                               u_int __recvsz ) ;
#line 395
extern struct rpc_createerr rpc_createerr ;
#line 402
extern  __attribute__((__nothrow__)) char *clnt_sperrno(enum clnt_stat __num ) ;
#line 85 "/usr/include/rpc/pmap_clnt.h"
extern  __attribute__((__nothrow__)) enum clnt_stat clnt_broadcast(u_long __prog ,
                                                                   u_long __vers ,
                                                                   u_long __proc ,
                                                                   bool_t (*__xargs)(XDR * ,
                                                                                     void *
                                                                                     , ...) ,
                                                                   caddr_t __argsp ,
                                                                   bool_t (*__xresults)(XDR * ,
                                                                                        void *
                                                                                        , ...) ,
                                                                   caddr_t __resultsp ,
                                                                   bool_t (*__eachresult)(caddr_t resp ,
                                                                                          struct sockaddr_in *raddr ) ) ;
#line 97 "/usr/include/rpc/pmap_prot.h"
extern  __attribute__((__nothrow__)) bool_t xdr_pmap(XDR *__xdrs , struct pmap *__regs ) ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request
                                               , ...) ;
#line 187 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 231 "/usr/include/pthread.h"
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
#line 725
extern  __attribute__((__nothrow__)) int pthread_mutex_trylock(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
#line 39 "pthread_np.h"
int pthread_rdwr_rlock_np(pthread_rdwr_t *rdwrp ) ;
#line 40
int pthread_rdwr_wlock_np(pthread_rdwr_t *rdwrp ) ;
#line 41
int pthread_rdwr_runlock_np(pthread_rdwr_t *rdwrp ) ;
#line 42
int pthread_rdwr_wunlock_np(pthread_rdwr_t *rdwrp ) ;
#line 84 "serv_list.c"
static struct binding *domainlist  =    (struct binding *)((void *)0);
#line 85 "serv_list.c"
static int max_domains  =    0;
#line 86 "serv_list.c"
static struct __anonstruct_pthread_rdwr_t_72 domainlock  =    {0, 0, 0, {{0, 0U, 0, 0, 0U, {0}}}, {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}};
#line 87 "serv_list.c"
static union __anonunion_pthread_mutex_t_5 search_lock  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 89
static void do_broadcast(struct binding *list ) ;
#line 90
static int ping_all(struct binding *list ) ;
#line 92 "serv_list.c"
static void remove_bindingfile(char const   *domain___0 )
{ size_t tmp ;
  size_t tmp___0 ;
  char *path ;
  unsigned int __lengthofpath ;

  {
#line 95
  tmp = strlen("/var/yp/binding");
#line 95
  tmp___0 = strlen(domain___0);
#line 95
  __lengthofpath = (tmp + tmp___0) + 10U;
#line 95
  path = (char *)__builtin_alloca(sizeof((*path)) * __lengthofpath);
#line 97
  sprintf((char * __restrict  )path, (char const   * __restrict  )"%s/%s.1", "/var/yp/binding",
          domain___0);
#line 98
  unlink((char const   *)path);
#line 99
  sprintf((char * __restrict  )path, (char const   * __restrict  )"%s/%s.2", "/var/yp/binding",
          domain___0);
#line 100
  unlink((char const   *)path);
#line 101
  return;
}
}
#line 105 "serv_list.c"
static void update_bindingfile(struct binding *entry )
{ unsigned short sport ;
  struct iovec iov[2] ;
  struct ypbind_resp ybres ;
  char path1[4097] ;
  char path2[4097] ;
  int fd ;
  int len ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  ssize_t tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;

  {
#line 109
  sport = (unsigned short )port;
#line 115
  sprintf((char * __restrict  )(path1), (char const   * __restrict  )"%s/%s.1", "/var/yp/binding",
          entry->domain);
#line 116
  sprintf((char * __restrict  )(path2), (char const   * __restrict  )"%s/%s.2", "/var/yp/binding",
          entry->domain);
#line 118
  iov[0].iov_base = (void *)((char *)(& sport));
#line 119
  iov[0].iov_len = sizeof(sport);
#line 120
  iov[1].iov_base = (void *)((char *)(& ybres));
#line 121
  iov[1].iov_len = sizeof(ybres);
#line 123
  memset((void *)(& ybres), 0, sizeof(ybres));
#line 124
  ybres.ypbind_status = 1;
#line 125
  if (entry->active >= 0) {
#line 127
    memcpy((void * __restrict  )(& ybres.ypbind_resp_u.ypbind_bindinfo.ypbind_binding_addr),
           (void const   * __restrict  )(& entry->server[entry->active].addr), sizeof(struct in_addr ));
#line 129
    memcpy((void * __restrict  )(& ybres.ypbind_resp_u.ypbind_bindinfo.ypbind_binding_port),
           (void const   * __restrict  )(& entry->server[entry->active].port), sizeof(unsigned short ));
  } else {
#line 132
    if (entry->active == -2) {
#line 134
      memcpy((void * __restrict  )(& ybres.ypbind_resp_u.ypbind_bindinfo.ypbind_binding_addr),
             (void const   * __restrict  )(& entry->ypset.addr), sizeof(struct in_addr ));
#line 136
      memcpy((void * __restrict  )(& ybres.ypbind_resp_u.ypbind_bindinfo.ypbind_binding_port),
             (void const   * __restrict  )(& entry->ypset.port), sizeof(unsigned short ));
    } else {
#line 143
      unlink((char const   *)(path1));
#line 144
      unlink((char const   *)(path2));
#line 145
      log_msg(3, "INTERNAL ERROR: update_bindingfile called without valid data!");
#line 146
      return;
    }
  }
#line 149
  len = (int )(iov[0].iov_len + iov[1].iov_len);
#line 151
  fd = open((char const   *)(path1), 578, 420);
#line 151
  if (fd != -1) {
#line 153
    tmp___1 = writev(fd, (struct iovec  const  *)(iov), 2);
#line 153
    if (tmp___1 != len) {
#line 155
      tmp = __errno_location();
#line 155
      tmp___0 = strerror((*tmp));
#line 155
      log_msg(3, "writev (%s): %s", path1, tmp___0);
#line 156
      unlink((char const   *)(path1));
    }
#line 158
    close(fd);
  } else {
#line 161
    tmp___2 = __errno_location();
#line 161
    tmp___3 = strerror((*tmp___2));
#line 161
    log_msg(3, "open(%s): %s", path1, tmp___3);
  }
#line 163
  fd = open((char const   *)(path2), 578, 420);
#line 163
  if (fd != -1) {
#line 165
    tmp___6 = writev(fd, (struct iovec  const  *)(iov), 2);
#line 165
    if (tmp___6 != len) {
#line 167
      tmp___4 = __errno_location();
#line 167
      tmp___5 = strerror((*tmp___4));
#line 167
      log_msg(3, "writev (%s): %s", path2, tmp___5);
#line 168
      unlink((char const   *)(path2));
    }
#line 170
    close(fd);
  } else {
#line 173
    tmp___7 = __errno_location();
#line 173
    tmp___8 = strerror((*tmp___7));
#line 173
    log_msg(3, "open(%s): %s", path2, tmp___8);
  }
#line 174
  return;
}
}
#line 177 "serv_list.c"
void change_binding(char const   *domain___0 , ypbind_binding *binding )
{ int i ;
  struct sockaddr_in addr ;
  struct timeval timeout___0 ;
  int sock ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 182
  pthread_rdwr_rlock_np(& domainlock);
#line 184
  i = 0;
#line 184
  while (i < max_domains) {
#line 186
    if (0) {
#line 186
      __s1_len = strlen((char const   *)((domainlist + i)->domain));
#line 186
      __s2_len = strlen(domain___0);
#line 186
      if (! ((unsigned int )((void const   *)((domainlist + i)->domain + 1)) - (unsigned int )((void const   *)((domainlist + i)->domain)) == 1U)) {
        goto _L___0;
      } else {
#line 186
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */
#line 186
          if (! ((unsigned int )((void const   *)(domain___0 + 1)) - (unsigned int )((void const   *)domain___0) == 1U)) {
#line 186
            tmp___8 = 1;
          } else {
#line 186
            if (__s2_len >= 4U) {
#line 186
              tmp___8 = 1;
            } else {
#line 186
              tmp___8 = 0;
            }
          }
        } else {
#line 186
          tmp___8 = 0;
        }
      }
#line 186
      if (tmp___8) {
#line 186
        tmp___4 = __builtin_strcmp((char const   *)((domainlist + i)->domain), domain___0);
      } else {
#line 186
        tmp___7 = __builtin_strcmp((char const   *)((domainlist + i)->domain), domain___0);
#line 186
        tmp___4 = tmp___7;
      }
    } else {
#line 186
      tmp___7 = __builtin_strcmp((char const   *)((domainlist + i)->domain), domain___0);
#line 186
      tmp___4 = tmp___7;
    }
#line 186
    if (tmp___4 == 0) {
#line 192
      pthread_rdwr_runlock_np(& domainlock);
#line 193
      pthread_rdwr_wlock_np(& domainlock);
#line 195
      if ((unsigned int )(domainlist + i)->client_handle != (unsigned int )((void *)0)) {
#line 196
        ((*((((domainlist + i)->client_handle)->cl_ops)->cl_destroy)))((domainlist + i)->client_handle);
      }
#line 198
      (domainlist + i)->active = -2;
#line 199
      memcpy((void * __restrict  )(& (domainlist + i)->ypset.addr), (void const   * __restrict  )(& binding->ypbind_binding_addr),
             sizeof(struct in_addr ));
#line 202
      memcpy((void * __restrict  )(& (domainlist + i)->ypset.port), (void const   * __restrict  )(& binding->ypbind_binding_port),
             sizeof(unsigned short ));
#line 205
      (domainlist + i)->ypset.family = (unsigned short)2;
#line 207
      sock = -1;
#line 208
      timeout___0.tv_sec = 1L;
#line 209
      timeout___0.tv_usec = 0L;
#line 210
      memset((void *)(& addr), 0, sizeof(struct sockaddr_in ));
#line 211
      memcpy((void * __restrict  )(& addr.sin_addr), (void const   * __restrict  )(& (domainlist + i)->ypset.addr),
             sizeof(struct in_addr ));
#line 213
      memcpy((void * __restrict  )(& addr.sin_port), (void const   * __restrict  )(& (domainlist + i)->ypset.port),
             sizeof(unsigned short ));
#line 215
      addr.sin_family = (domainlist + i)->ypset.family;
#line 217
      (domainlist + i)->client_handle = clntudp_create(& addr, 100004UL, 2UL, timeout___0,
                                                       & sock);
#line 217
      if ((unsigned int )(domainlist + i)->client_handle == (unsigned int )((void *)0)) {
#line 220
        (domainlist + i)->active = -1;
#line 221
        remove_bindingfile(domain___0);
      }
#line 223
      pthread_rdwr_wunlock_np(& domainlock);
#line 224
      pthread_rdwr_rlock_np(& domainlock);
#line 225
      update_bindingfile(domainlist + i);
#line 226
      pthread_rdwr_runlock_np(& domainlock);
#line 228
      return;
    }
#line 184
    i ++;
  }
#line 232
  pthread_rdwr_runlock_np(& domainlock);
#line 233
  return;
}
}
#line 236 "serv_list.c"
void find_domain(char const   *domain___0 , ypbind_resp *result )
{ int i ;
  int count ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  register unsigned short __v ;
  register unsigned short __x ;
  char *tmp___9 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 239
  count = 0;
#line 241
  if ((unsigned int )domainlist == (unsigned int )((void *)0)) {
#line 242
    return;
  }
#line 244
  pthread_rdwr_rlock_np(& domainlock);
#line 246
  i = 0;
#line 246
  while (i < max_domains) {
#line 247
    if (0) {
#line 247
      __s1_len = strlen((char const   *)((domainlist + i)->domain));
#line 247
      __s2_len = strlen(domain___0);
#line 247
      if (! ((unsigned int )((void const   *)((domainlist + i)->domain + 1)) - (unsigned int )((void const   *)((domainlist + i)->domain)) == 1U)) {
        goto _L___0;
      } else {
#line 247
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */
#line 247
          if (! ((unsigned int )((void const   *)(domain___0 + 1)) - (unsigned int )((void const   *)domain___0) == 1U)) {
#line 247
            tmp___8 = 1;
          } else {
#line 247
            if (__s2_len >= 4U) {
#line 247
              tmp___8 = 1;
            } else {
#line 247
              tmp___8 = 0;
            }
          }
        } else {
#line 247
          tmp___8 = 0;
        }
      }
#line 247
      if (tmp___8) {
#line 247
        tmp___4 = __builtin_strcmp((char const   *)((domainlist + i)->domain), domain___0);
      } else {
#line 247
        tmp___7 = __builtin_strcmp((char const   *)((domainlist + i)->domain), domain___0);
#line 247
        tmp___4 = tmp___7;
      }
    } else {
#line 247
      tmp___7 = __builtin_strcmp((char const   *)((domainlist + i)->domain), domain___0);
#line 247
      tmp___4 = tmp___7;
    }
#line 247
    if (tmp___4 == 0) {
#line 248
      break;
    }
#line 246
    i ++;
  }
#line 250
  if (i >= max_domains) {
#line 252
    pthread_rdwr_runlock_np(& domainlock);
#line 253
    return;
  }
  again:
#line 257
  count ++;
#line 258
  if ((domainlist + i)->active >= 0) {
#line 260
    result->ypbind_status = 1;
#line 261
    memcpy((void * __restrict  )(& result->ypbind_resp_u.ypbind_bindinfo.ypbind_binding_addr),
           (void const   * __restrict  )(& (domainlist + i)->server[(domainlist + i)->active].addr),
           sizeof(struct in_addr ));
#line 264
    memcpy((void * __restrict  )(& result->ypbind_resp_u.ypbind_bindinfo.ypbind_binding_port),
           (void const   * __restrict  )(& (domainlist + i)->server[(domainlist + i)->active].port),
           sizeof(unsigned short ));
#line 267
    if (debug_flag) {
#line 270
      __x = (domainlist + i)->server[(domainlist + i)->active].port;
#line 270
      __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 270
      tmp___9 = inet_ntoa((domainlist + i)->server[(domainlist + i)->active].addr);
#line 270
      log_msg(7, "YPBINDPROC_DOMAIN: server \'%s\', port %d", tmp___9, __v);
    }
  } else {
#line 272
    if ((domainlist + i)->active == -2) {
#line 274
      result->ypbind_status = 1;
#line 275
      memcpy((void * __restrict  )(& result->ypbind_resp_u.ypbind_bindinfo.ypbind_binding_addr),
             (void const   * __restrict  )(& (domainlist + i)->ypset.addr), sizeof(struct in_addr ));
#line 277
      memcpy((void * __restrict  )(& result->ypbind_resp_u.ypbind_bindinfo.ypbind_binding_port),
             (void const   * __restrict  )(& (domainlist + i)->ypset.port), sizeof(unsigned short ));
#line 280
      if (debug_flag) {
#line 284
        __x___0 = (domainlist + i)->ypset.port;
#line 284
        __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 284
        tmp___10 = inet_ntoa((domainlist + i)->ypset.addr);
#line 284
        log_msg(7, "YPBINDPROC_DOMAIN: server \'%s\', port %d", tmp___10, __v___0);
      }
    } else {
#line 290
      pthread_rdwr_runlock_np(& domainlock);
#line 292
      if (count > 2) {
#line 293
        return;
      }
#line 295
      tmp___12 = pthread_mutex_trylock(& search_lock);
#line 295
      if (tmp___12 == 0) {
#line 297
        if (debug_flag) {
#line 298
          log_msg(7, "trylock = success");
        }
#line 299
        tmp___11 = ping_all(domainlist + i);
#line 299
        if (! tmp___11) {
#line 299
          if ((domainlist + i)->use_broadcast) {
#line 301
            do_broadcast(domainlist + i);
          }
        }
      } else {
#line 305
        if (debug_flag) {
#line 306
          log_msg(7, "trylock = failed");
        }
#line 309
        pthread_mutex_lock(& search_lock);
      }
#line 311
      pthread_mutex_unlock(& search_lock);
#line 313
      pthread_rdwr_rlock_np(& domainlock);
      goto again;
    }
  }
#line 317
  pthread_rdwr_runlock_np(& domainlock);
#line 319
  return;
}
}
#line 322 "serv_list.c"
void clear_server(void)
{ int i ;
  int j ;

  {
#line 327
  pthread_rdwr_wlock_np(& domainlock);
#line 329
  if ((unsigned int )domainlist != (unsigned int )((void *)0)) {
#line 331
    i = 0;
#line 331
    while (i < max_domains) {
#line 333
      j = 0;
#line 333
      while (j < 30) {
#line 335
        if ((unsigned int )(domainlist + i)->server[j].host != (unsigned int )((void *)0)) {
#line 336
          free((void *)(domainlist + i)->server[j].host);
        }
#line 333
        j ++;
      }
#line 338
      if ((unsigned int )(domainlist + i)->ypset.host != (unsigned int )((void *)0)) {
#line 339
        free((void *)(domainlist + i)->ypset.host);
      }
#line 340
      if ((unsigned int )(domainlist + i)->client_handle != (unsigned int )((void *)0)) {
#line 341
        ((*((((domainlist + i)->client_handle)->cl_ops)->cl_destroy)))((domainlist + i)->client_handle);
      }
#line 331
      i ++;
    }
#line 343
    free((void *)domainlist);
  }
#line 345
  domainlist = (struct binding *)((void *)0);
#line 346
  max_domains = 0;
#line 348
  pthread_rdwr_wunlock_np(& domainlock);
#line 349
  return;
}
}
#line 351 "serv_list.c"
static int get_entry(char const   *domain___0 , struct binding **entry )
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
#line 356
  (*entry) = (struct binding *)((void *)0);
#line 358
  i = 0;
#line 358
  while (i < max_domains) {
#line 360
    if (0) {
#line 360
      __s1_len = strlen((char const   *)((domainlist + i)->domain));
#line 360
      __s2_len = strlen(domain___0);
#line 360
      if (! ((unsigned int )((void const   *)((domainlist + i)->domain + 1)) - (unsigned int )((void const   *)((domainlist + i)->domain)) == 1U)) {
        goto _L___0;
      } else {
#line 360
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */
#line 360
          if (! ((unsigned int )((void const   *)(domain___0 + 1)) - (unsigned int )((void const   *)domain___0) == 1U)) {
#line 360
            tmp___8 = 1;
          } else {
#line 360
            if (__s2_len >= 4U) {
#line 360
              tmp___8 = 1;
            } else {
#line 360
              tmp___8 = 0;
            }
          }
        } else {
#line 360
          tmp___8 = 0;
        }
      }
#line 360
      if (tmp___8) {
#line 360
        tmp___4 = __builtin_strcmp((char const   *)((domainlist + i)->domain), domain___0);
      } else {
#line 360
        tmp___7 = __builtin_strcmp((char const   *)((domainlist + i)->domain), domain___0);
#line 360
        tmp___4 = tmp___7;
      }
    } else {
#line 360
      tmp___7 = __builtin_strcmp((char const   *)((domainlist + i)->domain), domain___0);
#line 360
      tmp___4 = tmp___7;
    }
#line 360
    if (tmp___4 == 0) {
#line 361
      (*entry) = domainlist + i;
    }
#line 358
    i ++;
  }
#line 364
  if (! (*entry)) {
#line 366
    max_domains ++;
#line 367
    domainlist = (struct binding *)realloc((void *)domainlist, (unsigned int )max_domains * sizeof(struct binding ));
#line 368
    if ((unsigned int )domainlist == (unsigned int )((void *)0)) {
#line 370
      tmp___9 = dcgettext((char const   *)((void *)0), "Not enough memory !", 5);
#line 370
      log_msg(3, (char const   *)tmp___9);
#line 371
      exit(1);
    }
#line 373
    // pthread_mutex_lock(& search_lock);
    strcpy((char * __restrict  )((domainlist + (max_domains - 1))->domain), (char const   * __restrict  )domain___0);
#line 374
    (domainlist + (max_domains - 1))->ypset.host = (char *)((void *)0);
#line 375
    (domainlist + (max_domains - 1))->active = -1;
#line 376
    (domainlist + (max_domains - 1))->use_broadcast = 0;
#line 377
    memset((void *)((domainlist + (max_domains - 1))->server), 0, 30U * sizeof(struct bound_server ));
#line 379
    (*entry) = domainlist + (max_domains - 1);
    // pthread_mutex_unlock(& search_lock);
  }
#line 382
  return (0);
}
}
#line 385 "serv_list.c"
int add_server(char const   *domain___0 , char const   *host , int check_syntax )
{ struct binding *entry ;
  int active ;
  int res ;
  char *tmp ;
  char *tmp___0 ;
  struct hostent *hent ;
  struct hostent hostbuf ;
  size_t hstbuflen ;
  char *hsttmpbuf ;
  int herr ;
  int error ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___24 ;

  {
#line 390
  res = 0;
#line 392
  if ((unsigned int )domain___0 == (unsigned int )((void *)0)) {
#line 394
    tmp = dcgettext((char const   *)((void *)0), "internal error: add_server called with NULL domain.",
                    5);
#line 394
    log_msg(3, (char const   *)tmp);
#line 396
    abort();
  }
#line 399
  pthread_rdwr_wlock_np(& domainlock);
#line 401
  get_entry(domain___0, & entry);
#line 403
  if ((unsigned int )host == (unsigned int )((void *)0)) {
#line 405
    entry->use_broadcast = 1;
#line 406
    res = 1;
#line 408
    if (debug_flag) {
#line 409
      tmp___0 = dcgettext((char const   *)((void *)0), "add_server() domain: %s, broadcast",
                          5);
#line 409
      log_msg(7, (char const   *)tmp___0, domain___0);
    }
  } else {
#line 425
    active = 0;
#line 425
    while (active < 30) {
#line 426
      if ((unsigned int )entry->server[active].host == (unsigned int )((void *)0)) {
#line 427
        break;
      }
#line 425
      active ++;
    }
#line 430
    if ((unsigned int )entry->server[active].host != (unsigned int )((void *)0)) {
#line 432
      if (debug_flag) {
#line 433
        tmp___1 = dcgettext((char const   *)((void *)0), "add_server() domain: %s, host: %s, NO SLOT FREE!",
                            5);
#line 433
        log_msg(7, (char const   *)tmp___1, domain___0, host);
      }
      goto exit;
    }
#line 439
    if (debug_flag) {
#line 440
      tmp___2 = dcgettext((char const   *)((void *)0), "add_server() domain: %s, host: %s, slot: %d",
                          5);
#line 440
      log_msg(7, (char const   *)tmp___2, domain___0, host, active);
    }
#line 445
    hstbuflen = 1024U;
#line 446
    hsttmpbuf = (char *)__builtin_alloca(hstbuflen);
#line 447
    while (1) {
#line 447
      error = gethostbyname_r((char const   * __restrict  )host, (struct hostent * __restrict  )(& hostbuf),
                              (char * __restrict  )hsttmpbuf, hstbuflen, (struct hostent ** __restrict  )(& hent),
                              (int * __restrict  )(& herr));
#line 447
      if (! (error != 0)) {
#line 447
        break;
      }
#line 449
      if (herr == -1) {
#line 453
        hstbuflen *= 2U;
#line 454
        hsttmpbuf = (char *)__builtin_alloca(hstbuflen);
      } else {
#line 449
        if (error == -1) {
#line 449
          tmp___3 = __errno_location();
#line 449
          if ((*tmp___3) == 34) {
#line 453
            hstbuflen *= 2U;
#line 454
            hsttmpbuf = (char *)__builtin_alloca(hstbuflen);
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */
#line 449
          if (error == 34) {
#line 453
            hstbuflen *= 2U;
#line 454
            hsttmpbuf = (char *)__builtin_alloca(hstbuflen);
          } else {
#line 457
            break;
          }
        }
      }
    }
#line 465
    if (! hent) {
#line 467
      tmp___4 = __h_errno_location();
#line 467
      switch ((*tmp___4)) {
      case 1:
#line 470
      if (check_syntax) {
#line 471
        tmp___5 = dcgettext((char const   *)((void *)0), "Unknown host:", 5);
#line 471
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s %s\n",
                tmp___5, host);
      } else {
#line 473
        tmp___6 = dcgettext((char const   *)((void *)0), "Unknown host:", 5);
#line 473
        log_msg(3, "%s %s", tmp___6, host);
      }
#line 474
      break;
      case 2:
#line 476
      if (check_syntax) {
#line 477
        tmp___7 = dcgettext((char const   *)((void *)0), "Host name lookup failure",
                            5);
#line 477
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n",
                tmp___7);
      } else {
#line 479
        tmp___8 = dcgettext((char const   *)((void *)0), "Host name lookup failure",
                            5);
#line 479
        log_msg(3, (char const   *)tmp___8);
      }
#line 480
      break;
      case 4:
#line 482
      if (check_syntax) {
#line 483
        tmp___9 = dcgettext((char const   *)((void *)0), "No address associated with name:",
                            5);
#line 483
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s %s\n",
                tmp___9, host);
      } else {
#line 486
        tmp___10 = dcgettext((char const   *)((void *)0), "No address associated with name:",
                             5);
#line 486
        log_msg(3, "%s %s", tmp___10, host);
      }
#line 488
      break;
      case 3:
#line 490
      if (check_syntax) {
#line 491
        tmp___11 = dcgettext((char const   *)((void *)0), "Unknown server error",
                             5);
#line 491
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n",
                tmp___11);
      } else {
#line 493
        tmp___12 = dcgettext((char const   *)((void *)0), "Unknown server error",
                             5);
#line 493
        log_msg(3, (char const   *)tmp___12);
      }
#line 494
      break;
      default: ;
#line 496
      if (check_syntax) {
#line 497
        tmp___13 = dcgettext((char const   *)((void *)0), "gethostbyname: Unknown error",
                             5);
#line 497
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n",
                tmp___13);
      } else {
#line 499
        tmp___14 = dcgettext((char const   *)((void *)0), "gethostbyname: Unknown error",
                             5);
#line 499
        log_msg(3, (char const   *)tmp___14);
      }
#line 500
      break;
      }
      goto exit;
    }
#line 504
    if ((unsigned int )(*(hent->h_addr_list + 0)) == (unsigned int )((void *)0)) {
      goto exit;
    }
#line 507
    tmp___24 = __strdup(host);
#line 507
    entry->server[active].host = tmp___24;
#line 508
    entry->server[active].family = (unsigned short )hent->h_addrtype;
#line 512
    memcpy((void * __restrict  )(& entry->server[active].addr), (void const   * __restrict  )(*(hent->h_addr_list + 0)),
           (unsigned int )hent->h_length);
#line 514
    res = 1;
  }
  exit:
#line 518
  pthread_rdwr_wunlock_np(& domainlock);
#line 519
  return (res);
}
}
#line 522 "serv_list.c"
static struct binding *in_use  =    (struct binding *)((void *)0);
#line 524 "serv_list.c"
static bool_t eachresult(bool_t *out , struct sockaddr_in *addr )
{ struct timeval timeout___0 ;
  int sock ;
  struct hostent hostbuf ;
  struct hostent *host ;
  size_t hstbuflen ;
  char *hsttmpbuf ;
  int herr ;
  int error ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  register unsigned short __v ;
  register unsigned short __x ;
  char *tmp___3 ;
  char *tmp___4 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;

  {
#line 530
  if ((*out)) {
#line 532
    if (debug_flag) {
#line 541
      hstbuflen = 1024U;
#line 542
      hsttmpbuf = (char *)__builtin_alloca(hstbuflen);
#line 543
      while (1) {
#line 543
        error = gethostbyaddr_r((void const   * __restrict  )((char *)(& addr->sin_addr.s_addr)),
                                sizeof(addr->sin_addr.s_addr), 2, (struct hostent * __restrict  )(& hostbuf),
                                (char * __restrict  )hsttmpbuf, hstbuflen, (struct hostent ** __restrict  )(& host),
                                (int * __restrict  )(& herr));
#line 543
        if (! (error < 0)) {
#line 543
          break;
        }
#line 547
        if (herr == -1) {
#line 551
          hstbuflen *= 2U;
#line 552
          hsttmpbuf = (char *)__builtin_alloca(hstbuflen);
        } else {
#line 547
          if (error == -1) {
#line 547
            tmp = __errno_location();
#line 547
            if ((*tmp) == 34) {
#line 551
              hstbuflen *= 2U;
#line 552
              hsttmpbuf = (char *)__builtin_alloca(hstbuflen);
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */
#line 547
            if (error == 34) {
#line 551
              hstbuflen *= 2U;
#line 552
              hsttmpbuf = (char *)__builtin_alloca(hstbuflen);
            } else {
#line 555
              break;
            }
          }
        }
      }
#line 570
      if ((unsigned int )host != (unsigned int )((void *)0)) {
#line 571
        tmp___0 = dcgettext((char const   *)((void *)0), "Answer for domain \'%s\' from server \'%s\'",
                            5);
#line 571
        log_msg(7, (char const   *)tmp___0, in_use->domain, host->h_name);
      } else {
#line 574
        tmp___1 = inet_ntoa(addr->sin_addr);
#line 574
        tmp___2 = dcgettext((char const   *)((void *)0), "Answer for domain \'%s\' from unknown server \'%s\'",
                            5);
#line 574
        log_msg(7, (char const   *)tmp___2, in_use->domain, tmp___1);
      }
    }
#line 579
    if (! broken_server) {
#line 579
      __x___0 = addr->sin_port;
#line 579
      __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 579
      if ((int )__v___0 >= 1024) {
#line 584
        __x = addr->sin_port;
#line 584
        __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 584
        tmp___3 = inet_ntoa(addr->sin_addr);
#line 584
        tmp___4 = dcgettext((char const   *)((void *)0), "Answer for domain \'%s\' from \'%s\' on illegal port %d.",
                            5);
#line 584
        log_msg(3, (char const   *)tmp___4, in_use->domain, tmp___3, __v);
#line 585
        return (0);
      }
    }
#line 588
    memcpy((void * __restrict  )(& in_use->server[0].addr), (void const   * __restrict  )(& addr->sin_addr),
           sizeof(struct in_addr ));
#line 590
    memcpy((void * __restrict  )(& in_use->server[0].port), (void const   * __restrict  )(& addr->sin_port),
           sizeof(unsigned short ));
#line 593
    sock = -1;
#line 594
    timeout___0.tv_sec = 1L;
#line 595
    timeout___0.tv_usec = 0L;
#line 596
    in_use->client_handle = clntudp_create(addr, 100004UL, 2UL, timeout___0, & sock);
#line 599
    if ((unsigned int )in_use->client_handle == (unsigned int )((void *)0)) {
#line 600
      return (0);
    }
#line 602
    in_use->active = 0;
#line 604
    return (1);
  } else {
#line 608
    return (0);
  }
}
}
#line 612 "serv_list.c"
static void do_broadcast(struct binding *list )
{ char *domain___0 ;
  bool_t out ;
  enum clnt_stat status ;
  char const   *__old ;
  size_t __len ;
  size_t tmp ;
  char *__new ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 622
  pthread_rdwr_rlock_np(& domainlock);
#line 623
  __old = (char const   *)(list->domain);
#line 623
  tmp = strlen(__old);
#line 623
  __len = tmp + 1U;
#line 623
  tmp___0 = (char *)__builtin_alloca(__len);
#line 623
  __new = tmp___0;
#line 623
  domain___0 = (char *)memcpy((void * __restrict  )__new, (void const   * __restrict  )__old,
                              __len);
#line 624
  pthread_rdwr_runlock_np(& domainlock);
#line 626
  if (debug_flag) {
#line 627
    tmp___2 = dcgettext((char const   *)((void *)0), "do_broadcast() for domain \'%s\' is called",
                        5);
#line 627
    log_msg(7, (char const   *)tmp___2, domain___0);
  }
#line 632
  pthread_rdwr_wlock_np(& domainlock);
#line 633
  list->active = -1;
#line 634
  pthread_rdwr_wunlock_np(& domainlock);
#line 641
  pthread_rdwr_rlock_np(& domainlock);
#line 643
  in_use = list;
#line 645
  status = clnt_broadcast(100004UL, 2UL, 2UL, (bool_t (*)(XDR * , void *  , ...))(& ypbind_xdr_domainname),
                          (char *)((void *)(& domain___0)), (bool_t (*)(XDR * , void *
                                                                        , ...))(& xdr_bool),
                          (char *)((void *)(& out)), (bool_t (*)(caddr_t resp , struct sockaddr_in *raddr ))(& eachresult));
#line 651
  if ((int )status != 0) {
#line 653
    remove_bindingfile((char const   *)domain___0);
#line 654
    tmp___3 = clnt_sperrno(status);
#line 654
    log_msg(3, "broadcast: %s.", tmp___3);
  } else {
#line 657
    update_bindingfile(list);
  }
#line 659
  pthread_rdwr_runlock_np(& domainlock);
#line 661
  if (debug_flag) {
#line 662
    tmp___4 = dcgettext((char const   *)((void *)0), "leave do_broadcast() for domain \'%s\'",
                        5);
#line 662
    log_msg(7, (char const   *)tmp___4, domain___0);
  }
#line 664
  return;
}
}
#line 668 "serv_list.c"
static struct timeval timeout  =    {(__time_t )1, (__suseconds_t )0};
#line 669 "serv_list.c"
static struct timeval tottimeout  =    {(__time_t )1, (__suseconds_t )0};
#line 676 "serv_list.c"
static u_short __pmap_getport(struct sockaddr_in *address , u_long program , u_long version ,
                              u_int protocol )
{ u_short rport ;
  int sock ;
  CLIENT *client ;
  struct pmap parms ;
  register unsigned short __v ;
  register unsigned short __x ;
  enum clnt_stat tmp ;

  {
#line 680
  rport = (u_short )0;
#line 681
  sock = -1;
#line 685
  __x = (unsigned short)111;
#line 685
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 685
  address->sin_port = __v;
#line 687
  client = clntudp_bufcreate(address, 100000UL, 2UL, timeout, & sock, 400U, 400U);
#line 690
  if ((unsigned int )client != (unsigned int )((CLIENT *)((void *)0))) {
#line 692
    parms.pm_prog = program;
#line 693
    parms.pm_vers = version;
#line 694
    parms.pm_prot = (unsigned long )protocol;
#line 695
    parms.pm_port = 0UL;
#line 696
    tmp = ((*((client->cl_ops)->cl_call)))(client, 3UL, (bool_t (*)(XDR * , void *
                                                                    , ...))(& xdr_pmap),
                                           (char *)(& parms), (bool_t (*)(XDR * ,
                                                                          void *
                                                                          , ...))(& xdr_u_short),
                                           (char *)(& rport), tottimeout);
#line 696
    if ((int )tmp != 0) {
#line 700
      rpc_createerr.cf_stat = 14;
#line 701
      ((*((client->cl_ops)->cl_geterr)))(client, & rpc_createerr.cf_error);
    } else {
#line 703
      if ((int )rport == 0) {
#line 705
        rpc_createerr.cf_stat = 15;
      }
    }
#line 707
    ((*((client->cl_ops)->cl_destroy)))(client);
  }
#line 709
  if (sock != -1) {
#line 710
    close(sock);
  }
#line 711
  address->sin_port = (unsigned short)0;
#line 712
  return (rport);
}
}
#line 744 "serv_list.c"
static int ping_all(struct binding *list )
{ struct timeval TIMEOUT50 ;
  struct timeval TIMEOUT00 ;
  CLIENT *clnt ;
  struct findserv_req **pings ;
  struct sockaddr_in s_in ;
  struct sockaddr_in *any ;
  int found ;
  u_int32_t xid_seed ;
  u_int32_t xid_lookup ;
  int sock ;
  int dontblock ;
  bool_t clnt_res ;
  u_long i ;
  u_long pings_count ;
  struct cu_data *cu ;
  char *domain___0 ;
  time_t tmp ;
  __pid_t tmp___0 ;
  char *tmp___1 ;
  register unsigned short __v ;
  register unsigned short __x ;
  unsigned short tmp___2 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  char *tmp___3 ;
  register unsigned short __v___1 ;
  register unsigned short __x___1 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 747
  TIMEOUT50.tv_sec = (__time_t )5;
#line 747
  TIMEOUT50.tv_usec = (__suseconds_t )0;
#line 748
  TIMEOUT00.tv_sec = (__time_t )0;
#line 748
  TIMEOUT00.tv_usec = (__suseconds_t )0;
#line 751
  any = (struct sockaddr_in *)((void *)0);
#line 752
  found = -1;
#line 754
  dontblock = 1;
#line 756
  pings_count = (u_long )0;
#line 758
  domain___0 = list->domain;
#line 760
  if ((unsigned int )list->server[0].host == (unsigned int )((void *)0)) {
#line 761
    return (0);
  }
#line 763
  pthread_rdwr_wlock_np(& domainlock);
#line 764
  list->active = -1;
#line 765
  pthread_rdwr_wunlock_np(& domainlock);
#line 767
  pings = (struct findserv_req **)malloc(sizeof(struct findserv_req *) * 30U);
#line 768
  if ((unsigned int )pings == (unsigned int )((void *)0)) {
#line 769
    return (0);
  }
#line 770
  tmp = time((time_t *)((void *)0));
#line 770
  tmp___0 = getpid();
#line 770
  xid_seed = (unsigned int )(tmp ^ (long )tmp___0);
#line 772
  i = 0UL;
#line 772
  while (1) {
#line 772
    if (i < 30UL) {
#line 772
      if (! list->server[i].host) {
#line 772
        break;
      }
    } else {
#line 772
      break;
    }
#line 774
    if (debug_flag) {
#line 775
      tmp___1 = dcgettext((char const   *)((void *)0), "ping host \'%s\', domain \'%s\'",
                          5);
#line 775
      log_msg(7, (char const   *)tmp___1, list->server[i].host, list->domain);
    }
#line 778
    memset((void *)(& s_in), 0, sizeof(struct sockaddr_in ));
#line 779
    memcpy((void * __restrict  )(& s_in.sin_addr), (void const   * __restrict  )(& list->server[i].addr),
           sizeof(struct in_addr ));
#line 781
    s_in.sin_family = list->server[i].family;
#line 783
    tmp___2 = __pmap_getport(& s_in, 100004UL, 2UL, 17U);
#line 783
    __x = tmp___2;
#line 783
    __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 783
    s_in.sin_port = __v;
#line 784
    if (! broken_server) {
#line 784
      __x___1 = s_in.sin_port;
#line 784
      __asm__  ("rorw $8, %w0": "=r" (__v___1): "0" (__x___1): "cc");
#line 784
      if ((int )__v___1 >= 1024) {
#line 789
        __x___0 = s_in.sin_port;
#line 789
        __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 789
        tmp___3 = dcgettext((char const   *)((void *)0), "Answer for domain \'%s\' from \'%s\' on illegal port %d.",
                            5);
#line 789
        log_msg(3, (char const   *)tmp___3, list->domain, list->server[i].host, __v___0);
        goto __Cont;
      }
    }
#line 792
    list->server[i].port = s_in.sin_port;
#line 793
    if ((int )s_in.sin_port == 0) {
#line 795
      if (debug_flag) {
#line 796
        tmp___4 = dcgettext((char const   *)((void *)0), "host \'%s\' doesn\'t answer.",
                            5);
#line 796
        log_msg(7, (char const   *)tmp___4, list->server[i].host);
      }
      goto __Cont;
    }
#line 801
    (*(pings + pings_count)) = (struct findserv_req *)calloc(1U, sizeof(struct findserv_req ));
#line 802
    memcpy((void * __restrict  )(& ((*(pings + pings_count)))->sin), (void const   * __restrict  )(& s_in),
           sizeof(struct sockaddr_in ));
#line 803
    any = & ((*(pings + pings_count)))->sin;
#line 804
    ((*(pings + pings_count)))->xid = xid_seed;
#line 805
    ((*(pings + pings_count)))->server_nr = (unsigned int )i;
#line 806
    xid_seed ++;
#line 807
    pings_count ++;
    __Cont: /* CIL Label */
#line 772
    i ++;
  }
#line 811
  if (pings_count == 0UL) {
#line 813
    free((void *)pings);
#line 814
    return (0);
  }
#line 818
  sock = socket(2, 2, 17);
#line 819
  clnt = clntudp_create(any, 100004UL, 2UL, TIMEOUT50, & sock);
#line 820
  if ((unsigned int )clnt == (unsigned int )((void *)0)) {
#line 822
    close(sock);
#line 823
    i = 0UL;
#line 823
    while (i < pings_count) {
#line 824
      free((void *)(*(pings + i)));
#line 823
      i ++;
    }
#line 825
    free((void *)pings);
#line 826
    return (0);
  }
#line 828
  clnt->cl_auth = authunix_create_default();
#line 829
  cu = (struct cu_data *)clnt->cl_private;
#line 830
  ((*((clnt->cl_ops)->cl_control)))(clnt, 1, (char *)(& TIMEOUT00));
#line 831
  ioctl(sock, 21537UL, & dontblock);
#line 834
  i = 0UL;
#line 834
  while (i < pings_count) {
#line 837
    (*((u_int32_t *)cu->cu_outbuf)) = ((*(pings + i)))->xid - 1U;
#line 838
    memcpy((void * __restrict  )(& cu->cu_raddr), (void const   * __restrict  )(& ((*(pings + i)))->sin),
           sizeof(struct sockaddr_in ));
#line 839
    memset((void *)(& clnt_res), 0, sizeof(clnt_res));
#line 841
    ((*((clnt->cl_ops)->cl_call)))(clnt, 2UL, (bool_t (*)(XDR * , void *  , ...))(& ypbind_xdr_domainname),
                                   (char *)(& domain___0), (bool_t (*)(XDR * , void *
                                                                       , ...))(& xdr_bool),
                                   (char *)(& clnt_res), TIMEOUT00);
#line 834
    i ++;
  }
#line 847
  memset((void *)((char *)(& clnt_res)), 0, sizeof(clnt_res));
#line 848
  ((*((clnt->cl_ops)->cl_call)))(clnt, 2UL, (bool_t (*)(XDR * , void *  , ...))((void *)0),
                                 (char *)((void *)0), (bool_t (*)(XDR * , void *
                                                                  , ...))(& xdr_bool),
                                 (char *)(& clnt_res), TIMEOUT00);
#line 851
  xid_lookup = (*((u_int32_t *)(cu->cu_inbuf)));
#line 852
  close(sock);
#line 853
  i = 0UL;
#line 853
  while (i < pings_count) {
#line 855
    if (((*(pings + i)))->xid == xid_lookup) {
#line 857
      pthread_rdwr_wlock_np(& domainlock);
#line 859
      sock = -1;
#line 860
      list->client_handle = clntudp_create(& ((*(pings + i)))->sin, 100004UL, 2UL,
                                           TIMEOUT50, & sock);
#line 863
      if ((unsigned int )list->client_handle == (unsigned int )((void *)0)) {
#line 866
        tmp___5 = dcgettext((char const   *)((void *)0), "Server \'%s\' for domain \'%s\' answer to ping but failed to bind",
                            5);
#line 866
        log_msg(7, (char const   *)tmp___5, list->server[list->active].host, domain___0);
      } else {
#line 872
        list->active = (int )((*(pings + i)))->server_nr;
#line 873
        pthread_rdwr_wunlock_np(& domainlock);
#line 874
        pthread_rdwr_rlock_np(& domainlock);
#line 875
        update_bindingfile(list);
#line 876
        pthread_rdwr_runlock_np(& domainlock);
#line 877
        if (debug_flag) {
#line 878
          tmp___6 = dcgettext((char const   *)((void *)0), "Answer for domain \'%s\' from server \'%s\'",
                              5);
#line 878
          log_msg(7, (char const   *)tmp___6, domain___0, list->server[list->active].host);
        }
#line 881
        found = 1;
      }
    }
#line 853
    i ++;
  }
#line 886
  ((*(((clnt->cl_auth)->ah_ops)->ah_destroy)))(clnt->cl_auth);
#line 887
  ((*((clnt->cl_ops)->cl_destroy)))(clnt);
#line 889
  i = 0UL;
#line 889
  while (i < pings_count) {
#line 890
    free((void *)(*(pings + i)));
#line 889
    i ++;
  }
#line 891
  free((void *)pings);
#line 893
  if (! found) {
#line 894
    remove_bindingfile((char const   *)(list->domain));
  }
#line 896
  return (found);
}
}
#line 996 "serv_list.c"
void do_binding(void)
{ int i ;
  int tmp ;

  {
#line 1001
  pthread_mutex_lock(& search_lock);
#line 1002
  i = 0;
#line 1002
  while (i < max_domains) {
#line 1004
    tmp = ping_all(domainlist + i);
#line 1004
    if (! tmp) {
#line 1004
      if ((domainlist + i)->use_broadcast) {
#line 1005
        do_broadcast(domainlist + i);
      }
    }
#line 1002
    i ++;
  }
#line 1007
  pthread_mutex_unlock(& search_lock);
#line 1008
  return;
}
}
#line 1016 "serv_list.c"
static int success  =    0;
#line 1013 "serv_list.c"
void *test_bindings(void *param  __attribute__((__unused__)) )
{ int lastcheck ;

  {
#line 1017
  lastcheck = 0;
#line 1019
  do_binding();
#line 1021
  if (ping_interval < 1) {
#line 1022
    pthread_exit((void *)(& success));
  }
#line 1024
  while (1) {
#line 1026
    sleep((unsigned int )ping_interval);
#line 1030
    if (ping_interval < 1) {
#line 1031
      pthread_exit((void *)(& success));
    }
#line 1033
    lastcheck += ping_interval;
#line 1034
    if (lastcheck >= 900) {
#line 1035
      lastcheck = 0;
    }
#line 1037
    lastcheck = test_bindings_once(lastcheck, (char const   *)((void *)0));
  }
}
}
#line 1042 "serv_list.c"
int test_bindings_once(int lastcheck , char const   *req_domain )
{ int i ;
  char *tmp ;
  char *tmp___0 ;
  char *domain___0 ;
  bool_t out ;
  enum clnt_stat status ;
  char *tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  struct timeval time_out ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 1050
  pthread_rdwr_wlock_np(& domainlock);
#line 1052
  if (debug_flag) {
#line 1054
    if (lastcheck) {
#line 1055
      tmp = dcgettext((char const   *)((void *)0), "Pinging all active server.", 5);
#line 1055
      log_msg(7, (char const   *)tmp);
    } else {
#line 1057
      tmp___0 = dcgettext((char const   *)((void *)0), "Check new for fastest server.",
                          5);
#line 1057
      log_msg(7, (char const   *)tmp___0);
    }
  }
#line 1060
  i = 0;
#line 1060
  while (i < max_domains) {
#line 1062
    domain___0 = (domainlist + i)->domain;
#line 1063
    out = 1;
#line 1064
    status = 0;
#line 1066
    if (req_domain) {
#line 1066
      if (0) {
#line 1066
        __s1_len = strlen((char const   *)domain___0);
#line 1066
        __s2_len = strlen(req_domain);
#line 1066
        if (! ((unsigned int )((void const   *)(domain___0 + 1)) - (unsigned int )((void const   *)domain___0) == 1U)) {
          goto _L___0;
        } else {
#line 1066
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */
#line 1066
            if (! ((unsigned int )((void const   *)(req_domain + 1)) - (unsigned int )((void const   *)req_domain) == 1U)) {
#line 1066
              tmp___11 = 1;
            } else {
#line 1066
              if (__s2_len >= 4U) {
#line 1066
                tmp___11 = 1;
              } else {
#line 1066
                tmp___11 = 0;
              }
            }
          } else {
#line 1066
            tmp___11 = 0;
          }
        }
#line 1066
        if (tmp___11) {
#line 1066
          tmp___7 = __builtin_strcmp((char const   *)domain___0, req_domain);
        } else {
#line 1066
          tmp___10 = __builtin_strcmp((char const   *)domain___0, req_domain);
#line 1066
          tmp___7 = tmp___10;
        }
      } else {
#line 1066
        tmp___10 = __builtin_strcmp((char const   *)domain___0, req_domain);
#line 1066
        tmp___7 = tmp___10;
      }
#line 1066
      if (tmp___7 != 0) {
#line 1068
        if (debug_flag) {
#line 1069
          tmp___1 = dcgettext((char const   *)((void *)0), "Requested domain %s, found %s, ignored.",
                              5);
#line 1069
          log_msg(7, (char const   *)tmp___1, req_domain, domain___0);
        }
        goto __Cont;
      }
    }
#line 1075
    if ((unsigned int )(domainlist + i)->client_handle == (unsigned int )((void *)0)) {
#line 1075
      if ((domainlist + i)->active != -1) {
#line 1077
        log_msg(3, "ALERT: active=%d, but client_handle is NULL!", (domainlist + i)->active);
#line 1079
        (domainlist + i)->active = -1;
      }
    }
#line 1082
    if ((domainlist + i)->active != -1) {
#line 1086
      if (lastcheck != 0) {
#line 1091
        time_out.tv_sec = 3L;
#line 1092
        time_out.tv_usec = 0L;
#line 1093
        status = ((*((((domainlist + i)->client_handle)->cl_ops)->cl_call)))((domainlist + i)->client_handle,
                                                                             1UL,
                                                                             (bool_t (*)(XDR * ,
                                                                                         void *
                                                                                         , ...))(& ypbind_xdr_domainname),
                                                                             (char *)(& domain___0),
                                                                             (bool_t (*)(XDR * ,
                                                                                         void *
                                                                                         , ...))(& xdr_bool),
                                                                             (char *)(& out),
                                                                             time_out);
      }
#line 1103
      if (lastcheck == 0) {
#line 1103
        if ((domainlist + i)->active != -2) {
          goto _L___1;
        } else {
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */
#line 1103
        if ((int )status != 0) {
          goto _L___1;
        } else {
#line 1103
          if (out != 1) {
            _L___1: /* CIL Label */
#line 1108
            if (debug_flag) {
#line 1108
              if (lastcheck != 0) {
#line 1112
                if ((domainlist + i)->use_broadcast) {
#line 1113
                  tmp___12 = dcgettext((char const   *)((void *)0), "Server for domain \'%s\' doesn\'t answer.",
                                       5);
#line 1113
                  log_msg(7, (char const   *)tmp___12, domain___0);
                } else {
#line 1118
                  if ((domainlist + i)->active == -2) {
#line 1119
                    tmp___13 = inet_ntoa((domainlist + i)->ypset.addr);
#line 1119
                    tmp___14 = dcgettext((char const   *)((void *)0), "Server \'%s\' for domain \'%s\' doesn\'t answer.",
                                         5);
#line 1119
                    log_msg(7, (char const   *)tmp___14, tmp___13, domain___0);
                  } else {
#line 1124
                    tmp___15 = dcgettext((char const   *)((void *)0), "Server \'%s\' for domain \'%s\' doesn\'t answer.",
                                         5);
#line 1124
                    log_msg(7, (char const   *)tmp___15, (domainlist + i)->server[(domainlist + i)->active].host,
                            domain___0);
                  }
                }
              }
            }
#line 1133
            if ((unsigned int )(domainlist + i)->client_handle == (unsigned int )((void *)0)) {
#line 1135
              log_msg(3, "ALERT: client_handle=NULL, active=%d, lastcheck=%d, domain=%s",
                      (domainlist + i)->active, lastcheck, domain___0);
            } else {
#line 1139
              ((*((((domainlist + i)->client_handle)->cl_ops)->cl_destroy)))((domainlist + i)->client_handle);
            }
#line 1140
            (domainlist + i)->client_handle = (CLIENT *)((void *)0);
#line 1141
            if ((domainlist + i)->active == -2) {
#line 1145
              if ((unsigned int )(domainlist + i)->ypset.host != (unsigned int )((void *)0)) {
#line 1146
                free((void *)(domainlist + i)->ypset.host);
              }
#line 1147
              (domainlist + i)->ypset.host = (char *)((void *)0);
            }
#line 1149
            (domainlist + i)->active = -1;
#line 1150
            lastcheck = 0;
#line 1154
            pthread_rdwr_wunlock_np(& domainlock);
#line 1155
            pthread_mutex_lock(& search_lock);
#line 1156
            tmp___16 = ping_all(domainlist + i);
#line 1156
            if (! tmp___16) {
#line 1156
              if ((domainlist + i)->use_broadcast) {
#line 1158
                do_broadcast(domainlist + i);
              }
            }
#line 1159
            pthread_mutex_unlock(& search_lock);
#line 1160
            pthread_rdwr_wlock_np(& domainlock);
          }
        }
      }
    } else {
#line 1167
      pthread_rdwr_wunlock_np(& domainlock);
#line 1168
      pthread_mutex_lock(& search_lock);
#line 1169
      tmp___17 = ping_all(domainlist + i);
#line 1169
      if (! tmp___17) {
#line 1169
        if ((domainlist + i)->use_broadcast) {
#line 1170
          do_broadcast(domainlist + i);
        }
      }
#line 1171
      pthread_mutex_unlock(& search_lock);
#line 1172
      pthread_rdwr_wlock_np(& domainlock);
    }
    __Cont: /* CIL Label */
#line 1060
    i ++;
  }
#line 1176
  pthread_rdwr_wunlock_np(& domainlock);
#line 1178
  return (lastcheck);
}
}
#line 1 "pthread_np.o"
#pragma merger(0,"/tmp/cil-KRVFXT38.i","-Wall,-g,-O2")
#line 716 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t const   *__mutexattr )  __attribute__((__nonnull__(1))) ;
#line 923
extern  __attribute__((__nothrow__)) int pthread_cond_init(pthread_cond_t * __restrict  __cond ,
                                                           pthread_condattr_t const   * __restrict  __cond_attr )  __attribute__((__nonnull__(1))) ;
#line 932
extern  __attribute__((__nothrow__)) int pthread_cond_signal(pthread_cond_t *__cond )  __attribute__((__nonnull__(1))) ;
#line 38 "./pthread_np.h"
int pthread_rdwr_init_np(pthread_rdwr_t *rdwrp ) ;
#line 24 "pthread_np.c"
int pthread_rdwr_init_np(pthread_rdwr_t *rdwrp )
{

  {
#line 27
  rdwrp->readers = 0;
#line 28
  rdwrp->writers = 0;
#line 29
  rdwrp->wishwrite = 0;
#line 30
  pthread_mutex_init(& rdwrp->mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 31
  pthread_cond_init((pthread_cond_t * __restrict  )(& rdwrp->lock_free), (pthread_condattr_t const   * __restrict  )((void *)0));
#line 32
  return (0);
}
}
#line 35 "pthread_np.c"
int pthread_rdwr_rlock_np(pthread_rdwr_t *rdwrp )
{

  {
#line 38
  pthread_mutex_lock(& rdwrp->mutex);
#line 40
  while (1) {
#line 40
    if (! rdwrp->writers) {
#line 40
      if (! rdwrp->wishwrite) {
#line 40
        break;
      }
    }
#line 41
    pthread_cond_wait((pthread_cond_t * __restrict  )(& rdwrp->lock_free), (pthread_mutex_t * __restrict  )(& rdwrp->mutex));
  }
#line 43
  rdwrp->readers ++;
#line 44
  pthread_mutex_unlock(& rdwrp->mutex);
#line 45
  return (0);
}
}
#line 48 "pthread_np.c"
int pthread_rdwr_wlock_np(pthread_rdwr_t *rdwrp )
{

  {
#line 51
  pthread_mutex_lock(& rdwrp->mutex);
#line 52
  rdwrp->wishwrite ++;
#line 53
  while (1) {
#line 53
    if (! rdwrp->writers) {
#line 53
      if (! rdwrp->readers) {
#line 53
        break;
      }
    }
#line 54
    pthread_cond_wait((pthread_cond_t * __restrict  )(& rdwrp->lock_free), (pthread_mutex_t * __restrict  )(& rdwrp->mutex));
  }
#line 55
  rdwrp->writers ++;
#line 56
  rdwrp->wishwrite --;
#line 57
  pthread_mutex_unlock(& rdwrp->mutex);
#line 58
  return (0);
}
}
#line 61 "pthread_np.c"
int pthread_rdwr_runlock_np(pthread_rdwr_t *rdwrp )
{ int status ;

  {
#line 66
  pthread_mutex_lock(& rdwrp->mutex);
#line 67
  if (rdwrp->readers == 0) {
#line 69
    status = -1;
  } else {
#line 73
    rdwrp->readers --;
#line 74
    if (rdwrp->readers == 0) {
#line 75
      pthread_cond_signal(& rdwrp->lock_free);
    }
#line 76
    status = 0;
  }
#line 78
  pthread_mutex_unlock(& rdwrp->mutex);
#line 79
  return (status);
}
}
#line 82 "pthread_np.c"
int pthread_rdwr_wunlock_np(pthread_rdwr_t *rdwrp )
{ int status ;

  {
#line 87
  pthread_mutex_lock(& rdwrp->mutex);
#line 88
  if (rdwrp->writers == 0) {
#line 90
    status = -1;
  } else {
#line 94
    rdwrp->writers = 0;
#line 95
    pthread_cond_broadcast(& rdwrp->lock_free);
#line 96
    status = 0;
  }
#line 98
  pthread_mutex_unlock(& rdwrp->mutex);
#line 99
  return (status);
}
}
#line 1 "ypbind_slp.o"
#pragma merger(0,"/tmp/cil-WCpVn6U1.i","-Wall,-g,-O2")
