typedef long ptrdiff_t;
typedef unsigned long size_t;
typedef int wchar_t;
struct __anonstruct_max_align_t_896270833 {
   long long __max_align_ll __attribute__((__aligned__(__alignof__(long long )))) ;
   long double __max_align_ld __attribute__((__aligned__(__alignof__(long double )))) ;
};
typedef struct __anonstruct_max_align_t_896270833 max_align_t;
typedef unsigned char __u_char;
typedef unsigned short __u_short;
typedef unsigned int __u_int;
typedef unsigned long __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long __int64_t;
typedef unsigned long __uint64_t;
typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;
typedef long __quad_t;
typedef unsigned long __u_quad_t;
typedef long __intmax_t;
typedef unsigned long __uintmax_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned long __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
struct __anonstruct___fsid_t_109580352 {
   int __val[2] ;
};
typedef struct __anonstruct___fsid_t_109580352 __fsid_t;
typedef long __clock_t;
typedef unsigned long __rlim_t;
typedef unsigned long __rlim64_t;
typedef unsigned int __id_t;
typedef long __time_t;
typedef unsigned int __useconds_t;
typedef long __suseconds_t;
typedef long __suseconds64_t;
typedef int __daddr_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void *__timer_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __blkcnt64_t;
typedef unsigned long __fsblkcnt_t;
typedef unsigned long __fsblkcnt64_t;
typedef unsigned long __fsfilcnt_t;
typedef unsigned long __fsfilcnt64_t;
typedef long __fsword_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef unsigned long __syscall_ulong_t;
typedef __off64_t __loff_t;
typedef char *__caddr_t;
typedef long __intptr_t;
typedef unsigned int __socklen_t;
typedef int __sig_atomic_t;
typedef __time_t time_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
typedef __pid_t pid_t;
struct sched_param {
   int sched_priority ;
};
typedef unsigned long __cpu_mask;
struct __anonstruct_cpu_set_t_826868708 {
   __cpu_mask __bits[1024UL / (8UL * sizeof(__cpu_mask ))] ;
};
typedef struct __anonstruct_cpu_set_t_826868708 cpu_set_t;
typedef __clock_t clock_t;
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const *tm_zone ;
};
typedef __clockid_t clockid_t;
typedef __timer_t timer_t;
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
struct sigevent ;
struct __locale_data ;
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const *__ctype_b ;
   int const *__ctype_tolower ;
   int const *__ctype_toupper ;
   char const *__names[13] ;
};
typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
struct __anonstruct___value32_817613185 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion___atomic_wide_counter_995974906 {
   unsigned long long __value64 ;
   struct __anonstruct___value32_817613185 __value32 ;
};
typedef union __anonunion___atomic_wide_counter_995974906 __atomic_wide_counter;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
typedef struct __pthread_internal_slist __pthread_slist_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
struct __pthread_cond_s {
   __atomic_wide_counter __wseq ;
   __atomic_wide_counter __g1_start ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
typedef unsigned int __tss_t;
typedef unsigned long __thrd_t;
struct __anonstruct___once_flag_995974907 {
   int __data ;
};
typedef struct __anonstruct___once_flag_995974907 __once_flag;
typedef unsigned long pthread_t;
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_condattr_t_488594145 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_condattr_t_488594145 pthread_condattr_t;
typedef unsigned int pthread_key_t;
typedef int pthread_once_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
union __anonunion_pthread_cond_t_951761805 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_951761805 pthread_cond_t;
union __anonunion_pthread_rwlock_t_656928968 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
typedef union __anonunion_pthread_rwlock_t_656928968 pthread_rwlock_t;
union __anonunion_pthread_rwlockattr_t_145707745 {
   char __size[8] ;
   long __align ;
};
typedef union __anonunion_pthread_rwlockattr_t_145707745 pthread_rwlockattr_t;
typedef int volatile pthread_spinlock_t;
union __anonunion_pthread_barrier_t_145707746 {
   char __size[32] ;
   long __align ;
};
typedef union __anonunion_pthread_barrier_t_145707746 pthread_barrier_t;
union __anonunion_pthread_barrierattr_t_951761806 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_barrierattr_t_951761806 pthread_barrierattr_t;
typedef long __jmp_buf[8];
struct __anonstruct___sigset_t_764561023 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_764561023 __sigset_t;
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
enum __anonenum_34415463 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1
} ;
enum __anonenum_508643754 {
    PTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP = 3,
    PTHREAD_MUTEX_NORMAL = 0,
    PTHREAD_MUTEX_RECURSIVE = 1,
    PTHREAD_MUTEX_ERRORCHECK = 2,
    PTHREAD_MUTEX_DEFAULT = 0
} ;
enum __anonenum_931900394 {
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_STALLED_NP = 0,
    PTHREAD_MUTEX_ROBUST = 1,
    PTHREAD_MUTEX_ROBUST_NP = 1
} ;
enum __anonenum_205214487 {
    PTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECT = 2
} ;
enum __anonenum_25043950 {
    PTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
    PTHREAD_RWLOCK_DEFAULT_NP = 0
} ;
enum __anonenum_436439511 {
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1
} ;
enum __anonenum_998661166 {
    PTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESS = 1
} ;
enum __anonenum_146137331 {
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1
} ;
struct _pthread_cleanup_buffer {
   void (*__routine)(void * ) ;
   void *__arg ;
   int __canceltype ;
   struct _pthread_cleanup_buffer *__prev ;
};
enum __anonenum_53396917 {
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1
} ;
enum __anonenum_904563783 {
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1
} ;
struct __cancel_jmp_buf_tag {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
struct __anonstruct___pthread_unwind_buf_t_530692248 {
   struct __cancel_jmp_buf_tag __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
typedef struct __anonstruct___pthread_unwind_buf_t_530692248 __attribute__((__aligned__)) __pthread_unwind_buf_t;
struct __pthread_cleanup_frame {
   void (*__cancel_routine)(void * ) ;
   void *__cancel_arg ;
   int __do_it ;
   int __cancel_type ;
};
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;
typedef __loff_t loff_t;
typedef __ino_t ino_t;
typedef __ino64_t ino64_t;
typedef __dev_t dev_t;
typedef __gid_t gid_t;
typedef __mode_t mode_t;
typedef __nlink_t nlink_t;
typedef __uid_t uid_t;
typedef __off_t off_t;
typedef __off64_t off64_t;
typedef __id_t id_t;
typedef __ssize_t ssize_t;
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;
typedef __key_t key_t;
typedef __useconds_t useconds_t;
typedef __suseconds_t suseconds_t;
typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;
typedef int register_t;
typedef __sigset_t sigset_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
typedef long __fd_mask;
struct __anonstruct_fd_set_356711149 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
typedef struct __anonstruct_fd_set_356711149 fd_set;
typedef __fd_mask fd_mask;
typedef __blksize_t blksize_t;
typedef __blkcnt_t blkcnt_t;
typedef __fsblkcnt_t fsblkcnt_t;
typedef __fsfilcnt_t fsfilcnt_t;
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;
typedef __socklen_t socklen_t;
enum __socket_type {
    SOCK_STREAM = 1,
    SOCK_DGRAM = 2,
    SOCK_RAW = 3,
    SOCK_RDM = 4,
    SOCK_SEQPACKET = 5,
    SOCK_DCCP = 6,
    SOCK_PACKET = 10,
    SOCK_CLOEXEC = 524288,
    SOCK_NONBLOCK = 2048
} ;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct sockaddr_storage {
   sa_family_t ss_family ;
   char __ss_padding[(128UL - sizeof(unsigned short )) - sizeof(unsigned long )] ;
   unsigned long __ss_align ;
};
enum __anonenum_83571709 {
    MSG_OOB = 1,
    MSG_PEEK = 2,
    MSG_DONTROUTE = 4,
    MSG_TRYHARD = 4,
    MSG_CTRUNC = 8,
    MSG_PROXY = 16,
    MSG_TRUNC = 32,
    MSG_DONTWAIT = 64,
    MSG_EOR = 128,
    MSG_WAITALL = 256,
    MSG_FIN = 512,
    MSG_SYN = 1024,
    MSG_CONFIRM = 2048,
    MSG_RST = 4096,
    MSG_ERRQUEUE = 8192,
    MSG_NOSIGNAL = 16384,
    MSG_MORE = 32768,
    MSG_WAITFORONE = 65536,
    MSG_BATCH = 262144,
    MSG_ZEROCOPY = 67108864,
    MSG_FASTOPEN = 536870912,
    MSG_CMSG_CLOEXEC = 1073741824
} ;
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
enum __anonenum_617082774 {
    SCM_RIGHTS = 1,
    SCM_CREDENTIALS = 2
} ;
struct ucred {
   pid_t pid ;
   uid_t uid ;
   gid_t gid ;
};
struct __anonstruct___kernel_fd_set_603278005 {
   unsigned long fds_bits[1024UL / (8UL * sizeof(long ))] ;
};
typedef struct __anonstruct___kernel_fd_set_603278005 __kernel_fd_set;
typedef void (*__kernel_sighandler_t)(int );
typedef int __kernel_key_t;
typedef int __kernel_mqd_t;
typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;
typedef unsigned long __kernel_old_dev_t;
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;
typedef __kernel_ulong_t __kernel_ino_t;
typedef unsigned int __kernel_mode_t;
typedef int __kernel_pid_t;
typedef int __kernel_ipc_pid_t;
typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;
typedef __kernel_long_t __kernel_suseconds_t;
typedef int __kernel_daddr_t;
typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_ptrdiff_t;
struct __anonstruct___kernel_fsid_t_951761807 {
   int val[2] ;
};
typedef struct __anonstruct___kernel_fsid_t_951761807 __kernel_fsid_t;
typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_old_time_t;
typedef __kernel_long_t __kernel_time_t;
typedef long long __kernel_time64_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char *__kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
struct linger {
   int l_onoff ;
   int l_linger ;
};
struct osockaddr {
   unsigned short sa_family ;
   unsigned char sa_data[14] ;
};
enum __anonenum_606441560 {
    SHUT_RD = 0,
    SHUT_WR = 1,
    SHUT_RDWR = 2
} ;
struct sockaddr_at ;
struct sockaddr_ax25 ;
struct sockaddr_dl ;
struct sockaddr_eon ;
struct sockaddr_in ;
struct sockaddr_in6 ;
struct sockaddr_inarp ;
struct sockaddr_ipx ;
struct sockaddr_iso ;
struct sockaddr_ns ;
struct sockaddr_un ;
struct sockaddr_x25 ;
union __anonunion___SOCKADDR_ARG_627422263 {
   struct sockaddr * __restrict __sockaddr__ ;
   struct sockaddr_at * __restrict __sockaddr_at__ ;
   struct sockaddr_ax25 * __restrict __sockaddr_ax25__ ;
   struct sockaddr_dl * __restrict __sockaddr_dl__ ;
   struct sockaddr_eon * __restrict __sockaddr_eon__ ;
   struct sockaddr_in * __restrict __sockaddr_in__ ;
   struct sockaddr_in6 * __restrict __sockaddr_in6__ ;
   struct sockaddr_inarp * __restrict __sockaddr_inarp__ ;
   struct sockaddr_ipx * __restrict __sockaddr_ipx__ ;
   struct sockaddr_iso * __restrict __sockaddr_iso__ ;
   struct sockaddr_ns * __restrict __sockaddr_ns__ ;
   struct sockaddr_un * __restrict __sockaddr_un__ ;
   struct sockaddr_x25 * __restrict __sockaddr_x25__ ;
};
typedef union __anonunion___SOCKADDR_ARG_627422263 __attribute__((__transparent_union__)) __SOCKADDR_ARG;
union __anonunion___CONST_SOCKADDR_ARG_307618866 {
   struct sockaddr const * __restrict __sockaddr__ ;
   struct sockaddr_at const * __restrict __sockaddr_at__ ;
   struct sockaddr_ax25 const * __restrict __sockaddr_ax25__ ;
   struct sockaddr_dl const * __restrict __sockaddr_dl__ ;
   struct sockaddr_eon const * __restrict __sockaddr_eon__ ;
   struct sockaddr_in const * __restrict __sockaddr_in__ ;
   struct sockaddr_in6 const * __restrict __sockaddr_in6__ ;
   struct sockaddr_inarp const * __restrict __sockaddr_inarp__ ;
   struct sockaddr_ipx const * __restrict __sockaddr_ipx__ ;
   struct sockaddr_iso const * __restrict __sockaddr_iso__ ;
   struct sockaddr_ns const * __restrict __sockaddr_ns__ ;
   struct sockaddr_un const * __restrict __sockaddr_un__ ;
   struct sockaddr_x25 const * __restrict __sockaddr_x25__ ;
};
typedef union __anonunion___CONST_SOCKADDR_ARG_307618866 __attribute__((__transparent_union__)) __CONST_SOCKADDR_ARG;
struct mmsghdr {
   struct msghdr msg_hdr ;
   unsigned int msg_len ;
};
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
struct ip_opts {
   struct in_addr ip_dst ;
   char ip_opts[40] ;
};
struct ip_mreqn {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_address ;
   int imr_ifindex ;
};
struct in_pktinfo {
   int ipi_ifindex ;
   struct in_addr ipi_spec_dst ;
   struct in_addr ipi_addr ;
};
enum __anonenum_264779956 {
    IPPROTO_IP = 0,
    IPPROTO_ICMP = 1,
    IPPROTO_IGMP = 2,
    IPPROTO_IPIP = 4,
    IPPROTO_TCP = 6,
    IPPROTO_EGP = 8,
    IPPROTO_PUP = 12,
    IPPROTO_UDP = 17,
    IPPROTO_IDP = 22,
    IPPROTO_TP = 29,
    IPPROTO_DCCP = 33,
    IPPROTO_IPV6 = 41,
    IPPROTO_RSVP = 46,
    IPPROTO_GRE = 47,
    IPPROTO_ESP = 50,
    IPPROTO_AH = 51,
    IPPROTO_MTP = 92,
    IPPROTO_BEETPH = 94,
    IPPROTO_ENCAP = 98,
    IPPROTO_PIM = 103,
    IPPROTO_COMP = 108,
    IPPROTO_SCTP = 132,
    IPPROTO_UDPLITE = 136,
    IPPROTO_MPLS = 137,
    IPPROTO_ETHERNET = 143,
    IPPROTO_RAW = 255,
    IPPROTO_MPTCP = 262,
    IPPROTO_MAX = 263
} ;
enum __anonenum_218739988 {
    IPPROTO_HOPOPTS = 0,
    IPPROTO_ROUTING = 43,
    IPPROTO_FRAGMENT = 44,
    IPPROTO_ICMPV6 = 58,
    IPPROTO_NONE = 59,
    IPPROTO_DSTOPTS = 60,
    IPPROTO_MH = 135
} ;
typedef uint16_t in_port_t;
enum __anonenum_662268580 {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,
    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,
    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,
    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,
    IPPORT_RESERVED = 1024,
    IPPORT_USERRESERVED = 5000
} ;
union __anonunion___in6_u_979734923 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
struct in6_addr {
   union __anonunion___in6_u_979734923 __in6_u ;
};
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
struct ip_mreq {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_interface ;
};
struct ip_mreq_source {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_interface ;
   struct in_addr imr_sourceaddr ;
};
struct ipv6_mreq {
   struct in6_addr ipv6mr_multiaddr ;
   unsigned int ipv6mr_interface ;
};
struct group_req {
   uint32_t gr_interface ;
   struct sockaddr_storage gr_group ;
};
struct group_source_req {
   uint32_t gsr_interface ;
   struct sockaddr_storage gsr_group ;
   struct sockaddr_storage gsr_source ;
};
struct ip_msfilter {
   struct in_addr imsf_multiaddr ;
   struct in_addr imsf_interface ;
   uint32_t imsf_fmode ;
   uint32_t imsf_numsrc ;
   struct in_addr imsf_slist[1] ;
};
struct group_filter {
   uint32_t gf_interface ;
   struct sockaddr_storage gf_group ;
   uint32_t gf_fmode ;
   uint32_t gf_numsrc ;
   struct sockaddr_storage gf_slist[1] ;
};
struct in6_pktinfo {
   struct in6_addr ipi6_addr ;
   unsigned int ipi6_ifindex ;
};
struct ip6_mtuinfo {
   struct sockaddr_in6 ip6m_addr ;
   uint32_t ip6m_mtu ;
};
enum __anonenum_18926444 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8
} ;
typedef int error_t;
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
struct flock64 {
   short l_type ;
   short l_whence ;
   __off64_t l_start ;
   __off64_t l_len ;
   __pid_t l_pid ;
};
enum __pid_type {
    F_OWNER_TID = 0,
    F_OWNER_PID = 1,
    F_OWNER_PGRP = 2,
    F_OWNER_GID = 2
} ;
struct f_owner_ex {
   enum __pid_type type ;
   __pid_t pid ;
};
struct file_handle {
   unsigned int handle_bytes ;
   int handle_type ;
   unsigned char f_handle[0] ;
};
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct dirent ;
struct __anonstruct_glob_t_915404294 {
   size_t gl_pathc ;
   char **gl_pathv ;
   size_t gl_offs ;
   int gl_flags ;
   void (*gl_closedir)(void * ) ;
   struct dirent *(*gl_readdir)(void * ) ;
   void *(*gl_opendir)(char const * ) ;
   int (*gl_lstat)(char const * , struct stat * ) ;
   int (*gl_stat)(char const * , struct stat * ) ;
};
typedef struct __anonstruct_glob_t_915404294 glob_t;
struct dirent64 ;
struct __anonstruct_glob64_t_870456264 {
   size_t gl_pathc ;
   char **gl_pathv ;
   size_t gl_offs ;
   int gl_flags ;
   void (*gl_closedir)(void * ) ;
   struct dirent64 *(*gl_readdir)(void * ) ;
   void *(*gl_opendir)(char const * ) ;
   int (*gl_lstat)(char const * , struct stat64 * ) ;
   int (*gl_stat)(char const * , struct stat64 * ) ;
};
typedef struct __anonstruct_glob64_t_870456264 glob64_t;
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;
typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;
typedef signed char int_fast8_t;
typedef long int_fast16_t;
typedef long int_fast32_t;
typedef long int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned long uint_fast16_t;
typedef unsigned long uint_fast32_t;
typedef unsigned long uint_fast64_t;
typedef long intptr_t;
typedef unsigned long uintptr_t;
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
typedef int __gwchar_t;
struct __anonstruct_imaxdiv_t_790849867 {
   long quot ;
   long rem ;
};
typedef struct __anonstruct_imaxdiv_t_790849867 imaxdiv_t;
typedef float float_t;
typedef double double_t;
enum __anonenum_913965969 {
    FP_INT_UPWARD = 0,
    FP_INT_DOWNWARD = 1,
    FP_INT_TOWARDZERO = 2,
    FP_INT_TONEARESTFROMZERO = 3,
    FP_INT_TONEAREST = 4
} ;
enum __anonenum_1037408945 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4
} ;
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
typedef __sig_atomic_t sig_atomic_t;
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval __sigval_t;
struct __anonstruct__kill_244518854 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
struct __anonstruct__timer_490064738 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
struct __anonstruct__rt_619254530 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
struct __anonstruct__sigchld_284671705 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
struct __anonstruct__addr_bnd_5259977 {
   void *_lower ;
   void *_upper ;
};
union __anonunion__bounds_1056015325 {
   struct __anonstruct__addr_bnd_5259977 _addr_bnd ;
   __uint32_t _pkey ;
};
struct __anonstruct__sigfault_855399223 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion__bounds_1056015325 _bounds ;
};
struct __anonstruct__sigpoll_386613454 {
   long si_band ;
   int si_fd ;
};
struct __anonstruct__sigsys_634745154 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
union __anonunion__sifields_758673759 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_244518854 _kill ;
   struct __anonstruct__timer_490064738 _timer ;
   struct __anonstruct__rt_619254530 _rt ;
   struct __anonstruct__sigchld_284671705 _sigchld ;
   struct __anonstruct__sigfault_855399223 _sigfault ;
   struct __anonstruct__sigpoll_386613454 _sigpoll ;
   struct __anonstruct__sigsys_634745154 _sigsys ;
};
struct __anonstruct_siginfo_t_432001254 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion__sifields_758673759 _sifields ;
};
typedef struct __anonstruct_siginfo_t_432001254 siginfo_t;
enum __anonenum_556971655 {
    SI_ASYNCNL = -60,
    SI_DETHREAD = -7,
    SI_TKILL = -6,
    SI_SIGIO = -5,
    SI_ASYNCIO = -4,
    SI_MESGQ = -3,
    SI_TIMER = -2,
    SI_QUEUE = -1,
    SI_USER = 0,
    SI_KERNEL = 128
} ;
enum __anonenum_640648963 {
    ILL_ILLOPC = 1,
    ILL_ILLOPN = 2,
    ILL_ILLADR = 3,
    ILL_ILLTRP = 4,
    ILL_PRVOPC = 5,
    ILL_PRVREG = 6,
    ILL_COPROC = 7,
    ILL_BADSTK = 8,
    ILL_BADIADDR = 9
} ;
enum __anonenum_457704180 {
    FPE_INTDIV = 1,
    FPE_INTOVF = 2,
    FPE_FLTDIV = 3,
    FPE_FLTOVF = 4,
    FPE_FLTUND = 5,
    FPE_FLTRES = 6,
    FPE_FLTINV = 7,
    FPE_FLTSUB = 8,
    FPE_FLTUNK = 14,
    FPE_CONDTRAP = 15
} ;
enum __anonenum_180375148 {
    SEGV_MAPERR = 1,
    SEGV_ACCERR = 2,
    SEGV_BNDERR = 3,
    SEGV_PKUERR = 4,
    SEGV_ACCADI = 5,
    SEGV_ADIDERR = 6,
    SEGV_ADIPERR = 7,
    SEGV_MTEAERR = 8,
    SEGV_MTESERR = 9
} ;
enum __anonenum_1036286214 {
    BUS_ADRALN = 1,
    BUS_ADRERR = 2,
    BUS_OBJERR = 3,
    BUS_MCEERR_AR = 4,
    BUS_MCEERR_AO = 5
} ;
enum __anonenum_91015150 {
    TRAP_BRKPT = 1,
    TRAP_TRACE = 2,
    TRAP_BRANCH = 3,
    TRAP_HWBKPT = 4,
    TRAP_UNK = 5
} ;
enum __anonenum_23175539 {
    CLD_EXITED = 1,
    CLD_KILLED = 2,
    CLD_DUMPED = 3,
    CLD_TRAPPED = 4,
    CLD_STOPPED = 5,
    CLD_CONTINUED = 6
} ;
enum __anonenum_111643124 {
    POLL_IN = 1,
    POLL_OUT = 2,
    POLL_MSG = 3,
    POLL_ERR = 4,
    POLL_PRI = 5,
    POLL_HUP = 6
} ;
typedef __sigval_t sigval_t;
struct __anonstruct__sigev_thread_746770901 {
   void (*_function)(__sigval_t ) ;
   pthread_attr_t *_attribute ;
};
union __anonunion__sigev_un_276561677 {
   int _pad[64UL / sizeof(int ) - 4UL] ;
   __pid_t _tid ;
   struct __anonstruct__sigev_thread_746770901 _sigev_thread ;
};
struct sigevent {
   __sigval_t sigev_value ;
   int sigev_signo ;
   int sigev_notify ;
   union __anonunion__sigev_un_276561677 _sigev_un ;
};
typedef struct sigevent sigevent_t;
enum __anonenum_852341087 {
    SIGEV_SIGNAL = 0,
    SIGEV_NONE = 1,
    SIGEV_THREAD = 2,
    SIGEV_THREAD_ID = 4
} ;
typedef void (*__sighandler_t)(int );
typedef void (*sighandler_t)(int );
typedef void (*sig_t)(int );
union __anonunion___sigaction_handler_363639592 {
   void (*sa_handler)(int ) ;
   void (*sa_sigaction)(int , siginfo_t * , void * ) ;
};
struct sigaction {
   union __anonunion___sigaction_handler_363639592 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
struct _fpx_sw_bytes {
   __uint32_t magic1 ;
   __uint32_t extended_size ;
   __uint64_t xstate_bv ;
   __uint32_t xstate_size ;
   __uint32_t __glibc_reserved1[7] ;
};
struct _fpreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
};
struct _fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short __glibc_reserved1[3] ;
};
struct _xmmreg {
   __uint32_t element[4] ;
};
struct _fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _fpxreg _st[8] ;
   struct _xmmreg _xmm[16] ;
   __uint32_t __glibc_reserved1[24] ;
};
union __anonunion____missing_field_name_501150464 {
   struct _fpstate *fpstate ;
   __uint64_t __fpstate_word ;
};
struct sigcontext {
   __uint64_t r8 ;
   __uint64_t r9 ;
   __uint64_t r10 ;
   __uint64_t r11 ;
   __uint64_t r12 ;
   __uint64_t r13 ;
   __uint64_t r14 ;
   __uint64_t r15 ;
   __uint64_t rdi ;
   __uint64_t rsi ;
   __uint64_t rbp ;
   __uint64_t rbx ;
   __uint64_t rdx ;
   __uint64_t rax ;
   __uint64_t rcx ;
   __uint64_t rsp ;
   __uint64_t rip ;
   __uint64_t eflags ;
   unsigned short cs ;
   unsigned short gs ;
   unsigned short fs ;
   unsigned short __pad0 ;
   __uint64_t err ;
   __uint64_t trapno ;
   __uint64_t oldmask ;
   __uint64_t cr2 ;
   union __anonunion____missing_field_name_501150464 __annonCompField1 ;
   __uint64_t __reserved1[8] ;
};
struct _xsave_hdr {
   __uint64_t xstate_bv ;
   __uint64_t __glibc_reserved1[2] ;
   __uint64_t __glibc_reserved2[5] ;
};
struct _ymmh_state {
   __uint32_t ymmh_space[64] ;
};
struct _xstate {
   struct _fpstate fpstate ;
   struct _xsave_hdr xstate_hdr ;
   struct _ymmh_state ymmh ;
};
struct __anonstruct_stack_t_648343364 {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
typedef struct __anonstruct_stack_t_648343364 stack_t;
typedef long long greg_t;
typedef greg_t gregset_t[23];
enum __anonenum_451154152 {
    REG_R8 = 0,
    REG_R9 = 1,
    REG_R10 = 2,
    REG_R11 = 3,
    REG_R12 = 4,
    REG_R13 = 5,
    REG_R14 = 6,
    REG_R15 = 7,
    REG_RDI = 8,
    REG_RSI = 9,
    REG_RBP = 10,
    REG_RBX = 11,
    REG_RDX = 12,
    REG_RAX = 13,
    REG_RCX = 14,
    REG_RSP = 15,
    REG_RIP = 16,
    REG_EFL = 17,
    REG_CSGSFS = 18,
    REG_ERR = 19,
    REG_TRAPNO = 20,
    REG_OLDMASK = 21,
    REG_CR2 = 22
} ;
struct _libc_fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short __glibc_reserved1[3] ;
};
struct _libc_xmmreg {
   __uint32_t element[4] ;
};
struct _libc_fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _libc_fpxreg _st[8] ;
   struct _libc_xmmreg _xmm[16] ;
   __uint32_t __glibc_reserved1[24] ;
};
typedef struct _libc_fpstate *fpregset_t;
struct __anonstruct_mcontext_t_5268627 {
   gregset_t gregs ;
   fpregset_t fpregs ;
   unsigned long long __reserved1[8] ;
};
typedef struct __anonstruct_mcontext_t_5268627 mcontext_t;
struct ucontext_t {
   unsigned long uc_flags ;
   struct ucontext_t *uc_link ;
   stack_t uc_stack ;
   mcontext_t uc_mcontext ;
   sigset_t uc_sigmask ;
   struct _libc_fpstate __fpregs_mem ;
   unsigned long long __ssp[4] ;
};
typedef struct ucontext_t ucontext_t;
enum __anonenum_437032235 {
    _PC_LINK_MAX = 0,
    _PC_MAX_CANON = 1,
    _PC_MAX_INPUT = 2,
    _PC_NAME_MAX = 3,
    _PC_PATH_MAX = 4,
    _PC_PIPE_BUF = 5,
    _PC_CHOWN_RESTRICTED = 6,
    _PC_NO_TRUNC = 7,
    _PC_VDISABLE = 8,
    _PC_SYNC_IO = 9,
    _PC_ASYNC_IO = 10,
    _PC_PRIO_IO = 11,
    _PC_SOCK_MAXBUF = 12,
    _PC_FILESIZEBITS = 13,
    _PC_REC_INCR_XFER_SIZE = 14,
    _PC_REC_MAX_XFER_SIZE = 15,
    _PC_REC_MIN_XFER_SIZE = 16,
    _PC_REC_XFER_ALIGN = 17,
    _PC_ALLOC_SIZE_MIN = 18,
    _PC_SYMLINK_MAX = 19,
    _PC_2_SYMLINKS = 20
} ;
enum __anonenum_315186338 {
    _SC_ARG_MAX = 0,
    _SC_CHILD_MAX = 1,
    _SC_CLK_TCK = 2,
    _SC_NGROUPS_MAX = 3,
    _SC_OPEN_MAX = 4,
    _SC_STREAM_MAX = 5,
    _SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL = 7,
    _SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS = 11,
    _SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC = 15,
    _SC_MAPPED_FILES = 16,
    _SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES = 21,
    _SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX = 28,
    _SC_VERSION = 29,
    _SC_PAGESIZE = 30,
    _SC_RTSIG_MAX = 31,
    _SC_SEM_NSEMS_MAX = 32,
    _SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX = 40,
    _SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX = 45,
    _SC_2_VERSION = 46,
    _SC_2_C_BIND = 47,
    _SC_2_C_DEV = 48,
    _SC_2_FORT_DEV = 49,
    _SC_2_FORT_RUN = 50,
    _SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF = 52,
    _SC_PII = 53,
    _SC_PII_XTI = 54,
    _SC_PII_SOCKET = 55,
    _SC_PII_INTERNET = 56,
    _SC_PII_OSI = 57,
    _SC_POLL = 58,
    _SC_SELECT = 59,
    _SC_UIO_MAXIOV = 60,
    _SC_IOV_MAX = 60,
    _SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS = 63,
    _SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX = 66,
    _SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX = 91,
    _SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N = 93,
    _SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION = 96,
    _SC_2_UPE = 97,
    _SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT = 101,
    _SC_CHAR_MAX = 102,
    _SC_CHAR_MIN = 103,
    _SC_INT_MAX = 104,
    _SC_INT_MIN = 105,
    _SC_LONG_BIT = 106,
    _SC_WORD_BIT = 107,
    _SC_MB_LEN_MAX = 108,
    _SC_NZERO = 109,
    _SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX = 113,
    _SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX = 115,
    _SC_UINT_MAX = 116,
    _SC_ULONG_MAX = 117,
    _SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX = 121,
    _SC_NL_NMAX = 122,
    _SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64 = 127,
    _SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS = 131,
    _SC_ADVISORY_INFO = 132,
    _SC_BARRIERS = 133,
    _SC_BASE = 134,
    _SC_C_LANG_SUPPORT = 135,
    _SC_C_LANG_SUPPORT_R = 136,
    _SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT = 143,
    _SC_FIFO = 144,
    _SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS = 154,
    _SC_REGEXP = 155,
    _SC_REGEX_VERSION = 156,
    _SC_SHELL = 157,
    _SC_SIGNALS = 158,
    _SC_SPAWN = 159,
    _SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R = 167,
    _SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX = 173,
    _SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX = 180,
    _SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6 = 235,
    _SC_RAW_SOCKETS = 236,
    _SC_V7_ILP32_OFF32 = 237,
    _SC_V7_ILP32_OFFBIG = 238,
    _SC_V7_LP64_OFF64 = 239,
    _SC_V7_LPBIG_OFFBIG = 240,
    _SC_SS_REPL_MAX = 241,
    _SC_TRACE_EVENT_NAME_MAX = 242,
    _SC_TRACE_NAME_MAX = 243,
    _SC_TRACE_SYS_MAX = 244,
    _SC_TRACE_USER_EVENT_MAX = 245,
    _SC_XOPEN_STREAMS = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT = 248,
    _SC_MINSIGSTKSZ = 249,
    _SC_SIGSTKSZ = 250
} ;
enum __anonenum_875524036 {
    _CS_PATH = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS = 1,
    _CS_GNU_LIBC_VERSION = 2,
    _CS_GNU_LIBPTHREAD_VERSION = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS = 5,
    _CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS = 1001,
    _CS_LFS_LIBS = 1002,
    _CS_LFS_LINTFLAGS = 1003,
    _CS_LFS64_CFLAGS = 1004,
    _CS_LFS64_LDFLAGS = 1005,
    _CS_LFS64_LIBS = 1006,
    _CS_LFS64_LINTFLAGS = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
    _CS_XBS5_LP64_OFF64_LIBS = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
    _CS_V6_ENV = 1148,
    _CS_V7_ENV = 1149
} ;
enum __anonenum_57186863 {
    SS_ONSTACK = 1,
    SS_DISABLE = 2
} ;
struct sigstack {
   void *ss_sp ;
   int ss_onstack ;
};
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
union __anonunion___value_628077854 {
   unsigned int __wch ;
   char __wchb[4] ;
};
struct __anonstruct___mbstate_t_615341979 {
   int __count ;
   union __anonunion___value_628077854 __value ;
};
typedef struct __anonstruct___mbstate_t_615341979 __mbstate_t;
struct _G_fpos_t {
   __off_t __pos ;
   __mbstate_t __state ;
};
typedef struct _G_fpos_t __fpos_t;
struct _G_fpos64_t {
   __off64_t __pos ;
   __mbstate_t __state ;
};
typedef struct _G_fpos64_t __fpos64_t;
typedef struct _IO_FILE __FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef __ssize_t cookie_read_function_t(void *__cookie , char *__buf , size_t __nbytes );
typedef __ssize_t cookie_write_function_t(void *__cookie , char const *__buf , size_t __nbytes );
typedef int cookie_seek_function_t(void *__cookie , __off64_t *__pos , int __w );
typedef int cookie_close_function_t(void *__cookie );
struct _IO_cookie_io_functions_t {
   cookie_read_function_t *read ;
   cookie_write_function_t *write ;
   cookie_seek_function_t *seek ;
   cookie_close_function_t *close ;
};
typedef struct _IO_cookie_io_functions_t cookie_io_functions_t;
typedef __fpos_t fpos_t;
typedef __fpos64_t fpos64_t;
struct obstack ;
struct __anonstruct_div_t_773697287 {
   int quot ;
   int rem ;
};
typedef struct __anonstruct_div_t_773697287 div_t;
struct __anonstruct_ldiv_t_1056015326 {
   long quot ;
   long rem ;
};
typedef struct __anonstruct_ldiv_t_1056015326 ldiv_t;
struct __anonstruct_lldiv_t_103911545 {
   long long quot ;
   long long rem ;
};
typedef struct __anonstruct_lldiv_t_103911545 lldiv_t;
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
typedef int (*__compar_fn_t)(void const * , void const * );
typedef int (*comparison_fn_t)(void const * , void const * );
typedef int (*__compar_d_fn_t)(void const * , void const * , void * );
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
struct termio {
   unsigned short c_iflag ;
   unsigned short c_oflag ;
   unsigned short c_cflag ;
   unsigned short c_lflag ;
   unsigned char c_line ;
   unsigned char c_cc[8] ;
};
typedef signed char __s8;
typedef unsigned char __u8;
typedef short __s16;
typedef unsigned short __u16;
typedef int __s32;
typedef unsigned int __u32;
typedef long long __s64;
typedef unsigned long long __u64;
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;
typedef __u16 __sum16;
typedef __u32 __wsum;
typedef unsigned int __poll_t;
struct statx_timestamp {
   __s64 tv_sec ;
   __u32 tv_nsec ;
   __s32 __reserved ;
};
struct statx {
   __u32 stx_mask ;
   __u32 stx_blksize ;
   __u64 stx_attributes ;
   __u32 stx_nlink ;
   __u32 stx_uid ;
   __u32 stx_gid ;
   __u16 stx_mode ;
   __u16 __spare0[1] ;
   __u64 stx_ino ;
   __u64 stx_size ;
   __u64 stx_blocks ;
   __u64 stx_attributes_mask ;
   struct statx_timestamp stx_atime ;
   struct statx_timestamp stx_btime ;
   struct statx_timestamp stx_ctime ;
   struct statx_timestamp stx_mtime ;
   __u32 stx_rdev_major ;
   __u32 stx_rdev_minor ;
   __u32 stx_dev_major ;
   __u32 stx_dev_minor ;
   __u64 stx_mnt_id ;
   __u64 __spare2 ;
   __u64 __spare3[12] ;
};
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2
} ;
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
typedef enum __itimer_which __itimer_which_t;
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
typedef int __ipc_pid_t;
struct ipc_perm {
   __key_t __key ;
   __uid_t uid ;
   __gid_t gid ;
   __uid_t cuid ;
   __gid_t cgid ;
   __mode_t mode ;
   unsigned short __seq ;
   unsigned short __pad2 ;
   __syscall_ulong_t __glibc_reserved1 ;
   __syscall_ulong_t __glibc_reserved2 ;
};
typedef __syscall_ulong_t shmatt_t;
struct shmid_ds {
   struct ipc_perm shm_perm ;
   size_t shm_segsz ;
   __time_t shm_atime ;
   __time_t shm_dtime ;
   __time_t shm_ctime ;
   __pid_t shm_cpid ;
   __pid_t shm_lpid ;
   shmatt_t shm_nattch ;
   __syscall_ulong_t __glibc_reserved5 ;
   __syscall_ulong_t __glibc_reserved6 ;
};
struct shminfo {
   __syscall_ulong_t shmmax ;
   __syscall_ulong_t shmmin ;
   __syscall_ulong_t shmmni ;
   __syscall_ulong_t shmseg ;
   __syscall_ulong_t shmall ;
   __syscall_ulong_t __glibc_reserved1 ;
   __syscall_ulong_t __glibc_reserved2 ;
   __syscall_ulong_t __glibc_reserved3 ;
   __syscall_ulong_t __glibc_reserved4 ;
};
struct shm_info {
   int used_ids ;
   __syscall_ulong_t shm_tot ;
   __syscall_ulong_t shm_rss ;
   __syscall_ulong_t shm_swp ;
   __syscall_ulong_t swap_attempts ;
   __syscall_ulong_t swap_successes ;
};
enum __anonenum_idtype_t_558242672 {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2
} ;
typedef enum __anonenum_idtype_t_558242672 idtype_t;
struct rusage ;
struct timex {
   unsigned int modes ;
   __syscall_slong_t offset ;
   __syscall_slong_t freq ;
   __syscall_slong_t maxerror ;
   __syscall_slong_t esterror ;
   int status ;
   __syscall_slong_t constant ;
   __syscall_slong_t precision ;
   __syscall_slong_t tolerance ;
   struct timeval time ;
   __syscall_slong_t tick ;
   __syscall_slong_t ppsfreq ;
   __syscall_slong_t jitter ;
   int shift ;
   __syscall_slong_t stabil ;
   __syscall_slong_t jitcnt ;
   __syscall_slong_t calcnt ;
   __syscall_slong_t errcnt ;
   __syscall_slong_t stbcnt ;
   int tai ;
   int : 32 ;
   int : 32 ;
   int : 32 ;
   int : 32 ;
   int : 32 ;
   int : 32 ;
   int : 32 ;
   int : 32 ;
   int : 32 ;
   int : 32 ;
   int : 32 ;
};
struct ntptimeval {
   struct timeval time ;
   long maxerror ;
   long esterror ;
   long tai ;
   long __glibc_reserved1 ;
   long __glibc_reserved2 ;
   long __glibc_reserved3 ;
   long __glibc_reserved4 ;
};
struct ARR_Instance_Record ;
typedef struct ARR_Instance_Record *ARR_Instance;
struct ARR_Instance_Record {
   void *data ;
   unsigned int elem_size ;
   unsigned int used ;
   unsigned int allocated ;
};
enum __anonenum_83571709___0 {
    MSG_OOB___0 = 1,
    MSG_PEEK___0 = 2,
    MSG_DONTROUTE___0 = 4,
    MSG_TRYHARD___0 = 4,
    MSG_CTRUNC___0 = 8,
    MSG_PROXY___0 = 16,
    MSG_TRUNC___0 = 32,
    MSG_DONTWAIT___0 = 64,
    MSG_EOR___0 = 128,
    MSG_WAITALL___0 = 256,
    MSG_FIN___0 = 512,
    MSG_SYN___0 = 1024,
    MSG_CONFIRM___0 = 2048,
    MSG_RST___0 = 4096,
    MSG_ERRQUEUE___0 = 8192,
    MSG_NOSIGNAL___0 = 16384,
    MSG_MORE___0 = 32768,
    MSG_WAITFORONE___0 = 65536,
    MSG_BATCH___0 = 262144,
    MSG_ZEROCOPY___0 = 67108864,
    MSG_FASTOPEN___0 = 536870912,
    MSG_CMSG_CLOEXEC___0 = 1073741824
} ;
enum __anonenum_617082774___0 {
    SCM_RIGHTS___0 = 1,
    SCM_CREDENTIALS___0 = 2
} ;
enum __anonenum_606441560___0 {
    SHUT_RD___0 = 0,
    SHUT_WR___0 = 1,
    SHUT_RDWR___0 = 2
} ;
enum __anonenum_264779956___0 {
    IPPROTO_IP___0 = 0,
    IPPROTO_ICMP___0 = 1,
    IPPROTO_IGMP___0 = 2,
    IPPROTO_IPIP___0 = 4,
    IPPROTO_TCP___0 = 6,
    IPPROTO_EGP___0 = 8,
    IPPROTO_PUP___0 = 12,
    IPPROTO_UDP___0 = 17,
    IPPROTO_IDP___0 = 22,
    IPPROTO_TP___0 = 29,
    IPPROTO_DCCP___0 = 33,
    IPPROTO_IPV6___0 = 41,
    IPPROTO_RSVP___0 = 46,
    IPPROTO_GRE___0 = 47,
    IPPROTO_ESP___0 = 50,
    IPPROTO_AH___0 = 51,
    IPPROTO_MTP___0 = 92,
    IPPROTO_BEETPH___0 = 94,
    IPPROTO_ENCAP___0 = 98,
    IPPROTO_PIM___0 = 103,
    IPPROTO_COMP___0 = 108,
    IPPROTO_SCTP___0 = 132,
    IPPROTO_UDPLITE___0 = 136,
    IPPROTO_MPLS___0 = 137,
    IPPROTO_ETHERNET___0 = 143,
    IPPROTO_RAW___0 = 255,
    IPPROTO_MPTCP___0 = 262,
    IPPROTO_MAX___0 = 263
} ;
enum __anonenum_218739988___0 {
    IPPROTO_HOPOPTS___0 = 0,
    IPPROTO_ROUTING___0 = 43,
    IPPROTO_FRAGMENT___0 = 44,
    IPPROTO_ICMPV6___0 = 58,
    IPPROTO_NONE___0 = 59,
    IPPROTO_DSTOPTS___0 = 60,
    IPPROTO_MH___0 = 135
} ;
enum __anonenum_662268580___0 {
    IPPORT_ECHO___0 = 7,
    IPPORT_DISCARD___0 = 9,
    IPPORT_SYSTAT___0 = 11,
    IPPORT_DAYTIME___0 = 13,
    IPPORT_NETSTAT___0 = 15,
    IPPORT_FTP___0 = 21,
    IPPORT_TELNET___0 = 23,
    IPPORT_SMTP___0 = 25,
    IPPORT_TIMESERVER___0 = 37,
    IPPORT_NAMESERVER___0 = 42,
    IPPORT_WHOIS___0 = 43,
    IPPORT_MTP___0 = 57,
    IPPORT_TFTP___0 = 69,
    IPPORT_RJE___0 = 77,
    IPPORT_FINGER___0 = 79,
    IPPORT_TTYLINK___0 = 87,
    IPPORT_SUPDUP___0 = 95,
    IPPORT_EXECSERVER___0 = 512,
    IPPORT_LOGINSERVER___0 = 513,
    IPPORT_CMDSERVER___0 = 514,
    IPPORT_EFSSERVER___0 = 520,
    IPPORT_BIFFUDP___0 = 512,
    IPPORT_WHOSERVER___0 = 513,
    IPPORT_ROUTESERVER___0 = 520,
    IPPORT_RESERVED___0 = 1024,
    IPPORT_USERRESERVED___0 = 5000
} ;
enum __anonenum_18926444___0 {
    _ISupper___0 = 256,
    _ISlower___0 = 512,
    _ISalpha___0 = 1024,
    _ISdigit___0 = 2048,
    _ISxdigit___0 = 4096,
    _ISspace___0 = 8192,
    _ISprint___0 = 16384,
    _ISgraph___0 = 32768,
    _ISblank___0 = 1,
    _IScntrl___0 = 2,
    _ISpunct___0 = 4,
    _ISalnum___0 = 8
} ;
enum __anonenum_913965969___0 {
    FP_INT_UPWARD___0 = 0,
    FP_INT_DOWNWARD___0 = 1,
    FP_INT_TOWARDZERO___0 = 2,
    FP_INT_TONEARESTFROMZERO___0 = 3,
    FP_INT_TONEAREST___0 = 4
} ;
enum __anonenum_1037408945___0 {
    FP_NAN___0 = 0,
    FP_INFINITE___0 = 1,
    FP_ZERO___0 = 2,
    FP_SUBNORMAL___0 = 3,
    FP_NORMAL___0 = 4
} ;
enum __anonenum_556971655___0 {
    SI_ASYNCNL___0 = -60,
    SI_DETHREAD___0 = -7,
    SI_TKILL___0 = -6,
    SI_SIGIO___0 = -5,
    SI_ASYNCIO___0 = -4,
    SI_MESGQ___0 = -3,
    SI_TIMER___0 = -2,
    SI_QUEUE___0 = -1,
    SI_USER___0 = 0,
    SI_KERNEL___0 = 128
} ;
enum __anonenum_640648963___0 {
    ILL_ILLOPC___0 = 1,
    ILL_ILLOPN___0 = 2,
    ILL_ILLADR___0 = 3,
    ILL_ILLTRP___0 = 4,
    ILL_PRVOPC___0 = 5,
    ILL_PRVREG___0 = 6,
    ILL_COPROC___0 = 7,
    ILL_BADSTK___0 = 8,
    ILL_BADIADDR___0 = 9
} ;
enum __anonenum_457704180___0 {
    FPE_INTDIV___0 = 1,
    FPE_INTOVF___0 = 2,
    FPE_FLTDIV___0 = 3,
    FPE_FLTOVF___0 = 4,
    FPE_FLTUND___0 = 5,
    FPE_FLTRES___0 = 6,
    FPE_FLTINV___0 = 7,
    FPE_FLTSUB___0 = 8,
    FPE_FLTUNK___0 = 14,
    FPE_CONDTRAP___0 = 15
} ;
enum __anonenum_180375148___0 {
    SEGV_MAPERR___0 = 1,
    SEGV_ACCERR___0 = 2,
    SEGV_BNDERR___0 = 3,
    SEGV_PKUERR___0 = 4,
    SEGV_ACCADI___0 = 5,
    SEGV_ADIDERR___0 = 6,
    SEGV_ADIPERR___0 = 7,
    SEGV_MTEAERR___0 = 8,
    SEGV_MTESERR___0 = 9
} ;
enum __anonenum_1036286214___0 {
    BUS_ADRALN___0 = 1,
    BUS_ADRERR___0 = 2,
    BUS_OBJERR___0 = 3,
    BUS_MCEERR_AR___0 = 4,
    BUS_MCEERR_AO___0 = 5
} ;
enum __anonenum_91015150___0 {
    TRAP_BRKPT___0 = 1,
    TRAP_TRACE___0 = 2,
    TRAP_BRANCH___0 = 3,
    TRAP_HWBKPT___0 = 4,
    TRAP_UNK___0 = 5
} ;
enum __anonenum_23175539___0 {
    CLD_EXITED___0 = 1,
    CLD_KILLED___0 = 2,
    CLD_DUMPED___0 = 3,
    CLD_TRAPPED___0 = 4,
    CLD_STOPPED___0 = 5,
    CLD_CONTINUED___0 = 6
} ;
enum __anonenum_111643124___0 {
    POLL_IN___0 = 1,
    POLL_OUT___0 = 2,
    POLL_MSG___0 = 3,
    POLL_ERR___0 = 4,
    POLL_PRI___0 = 5,
    POLL_HUP___0 = 6
} ;
enum __anonenum_852341087___0 {
    SIGEV_SIGNAL___0 = 0,
    SIGEV_NONE___0 = 1,
    SIGEV_THREAD___0 = 2,
    SIGEV_THREAD_ID___0 = 4
} ;
enum __anonenum_451154152___0 {
    REG_R8___0 = 0,
    REG_R9___0 = 1,
    REG_R10___0 = 2,
    REG_R11___0 = 3,
    REG_R12___0 = 4,
    REG_R13___0 = 5,
    REG_R14___0 = 6,
    REG_R15___0 = 7,
    REG_RDI___0 = 8,
    REG_RSI___0 = 9,
    REG_RBP___0 = 10,
    REG_RBX___0 = 11,
    REG_RDX___0 = 12,
    REG_RAX___0 = 13,
    REG_RCX___0 = 14,
    REG_RSP___0 = 15,
    REG_RIP___0 = 16,
    REG_EFL___0 = 17,
    REG_CSGSFS___0 = 18,
    REG_ERR___0 = 19,
    REG_TRAPNO___0 = 20,
    REG_OLDMASK___0 = 21,
    REG_CR2___0 = 22
} ;
enum __anonenum_437032235___0 {
    _PC_LINK_MAX___0 = 0,
    _PC_MAX_CANON___0 = 1,
    _PC_MAX_INPUT___0 = 2,
    _PC_NAME_MAX___0 = 3,
    _PC_PATH_MAX___0 = 4,
    _PC_PIPE_BUF___0 = 5,
    _PC_CHOWN_RESTRICTED___0 = 6,
    _PC_NO_TRUNC___0 = 7,
    _PC_VDISABLE___0 = 8,
    _PC_SYNC_IO___0 = 9,
    _PC_ASYNC_IO___0 = 10,
    _PC_PRIO_IO___0 = 11,
    _PC_SOCK_MAXBUF___0 = 12,
    _PC_FILESIZEBITS___0 = 13,
    _PC_REC_INCR_XFER_SIZE___0 = 14,
    _PC_REC_MAX_XFER_SIZE___0 = 15,
    _PC_REC_MIN_XFER_SIZE___0 = 16,
    _PC_REC_XFER_ALIGN___0 = 17,
    _PC_ALLOC_SIZE_MIN___0 = 18,
    _PC_SYMLINK_MAX___0 = 19,
    _PC_2_SYMLINKS___0 = 20
} ;
enum __anonenum_315186338___0 {
    _SC_ARG_MAX___0 = 0,
    _SC_CHILD_MAX___0 = 1,
    _SC_CLK_TCK___0 = 2,
    _SC_NGROUPS_MAX___0 = 3,
    _SC_OPEN_MAX___0 = 4,
    _SC_STREAM_MAX___0 = 5,
    _SC_TZNAME_MAX___0 = 6,
    _SC_JOB_CONTROL___0 = 7,
    _SC_SAVED_IDS___0 = 8,
    _SC_REALTIME_SIGNALS___0 = 9,
    _SC_PRIORITY_SCHEDULING___0 = 10,
    _SC_TIMERS___0 = 11,
    _SC_ASYNCHRONOUS_IO___0 = 12,
    _SC_PRIORITIZED_IO___0 = 13,
    _SC_SYNCHRONIZED_IO___0 = 14,
    _SC_FSYNC___0 = 15,
    _SC_MAPPED_FILES___0 = 16,
    _SC_MEMLOCK___0 = 17,
    _SC_MEMLOCK_RANGE___0 = 18,
    _SC_MEMORY_PROTECTION___0 = 19,
    _SC_MESSAGE_PASSING___0 = 20,
    _SC_SEMAPHORES___0 = 21,
    _SC_SHARED_MEMORY_OBJECTS___0 = 22,
    _SC_AIO_LISTIO_MAX___0 = 23,
    _SC_AIO_MAX___0 = 24,
    _SC_AIO_PRIO_DELTA_MAX___0 = 25,
    _SC_DELAYTIMER_MAX___0 = 26,
    _SC_MQ_OPEN_MAX___0 = 27,
    _SC_MQ_PRIO_MAX___0 = 28,
    _SC_VERSION___0 = 29,
    _SC_PAGESIZE___0 = 30,
    _SC_RTSIG_MAX___0 = 31,
    _SC_SEM_NSEMS_MAX___0 = 32,
    _SC_SEM_VALUE_MAX___0 = 33,
    _SC_SIGQUEUE_MAX___0 = 34,
    _SC_TIMER_MAX___0 = 35,
    _SC_BC_BASE_MAX___0 = 36,
    _SC_BC_DIM_MAX___0 = 37,
    _SC_BC_SCALE_MAX___0 = 38,
    _SC_BC_STRING_MAX___0 = 39,
    _SC_COLL_WEIGHTS_MAX___0 = 40,
    _SC_EQUIV_CLASS_MAX___0 = 41,
    _SC_EXPR_NEST_MAX___0 = 42,
    _SC_LINE_MAX___0 = 43,
    _SC_RE_DUP_MAX___0 = 44,
    _SC_CHARCLASS_NAME_MAX___0 = 45,
    _SC_2_VERSION___0 = 46,
    _SC_2_C_BIND___0 = 47,
    _SC_2_C_DEV___0 = 48,
    _SC_2_FORT_DEV___0 = 49,
    _SC_2_FORT_RUN___0 = 50,
    _SC_2_SW_DEV___0 = 51,
    _SC_2_LOCALEDEF___0 = 52,
    _SC_PII___0 = 53,
    _SC_PII_XTI___0 = 54,
    _SC_PII_SOCKET___0 = 55,
    _SC_PII_INTERNET___0 = 56,
    _SC_PII_OSI___0 = 57,
    _SC_POLL___0 = 58,
    _SC_SELECT___0 = 59,
    _SC_UIO_MAXIOV___0 = 60,
    _SC_IOV_MAX___0 = 60,
    _SC_PII_INTERNET_STREAM___0 = 61,
    _SC_PII_INTERNET_DGRAM___0 = 62,
    _SC_PII_OSI_COTS___0 = 63,
    _SC_PII_OSI_CLTS___0 = 64,
    _SC_PII_OSI_M___0 = 65,
    _SC_T_IOV_MAX___0 = 66,
    _SC_THREADS___0 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___0 = 68,
    _SC_GETGR_R_SIZE_MAX___0 = 69,
    _SC_GETPW_R_SIZE_MAX___0 = 70,
    _SC_LOGIN_NAME_MAX___0 = 71,
    _SC_TTY_NAME_MAX___0 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___0 = 73,
    _SC_THREAD_KEYS_MAX___0 = 74,
    _SC_THREAD_STACK_MIN___0 = 75,
    _SC_THREAD_THREADS_MAX___0 = 76,
    _SC_THREAD_ATTR_STACKADDR___0 = 77,
    _SC_THREAD_ATTR_STACKSIZE___0 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___0 = 79,
    _SC_THREAD_PRIO_INHERIT___0 = 80,
    _SC_THREAD_PRIO_PROTECT___0 = 81,
    _SC_THREAD_PROCESS_SHARED___0 = 82,
    _SC_NPROCESSORS_CONF___0 = 83,
    _SC_NPROCESSORS_ONLN___0 = 84,
    _SC_PHYS_PAGES___0 = 85,
    _SC_AVPHYS_PAGES___0 = 86,
    _SC_ATEXIT_MAX___0 = 87,
    _SC_PASS_MAX___0 = 88,
    _SC_XOPEN_VERSION___0 = 89,
    _SC_XOPEN_XCU_VERSION___0 = 90,
    _SC_XOPEN_UNIX___0 = 91,
    _SC_XOPEN_CRYPT___0 = 92,
    _SC_XOPEN_ENH_I18N___0 = 93,
    _SC_XOPEN_SHM___0 = 94,
    _SC_2_CHAR_TERM___0 = 95,
    _SC_2_C_VERSION___0 = 96,
    _SC_2_UPE___0 = 97,
    _SC_XOPEN_XPG2___0 = 98,
    _SC_XOPEN_XPG3___0 = 99,
    _SC_XOPEN_XPG4___0 = 100,
    _SC_CHAR_BIT___0 = 101,
    _SC_CHAR_MAX___0 = 102,
    _SC_CHAR_MIN___0 = 103,
    _SC_INT_MAX___0 = 104,
    _SC_INT_MIN___0 = 105,
    _SC_LONG_BIT___0 = 106,
    _SC_WORD_BIT___0 = 107,
    _SC_MB_LEN_MAX___0 = 108,
    _SC_NZERO___0 = 109,
    _SC_SSIZE_MAX___0 = 110,
    _SC_SCHAR_MAX___0 = 111,
    _SC_SCHAR_MIN___0 = 112,
    _SC_SHRT_MAX___0 = 113,
    _SC_SHRT_MIN___0 = 114,
    _SC_UCHAR_MAX___0 = 115,
    _SC_UINT_MAX___0 = 116,
    _SC_ULONG_MAX___0 = 117,
    _SC_USHRT_MAX___0 = 118,
    _SC_NL_ARGMAX___0 = 119,
    _SC_NL_LANGMAX___0 = 120,
    _SC_NL_MSGMAX___0 = 121,
    _SC_NL_NMAX___0 = 122,
    _SC_NL_SETMAX___0 = 123,
    _SC_NL_TEXTMAX___0 = 124,
    _SC_XBS5_ILP32_OFF32___0 = 125,
    _SC_XBS5_ILP32_OFFBIG___0 = 126,
    _SC_XBS5_LP64_OFF64___0 = 127,
    _SC_XBS5_LPBIG_OFFBIG___0 = 128,
    _SC_XOPEN_LEGACY___0 = 129,
    _SC_XOPEN_REALTIME___0 = 130,
    _SC_XOPEN_REALTIME_THREADS___0 = 131,
    _SC_ADVISORY_INFO___0 = 132,
    _SC_BARRIERS___0 = 133,
    _SC_BASE___0 = 134,
    _SC_C_LANG_SUPPORT___0 = 135,
    _SC_C_LANG_SUPPORT_R___0 = 136,
    _SC_CLOCK_SELECTION___0 = 137,
    _SC_CPUTIME___0 = 138,
    _SC_THREAD_CPUTIME___0 = 139,
    _SC_DEVICE_IO___0 = 140,
    _SC_DEVICE_SPECIFIC___0 = 141,
    _SC_DEVICE_SPECIFIC_R___0 = 142,
    _SC_FD_MGMT___0 = 143,
    _SC_FIFO___0 = 144,
    _SC_PIPE___0 = 145,
    _SC_FILE_ATTRIBUTES___0 = 146,
    _SC_FILE_LOCKING___0 = 147,
    _SC_FILE_SYSTEM___0 = 148,
    _SC_MONOTONIC_CLOCK___0 = 149,
    _SC_MULTI_PROCESS___0 = 150,
    _SC_SINGLE_PROCESS___0 = 151,
    _SC_NETWORKING___0 = 152,
    _SC_READER_WRITER_LOCKS___0 = 153,
    _SC_SPIN_LOCKS___0 = 154,
    _SC_REGEXP___0 = 155,
    _SC_REGEX_VERSION___0 = 156,
    _SC_SHELL___0 = 157,
    _SC_SIGNALS___0 = 158,
    _SC_SPAWN___0 = 159,
    _SC_SPORADIC_SERVER___0 = 160,
    _SC_THREAD_SPORADIC_SERVER___0 = 161,
    _SC_SYSTEM_DATABASE___0 = 162,
    _SC_SYSTEM_DATABASE_R___0 = 163,
    _SC_TIMEOUTS___0 = 164,
    _SC_TYPED_MEMORY_OBJECTS___0 = 165,
    _SC_USER_GROUPS___0 = 166,
    _SC_USER_GROUPS_R___0 = 167,
    _SC_2_PBS___0 = 168,
    _SC_2_PBS_ACCOUNTING___0 = 169,
    _SC_2_PBS_LOCATE___0 = 170,
    _SC_2_PBS_MESSAGE___0 = 171,
    _SC_2_PBS_TRACK___0 = 172,
    _SC_SYMLOOP_MAX___0 = 173,
    _SC_STREAMS___0 = 174,
    _SC_2_PBS_CHECKPOINT___0 = 175,
    _SC_V6_ILP32_OFF32___0 = 176,
    _SC_V6_ILP32_OFFBIG___0 = 177,
    _SC_V6_LP64_OFF64___0 = 178,
    _SC_V6_LPBIG_OFFBIG___0 = 179,
    _SC_HOST_NAME_MAX___0 = 180,
    _SC_TRACE___0 = 181,
    _SC_TRACE_EVENT_FILTER___0 = 182,
    _SC_TRACE_INHERIT___0 = 183,
    _SC_TRACE_LOG___0 = 184,
    _SC_LEVEL1_ICACHE_SIZE___0 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___0 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___0 = 187,
    _SC_LEVEL1_DCACHE_SIZE___0 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___0 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___0 = 190,
    _SC_LEVEL2_CACHE_SIZE___0 = 191,
    _SC_LEVEL2_CACHE_ASSOC___0 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___0 = 193,
    _SC_LEVEL3_CACHE_SIZE___0 = 194,
    _SC_LEVEL3_CACHE_ASSOC___0 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___0 = 196,
    _SC_LEVEL4_CACHE_SIZE___0 = 197,
    _SC_LEVEL4_CACHE_ASSOC___0 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___0 = 199,
    _SC_IPV6___0 = 235,
    _SC_RAW_SOCKETS___0 = 236,
    _SC_V7_ILP32_OFF32___0 = 237,
    _SC_V7_ILP32_OFFBIG___0 = 238,
    _SC_V7_LP64_OFF64___0 = 239,
    _SC_V7_LPBIG_OFFBIG___0 = 240,
    _SC_SS_REPL_MAX___0 = 241,
    _SC_TRACE_EVENT_NAME_MAX___0 = 242,
    _SC_TRACE_NAME_MAX___0 = 243,
    _SC_TRACE_SYS_MAX___0 = 244,
    _SC_TRACE_USER_EVENT_MAX___0 = 245,
    _SC_XOPEN_STREAMS___0 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___0 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___0 = 248,
    _SC_MINSIGSTKSZ___0 = 249,
    _SC_SIGSTKSZ___0 = 250
} ;
enum __anonenum_875524036___0 {
    _CS_PATH___0 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___0 = 1,
    _CS_GNU_LIBC_VERSION___0 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___0 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___0 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___0 = 5,
    _CS_LFS_CFLAGS___0 = 1000,
    _CS_LFS_LDFLAGS___0 = 1001,
    _CS_LFS_LIBS___0 = 1002,
    _CS_LFS_LINTFLAGS___0 = 1003,
    _CS_LFS64_CFLAGS___0 = 1004,
    _CS_LFS64_LDFLAGS___0 = 1005,
    _CS_LFS64_LIBS___0 = 1006,
    _CS_LFS64_LINTFLAGS___0 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___0 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___0 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___0 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___0 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___0 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___0 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___0 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___0 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___0 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___0 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___0 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___0 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___0 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___0 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___0 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___0 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___0 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___0 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___0 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___0 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___0 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___0 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___0 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___0 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___0 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___0 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___0 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___0 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___0 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___0 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___0 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___0 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___0 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___0 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___0 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___0 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___0 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___0 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___0 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___0 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___0 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___0 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___0 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___0 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___0 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___0 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___0 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___0 = 1147,
    _CS_V6_ENV___0 = 1148,
    _CS_V7_ENV___0 = 1149
} ;
enum __anonenum_57186863___0 {
    SS_ONSTACK___0 = 1,
    SS_DISABLE___0 = 2
} ;
enum __anonenum_HSH_Algorithm_33112142 {
    HSH_INVALID = 0,
    HSH_MD5 = 1,
    HSH_SHA1 = 2,
    HSH_SHA256 = 3,
    HSH_SHA384 = 4,
    HSH_SHA512 = 5,
    HSH_SHA3_224 = 6,
    HSH_SHA3_256 = 7,
    HSH_SHA3_384 = 8,
    HSH_SHA3_512 = 9,
    HSH_TIGER = 10,
    HSH_WHIRLPOOL = 11,
    HSH_MD5_NONCRYPTO = 10000
} ;
typedef enum __anonenum_HSH_Algorithm_33112142 HSH_Algorithm;
struct __anonstruct_NTP_int64_1034260629 {
   uint32_t hi ;
   uint32_t lo ;
};
typedef struct __anonstruct_NTP_int64_1034260629 NTP_int64;
typedef uint32_t NTP_int32;
enum __anonenum_NTP_Leap_70547756 {
    LEAP_Normal = 0,
    LEAP_InsertSecond = 1,
    LEAP_DeleteSecond = 2,
    LEAP_Unsynchronised = 3
} ;
typedef enum __anonenum_NTP_Leap_70547756 NTP_Leap;
enum __anonenum_NTP_Mode_2125497 {
    MODE_UNDEFINED = 0,
    MODE_ACTIVE = 1,
    MODE_PASSIVE = 2,
    MODE_CLIENT = 3,
    MODE_SERVER = 4,
    MODE_BROADCAST = 5
} ;
typedef enum __anonenum_NTP_Mode_2125497 NTP_Mode;
struct __anonstruct_NTP_Packet_354475138 {
   uint8_t lvm ;
   uint8_t stratum ;
   int8_t poll ;
   int8_t precision ;
   NTP_int32 root_delay ;
   NTP_int32 root_dispersion ;
   NTP_int32 reference_id ;
   NTP_int64 reference_ts ;
   NTP_int64 originate_ts ;
   NTP_int64 receive_ts ;
   NTP_int64 transmit_ts ;
   uint8_t extensions[1092] ;
};
typedef struct __anonstruct_NTP_Packet_354475138 NTP_Packet;
struct __anonstruct_NTP_ExtFieldExp1_905945417 {
   uint32_t magic ;
   NTP_int32 root_delay ;
   NTP_int32 root_dispersion ;
   NTP_int64 mono_receive_ts ;
   uint32_t mono_epoch ;
};
typedef struct __anonstruct_NTP_ExtFieldExp1_905945417 NTP_ExtFieldExp1;
enum __anonenum_NTP_AuthMode_848727617 {
    NTP_AUTH_NONE = 0,
    NTP_AUTH_SYMMETRIC = 1,
    NTP_AUTH_MSSNTP = 2,
    NTP_AUTH_MSSNTP_EXT = 3,
    NTP_AUTH_NTS = 4
} ;
typedef enum __anonenum_NTP_AuthMode_848727617 NTP_AuthMode;
struct __anonstruct_mac_629018261 {
   int start ;
   int length ;
   uint32_t key_id ;
};
struct __anonstruct_auth_321218761 {
   NTP_AuthMode mode ;
   struct __anonstruct_mac_629018261 mac ;
};
struct __anonstruct_NTP_PacketInfo_324986898 {
   int length ;
   int version ;
   NTP_Mode mode ;
   int ext_fields ;
   int ext_field_flags ;
   struct __anonstruct_auth_321218761 auth ;
};
typedef struct __anonstruct_NTP_PacketInfo_324986898 NTP_PacketInfo;
struct __anonstruct_NTP_Sample_191808578 {
   struct timespec time ;
   double offset ;
   double peer_delay ;
   double peer_dispersion ;
   double root_delay ;
   double root_dispersion ;
};
typedef struct __anonstruct_NTP_Sample_191808578 NTP_Sample;
union __anonunion_addr_760363794 {
   uint32_t in4 ;
   uint8_t in6[16] ;
   uint32_t id ;
};
struct __anonstruct_IPAddr_611076257 {
   union __anonunion_addr_760363794 addr ;
   uint16_t family ;
   uint16_t _pad ;
};
typedef struct __anonstruct_IPAddr_611076257 IPAddr;
struct __anonstruct_IPSockAddr_1027281578 {
   IPAddr ip_addr ;
   uint16_t port ;
};
typedef struct __anonstruct_IPSockAddr_1027281578 IPSockAddr;
typedef IPSockAddr NTP_Remote_Address;
struct __anonstruct_NTP_Local_Address_181546951 {
   IPAddr ip_addr ;
   int if_index ;
   int sock_fd ;
};
typedef struct __anonstruct_NTP_Local_Address_181546951 NTP_Local_Address;
enum __anonenum_mode_14858290 {
    RPT_NTP_CLIENT = 0,
    RPT_NTP_PEER = 1,
    RPT_LOCAL_REFERENCE = 2
} ;
enum __anonenum_state_667680095 {
    RPT_NONSELECTABLE = 0,
    RPT_FALSETICKER = 1,
    RPT_JITTERY = 2,
    RPT_SELECTABLE = 3,
    RPT_UNSELECTED = 4,
    RPT_SELECTED = 5
} ;
struct __anonstruct_RPT_SourceReport_83466793 {
   IPAddr ip_addr ;
   int stratum ;
   int poll ;
   enum __anonenum_mode_14858290 mode ;
   enum __anonenum_state_667680095 state ;
   int reachability ;
   unsigned long latest_meas_ago ;
   double orig_latest_meas ;
   double latest_meas ;
   double latest_meas_err ;
};
typedef struct __anonstruct_RPT_SourceReport_83466793 RPT_SourceReport;
struct __anonstruct_RPT_TrackingReport_894134302 {
   uint32_t ref_id ;
   IPAddr ip_addr ;
   int stratum ;
   NTP_Leap leap_status ;
   struct timespec ref_time ;
   double current_correction ;
   double last_offset ;
   double rms_offset ;
   double freq_ppm ;
   double resid_freq_ppm ;
   double skew_ppm ;
   double root_delay ;
   double root_dispersion ;
   double last_update_interval ;
};
typedef struct __anonstruct_RPT_TrackingReport_894134302 RPT_TrackingReport;
struct __anonstruct_RPT_SourcestatsReport_188560594 {
   uint32_t ref_id ;
   IPAddr ip_addr ;
   unsigned long n_samples ;
   unsigned long n_runs ;
   unsigned long span_seconds ;
   double resid_freq_ppm ;
   double skew_ppm ;
   double sd ;
   double est_offset ;
   double est_offset_err ;
};
typedef struct __anonstruct_RPT_SourcestatsReport_188560594 RPT_SourcestatsReport;
struct __anonstruct_RPT_RTC_Report_83595589 {
   struct timespec ref_time ;
   unsigned long n_samples ;
   unsigned long n_runs ;
   unsigned long span_seconds ;
   double rtc_seconds_fast ;
   double rtc_gain_rate_ppm ;
};
typedef struct __anonstruct_RPT_RTC_Report_83595589 RPT_RTC_Report;
struct __anonstruct_RPT_ClientAccessByIndex_Report_1047165682 {
   IPAddr ip_addr ;
   uint32_t ntp_hits ;
   uint32_t nke_hits ;
   uint32_t cmd_hits ;
   uint16_t ntp_drops ;
   uint16_t nke_drops ;
   uint16_t cmd_drops ;
   int8_t ntp_interval ;
   int8_t nke_interval ;
   int8_t cmd_interval ;
   int8_t ntp_timeout_interval ;
   uint32_t last_ntp_hit_ago ;
   uint32_t last_nke_hit_ago ;
   uint32_t last_cmd_hit_ago ;
};
typedef struct __anonstruct_RPT_ClientAccessByIndex_Report_1047165682 RPT_ClientAccessByIndex_Report;
struct __anonstruct_RPT_ServerStatsReport_35876470 {
   uint32_t ntp_hits ;
   uint32_t nke_hits ;
   uint32_t cmd_hits ;
   uint32_t ntp_drops ;
   uint32_t nke_drops ;
   uint32_t cmd_drops ;
   uint32_t log_drops ;
   uint32_t ntp_auth_hits ;
   uint32_t ntp_interleaved_hits ;
   uint32_t ntp_timestamps ;
   uint32_t ntp_span_seconds ;
};
typedef struct __anonstruct_RPT_ServerStatsReport_35876470 RPT_ServerStatsReport;
struct __anonstruct_RPT_ManualSamplesReport_466748285 {
   struct timespec when ;
   double slewed_offset ;
   double orig_offset ;
   double residual ;
};
typedef struct __anonstruct_RPT_ManualSamplesReport_466748285 RPT_ManualSamplesReport;
struct __anonstruct_RPT_ActivityReport_1068738709 {
   int online ;
   int offline ;
   int burst_online ;
   int burst_offline ;
   int unresolved ;
};
typedef struct __anonstruct_RPT_ActivityReport_1068738709 RPT_ActivityReport;
struct __anonstruct_RPT_SmoothingReport_976439729 {
   int active ;
   int leap_only ;
   double offset ;
   double freq_ppm ;
   double wander_ppm ;
   double last_update_ago ;
   double remaining_time ;
};
typedef struct __anonstruct_RPT_SmoothingReport_976439729 RPT_SmoothingReport;
struct __anonstruct_RPT_NTPReport_708252371 {
   IPAddr remote_addr ;
   IPAddr local_addr ;
   uint16_t remote_port ;
   uint8_t leap ;
   uint8_t version ;
   uint8_t mode ;
   uint8_t stratum ;
   int8_t poll ;
   int8_t precision ;
   double root_delay ;
   double root_dispersion ;
   uint32_t ref_id ;
   struct timespec ref_time ;
   double offset ;
   double peer_delay ;
   double peer_dispersion ;
   double response_time ;
   double jitter_asymmetry ;
   uint16_t tests ;
   int interleaved ;
   int authenticated ;
   char tx_tss_char ;
   char rx_tss_char ;
   uint32_t total_tx_count ;
   uint32_t total_rx_count ;
   uint32_t total_valid_count ;
};
typedef struct __anonstruct_RPT_NTPReport_708252371 RPT_NTPReport;
struct __anonstruct_RPT_AuthReport_179453909 {
   NTP_AuthMode mode ;
   uint32_t key_id ;
   int key_type ;
   int key_length ;
   int ke_attempts ;
   uint32_t last_ke_ago ;
   int cookies ;
   int cookie_length ;
   int nak ;
};
typedef struct __anonstruct_RPT_AuthReport_179453909 RPT_AuthReport;
struct __anonstruct_RPT_SelectReport_621107247 {
   uint32_t ref_id ;
   IPAddr ip_addr ;
   char state_char ;
   int authentication ;
   NTP_Leap leap ;
   int conf_options ;
   int eff_options ;
   uint32_t last_sample_ago ;
   double score ;
   double lo_limit ;
   double hi_limit ;
};
typedef struct __anonstruct_RPT_SelectReport_621107247 RPT_SelectReport;
struct SST_Stats_Record ;
typedef struct SST_Stats_Record *SST_Stats;
struct SRC_Instance_Record ;
typedef struct SRC_Instance_Record *SRC_Instance;
enum __anonenum_SRC_AuthSelectMode_733187893 {
    SRC_AUTHSELECT_IGNORE = 0,
    SRC_AUTHSELECT_MIX = 1,
    SRC_AUTHSELECT_PREFER = 2,
    SRC_AUTHSELECT_REQUIRE = 3
} ;
typedef enum __anonenum_SRC_AuthSelectMode_733187893 SRC_AuthSelectMode;
enum __anonenum_SRC_Type_666789876 {
    SRC_NTP = 0,
    SRC_REFCLOCK = 1
} ;
typedef enum __anonenum_SRC_Type_666789876 SRC_Type;
enum __anonenum_SRC_Connectivity_112132371 {
    SRC_OFFLINE = 0,
    SRC_ONLINE = 1,
    SRC_MAYBE_ONLINE = 2
} ;
typedef enum __anonenum_SRC_Connectivity_112132371 SRC_Connectivity;
struct __anonstruct_SourceParameters_127324553 {
   int minpoll ;
   int maxpoll ;
   SRC_Connectivity connectivity ;
   int auto_offline ;
   int presend_minpoll ;
   int burst ;
   int iburst ;
   int min_stratum ;
   int poll_target ;
   int version ;
   int max_sources ;
   int min_samples ;
   int max_samples ;
   int filter_length ;
   int interleaved ;
   int sel_options ;
   int nts ;
   int nts_port ;
   int copy ;
   int ext_fields ;
   uint32_t authkey ;
   uint32_t cert_set ;
   double max_delay ;
   double max_delay_ratio ;
   double max_delay_dev_ratio ;
   double min_delay ;
   double asymmetry ;
   double offset ;
};
typedef struct __anonstruct_SourceParameters_127324553 SourceParameters;
struct __anonstruct_CPS_NTP_Source_2926370 {
   char *name ;
   int port ;
   SourceParameters params ;
};
typedef struct __anonstruct_CPS_NTP_Source_2926370 CPS_NTP_Source;
enum __anonenum_DNS_Status_807707992 {
    DNS_Success = 0,
    DNS_TryAgain = 1,
    DNS_Failure = 2
} ;
typedef enum __anonenum_DNS_Status_807707992 DNS_Status;
struct __anonstruct_Timespec_669259541 {
   uint32_t tv_sec_high ;
   uint32_t tv_sec_low ;
   uint32_t tv_nsec ;
};
typedef struct __anonstruct_Timespec_669259541 Timespec;
struct __anonstruct_Float_731362540 {
   int32_t f ;
};
typedef struct __anonstruct_Float_731362540 Float;
struct __anonstruct_REQ_Null_731362541 {
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Null_731362541 REQ_Null;
struct __anonstruct_REQ_Online_959891288 {
   IPAddr mask ;
   IPAddr address ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Online_959891288 REQ_Online;
struct __anonstruct_REQ_Offline_959891289 {
   IPAddr mask ;
   IPAddr address ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Offline_959891289 REQ_Offline;
struct __anonstruct_REQ_Burst_50683070 {
   IPAddr mask ;
   IPAddr address ;
   int32_t n_good_samples ;
   int32_t n_total_samples ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Burst_50683070 REQ_Burst;
struct __anonstruct_REQ_Modify_Minpoll_988728471 {
   IPAddr address ;
   int32_t new_minpoll ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Modify_Minpoll_988728471 REQ_Modify_Minpoll;
struct __anonstruct_REQ_Modify_Maxpoll_988728472 {
   IPAddr address ;
   int32_t new_maxpoll ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Modify_Maxpoll_988728472 REQ_Modify_Maxpoll;
struct __anonstruct_REQ_Dump_814805217 {
   int32_t pad ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Dump_814805217 REQ_Dump;
struct __anonstruct_REQ_Modify_Maxdelay_158449272 {
   IPAddr address ;
   Float new_max_delay ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Modify_Maxdelay_158449272 REQ_Modify_Maxdelay;
struct __anonstruct_REQ_Modify_Maxdelayratio_158449273 {
   IPAddr address ;
   Float new_max_delay_ratio ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Modify_Maxdelayratio_158449273 REQ_Modify_Maxdelayratio;
struct __anonstruct_REQ_Modify_Maxdelaydevratio_158449274 {
   IPAddr address ;
   Float new_max_delay_dev_ratio ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Modify_Maxdelaydevratio_158449274 REQ_Modify_Maxdelaydevratio;
struct __anonstruct_REQ_Modify_Minstratum_988728473 {
   IPAddr address ;
   int32_t new_min_stratum ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Modify_Minstratum_988728473 REQ_Modify_Minstratum;
struct __anonstruct_REQ_Modify_Polltarget_988728474 {
   IPAddr address ;
   int32_t new_poll_target ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Modify_Polltarget_988728474 REQ_Modify_Polltarget;
struct __anonstruct_REQ_Modify_Maxupdateskew_234674540 {
   Float new_max_update_skew ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Modify_Maxupdateskew_234674540 REQ_Modify_Maxupdateskew;
struct __anonstruct_REQ_Modify_Makestep_1046587163 {
   int32_t limit ;
   Float threshold ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Modify_Makestep_1046587163 REQ_Modify_Makestep;
struct __anonstruct_REQ_Logon_538839186 {
   Timespec ts ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Logon_538839186 REQ_Logon;
struct __anonstruct_REQ_Settime_538839187 {
   Timespec ts ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Settime_538839187 REQ_Settime;
struct __anonstruct_REQ_Local_107649657 {
   int32_t on_off ;
   int32_t stratum ;
   Float distance ;
   int32_t orphan ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Local_107649657 REQ_Local;
struct __anonstruct_REQ_Manual_1046587164 {
   int32_t option ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Manual_1046587164 REQ_Manual;
struct __anonstruct_REQ_Source_Data_1046587165 {
   int32_t index ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Source_Data_1046587165 REQ_Source_Data;
struct __anonstruct_REQ_Allow_Deny_1046587166 {
   IPAddr ip ;
   int32_t subnet_bits ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Allow_Deny_1046587166 REQ_Allow_Deny;
struct __anonstruct_REQ_Ac_Check_95246947 {
   IPAddr ip ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Ac_Check_95246947 REQ_Ac_Check;
struct __anonstruct_REQ_NTP_Source_1044133112 {
   uint32_t type ;
   uint8_t name[256] ;
   uint32_t port ;
   int32_t minpoll ;
   int32_t maxpoll ;
   int32_t presend_minpoll ;
   uint32_t min_stratum ;
   uint32_t poll_target ;
   uint32_t version ;
   uint32_t max_sources ;
   int32_t min_samples ;
   int32_t max_samples ;
   uint32_t authkey ;
   uint32_t nts_port ;
   Float max_delay ;
   Float max_delay_ratio ;
   Float max_delay_dev_ratio ;
   Float min_delay ;
   Float asymmetry ;
   Float offset ;
   uint32_t flags ;
   int32_t filter_length ;
   uint32_t cert_set ;
   uint32_t reserved[2] ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_NTP_Source_1044133112 REQ_NTP_Source;
struct __anonstruct_REQ_Del_Source_1044133113 {
   IPAddr ip_addr ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Del_Source_1044133113 REQ_Del_Source;
struct __anonstruct_REQ_Dfreq_1046587167 {
   Float dfreq ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Dfreq_1046587167 REQ_Dfreq;
struct __anonstruct_REQ_Doffset_1046587168 {
   Float doffset ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Doffset_1046587168 REQ_Doffset;
struct __anonstruct_REQ_Sourcestats_146699947 {
   uint32_t index ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_Sourcestats_146699947 REQ_Sourcestats;
struct __anonstruct_REQ_ClientAccessesByIndex_1072063697 {
   uint32_t first_index ;
   uint32_t n_clients ;
   uint32_t min_hits ;
   uint32_t reset ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_ClientAccessesByIndex_1072063697 REQ_ClientAccessesByIndex;
struct __anonstruct_REQ_ManualDelete_1072063698 {
   int32_t index ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_ManualDelete_1072063698 REQ_ManualDelete;
struct __anonstruct_REQ_ReselectDistance_1072063699 {
   Float distance ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_ReselectDistance_1072063699 REQ_ReselectDistance;
struct __anonstruct_REQ_SmoothTime_1072063700 {
   int32_t option ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_SmoothTime_1072063700 REQ_SmoothTime;
struct __anonstruct_REQ_NTPData_1072063701 {
   IPAddr ip_addr ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_NTPData_1072063701 REQ_NTPData;
struct __anonstruct_REQ_NTPSourceName_1072063702 {
   IPAddr ip_addr ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_NTPSourceName_1072063702 REQ_NTPSourceName;
struct __anonstruct_REQ_AuthData_1072063703 {
   IPAddr ip_addr ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_AuthData_1072063703 REQ_AuthData;
struct __anonstruct_REQ_SelectData_1072063704 {
   uint32_t index ;
   int32_t EOR ;
};
typedef struct __anonstruct_REQ_SelectData_1072063704 REQ_SelectData;
union __anonunion_data_1016237402 {
   REQ_Null null ;
   REQ_Online online ;
   REQ_Offline offline ;
   REQ_Burst burst ;
   REQ_Modify_Minpoll modify_minpoll ;
   REQ_Modify_Maxpoll modify_maxpoll ;
   REQ_Dump dump ;
   REQ_Modify_Maxdelay modify_maxdelay ;
   REQ_Modify_Maxdelayratio modify_maxdelayratio ;
   REQ_Modify_Maxdelaydevratio modify_maxdelaydevratio ;
   REQ_Modify_Minstratum modify_minstratum ;
   REQ_Modify_Polltarget modify_polltarget ;
   REQ_Modify_Maxupdateskew modify_maxupdateskew ;
   REQ_Modify_Makestep modify_makestep ;
   REQ_Logon logon ;
   REQ_Settime settime ;
   REQ_Local local ;
   REQ_Manual manual ;
   REQ_Source_Data source_data ;
   REQ_Allow_Deny allow_deny ;
   REQ_Ac_Check ac_check ;
   REQ_NTP_Source ntp_source ;
   REQ_Del_Source del_source ;
   REQ_Dfreq dfreq ;
   REQ_Doffset doffset ;
   REQ_Sourcestats sourcestats ;
   REQ_ClientAccessesByIndex client_accesses_by_index ;
   REQ_ManualDelete manual_delete ;
   REQ_ReselectDistance reselect_distance ;
   REQ_SmoothTime smoothtime ;
   REQ_NTPData ntp_data ;
   REQ_NTPSourceName ntp_source_name ;
   REQ_AuthData auth_data ;
   REQ_SelectData select_data ;
};
struct __anonstruct_CMD_Request_904882895 {
   uint8_t version ;
   uint8_t pkt_type ;
   uint8_t res1 ;
   uint8_t res2 ;
   uint16_t command ;
   uint16_t attempt ;
   uint32_t sequence ;
   uint32_t pad1 ;
   uint32_t pad2 ;
   union __anonunion_data_1016237402 data ;
   uint8_t padding[484] ;
};
typedef struct __anonstruct_CMD_Request_904882895 CMD_Request;
struct __anonstruct_RPY_Null_1072063705 {
   int32_t EOR ;
};
typedef struct __anonstruct_RPY_Null_1072063705 RPY_Null;
struct __anonstruct_RPY_N_Sources_1072063706 {
   uint32_t n_sources ;
   int32_t EOR ;
};
typedef struct __anonstruct_RPY_N_Sources_1072063706 RPY_N_Sources;
struct __anonstruct_RPY_Source_Data_491798559 {
   IPAddr ip_addr ;
   int16_t poll ;
   uint16_t stratum ;
   uint16_t state ;
   uint16_t mode ;
   uint16_t flags ;
   uint16_t reachability ;
   uint32_t since_sample ;
   Float orig_latest_meas ;
   Float latest_meas ;
   Float latest_meas_err ;
   int32_t EOR ;
};
typedef struct __anonstruct_RPY_Source_Data_491798559 RPY_Source_Data;
struct __anonstruct_RPY_Tracking_419046012 {
   uint32_t ref_id ;
   IPAddr ip_addr ;
   uint16_t stratum ;
   uint16_t leap_status ;
   Timespec ref_time ;
   Float current_correction ;
   Float last_offset ;
   Float rms_offset ;
   Float freq_ppm ;
   Float resid_freq_ppm ;
   Float skew_ppm ;
   Float root_delay ;
   Float root_dispersion ;
   Float last_update_interval ;
   int32_t EOR ;
};
typedef struct __anonstruct_RPY_Tracking_419046012 RPY_Tracking;
struct __anonstruct_RPY_Sourcestats_919560742 {
   uint32_t ref_id ;
   IPAddr ip_addr ;
   uint32_t n_samples ;
   uint32_t n_runs ;
   uint32_t span_seconds ;
   Float sd ;
   Float resid_freq_ppm ;
   Float skew_ppm ;
   Float est_offset ;
   Float est_offset_err ;
   int32_t EOR ;
};
typedef struct __anonstruct_RPY_Sourcestats_919560742 RPY_Sourcestats;
struct __anonstruct_RPY_Rtc_1032620023 {
   Timespec ref_time ;
   uint16_t n_samples ;
   uint16_t n_runs ;
   uint32_t span_seconds ;
   Float rtc_seconds_fast ;
   Float rtc_gain_rate_ppm ;
   int32_t EOR ;
};
typedef struct __anonstruct_RPY_Rtc_1032620023 RPY_Rtc;
struct __anonstruct_RPY_ManualTimestamp_757478773 {
   Float offset ;
   Float dfreq_ppm ;
   Float new_afreq_ppm ;
   int32_t EOR ;
};
typedef struct __anonstruct_RPY_ManualTimestamp_757478773 RPY_ManualTimestamp;
struct __anonstruct_RPY_ClientAccesses_Client_616375022 {
   IPAddr ip ;
   uint32_t ntp_hits ;
   uint32_t nke_hits ;
   uint32_t cmd_hits ;
   uint32_t ntp_drops ;
   uint32_t nke_drops ;
   uint32_t cmd_drops ;
   int8_t ntp_interval ;
   int8_t nke_interval ;
   int8_t cmd_interval ;
   int8_t ntp_timeout_interval ;
   uint32_t last_ntp_hit_ago ;
   uint32_t last_nke_hit_ago ;
   uint32_t last_cmd_hit_ago ;
};
typedef struct __anonstruct_RPY_ClientAccesses_Client_616375022 RPY_ClientAccesses_Client;
struct __anonstruct_RPY_ClientAccessesByIndex_186358595 {
   uint32_t n_indices ;
   uint32_t next_index ;
   uint32_t n_clients ;
   RPY_ClientAccesses_Client clients[8] ;
   int32_t EOR ;
};
typedef struct __anonstruct_RPY_ClientAccessesByIndex_186358595 RPY_ClientAccessesByIndex;
struct __anonstruct_RPY_ServerStats_675510895 {
   uint32_t ntp_hits ;
   uint32_t nke_hits ;
   uint32_t cmd_hits ;
   uint32_t ntp_drops ;
   uint32_t nke_drops ;
   uint32_t cmd_drops ;
   uint32_t log_drops ;
   uint32_t ntp_auth_hits ;
   uint32_t ntp_interleaved_hits ;
   uint32_t ntp_timestamps ;
   uint32_t ntp_span_seconds ;
   int32_t EOR ;
};
typedef struct __anonstruct_RPY_ServerStats_675510895 RPY_ServerStats;
struct __anonstruct_RPY_ManualListSample_1068763338 {
   Timespec when ;
   Float slewed_offset ;
   Float orig_offset ;
   Float residual ;
};
typedef struct __anonstruct_RPY_ManualListSample_1068763338 RPY_ManualListSample;
struct __anonstruct_RPY_ManualList_74261832 {
   uint32_t n_samples ;
   RPY_ManualListSample samples[16] ;
   int32_t EOR ;
};
typedef struct __anonstruct_RPY_ManualList_74261832 RPY_ManualList;
struct __anonstruct_RPY_Activity_233135513 {
   int32_t online ;
   int32_t offline ;
   int32_t burst_online ;
   int32_t burst_offline ;
   int32_t unresolved ;
   int32_t EOR ;
};
typedef struct __anonstruct_RPY_Activity_233135513 RPY_Activity;
struct __anonstruct_RPY_Smoothing_180070779 {
   uint32_t flags ;
   Float offset ;
   Float freq_ppm ;
   Float wander_ppm ;
   Float last_update_ago ;
   Float remaining_time ;
   int32_t EOR ;
};
typedef struct __anonstruct_RPY_Smoothing_180070779 RPY_Smoothing;
struct __anonstruct_RPY_NTPData_575385775 {
   IPAddr remote_addr ;
   IPAddr local_addr ;
   uint16_t remote_port ;
   uint8_t leap ;
   uint8_t version ;
   uint8_t mode ;
   uint8_t stratum ;
   int8_t poll ;
   int8_t precision ;
   Float root_delay ;
   Float root_dispersion ;
   uint32_t ref_id ;
   Timespec ref_time ;
   Float offset ;
   Float peer_delay ;
   Float peer_dispersion ;
   Float response_time ;
   Float jitter_asymmetry ;
   uint16_t flags ;
   uint8_t tx_tss_char ;
   uint8_t rx_tss_char ;
   uint32_t total_tx_count ;
   uint32_t total_rx_count ;
   uint32_t total_valid_count ;
   uint32_t reserved[4] ;
   int32_t EOR ;
};
typedef struct __anonstruct_RPY_NTPData_575385775 RPY_NTPData;
struct __anonstruct_RPY_NTPSourceName_797956145 {
   uint8_t name[256] ;
   int32_t EOR ;
};
typedef struct __anonstruct_RPY_NTPSourceName_797956145 RPY_NTPSourceName;
struct __anonstruct_RPY_AuthData_356340533 {
   uint16_t mode ;
   uint16_t key_type ;
   uint32_t key_id ;
   uint16_t key_length ;
   uint16_t ke_attempts ;
   uint32_t last_ke_ago ;
   uint16_t cookies ;
   uint16_t cookie_length ;
   uint16_t nak ;
   uint16_t pad ;
   int32_t EOR ;
};
typedef struct __anonstruct_RPY_AuthData_356340533 RPY_AuthData;
struct __anonstruct_RPY_SelectData_374097778 {
   uint32_t ref_id ;
   IPAddr ip_addr ;
   uint8_t state_char ;
   uint8_t authentication ;
   uint8_t leap ;
   uint8_t pad ;
   uint16_t conf_options ;
   uint16_t eff_options ;
   uint32_t last_sample_ago ;
   Float score ;
   Float lo_limit ;
   Float hi_limit ;
   int32_t EOR ;
};
typedef struct __anonstruct_RPY_SelectData_374097778 RPY_SelectData;
union __anonunion_data_581030800 {
   RPY_Null null ;
   RPY_N_Sources n_sources ;
   RPY_Source_Data source_data ;
   RPY_ManualTimestamp manual_timestamp ;
   RPY_Tracking tracking ;
   RPY_Sourcestats sourcestats ;
   RPY_Rtc rtc ;
   RPY_ClientAccessesByIndex client_accesses_by_index ;
   RPY_ServerStats server_stats ;
   RPY_ManualList manual_list ;
   RPY_Activity activity ;
   RPY_Smoothing smoothing ;
   RPY_NTPData ntp_data ;
   RPY_NTPSourceName ntp_source_name ;
   RPY_AuthData auth_data ;
   RPY_SelectData select_data ;
};
struct __anonstruct_CMD_Reply_431914442 {
   uint8_t version ;
   uint8_t pkt_type ;
   uint8_t res1 ;
   uint8_t res2 ;
   uint16_t command ;
   uint16_t reply ;
   uint16_t status ;
   uint16_t pad1 ;
   uint16_t pad2 ;
   uint16_t pad3 ;
   uint32_t sequence ;
   uint32_t pad4 ;
   uint32_t pad5 ;
   union __anonunion_data_581030800 data ;
};
typedef struct __anonstruct_CMD_Reply_431914442 CMD_Reply;
enum __anonenum_CMC_Algorithm_794086686 {
    CMC_INVALID = 0,
    CMC_AES128 = 13,
    CMC_AES256 = 14
} ;
typedef enum __anonenum_CMC_Algorithm_794086686 CMC_Algorithm;
struct CMC_Instance_Record ;
typedef struct CMC_Instance_Record *CMC_Instance;
enum __anonenum_83571709___1 {
    MSG_OOB___1 = 1,
    MSG_PEEK___1 = 2,
    MSG_DONTROUTE___1 = 4,
    MSG_TRYHARD___1 = 4,
    MSG_CTRUNC___1 = 8,
    MSG_PROXY___1 = 16,
    MSG_TRUNC___1 = 32,
    MSG_DONTWAIT___1 = 64,
    MSG_EOR___1 = 128,
    MSG_WAITALL___1 = 256,
    MSG_FIN___1 = 512,
    MSG_SYN___1 = 1024,
    MSG_CONFIRM___1 = 2048,
    MSG_RST___1 = 4096,
    MSG_ERRQUEUE___1 = 8192,
    MSG_NOSIGNAL___1 = 16384,
    MSG_MORE___1 = 32768,
    MSG_WAITFORONE___1 = 65536,
    MSG_BATCH___1 = 262144,
    MSG_ZEROCOPY___1 = 67108864,
    MSG_FASTOPEN___1 = 536870912,
    MSG_CMSG_CLOEXEC___1 = 1073741824
} ;
enum __anonenum_617082774___1 {
    SCM_RIGHTS___1 = 1,
    SCM_CREDENTIALS___1 = 2
} ;
enum __anonenum_606441560___1 {
    SHUT_RD___1 = 0,
    SHUT_WR___1 = 1,
    SHUT_RDWR___1 = 2
} ;
enum __anonenum_264779956___1 {
    IPPROTO_IP___1 = 0,
    IPPROTO_ICMP___1 = 1,
    IPPROTO_IGMP___1 = 2,
    IPPROTO_IPIP___1 = 4,
    IPPROTO_TCP___1 = 6,
    IPPROTO_EGP___1 = 8,
    IPPROTO_PUP___1 = 12,
    IPPROTO_UDP___1 = 17,
    IPPROTO_IDP___1 = 22,
    IPPROTO_TP___1 = 29,
    IPPROTO_DCCP___1 = 33,
    IPPROTO_IPV6___1 = 41,
    IPPROTO_RSVP___1 = 46,
    IPPROTO_GRE___1 = 47,
    IPPROTO_ESP___1 = 50,
    IPPROTO_AH___1 = 51,
    IPPROTO_MTP___1 = 92,
    IPPROTO_BEETPH___1 = 94,
    IPPROTO_ENCAP___1 = 98,
    IPPROTO_PIM___1 = 103,
    IPPROTO_COMP___1 = 108,
    IPPROTO_SCTP___1 = 132,
    IPPROTO_UDPLITE___1 = 136,
    IPPROTO_MPLS___1 = 137,
    IPPROTO_ETHERNET___1 = 143,
    IPPROTO_RAW___1 = 255,
    IPPROTO_MPTCP___1 = 262,
    IPPROTO_MAX___1 = 263
} ;
enum __anonenum_218739988___1 {
    IPPROTO_HOPOPTS___1 = 0,
    IPPROTO_ROUTING___1 = 43,
    IPPROTO_FRAGMENT___1 = 44,
    IPPROTO_ICMPV6___1 = 58,
    IPPROTO_NONE___1 = 59,
    IPPROTO_DSTOPTS___1 = 60,
    IPPROTO_MH___1 = 135
} ;
enum __anonenum_662268580___1 {
    IPPORT_ECHO___1 = 7,
    IPPORT_DISCARD___1 = 9,
    IPPORT_SYSTAT___1 = 11,
    IPPORT_DAYTIME___1 = 13,
    IPPORT_NETSTAT___1 = 15,
    IPPORT_FTP___1 = 21,
    IPPORT_TELNET___1 = 23,
    IPPORT_SMTP___1 = 25,
    IPPORT_TIMESERVER___1 = 37,
    IPPORT_NAMESERVER___1 = 42,
    IPPORT_WHOIS___1 = 43,
    IPPORT_MTP___1 = 57,
    IPPORT_TFTP___1 = 69,
    IPPORT_RJE___1 = 77,
    IPPORT_FINGER___1 = 79,
    IPPORT_TTYLINK___1 = 87,
    IPPORT_SUPDUP___1 = 95,
    IPPORT_EXECSERVER___1 = 512,
    IPPORT_LOGINSERVER___1 = 513,
    IPPORT_CMDSERVER___1 = 514,
    IPPORT_EFSSERVER___1 = 520,
    IPPORT_BIFFUDP___1 = 512,
    IPPORT_WHOSERVER___1 = 513,
    IPPORT_ROUTESERVER___1 = 520,
    IPPORT_RESERVED___1 = 1024,
    IPPORT_USERRESERVED___1 = 5000
} ;
enum __anonenum_18926444___1 {
    _ISupper___1 = 256,
    _ISlower___1 = 512,
    _ISalpha___1 = 1024,
    _ISdigit___1 = 2048,
    _ISxdigit___1 = 4096,
    _ISspace___1 = 8192,
    _ISprint___1 = 16384,
    _ISgraph___1 = 32768,
    _ISblank___1 = 1,
    _IScntrl___1 = 2,
    _ISpunct___1 = 4,
    _ISalnum___1 = 8
} ;
enum __anonenum_913965969___1 {
    FP_INT_UPWARD___1 = 0,
    FP_INT_DOWNWARD___1 = 1,
    FP_INT_TOWARDZERO___1 = 2,
    FP_INT_TONEARESTFROMZERO___1 = 3,
    FP_INT_TONEAREST___1 = 4
} ;
enum __anonenum_1037408945___1 {
    FP_NAN___1 = 0,
    FP_INFINITE___1 = 1,
    FP_ZERO___1 = 2,
    FP_SUBNORMAL___1 = 3,
    FP_NORMAL___1 = 4
} ;
enum __anonenum_556971655___1 {
    SI_ASYNCNL___1 = -60,
    SI_DETHREAD___1 = -7,
    SI_TKILL___1 = -6,
    SI_SIGIO___1 = -5,
    SI_ASYNCIO___1 = -4,
    SI_MESGQ___1 = -3,
    SI_TIMER___1 = -2,
    SI_QUEUE___1 = -1,
    SI_USER___1 = 0,
    SI_KERNEL___1 = 128
} ;
enum __anonenum_640648963___1 {
    ILL_ILLOPC___1 = 1,
    ILL_ILLOPN___1 = 2,
    ILL_ILLADR___1 = 3,
    ILL_ILLTRP___1 = 4,
    ILL_PRVOPC___1 = 5,
    ILL_PRVREG___1 = 6,
    ILL_COPROC___1 = 7,
    ILL_BADSTK___1 = 8,
    ILL_BADIADDR___1 = 9
} ;
enum __anonenum_457704180___1 {
    FPE_INTDIV___1 = 1,
    FPE_INTOVF___1 = 2,
    FPE_FLTDIV___1 = 3,
    FPE_FLTOVF___1 = 4,
    FPE_FLTUND___1 = 5,
    FPE_FLTRES___1 = 6,
    FPE_FLTINV___1 = 7,
    FPE_FLTSUB___1 = 8,
    FPE_FLTUNK___1 = 14,
    FPE_CONDTRAP___1 = 15
} ;
enum __anonenum_180375148___1 {
    SEGV_MAPERR___1 = 1,
    SEGV_ACCERR___1 = 2,
    SEGV_BNDERR___1 = 3,
    SEGV_PKUERR___1 = 4,
    SEGV_ACCADI___1 = 5,
    SEGV_ADIDERR___1 = 6,
    SEGV_ADIPERR___1 = 7,
    SEGV_MTEAERR___1 = 8,
    SEGV_MTESERR___1 = 9
} ;
enum __anonenum_1036286214___1 {
    BUS_ADRALN___1 = 1,
    BUS_ADRERR___1 = 2,
    BUS_OBJERR___1 = 3,
    BUS_MCEERR_AR___1 = 4,
    BUS_MCEERR_AO___1 = 5
} ;
enum __anonenum_91015150___1 {
    TRAP_BRKPT___1 = 1,
    TRAP_TRACE___1 = 2,
    TRAP_BRANCH___1 = 3,
    TRAP_HWBKPT___1 = 4,
    TRAP_UNK___1 = 5
} ;
enum __anonenum_23175539___1 {
    CLD_EXITED___1 = 1,
    CLD_KILLED___1 = 2,
    CLD_DUMPED___1 = 3,
    CLD_TRAPPED___1 = 4,
    CLD_STOPPED___1 = 5,
    CLD_CONTINUED___1 = 6
} ;
enum __anonenum_111643124___1 {
    POLL_IN___1 = 1,
    POLL_OUT___1 = 2,
    POLL_MSG___1 = 3,
    POLL_ERR___1 = 4,
    POLL_PRI___1 = 5,
    POLL_HUP___1 = 6
} ;
enum __anonenum_852341087___1 {
    SIGEV_SIGNAL___1 = 0,
    SIGEV_NONE___1 = 1,
    SIGEV_THREAD___1 = 2,
    SIGEV_THREAD_ID___1 = 4
} ;
enum __anonenum_451154152___1 {
    REG_R8___1 = 0,
    REG_R9___1 = 1,
    REG_R10___1 = 2,
    REG_R11___1 = 3,
    REG_R12___1 = 4,
    REG_R13___1 = 5,
    REG_R14___1 = 6,
    REG_R15___1 = 7,
    REG_RDI___1 = 8,
    REG_RSI___1 = 9,
    REG_RBP___1 = 10,
    REG_RBX___1 = 11,
    REG_RDX___1 = 12,
    REG_RAX___1 = 13,
    REG_RCX___1 = 14,
    REG_RSP___1 = 15,
    REG_RIP___1 = 16,
    REG_EFL___1 = 17,
    REG_CSGSFS___1 = 18,
    REG_ERR___1 = 19,
    REG_TRAPNO___1 = 20,
    REG_OLDMASK___1 = 21,
    REG_CR2___1 = 22
} ;
enum __anonenum_437032235___1 {
    _PC_LINK_MAX___1 = 0,
    _PC_MAX_CANON___1 = 1,
    _PC_MAX_INPUT___1 = 2,
    _PC_NAME_MAX___1 = 3,
    _PC_PATH_MAX___1 = 4,
    _PC_PIPE_BUF___1 = 5,
    _PC_CHOWN_RESTRICTED___1 = 6,
    _PC_NO_TRUNC___1 = 7,
    _PC_VDISABLE___1 = 8,
    _PC_SYNC_IO___1 = 9,
    _PC_ASYNC_IO___1 = 10,
    _PC_PRIO_IO___1 = 11,
    _PC_SOCK_MAXBUF___1 = 12,
    _PC_FILESIZEBITS___1 = 13,
    _PC_REC_INCR_XFER_SIZE___1 = 14,
    _PC_REC_MAX_XFER_SIZE___1 = 15,
    _PC_REC_MIN_XFER_SIZE___1 = 16,
    _PC_REC_XFER_ALIGN___1 = 17,
    _PC_ALLOC_SIZE_MIN___1 = 18,
    _PC_SYMLINK_MAX___1 = 19,
    _PC_2_SYMLINKS___1 = 20
} ;
enum __anonenum_315186338___1 {
    _SC_ARG_MAX___1 = 0,
    _SC_CHILD_MAX___1 = 1,
    _SC_CLK_TCK___1 = 2,
    _SC_NGROUPS_MAX___1 = 3,
    _SC_OPEN_MAX___1 = 4,
    _SC_STREAM_MAX___1 = 5,
    _SC_TZNAME_MAX___1 = 6,
    _SC_JOB_CONTROL___1 = 7,
    _SC_SAVED_IDS___1 = 8,
    _SC_REALTIME_SIGNALS___1 = 9,
    _SC_PRIORITY_SCHEDULING___1 = 10,
    _SC_TIMERS___1 = 11,
    _SC_ASYNCHRONOUS_IO___1 = 12,
    _SC_PRIORITIZED_IO___1 = 13,
    _SC_SYNCHRONIZED_IO___1 = 14,
    _SC_FSYNC___1 = 15,
    _SC_MAPPED_FILES___1 = 16,
    _SC_MEMLOCK___1 = 17,
    _SC_MEMLOCK_RANGE___1 = 18,
    _SC_MEMORY_PROTECTION___1 = 19,
    _SC_MESSAGE_PASSING___1 = 20,
    _SC_SEMAPHORES___1 = 21,
    _SC_SHARED_MEMORY_OBJECTS___1 = 22,
    _SC_AIO_LISTIO_MAX___1 = 23,
    _SC_AIO_MAX___1 = 24,
    _SC_AIO_PRIO_DELTA_MAX___1 = 25,
    _SC_DELAYTIMER_MAX___1 = 26,
    _SC_MQ_OPEN_MAX___1 = 27,
    _SC_MQ_PRIO_MAX___1 = 28,
    _SC_VERSION___1 = 29,
    _SC_PAGESIZE___1 = 30,
    _SC_RTSIG_MAX___1 = 31,
    _SC_SEM_NSEMS_MAX___1 = 32,
    _SC_SEM_VALUE_MAX___1 = 33,
    _SC_SIGQUEUE_MAX___1 = 34,
    _SC_TIMER_MAX___1 = 35,
    _SC_BC_BASE_MAX___1 = 36,
    _SC_BC_DIM_MAX___1 = 37,
    _SC_BC_SCALE_MAX___1 = 38,
    _SC_BC_STRING_MAX___1 = 39,
    _SC_COLL_WEIGHTS_MAX___1 = 40,
    _SC_EQUIV_CLASS_MAX___1 = 41,
    _SC_EXPR_NEST_MAX___1 = 42,
    _SC_LINE_MAX___1 = 43,
    _SC_RE_DUP_MAX___1 = 44,
    _SC_CHARCLASS_NAME_MAX___1 = 45,
    _SC_2_VERSION___1 = 46,
    _SC_2_C_BIND___1 = 47,
    _SC_2_C_DEV___1 = 48,
    _SC_2_FORT_DEV___1 = 49,
    _SC_2_FORT_RUN___1 = 50,
    _SC_2_SW_DEV___1 = 51,
    _SC_2_LOCALEDEF___1 = 52,
    _SC_PII___1 = 53,
    _SC_PII_XTI___1 = 54,
    _SC_PII_SOCKET___1 = 55,
    _SC_PII_INTERNET___1 = 56,
    _SC_PII_OSI___1 = 57,
    _SC_POLL___1 = 58,
    _SC_SELECT___1 = 59,
    _SC_UIO_MAXIOV___1 = 60,
    _SC_IOV_MAX___1 = 60,
    _SC_PII_INTERNET_STREAM___1 = 61,
    _SC_PII_INTERNET_DGRAM___1 = 62,
    _SC_PII_OSI_COTS___1 = 63,
    _SC_PII_OSI_CLTS___1 = 64,
    _SC_PII_OSI_M___1 = 65,
    _SC_T_IOV_MAX___1 = 66,
    _SC_THREADS___1 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___1 = 68,
    _SC_GETGR_R_SIZE_MAX___1 = 69,
    _SC_GETPW_R_SIZE_MAX___1 = 70,
    _SC_LOGIN_NAME_MAX___1 = 71,
    _SC_TTY_NAME_MAX___1 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___1 = 73,
    _SC_THREAD_KEYS_MAX___1 = 74,
    _SC_THREAD_STACK_MIN___1 = 75,
    _SC_THREAD_THREADS_MAX___1 = 76,
    _SC_THREAD_ATTR_STACKADDR___1 = 77,
    _SC_THREAD_ATTR_STACKSIZE___1 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___1 = 79,
    _SC_THREAD_PRIO_INHERIT___1 = 80,
    _SC_THREAD_PRIO_PROTECT___1 = 81,
    _SC_THREAD_PROCESS_SHARED___1 = 82,
    _SC_NPROCESSORS_CONF___1 = 83,
    _SC_NPROCESSORS_ONLN___1 = 84,
    _SC_PHYS_PAGES___1 = 85,
    _SC_AVPHYS_PAGES___1 = 86,
    _SC_ATEXIT_MAX___1 = 87,
    _SC_PASS_MAX___1 = 88,
    _SC_XOPEN_VERSION___1 = 89,
    _SC_XOPEN_XCU_VERSION___1 = 90,
    _SC_XOPEN_UNIX___1 = 91,
    _SC_XOPEN_CRYPT___1 = 92,
    _SC_XOPEN_ENH_I18N___1 = 93,
    _SC_XOPEN_SHM___1 = 94,
    _SC_2_CHAR_TERM___1 = 95,
    _SC_2_C_VERSION___1 = 96,
    _SC_2_UPE___1 = 97,
    _SC_XOPEN_XPG2___1 = 98,
    _SC_XOPEN_XPG3___1 = 99,
    _SC_XOPEN_XPG4___1 = 100,
    _SC_CHAR_BIT___1 = 101,
    _SC_CHAR_MAX___1 = 102,
    _SC_CHAR_MIN___1 = 103,
    _SC_INT_MAX___1 = 104,
    _SC_INT_MIN___1 = 105,
    _SC_LONG_BIT___1 = 106,
    _SC_WORD_BIT___1 = 107,
    _SC_MB_LEN_MAX___1 = 108,
    _SC_NZERO___1 = 109,
    _SC_SSIZE_MAX___1 = 110,
    _SC_SCHAR_MAX___1 = 111,
    _SC_SCHAR_MIN___1 = 112,
    _SC_SHRT_MAX___1 = 113,
    _SC_SHRT_MIN___1 = 114,
    _SC_UCHAR_MAX___1 = 115,
    _SC_UINT_MAX___1 = 116,
    _SC_ULONG_MAX___1 = 117,
    _SC_USHRT_MAX___1 = 118,
    _SC_NL_ARGMAX___1 = 119,
    _SC_NL_LANGMAX___1 = 120,
    _SC_NL_MSGMAX___1 = 121,
    _SC_NL_NMAX___1 = 122,
    _SC_NL_SETMAX___1 = 123,
    _SC_NL_TEXTMAX___1 = 124,
    _SC_XBS5_ILP32_OFF32___1 = 125,
    _SC_XBS5_ILP32_OFFBIG___1 = 126,
    _SC_XBS5_LP64_OFF64___1 = 127,
    _SC_XBS5_LPBIG_OFFBIG___1 = 128,
    _SC_XOPEN_LEGACY___1 = 129,
    _SC_XOPEN_REALTIME___1 = 130,
    _SC_XOPEN_REALTIME_THREADS___1 = 131,
    _SC_ADVISORY_INFO___1 = 132,
    _SC_BARRIERS___1 = 133,
    _SC_BASE___1 = 134,
    _SC_C_LANG_SUPPORT___1 = 135,
    _SC_C_LANG_SUPPORT_R___1 = 136,
    _SC_CLOCK_SELECTION___1 = 137,
    _SC_CPUTIME___1 = 138,
    _SC_THREAD_CPUTIME___1 = 139,
    _SC_DEVICE_IO___1 = 140,
    _SC_DEVICE_SPECIFIC___1 = 141,
    _SC_DEVICE_SPECIFIC_R___1 = 142,
    _SC_FD_MGMT___1 = 143,
    _SC_FIFO___1 = 144,
    _SC_PIPE___1 = 145,
    _SC_FILE_ATTRIBUTES___1 = 146,
    _SC_FILE_LOCKING___1 = 147,
    _SC_FILE_SYSTEM___1 = 148,
    _SC_MONOTONIC_CLOCK___1 = 149,
    _SC_MULTI_PROCESS___1 = 150,
    _SC_SINGLE_PROCESS___1 = 151,
    _SC_NETWORKING___1 = 152,
    _SC_READER_WRITER_LOCKS___1 = 153,
    _SC_SPIN_LOCKS___1 = 154,
    _SC_REGEXP___1 = 155,
    _SC_REGEX_VERSION___1 = 156,
    _SC_SHELL___1 = 157,
    _SC_SIGNALS___1 = 158,
    _SC_SPAWN___1 = 159,
    _SC_SPORADIC_SERVER___1 = 160,
    _SC_THREAD_SPORADIC_SERVER___1 = 161,
    _SC_SYSTEM_DATABASE___1 = 162,
    _SC_SYSTEM_DATABASE_R___1 = 163,
    _SC_TIMEOUTS___1 = 164,
    _SC_TYPED_MEMORY_OBJECTS___1 = 165,
    _SC_USER_GROUPS___1 = 166,
    _SC_USER_GROUPS_R___1 = 167,
    _SC_2_PBS___1 = 168,
    _SC_2_PBS_ACCOUNTING___1 = 169,
    _SC_2_PBS_LOCATE___1 = 170,
    _SC_2_PBS_MESSAGE___1 = 171,
    _SC_2_PBS_TRACK___1 = 172,
    _SC_SYMLOOP_MAX___1 = 173,
    _SC_STREAMS___1 = 174,
    _SC_2_PBS_CHECKPOINT___1 = 175,
    _SC_V6_ILP32_OFF32___1 = 176,
    _SC_V6_ILP32_OFFBIG___1 = 177,
    _SC_V6_LP64_OFF64___1 = 178,
    _SC_V6_LPBIG_OFFBIG___1 = 179,
    _SC_HOST_NAME_MAX___1 = 180,
    _SC_TRACE___1 = 181,
    _SC_TRACE_EVENT_FILTER___1 = 182,
    _SC_TRACE_INHERIT___1 = 183,
    _SC_TRACE_LOG___1 = 184,
    _SC_LEVEL1_ICACHE_SIZE___1 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___1 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___1 = 187,
    _SC_LEVEL1_DCACHE_SIZE___1 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___1 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___1 = 190,
    _SC_LEVEL2_CACHE_SIZE___1 = 191,
    _SC_LEVEL2_CACHE_ASSOC___1 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___1 = 193,
    _SC_LEVEL3_CACHE_SIZE___1 = 194,
    _SC_LEVEL3_CACHE_ASSOC___1 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___1 = 196,
    _SC_LEVEL4_CACHE_SIZE___1 = 197,
    _SC_LEVEL4_CACHE_ASSOC___1 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___1 = 199,
    _SC_IPV6___1 = 235,
    _SC_RAW_SOCKETS___1 = 236,
    _SC_V7_ILP32_OFF32___1 = 237,
    _SC_V7_ILP32_OFFBIG___1 = 238,
    _SC_V7_LP64_OFF64___1 = 239,
    _SC_V7_LPBIG_OFFBIG___1 = 240,
    _SC_SS_REPL_MAX___1 = 241,
    _SC_TRACE_EVENT_NAME_MAX___1 = 242,
    _SC_TRACE_NAME_MAX___1 = 243,
    _SC_TRACE_SYS_MAX___1 = 244,
    _SC_TRACE_USER_EVENT_MAX___1 = 245,
    _SC_XOPEN_STREAMS___1 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___1 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___1 = 248,
    _SC_MINSIGSTKSZ___1 = 249,
    _SC_SIGSTKSZ___1 = 250
} ;
enum __anonenum_875524036___1 {
    _CS_PATH___1 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___1 = 1,
    _CS_GNU_LIBC_VERSION___1 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___1 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___1 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___1 = 5,
    _CS_LFS_CFLAGS___1 = 1000,
    _CS_LFS_LDFLAGS___1 = 1001,
    _CS_LFS_LIBS___1 = 1002,
    _CS_LFS_LINTFLAGS___1 = 1003,
    _CS_LFS64_CFLAGS___1 = 1004,
    _CS_LFS64_LDFLAGS___1 = 1005,
    _CS_LFS64_LIBS___1 = 1006,
    _CS_LFS64_LINTFLAGS___1 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___1 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___1 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___1 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___1 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___1 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___1 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___1 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___1 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___1 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___1 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___1 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___1 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___1 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___1 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___1 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___1 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___1 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___1 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___1 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___1 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___1 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___1 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___1 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___1 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___1 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___1 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___1 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___1 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___1 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___1 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___1 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___1 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___1 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___1 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___1 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___1 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___1 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___1 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___1 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___1 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___1 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___1 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___1 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___1 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___1 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___1 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___1 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___1 = 1147,
    _CS_V6_ENV___1 = 1148,
    _CS_V7_ENV___1 = 1149
} ;
enum __anonenum_57186863___1 {
    SS_ONSTACK___1 = 1,
    SS_DISABLE___1 = 2
} ;
enum __anonenum_REF_LeapMode_884739971 {
    REF_LeapModeSystem = 0,
    REF_LeapModeSlew = 1,
    REF_LeapModeStep = 2,
    REF_LeapModeIgnore = 3
} ;
typedef enum __anonenum_REF_LeapMode_884739971 REF_LeapMode;
enum __anonenum_REF_Mode_814631379 {
    REF_ModeNormal = 0,
    REF_ModeInitStepSlew = 1,
    REF_ModeUpdateOnce = 2,
    REF_ModePrintOnce = 3,
    REF_ModeIgnore = 4
} ;
typedef enum __anonenum_REF_Mode_814631379 REF_Mode;
typedef void (*REF_ModeEndHandler)(int result );
enum __anonenum_CNF_HwTs_RxFilter_495161867 {
    CNF_HWTS_RXFILTER_ANY = 0,
    CNF_HWTS_RXFILTER_NONE = 1,
    CNF_HWTS_RXFILTER_NTP = 2,
    CNF_HWTS_RXFILTER_PTP = 3,
    CNF_HWTS_RXFILTER_ALL = 4
} ;
typedef enum __anonenum_CNF_HwTs_RxFilter_495161867 CNF_HwTs_RxFilter;
struct __anonstruct_CNF_HwTsInterface_944255021 {
   char *name ;
   int minpoll ;
   int min_samples ;
   int max_samples ;
   int nocrossts ;
   CNF_HwTs_RxFilter rxfilter ;
   double precision ;
   double tx_comp ;
   double rx_comp ;
};
typedef struct __anonstruct_CNF_HwTsInterface_944255021 CNF_HwTsInterface;
enum __anonenum_NTP_Source_Type_837427883 {
    NTP_SERVER = 0,
    NTP_PEER = 1
} ;
typedef enum __anonenum_NTP_Source_Type_837427883 NTP_Source_Type;
enum __anonenum_NTP_Timestamp_Source_1025412448 {
    NTP_TS_DAEMON = 0,
    NTP_TS_KERNEL = 1,
    NTP_TS_HARDWARE = 2
} ;
typedef enum __anonenum_NTP_Timestamp_Source_1025412448 NTP_Timestamp_Source;
struct __anonstruct_NTP_Local_Timestamp_123667326 {
   struct timespec ts ;
   double err ;
   NTP_Timestamp_Source source ;
};
typedef struct __anonstruct_NTP_Local_Timestamp_123667326 NTP_Local_Timestamp;
struct NCR_Instance_Record ;
typedef struct NCR_Instance_Record *NCR_Instance;
enum __anonenum_NSR_Status_139451223 {
    NSR_Success = 0,
    NSR_NoSuchSource = 1,
    NSR_AlreadyInUse = 2,
    NSR_TooManySources = 3,
    NSR_InvalidAF = 4,
    NSR_InvalidName = 5,
    NSR_UnresolvedName = 6
} ;
typedef enum __anonenum_NSR_Status_139451223 NSR_Status;
typedef void (*NSR_SourceResolvingEndHandler)(void);
enum __anonenum_SIV_Algorithm_211322349 {
    AEAD_AES_SIV_CMAC_256 = 15,
    AEAD_AES_SIV_CMAC_384 = 16,
    AEAD_AES_SIV_CMAC_512 = 17,
    AEAD_AES_128_GCM_SIV = 30,
    AEAD_AES_256_GCM_SIV = 31
} ;
typedef enum __anonenum_SIV_Algorithm_211322349 SIV_Algorithm;
struct SIV_Instance_Record ;
typedef struct SIV_Instance_Record *SIV_Instance;
struct __anonstruct_NKE_Key_25692831 {
   int length ;
   unsigned char key[32] ;
};
typedef struct __anonstruct_NKE_Key_25692831 NKE_Key;
struct __anonstruct_NKE_Context_482017077 {
   SIV_Algorithm algorithm ;
   NKE_Key c2s ;
   NKE_Key s2c ;
};
typedef struct __anonstruct_NKE_Context_482017077 NKE_Context;
struct __anonstruct_NKE_Cookie_482017078 {
   int length ;
   unsigned char cookie[256] ;
};
typedef struct __anonstruct_NKE_Cookie_482017078 NKE_Cookie;
struct __anonstruct_RefclockParameters_809919092 {
   char *driver_name ;
   char *driver_parameter ;
   int driver_poll ;
   int poll ;
   int filter_length ;
   int pps_forced ;
   int pps_rate ;
   int min_samples ;
   int max_samples ;
   int sel_options ;
   int max_lock_age ;
   int stratum ;
   int tai ;
   uint32_t ref_id ;
   uint32_t lock_ref_id ;
   double offset ;
   double delay ;
   double precision ;
   double max_dispersion ;
   double pulse_width ;
};
typedef struct __anonstruct_RefclockParameters_809919092 RefclockParameters;
struct RCL_Instance_Record ;
typedef struct RCL_Instance_Record *RCL_Instance;
struct __anonstruct_RefclockDriver_139017559 {
   int (*init)(RCL_Instance instance ) ;
   void (*fini)(RCL_Instance instance ) ;
   int (*poll)(RCL_Instance instance ) ;
};
typedef struct __anonstruct_RefclockDriver_139017559 RefclockDriver;
enum __anonenum_SCK_AddressType_841169481 {
    SCK_ADDR_UNSPEC = 0,
    SCK_ADDR_IP = 1,
    SCK_ADDR_UNIX = 2
} ;
typedef enum __anonenum_SCK_AddressType_841169481 SCK_AddressType;
union __anonunion_remote_addr_476520550 {
   IPSockAddr ip ;
   char const *path ;
};
union __anonunion_local_addr_728112605 {
   IPAddr ip ;
};
struct __anonstruct_timestamp_559854800 {
   struct timespec kernel ;
   struct timespec hw ;
   int if_index ;
   int l2_length ;
   int tx_flags ;
};
struct __anonstruct_SCK_Message_90571441 {
   void *data ;
   int length ;
   SCK_AddressType addr_type ;
   int if_index ;
   union __anonunion_remote_addr_476520550 remote_addr ;
   union __anonunion_local_addr_728112605 local_addr ;
   struct __anonstruct_timestamp_559854800 timestamp ;
   int descriptor ;
};
typedef struct __anonstruct_SCK_Message_90571441 SCK_Message;
enum __anonenum_LOG_Severity_741470402 {
    LOGS_DEBUG = -1,
    LOGS_INFO = 0,
    LOGS_WARN = 1,
    LOGS_ERR = 2,
    LOGS_FATAL = 3
} ;
typedef enum __anonenum_LOG_Severity_741470402 LOG_Severity;
typedef int LOG_FileID;
struct __anonstruct_NTP_Source_192544319 {
   NTP_Source_Type type ;
   int pool ;
   CPS_NTP_Source params ;
};
typedef struct __anonstruct_NTP_Source_192544319 NTP_Source;
struct _AllowDeny {
   IPAddr ip ;
   int subnet_bits ;
   int all ;
   int allow ;
};
typedef struct _AllowDeny AllowDeny;
struct __anonstruct_NTP_Broadcast_Destination_944073855 {
   NTP_Remote_Address addr ;
   int interval ;
};
typedef struct __anonstruct_NTP_Broadcast_Destination_944073855 NTP_Broadcast_Destination;
enum __anonenum_83571709___2 {
    MSG_OOB___2 = 1,
    MSG_PEEK___2 = 2,
    MSG_DONTROUTE___2 = 4,
    MSG_TRYHARD___2 = 4,
    MSG_CTRUNC___2 = 8,
    MSG_PROXY___2 = 16,
    MSG_TRUNC___2 = 32,
    MSG_DONTWAIT___2 = 64,
    MSG_EOR___2 = 128,
    MSG_WAITALL___2 = 256,
    MSG_FIN___2 = 512,
    MSG_SYN___2 = 1024,
    MSG_CONFIRM___2 = 2048,
    MSG_RST___2 = 4096,
    MSG_ERRQUEUE___2 = 8192,
    MSG_NOSIGNAL___2 = 16384,
    MSG_MORE___2 = 32768,
    MSG_WAITFORONE___2 = 65536,
    MSG_BATCH___2 = 262144,
    MSG_ZEROCOPY___2 = 67108864,
    MSG_FASTOPEN___2 = 536870912,
    MSG_CMSG_CLOEXEC___2 = 1073741824
} ;
enum __anonenum_617082774___2 {
    SCM_RIGHTS___2 = 1,
    SCM_CREDENTIALS___2 = 2
} ;
enum __anonenum_606441560___2 {
    SHUT_RD___2 = 0,
    SHUT_WR___2 = 1,
    SHUT_RDWR___2 = 2
} ;
enum __anonenum_264779956___2 {
    IPPROTO_IP___2 = 0,
    IPPROTO_ICMP___2 = 1,
    IPPROTO_IGMP___2 = 2,
    IPPROTO_IPIP___2 = 4,
    IPPROTO_TCP___2 = 6,
    IPPROTO_EGP___2 = 8,
    IPPROTO_PUP___2 = 12,
    IPPROTO_UDP___2 = 17,
    IPPROTO_IDP___2 = 22,
    IPPROTO_TP___2 = 29,
    IPPROTO_DCCP___2 = 33,
    IPPROTO_IPV6___2 = 41,
    IPPROTO_RSVP___2 = 46,
    IPPROTO_GRE___2 = 47,
    IPPROTO_ESP___2 = 50,
    IPPROTO_AH___2 = 51,
    IPPROTO_MTP___2 = 92,
    IPPROTO_BEETPH___2 = 94,
    IPPROTO_ENCAP___2 = 98,
    IPPROTO_PIM___2 = 103,
    IPPROTO_COMP___2 = 108,
    IPPROTO_SCTP___2 = 132,
    IPPROTO_UDPLITE___2 = 136,
    IPPROTO_MPLS___2 = 137,
    IPPROTO_ETHERNET___2 = 143,
    IPPROTO_RAW___2 = 255,
    IPPROTO_MPTCP___2 = 262,
    IPPROTO_MAX___2 = 263
} ;
enum __anonenum_218739988___2 {
    IPPROTO_HOPOPTS___2 = 0,
    IPPROTO_ROUTING___2 = 43,
    IPPROTO_FRAGMENT___2 = 44,
    IPPROTO_ICMPV6___2 = 58,
    IPPROTO_NONE___2 = 59,
    IPPROTO_DSTOPTS___2 = 60,
    IPPROTO_MH___2 = 135
} ;
enum __anonenum_662268580___2 {
    IPPORT_ECHO___2 = 7,
    IPPORT_DISCARD___2 = 9,
    IPPORT_SYSTAT___2 = 11,
    IPPORT_DAYTIME___2 = 13,
    IPPORT_NETSTAT___2 = 15,
    IPPORT_FTP___2 = 21,
    IPPORT_TELNET___2 = 23,
    IPPORT_SMTP___2 = 25,
    IPPORT_TIMESERVER___2 = 37,
    IPPORT_NAMESERVER___2 = 42,
    IPPORT_WHOIS___2 = 43,
    IPPORT_MTP___2 = 57,
    IPPORT_TFTP___2 = 69,
    IPPORT_RJE___2 = 77,
    IPPORT_FINGER___2 = 79,
    IPPORT_TTYLINK___2 = 87,
    IPPORT_SUPDUP___2 = 95,
    IPPORT_EXECSERVER___2 = 512,
    IPPORT_LOGINSERVER___2 = 513,
    IPPORT_CMDSERVER___2 = 514,
    IPPORT_EFSSERVER___2 = 520,
    IPPORT_BIFFUDP___2 = 512,
    IPPORT_WHOSERVER___2 = 513,
    IPPORT_ROUTESERVER___2 = 520,
    IPPORT_RESERVED___2 = 1024,
    IPPORT_USERRESERVED___2 = 5000
} ;
enum __anonenum_18926444___2 {
    _ISupper___2 = 256,
    _ISlower___2 = 512,
    _ISalpha___2 = 1024,
    _ISdigit___2 = 2048,
    _ISxdigit___2 = 4096,
    _ISspace___2 = 8192,
    _ISprint___2 = 16384,
    _ISgraph___2 = 32768,
    _ISblank___2 = 1,
    _IScntrl___2 = 2,
    _ISpunct___2 = 4,
    _ISalnum___2 = 8
} ;
enum __anonenum_913965969___2 {
    FP_INT_UPWARD___2 = 0,
    FP_INT_DOWNWARD___2 = 1,
    FP_INT_TOWARDZERO___2 = 2,
    FP_INT_TONEARESTFROMZERO___2 = 3,
    FP_INT_TONEAREST___2 = 4
} ;
enum __anonenum_1037408945___2 {
    FP_NAN___2 = 0,
    FP_INFINITE___2 = 1,
    FP_ZERO___2 = 2,
    FP_SUBNORMAL___2 = 3,
    FP_NORMAL___2 = 4
} ;
enum __anonenum_556971655___2 {
    SI_ASYNCNL___2 = -60,
    SI_DETHREAD___2 = -7,
    SI_TKILL___2 = -6,
    SI_SIGIO___2 = -5,
    SI_ASYNCIO___2 = -4,
    SI_MESGQ___2 = -3,
    SI_TIMER___2 = -2,
    SI_QUEUE___2 = -1,
    SI_USER___2 = 0,
    SI_KERNEL___2 = 128
} ;
enum __anonenum_640648963___2 {
    ILL_ILLOPC___2 = 1,
    ILL_ILLOPN___2 = 2,
    ILL_ILLADR___2 = 3,
    ILL_ILLTRP___2 = 4,
    ILL_PRVOPC___2 = 5,
    ILL_PRVREG___2 = 6,
    ILL_COPROC___2 = 7,
    ILL_BADSTK___2 = 8,
    ILL_BADIADDR___2 = 9
} ;
enum __anonenum_457704180___2 {
    FPE_INTDIV___2 = 1,
    FPE_INTOVF___2 = 2,
    FPE_FLTDIV___2 = 3,
    FPE_FLTOVF___2 = 4,
    FPE_FLTUND___2 = 5,
    FPE_FLTRES___2 = 6,
    FPE_FLTINV___2 = 7,
    FPE_FLTSUB___2 = 8,
    FPE_FLTUNK___2 = 14,
    FPE_CONDTRAP___2 = 15
} ;
enum __anonenum_180375148___2 {
    SEGV_MAPERR___2 = 1,
    SEGV_ACCERR___2 = 2,
    SEGV_BNDERR___2 = 3,
    SEGV_PKUERR___2 = 4,
    SEGV_ACCADI___2 = 5,
    SEGV_ADIDERR___2 = 6,
    SEGV_ADIPERR___2 = 7,
    SEGV_MTEAERR___2 = 8,
    SEGV_MTESERR___2 = 9
} ;
enum __anonenum_1036286214___2 {
    BUS_ADRALN___2 = 1,
    BUS_ADRERR___2 = 2,
    BUS_OBJERR___2 = 3,
    BUS_MCEERR_AR___2 = 4,
    BUS_MCEERR_AO___2 = 5
} ;
enum __anonenum_91015150___2 {
    TRAP_BRKPT___2 = 1,
    TRAP_TRACE___2 = 2,
    TRAP_BRANCH___2 = 3,
    TRAP_HWBKPT___2 = 4,
    TRAP_UNK___2 = 5
} ;
enum __anonenum_23175539___2 {
    CLD_EXITED___2 = 1,
    CLD_KILLED___2 = 2,
    CLD_DUMPED___2 = 3,
    CLD_TRAPPED___2 = 4,
    CLD_STOPPED___2 = 5,
    CLD_CONTINUED___2 = 6
} ;
enum __anonenum_111643124___2 {
    POLL_IN___2 = 1,
    POLL_OUT___2 = 2,
    POLL_MSG___2 = 3,
    POLL_ERR___2 = 4,
    POLL_PRI___2 = 5,
    POLL_HUP___2 = 6
} ;
enum __anonenum_852341087___2 {
    SIGEV_SIGNAL___2 = 0,
    SIGEV_NONE___2 = 1,
    SIGEV_THREAD___2 = 2,
    SIGEV_THREAD_ID___2 = 4
} ;
enum __anonenum_451154152___2 {
    REG_R8___2 = 0,
    REG_R9___2 = 1,
    REG_R10___2 = 2,
    REG_R11___2 = 3,
    REG_R12___2 = 4,
    REG_R13___2 = 5,
    REG_R14___2 = 6,
    REG_R15___2 = 7,
    REG_RDI___2 = 8,
    REG_RSI___2 = 9,
    REG_RBP___2 = 10,
    REG_RBX___2 = 11,
    REG_RDX___2 = 12,
    REG_RAX___2 = 13,
    REG_RCX___2 = 14,
    REG_RSP___2 = 15,
    REG_RIP___2 = 16,
    REG_EFL___2 = 17,
    REG_CSGSFS___2 = 18,
    REG_ERR___2 = 19,
    REG_TRAPNO___2 = 20,
    REG_OLDMASK___2 = 21,
    REG_CR2___2 = 22
} ;
enum __anonenum_437032235___2 {
    _PC_LINK_MAX___2 = 0,
    _PC_MAX_CANON___2 = 1,
    _PC_MAX_INPUT___2 = 2,
    _PC_NAME_MAX___2 = 3,
    _PC_PATH_MAX___2 = 4,
    _PC_PIPE_BUF___2 = 5,
    _PC_CHOWN_RESTRICTED___2 = 6,
    _PC_NO_TRUNC___2 = 7,
    _PC_VDISABLE___2 = 8,
    _PC_SYNC_IO___2 = 9,
    _PC_ASYNC_IO___2 = 10,
    _PC_PRIO_IO___2 = 11,
    _PC_SOCK_MAXBUF___2 = 12,
    _PC_FILESIZEBITS___2 = 13,
    _PC_REC_INCR_XFER_SIZE___2 = 14,
    _PC_REC_MAX_XFER_SIZE___2 = 15,
    _PC_REC_MIN_XFER_SIZE___2 = 16,
    _PC_REC_XFER_ALIGN___2 = 17,
    _PC_ALLOC_SIZE_MIN___2 = 18,
    _PC_SYMLINK_MAX___2 = 19,
    _PC_2_SYMLINKS___2 = 20
} ;
enum __anonenum_315186338___2 {
    _SC_ARG_MAX___2 = 0,
    _SC_CHILD_MAX___2 = 1,
    _SC_CLK_TCK___2 = 2,
    _SC_NGROUPS_MAX___2 = 3,
    _SC_OPEN_MAX___2 = 4,
    _SC_STREAM_MAX___2 = 5,
    _SC_TZNAME_MAX___2 = 6,
    _SC_JOB_CONTROL___2 = 7,
    _SC_SAVED_IDS___2 = 8,
    _SC_REALTIME_SIGNALS___2 = 9,
    _SC_PRIORITY_SCHEDULING___2 = 10,
    _SC_TIMERS___2 = 11,
    _SC_ASYNCHRONOUS_IO___2 = 12,
    _SC_PRIORITIZED_IO___2 = 13,
    _SC_SYNCHRONIZED_IO___2 = 14,
    _SC_FSYNC___2 = 15,
    _SC_MAPPED_FILES___2 = 16,
    _SC_MEMLOCK___2 = 17,
    _SC_MEMLOCK_RANGE___2 = 18,
    _SC_MEMORY_PROTECTION___2 = 19,
    _SC_MESSAGE_PASSING___2 = 20,
    _SC_SEMAPHORES___2 = 21,
    _SC_SHARED_MEMORY_OBJECTS___2 = 22,
    _SC_AIO_LISTIO_MAX___2 = 23,
    _SC_AIO_MAX___2 = 24,
    _SC_AIO_PRIO_DELTA_MAX___2 = 25,
    _SC_DELAYTIMER_MAX___2 = 26,
    _SC_MQ_OPEN_MAX___2 = 27,
    _SC_MQ_PRIO_MAX___2 = 28,
    _SC_VERSION___2 = 29,
    _SC_PAGESIZE___2 = 30,
    _SC_RTSIG_MAX___2 = 31,
    _SC_SEM_NSEMS_MAX___2 = 32,
    _SC_SEM_VALUE_MAX___2 = 33,
    _SC_SIGQUEUE_MAX___2 = 34,
    _SC_TIMER_MAX___2 = 35,
    _SC_BC_BASE_MAX___2 = 36,
    _SC_BC_DIM_MAX___2 = 37,
    _SC_BC_SCALE_MAX___2 = 38,
    _SC_BC_STRING_MAX___2 = 39,
    _SC_COLL_WEIGHTS_MAX___2 = 40,
    _SC_EQUIV_CLASS_MAX___2 = 41,
    _SC_EXPR_NEST_MAX___2 = 42,
    _SC_LINE_MAX___2 = 43,
    _SC_RE_DUP_MAX___2 = 44,
    _SC_CHARCLASS_NAME_MAX___2 = 45,
    _SC_2_VERSION___2 = 46,
    _SC_2_C_BIND___2 = 47,
    _SC_2_C_DEV___2 = 48,
    _SC_2_FORT_DEV___2 = 49,
    _SC_2_FORT_RUN___2 = 50,
    _SC_2_SW_DEV___2 = 51,
    _SC_2_LOCALEDEF___2 = 52,
    _SC_PII___2 = 53,
    _SC_PII_XTI___2 = 54,
    _SC_PII_SOCKET___2 = 55,
    _SC_PII_INTERNET___2 = 56,
    _SC_PII_OSI___2 = 57,
    _SC_POLL___2 = 58,
    _SC_SELECT___2 = 59,
    _SC_UIO_MAXIOV___2 = 60,
    _SC_IOV_MAX___2 = 60,
    _SC_PII_INTERNET_STREAM___2 = 61,
    _SC_PII_INTERNET_DGRAM___2 = 62,
    _SC_PII_OSI_COTS___2 = 63,
    _SC_PII_OSI_CLTS___2 = 64,
    _SC_PII_OSI_M___2 = 65,
    _SC_T_IOV_MAX___2 = 66,
    _SC_THREADS___2 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___2 = 68,
    _SC_GETGR_R_SIZE_MAX___2 = 69,
    _SC_GETPW_R_SIZE_MAX___2 = 70,
    _SC_LOGIN_NAME_MAX___2 = 71,
    _SC_TTY_NAME_MAX___2 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___2 = 73,
    _SC_THREAD_KEYS_MAX___2 = 74,
    _SC_THREAD_STACK_MIN___2 = 75,
    _SC_THREAD_THREADS_MAX___2 = 76,
    _SC_THREAD_ATTR_STACKADDR___2 = 77,
    _SC_THREAD_ATTR_STACKSIZE___2 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___2 = 79,
    _SC_THREAD_PRIO_INHERIT___2 = 80,
    _SC_THREAD_PRIO_PROTECT___2 = 81,
    _SC_THREAD_PROCESS_SHARED___2 = 82,
    _SC_NPROCESSORS_CONF___2 = 83,
    _SC_NPROCESSORS_ONLN___2 = 84,
    _SC_PHYS_PAGES___2 = 85,
    _SC_AVPHYS_PAGES___2 = 86,
    _SC_ATEXIT_MAX___2 = 87,
    _SC_PASS_MAX___2 = 88,
    _SC_XOPEN_VERSION___2 = 89,
    _SC_XOPEN_XCU_VERSION___2 = 90,
    _SC_XOPEN_UNIX___2 = 91,
    _SC_XOPEN_CRYPT___2 = 92,
    _SC_XOPEN_ENH_I18N___2 = 93,
    _SC_XOPEN_SHM___2 = 94,
    _SC_2_CHAR_TERM___2 = 95,
    _SC_2_C_VERSION___2 = 96,
    _SC_2_UPE___2 = 97,
    _SC_XOPEN_XPG2___2 = 98,
    _SC_XOPEN_XPG3___2 = 99,
    _SC_XOPEN_XPG4___2 = 100,
    _SC_CHAR_BIT___2 = 101,
    _SC_CHAR_MAX___2 = 102,
    _SC_CHAR_MIN___2 = 103,
    _SC_INT_MAX___2 = 104,
    _SC_INT_MIN___2 = 105,
    _SC_LONG_BIT___2 = 106,
    _SC_WORD_BIT___2 = 107,
    _SC_MB_LEN_MAX___2 = 108,
    _SC_NZERO___2 = 109,
    _SC_SSIZE_MAX___2 = 110,
    _SC_SCHAR_MAX___2 = 111,
    _SC_SCHAR_MIN___2 = 112,
    _SC_SHRT_MAX___2 = 113,
    _SC_SHRT_MIN___2 = 114,
    _SC_UCHAR_MAX___2 = 115,
    _SC_UINT_MAX___2 = 116,
    _SC_ULONG_MAX___2 = 117,
    _SC_USHRT_MAX___2 = 118,
    _SC_NL_ARGMAX___2 = 119,
    _SC_NL_LANGMAX___2 = 120,
    _SC_NL_MSGMAX___2 = 121,
    _SC_NL_NMAX___2 = 122,
    _SC_NL_SETMAX___2 = 123,
    _SC_NL_TEXTMAX___2 = 124,
    _SC_XBS5_ILP32_OFF32___2 = 125,
    _SC_XBS5_ILP32_OFFBIG___2 = 126,
    _SC_XBS5_LP64_OFF64___2 = 127,
    _SC_XBS5_LPBIG_OFFBIG___2 = 128,
    _SC_XOPEN_LEGACY___2 = 129,
    _SC_XOPEN_REALTIME___2 = 130,
    _SC_XOPEN_REALTIME_THREADS___2 = 131,
    _SC_ADVISORY_INFO___2 = 132,
    _SC_BARRIERS___2 = 133,
    _SC_BASE___2 = 134,
    _SC_C_LANG_SUPPORT___2 = 135,
    _SC_C_LANG_SUPPORT_R___2 = 136,
    _SC_CLOCK_SELECTION___2 = 137,
    _SC_CPUTIME___2 = 138,
    _SC_THREAD_CPUTIME___2 = 139,
    _SC_DEVICE_IO___2 = 140,
    _SC_DEVICE_SPECIFIC___2 = 141,
    _SC_DEVICE_SPECIFIC_R___2 = 142,
    _SC_FD_MGMT___2 = 143,
    _SC_FIFO___2 = 144,
    _SC_PIPE___2 = 145,
    _SC_FILE_ATTRIBUTES___2 = 146,
    _SC_FILE_LOCKING___2 = 147,
    _SC_FILE_SYSTEM___2 = 148,
    _SC_MONOTONIC_CLOCK___2 = 149,
    _SC_MULTI_PROCESS___2 = 150,
    _SC_SINGLE_PROCESS___2 = 151,
    _SC_NETWORKING___2 = 152,
    _SC_READER_WRITER_LOCKS___2 = 153,
    _SC_SPIN_LOCKS___2 = 154,
    _SC_REGEXP___2 = 155,
    _SC_REGEX_VERSION___2 = 156,
    _SC_SHELL___2 = 157,
    _SC_SIGNALS___2 = 158,
    _SC_SPAWN___2 = 159,
    _SC_SPORADIC_SERVER___2 = 160,
    _SC_THREAD_SPORADIC_SERVER___2 = 161,
    _SC_SYSTEM_DATABASE___2 = 162,
    _SC_SYSTEM_DATABASE_R___2 = 163,
    _SC_TIMEOUTS___2 = 164,
    _SC_TYPED_MEMORY_OBJECTS___2 = 165,
    _SC_USER_GROUPS___2 = 166,
    _SC_USER_GROUPS_R___2 = 167,
    _SC_2_PBS___2 = 168,
    _SC_2_PBS_ACCOUNTING___2 = 169,
    _SC_2_PBS_LOCATE___2 = 170,
    _SC_2_PBS_MESSAGE___2 = 171,
    _SC_2_PBS_TRACK___2 = 172,
    _SC_SYMLOOP_MAX___2 = 173,
    _SC_STREAMS___2 = 174,
    _SC_2_PBS_CHECKPOINT___2 = 175,
    _SC_V6_ILP32_OFF32___2 = 176,
    _SC_V6_ILP32_OFFBIG___2 = 177,
    _SC_V6_LP64_OFF64___2 = 178,
    _SC_V6_LPBIG_OFFBIG___2 = 179,
    _SC_HOST_NAME_MAX___2 = 180,
    _SC_TRACE___2 = 181,
    _SC_TRACE_EVENT_FILTER___2 = 182,
    _SC_TRACE_INHERIT___2 = 183,
    _SC_TRACE_LOG___2 = 184,
    _SC_LEVEL1_ICACHE_SIZE___2 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___2 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___2 = 187,
    _SC_LEVEL1_DCACHE_SIZE___2 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___2 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___2 = 190,
    _SC_LEVEL2_CACHE_SIZE___2 = 191,
    _SC_LEVEL2_CACHE_ASSOC___2 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___2 = 193,
    _SC_LEVEL3_CACHE_SIZE___2 = 194,
    _SC_LEVEL3_CACHE_ASSOC___2 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___2 = 196,
    _SC_LEVEL4_CACHE_SIZE___2 = 197,
    _SC_LEVEL4_CACHE_ASSOC___2 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___2 = 199,
    _SC_IPV6___2 = 235,
    _SC_RAW_SOCKETS___2 = 236,
    _SC_V7_ILP32_OFF32___2 = 237,
    _SC_V7_ILP32_OFFBIG___2 = 238,
    _SC_V7_LP64_OFF64___2 = 239,
    _SC_V7_LPBIG_OFFBIG___2 = 240,
    _SC_SS_REPL_MAX___2 = 241,
    _SC_TRACE_EVENT_NAME_MAX___2 = 242,
    _SC_TRACE_NAME_MAX___2 = 243,
    _SC_TRACE_SYS_MAX___2 = 244,
    _SC_TRACE_USER_EVENT_MAX___2 = 245,
    _SC_XOPEN_STREAMS___2 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___2 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___2 = 248,
    _SC_MINSIGSTKSZ___2 = 249,
    _SC_SIGSTKSZ___2 = 250
} ;
enum __anonenum_875524036___2 {
    _CS_PATH___2 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___2 = 1,
    _CS_GNU_LIBC_VERSION___2 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___2 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___2 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___2 = 5,
    _CS_LFS_CFLAGS___2 = 1000,
    _CS_LFS_LDFLAGS___2 = 1001,
    _CS_LFS_LIBS___2 = 1002,
    _CS_LFS_LINTFLAGS___2 = 1003,
    _CS_LFS64_CFLAGS___2 = 1004,
    _CS_LFS64_LDFLAGS___2 = 1005,
    _CS_LFS64_LIBS___2 = 1006,
    _CS_LFS64_LINTFLAGS___2 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___2 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___2 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___2 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___2 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___2 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___2 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___2 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___2 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___2 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___2 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___2 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___2 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___2 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___2 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___2 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___2 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___2 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___2 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___2 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___2 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___2 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___2 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___2 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___2 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___2 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___2 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___2 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___2 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___2 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___2 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___2 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___2 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___2 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___2 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___2 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___2 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___2 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___2 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___2 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___2 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___2 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___2 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___2 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___2 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___2 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___2 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___2 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___2 = 1147,
    _CS_V6_ENV___2 = 1148,
    _CS_V7_ENV___2 = 1149
} ;
enum __anonenum_57186863___2 {
    SS_ONSTACK___2 = 1,
    SS_DISABLE___2 = 2
} ;
enum __anonenum_LCL_ChangeType_204222480 {
    LCL_ChangeAdjust = 0,
    LCL_ChangeStep = 1,
    LCL_ChangeUnknownStep = 2
} ;
typedef enum __anonenum_LCL_ChangeType_204222480 LCL_ChangeType;
typedef void (*LCL_ParameterChangeHandler)(struct timespec *raw , struct timespec *cooked ,
                                           double dfreq , double doffset , LCL_ChangeType change_type ,
                                           void *anything );
typedef void (*LCL_DispersionNotifyHandler)(double dispersion , void *anything );
typedef double (*lcl_ReadFrequencyDriver)(void);
typedef double (*lcl_SetFrequencyDriver)(double freq_ppm );
typedef void (*lcl_AccrueOffsetDriver)(double offset , double corr_rate );
typedef int (*lcl_ApplyStepOffsetDriver)(double offset );
typedef void (*lcl_OffsetCorrectionDriver)(struct timespec *raw , double *corr , double *err );
typedef void (*lcl_SetLeapDriver)(int leap , int tai_offset );
typedef void (*lcl_SetSyncStatusDriver)(int synchronised , double est_error , double max_error );
struct _ChangeListEntry {
   struct _ChangeListEntry *next ;
   struct _ChangeListEntry *prev ;
   void (*handler)(struct timespec *raw , struct timespec *cooked , double dfreq ,
                   double doffset , LCL_ChangeType change_type , void *anything ) ;
   void *anything ;
};
typedef struct _ChangeListEntry ChangeListEntry;
struct _DispersionNotifyListEntry {
   struct _DispersionNotifyListEntry *next ;
   struct _DispersionNotifyListEntry *prev ;
   void (*handler)(double dispersion , void *anything ) ;
   void *anything ;
};
typedef struct _DispersionNotifyListEntry DispersionNotifyListEntry;
enum __anonenum_83571709___3 {
    MSG_OOB___3 = 1,
    MSG_PEEK___3 = 2,
    MSG_DONTROUTE___3 = 4,
    MSG_TRYHARD___3 = 4,
    MSG_CTRUNC___3 = 8,
    MSG_PROXY___3 = 16,
    MSG_TRUNC___3 = 32,
    MSG_DONTWAIT___3 = 64,
    MSG_EOR___3 = 128,
    MSG_WAITALL___3 = 256,
    MSG_FIN___3 = 512,
    MSG_SYN___3 = 1024,
    MSG_CONFIRM___3 = 2048,
    MSG_RST___3 = 4096,
    MSG_ERRQUEUE___3 = 8192,
    MSG_NOSIGNAL___3 = 16384,
    MSG_MORE___3 = 32768,
    MSG_WAITFORONE___3 = 65536,
    MSG_BATCH___3 = 262144,
    MSG_ZEROCOPY___3 = 67108864,
    MSG_FASTOPEN___3 = 536870912,
    MSG_CMSG_CLOEXEC___3 = 1073741824
} ;
enum __anonenum_617082774___3 {
    SCM_RIGHTS___3 = 1,
    SCM_CREDENTIALS___3 = 2
} ;
enum __anonenum_606441560___3 {
    SHUT_RD___3 = 0,
    SHUT_WR___3 = 1,
    SHUT_RDWR___3 = 2
} ;
enum __anonenum_264779956___3 {
    IPPROTO_IP___3 = 0,
    IPPROTO_ICMP___3 = 1,
    IPPROTO_IGMP___3 = 2,
    IPPROTO_IPIP___3 = 4,
    IPPROTO_TCP___3 = 6,
    IPPROTO_EGP___3 = 8,
    IPPROTO_PUP___3 = 12,
    IPPROTO_UDP___3 = 17,
    IPPROTO_IDP___3 = 22,
    IPPROTO_TP___3 = 29,
    IPPROTO_DCCP___3 = 33,
    IPPROTO_IPV6___3 = 41,
    IPPROTO_RSVP___3 = 46,
    IPPROTO_GRE___3 = 47,
    IPPROTO_ESP___3 = 50,
    IPPROTO_AH___3 = 51,
    IPPROTO_MTP___3 = 92,
    IPPROTO_BEETPH___3 = 94,
    IPPROTO_ENCAP___3 = 98,
    IPPROTO_PIM___3 = 103,
    IPPROTO_COMP___3 = 108,
    IPPROTO_SCTP___3 = 132,
    IPPROTO_UDPLITE___3 = 136,
    IPPROTO_MPLS___3 = 137,
    IPPROTO_ETHERNET___3 = 143,
    IPPROTO_RAW___3 = 255,
    IPPROTO_MPTCP___3 = 262,
    IPPROTO_MAX___3 = 263
} ;
enum __anonenum_218739988___3 {
    IPPROTO_HOPOPTS___3 = 0,
    IPPROTO_ROUTING___3 = 43,
    IPPROTO_FRAGMENT___3 = 44,
    IPPROTO_ICMPV6___3 = 58,
    IPPROTO_NONE___3 = 59,
    IPPROTO_DSTOPTS___3 = 60,
    IPPROTO_MH___3 = 135
} ;
enum __anonenum_662268580___3 {
    IPPORT_ECHO___3 = 7,
    IPPORT_DISCARD___3 = 9,
    IPPORT_SYSTAT___3 = 11,
    IPPORT_DAYTIME___3 = 13,
    IPPORT_NETSTAT___3 = 15,
    IPPORT_FTP___3 = 21,
    IPPORT_TELNET___3 = 23,
    IPPORT_SMTP___3 = 25,
    IPPORT_TIMESERVER___3 = 37,
    IPPORT_NAMESERVER___3 = 42,
    IPPORT_WHOIS___3 = 43,
    IPPORT_MTP___3 = 57,
    IPPORT_TFTP___3 = 69,
    IPPORT_RJE___3 = 77,
    IPPORT_FINGER___3 = 79,
    IPPORT_TTYLINK___3 = 87,
    IPPORT_SUPDUP___3 = 95,
    IPPORT_EXECSERVER___3 = 512,
    IPPORT_LOGINSERVER___3 = 513,
    IPPORT_CMDSERVER___3 = 514,
    IPPORT_EFSSERVER___3 = 520,
    IPPORT_BIFFUDP___3 = 512,
    IPPORT_WHOSERVER___3 = 513,
    IPPORT_ROUTESERVER___3 = 520,
    IPPORT_RESERVED___3 = 1024,
    IPPORT_USERRESERVED___3 = 5000
} ;
enum __anonenum_18926444___3 {
    _ISupper___3 = 256,
    _ISlower___3 = 512,
    _ISalpha___3 = 1024,
    _ISdigit___3 = 2048,
    _ISxdigit___3 = 4096,
    _ISspace___3 = 8192,
    _ISprint___3 = 16384,
    _ISgraph___3 = 32768,
    _ISblank___3 = 1,
    _IScntrl___3 = 2,
    _ISpunct___3 = 4,
    _ISalnum___3 = 8
} ;
enum __anonenum_913965969___3 {
    FP_INT_UPWARD___3 = 0,
    FP_INT_DOWNWARD___3 = 1,
    FP_INT_TOWARDZERO___3 = 2,
    FP_INT_TONEARESTFROMZERO___3 = 3,
    FP_INT_TONEAREST___3 = 4
} ;
enum __anonenum_1037408945___3 {
    FP_NAN___3 = 0,
    FP_INFINITE___3 = 1,
    FP_ZERO___3 = 2,
    FP_SUBNORMAL___3 = 3,
    FP_NORMAL___3 = 4
} ;
enum __anonenum_556971655___3 {
    SI_ASYNCNL___3 = -60,
    SI_DETHREAD___3 = -7,
    SI_TKILL___3 = -6,
    SI_SIGIO___3 = -5,
    SI_ASYNCIO___3 = -4,
    SI_MESGQ___3 = -3,
    SI_TIMER___3 = -2,
    SI_QUEUE___3 = -1,
    SI_USER___3 = 0,
    SI_KERNEL___3 = 128
} ;
enum __anonenum_640648963___3 {
    ILL_ILLOPC___3 = 1,
    ILL_ILLOPN___3 = 2,
    ILL_ILLADR___3 = 3,
    ILL_ILLTRP___3 = 4,
    ILL_PRVOPC___3 = 5,
    ILL_PRVREG___3 = 6,
    ILL_COPROC___3 = 7,
    ILL_BADSTK___3 = 8,
    ILL_BADIADDR___3 = 9
} ;
enum __anonenum_457704180___3 {
    FPE_INTDIV___3 = 1,
    FPE_INTOVF___3 = 2,
    FPE_FLTDIV___3 = 3,
    FPE_FLTOVF___3 = 4,
    FPE_FLTUND___3 = 5,
    FPE_FLTRES___3 = 6,
    FPE_FLTINV___3 = 7,
    FPE_FLTSUB___3 = 8,
    FPE_FLTUNK___3 = 14,
    FPE_CONDTRAP___3 = 15
} ;
enum __anonenum_180375148___3 {
    SEGV_MAPERR___3 = 1,
    SEGV_ACCERR___3 = 2,
    SEGV_BNDERR___3 = 3,
    SEGV_PKUERR___3 = 4,
    SEGV_ACCADI___3 = 5,
    SEGV_ADIDERR___3 = 6,
    SEGV_ADIPERR___3 = 7,
    SEGV_MTEAERR___3 = 8,
    SEGV_MTESERR___3 = 9
} ;
enum __anonenum_1036286214___3 {
    BUS_ADRALN___3 = 1,
    BUS_ADRERR___3 = 2,
    BUS_OBJERR___3 = 3,
    BUS_MCEERR_AR___3 = 4,
    BUS_MCEERR_AO___3 = 5
} ;
enum __anonenum_91015150___3 {
    TRAP_BRKPT___3 = 1,
    TRAP_TRACE___3 = 2,
    TRAP_BRANCH___3 = 3,
    TRAP_HWBKPT___3 = 4,
    TRAP_UNK___3 = 5
} ;
enum __anonenum_23175539___3 {
    CLD_EXITED___3 = 1,
    CLD_KILLED___3 = 2,
    CLD_DUMPED___3 = 3,
    CLD_TRAPPED___3 = 4,
    CLD_STOPPED___3 = 5,
    CLD_CONTINUED___3 = 6
} ;
enum __anonenum_111643124___3 {
    POLL_IN___3 = 1,
    POLL_OUT___3 = 2,
    POLL_MSG___3 = 3,
    POLL_ERR___3 = 4,
    POLL_PRI___3 = 5,
    POLL_HUP___3 = 6
} ;
enum __anonenum_852341087___3 {
    SIGEV_SIGNAL___3 = 0,
    SIGEV_NONE___3 = 1,
    SIGEV_THREAD___3 = 2,
    SIGEV_THREAD_ID___3 = 4
} ;
enum __anonenum_451154152___3 {
    REG_R8___3 = 0,
    REG_R9___3 = 1,
    REG_R10___3 = 2,
    REG_R11___3 = 3,
    REG_R12___3 = 4,
    REG_R13___3 = 5,
    REG_R14___3 = 6,
    REG_R15___3 = 7,
    REG_RDI___3 = 8,
    REG_RSI___3 = 9,
    REG_RBP___3 = 10,
    REG_RBX___3 = 11,
    REG_RDX___3 = 12,
    REG_RAX___3 = 13,
    REG_RCX___3 = 14,
    REG_RSP___3 = 15,
    REG_RIP___3 = 16,
    REG_EFL___3 = 17,
    REG_CSGSFS___3 = 18,
    REG_ERR___3 = 19,
    REG_TRAPNO___3 = 20,
    REG_OLDMASK___3 = 21,
    REG_CR2___3 = 22
} ;
enum __anonenum_437032235___3 {
    _PC_LINK_MAX___3 = 0,
    _PC_MAX_CANON___3 = 1,
    _PC_MAX_INPUT___3 = 2,
    _PC_NAME_MAX___3 = 3,
    _PC_PATH_MAX___3 = 4,
    _PC_PIPE_BUF___3 = 5,
    _PC_CHOWN_RESTRICTED___3 = 6,
    _PC_NO_TRUNC___3 = 7,
    _PC_VDISABLE___3 = 8,
    _PC_SYNC_IO___3 = 9,
    _PC_ASYNC_IO___3 = 10,
    _PC_PRIO_IO___3 = 11,
    _PC_SOCK_MAXBUF___3 = 12,
    _PC_FILESIZEBITS___3 = 13,
    _PC_REC_INCR_XFER_SIZE___3 = 14,
    _PC_REC_MAX_XFER_SIZE___3 = 15,
    _PC_REC_MIN_XFER_SIZE___3 = 16,
    _PC_REC_XFER_ALIGN___3 = 17,
    _PC_ALLOC_SIZE_MIN___3 = 18,
    _PC_SYMLINK_MAX___3 = 19,
    _PC_2_SYMLINKS___3 = 20
} ;
enum __anonenum_315186338___3 {
    _SC_ARG_MAX___3 = 0,
    _SC_CHILD_MAX___3 = 1,
    _SC_CLK_TCK___3 = 2,
    _SC_NGROUPS_MAX___3 = 3,
    _SC_OPEN_MAX___3 = 4,
    _SC_STREAM_MAX___3 = 5,
    _SC_TZNAME_MAX___3 = 6,
    _SC_JOB_CONTROL___3 = 7,
    _SC_SAVED_IDS___3 = 8,
    _SC_REALTIME_SIGNALS___3 = 9,
    _SC_PRIORITY_SCHEDULING___3 = 10,
    _SC_TIMERS___3 = 11,
    _SC_ASYNCHRONOUS_IO___3 = 12,
    _SC_PRIORITIZED_IO___3 = 13,
    _SC_SYNCHRONIZED_IO___3 = 14,
    _SC_FSYNC___3 = 15,
    _SC_MAPPED_FILES___3 = 16,
    _SC_MEMLOCK___3 = 17,
    _SC_MEMLOCK_RANGE___3 = 18,
    _SC_MEMORY_PROTECTION___3 = 19,
    _SC_MESSAGE_PASSING___3 = 20,
    _SC_SEMAPHORES___3 = 21,
    _SC_SHARED_MEMORY_OBJECTS___3 = 22,
    _SC_AIO_LISTIO_MAX___3 = 23,
    _SC_AIO_MAX___3 = 24,
    _SC_AIO_PRIO_DELTA_MAX___3 = 25,
    _SC_DELAYTIMER_MAX___3 = 26,
    _SC_MQ_OPEN_MAX___3 = 27,
    _SC_MQ_PRIO_MAX___3 = 28,
    _SC_VERSION___3 = 29,
    _SC_PAGESIZE___3 = 30,
    _SC_RTSIG_MAX___3 = 31,
    _SC_SEM_NSEMS_MAX___3 = 32,
    _SC_SEM_VALUE_MAX___3 = 33,
    _SC_SIGQUEUE_MAX___3 = 34,
    _SC_TIMER_MAX___3 = 35,
    _SC_BC_BASE_MAX___3 = 36,
    _SC_BC_DIM_MAX___3 = 37,
    _SC_BC_SCALE_MAX___3 = 38,
    _SC_BC_STRING_MAX___3 = 39,
    _SC_COLL_WEIGHTS_MAX___3 = 40,
    _SC_EQUIV_CLASS_MAX___3 = 41,
    _SC_EXPR_NEST_MAX___3 = 42,
    _SC_LINE_MAX___3 = 43,
    _SC_RE_DUP_MAX___3 = 44,
    _SC_CHARCLASS_NAME_MAX___3 = 45,
    _SC_2_VERSION___3 = 46,
    _SC_2_C_BIND___3 = 47,
    _SC_2_C_DEV___3 = 48,
    _SC_2_FORT_DEV___3 = 49,
    _SC_2_FORT_RUN___3 = 50,
    _SC_2_SW_DEV___3 = 51,
    _SC_2_LOCALEDEF___3 = 52,
    _SC_PII___3 = 53,
    _SC_PII_XTI___3 = 54,
    _SC_PII_SOCKET___3 = 55,
    _SC_PII_INTERNET___3 = 56,
    _SC_PII_OSI___3 = 57,
    _SC_POLL___3 = 58,
    _SC_SELECT___3 = 59,
    _SC_UIO_MAXIOV___3 = 60,
    _SC_IOV_MAX___3 = 60,
    _SC_PII_INTERNET_STREAM___3 = 61,
    _SC_PII_INTERNET_DGRAM___3 = 62,
    _SC_PII_OSI_COTS___3 = 63,
    _SC_PII_OSI_CLTS___3 = 64,
    _SC_PII_OSI_M___3 = 65,
    _SC_T_IOV_MAX___3 = 66,
    _SC_THREADS___3 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___3 = 68,
    _SC_GETGR_R_SIZE_MAX___3 = 69,
    _SC_GETPW_R_SIZE_MAX___3 = 70,
    _SC_LOGIN_NAME_MAX___3 = 71,
    _SC_TTY_NAME_MAX___3 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___3 = 73,
    _SC_THREAD_KEYS_MAX___3 = 74,
    _SC_THREAD_STACK_MIN___3 = 75,
    _SC_THREAD_THREADS_MAX___3 = 76,
    _SC_THREAD_ATTR_STACKADDR___3 = 77,
    _SC_THREAD_ATTR_STACKSIZE___3 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___3 = 79,
    _SC_THREAD_PRIO_INHERIT___3 = 80,
    _SC_THREAD_PRIO_PROTECT___3 = 81,
    _SC_THREAD_PROCESS_SHARED___3 = 82,
    _SC_NPROCESSORS_CONF___3 = 83,
    _SC_NPROCESSORS_ONLN___3 = 84,
    _SC_PHYS_PAGES___3 = 85,
    _SC_AVPHYS_PAGES___3 = 86,
    _SC_ATEXIT_MAX___3 = 87,
    _SC_PASS_MAX___3 = 88,
    _SC_XOPEN_VERSION___3 = 89,
    _SC_XOPEN_XCU_VERSION___3 = 90,
    _SC_XOPEN_UNIX___3 = 91,
    _SC_XOPEN_CRYPT___3 = 92,
    _SC_XOPEN_ENH_I18N___3 = 93,
    _SC_XOPEN_SHM___3 = 94,
    _SC_2_CHAR_TERM___3 = 95,
    _SC_2_C_VERSION___3 = 96,
    _SC_2_UPE___3 = 97,
    _SC_XOPEN_XPG2___3 = 98,
    _SC_XOPEN_XPG3___3 = 99,
    _SC_XOPEN_XPG4___3 = 100,
    _SC_CHAR_BIT___3 = 101,
    _SC_CHAR_MAX___3 = 102,
    _SC_CHAR_MIN___3 = 103,
    _SC_INT_MAX___3 = 104,
    _SC_INT_MIN___3 = 105,
    _SC_LONG_BIT___3 = 106,
    _SC_WORD_BIT___3 = 107,
    _SC_MB_LEN_MAX___3 = 108,
    _SC_NZERO___3 = 109,
    _SC_SSIZE_MAX___3 = 110,
    _SC_SCHAR_MAX___3 = 111,
    _SC_SCHAR_MIN___3 = 112,
    _SC_SHRT_MAX___3 = 113,
    _SC_SHRT_MIN___3 = 114,
    _SC_UCHAR_MAX___3 = 115,
    _SC_UINT_MAX___3 = 116,
    _SC_ULONG_MAX___3 = 117,
    _SC_USHRT_MAX___3 = 118,
    _SC_NL_ARGMAX___3 = 119,
    _SC_NL_LANGMAX___3 = 120,
    _SC_NL_MSGMAX___3 = 121,
    _SC_NL_NMAX___3 = 122,
    _SC_NL_SETMAX___3 = 123,
    _SC_NL_TEXTMAX___3 = 124,
    _SC_XBS5_ILP32_OFF32___3 = 125,
    _SC_XBS5_ILP32_OFFBIG___3 = 126,
    _SC_XBS5_LP64_OFF64___3 = 127,
    _SC_XBS5_LPBIG_OFFBIG___3 = 128,
    _SC_XOPEN_LEGACY___3 = 129,
    _SC_XOPEN_REALTIME___3 = 130,
    _SC_XOPEN_REALTIME_THREADS___3 = 131,
    _SC_ADVISORY_INFO___3 = 132,
    _SC_BARRIERS___3 = 133,
    _SC_BASE___3 = 134,
    _SC_C_LANG_SUPPORT___3 = 135,
    _SC_C_LANG_SUPPORT_R___3 = 136,
    _SC_CLOCK_SELECTION___3 = 137,
    _SC_CPUTIME___3 = 138,
    _SC_THREAD_CPUTIME___3 = 139,
    _SC_DEVICE_IO___3 = 140,
    _SC_DEVICE_SPECIFIC___3 = 141,
    _SC_DEVICE_SPECIFIC_R___3 = 142,
    _SC_FD_MGMT___3 = 143,
    _SC_FIFO___3 = 144,
    _SC_PIPE___3 = 145,
    _SC_FILE_ATTRIBUTES___3 = 146,
    _SC_FILE_LOCKING___3 = 147,
    _SC_FILE_SYSTEM___3 = 148,
    _SC_MONOTONIC_CLOCK___3 = 149,
    _SC_MULTI_PROCESS___3 = 150,
    _SC_SINGLE_PROCESS___3 = 151,
    _SC_NETWORKING___3 = 152,
    _SC_READER_WRITER_LOCKS___3 = 153,
    _SC_SPIN_LOCKS___3 = 154,
    _SC_REGEXP___3 = 155,
    _SC_REGEX_VERSION___3 = 156,
    _SC_SHELL___3 = 157,
    _SC_SIGNALS___3 = 158,
    _SC_SPAWN___3 = 159,
    _SC_SPORADIC_SERVER___3 = 160,
    _SC_THREAD_SPORADIC_SERVER___3 = 161,
    _SC_SYSTEM_DATABASE___3 = 162,
    _SC_SYSTEM_DATABASE_R___3 = 163,
    _SC_TIMEOUTS___3 = 164,
    _SC_TYPED_MEMORY_OBJECTS___3 = 165,
    _SC_USER_GROUPS___3 = 166,
    _SC_USER_GROUPS_R___3 = 167,
    _SC_2_PBS___3 = 168,
    _SC_2_PBS_ACCOUNTING___3 = 169,
    _SC_2_PBS_LOCATE___3 = 170,
    _SC_2_PBS_MESSAGE___3 = 171,
    _SC_2_PBS_TRACK___3 = 172,
    _SC_SYMLOOP_MAX___3 = 173,
    _SC_STREAMS___3 = 174,
    _SC_2_PBS_CHECKPOINT___3 = 175,
    _SC_V6_ILP32_OFF32___3 = 176,
    _SC_V6_ILP32_OFFBIG___3 = 177,
    _SC_V6_LP64_OFF64___3 = 178,
    _SC_V6_LPBIG_OFFBIG___3 = 179,
    _SC_HOST_NAME_MAX___3 = 180,
    _SC_TRACE___3 = 181,
    _SC_TRACE_EVENT_FILTER___3 = 182,
    _SC_TRACE_INHERIT___3 = 183,
    _SC_TRACE_LOG___3 = 184,
    _SC_LEVEL1_ICACHE_SIZE___3 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___3 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___3 = 187,
    _SC_LEVEL1_DCACHE_SIZE___3 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___3 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___3 = 190,
    _SC_LEVEL2_CACHE_SIZE___3 = 191,
    _SC_LEVEL2_CACHE_ASSOC___3 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___3 = 193,
    _SC_LEVEL3_CACHE_SIZE___3 = 194,
    _SC_LEVEL3_CACHE_ASSOC___3 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___3 = 196,
    _SC_LEVEL4_CACHE_SIZE___3 = 197,
    _SC_LEVEL4_CACHE_ASSOC___3 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___3 = 199,
    _SC_IPV6___3 = 235,
    _SC_RAW_SOCKETS___3 = 236,
    _SC_V7_ILP32_OFF32___3 = 237,
    _SC_V7_ILP32_OFFBIG___3 = 238,
    _SC_V7_LP64_OFF64___3 = 239,
    _SC_V7_LPBIG_OFFBIG___3 = 240,
    _SC_SS_REPL_MAX___3 = 241,
    _SC_TRACE_EVENT_NAME_MAX___3 = 242,
    _SC_TRACE_NAME_MAX___3 = 243,
    _SC_TRACE_SYS_MAX___3 = 244,
    _SC_TRACE_USER_EVENT_MAX___3 = 245,
    _SC_XOPEN_STREAMS___3 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___3 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___3 = 248,
    _SC_MINSIGSTKSZ___3 = 249,
    _SC_SIGSTKSZ___3 = 250
} ;
enum __anonenum_875524036___3 {
    _CS_PATH___3 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___3 = 1,
    _CS_GNU_LIBC_VERSION___3 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___3 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___3 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___3 = 5,
    _CS_LFS_CFLAGS___3 = 1000,
    _CS_LFS_LDFLAGS___3 = 1001,
    _CS_LFS_LIBS___3 = 1002,
    _CS_LFS_LINTFLAGS___3 = 1003,
    _CS_LFS64_CFLAGS___3 = 1004,
    _CS_LFS64_LDFLAGS___3 = 1005,
    _CS_LFS64_LIBS___3 = 1006,
    _CS_LFS64_LINTFLAGS___3 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___3 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___3 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___3 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___3 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___3 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___3 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___3 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___3 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___3 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___3 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___3 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___3 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___3 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___3 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___3 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___3 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___3 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___3 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___3 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___3 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___3 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___3 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___3 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___3 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___3 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___3 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___3 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___3 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___3 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___3 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___3 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___3 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___3 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___3 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___3 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___3 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___3 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___3 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___3 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___3 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___3 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___3 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___3 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___3 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___3 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___3 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___3 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___3 = 1147,
    _CS_V6_ENV___3 = 1148,
    _CS_V7_ENV___3 = 1149
} ;
enum __anonenum_57186863___3 {
    SS_ONSTACK___3 = 1,
    SS_DISABLE___3 = 2
} ;
struct LogFile {
   char const *name ;
   char const *banner ;
   FILE *file ;
   unsigned long writes ;
};
enum __anonenum_83571709___4 {
    MSG_OOB___4 = 1,
    MSG_PEEK___4 = 2,
    MSG_DONTROUTE___4 = 4,
    MSG_TRYHARD___4 = 4,
    MSG_CTRUNC___4 = 8,
    MSG_PROXY___4 = 16,
    MSG_TRUNC___4 = 32,
    MSG_DONTWAIT___4 = 64,
    MSG_EOR___4 = 128,
    MSG_WAITALL___4 = 256,
    MSG_FIN___4 = 512,
    MSG_SYN___4 = 1024,
    MSG_CONFIRM___4 = 2048,
    MSG_RST___4 = 4096,
    MSG_ERRQUEUE___4 = 8192,
    MSG_NOSIGNAL___4 = 16384,
    MSG_MORE___4 = 32768,
    MSG_WAITFORONE___4 = 65536,
    MSG_BATCH___4 = 262144,
    MSG_ZEROCOPY___4 = 67108864,
    MSG_FASTOPEN___4 = 536870912,
    MSG_CMSG_CLOEXEC___4 = 1073741824
} ;
enum __anonenum_617082774___4 {
    SCM_RIGHTS___4 = 1,
    SCM_CREDENTIALS___4 = 2
} ;
enum __anonenum_606441560___4 {
    SHUT_RD___4 = 0,
    SHUT_WR___4 = 1,
    SHUT_RDWR___4 = 2
} ;
enum __anonenum_264779956___4 {
    IPPROTO_IP___4 = 0,
    IPPROTO_ICMP___4 = 1,
    IPPROTO_IGMP___4 = 2,
    IPPROTO_IPIP___4 = 4,
    IPPROTO_TCP___4 = 6,
    IPPROTO_EGP___4 = 8,
    IPPROTO_PUP___4 = 12,
    IPPROTO_UDP___4 = 17,
    IPPROTO_IDP___4 = 22,
    IPPROTO_TP___4 = 29,
    IPPROTO_DCCP___4 = 33,
    IPPROTO_IPV6___4 = 41,
    IPPROTO_RSVP___4 = 46,
    IPPROTO_GRE___4 = 47,
    IPPROTO_ESP___4 = 50,
    IPPROTO_AH___4 = 51,
    IPPROTO_MTP___4 = 92,
    IPPROTO_BEETPH___4 = 94,
    IPPROTO_ENCAP___4 = 98,
    IPPROTO_PIM___4 = 103,
    IPPROTO_COMP___4 = 108,
    IPPROTO_SCTP___4 = 132,
    IPPROTO_UDPLITE___4 = 136,
    IPPROTO_MPLS___4 = 137,
    IPPROTO_ETHERNET___4 = 143,
    IPPROTO_RAW___4 = 255,
    IPPROTO_MPTCP___4 = 262,
    IPPROTO_MAX___4 = 263
} ;
enum __anonenum_218739988___4 {
    IPPROTO_HOPOPTS___4 = 0,
    IPPROTO_ROUTING___4 = 43,
    IPPROTO_FRAGMENT___4 = 44,
    IPPROTO_ICMPV6___4 = 58,
    IPPROTO_NONE___4 = 59,
    IPPROTO_DSTOPTS___4 = 60,
    IPPROTO_MH___4 = 135
} ;
enum __anonenum_662268580___4 {
    IPPORT_ECHO___4 = 7,
    IPPORT_DISCARD___4 = 9,
    IPPORT_SYSTAT___4 = 11,
    IPPORT_DAYTIME___4 = 13,
    IPPORT_NETSTAT___4 = 15,
    IPPORT_FTP___4 = 21,
    IPPORT_TELNET___4 = 23,
    IPPORT_SMTP___4 = 25,
    IPPORT_TIMESERVER___4 = 37,
    IPPORT_NAMESERVER___4 = 42,
    IPPORT_WHOIS___4 = 43,
    IPPORT_MTP___4 = 57,
    IPPORT_TFTP___4 = 69,
    IPPORT_RJE___4 = 77,
    IPPORT_FINGER___4 = 79,
    IPPORT_TTYLINK___4 = 87,
    IPPORT_SUPDUP___4 = 95,
    IPPORT_EXECSERVER___4 = 512,
    IPPORT_LOGINSERVER___4 = 513,
    IPPORT_CMDSERVER___4 = 514,
    IPPORT_EFSSERVER___4 = 520,
    IPPORT_BIFFUDP___4 = 512,
    IPPORT_WHOSERVER___4 = 513,
    IPPORT_ROUTESERVER___4 = 520,
    IPPORT_RESERVED___4 = 1024,
    IPPORT_USERRESERVED___4 = 5000
} ;
enum __anonenum_18926444___4 {
    _ISupper___4 = 256,
    _ISlower___4 = 512,
    _ISalpha___4 = 1024,
    _ISdigit___4 = 2048,
    _ISxdigit___4 = 4096,
    _ISspace___4 = 8192,
    _ISprint___4 = 16384,
    _ISgraph___4 = 32768,
    _ISblank___4 = 1,
    _IScntrl___4 = 2,
    _ISpunct___4 = 4,
    _ISalnum___4 = 8
} ;
enum __anonenum_913965969___4 {
    FP_INT_UPWARD___4 = 0,
    FP_INT_DOWNWARD___4 = 1,
    FP_INT_TOWARDZERO___4 = 2,
    FP_INT_TONEARESTFROMZERO___4 = 3,
    FP_INT_TONEAREST___4 = 4
} ;
enum __anonenum_1037408945___4 {
    FP_NAN___4 = 0,
    FP_INFINITE___4 = 1,
    FP_ZERO___4 = 2,
    FP_SUBNORMAL___4 = 3,
    FP_NORMAL___4 = 4
} ;
enum __anonenum_556971655___4 {
    SI_ASYNCNL___4 = -60,
    SI_DETHREAD___4 = -7,
    SI_TKILL___4 = -6,
    SI_SIGIO___4 = -5,
    SI_ASYNCIO___4 = -4,
    SI_MESGQ___4 = -3,
    SI_TIMER___4 = -2,
    SI_QUEUE___4 = -1,
    SI_USER___4 = 0,
    SI_KERNEL___4 = 128
} ;
enum __anonenum_640648963___4 {
    ILL_ILLOPC___4 = 1,
    ILL_ILLOPN___4 = 2,
    ILL_ILLADR___4 = 3,
    ILL_ILLTRP___4 = 4,
    ILL_PRVOPC___4 = 5,
    ILL_PRVREG___4 = 6,
    ILL_COPROC___4 = 7,
    ILL_BADSTK___4 = 8,
    ILL_BADIADDR___4 = 9
} ;
enum __anonenum_457704180___4 {
    FPE_INTDIV___4 = 1,
    FPE_INTOVF___4 = 2,
    FPE_FLTDIV___4 = 3,
    FPE_FLTOVF___4 = 4,
    FPE_FLTUND___4 = 5,
    FPE_FLTRES___4 = 6,
    FPE_FLTINV___4 = 7,
    FPE_FLTSUB___4 = 8,
    FPE_FLTUNK___4 = 14,
    FPE_CONDTRAP___4 = 15
} ;
enum __anonenum_180375148___4 {
    SEGV_MAPERR___4 = 1,
    SEGV_ACCERR___4 = 2,
    SEGV_BNDERR___4 = 3,
    SEGV_PKUERR___4 = 4,
    SEGV_ACCADI___4 = 5,
    SEGV_ADIDERR___4 = 6,
    SEGV_ADIPERR___4 = 7,
    SEGV_MTEAERR___4 = 8,
    SEGV_MTESERR___4 = 9
} ;
enum __anonenum_1036286214___4 {
    BUS_ADRALN___4 = 1,
    BUS_ADRERR___4 = 2,
    BUS_OBJERR___4 = 3,
    BUS_MCEERR_AR___4 = 4,
    BUS_MCEERR_AO___4 = 5
} ;
enum __anonenum_91015150___4 {
    TRAP_BRKPT___4 = 1,
    TRAP_TRACE___4 = 2,
    TRAP_BRANCH___4 = 3,
    TRAP_HWBKPT___4 = 4,
    TRAP_UNK___4 = 5
} ;
enum __anonenum_23175539___4 {
    CLD_EXITED___4 = 1,
    CLD_KILLED___4 = 2,
    CLD_DUMPED___4 = 3,
    CLD_TRAPPED___4 = 4,
    CLD_STOPPED___4 = 5,
    CLD_CONTINUED___4 = 6
} ;
enum __anonenum_111643124___4 {
    POLL_IN___4 = 1,
    POLL_OUT___4 = 2,
    POLL_MSG___4 = 3,
    POLL_ERR___4 = 4,
    POLL_PRI___4 = 5,
    POLL_HUP___4 = 6
} ;
enum __anonenum_852341087___4 {
    SIGEV_SIGNAL___4 = 0,
    SIGEV_NONE___4 = 1,
    SIGEV_THREAD___4 = 2,
    SIGEV_THREAD_ID___4 = 4
} ;
enum __anonenum_451154152___4 {
    REG_R8___4 = 0,
    REG_R9___4 = 1,
    REG_R10___4 = 2,
    REG_R11___4 = 3,
    REG_R12___4 = 4,
    REG_R13___4 = 5,
    REG_R14___4 = 6,
    REG_R15___4 = 7,
    REG_RDI___4 = 8,
    REG_RSI___4 = 9,
    REG_RBP___4 = 10,
    REG_RBX___4 = 11,
    REG_RDX___4 = 12,
    REG_RAX___4 = 13,
    REG_RCX___4 = 14,
    REG_RSP___4 = 15,
    REG_RIP___4 = 16,
    REG_EFL___4 = 17,
    REG_CSGSFS___4 = 18,
    REG_ERR___4 = 19,
    REG_TRAPNO___4 = 20,
    REG_OLDMASK___4 = 21,
    REG_CR2___4 = 22
} ;
enum __anonenum_437032235___4 {
    _PC_LINK_MAX___4 = 0,
    _PC_MAX_CANON___4 = 1,
    _PC_MAX_INPUT___4 = 2,
    _PC_NAME_MAX___4 = 3,
    _PC_PATH_MAX___4 = 4,
    _PC_PIPE_BUF___4 = 5,
    _PC_CHOWN_RESTRICTED___4 = 6,
    _PC_NO_TRUNC___4 = 7,
    _PC_VDISABLE___4 = 8,
    _PC_SYNC_IO___4 = 9,
    _PC_ASYNC_IO___4 = 10,
    _PC_PRIO_IO___4 = 11,
    _PC_SOCK_MAXBUF___4 = 12,
    _PC_FILESIZEBITS___4 = 13,
    _PC_REC_INCR_XFER_SIZE___4 = 14,
    _PC_REC_MAX_XFER_SIZE___4 = 15,
    _PC_REC_MIN_XFER_SIZE___4 = 16,
    _PC_REC_XFER_ALIGN___4 = 17,
    _PC_ALLOC_SIZE_MIN___4 = 18,
    _PC_SYMLINK_MAX___4 = 19,
    _PC_2_SYMLINKS___4 = 20
} ;
enum __anonenum_315186338___4 {
    _SC_ARG_MAX___4 = 0,
    _SC_CHILD_MAX___4 = 1,
    _SC_CLK_TCK___4 = 2,
    _SC_NGROUPS_MAX___4 = 3,
    _SC_OPEN_MAX___4 = 4,
    _SC_STREAM_MAX___4 = 5,
    _SC_TZNAME_MAX___4 = 6,
    _SC_JOB_CONTROL___4 = 7,
    _SC_SAVED_IDS___4 = 8,
    _SC_REALTIME_SIGNALS___4 = 9,
    _SC_PRIORITY_SCHEDULING___4 = 10,
    _SC_TIMERS___4 = 11,
    _SC_ASYNCHRONOUS_IO___4 = 12,
    _SC_PRIORITIZED_IO___4 = 13,
    _SC_SYNCHRONIZED_IO___4 = 14,
    _SC_FSYNC___4 = 15,
    _SC_MAPPED_FILES___4 = 16,
    _SC_MEMLOCK___4 = 17,
    _SC_MEMLOCK_RANGE___4 = 18,
    _SC_MEMORY_PROTECTION___4 = 19,
    _SC_MESSAGE_PASSING___4 = 20,
    _SC_SEMAPHORES___4 = 21,
    _SC_SHARED_MEMORY_OBJECTS___4 = 22,
    _SC_AIO_LISTIO_MAX___4 = 23,
    _SC_AIO_MAX___4 = 24,
    _SC_AIO_PRIO_DELTA_MAX___4 = 25,
    _SC_DELAYTIMER_MAX___4 = 26,
    _SC_MQ_OPEN_MAX___4 = 27,
    _SC_MQ_PRIO_MAX___4 = 28,
    _SC_VERSION___4 = 29,
    _SC_PAGESIZE___4 = 30,
    _SC_RTSIG_MAX___4 = 31,
    _SC_SEM_NSEMS_MAX___4 = 32,
    _SC_SEM_VALUE_MAX___4 = 33,
    _SC_SIGQUEUE_MAX___4 = 34,
    _SC_TIMER_MAX___4 = 35,
    _SC_BC_BASE_MAX___4 = 36,
    _SC_BC_DIM_MAX___4 = 37,
    _SC_BC_SCALE_MAX___4 = 38,
    _SC_BC_STRING_MAX___4 = 39,
    _SC_COLL_WEIGHTS_MAX___4 = 40,
    _SC_EQUIV_CLASS_MAX___4 = 41,
    _SC_EXPR_NEST_MAX___4 = 42,
    _SC_LINE_MAX___4 = 43,
    _SC_RE_DUP_MAX___4 = 44,
    _SC_CHARCLASS_NAME_MAX___4 = 45,
    _SC_2_VERSION___4 = 46,
    _SC_2_C_BIND___4 = 47,
    _SC_2_C_DEV___4 = 48,
    _SC_2_FORT_DEV___4 = 49,
    _SC_2_FORT_RUN___4 = 50,
    _SC_2_SW_DEV___4 = 51,
    _SC_2_LOCALEDEF___4 = 52,
    _SC_PII___4 = 53,
    _SC_PII_XTI___4 = 54,
    _SC_PII_SOCKET___4 = 55,
    _SC_PII_INTERNET___4 = 56,
    _SC_PII_OSI___4 = 57,
    _SC_POLL___4 = 58,
    _SC_SELECT___4 = 59,
    _SC_UIO_MAXIOV___4 = 60,
    _SC_IOV_MAX___4 = 60,
    _SC_PII_INTERNET_STREAM___4 = 61,
    _SC_PII_INTERNET_DGRAM___4 = 62,
    _SC_PII_OSI_COTS___4 = 63,
    _SC_PII_OSI_CLTS___4 = 64,
    _SC_PII_OSI_M___4 = 65,
    _SC_T_IOV_MAX___4 = 66,
    _SC_THREADS___4 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___4 = 68,
    _SC_GETGR_R_SIZE_MAX___4 = 69,
    _SC_GETPW_R_SIZE_MAX___4 = 70,
    _SC_LOGIN_NAME_MAX___4 = 71,
    _SC_TTY_NAME_MAX___4 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___4 = 73,
    _SC_THREAD_KEYS_MAX___4 = 74,
    _SC_THREAD_STACK_MIN___4 = 75,
    _SC_THREAD_THREADS_MAX___4 = 76,
    _SC_THREAD_ATTR_STACKADDR___4 = 77,
    _SC_THREAD_ATTR_STACKSIZE___4 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___4 = 79,
    _SC_THREAD_PRIO_INHERIT___4 = 80,
    _SC_THREAD_PRIO_PROTECT___4 = 81,
    _SC_THREAD_PROCESS_SHARED___4 = 82,
    _SC_NPROCESSORS_CONF___4 = 83,
    _SC_NPROCESSORS_ONLN___4 = 84,
    _SC_PHYS_PAGES___4 = 85,
    _SC_AVPHYS_PAGES___4 = 86,
    _SC_ATEXIT_MAX___4 = 87,
    _SC_PASS_MAX___4 = 88,
    _SC_XOPEN_VERSION___4 = 89,
    _SC_XOPEN_XCU_VERSION___4 = 90,
    _SC_XOPEN_UNIX___4 = 91,
    _SC_XOPEN_CRYPT___4 = 92,
    _SC_XOPEN_ENH_I18N___4 = 93,
    _SC_XOPEN_SHM___4 = 94,
    _SC_2_CHAR_TERM___4 = 95,
    _SC_2_C_VERSION___4 = 96,
    _SC_2_UPE___4 = 97,
    _SC_XOPEN_XPG2___4 = 98,
    _SC_XOPEN_XPG3___4 = 99,
    _SC_XOPEN_XPG4___4 = 100,
    _SC_CHAR_BIT___4 = 101,
    _SC_CHAR_MAX___4 = 102,
    _SC_CHAR_MIN___4 = 103,
    _SC_INT_MAX___4 = 104,
    _SC_INT_MIN___4 = 105,
    _SC_LONG_BIT___4 = 106,
    _SC_WORD_BIT___4 = 107,
    _SC_MB_LEN_MAX___4 = 108,
    _SC_NZERO___4 = 109,
    _SC_SSIZE_MAX___4 = 110,
    _SC_SCHAR_MAX___4 = 111,
    _SC_SCHAR_MIN___4 = 112,
    _SC_SHRT_MAX___4 = 113,
    _SC_SHRT_MIN___4 = 114,
    _SC_UCHAR_MAX___4 = 115,
    _SC_UINT_MAX___4 = 116,
    _SC_ULONG_MAX___4 = 117,
    _SC_USHRT_MAX___4 = 118,
    _SC_NL_ARGMAX___4 = 119,
    _SC_NL_LANGMAX___4 = 120,
    _SC_NL_MSGMAX___4 = 121,
    _SC_NL_NMAX___4 = 122,
    _SC_NL_SETMAX___4 = 123,
    _SC_NL_TEXTMAX___4 = 124,
    _SC_XBS5_ILP32_OFF32___4 = 125,
    _SC_XBS5_ILP32_OFFBIG___4 = 126,
    _SC_XBS5_LP64_OFF64___4 = 127,
    _SC_XBS5_LPBIG_OFFBIG___4 = 128,
    _SC_XOPEN_LEGACY___4 = 129,
    _SC_XOPEN_REALTIME___4 = 130,
    _SC_XOPEN_REALTIME_THREADS___4 = 131,
    _SC_ADVISORY_INFO___4 = 132,
    _SC_BARRIERS___4 = 133,
    _SC_BASE___4 = 134,
    _SC_C_LANG_SUPPORT___4 = 135,
    _SC_C_LANG_SUPPORT_R___4 = 136,
    _SC_CLOCK_SELECTION___4 = 137,
    _SC_CPUTIME___4 = 138,
    _SC_THREAD_CPUTIME___4 = 139,
    _SC_DEVICE_IO___4 = 140,
    _SC_DEVICE_SPECIFIC___4 = 141,
    _SC_DEVICE_SPECIFIC_R___4 = 142,
    _SC_FD_MGMT___4 = 143,
    _SC_FIFO___4 = 144,
    _SC_PIPE___4 = 145,
    _SC_FILE_ATTRIBUTES___4 = 146,
    _SC_FILE_LOCKING___4 = 147,
    _SC_FILE_SYSTEM___4 = 148,
    _SC_MONOTONIC_CLOCK___4 = 149,
    _SC_MULTI_PROCESS___4 = 150,
    _SC_SINGLE_PROCESS___4 = 151,
    _SC_NETWORKING___4 = 152,
    _SC_READER_WRITER_LOCKS___4 = 153,
    _SC_SPIN_LOCKS___4 = 154,
    _SC_REGEXP___4 = 155,
    _SC_REGEX_VERSION___4 = 156,
    _SC_SHELL___4 = 157,
    _SC_SIGNALS___4 = 158,
    _SC_SPAWN___4 = 159,
    _SC_SPORADIC_SERVER___4 = 160,
    _SC_THREAD_SPORADIC_SERVER___4 = 161,
    _SC_SYSTEM_DATABASE___4 = 162,
    _SC_SYSTEM_DATABASE_R___4 = 163,
    _SC_TIMEOUTS___4 = 164,
    _SC_TYPED_MEMORY_OBJECTS___4 = 165,
    _SC_USER_GROUPS___4 = 166,
    _SC_USER_GROUPS_R___4 = 167,
    _SC_2_PBS___4 = 168,
    _SC_2_PBS_ACCOUNTING___4 = 169,
    _SC_2_PBS_LOCATE___4 = 170,
    _SC_2_PBS_MESSAGE___4 = 171,
    _SC_2_PBS_TRACK___4 = 172,
    _SC_SYMLOOP_MAX___4 = 173,
    _SC_STREAMS___4 = 174,
    _SC_2_PBS_CHECKPOINT___4 = 175,
    _SC_V6_ILP32_OFF32___4 = 176,
    _SC_V6_ILP32_OFFBIG___4 = 177,
    _SC_V6_LP64_OFF64___4 = 178,
    _SC_V6_LPBIG_OFFBIG___4 = 179,
    _SC_HOST_NAME_MAX___4 = 180,
    _SC_TRACE___4 = 181,
    _SC_TRACE_EVENT_FILTER___4 = 182,
    _SC_TRACE_INHERIT___4 = 183,
    _SC_TRACE_LOG___4 = 184,
    _SC_LEVEL1_ICACHE_SIZE___4 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___4 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___4 = 187,
    _SC_LEVEL1_DCACHE_SIZE___4 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___4 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___4 = 190,
    _SC_LEVEL2_CACHE_SIZE___4 = 191,
    _SC_LEVEL2_CACHE_ASSOC___4 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___4 = 193,
    _SC_LEVEL3_CACHE_SIZE___4 = 194,
    _SC_LEVEL3_CACHE_ASSOC___4 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___4 = 196,
    _SC_LEVEL4_CACHE_SIZE___4 = 197,
    _SC_LEVEL4_CACHE_ASSOC___4 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___4 = 199,
    _SC_IPV6___4 = 235,
    _SC_RAW_SOCKETS___4 = 236,
    _SC_V7_ILP32_OFF32___4 = 237,
    _SC_V7_ILP32_OFFBIG___4 = 238,
    _SC_V7_LP64_OFF64___4 = 239,
    _SC_V7_LPBIG_OFFBIG___4 = 240,
    _SC_SS_REPL_MAX___4 = 241,
    _SC_TRACE_EVENT_NAME_MAX___4 = 242,
    _SC_TRACE_NAME_MAX___4 = 243,
    _SC_TRACE_SYS_MAX___4 = 244,
    _SC_TRACE_USER_EVENT_MAX___4 = 245,
    _SC_XOPEN_STREAMS___4 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___4 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___4 = 248,
    _SC_MINSIGSTKSZ___4 = 249,
    _SC_SIGSTKSZ___4 = 250
} ;
enum __anonenum_875524036___4 {
    _CS_PATH___4 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___4 = 1,
    _CS_GNU_LIBC_VERSION___4 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___4 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___4 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___4 = 5,
    _CS_LFS_CFLAGS___4 = 1000,
    _CS_LFS_LDFLAGS___4 = 1001,
    _CS_LFS_LIBS___4 = 1002,
    _CS_LFS_LINTFLAGS___4 = 1003,
    _CS_LFS64_CFLAGS___4 = 1004,
    _CS_LFS64_LDFLAGS___4 = 1005,
    _CS_LFS64_LIBS___4 = 1006,
    _CS_LFS64_LINTFLAGS___4 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___4 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___4 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___4 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___4 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___4 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___4 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___4 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___4 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___4 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___4 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___4 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___4 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___4 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___4 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___4 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___4 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___4 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___4 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___4 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___4 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___4 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___4 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___4 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___4 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___4 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___4 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___4 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___4 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___4 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___4 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___4 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___4 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___4 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___4 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___4 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___4 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___4 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___4 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___4 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___4 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___4 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___4 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___4 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___4 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___4 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___4 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___4 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___4 = 1147,
    _CS_V6_ENV___4 = 1148,
    _CS_V7_ENV___4 = 1149
} ;
enum __anonenum_57186863___4 {
    SS_ONSTACK___4 = 1,
    SS_DISABLE___4 = 2
} ;
typedef unsigned int SCH_TimeoutID;
enum __anonenum_SCH_TimeoutClass_1014897062 {
    SCH_ReservedTimeoutValue = 0,
    SCH_NtpClientClass = 1,
    SCH_NtpPeerClass = 2,
    SCH_NtpBroadcastClass = 3,
    SCH_NumberOfClasses = 4
} ;
typedef enum __anonenum_SCH_TimeoutClass_1014897062 SCH_TimeoutClass;
typedef void *SCH_ArbitraryArgument;
typedef void (*SCH_FileHandler)(int fd , int event , SCH_ArbitraryArgument );
typedef void (*SCH_TimeoutHandler)(SCH_ArbitraryArgument );
enum __anonenum_SYS_ProcessContext_818200057 {
    SYS_MAIN_PROCESS = 0,
    SYS_NTSKE_HELPER = 1
} ;
typedef enum __anonenum_SYS_ProcessContext_818200057 SYS_ProcessContext;
enum __anonenum_CLG_Service_238172072 {
    CLG_NTP = 0,
    CLG_NTSKE = 1,
    CLG_CMDMON = 2
} ;
typedef enum __anonenum_CLG_Service_238172072 CLG_Service;
enum __anonenum_83571709___5 {
    MSG_OOB___5 = 1,
    MSG_PEEK___5 = 2,
    MSG_DONTROUTE___5 = 4,
    MSG_TRYHARD___5 = 4,
    MSG_CTRUNC___5 = 8,
    MSG_PROXY___5 = 16,
    MSG_TRUNC___5 = 32,
    MSG_DONTWAIT___5 = 64,
    MSG_EOR___5 = 128,
    MSG_WAITALL___5 = 256,
    MSG_FIN___5 = 512,
    MSG_SYN___5 = 1024,
    MSG_CONFIRM___5 = 2048,
    MSG_RST___5 = 4096,
    MSG_ERRQUEUE___5 = 8192,
    MSG_NOSIGNAL___5 = 16384,
    MSG_MORE___5 = 32768,
    MSG_WAITFORONE___5 = 65536,
    MSG_BATCH___5 = 262144,
    MSG_ZEROCOPY___5 = 67108864,
    MSG_FASTOPEN___5 = 536870912,
    MSG_CMSG_CLOEXEC___5 = 1073741824
} ;
enum __anonenum_617082774___5 {
    SCM_RIGHTS___5 = 1,
    SCM_CREDENTIALS___5 = 2
} ;
enum __anonenum_606441560___5 {
    SHUT_RD___5 = 0,
    SHUT_WR___5 = 1,
    SHUT_RDWR___5 = 2
} ;
enum __anonenum_264779956___5 {
    IPPROTO_IP___5 = 0,
    IPPROTO_ICMP___5 = 1,
    IPPROTO_IGMP___5 = 2,
    IPPROTO_IPIP___5 = 4,
    IPPROTO_TCP___5 = 6,
    IPPROTO_EGP___5 = 8,
    IPPROTO_PUP___5 = 12,
    IPPROTO_UDP___5 = 17,
    IPPROTO_IDP___5 = 22,
    IPPROTO_TP___5 = 29,
    IPPROTO_DCCP___5 = 33,
    IPPROTO_IPV6___5 = 41,
    IPPROTO_RSVP___5 = 46,
    IPPROTO_GRE___5 = 47,
    IPPROTO_ESP___5 = 50,
    IPPROTO_AH___5 = 51,
    IPPROTO_MTP___5 = 92,
    IPPROTO_BEETPH___5 = 94,
    IPPROTO_ENCAP___5 = 98,
    IPPROTO_PIM___5 = 103,
    IPPROTO_COMP___5 = 108,
    IPPROTO_SCTP___5 = 132,
    IPPROTO_UDPLITE___5 = 136,
    IPPROTO_MPLS___5 = 137,
    IPPROTO_ETHERNET___5 = 143,
    IPPROTO_RAW___5 = 255,
    IPPROTO_MPTCP___5 = 262,
    IPPROTO_MAX___5 = 263
} ;
enum __anonenum_218739988___5 {
    IPPROTO_HOPOPTS___5 = 0,
    IPPROTO_ROUTING___5 = 43,
    IPPROTO_FRAGMENT___5 = 44,
    IPPROTO_ICMPV6___5 = 58,
    IPPROTO_NONE___5 = 59,
    IPPROTO_DSTOPTS___5 = 60,
    IPPROTO_MH___5 = 135
} ;
enum __anonenum_662268580___5 {
    IPPORT_ECHO___5 = 7,
    IPPORT_DISCARD___5 = 9,
    IPPORT_SYSTAT___5 = 11,
    IPPORT_DAYTIME___5 = 13,
    IPPORT_NETSTAT___5 = 15,
    IPPORT_FTP___5 = 21,
    IPPORT_TELNET___5 = 23,
    IPPORT_SMTP___5 = 25,
    IPPORT_TIMESERVER___5 = 37,
    IPPORT_NAMESERVER___5 = 42,
    IPPORT_WHOIS___5 = 43,
    IPPORT_MTP___5 = 57,
    IPPORT_TFTP___5 = 69,
    IPPORT_RJE___5 = 77,
    IPPORT_FINGER___5 = 79,
    IPPORT_TTYLINK___5 = 87,
    IPPORT_SUPDUP___5 = 95,
    IPPORT_EXECSERVER___5 = 512,
    IPPORT_LOGINSERVER___5 = 513,
    IPPORT_CMDSERVER___5 = 514,
    IPPORT_EFSSERVER___5 = 520,
    IPPORT_BIFFUDP___5 = 512,
    IPPORT_WHOSERVER___5 = 513,
    IPPORT_ROUTESERVER___5 = 520,
    IPPORT_RESERVED___5 = 1024,
    IPPORT_USERRESERVED___5 = 5000
} ;
enum __anonenum_18926444___5 {
    _ISupper___5 = 256,
    _ISlower___5 = 512,
    _ISalpha___5 = 1024,
    _ISdigit___5 = 2048,
    _ISxdigit___5 = 4096,
    _ISspace___5 = 8192,
    _ISprint___5 = 16384,
    _ISgraph___5 = 32768,
    _ISblank___5 = 1,
    _IScntrl___5 = 2,
    _ISpunct___5 = 4,
    _ISalnum___5 = 8
} ;
enum __anonenum_913965969___5 {
    FP_INT_UPWARD___5 = 0,
    FP_INT_DOWNWARD___5 = 1,
    FP_INT_TOWARDZERO___5 = 2,
    FP_INT_TONEARESTFROMZERO___5 = 3,
    FP_INT_TONEAREST___5 = 4
} ;
enum __anonenum_1037408945___5 {
    FP_NAN___5 = 0,
    FP_INFINITE___5 = 1,
    FP_ZERO___5 = 2,
    FP_SUBNORMAL___5 = 3,
    FP_NORMAL___5 = 4
} ;
enum __anonenum_556971655___5 {
    SI_ASYNCNL___5 = -60,
    SI_DETHREAD___5 = -7,
    SI_TKILL___5 = -6,
    SI_SIGIO___5 = -5,
    SI_ASYNCIO___5 = -4,
    SI_MESGQ___5 = -3,
    SI_TIMER___5 = -2,
    SI_QUEUE___5 = -1,
    SI_USER___5 = 0,
    SI_KERNEL___5 = 128
} ;
enum __anonenum_640648963___5 {
    ILL_ILLOPC___5 = 1,
    ILL_ILLOPN___5 = 2,
    ILL_ILLADR___5 = 3,
    ILL_ILLTRP___5 = 4,
    ILL_PRVOPC___5 = 5,
    ILL_PRVREG___5 = 6,
    ILL_COPROC___5 = 7,
    ILL_BADSTK___5 = 8,
    ILL_BADIADDR___5 = 9
} ;
enum __anonenum_457704180___5 {
    FPE_INTDIV___5 = 1,
    FPE_INTOVF___5 = 2,
    FPE_FLTDIV___5 = 3,
    FPE_FLTOVF___5 = 4,
    FPE_FLTUND___5 = 5,
    FPE_FLTRES___5 = 6,
    FPE_FLTINV___5 = 7,
    FPE_FLTSUB___5 = 8,
    FPE_FLTUNK___5 = 14,
    FPE_CONDTRAP___5 = 15
} ;
enum __anonenum_180375148___5 {
    SEGV_MAPERR___5 = 1,
    SEGV_ACCERR___5 = 2,
    SEGV_BNDERR___5 = 3,
    SEGV_PKUERR___5 = 4,
    SEGV_ACCADI___5 = 5,
    SEGV_ADIDERR___5 = 6,
    SEGV_ADIPERR___5 = 7,
    SEGV_MTEAERR___5 = 8,
    SEGV_MTESERR___5 = 9
} ;
enum __anonenum_1036286214___5 {
    BUS_ADRALN___5 = 1,
    BUS_ADRERR___5 = 2,
    BUS_OBJERR___5 = 3,
    BUS_MCEERR_AR___5 = 4,
    BUS_MCEERR_AO___5 = 5
} ;
enum __anonenum_91015150___5 {
    TRAP_BRKPT___5 = 1,
    TRAP_TRACE___5 = 2,
    TRAP_BRANCH___5 = 3,
    TRAP_HWBKPT___5 = 4,
    TRAP_UNK___5 = 5
} ;
enum __anonenum_23175539___5 {
    CLD_EXITED___5 = 1,
    CLD_KILLED___5 = 2,
    CLD_DUMPED___5 = 3,
    CLD_TRAPPED___5 = 4,
    CLD_STOPPED___5 = 5,
    CLD_CONTINUED___5 = 6
} ;
enum __anonenum_111643124___5 {
    POLL_IN___5 = 1,
    POLL_OUT___5 = 2,
    POLL_MSG___5 = 3,
    POLL_ERR___5 = 4,
    POLL_PRI___5 = 5,
    POLL_HUP___5 = 6
} ;
enum __anonenum_852341087___5 {
    SIGEV_SIGNAL___5 = 0,
    SIGEV_NONE___5 = 1,
    SIGEV_THREAD___5 = 2,
    SIGEV_THREAD_ID___5 = 4
} ;
enum __anonenum_451154152___5 {
    REG_R8___5 = 0,
    REG_R9___5 = 1,
    REG_R10___5 = 2,
    REG_R11___5 = 3,
    REG_R12___5 = 4,
    REG_R13___5 = 5,
    REG_R14___5 = 6,
    REG_R15___5 = 7,
    REG_RDI___5 = 8,
    REG_RSI___5 = 9,
    REG_RBP___5 = 10,
    REG_RBX___5 = 11,
    REG_RDX___5 = 12,
    REG_RAX___5 = 13,
    REG_RCX___5 = 14,
    REG_RSP___5 = 15,
    REG_RIP___5 = 16,
    REG_EFL___5 = 17,
    REG_CSGSFS___5 = 18,
    REG_ERR___5 = 19,
    REG_TRAPNO___5 = 20,
    REG_OLDMASK___5 = 21,
    REG_CR2___5 = 22
} ;
enum __anonenum_437032235___5 {
    _PC_LINK_MAX___5 = 0,
    _PC_MAX_CANON___5 = 1,
    _PC_MAX_INPUT___5 = 2,
    _PC_NAME_MAX___5 = 3,
    _PC_PATH_MAX___5 = 4,
    _PC_PIPE_BUF___5 = 5,
    _PC_CHOWN_RESTRICTED___5 = 6,
    _PC_NO_TRUNC___5 = 7,
    _PC_VDISABLE___5 = 8,
    _PC_SYNC_IO___5 = 9,
    _PC_ASYNC_IO___5 = 10,
    _PC_PRIO_IO___5 = 11,
    _PC_SOCK_MAXBUF___5 = 12,
    _PC_FILESIZEBITS___5 = 13,
    _PC_REC_INCR_XFER_SIZE___5 = 14,
    _PC_REC_MAX_XFER_SIZE___5 = 15,
    _PC_REC_MIN_XFER_SIZE___5 = 16,
    _PC_REC_XFER_ALIGN___5 = 17,
    _PC_ALLOC_SIZE_MIN___5 = 18,
    _PC_SYMLINK_MAX___5 = 19,
    _PC_2_SYMLINKS___5 = 20
} ;
enum __anonenum_315186338___5 {
    _SC_ARG_MAX___5 = 0,
    _SC_CHILD_MAX___5 = 1,
    _SC_CLK_TCK___5 = 2,
    _SC_NGROUPS_MAX___5 = 3,
    _SC_OPEN_MAX___5 = 4,
    _SC_STREAM_MAX___5 = 5,
    _SC_TZNAME_MAX___5 = 6,
    _SC_JOB_CONTROL___5 = 7,
    _SC_SAVED_IDS___5 = 8,
    _SC_REALTIME_SIGNALS___5 = 9,
    _SC_PRIORITY_SCHEDULING___5 = 10,
    _SC_TIMERS___5 = 11,
    _SC_ASYNCHRONOUS_IO___5 = 12,
    _SC_PRIORITIZED_IO___5 = 13,
    _SC_SYNCHRONIZED_IO___5 = 14,
    _SC_FSYNC___5 = 15,
    _SC_MAPPED_FILES___5 = 16,
    _SC_MEMLOCK___5 = 17,
    _SC_MEMLOCK_RANGE___5 = 18,
    _SC_MEMORY_PROTECTION___5 = 19,
    _SC_MESSAGE_PASSING___5 = 20,
    _SC_SEMAPHORES___5 = 21,
    _SC_SHARED_MEMORY_OBJECTS___5 = 22,
    _SC_AIO_LISTIO_MAX___5 = 23,
    _SC_AIO_MAX___5 = 24,
    _SC_AIO_PRIO_DELTA_MAX___5 = 25,
    _SC_DELAYTIMER_MAX___5 = 26,
    _SC_MQ_OPEN_MAX___5 = 27,
    _SC_MQ_PRIO_MAX___5 = 28,
    _SC_VERSION___5 = 29,
    _SC_PAGESIZE___5 = 30,
    _SC_RTSIG_MAX___5 = 31,
    _SC_SEM_NSEMS_MAX___5 = 32,
    _SC_SEM_VALUE_MAX___5 = 33,
    _SC_SIGQUEUE_MAX___5 = 34,
    _SC_TIMER_MAX___5 = 35,
    _SC_BC_BASE_MAX___5 = 36,
    _SC_BC_DIM_MAX___5 = 37,
    _SC_BC_SCALE_MAX___5 = 38,
    _SC_BC_STRING_MAX___5 = 39,
    _SC_COLL_WEIGHTS_MAX___5 = 40,
    _SC_EQUIV_CLASS_MAX___5 = 41,
    _SC_EXPR_NEST_MAX___5 = 42,
    _SC_LINE_MAX___5 = 43,
    _SC_RE_DUP_MAX___5 = 44,
    _SC_CHARCLASS_NAME_MAX___5 = 45,
    _SC_2_VERSION___5 = 46,
    _SC_2_C_BIND___5 = 47,
    _SC_2_C_DEV___5 = 48,
    _SC_2_FORT_DEV___5 = 49,
    _SC_2_FORT_RUN___5 = 50,
    _SC_2_SW_DEV___5 = 51,
    _SC_2_LOCALEDEF___5 = 52,
    _SC_PII___5 = 53,
    _SC_PII_XTI___5 = 54,
    _SC_PII_SOCKET___5 = 55,
    _SC_PII_INTERNET___5 = 56,
    _SC_PII_OSI___5 = 57,
    _SC_POLL___5 = 58,
    _SC_SELECT___5 = 59,
    _SC_UIO_MAXIOV___5 = 60,
    _SC_IOV_MAX___5 = 60,
    _SC_PII_INTERNET_STREAM___5 = 61,
    _SC_PII_INTERNET_DGRAM___5 = 62,
    _SC_PII_OSI_COTS___5 = 63,
    _SC_PII_OSI_CLTS___5 = 64,
    _SC_PII_OSI_M___5 = 65,
    _SC_T_IOV_MAX___5 = 66,
    _SC_THREADS___5 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___5 = 68,
    _SC_GETGR_R_SIZE_MAX___5 = 69,
    _SC_GETPW_R_SIZE_MAX___5 = 70,
    _SC_LOGIN_NAME_MAX___5 = 71,
    _SC_TTY_NAME_MAX___5 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___5 = 73,
    _SC_THREAD_KEYS_MAX___5 = 74,
    _SC_THREAD_STACK_MIN___5 = 75,
    _SC_THREAD_THREADS_MAX___5 = 76,
    _SC_THREAD_ATTR_STACKADDR___5 = 77,
    _SC_THREAD_ATTR_STACKSIZE___5 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___5 = 79,
    _SC_THREAD_PRIO_INHERIT___5 = 80,
    _SC_THREAD_PRIO_PROTECT___5 = 81,
    _SC_THREAD_PROCESS_SHARED___5 = 82,
    _SC_NPROCESSORS_CONF___5 = 83,
    _SC_NPROCESSORS_ONLN___5 = 84,
    _SC_PHYS_PAGES___5 = 85,
    _SC_AVPHYS_PAGES___5 = 86,
    _SC_ATEXIT_MAX___5 = 87,
    _SC_PASS_MAX___5 = 88,
    _SC_XOPEN_VERSION___5 = 89,
    _SC_XOPEN_XCU_VERSION___5 = 90,
    _SC_XOPEN_UNIX___5 = 91,
    _SC_XOPEN_CRYPT___5 = 92,
    _SC_XOPEN_ENH_I18N___5 = 93,
    _SC_XOPEN_SHM___5 = 94,
    _SC_2_CHAR_TERM___5 = 95,
    _SC_2_C_VERSION___5 = 96,
    _SC_2_UPE___5 = 97,
    _SC_XOPEN_XPG2___5 = 98,
    _SC_XOPEN_XPG3___5 = 99,
    _SC_XOPEN_XPG4___5 = 100,
    _SC_CHAR_BIT___5 = 101,
    _SC_CHAR_MAX___5 = 102,
    _SC_CHAR_MIN___5 = 103,
    _SC_INT_MAX___5 = 104,
    _SC_INT_MIN___5 = 105,
    _SC_LONG_BIT___5 = 106,
    _SC_WORD_BIT___5 = 107,
    _SC_MB_LEN_MAX___5 = 108,
    _SC_NZERO___5 = 109,
    _SC_SSIZE_MAX___5 = 110,
    _SC_SCHAR_MAX___5 = 111,
    _SC_SCHAR_MIN___5 = 112,
    _SC_SHRT_MAX___5 = 113,
    _SC_SHRT_MIN___5 = 114,
    _SC_UCHAR_MAX___5 = 115,
    _SC_UINT_MAX___5 = 116,
    _SC_ULONG_MAX___5 = 117,
    _SC_USHRT_MAX___5 = 118,
    _SC_NL_ARGMAX___5 = 119,
    _SC_NL_LANGMAX___5 = 120,
    _SC_NL_MSGMAX___5 = 121,
    _SC_NL_NMAX___5 = 122,
    _SC_NL_SETMAX___5 = 123,
    _SC_NL_TEXTMAX___5 = 124,
    _SC_XBS5_ILP32_OFF32___5 = 125,
    _SC_XBS5_ILP32_OFFBIG___5 = 126,
    _SC_XBS5_LP64_OFF64___5 = 127,
    _SC_XBS5_LPBIG_OFFBIG___5 = 128,
    _SC_XOPEN_LEGACY___5 = 129,
    _SC_XOPEN_REALTIME___5 = 130,
    _SC_XOPEN_REALTIME_THREADS___5 = 131,
    _SC_ADVISORY_INFO___5 = 132,
    _SC_BARRIERS___5 = 133,
    _SC_BASE___5 = 134,
    _SC_C_LANG_SUPPORT___5 = 135,
    _SC_C_LANG_SUPPORT_R___5 = 136,
    _SC_CLOCK_SELECTION___5 = 137,
    _SC_CPUTIME___5 = 138,
    _SC_THREAD_CPUTIME___5 = 139,
    _SC_DEVICE_IO___5 = 140,
    _SC_DEVICE_SPECIFIC___5 = 141,
    _SC_DEVICE_SPECIFIC_R___5 = 142,
    _SC_FD_MGMT___5 = 143,
    _SC_FIFO___5 = 144,
    _SC_PIPE___5 = 145,
    _SC_FILE_ATTRIBUTES___5 = 146,
    _SC_FILE_LOCKING___5 = 147,
    _SC_FILE_SYSTEM___5 = 148,
    _SC_MONOTONIC_CLOCK___5 = 149,
    _SC_MULTI_PROCESS___5 = 150,
    _SC_SINGLE_PROCESS___5 = 151,
    _SC_NETWORKING___5 = 152,
    _SC_READER_WRITER_LOCKS___5 = 153,
    _SC_SPIN_LOCKS___5 = 154,
    _SC_REGEXP___5 = 155,
    _SC_REGEX_VERSION___5 = 156,
    _SC_SHELL___5 = 157,
    _SC_SIGNALS___5 = 158,
    _SC_SPAWN___5 = 159,
    _SC_SPORADIC_SERVER___5 = 160,
    _SC_THREAD_SPORADIC_SERVER___5 = 161,
    _SC_SYSTEM_DATABASE___5 = 162,
    _SC_SYSTEM_DATABASE_R___5 = 163,
    _SC_TIMEOUTS___5 = 164,
    _SC_TYPED_MEMORY_OBJECTS___5 = 165,
    _SC_USER_GROUPS___5 = 166,
    _SC_USER_GROUPS_R___5 = 167,
    _SC_2_PBS___5 = 168,
    _SC_2_PBS_ACCOUNTING___5 = 169,
    _SC_2_PBS_LOCATE___5 = 170,
    _SC_2_PBS_MESSAGE___5 = 171,
    _SC_2_PBS_TRACK___5 = 172,
    _SC_SYMLOOP_MAX___5 = 173,
    _SC_STREAMS___5 = 174,
    _SC_2_PBS_CHECKPOINT___5 = 175,
    _SC_V6_ILP32_OFF32___5 = 176,
    _SC_V6_ILP32_OFFBIG___5 = 177,
    _SC_V6_LP64_OFF64___5 = 178,
    _SC_V6_LPBIG_OFFBIG___5 = 179,
    _SC_HOST_NAME_MAX___5 = 180,
    _SC_TRACE___5 = 181,
    _SC_TRACE_EVENT_FILTER___5 = 182,
    _SC_TRACE_INHERIT___5 = 183,
    _SC_TRACE_LOG___5 = 184,
    _SC_LEVEL1_ICACHE_SIZE___5 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___5 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___5 = 187,
    _SC_LEVEL1_DCACHE_SIZE___5 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___5 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___5 = 190,
    _SC_LEVEL2_CACHE_SIZE___5 = 191,
    _SC_LEVEL2_CACHE_ASSOC___5 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___5 = 193,
    _SC_LEVEL3_CACHE_SIZE___5 = 194,
    _SC_LEVEL3_CACHE_ASSOC___5 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___5 = 196,
    _SC_LEVEL4_CACHE_SIZE___5 = 197,
    _SC_LEVEL4_CACHE_ASSOC___5 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___5 = 199,
    _SC_IPV6___5 = 235,
    _SC_RAW_SOCKETS___5 = 236,
    _SC_V7_ILP32_OFF32___5 = 237,
    _SC_V7_ILP32_OFFBIG___5 = 238,
    _SC_V7_LP64_OFF64___5 = 239,
    _SC_V7_LPBIG_OFFBIG___5 = 240,
    _SC_SS_REPL_MAX___5 = 241,
    _SC_TRACE_EVENT_NAME_MAX___5 = 242,
    _SC_TRACE_NAME_MAX___5 = 243,
    _SC_TRACE_SYS_MAX___5 = 244,
    _SC_TRACE_USER_EVENT_MAX___5 = 245,
    _SC_XOPEN_STREAMS___5 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___5 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___5 = 248,
    _SC_MINSIGSTKSZ___5 = 249,
    _SC_SIGSTKSZ___5 = 250
} ;
enum __anonenum_875524036___5 {
    _CS_PATH___5 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___5 = 1,
    _CS_GNU_LIBC_VERSION___5 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___5 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___5 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___5 = 5,
    _CS_LFS_CFLAGS___5 = 1000,
    _CS_LFS_LDFLAGS___5 = 1001,
    _CS_LFS_LIBS___5 = 1002,
    _CS_LFS_LINTFLAGS___5 = 1003,
    _CS_LFS64_CFLAGS___5 = 1004,
    _CS_LFS64_LDFLAGS___5 = 1005,
    _CS_LFS64_LIBS___5 = 1006,
    _CS_LFS64_LINTFLAGS___5 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___5 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___5 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___5 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___5 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___5 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___5 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___5 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___5 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___5 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___5 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___5 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___5 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___5 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___5 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___5 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___5 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___5 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___5 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___5 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___5 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___5 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___5 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___5 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___5 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___5 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___5 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___5 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___5 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___5 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___5 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___5 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___5 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___5 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___5 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___5 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___5 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___5 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___5 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___5 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___5 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___5 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___5 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___5 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___5 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___5 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___5 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___5 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___5 = 1147,
    _CS_V6_ENV___5 = 1148,
    _CS_V7_ENV___5 = 1149
} ;
enum __anonenum_57186863___5 {
    SS_ONSTACK___5 = 1,
    SS_DISABLE___5 = 2
} ;
enum __anonenum_83571709___6 {
    MSG_OOB___6 = 1,
    MSG_PEEK___6 = 2,
    MSG_DONTROUTE___6 = 4,
    MSG_TRYHARD___6 = 4,
    MSG_CTRUNC___6 = 8,
    MSG_PROXY___6 = 16,
    MSG_TRUNC___6 = 32,
    MSG_DONTWAIT___6 = 64,
    MSG_EOR___6 = 128,
    MSG_WAITALL___6 = 256,
    MSG_FIN___6 = 512,
    MSG_SYN___6 = 1024,
    MSG_CONFIRM___6 = 2048,
    MSG_RST___6 = 4096,
    MSG_ERRQUEUE___6 = 8192,
    MSG_NOSIGNAL___6 = 16384,
    MSG_MORE___6 = 32768,
    MSG_WAITFORONE___6 = 65536,
    MSG_BATCH___6 = 262144,
    MSG_ZEROCOPY___6 = 67108864,
    MSG_FASTOPEN___6 = 536870912,
    MSG_CMSG_CLOEXEC___6 = 1073741824
} ;
enum __anonenum_617082774___6 {
    SCM_RIGHTS___6 = 1,
    SCM_CREDENTIALS___6 = 2
} ;
enum __anonenum_606441560___6 {
    SHUT_RD___6 = 0,
    SHUT_WR___6 = 1,
    SHUT_RDWR___6 = 2
} ;
enum __anonenum_264779956___6 {
    IPPROTO_IP___6 = 0,
    IPPROTO_ICMP___6 = 1,
    IPPROTO_IGMP___6 = 2,
    IPPROTO_IPIP___6 = 4,
    IPPROTO_TCP___6 = 6,
    IPPROTO_EGP___6 = 8,
    IPPROTO_PUP___6 = 12,
    IPPROTO_UDP___6 = 17,
    IPPROTO_IDP___6 = 22,
    IPPROTO_TP___6 = 29,
    IPPROTO_DCCP___6 = 33,
    IPPROTO_IPV6___6 = 41,
    IPPROTO_RSVP___6 = 46,
    IPPROTO_GRE___6 = 47,
    IPPROTO_ESP___6 = 50,
    IPPROTO_AH___6 = 51,
    IPPROTO_MTP___6 = 92,
    IPPROTO_BEETPH___6 = 94,
    IPPROTO_ENCAP___6 = 98,
    IPPROTO_PIM___6 = 103,
    IPPROTO_COMP___6 = 108,
    IPPROTO_SCTP___6 = 132,
    IPPROTO_UDPLITE___6 = 136,
    IPPROTO_MPLS___6 = 137,
    IPPROTO_ETHERNET___6 = 143,
    IPPROTO_RAW___6 = 255,
    IPPROTO_MPTCP___6 = 262,
    IPPROTO_MAX___6 = 263
} ;
enum __anonenum_218739988___6 {
    IPPROTO_HOPOPTS___6 = 0,
    IPPROTO_ROUTING___6 = 43,
    IPPROTO_FRAGMENT___6 = 44,
    IPPROTO_ICMPV6___6 = 58,
    IPPROTO_NONE___6 = 59,
    IPPROTO_DSTOPTS___6 = 60,
    IPPROTO_MH___6 = 135
} ;
enum __anonenum_662268580___6 {
    IPPORT_ECHO___6 = 7,
    IPPORT_DISCARD___6 = 9,
    IPPORT_SYSTAT___6 = 11,
    IPPORT_DAYTIME___6 = 13,
    IPPORT_NETSTAT___6 = 15,
    IPPORT_FTP___6 = 21,
    IPPORT_TELNET___6 = 23,
    IPPORT_SMTP___6 = 25,
    IPPORT_TIMESERVER___6 = 37,
    IPPORT_NAMESERVER___6 = 42,
    IPPORT_WHOIS___6 = 43,
    IPPORT_MTP___6 = 57,
    IPPORT_TFTP___6 = 69,
    IPPORT_RJE___6 = 77,
    IPPORT_FINGER___6 = 79,
    IPPORT_TTYLINK___6 = 87,
    IPPORT_SUPDUP___6 = 95,
    IPPORT_EXECSERVER___6 = 512,
    IPPORT_LOGINSERVER___6 = 513,
    IPPORT_CMDSERVER___6 = 514,
    IPPORT_EFSSERVER___6 = 520,
    IPPORT_BIFFUDP___6 = 512,
    IPPORT_WHOSERVER___6 = 513,
    IPPORT_ROUTESERVER___6 = 520,
    IPPORT_RESERVED___6 = 1024,
    IPPORT_USERRESERVED___6 = 5000
} ;
enum __anonenum_18926444___6 {
    _ISupper___6 = 256,
    _ISlower___6 = 512,
    _ISalpha___6 = 1024,
    _ISdigit___6 = 2048,
    _ISxdigit___6 = 4096,
    _ISspace___6 = 8192,
    _ISprint___6 = 16384,
    _ISgraph___6 = 32768,
    _ISblank___6 = 1,
    _IScntrl___6 = 2,
    _ISpunct___6 = 4,
    _ISalnum___6 = 8
} ;
enum __anonenum_913965969___6 {
    FP_INT_UPWARD___6 = 0,
    FP_INT_DOWNWARD___6 = 1,
    FP_INT_TOWARDZERO___6 = 2,
    FP_INT_TONEARESTFROMZERO___6 = 3,
    FP_INT_TONEAREST___6 = 4
} ;
enum __anonenum_1037408945___6 {
    FP_NAN___6 = 0,
    FP_INFINITE___6 = 1,
    FP_ZERO___6 = 2,
    FP_SUBNORMAL___6 = 3,
    FP_NORMAL___6 = 4
} ;
enum __anonenum_556971655___6 {
    SI_ASYNCNL___6 = -60,
    SI_DETHREAD___6 = -7,
    SI_TKILL___6 = -6,
    SI_SIGIO___6 = -5,
    SI_ASYNCIO___6 = -4,
    SI_MESGQ___6 = -3,
    SI_TIMER___6 = -2,
    SI_QUEUE___6 = -1,
    SI_USER___6 = 0,
    SI_KERNEL___6 = 128
} ;
enum __anonenum_640648963___6 {
    ILL_ILLOPC___6 = 1,
    ILL_ILLOPN___6 = 2,
    ILL_ILLADR___6 = 3,
    ILL_ILLTRP___6 = 4,
    ILL_PRVOPC___6 = 5,
    ILL_PRVREG___6 = 6,
    ILL_COPROC___6 = 7,
    ILL_BADSTK___6 = 8,
    ILL_BADIADDR___6 = 9
} ;
enum __anonenum_457704180___6 {
    FPE_INTDIV___6 = 1,
    FPE_INTOVF___6 = 2,
    FPE_FLTDIV___6 = 3,
    FPE_FLTOVF___6 = 4,
    FPE_FLTUND___6 = 5,
    FPE_FLTRES___6 = 6,
    FPE_FLTINV___6 = 7,
    FPE_FLTSUB___6 = 8,
    FPE_FLTUNK___6 = 14,
    FPE_CONDTRAP___6 = 15
} ;
enum __anonenum_180375148___6 {
    SEGV_MAPERR___6 = 1,
    SEGV_ACCERR___6 = 2,
    SEGV_BNDERR___6 = 3,
    SEGV_PKUERR___6 = 4,
    SEGV_ACCADI___6 = 5,
    SEGV_ADIDERR___6 = 6,
    SEGV_ADIPERR___6 = 7,
    SEGV_MTEAERR___6 = 8,
    SEGV_MTESERR___6 = 9
} ;
enum __anonenum_1036286214___6 {
    BUS_ADRALN___6 = 1,
    BUS_ADRERR___6 = 2,
    BUS_OBJERR___6 = 3,
    BUS_MCEERR_AR___6 = 4,
    BUS_MCEERR_AO___6 = 5
} ;
enum __anonenum_91015150___6 {
    TRAP_BRKPT___6 = 1,
    TRAP_TRACE___6 = 2,
    TRAP_BRANCH___6 = 3,
    TRAP_HWBKPT___6 = 4,
    TRAP_UNK___6 = 5
} ;
enum __anonenum_23175539___6 {
    CLD_EXITED___6 = 1,
    CLD_KILLED___6 = 2,
    CLD_DUMPED___6 = 3,
    CLD_TRAPPED___6 = 4,
    CLD_STOPPED___6 = 5,
    CLD_CONTINUED___6 = 6
} ;
enum __anonenum_111643124___6 {
    POLL_IN___6 = 1,
    POLL_OUT___6 = 2,
    POLL_MSG___6 = 3,
    POLL_ERR___6 = 4,
    POLL_PRI___6 = 5,
    POLL_HUP___6 = 6
} ;
enum __anonenum_852341087___6 {
    SIGEV_SIGNAL___6 = 0,
    SIGEV_NONE___6 = 1,
    SIGEV_THREAD___6 = 2,
    SIGEV_THREAD_ID___6 = 4
} ;
enum __anonenum_451154152___6 {
    REG_R8___6 = 0,
    REG_R9___6 = 1,
    REG_R10___6 = 2,
    REG_R11___6 = 3,
    REG_R12___6 = 4,
    REG_R13___6 = 5,
    REG_R14___6 = 6,
    REG_R15___6 = 7,
    REG_RDI___6 = 8,
    REG_RSI___6 = 9,
    REG_RBP___6 = 10,
    REG_RBX___6 = 11,
    REG_RDX___6 = 12,
    REG_RAX___6 = 13,
    REG_RCX___6 = 14,
    REG_RSP___6 = 15,
    REG_RIP___6 = 16,
    REG_EFL___6 = 17,
    REG_CSGSFS___6 = 18,
    REG_ERR___6 = 19,
    REG_TRAPNO___6 = 20,
    REG_OLDMASK___6 = 21,
    REG_CR2___6 = 22
} ;
enum __anonenum_437032235___6 {
    _PC_LINK_MAX___6 = 0,
    _PC_MAX_CANON___6 = 1,
    _PC_MAX_INPUT___6 = 2,
    _PC_NAME_MAX___6 = 3,
    _PC_PATH_MAX___6 = 4,
    _PC_PIPE_BUF___6 = 5,
    _PC_CHOWN_RESTRICTED___6 = 6,
    _PC_NO_TRUNC___6 = 7,
    _PC_VDISABLE___6 = 8,
    _PC_SYNC_IO___6 = 9,
    _PC_ASYNC_IO___6 = 10,
    _PC_PRIO_IO___6 = 11,
    _PC_SOCK_MAXBUF___6 = 12,
    _PC_FILESIZEBITS___6 = 13,
    _PC_REC_INCR_XFER_SIZE___6 = 14,
    _PC_REC_MAX_XFER_SIZE___6 = 15,
    _PC_REC_MIN_XFER_SIZE___6 = 16,
    _PC_REC_XFER_ALIGN___6 = 17,
    _PC_ALLOC_SIZE_MIN___6 = 18,
    _PC_SYMLINK_MAX___6 = 19,
    _PC_2_SYMLINKS___6 = 20
} ;
enum __anonenum_315186338___6 {
    _SC_ARG_MAX___6 = 0,
    _SC_CHILD_MAX___6 = 1,
    _SC_CLK_TCK___6 = 2,
    _SC_NGROUPS_MAX___6 = 3,
    _SC_OPEN_MAX___6 = 4,
    _SC_STREAM_MAX___6 = 5,
    _SC_TZNAME_MAX___6 = 6,
    _SC_JOB_CONTROL___6 = 7,
    _SC_SAVED_IDS___6 = 8,
    _SC_REALTIME_SIGNALS___6 = 9,
    _SC_PRIORITY_SCHEDULING___6 = 10,
    _SC_TIMERS___6 = 11,
    _SC_ASYNCHRONOUS_IO___6 = 12,
    _SC_PRIORITIZED_IO___6 = 13,
    _SC_SYNCHRONIZED_IO___6 = 14,
    _SC_FSYNC___6 = 15,
    _SC_MAPPED_FILES___6 = 16,
    _SC_MEMLOCK___6 = 17,
    _SC_MEMLOCK_RANGE___6 = 18,
    _SC_MEMORY_PROTECTION___6 = 19,
    _SC_MESSAGE_PASSING___6 = 20,
    _SC_SEMAPHORES___6 = 21,
    _SC_SHARED_MEMORY_OBJECTS___6 = 22,
    _SC_AIO_LISTIO_MAX___6 = 23,
    _SC_AIO_MAX___6 = 24,
    _SC_AIO_PRIO_DELTA_MAX___6 = 25,
    _SC_DELAYTIMER_MAX___6 = 26,
    _SC_MQ_OPEN_MAX___6 = 27,
    _SC_MQ_PRIO_MAX___6 = 28,
    _SC_VERSION___6 = 29,
    _SC_PAGESIZE___6 = 30,
    _SC_RTSIG_MAX___6 = 31,
    _SC_SEM_NSEMS_MAX___6 = 32,
    _SC_SEM_VALUE_MAX___6 = 33,
    _SC_SIGQUEUE_MAX___6 = 34,
    _SC_TIMER_MAX___6 = 35,
    _SC_BC_BASE_MAX___6 = 36,
    _SC_BC_DIM_MAX___6 = 37,
    _SC_BC_SCALE_MAX___6 = 38,
    _SC_BC_STRING_MAX___6 = 39,
    _SC_COLL_WEIGHTS_MAX___6 = 40,
    _SC_EQUIV_CLASS_MAX___6 = 41,
    _SC_EXPR_NEST_MAX___6 = 42,
    _SC_LINE_MAX___6 = 43,
    _SC_RE_DUP_MAX___6 = 44,
    _SC_CHARCLASS_NAME_MAX___6 = 45,
    _SC_2_VERSION___6 = 46,
    _SC_2_C_BIND___6 = 47,
    _SC_2_C_DEV___6 = 48,
    _SC_2_FORT_DEV___6 = 49,
    _SC_2_FORT_RUN___6 = 50,
    _SC_2_SW_DEV___6 = 51,
    _SC_2_LOCALEDEF___6 = 52,
    _SC_PII___6 = 53,
    _SC_PII_XTI___6 = 54,
    _SC_PII_SOCKET___6 = 55,
    _SC_PII_INTERNET___6 = 56,
    _SC_PII_OSI___6 = 57,
    _SC_POLL___6 = 58,
    _SC_SELECT___6 = 59,
    _SC_UIO_MAXIOV___6 = 60,
    _SC_IOV_MAX___6 = 60,
    _SC_PII_INTERNET_STREAM___6 = 61,
    _SC_PII_INTERNET_DGRAM___6 = 62,
    _SC_PII_OSI_COTS___6 = 63,
    _SC_PII_OSI_CLTS___6 = 64,
    _SC_PII_OSI_M___6 = 65,
    _SC_T_IOV_MAX___6 = 66,
    _SC_THREADS___6 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___6 = 68,
    _SC_GETGR_R_SIZE_MAX___6 = 69,
    _SC_GETPW_R_SIZE_MAX___6 = 70,
    _SC_LOGIN_NAME_MAX___6 = 71,
    _SC_TTY_NAME_MAX___6 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___6 = 73,
    _SC_THREAD_KEYS_MAX___6 = 74,
    _SC_THREAD_STACK_MIN___6 = 75,
    _SC_THREAD_THREADS_MAX___6 = 76,
    _SC_THREAD_ATTR_STACKADDR___6 = 77,
    _SC_THREAD_ATTR_STACKSIZE___6 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___6 = 79,
    _SC_THREAD_PRIO_INHERIT___6 = 80,
    _SC_THREAD_PRIO_PROTECT___6 = 81,
    _SC_THREAD_PROCESS_SHARED___6 = 82,
    _SC_NPROCESSORS_CONF___6 = 83,
    _SC_NPROCESSORS_ONLN___6 = 84,
    _SC_PHYS_PAGES___6 = 85,
    _SC_AVPHYS_PAGES___6 = 86,
    _SC_ATEXIT_MAX___6 = 87,
    _SC_PASS_MAX___6 = 88,
    _SC_XOPEN_VERSION___6 = 89,
    _SC_XOPEN_XCU_VERSION___6 = 90,
    _SC_XOPEN_UNIX___6 = 91,
    _SC_XOPEN_CRYPT___6 = 92,
    _SC_XOPEN_ENH_I18N___6 = 93,
    _SC_XOPEN_SHM___6 = 94,
    _SC_2_CHAR_TERM___6 = 95,
    _SC_2_C_VERSION___6 = 96,
    _SC_2_UPE___6 = 97,
    _SC_XOPEN_XPG2___6 = 98,
    _SC_XOPEN_XPG3___6 = 99,
    _SC_XOPEN_XPG4___6 = 100,
    _SC_CHAR_BIT___6 = 101,
    _SC_CHAR_MAX___6 = 102,
    _SC_CHAR_MIN___6 = 103,
    _SC_INT_MAX___6 = 104,
    _SC_INT_MIN___6 = 105,
    _SC_LONG_BIT___6 = 106,
    _SC_WORD_BIT___6 = 107,
    _SC_MB_LEN_MAX___6 = 108,
    _SC_NZERO___6 = 109,
    _SC_SSIZE_MAX___6 = 110,
    _SC_SCHAR_MAX___6 = 111,
    _SC_SCHAR_MIN___6 = 112,
    _SC_SHRT_MAX___6 = 113,
    _SC_SHRT_MIN___6 = 114,
    _SC_UCHAR_MAX___6 = 115,
    _SC_UINT_MAX___6 = 116,
    _SC_ULONG_MAX___6 = 117,
    _SC_USHRT_MAX___6 = 118,
    _SC_NL_ARGMAX___6 = 119,
    _SC_NL_LANGMAX___6 = 120,
    _SC_NL_MSGMAX___6 = 121,
    _SC_NL_NMAX___6 = 122,
    _SC_NL_SETMAX___6 = 123,
    _SC_NL_TEXTMAX___6 = 124,
    _SC_XBS5_ILP32_OFF32___6 = 125,
    _SC_XBS5_ILP32_OFFBIG___6 = 126,
    _SC_XBS5_LP64_OFF64___6 = 127,
    _SC_XBS5_LPBIG_OFFBIG___6 = 128,
    _SC_XOPEN_LEGACY___6 = 129,
    _SC_XOPEN_REALTIME___6 = 130,
    _SC_XOPEN_REALTIME_THREADS___6 = 131,
    _SC_ADVISORY_INFO___6 = 132,
    _SC_BARRIERS___6 = 133,
    _SC_BASE___6 = 134,
    _SC_C_LANG_SUPPORT___6 = 135,
    _SC_C_LANG_SUPPORT_R___6 = 136,
    _SC_CLOCK_SELECTION___6 = 137,
    _SC_CPUTIME___6 = 138,
    _SC_THREAD_CPUTIME___6 = 139,
    _SC_DEVICE_IO___6 = 140,
    _SC_DEVICE_SPECIFIC___6 = 141,
    _SC_DEVICE_SPECIFIC_R___6 = 142,
    _SC_FD_MGMT___6 = 143,
    _SC_FIFO___6 = 144,
    _SC_PIPE___6 = 145,
    _SC_FILE_ATTRIBUTES___6 = 146,
    _SC_FILE_LOCKING___6 = 147,
    _SC_FILE_SYSTEM___6 = 148,
    _SC_MONOTONIC_CLOCK___6 = 149,
    _SC_MULTI_PROCESS___6 = 150,
    _SC_SINGLE_PROCESS___6 = 151,
    _SC_NETWORKING___6 = 152,
    _SC_READER_WRITER_LOCKS___6 = 153,
    _SC_SPIN_LOCKS___6 = 154,
    _SC_REGEXP___6 = 155,
    _SC_REGEX_VERSION___6 = 156,
    _SC_SHELL___6 = 157,
    _SC_SIGNALS___6 = 158,
    _SC_SPAWN___6 = 159,
    _SC_SPORADIC_SERVER___6 = 160,
    _SC_THREAD_SPORADIC_SERVER___6 = 161,
    _SC_SYSTEM_DATABASE___6 = 162,
    _SC_SYSTEM_DATABASE_R___6 = 163,
    _SC_TIMEOUTS___6 = 164,
    _SC_TYPED_MEMORY_OBJECTS___6 = 165,
    _SC_USER_GROUPS___6 = 166,
    _SC_USER_GROUPS_R___6 = 167,
    _SC_2_PBS___6 = 168,
    _SC_2_PBS_ACCOUNTING___6 = 169,
    _SC_2_PBS_LOCATE___6 = 170,
    _SC_2_PBS_MESSAGE___6 = 171,
    _SC_2_PBS_TRACK___6 = 172,
    _SC_SYMLOOP_MAX___6 = 173,
    _SC_STREAMS___6 = 174,
    _SC_2_PBS_CHECKPOINT___6 = 175,
    _SC_V6_ILP32_OFF32___6 = 176,
    _SC_V6_ILP32_OFFBIG___6 = 177,
    _SC_V6_LP64_OFF64___6 = 178,
    _SC_V6_LPBIG_OFFBIG___6 = 179,
    _SC_HOST_NAME_MAX___6 = 180,
    _SC_TRACE___6 = 181,
    _SC_TRACE_EVENT_FILTER___6 = 182,
    _SC_TRACE_INHERIT___6 = 183,
    _SC_TRACE_LOG___6 = 184,
    _SC_LEVEL1_ICACHE_SIZE___6 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___6 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___6 = 187,
    _SC_LEVEL1_DCACHE_SIZE___6 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___6 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___6 = 190,
    _SC_LEVEL2_CACHE_SIZE___6 = 191,
    _SC_LEVEL2_CACHE_ASSOC___6 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___6 = 193,
    _SC_LEVEL3_CACHE_SIZE___6 = 194,
    _SC_LEVEL3_CACHE_ASSOC___6 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___6 = 196,
    _SC_LEVEL4_CACHE_SIZE___6 = 197,
    _SC_LEVEL4_CACHE_ASSOC___6 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___6 = 199,
    _SC_IPV6___6 = 235,
    _SC_RAW_SOCKETS___6 = 236,
    _SC_V7_ILP32_OFF32___6 = 237,
    _SC_V7_ILP32_OFFBIG___6 = 238,
    _SC_V7_LP64_OFF64___6 = 239,
    _SC_V7_LPBIG_OFFBIG___6 = 240,
    _SC_SS_REPL_MAX___6 = 241,
    _SC_TRACE_EVENT_NAME_MAX___6 = 242,
    _SC_TRACE_NAME_MAX___6 = 243,
    _SC_TRACE_SYS_MAX___6 = 244,
    _SC_TRACE_USER_EVENT_MAX___6 = 245,
    _SC_XOPEN_STREAMS___6 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___6 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___6 = 248,
    _SC_MINSIGSTKSZ___6 = 249,
    _SC_SIGSTKSZ___6 = 250
} ;
enum __anonenum_875524036___6 {
    _CS_PATH___6 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___6 = 1,
    _CS_GNU_LIBC_VERSION___6 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___6 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___6 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___6 = 5,
    _CS_LFS_CFLAGS___6 = 1000,
    _CS_LFS_LDFLAGS___6 = 1001,
    _CS_LFS_LIBS___6 = 1002,
    _CS_LFS_LINTFLAGS___6 = 1003,
    _CS_LFS64_CFLAGS___6 = 1004,
    _CS_LFS64_LDFLAGS___6 = 1005,
    _CS_LFS64_LIBS___6 = 1006,
    _CS_LFS64_LINTFLAGS___6 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___6 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___6 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___6 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___6 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___6 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___6 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___6 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___6 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___6 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___6 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___6 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___6 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___6 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___6 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___6 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___6 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___6 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___6 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___6 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___6 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___6 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___6 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___6 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___6 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___6 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___6 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___6 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___6 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___6 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___6 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___6 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___6 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___6 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___6 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___6 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___6 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___6 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___6 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___6 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___6 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___6 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___6 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___6 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___6 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___6 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___6 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___6 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___6 = 1147,
    _CS_V6_ENV___6 = 1148,
    _CS_V7_ENV___6 = 1149
} ;
enum __anonenum_57186863___6 {
    SS_ONSTACK___6 = 1,
    SS_DISABLE___6 = 2
} ;
struct fb_drift {
   double freq ;
   double secs ;
};
enum __anonenum_83571709___7 {
    MSG_OOB___7 = 1,
    MSG_PEEK___7 = 2,
    MSG_DONTROUTE___7 = 4,
    MSG_TRYHARD___7 = 4,
    MSG_CTRUNC___7 = 8,
    MSG_PROXY___7 = 16,
    MSG_TRUNC___7 = 32,
    MSG_DONTWAIT___7 = 64,
    MSG_EOR___7 = 128,
    MSG_WAITALL___7 = 256,
    MSG_FIN___7 = 512,
    MSG_SYN___7 = 1024,
    MSG_CONFIRM___7 = 2048,
    MSG_RST___7 = 4096,
    MSG_ERRQUEUE___7 = 8192,
    MSG_NOSIGNAL___7 = 16384,
    MSG_MORE___7 = 32768,
    MSG_WAITFORONE___7 = 65536,
    MSG_BATCH___7 = 262144,
    MSG_ZEROCOPY___7 = 67108864,
    MSG_FASTOPEN___7 = 536870912,
    MSG_CMSG_CLOEXEC___7 = 1073741824
} ;
enum __anonenum_617082774___7 {
    SCM_RIGHTS___7 = 1,
    SCM_CREDENTIALS___7 = 2
} ;
enum __anonenum_606441560___7 {
    SHUT_RD___7 = 0,
    SHUT_WR___7 = 1,
    SHUT_RDWR___7 = 2
} ;
enum __anonenum_264779956___7 {
    IPPROTO_IP___7 = 0,
    IPPROTO_ICMP___7 = 1,
    IPPROTO_IGMP___7 = 2,
    IPPROTO_IPIP___7 = 4,
    IPPROTO_TCP___7 = 6,
    IPPROTO_EGP___7 = 8,
    IPPROTO_PUP___7 = 12,
    IPPROTO_UDP___7 = 17,
    IPPROTO_IDP___7 = 22,
    IPPROTO_TP___7 = 29,
    IPPROTO_DCCP___7 = 33,
    IPPROTO_IPV6___7 = 41,
    IPPROTO_RSVP___7 = 46,
    IPPROTO_GRE___7 = 47,
    IPPROTO_ESP___7 = 50,
    IPPROTO_AH___7 = 51,
    IPPROTO_MTP___7 = 92,
    IPPROTO_BEETPH___7 = 94,
    IPPROTO_ENCAP___7 = 98,
    IPPROTO_PIM___7 = 103,
    IPPROTO_COMP___7 = 108,
    IPPROTO_SCTP___7 = 132,
    IPPROTO_UDPLITE___7 = 136,
    IPPROTO_MPLS___7 = 137,
    IPPROTO_ETHERNET___7 = 143,
    IPPROTO_RAW___7 = 255,
    IPPROTO_MPTCP___7 = 262,
    IPPROTO_MAX___7 = 263
} ;
enum __anonenum_218739988___7 {
    IPPROTO_HOPOPTS___7 = 0,
    IPPROTO_ROUTING___7 = 43,
    IPPROTO_FRAGMENT___7 = 44,
    IPPROTO_ICMPV6___7 = 58,
    IPPROTO_NONE___7 = 59,
    IPPROTO_DSTOPTS___7 = 60,
    IPPROTO_MH___7 = 135
} ;
enum __anonenum_662268580___7 {
    IPPORT_ECHO___7 = 7,
    IPPORT_DISCARD___7 = 9,
    IPPORT_SYSTAT___7 = 11,
    IPPORT_DAYTIME___7 = 13,
    IPPORT_NETSTAT___7 = 15,
    IPPORT_FTP___7 = 21,
    IPPORT_TELNET___7 = 23,
    IPPORT_SMTP___7 = 25,
    IPPORT_TIMESERVER___7 = 37,
    IPPORT_NAMESERVER___7 = 42,
    IPPORT_WHOIS___7 = 43,
    IPPORT_MTP___7 = 57,
    IPPORT_TFTP___7 = 69,
    IPPORT_RJE___7 = 77,
    IPPORT_FINGER___7 = 79,
    IPPORT_TTYLINK___7 = 87,
    IPPORT_SUPDUP___7 = 95,
    IPPORT_EXECSERVER___7 = 512,
    IPPORT_LOGINSERVER___7 = 513,
    IPPORT_CMDSERVER___7 = 514,
    IPPORT_EFSSERVER___7 = 520,
    IPPORT_BIFFUDP___7 = 512,
    IPPORT_WHOSERVER___7 = 513,
    IPPORT_ROUTESERVER___7 = 520,
    IPPORT_RESERVED___7 = 1024,
    IPPORT_USERRESERVED___7 = 5000
} ;
enum __anonenum_18926444___7 {
    _ISupper___7 = 256,
    _ISlower___7 = 512,
    _ISalpha___7 = 1024,
    _ISdigit___7 = 2048,
    _ISxdigit___7 = 4096,
    _ISspace___7 = 8192,
    _ISprint___7 = 16384,
    _ISgraph___7 = 32768,
    _ISblank___7 = 1,
    _IScntrl___7 = 2,
    _ISpunct___7 = 4,
    _ISalnum___7 = 8
} ;
enum __anonenum_913965969___7 {
    FP_INT_UPWARD___7 = 0,
    FP_INT_DOWNWARD___7 = 1,
    FP_INT_TOWARDZERO___7 = 2,
    FP_INT_TONEARESTFROMZERO___7 = 3,
    FP_INT_TONEAREST___7 = 4
} ;
enum __anonenum_1037408945___7 {
    FP_NAN___7 = 0,
    FP_INFINITE___7 = 1,
    FP_ZERO___7 = 2,
    FP_SUBNORMAL___7 = 3,
    FP_NORMAL___7 = 4
} ;
enum __anonenum_556971655___7 {
    SI_ASYNCNL___7 = -60,
    SI_DETHREAD___7 = -7,
    SI_TKILL___7 = -6,
    SI_SIGIO___7 = -5,
    SI_ASYNCIO___7 = -4,
    SI_MESGQ___7 = -3,
    SI_TIMER___7 = -2,
    SI_QUEUE___7 = -1,
    SI_USER___7 = 0,
    SI_KERNEL___7 = 128
} ;
enum __anonenum_640648963___7 {
    ILL_ILLOPC___7 = 1,
    ILL_ILLOPN___7 = 2,
    ILL_ILLADR___7 = 3,
    ILL_ILLTRP___7 = 4,
    ILL_PRVOPC___7 = 5,
    ILL_PRVREG___7 = 6,
    ILL_COPROC___7 = 7,
    ILL_BADSTK___7 = 8,
    ILL_BADIADDR___7 = 9
} ;
enum __anonenum_457704180___7 {
    FPE_INTDIV___7 = 1,
    FPE_INTOVF___7 = 2,
    FPE_FLTDIV___7 = 3,
    FPE_FLTOVF___7 = 4,
    FPE_FLTUND___7 = 5,
    FPE_FLTRES___7 = 6,
    FPE_FLTINV___7 = 7,
    FPE_FLTSUB___7 = 8,
    FPE_FLTUNK___7 = 14,
    FPE_CONDTRAP___7 = 15
} ;
enum __anonenum_180375148___7 {
    SEGV_MAPERR___7 = 1,
    SEGV_ACCERR___7 = 2,
    SEGV_BNDERR___7 = 3,
    SEGV_PKUERR___7 = 4,
    SEGV_ACCADI___7 = 5,
    SEGV_ADIDERR___7 = 6,
    SEGV_ADIPERR___7 = 7,
    SEGV_MTEAERR___7 = 8,
    SEGV_MTESERR___7 = 9
} ;
enum __anonenum_1036286214___7 {
    BUS_ADRALN___7 = 1,
    BUS_ADRERR___7 = 2,
    BUS_OBJERR___7 = 3,
    BUS_MCEERR_AR___7 = 4,
    BUS_MCEERR_AO___7 = 5
} ;
enum __anonenum_91015150___7 {
    TRAP_BRKPT___7 = 1,
    TRAP_TRACE___7 = 2,
    TRAP_BRANCH___7 = 3,
    TRAP_HWBKPT___7 = 4,
    TRAP_UNK___7 = 5
} ;
enum __anonenum_23175539___7 {
    CLD_EXITED___7 = 1,
    CLD_KILLED___7 = 2,
    CLD_DUMPED___7 = 3,
    CLD_TRAPPED___7 = 4,
    CLD_STOPPED___7 = 5,
    CLD_CONTINUED___7 = 6
} ;
enum __anonenum_111643124___7 {
    POLL_IN___7 = 1,
    POLL_OUT___7 = 2,
    POLL_MSG___7 = 3,
    POLL_ERR___7 = 4,
    POLL_PRI___7 = 5,
    POLL_HUP___7 = 6
} ;
enum __anonenum_852341087___7 {
    SIGEV_SIGNAL___7 = 0,
    SIGEV_NONE___7 = 1,
    SIGEV_THREAD___7 = 2,
    SIGEV_THREAD_ID___7 = 4
} ;
enum __anonenum_451154152___7 {
    REG_R8___7 = 0,
    REG_R9___7 = 1,
    REG_R10___7 = 2,
    REG_R11___7 = 3,
    REG_R12___7 = 4,
    REG_R13___7 = 5,
    REG_R14___7 = 6,
    REG_R15___7 = 7,
    REG_RDI___7 = 8,
    REG_RSI___7 = 9,
    REG_RBP___7 = 10,
    REG_RBX___7 = 11,
    REG_RDX___7 = 12,
    REG_RAX___7 = 13,
    REG_RCX___7 = 14,
    REG_RSP___7 = 15,
    REG_RIP___7 = 16,
    REG_EFL___7 = 17,
    REG_CSGSFS___7 = 18,
    REG_ERR___7 = 19,
    REG_TRAPNO___7 = 20,
    REG_OLDMASK___7 = 21,
    REG_CR2___7 = 22
} ;
enum __anonenum_437032235___7 {
    _PC_LINK_MAX___7 = 0,
    _PC_MAX_CANON___7 = 1,
    _PC_MAX_INPUT___7 = 2,
    _PC_NAME_MAX___7 = 3,
    _PC_PATH_MAX___7 = 4,
    _PC_PIPE_BUF___7 = 5,
    _PC_CHOWN_RESTRICTED___7 = 6,
    _PC_NO_TRUNC___7 = 7,
    _PC_VDISABLE___7 = 8,
    _PC_SYNC_IO___7 = 9,
    _PC_ASYNC_IO___7 = 10,
    _PC_PRIO_IO___7 = 11,
    _PC_SOCK_MAXBUF___7 = 12,
    _PC_FILESIZEBITS___7 = 13,
    _PC_REC_INCR_XFER_SIZE___7 = 14,
    _PC_REC_MAX_XFER_SIZE___7 = 15,
    _PC_REC_MIN_XFER_SIZE___7 = 16,
    _PC_REC_XFER_ALIGN___7 = 17,
    _PC_ALLOC_SIZE_MIN___7 = 18,
    _PC_SYMLINK_MAX___7 = 19,
    _PC_2_SYMLINKS___7 = 20
} ;
enum __anonenum_315186338___7 {
    _SC_ARG_MAX___7 = 0,
    _SC_CHILD_MAX___7 = 1,
    _SC_CLK_TCK___7 = 2,
    _SC_NGROUPS_MAX___7 = 3,
    _SC_OPEN_MAX___7 = 4,
    _SC_STREAM_MAX___7 = 5,
    _SC_TZNAME_MAX___7 = 6,
    _SC_JOB_CONTROL___7 = 7,
    _SC_SAVED_IDS___7 = 8,
    _SC_REALTIME_SIGNALS___7 = 9,
    _SC_PRIORITY_SCHEDULING___7 = 10,
    _SC_TIMERS___7 = 11,
    _SC_ASYNCHRONOUS_IO___7 = 12,
    _SC_PRIORITIZED_IO___7 = 13,
    _SC_SYNCHRONIZED_IO___7 = 14,
    _SC_FSYNC___7 = 15,
    _SC_MAPPED_FILES___7 = 16,
    _SC_MEMLOCK___7 = 17,
    _SC_MEMLOCK_RANGE___7 = 18,
    _SC_MEMORY_PROTECTION___7 = 19,
    _SC_MESSAGE_PASSING___7 = 20,
    _SC_SEMAPHORES___7 = 21,
    _SC_SHARED_MEMORY_OBJECTS___7 = 22,
    _SC_AIO_LISTIO_MAX___7 = 23,
    _SC_AIO_MAX___7 = 24,
    _SC_AIO_PRIO_DELTA_MAX___7 = 25,
    _SC_DELAYTIMER_MAX___7 = 26,
    _SC_MQ_OPEN_MAX___7 = 27,
    _SC_MQ_PRIO_MAX___7 = 28,
    _SC_VERSION___7 = 29,
    _SC_PAGESIZE___7 = 30,
    _SC_RTSIG_MAX___7 = 31,
    _SC_SEM_NSEMS_MAX___7 = 32,
    _SC_SEM_VALUE_MAX___7 = 33,
    _SC_SIGQUEUE_MAX___7 = 34,
    _SC_TIMER_MAX___7 = 35,
    _SC_BC_BASE_MAX___7 = 36,
    _SC_BC_DIM_MAX___7 = 37,
    _SC_BC_SCALE_MAX___7 = 38,
    _SC_BC_STRING_MAX___7 = 39,
    _SC_COLL_WEIGHTS_MAX___7 = 40,
    _SC_EQUIV_CLASS_MAX___7 = 41,
    _SC_EXPR_NEST_MAX___7 = 42,
    _SC_LINE_MAX___7 = 43,
    _SC_RE_DUP_MAX___7 = 44,
    _SC_CHARCLASS_NAME_MAX___7 = 45,
    _SC_2_VERSION___7 = 46,
    _SC_2_C_BIND___7 = 47,
    _SC_2_C_DEV___7 = 48,
    _SC_2_FORT_DEV___7 = 49,
    _SC_2_FORT_RUN___7 = 50,
    _SC_2_SW_DEV___7 = 51,
    _SC_2_LOCALEDEF___7 = 52,
    _SC_PII___7 = 53,
    _SC_PII_XTI___7 = 54,
    _SC_PII_SOCKET___7 = 55,
    _SC_PII_INTERNET___7 = 56,
    _SC_PII_OSI___7 = 57,
    _SC_POLL___7 = 58,
    _SC_SELECT___7 = 59,
    _SC_UIO_MAXIOV___7 = 60,
    _SC_IOV_MAX___7 = 60,
    _SC_PII_INTERNET_STREAM___7 = 61,
    _SC_PII_INTERNET_DGRAM___7 = 62,
    _SC_PII_OSI_COTS___7 = 63,
    _SC_PII_OSI_CLTS___7 = 64,
    _SC_PII_OSI_M___7 = 65,
    _SC_T_IOV_MAX___7 = 66,
    _SC_THREADS___7 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___7 = 68,
    _SC_GETGR_R_SIZE_MAX___7 = 69,
    _SC_GETPW_R_SIZE_MAX___7 = 70,
    _SC_LOGIN_NAME_MAX___7 = 71,
    _SC_TTY_NAME_MAX___7 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___7 = 73,
    _SC_THREAD_KEYS_MAX___7 = 74,
    _SC_THREAD_STACK_MIN___7 = 75,
    _SC_THREAD_THREADS_MAX___7 = 76,
    _SC_THREAD_ATTR_STACKADDR___7 = 77,
    _SC_THREAD_ATTR_STACKSIZE___7 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___7 = 79,
    _SC_THREAD_PRIO_INHERIT___7 = 80,
    _SC_THREAD_PRIO_PROTECT___7 = 81,
    _SC_THREAD_PROCESS_SHARED___7 = 82,
    _SC_NPROCESSORS_CONF___7 = 83,
    _SC_NPROCESSORS_ONLN___7 = 84,
    _SC_PHYS_PAGES___7 = 85,
    _SC_AVPHYS_PAGES___7 = 86,
    _SC_ATEXIT_MAX___7 = 87,
    _SC_PASS_MAX___7 = 88,
    _SC_XOPEN_VERSION___7 = 89,
    _SC_XOPEN_XCU_VERSION___7 = 90,
    _SC_XOPEN_UNIX___7 = 91,
    _SC_XOPEN_CRYPT___7 = 92,
    _SC_XOPEN_ENH_I18N___7 = 93,
    _SC_XOPEN_SHM___7 = 94,
    _SC_2_CHAR_TERM___7 = 95,
    _SC_2_C_VERSION___7 = 96,
    _SC_2_UPE___7 = 97,
    _SC_XOPEN_XPG2___7 = 98,
    _SC_XOPEN_XPG3___7 = 99,
    _SC_XOPEN_XPG4___7 = 100,
    _SC_CHAR_BIT___7 = 101,
    _SC_CHAR_MAX___7 = 102,
    _SC_CHAR_MIN___7 = 103,
    _SC_INT_MAX___7 = 104,
    _SC_INT_MIN___7 = 105,
    _SC_LONG_BIT___7 = 106,
    _SC_WORD_BIT___7 = 107,
    _SC_MB_LEN_MAX___7 = 108,
    _SC_NZERO___7 = 109,
    _SC_SSIZE_MAX___7 = 110,
    _SC_SCHAR_MAX___7 = 111,
    _SC_SCHAR_MIN___7 = 112,
    _SC_SHRT_MAX___7 = 113,
    _SC_SHRT_MIN___7 = 114,
    _SC_UCHAR_MAX___7 = 115,
    _SC_UINT_MAX___7 = 116,
    _SC_ULONG_MAX___7 = 117,
    _SC_USHRT_MAX___7 = 118,
    _SC_NL_ARGMAX___7 = 119,
    _SC_NL_LANGMAX___7 = 120,
    _SC_NL_MSGMAX___7 = 121,
    _SC_NL_NMAX___7 = 122,
    _SC_NL_SETMAX___7 = 123,
    _SC_NL_TEXTMAX___7 = 124,
    _SC_XBS5_ILP32_OFF32___7 = 125,
    _SC_XBS5_ILP32_OFFBIG___7 = 126,
    _SC_XBS5_LP64_OFF64___7 = 127,
    _SC_XBS5_LPBIG_OFFBIG___7 = 128,
    _SC_XOPEN_LEGACY___7 = 129,
    _SC_XOPEN_REALTIME___7 = 130,
    _SC_XOPEN_REALTIME_THREADS___7 = 131,
    _SC_ADVISORY_INFO___7 = 132,
    _SC_BARRIERS___7 = 133,
    _SC_BASE___7 = 134,
    _SC_C_LANG_SUPPORT___7 = 135,
    _SC_C_LANG_SUPPORT_R___7 = 136,
    _SC_CLOCK_SELECTION___7 = 137,
    _SC_CPUTIME___7 = 138,
    _SC_THREAD_CPUTIME___7 = 139,
    _SC_DEVICE_IO___7 = 140,
    _SC_DEVICE_SPECIFIC___7 = 141,
    _SC_DEVICE_SPECIFIC_R___7 = 142,
    _SC_FD_MGMT___7 = 143,
    _SC_FIFO___7 = 144,
    _SC_PIPE___7 = 145,
    _SC_FILE_ATTRIBUTES___7 = 146,
    _SC_FILE_LOCKING___7 = 147,
    _SC_FILE_SYSTEM___7 = 148,
    _SC_MONOTONIC_CLOCK___7 = 149,
    _SC_MULTI_PROCESS___7 = 150,
    _SC_SINGLE_PROCESS___7 = 151,
    _SC_NETWORKING___7 = 152,
    _SC_READER_WRITER_LOCKS___7 = 153,
    _SC_SPIN_LOCKS___7 = 154,
    _SC_REGEXP___7 = 155,
    _SC_REGEX_VERSION___7 = 156,
    _SC_SHELL___7 = 157,
    _SC_SIGNALS___7 = 158,
    _SC_SPAWN___7 = 159,
    _SC_SPORADIC_SERVER___7 = 160,
    _SC_THREAD_SPORADIC_SERVER___7 = 161,
    _SC_SYSTEM_DATABASE___7 = 162,
    _SC_SYSTEM_DATABASE_R___7 = 163,
    _SC_TIMEOUTS___7 = 164,
    _SC_TYPED_MEMORY_OBJECTS___7 = 165,
    _SC_USER_GROUPS___7 = 166,
    _SC_USER_GROUPS_R___7 = 167,
    _SC_2_PBS___7 = 168,
    _SC_2_PBS_ACCOUNTING___7 = 169,
    _SC_2_PBS_LOCATE___7 = 170,
    _SC_2_PBS_MESSAGE___7 = 171,
    _SC_2_PBS_TRACK___7 = 172,
    _SC_SYMLOOP_MAX___7 = 173,
    _SC_STREAMS___7 = 174,
    _SC_2_PBS_CHECKPOINT___7 = 175,
    _SC_V6_ILP32_OFF32___7 = 176,
    _SC_V6_ILP32_OFFBIG___7 = 177,
    _SC_V6_LP64_OFF64___7 = 178,
    _SC_V6_LPBIG_OFFBIG___7 = 179,
    _SC_HOST_NAME_MAX___7 = 180,
    _SC_TRACE___7 = 181,
    _SC_TRACE_EVENT_FILTER___7 = 182,
    _SC_TRACE_INHERIT___7 = 183,
    _SC_TRACE_LOG___7 = 184,
    _SC_LEVEL1_ICACHE_SIZE___7 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___7 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___7 = 187,
    _SC_LEVEL1_DCACHE_SIZE___7 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___7 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___7 = 190,
    _SC_LEVEL2_CACHE_SIZE___7 = 191,
    _SC_LEVEL2_CACHE_ASSOC___7 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___7 = 193,
    _SC_LEVEL3_CACHE_SIZE___7 = 194,
    _SC_LEVEL3_CACHE_ASSOC___7 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___7 = 196,
    _SC_LEVEL4_CACHE_SIZE___7 = 197,
    _SC_LEVEL4_CACHE_ASSOC___7 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___7 = 199,
    _SC_IPV6___7 = 235,
    _SC_RAW_SOCKETS___7 = 236,
    _SC_V7_ILP32_OFF32___7 = 237,
    _SC_V7_ILP32_OFFBIG___7 = 238,
    _SC_V7_LP64_OFF64___7 = 239,
    _SC_V7_LPBIG_OFFBIG___7 = 240,
    _SC_SS_REPL_MAX___7 = 241,
    _SC_TRACE_EVENT_NAME_MAX___7 = 242,
    _SC_TRACE_NAME_MAX___7 = 243,
    _SC_TRACE_SYS_MAX___7 = 244,
    _SC_TRACE_USER_EVENT_MAX___7 = 245,
    _SC_XOPEN_STREAMS___7 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___7 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___7 = 248,
    _SC_MINSIGSTKSZ___7 = 249,
    _SC_SIGSTKSZ___7 = 250
} ;
enum __anonenum_875524036___7 {
    _CS_PATH___7 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___7 = 1,
    _CS_GNU_LIBC_VERSION___7 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___7 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___7 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___7 = 5,
    _CS_LFS_CFLAGS___7 = 1000,
    _CS_LFS_LDFLAGS___7 = 1001,
    _CS_LFS_LIBS___7 = 1002,
    _CS_LFS_LINTFLAGS___7 = 1003,
    _CS_LFS64_CFLAGS___7 = 1004,
    _CS_LFS64_LDFLAGS___7 = 1005,
    _CS_LFS64_LIBS___7 = 1006,
    _CS_LFS64_LINTFLAGS___7 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___7 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___7 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___7 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___7 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___7 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___7 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___7 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___7 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___7 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___7 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___7 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___7 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___7 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___7 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___7 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___7 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___7 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___7 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___7 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___7 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___7 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___7 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___7 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___7 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___7 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___7 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___7 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___7 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___7 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___7 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___7 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___7 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___7 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___7 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___7 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___7 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___7 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___7 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___7 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___7 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___7 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___7 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___7 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___7 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___7 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___7 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___7 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___7 = 1147,
    _CS_V6_ENV___7 = 1148,
    _CS_V7_ENV___7 = 1149
} ;
enum __anonenum_57186863___7 {
    SS_ONSTACK___7 = 1,
    SS_DISABLE___7 = 2
} ;
enum __anonenum_83571709___8 {
    MSG_OOB___8 = 1,
    MSG_PEEK___8 = 2,
    MSG_DONTROUTE___8 = 4,
    MSG_TRYHARD___8 = 4,
    MSG_CTRUNC___8 = 8,
    MSG_PROXY___8 = 16,
    MSG_TRUNC___8 = 32,
    MSG_DONTWAIT___8 = 64,
    MSG_EOR___8 = 128,
    MSG_WAITALL___8 = 256,
    MSG_FIN___8 = 512,
    MSG_SYN___8 = 1024,
    MSG_CONFIRM___8 = 2048,
    MSG_RST___8 = 4096,
    MSG_ERRQUEUE___8 = 8192,
    MSG_NOSIGNAL___8 = 16384,
    MSG_MORE___8 = 32768,
    MSG_WAITFORONE___8 = 65536,
    MSG_BATCH___8 = 262144,
    MSG_ZEROCOPY___8 = 67108864,
    MSG_FASTOPEN___8 = 536870912,
    MSG_CMSG_CLOEXEC___8 = 1073741824
} ;
enum __anonenum_617082774___8 {
    SCM_RIGHTS___8 = 1,
    SCM_CREDENTIALS___8 = 2
} ;
enum __anonenum_606441560___8 {
    SHUT_RD___8 = 0,
    SHUT_WR___8 = 1,
    SHUT_RDWR___8 = 2
} ;
enum __anonenum_264779956___8 {
    IPPROTO_IP___8 = 0,
    IPPROTO_ICMP___8 = 1,
    IPPROTO_IGMP___8 = 2,
    IPPROTO_IPIP___8 = 4,
    IPPROTO_TCP___8 = 6,
    IPPROTO_EGP___8 = 8,
    IPPROTO_PUP___8 = 12,
    IPPROTO_UDP___8 = 17,
    IPPROTO_IDP___8 = 22,
    IPPROTO_TP___8 = 29,
    IPPROTO_DCCP___8 = 33,
    IPPROTO_IPV6___8 = 41,
    IPPROTO_RSVP___8 = 46,
    IPPROTO_GRE___8 = 47,
    IPPROTO_ESP___8 = 50,
    IPPROTO_AH___8 = 51,
    IPPROTO_MTP___8 = 92,
    IPPROTO_BEETPH___8 = 94,
    IPPROTO_ENCAP___8 = 98,
    IPPROTO_PIM___8 = 103,
    IPPROTO_COMP___8 = 108,
    IPPROTO_SCTP___8 = 132,
    IPPROTO_UDPLITE___8 = 136,
    IPPROTO_MPLS___8 = 137,
    IPPROTO_ETHERNET___8 = 143,
    IPPROTO_RAW___8 = 255,
    IPPROTO_MPTCP___8 = 262,
    IPPROTO_MAX___8 = 263
} ;
enum __anonenum_218739988___8 {
    IPPROTO_HOPOPTS___8 = 0,
    IPPROTO_ROUTING___8 = 43,
    IPPROTO_FRAGMENT___8 = 44,
    IPPROTO_ICMPV6___8 = 58,
    IPPROTO_NONE___8 = 59,
    IPPROTO_DSTOPTS___8 = 60,
    IPPROTO_MH___8 = 135
} ;
enum __anonenum_662268580___8 {
    IPPORT_ECHO___8 = 7,
    IPPORT_DISCARD___8 = 9,
    IPPORT_SYSTAT___8 = 11,
    IPPORT_DAYTIME___8 = 13,
    IPPORT_NETSTAT___8 = 15,
    IPPORT_FTP___8 = 21,
    IPPORT_TELNET___8 = 23,
    IPPORT_SMTP___8 = 25,
    IPPORT_TIMESERVER___8 = 37,
    IPPORT_NAMESERVER___8 = 42,
    IPPORT_WHOIS___8 = 43,
    IPPORT_MTP___8 = 57,
    IPPORT_TFTP___8 = 69,
    IPPORT_RJE___8 = 77,
    IPPORT_FINGER___8 = 79,
    IPPORT_TTYLINK___8 = 87,
    IPPORT_SUPDUP___8 = 95,
    IPPORT_EXECSERVER___8 = 512,
    IPPORT_LOGINSERVER___8 = 513,
    IPPORT_CMDSERVER___8 = 514,
    IPPORT_EFSSERVER___8 = 520,
    IPPORT_BIFFUDP___8 = 512,
    IPPORT_WHOSERVER___8 = 513,
    IPPORT_ROUTESERVER___8 = 520,
    IPPORT_RESERVED___8 = 1024,
    IPPORT_USERRESERVED___8 = 5000
} ;
enum __anonenum_18926444___8 {
    _ISupper___8 = 256,
    _ISlower___8 = 512,
    _ISalpha___8 = 1024,
    _ISdigit___8 = 2048,
    _ISxdigit___8 = 4096,
    _ISspace___8 = 8192,
    _ISprint___8 = 16384,
    _ISgraph___8 = 32768,
    _ISblank___8 = 1,
    _IScntrl___8 = 2,
    _ISpunct___8 = 4,
    _ISalnum___8 = 8
} ;
enum __anonenum_913965969___8 {
    FP_INT_UPWARD___8 = 0,
    FP_INT_DOWNWARD___8 = 1,
    FP_INT_TOWARDZERO___8 = 2,
    FP_INT_TONEARESTFROMZERO___8 = 3,
    FP_INT_TONEAREST___8 = 4
} ;
enum __anonenum_1037408945___8 {
    FP_NAN___8 = 0,
    FP_INFINITE___8 = 1,
    FP_ZERO___8 = 2,
    FP_SUBNORMAL___8 = 3,
    FP_NORMAL___8 = 4
} ;
enum __anonenum_556971655___8 {
    SI_ASYNCNL___8 = -60,
    SI_DETHREAD___8 = -7,
    SI_TKILL___8 = -6,
    SI_SIGIO___8 = -5,
    SI_ASYNCIO___8 = -4,
    SI_MESGQ___8 = -3,
    SI_TIMER___8 = -2,
    SI_QUEUE___8 = -1,
    SI_USER___8 = 0,
    SI_KERNEL___8 = 128
} ;
enum __anonenum_640648963___8 {
    ILL_ILLOPC___8 = 1,
    ILL_ILLOPN___8 = 2,
    ILL_ILLADR___8 = 3,
    ILL_ILLTRP___8 = 4,
    ILL_PRVOPC___8 = 5,
    ILL_PRVREG___8 = 6,
    ILL_COPROC___8 = 7,
    ILL_BADSTK___8 = 8,
    ILL_BADIADDR___8 = 9
} ;
enum __anonenum_457704180___8 {
    FPE_INTDIV___8 = 1,
    FPE_INTOVF___8 = 2,
    FPE_FLTDIV___8 = 3,
    FPE_FLTOVF___8 = 4,
    FPE_FLTUND___8 = 5,
    FPE_FLTRES___8 = 6,
    FPE_FLTINV___8 = 7,
    FPE_FLTSUB___8 = 8,
    FPE_FLTUNK___8 = 14,
    FPE_CONDTRAP___8 = 15
} ;
enum __anonenum_180375148___8 {
    SEGV_MAPERR___8 = 1,
    SEGV_ACCERR___8 = 2,
    SEGV_BNDERR___8 = 3,
    SEGV_PKUERR___8 = 4,
    SEGV_ACCADI___8 = 5,
    SEGV_ADIDERR___8 = 6,
    SEGV_ADIPERR___8 = 7,
    SEGV_MTEAERR___8 = 8,
    SEGV_MTESERR___8 = 9
} ;
enum __anonenum_1036286214___8 {
    BUS_ADRALN___8 = 1,
    BUS_ADRERR___8 = 2,
    BUS_OBJERR___8 = 3,
    BUS_MCEERR_AR___8 = 4,
    BUS_MCEERR_AO___8 = 5
} ;
enum __anonenum_91015150___8 {
    TRAP_BRKPT___8 = 1,
    TRAP_TRACE___8 = 2,
    TRAP_BRANCH___8 = 3,
    TRAP_HWBKPT___8 = 4,
    TRAP_UNK___8 = 5
} ;
enum __anonenum_23175539___8 {
    CLD_EXITED___8 = 1,
    CLD_KILLED___8 = 2,
    CLD_DUMPED___8 = 3,
    CLD_TRAPPED___8 = 4,
    CLD_STOPPED___8 = 5,
    CLD_CONTINUED___8 = 6
} ;
enum __anonenum_111643124___8 {
    POLL_IN___8 = 1,
    POLL_OUT___8 = 2,
    POLL_MSG___8 = 3,
    POLL_ERR___8 = 4,
    POLL_PRI___8 = 5,
    POLL_HUP___8 = 6
} ;
enum __anonenum_852341087___8 {
    SIGEV_SIGNAL___8 = 0,
    SIGEV_NONE___8 = 1,
    SIGEV_THREAD___8 = 2,
    SIGEV_THREAD_ID___8 = 4
} ;
enum __anonenum_451154152___8 {
    REG_R8___8 = 0,
    REG_R9___8 = 1,
    REG_R10___8 = 2,
    REG_R11___8 = 3,
    REG_R12___8 = 4,
    REG_R13___8 = 5,
    REG_R14___8 = 6,
    REG_R15___8 = 7,
    REG_RDI___8 = 8,
    REG_RSI___8 = 9,
    REG_RBP___8 = 10,
    REG_RBX___8 = 11,
    REG_RDX___8 = 12,
    REG_RAX___8 = 13,
    REG_RCX___8 = 14,
    REG_RSP___8 = 15,
    REG_RIP___8 = 16,
    REG_EFL___8 = 17,
    REG_CSGSFS___8 = 18,
    REG_ERR___8 = 19,
    REG_TRAPNO___8 = 20,
    REG_OLDMASK___8 = 21,
    REG_CR2___8 = 22
} ;
enum __anonenum_437032235___8 {
    _PC_LINK_MAX___8 = 0,
    _PC_MAX_CANON___8 = 1,
    _PC_MAX_INPUT___8 = 2,
    _PC_NAME_MAX___8 = 3,
    _PC_PATH_MAX___8 = 4,
    _PC_PIPE_BUF___8 = 5,
    _PC_CHOWN_RESTRICTED___8 = 6,
    _PC_NO_TRUNC___8 = 7,
    _PC_VDISABLE___8 = 8,
    _PC_SYNC_IO___8 = 9,
    _PC_ASYNC_IO___8 = 10,
    _PC_PRIO_IO___8 = 11,
    _PC_SOCK_MAXBUF___8 = 12,
    _PC_FILESIZEBITS___8 = 13,
    _PC_REC_INCR_XFER_SIZE___8 = 14,
    _PC_REC_MAX_XFER_SIZE___8 = 15,
    _PC_REC_MIN_XFER_SIZE___8 = 16,
    _PC_REC_XFER_ALIGN___8 = 17,
    _PC_ALLOC_SIZE_MIN___8 = 18,
    _PC_SYMLINK_MAX___8 = 19,
    _PC_2_SYMLINKS___8 = 20
} ;
enum __anonenum_315186338___8 {
    _SC_ARG_MAX___8 = 0,
    _SC_CHILD_MAX___8 = 1,
    _SC_CLK_TCK___8 = 2,
    _SC_NGROUPS_MAX___8 = 3,
    _SC_OPEN_MAX___8 = 4,
    _SC_STREAM_MAX___8 = 5,
    _SC_TZNAME_MAX___8 = 6,
    _SC_JOB_CONTROL___8 = 7,
    _SC_SAVED_IDS___8 = 8,
    _SC_REALTIME_SIGNALS___8 = 9,
    _SC_PRIORITY_SCHEDULING___8 = 10,
    _SC_TIMERS___8 = 11,
    _SC_ASYNCHRONOUS_IO___8 = 12,
    _SC_PRIORITIZED_IO___8 = 13,
    _SC_SYNCHRONIZED_IO___8 = 14,
    _SC_FSYNC___8 = 15,
    _SC_MAPPED_FILES___8 = 16,
    _SC_MEMLOCK___8 = 17,
    _SC_MEMLOCK_RANGE___8 = 18,
    _SC_MEMORY_PROTECTION___8 = 19,
    _SC_MESSAGE_PASSING___8 = 20,
    _SC_SEMAPHORES___8 = 21,
    _SC_SHARED_MEMORY_OBJECTS___8 = 22,
    _SC_AIO_LISTIO_MAX___8 = 23,
    _SC_AIO_MAX___8 = 24,
    _SC_AIO_PRIO_DELTA_MAX___8 = 25,
    _SC_DELAYTIMER_MAX___8 = 26,
    _SC_MQ_OPEN_MAX___8 = 27,
    _SC_MQ_PRIO_MAX___8 = 28,
    _SC_VERSION___8 = 29,
    _SC_PAGESIZE___8 = 30,
    _SC_RTSIG_MAX___8 = 31,
    _SC_SEM_NSEMS_MAX___8 = 32,
    _SC_SEM_VALUE_MAX___8 = 33,
    _SC_SIGQUEUE_MAX___8 = 34,
    _SC_TIMER_MAX___8 = 35,
    _SC_BC_BASE_MAX___8 = 36,
    _SC_BC_DIM_MAX___8 = 37,
    _SC_BC_SCALE_MAX___8 = 38,
    _SC_BC_STRING_MAX___8 = 39,
    _SC_COLL_WEIGHTS_MAX___8 = 40,
    _SC_EQUIV_CLASS_MAX___8 = 41,
    _SC_EXPR_NEST_MAX___8 = 42,
    _SC_LINE_MAX___8 = 43,
    _SC_RE_DUP_MAX___8 = 44,
    _SC_CHARCLASS_NAME_MAX___8 = 45,
    _SC_2_VERSION___8 = 46,
    _SC_2_C_BIND___8 = 47,
    _SC_2_C_DEV___8 = 48,
    _SC_2_FORT_DEV___8 = 49,
    _SC_2_FORT_RUN___8 = 50,
    _SC_2_SW_DEV___8 = 51,
    _SC_2_LOCALEDEF___8 = 52,
    _SC_PII___8 = 53,
    _SC_PII_XTI___8 = 54,
    _SC_PII_SOCKET___8 = 55,
    _SC_PII_INTERNET___8 = 56,
    _SC_PII_OSI___8 = 57,
    _SC_POLL___8 = 58,
    _SC_SELECT___8 = 59,
    _SC_UIO_MAXIOV___8 = 60,
    _SC_IOV_MAX___8 = 60,
    _SC_PII_INTERNET_STREAM___8 = 61,
    _SC_PII_INTERNET_DGRAM___8 = 62,
    _SC_PII_OSI_COTS___8 = 63,
    _SC_PII_OSI_CLTS___8 = 64,
    _SC_PII_OSI_M___8 = 65,
    _SC_T_IOV_MAX___8 = 66,
    _SC_THREADS___8 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___8 = 68,
    _SC_GETGR_R_SIZE_MAX___8 = 69,
    _SC_GETPW_R_SIZE_MAX___8 = 70,
    _SC_LOGIN_NAME_MAX___8 = 71,
    _SC_TTY_NAME_MAX___8 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___8 = 73,
    _SC_THREAD_KEYS_MAX___8 = 74,
    _SC_THREAD_STACK_MIN___8 = 75,
    _SC_THREAD_THREADS_MAX___8 = 76,
    _SC_THREAD_ATTR_STACKADDR___8 = 77,
    _SC_THREAD_ATTR_STACKSIZE___8 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___8 = 79,
    _SC_THREAD_PRIO_INHERIT___8 = 80,
    _SC_THREAD_PRIO_PROTECT___8 = 81,
    _SC_THREAD_PROCESS_SHARED___8 = 82,
    _SC_NPROCESSORS_CONF___8 = 83,
    _SC_NPROCESSORS_ONLN___8 = 84,
    _SC_PHYS_PAGES___8 = 85,
    _SC_AVPHYS_PAGES___8 = 86,
    _SC_ATEXIT_MAX___8 = 87,
    _SC_PASS_MAX___8 = 88,
    _SC_XOPEN_VERSION___8 = 89,
    _SC_XOPEN_XCU_VERSION___8 = 90,
    _SC_XOPEN_UNIX___8 = 91,
    _SC_XOPEN_CRYPT___8 = 92,
    _SC_XOPEN_ENH_I18N___8 = 93,
    _SC_XOPEN_SHM___8 = 94,
    _SC_2_CHAR_TERM___8 = 95,
    _SC_2_C_VERSION___8 = 96,
    _SC_2_UPE___8 = 97,
    _SC_XOPEN_XPG2___8 = 98,
    _SC_XOPEN_XPG3___8 = 99,
    _SC_XOPEN_XPG4___8 = 100,
    _SC_CHAR_BIT___8 = 101,
    _SC_CHAR_MAX___8 = 102,
    _SC_CHAR_MIN___8 = 103,
    _SC_INT_MAX___8 = 104,
    _SC_INT_MIN___8 = 105,
    _SC_LONG_BIT___8 = 106,
    _SC_WORD_BIT___8 = 107,
    _SC_MB_LEN_MAX___8 = 108,
    _SC_NZERO___8 = 109,
    _SC_SSIZE_MAX___8 = 110,
    _SC_SCHAR_MAX___8 = 111,
    _SC_SCHAR_MIN___8 = 112,
    _SC_SHRT_MAX___8 = 113,
    _SC_SHRT_MIN___8 = 114,
    _SC_UCHAR_MAX___8 = 115,
    _SC_UINT_MAX___8 = 116,
    _SC_ULONG_MAX___8 = 117,
    _SC_USHRT_MAX___8 = 118,
    _SC_NL_ARGMAX___8 = 119,
    _SC_NL_LANGMAX___8 = 120,
    _SC_NL_MSGMAX___8 = 121,
    _SC_NL_NMAX___8 = 122,
    _SC_NL_SETMAX___8 = 123,
    _SC_NL_TEXTMAX___8 = 124,
    _SC_XBS5_ILP32_OFF32___8 = 125,
    _SC_XBS5_ILP32_OFFBIG___8 = 126,
    _SC_XBS5_LP64_OFF64___8 = 127,
    _SC_XBS5_LPBIG_OFFBIG___8 = 128,
    _SC_XOPEN_LEGACY___8 = 129,
    _SC_XOPEN_REALTIME___8 = 130,
    _SC_XOPEN_REALTIME_THREADS___8 = 131,
    _SC_ADVISORY_INFO___8 = 132,
    _SC_BARRIERS___8 = 133,
    _SC_BASE___8 = 134,
    _SC_C_LANG_SUPPORT___8 = 135,
    _SC_C_LANG_SUPPORT_R___8 = 136,
    _SC_CLOCK_SELECTION___8 = 137,
    _SC_CPUTIME___8 = 138,
    _SC_THREAD_CPUTIME___8 = 139,
    _SC_DEVICE_IO___8 = 140,
    _SC_DEVICE_SPECIFIC___8 = 141,
    _SC_DEVICE_SPECIFIC_R___8 = 142,
    _SC_FD_MGMT___8 = 143,
    _SC_FIFO___8 = 144,
    _SC_PIPE___8 = 145,
    _SC_FILE_ATTRIBUTES___8 = 146,
    _SC_FILE_LOCKING___8 = 147,
    _SC_FILE_SYSTEM___8 = 148,
    _SC_MONOTONIC_CLOCK___8 = 149,
    _SC_MULTI_PROCESS___8 = 150,
    _SC_SINGLE_PROCESS___8 = 151,
    _SC_NETWORKING___8 = 152,
    _SC_READER_WRITER_LOCKS___8 = 153,
    _SC_SPIN_LOCKS___8 = 154,
    _SC_REGEXP___8 = 155,
    _SC_REGEX_VERSION___8 = 156,
    _SC_SHELL___8 = 157,
    _SC_SIGNALS___8 = 158,
    _SC_SPAWN___8 = 159,
    _SC_SPORADIC_SERVER___8 = 160,
    _SC_THREAD_SPORADIC_SERVER___8 = 161,
    _SC_SYSTEM_DATABASE___8 = 162,
    _SC_SYSTEM_DATABASE_R___8 = 163,
    _SC_TIMEOUTS___8 = 164,
    _SC_TYPED_MEMORY_OBJECTS___8 = 165,
    _SC_USER_GROUPS___8 = 166,
    _SC_USER_GROUPS_R___8 = 167,
    _SC_2_PBS___8 = 168,
    _SC_2_PBS_ACCOUNTING___8 = 169,
    _SC_2_PBS_LOCATE___8 = 170,
    _SC_2_PBS_MESSAGE___8 = 171,
    _SC_2_PBS_TRACK___8 = 172,
    _SC_SYMLOOP_MAX___8 = 173,
    _SC_STREAMS___8 = 174,
    _SC_2_PBS_CHECKPOINT___8 = 175,
    _SC_V6_ILP32_OFF32___8 = 176,
    _SC_V6_ILP32_OFFBIG___8 = 177,
    _SC_V6_LP64_OFF64___8 = 178,
    _SC_V6_LPBIG_OFFBIG___8 = 179,
    _SC_HOST_NAME_MAX___8 = 180,
    _SC_TRACE___8 = 181,
    _SC_TRACE_EVENT_FILTER___8 = 182,
    _SC_TRACE_INHERIT___8 = 183,
    _SC_TRACE_LOG___8 = 184,
    _SC_LEVEL1_ICACHE_SIZE___8 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___8 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___8 = 187,
    _SC_LEVEL1_DCACHE_SIZE___8 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___8 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___8 = 190,
    _SC_LEVEL2_CACHE_SIZE___8 = 191,
    _SC_LEVEL2_CACHE_ASSOC___8 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___8 = 193,
    _SC_LEVEL3_CACHE_SIZE___8 = 194,
    _SC_LEVEL3_CACHE_ASSOC___8 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___8 = 196,
    _SC_LEVEL4_CACHE_SIZE___8 = 197,
    _SC_LEVEL4_CACHE_ASSOC___8 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___8 = 199,
    _SC_IPV6___8 = 235,
    _SC_RAW_SOCKETS___8 = 236,
    _SC_V7_ILP32_OFF32___8 = 237,
    _SC_V7_ILP32_OFFBIG___8 = 238,
    _SC_V7_LP64_OFF64___8 = 239,
    _SC_V7_LPBIG_OFFBIG___8 = 240,
    _SC_SS_REPL_MAX___8 = 241,
    _SC_TRACE_EVENT_NAME_MAX___8 = 242,
    _SC_TRACE_NAME_MAX___8 = 243,
    _SC_TRACE_SYS_MAX___8 = 244,
    _SC_TRACE_USER_EVENT_MAX___8 = 245,
    _SC_XOPEN_STREAMS___8 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___8 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___8 = 248,
    _SC_MINSIGSTKSZ___8 = 249,
    _SC_SIGSTKSZ___8 = 250
} ;
enum __anonenum_875524036___8 {
    _CS_PATH___8 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___8 = 1,
    _CS_GNU_LIBC_VERSION___8 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___8 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___8 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___8 = 5,
    _CS_LFS_CFLAGS___8 = 1000,
    _CS_LFS_LDFLAGS___8 = 1001,
    _CS_LFS_LIBS___8 = 1002,
    _CS_LFS_LINTFLAGS___8 = 1003,
    _CS_LFS64_CFLAGS___8 = 1004,
    _CS_LFS64_LDFLAGS___8 = 1005,
    _CS_LFS64_LIBS___8 = 1006,
    _CS_LFS64_LINTFLAGS___8 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___8 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___8 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___8 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___8 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___8 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___8 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___8 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___8 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___8 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___8 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___8 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___8 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___8 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___8 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___8 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___8 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___8 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___8 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___8 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___8 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___8 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___8 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___8 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___8 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___8 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___8 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___8 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___8 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___8 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___8 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___8 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___8 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___8 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___8 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___8 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___8 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___8 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___8 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___8 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___8 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___8 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___8 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___8 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___8 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___8 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___8 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___8 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___8 = 1147,
    _CS_V6_ENV___8 = 1148,
    _CS_V7_ENV___8 = 1149
} ;
enum __anonenum_57186863___8 {
    SS_ONSTACK___8 = 1,
    SS_DISABLE___8 = 2
} ;
struct __anonstruct_driver_285539026 {
   int (*init)(void) ;
   void (*fini)(void) ;
   int (*time_pre_init)(time_t driftfile_time ) ;
   void (*time_init)(void (*after_hook)(void * ) , void *anything ) ;
   void (*start_measurements)(void) ;
   int (*write_parameters)(void) ;
   int (*get_report)(RPT_RTC_Report *report ) ;
   int (*trim)(void) ;
};
enum __anonenum_83571709___9 {
    MSG_OOB___9 = 1,
    MSG_PEEK___9 = 2,
    MSG_DONTROUTE___9 = 4,
    MSG_TRYHARD___9 = 4,
    MSG_CTRUNC___9 = 8,
    MSG_PROXY___9 = 16,
    MSG_TRUNC___9 = 32,
    MSG_DONTWAIT___9 = 64,
    MSG_EOR___9 = 128,
    MSG_WAITALL___9 = 256,
    MSG_FIN___9 = 512,
    MSG_SYN___9 = 1024,
    MSG_CONFIRM___9 = 2048,
    MSG_RST___9 = 4096,
    MSG_ERRQUEUE___9 = 8192,
    MSG_NOSIGNAL___9 = 16384,
    MSG_MORE___9 = 32768,
    MSG_WAITFORONE___9 = 65536,
    MSG_BATCH___9 = 262144,
    MSG_ZEROCOPY___9 = 67108864,
    MSG_FASTOPEN___9 = 536870912,
    MSG_CMSG_CLOEXEC___9 = 1073741824
} ;
enum __anonenum_617082774___9 {
    SCM_RIGHTS___9 = 1,
    SCM_CREDENTIALS___9 = 2
} ;
enum __anonenum_606441560___9 {
    SHUT_RD___9 = 0,
    SHUT_WR___9 = 1,
    SHUT_RDWR___9 = 2
} ;
enum __anonenum_264779956___9 {
    IPPROTO_IP___9 = 0,
    IPPROTO_ICMP___9 = 1,
    IPPROTO_IGMP___9 = 2,
    IPPROTO_IPIP___9 = 4,
    IPPROTO_TCP___9 = 6,
    IPPROTO_EGP___9 = 8,
    IPPROTO_PUP___9 = 12,
    IPPROTO_UDP___9 = 17,
    IPPROTO_IDP___9 = 22,
    IPPROTO_TP___9 = 29,
    IPPROTO_DCCP___9 = 33,
    IPPROTO_IPV6___9 = 41,
    IPPROTO_RSVP___9 = 46,
    IPPROTO_GRE___9 = 47,
    IPPROTO_ESP___9 = 50,
    IPPROTO_AH___9 = 51,
    IPPROTO_MTP___9 = 92,
    IPPROTO_BEETPH___9 = 94,
    IPPROTO_ENCAP___9 = 98,
    IPPROTO_PIM___9 = 103,
    IPPROTO_COMP___9 = 108,
    IPPROTO_SCTP___9 = 132,
    IPPROTO_UDPLITE___9 = 136,
    IPPROTO_MPLS___9 = 137,
    IPPROTO_ETHERNET___9 = 143,
    IPPROTO_RAW___9 = 255,
    IPPROTO_MPTCP___9 = 262,
    IPPROTO_MAX___9 = 263
} ;
enum __anonenum_218739988___9 {
    IPPROTO_HOPOPTS___9 = 0,
    IPPROTO_ROUTING___9 = 43,
    IPPROTO_FRAGMENT___9 = 44,
    IPPROTO_ICMPV6___9 = 58,
    IPPROTO_NONE___9 = 59,
    IPPROTO_DSTOPTS___9 = 60,
    IPPROTO_MH___9 = 135
} ;
enum __anonenum_662268580___9 {
    IPPORT_ECHO___9 = 7,
    IPPORT_DISCARD___9 = 9,
    IPPORT_SYSTAT___9 = 11,
    IPPORT_DAYTIME___9 = 13,
    IPPORT_NETSTAT___9 = 15,
    IPPORT_FTP___9 = 21,
    IPPORT_TELNET___9 = 23,
    IPPORT_SMTP___9 = 25,
    IPPORT_TIMESERVER___9 = 37,
    IPPORT_NAMESERVER___9 = 42,
    IPPORT_WHOIS___9 = 43,
    IPPORT_MTP___9 = 57,
    IPPORT_TFTP___9 = 69,
    IPPORT_RJE___9 = 77,
    IPPORT_FINGER___9 = 79,
    IPPORT_TTYLINK___9 = 87,
    IPPORT_SUPDUP___9 = 95,
    IPPORT_EXECSERVER___9 = 512,
    IPPORT_LOGINSERVER___9 = 513,
    IPPORT_CMDSERVER___9 = 514,
    IPPORT_EFSSERVER___9 = 520,
    IPPORT_BIFFUDP___9 = 512,
    IPPORT_WHOSERVER___9 = 513,
    IPPORT_ROUTESERVER___9 = 520,
    IPPORT_RESERVED___9 = 1024,
    IPPORT_USERRESERVED___9 = 5000
} ;
enum __anonenum_18926444___9 {
    _ISupper___9 = 256,
    _ISlower___9 = 512,
    _ISalpha___9 = 1024,
    _ISdigit___9 = 2048,
    _ISxdigit___9 = 4096,
    _ISspace___9 = 8192,
    _ISprint___9 = 16384,
    _ISgraph___9 = 32768,
    _ISblank___9 = 1,
    _IScntrl___9 = 2,
    _ISpunct___9 = 4,
    _ISalnum___9 = 8
} ;
enum __anonenum_913965969___9 {
    FP_INT_UPWARD___9 = 0,
    FP_INT_DOWNWARD___9 = 1,
    FP_INT_TOWARDZERO___9 = 2,
    FP_INT_TONEARESTFROMZERO___9 = 3,
    FP_INT_TONEAREST___9 = 4
} ;
enum __anonenum_1037408945___9 {
    FP_NAN___9 = 0,
    FP_INFINITE___9 = 1,
    FP_ZERO___9 = 2,
    FP_SUBNORMAL___9 = 3,
    FP_NORMAL___9 = 4
} ;
enum __anonenum_556971655___9 {
    SI_ASYNCNL___9 = -60,
    SI_DETHREAD___9 = -7,
    SI_TKILL___9 = -6,
    SI_SIGIO___9 = -5,
    SI_ASYNCIO___9 = -4,
    SI_MESGQ___9 = -3,
    SI_TIMER___9 = -2,
    SI_QUEUE___9 = -1,
    SI_USER___9 = 0,
    SI_KERNEL___9 = 128
} ;
enum __anonenum_640648963___9 {
    ILL_ILLOPC___9 = 1,
    ILL_ILLOPN___9 = 2,
    ILL_ILLADR___9 = 3,
    ILL_ILLTRP___9 = 4,
    ILL_PRVOPC___9 = 5,
    ILL_PRVREG___9 = 6,
    ILL_COPROC___9 = 7,
    ILL_BADSTK___9 = 8,
    ILL_BADIADDR___9 = 9
} ;
enum __anonenum_457704180___9 {
    FPE_INTDIV___9 = 1,
    FPE_INTOVF___9 = 2,
    FPE_FLTDIV___9 = 3,
    FPE_FLTOVF___9 = 4,
    FPE_FLTUND___9 = 5,
    FPE_FLTRES___9 = 6,
    FPE_FLTINV___9 = 7,
    FPE_FLTSUB___9 = 8,
    FPE_FLTUNK___9 = 14,
    FPE_CONDTRAP___9 = 15
} ;
enum __anonenum_180375148___9 {
    SEGV_MAPERR___9 = 1,
    SEGV_ACCERR___9 = 2,
    SEGV_BNDERR___9 = 3,
    SEGV_PKUERR___9 = 4,
    SEGV_ACCADI___9 = 5,
    SEGV_ADIDERR___9 = 6,
    SEGV_ADIPERR___9 = 7,
    SEGV_MTEAERR___9 = 8,
    SEGV_MTESERR___9 = 9
} ;
enum __anonenum_1036286214___9 {
    BUS_ADRALN___9 = 1,
    BUS_ADRERR___9 = 2,
    BUS_OBJERR___9 = 3,
    BUS_MCEERR_AR___9 = 4,
    BUS_MCEERR_AO___9 = 5
} ;
enum __anonenum_91015150___9 {
    TRAP_BRKPT___9 = 1,
    TRAP_TRACE___9 = 2,
    TRAP_BRANCH___9 = 3,
    TRAP_HWBKPT___9 = 4,
    TRAP_UNK___9 = 5
} ;
enum __anonenum_23175539___9 {
    CLD_EXITED___9 = 1,
    CLD_KILLED___9 = 2,
    CLD_DUMPED___9 = 3,
    CLD_TRAPPED___9 = 4,
    CLD_STOPPED___9 = 5,
    CLD_CONTINUED___9 = 6
} ;
enum __anonenum_111643124___9 {
    POLL_IN___9 = 1,
    POLL_OUT___9 = 2,
    POLL_MSG___9 = 3,
    POLL_ERR___9 = 4,
    POLL_PRI___9 = 5,
    POLL_HUP___9 = 6
} ;
enum __anonenum_852341087___9 {
    SIGEV_SIGNAL___9 = 0,
    SIGEV_NONE___9 = 1,
    SIGEV_THREAD___9 = 2,
    SIGEV_THREAD_ID___9 = 4
} ;
enum __anonenum_451154152___9 {
    REG_R8___9 = 0,
    REG_R9___9 = 1,
    REG_R10___9 = 2,
    REG_R11___9 = 3,
    REG_R12___9 = 4,
    REG_R13___9 = 5,
    REG_R14___9 = 6,
    REG_R15___9 = 7,
    REG_RDI___9 = 8,
    REG_RSI___9 = 9,
    REG_RBP___9 = 10,
    REG_RBX___9 = 11,
    REG_RDX___9 = 12,
    REG_RAX___9 = 13,
    REG_RCX___9 = 14,
    REG_RSP___9 = 15,
    REG_RIP___9 = 16,
    REG_EFL___9 = 17,
    REG_CSGSFS___9 = 18,
    REG_ERR___9 = 19,
    REG_TRAPNO___9 = 20,
    REG_OLDMASK___9 = 21,
    REG_CR2___9 = 22
} ;
enum __anonenum_437032235___9 {
    _PC_LINK_MAX___9 = 0,
    _PC_MAX_CANON___9 = 1,
    _PC_MAX_INPUT___9 = 2,
    _PC_NAME_MAX___9 = 3,
    _PC_PATH_MAX___9 = 4,
    _PC_PIPE_BUF___9 = 5,
    _PC_CHOWN_RESTRICTED___9 = 6,
    _PC_NO_TRUNC___9 = 7,
    _PC_VDISABLE___9 = 8,
    _PC_SYNC_IO___9 = 9,
    _PC_ASYNC_IO___9 = 10,
    _PC_PRIO_IO___9 = 11,
    _PC_SOCK_MAXBUF___9 = 12,
    _PC_FILESIZEBITS___9 = 13,
    _PC_REC_INCR_XFER_SIZE___9 = 14,
    _PC_REC_MAX_XFER_SIZE___9 = 15,
    _PC_REC_MIN_XFER_SIZE___9 = 16,
    _PC_REC_XFER_ALIGN___9 = 17,
    _PC_ALLOC_SIZE_MIN___9 = 18,
    _PC_SYMLINK_MAX___9 = 19,
    _PC_2_SYMLINKS___9 = 20
} ;
enum __anonenum_315186338___9 {
    _SC_ARG_MAX___9 = 0,
    _SC_CHILD_MAX___9 = 1,
    _SC_CLK_TCK___9 = 2,
    _SC_NGROUPS_MAX___9 = 3,
    _SC_OPEN_MAX___9 = 4,
    _SC_STREAM_MAX___9 = 5,
    _SC_TZNAME_MAX___9 = 6,
    _SC_JOB_CONTROL___9 = 7,
    _SC_SAVED_IDS___9 = 8,
    _SC_REALTIME_SIGNALS___9 = 9,
    _SC_PRIORITY_SCHEDULING___9 = 10,
    _SC_TIMERS___9 = 11,
    _SC_ASYNCHRONOUS_IO___9 = 12,
    _SC_PRIORITIZED_IO___9 = 13,
    _SC_SYNCHRONIZED_IO___9 = 14,
    _SC_FSYNC___9 = 15,
    _SC_MAPPED_FILES___9 = 16,
    _SC_MEMLOCK___9 = 17,
    _SC_MEMLOCK_RANGE___9 = 18,
    _SC_MEMORY_PROTECTION___9 = 19,
    _SC_MESSAGE_PASSING___9 = 20,
    _SC_SEMAPHORES___9 = 21,
    _SC_SHARED_MEMORY_OBJECTS___9 = 22,
    _SC_AIO_LISTIO_MAX___9 = 23,
    _SC_AIO_MAX___9 = 24,
    _SC_AIO_PRIO_DELTA_MAX___9 = 25,
    _SC_DELAYTIMER_MAX___9 = 26,
    _SC_MQ_OPEN_MAX___9 = 27,
    _SC_MQ_PRIO_MAX___9 = 28,
    _SC_VERSION___9 = 29,
    _SC_PAGESIZE___9 = 30,
    _SC_RTSIG_MAX___9 = 31,
    _SC_SEM_NSEMS_MAX___9 = 32,
    _SC_SEM_VALUE_MAX___9 = 33,
    _SC_SIGQUEUE_MAX___9 = 34,
    _SC_TIMER_MAX___9 = 35,
    _SC_BC_BASE_MAX___9 = 36,
    _SC_BC_DIM_MAX___9 = 37,
    _SC_BC_SCALE_MAX___9 = 38,
    _SC_BC_STRING_MAX___9 = 39,
    _SC_COLL_WEIGHTS_MAX___9 = 40,
    _SC_EQUIV_CLASS_MAX___9 = 41,
    _SC_EXPR_NEST_MAX___9 = 42,
    _SC_LINE_MAX___9 = 43,
    _SC_RE_DUP_MAX___9 = 44,
    _SC_CHARCLASS_NAME_MAX___9 = 45,
    _SC_2_VERSION___9 = 46,
    _SC_2_C_BIND___9 = 47,
    _SC_2_C_DEV___9 = 48,
    _SC_2_FORT_DEV___9 = 49,
    _SC_2_FORT_RUN___9 = 50,
    _SC_2_SW_DEV___9 = 51,
    _SC_2_LOCALEDEF___9 = 52,
    _SC_PII___9 = 53,
    _SC_PII_XTI___9 = 54,
    _SC_PII_SOCKET___9 = 55,
    _SC_PII_INTERNET___9 = 56,
    _SC_PII_OSI___9 = 57,
    _SC_POLL___9 = 58,
    _SC_SELECT___9 = 59,
    _SC_UIO_MAXIOV___9 = 60,
    _SC_IOV_MAX___9 = 60,
    _SC_PII_INTERNET_STREAM___9 = 61,
    _SC_PII_INTERNET_DGRAM___9 = 62,
    _SC_PII_OSI_COTS___9 = 63,
    _SC_PII_OSI_CLTS___9 = 64,
    _SC_PII_OSI_M___9 = 65,
    _SC_T_IOV_MAX___9 = 66,
    _SC_THREADS___9 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___9 = 68,
    _SC_GETGR_R_SIZE_MAX___9 = 69,
    _SC_GETPW_R_SIZE_MAX___9 = 70,
    _SC_LOGIN_NAME_MAX___9 = 71,
    _SC_TTY_NAME_MAX___9 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___9 = 73,
    _SC_THREAD_KEYS_MAX___9 = 74,
    _SC_THREAD_STACK_MIN___9 = 75,
    _SC_THREAD_THREADS_MAX___9 = 76,
    _SC_THREAD_ATTR_STACKADDR___9 = 77,
    _SC_THREAD_ATTR_STACKSIZE___9 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___9 = 79,
    _SC_THREAD_PRIO_INHERIT___9 = 80,
    _SC_THREAD_PRIO_PROTECT___9 = 81,
    _SC_THREAD_PROCESS_SHARED___9 = 82,
    _SC_NPROCESSORS_CONF___9 = 83,
    _SC_NPROCESSORS_ONLN___9 = 84,
    _SC_PHYS_PAGES___9 = 85,
    _SC_AVPHYS_PAGES___9 = 86,
    _SC_ATEXIT_MAX___9 = 87,
    _SC_PASS_MAX___9 = 88,
    _SC_XOPEN_VERSION___9 = 89,
    _SC_XOPEN_XCU_VERSION___9 = 90,
    _SC_XOPEN_UNIX___9 = 91,
    _SC_XOPEN_CRYPT___9 = 92,
    _SC_XOPEN_ENH_I18N___9 = 93,
    _SC_XOPEN_SHM___9 = 94,
    _SC_2_CHAR_TERM___9 = 95,
    _SC_2_C_VERSION___9 = 96,
    _SC_2_UPE___9 = 97,
    _SC_XOPEN_XPG2___9 = 98,
    _SC_XOPEN_XPG3___9 = 99,
    _SC_XOPEN_XPG4___9 = 100,
    _SC_CHAR_BIT___9 = 101,
    _SC_CHAR_MAX___9 = 102,
    _SC_CHAR_MIN___9 = 103,
    _SC_INT_MAX___9 = 104,
    _SC_INT_MIN___9 = 105,
    _SC_LONG_BIT___9 = 106,
    _SC_WORD_BIT___9 = 107,
    _SC_MB_LEN_MAX___9 = 108,
    _SC_NZERO___9 = 109,
    _SC_SSIZE_MAX___9 = 110,
    _SC_SCHAR_MAX___9 = 111,
    _SC_SCHAR_MIN___9 = 112,
    _SC_SHRT_MAX___9 = 113,
    _SC_SHRT_MIN___9 = 114,
    _SC_UCHAR_MAX___9 = 115,
    _SC_UINT_MAX___9 = 116,
    _SC_ULONG_MAX___9 = 117,
    _SC_USHRT_MAX___9 = 118,
    _SC_NL_ARGMAX___9 = 119,
    _SC_NL_LANGMAX___9 = 120,
    _SC_NL_MSGMAX___9 = 121,
    _SC_NL_NMAX___9 = 122,
    _SC_NL_SETMAX___9 = 123,
    _SC_NL_TEXTMAX___9 = 124,
    _SC_XBS5_ILP32_OFF32___9 = 125,
    _SC_XBS5_ILP32_OFFBIG___9 = 126,
    _SC_XBS5_LP64_OFF64___9 = 127,
    _SC_XBS5_LPBIG_OFFBIG___9 = 128,
    _SC_XOPEN_LEGACY___9 = 129,
    _SC_XOPEN_REALTIME___9 = 130,
    _SC_XOPEN_REALTIME_THREADS___9 = 131,
    _SC_ADVISORY_INFO___9 = 132,
    _SC_BARRIERS___9 = 133,
    _SC_BASE___9 = 134,
    _SC_C_LANG_SUPPORT___9 = 135,
    _SC_C_LANG_SUPPORT_R___9 = 136,
    _SC_CLOCK_SELECTION___9 = 137,
    _SC_CPUTIME___9 = 138,
    _SC_THREAD_CPUTIME___9 = 139,
    _SC_DEVICE_IO___9 = 140,
    _SC_DEVICE_SPECIFIC___9 = 141,
    _SC_DEVICE_SPECIFIC_R___9 = 142,
    _SC_FD_MGMT___9 = 143,
    _SC_FIFO___9 = 144,
    _SC_PIPE___9 = 145,
    _SC_FILE_ATTRIBUTES___9 = 146,
    _SC_FILE_LOCKING___9 = 147,
    _SC_FILE_SYSTEM___9 = 148,
    _SC_MONOTONIC_CLOCK___9 = 149,
    _SC_MULTI_PROCESS___9 = 150,
    _SC_SINGLE_PROCESS___9 = 151,
    _SC_NETWORKING___9 = 152,
    _SC_READER_WRITER_LOCKS___9 = 153,
    _SC_SPIN_LOCKS___9 = 154,
    _SC_REGEXP___9 = 155,
    _SC_REGEX_VERSION___9 = 156,
    _SC_SHELL___9 = 157,
    _SC_SIGNALS___9 = 158,
    _SC_SPAWN___9 = 159,
    _SC_SPORADIC_SERVER___9 = 160,
    _SC_THREAD_SPORADIC_SERVER___9 = 161,
    _SC_SYSTEM_DATABASE___9 = 162,
    _SC_SYSTEM_DATABASE_R___9 = 163,
    _SC_TIMEOUTS___9 = 164,
    _SC_TYPED_MEMORY_OBJECTS___9 = 165,
    _SC_USER_GROUPS___9 = 166,
    _SC_USER_GROUPS_R___9 = 167,
    _SC_2_PBS___9 = 168,
    _SC_2_PBS_ACCOUNTING___9 = 169,
    _SC_2_PBS_LOCATE___9 = 170,
    _SC_2_PBS_MESSAGE___9 = 171,
    _SC_2_PBS_TRACK___9 = 172,
    _SC_SYMLOOP_MAX___9 = 173,
    _SC_STREAMS___9 = 174,
    _SC_2_PBS_CHECKPOINT___9 = 175,
    _SC_V6_ILP32_OFF32___9 = 176,
    _SC_V6_ILP32_OFFBIG___9 = 177,
    _SC_V6_LP64_OFF64___9 = 178,
    _SC_V6_LPBIG_OFFBIG___9 = 179,
    _SC_HOST_NAME_MAX___9 = 180,
    _SC_TRACE___9 = 181,
    _SC_TRACE_EVENT_FILTER___9 = 182,
    _SC_TRACE_INHERIT___9 = 183,
    _SC_TRACE_LOG___9 = 184,
    _SC_LEVEL1_ICACHE_SIZE___9 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___9 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___9 = 187,
    _SC_LEVEL1_DCACHE_SIZE___9 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___9 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___9 = 190,
    _SC_LEVEL2_CACHE_SIZE___9 = 191,
    _SC_LEVEL2_CACHE_ASSOC___9 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___9 = 193,
    _SC_LEVEL3_CACHE_SIZE___9 = 194,
    _SC_LEVEL3_CACHE_ASSOC___9 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___9 = 196,
    _SC_LEVEL4_CACHE_SIZE___9 = 197,
    _SC_LEVEL4_CACHE_ASSOC___9 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___9 = 199,
    _SC_IPV6___9 = 235,
    _SC_RAW_SOCKETS___9 = 236,
    _SC_V7_ILP32_OFF32___9 = 237,
    _SC_V7_ILP32_OFFBIG___9 = 238,
    _SC_V7_LP64_OFF64___9 = 239,
    _SC_V7_LPBIG_OFFBIG___9 = 240,
    _SC_SS_REPL_MAX___9 = 241,
    _SC_TRACE_EVENT_NAME_MAX___9 = 242,
    _SC_TRACE_NAME_MAX___9 = 243,
    _SC_TRACE_SYS_MAX___9 = 244,
    _SC_TRACE_USER_EVENT_MAX___9 = 245,
    _SC_XOPEN_STREAMS___9 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___9 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___9 = 248,
    _SC_MINSIGSTKSZ___9 = 249,
    _SC_SIGSTKSZ___9 = 250
} ;
enum __anonenum_875524036___9 {
    _CS_PATH___9 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___9 = 1,
    _CS_GNU_LIBC_VERSION___9 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___9 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___9 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___9 = 5,
    _CS_LFS_CFLAGS___9 = 1000,
    _CS_LFS_LDFLAGS___9 = 1001,
    _CS_LFS_LIBS___9 = 1002,
    _CS_LFS_LINTFLAGS___9 = 1003,
    _CS_LFS64_CFLAGS___9 = 1004,
    _CS_LFS64_LDFLAGS___9 = 1005,
    _CS_LFS64_LIBS___9 = 1006,
    _CS_LFS64_LINTFLAGS___9 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___9 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___9 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___9 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___9 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___9 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___9 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___9 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___9 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___9 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___9 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___9 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___9 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___9 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___9 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___9 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___9 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___9 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___9 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___9 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___9 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___9 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___9 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___9 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___9 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___9 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___9 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___9 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___9 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___9 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___9 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___9 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___9 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___9 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___9 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___9 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___9 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___9 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___9 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___9 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___9 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___9 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___9 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___9 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___9 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___9 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___9 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___9 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___9 = 1147,
    _CS_V6_ENV___9 = 1148,
    _CS_V7_ENV___9 = 1149
} ;
enum __anonenum_57186863___9 {
    SS_ONSTACK___9 = 1,
    SS_DISABLE___9 = 2
} ;
struct SPF_Instance_Record ;
typedef struct SPF_Instance_Record *SPF_Instance;
struct SPF_Instance_Record {
   int min_samples ;
   int max_samples ;
   int index ;
   int used ;
   int last ;
   int avg_var_n ;
   double avg_var ;
   double max_var ;
   double combine_ratio ;
   NTP_Sample *samples ;
   int *selected ;
   double *x_data ;
   double *y_data ;
   double *w_data ;
};
enum __anonenum_83571709___10 {
    MSG_OOB___10 = 1,
    MSG_PEEK___10 = 2,
    MSG_DONTROUTE___10 = 4,
    MSG_TRYHARD___10 = 4,
    MSG_CTRUNC___10 = 8,
    MSG_PROXY___10 = 16,
    MSG_TRUNC___10 = 32,
    MSG_DONTWAIT___10 = 64,
    MSG_EOR___10 = 128,
    MSG_WAITALL___10 = 256,
    MSG_FIN___10 = 512,
    MSG_SYN___10 = 1024,
    MSG_CONFIRM___10 = 2048,
    MSG_RST___10 = 4096,
    MSG_ERRQUEUE___10 = 8192,
    MSG_NOSIGNAL___10 = 16384,
    MSG_MORE___10 = 32768,
    MSG_WAITFORONE___10 = 65536,
    MSG_BATCH___10 = 262144,
    MSG_ZEROCOPY___10 = 67108864,
    MSG_FASTOPEN___10 = 536870912,
    MSG_CMSG_CLOEXEC___10 = 1073741824
} ;
enum __anonenum_617082774___10 {
    SCM_RIGHTS___10 = 1,
    SCM_CREDENTIALS___10 = 2
} ;
enum __anonenum_606441560___10 {
    SHUT_RD___10 = 0,
    SHUT_WR___10 = 1,
    SHUT_RDWR___10 = 2
} ;
enum __anonenum_264779956___10 {
    IPPROTO_IP___10 = 0,
    IPPROTO_ICMP___10 = 1,
    IPPROTO_IGMP___10 = 2,
    IPPROTO_IPIP___10 = 4,
    IPPROTO_TCP___10 = 6,
    IPPROTO_EGP___10 = 8,
    IPPROTO_PUP___10 = 12,
    IPPROTO_UDP___10 = 17,
    IPPROTO_IDP___10 = 22,
    IPPROTO_TP___10 = 29,
    IPPROTO_DCCP___10 = 33,
    IPPROTO_IPV6___10 = 41,
    IPPROTO_RSVP___10 = 46,
    IPPROTO_GRE___10 = 47,
    IPPROTO_ESP___10 = 50,
    IPPROTO_AH___10 = 51,
    IPPROTO_MTP___10 = 92,
    IPPROTO_BEETPH___10 = 94,
    IPPROTO_ENCAP___10 = 98,
    IPPROTO_PIM___10 = 103,
    IPPROTO_COMP___10 = 108,
    IPPROTO_SCTP___10 = 132,
    IPPROTO_UDPLITE___10 = 136,
    IPPROTO_MPLS___10 = 137,
    IPPROTO_ETHERNET___10 = 143,
    IPPROTO_RAW___10 = 255,
    IPPROTO_MPTCP___10 = 262,
    IPPROTO_MAX___10 = 263
} ;
enum __anonenum_218739988___10 {
    IPPROTO_HOPOPTS___10 = 0,
    IPPROTO_ROUTING___10 = 43,
    IPPROTO_FRAGMENT___10 = 44,
    IPPROTO_ICMPV6___10 = 58,
    IPPROTO_NONE___10 = 59,
    IPPROTO_DSTOPTS___10 = 60,
    IPPROTO_MH___10 = 135
} ;
enum __anonenum_662268580___10 {
    IPPORT_ECHO___10 = 7,
    IPPORT_DISCARD___10 = 9,
    IPPORT_SYSTAT___10 = 11,
    IPPORT_DAYTIME___10 = 13,
    IPPORT_NETSTAT___10 = 15,
    IPPORT_FTP___10 = 21,
    IPPORT_TELNET___10 = 23,
    IPPORT_SMTP___10 = 25,
    IPPORT_TIMESERVER___10 = 37,
    IPPORT_NAMESERVER___10 = 42,
    IPPORT_WHOIS___10 = 43,
    IPPORT_MTP___10 = 57,
    IPPORT_TFTP___10 = 69,
    IPPORT_RJE___10 = 77,
    IPPORT_FINGER___10 = 79,
    IPPORT_TTYLINK___10 = 87,
    IPPORT_SUPDUP___10 = 95,
    IPPORT_EXECSERVER___10 = 512,
    IPPORT_LOGINSERVER___10 = 513,
    IPPORT_CMDSERVER___10 = 514,
    IPPORT_EFSSERVER___10 = 520,
    IPPORT_BIFFUDP___10 = 512,
    IPPORT_WHOSERVER___10 = 513,
    IPPORT_ROUTESERVER___10 = 520,
    IPPORT_RESERVED___10 = 1024,
    IPPORT_USERRESERVED___10 = 5000
} ;
enum __anonenum_18926444___10 {
    _ISupper___10 = 256,
    _ISlower___10 = 512,
    _ISalpha___10 = 1024,
    _ISdigit___10 = 2048,
    _ISxdigit___10 = 4096,
    _ISspace___10 = 8192,
    _ISprint___10 = 16384,
    _ISgraph___10 = 32768,
    _ISblank___10 = 1,
    _IScntrl___10 = 2,
    _ISpunct___10 = 4,
    _ISalnum___10 = 8
} ;
enum __anonenum_913965969___10 {
    FP_INT_UPWARD___10 = 0,
    FP_INT_DOWNWARD___10 = 1,
    FP_INT_TOWARDZERO___10 = 2,
    FP_INT_TONEARESTFROMZERO___10 = 3,
    FP_INT_TONEAREST___10 = 4
} ;
enum __anonenum_1037408945___10 {
    FP_NAN___10 = 0,
    FP_INFINITE___10 = 1,
    FP_ZERO___10 = 2,
    FP_SUBNORMAL___10 = 3,
    FP_NORMAL___10 = 4
} ;
enum __anonenum_556971655___10 {
    SI_ASYNCNL___10 = -60,
    SI_DETHREAD___10 = -7,
    SI_TKILL___10 = -6,
    SI_SIGIO___10 = -5,
    SI_ASYNCIO___10 = -4,
    SI_MESGQ___10 = -3,
    SI_TIMER___10 = -2,
    SI_QUEUE___10 = -1,
    SI_USER___10 = 0,
    SI_KERNEL___10 = 128
} ;
enum __anonenum_640648963___10 {
    ILL_ILLOPC___10 = 1,
    ILL_ILLOPN___10 = 2,
    ILL_ILLADR___10 = 3,
    ILL_ILLTRP___10 = 4,
    ILL_PRVOPC___10 = 5,
    ILL_PRVREG___10 = 6,
    ILL_COPROC___10 = 7,
    ILL_BADSTK___10 = 8,
    ILL_BADIADDR___10 = 9
} ;
enum __anonenum_457704180___10 {
    FPE_INTDIV___10 = 1,
    FPE_INTOVF___10 = 2,
    FPE_FLTDIV___10 = 3,
    FPE_FLTOVF___10 = 4,
    FPE_FLTUND___10 = 5,
    FPE_FLTRES___10 = 6,
    FPE_FLTINV___10 = 7,
    FPE_FLTSUB___10 = 8,
    FPE_FLTUNK___10 = 14,
    FPE_CONDTRAP___10 = 15
} ;
enum __anonenum_180375148___10 {
    SEGV_MAPERR___10 = 1,
    SEGV_ACCERR___10 = 2,
    SEGV_BNDERR___10 = 3,
    SEGV_PKUERR___10 = 4,
    SEGV_ACCADI___10 = 5,
    SEGV_ADIDERR___10 = 6,
    SEGV_ADIPERR___10 = 7,
    SEGV_MTEAERR___10 = 8,
    SEGV_MTESERR___10 = 9
} ;
enum __anonenum_1036286214___10 {
    BUS_ADRALN___10 = 1,
    BUS_ADRERR___10 = 2,
    BUS_OBJERR___10 = 3,
    BUS_MCEERR_AR___10 = 4,
    BUS_MCEERR_AO___10 = 5
} ;
enum __anonenum_91015150___10 {
    TRAP_BRKPT___10 = 1,
    TRAP_TRACE___10 = 2,
    TRAP_BRANCH___10 = 3,
    TRAP_HWBKPT___10 = 4,
    TRAP_UNK___10 = 5
} ;
enum __anonenum_23175539___10 {
    CLD_EXITED___10 = 1,
    CLD_KILLED___10 = 2,
    CLD_DUMPED___10 = 3,
    CLD_TRAPPED___10 = 4,
    CLD_STOPPED___10 = 5,
    CLD_CONTINUED___10 = 6
} ;
enum __anonenum_111643124___10 {
    POLL_IN___10 = 1,
    POLL_OUT___10 = 2,
    POLL_MSG___10 = 3,
    POLL_ERR___10 = 4,
    POLL_PRI___10 = 5,
    POLL_HUP___10 = 6
} ;
enum __anonenum_852341087___10 {
    SIGEV_SIGNAL___10 = 0,
    SIGEV_NONE___10 = 1,
    SIGEV_THREAD___10 = 2,
    SIGEV_THREAD_ID___10 = 4
} ;
enum __anonenum_451154152___10 {
    REG_R8___10 = 0,
    REG_R9___10 = 1,
    REG_R10___10 = 2,
    REG_R11___10 = 3,
    REG_R12___10 = 4,
    REG_R13___10 = 5,
    REG_R14___10 = 6,
    REG_R15___10 = 7,
    REG_RDI___10 = 8,
    REG_RSI___10 = 9,
    REG_RBP___10 = 10,
    REG_RBX___10 = 11,
    REG_RDX___10 = 12,
    REG_RAX___10 = 13,
    REG_RCX___10 = 14,
    REG_RSP___10 = 15,
    REG_RIP___10 = 16,
    REG_EFL___10 = 17,
    REG_CSGSFS___10 = 18,
    REG_ERR___10 = 19,
    REG_TRAPNO___10 = 20,
    REG_OLDMASK___10 = 21,
    REG_CR2___10 = 22
} ;
enum __anonenum_437032235___10 {
    _PC_LINK_MAX___10 = 0,
    _PC_MAX_CANON___10 = 1,
    _PC_MAX_INPUT___10 = 2,
    _PC_NAME_MAX___10 = 3,
    _PC_PATH_MAX___10 = 4,
    _PC_PIPE_BUF___10 = 5,
    _PC_CHOWN_RESTRICTED___10 = 6,
    _PC_NO_TRUNC___10 = 7,
    _PC_VDISABLE___10 = 8,
    _PC_SYNC_IO___10 = 9,
    _PC_ASYNC_IO___10 = 10,
    _PC_PRIO_IO___10 = 11,
    _PC_SOCK_MAXBUF___10 = 12,
    _PC_FILESIZEBITS___10 = 13,
    _PC_REC_INCR_XFER_SIZE___10 = 14,
    _PC_REC_MAX_XFER_SIZE___10 = 15,
    _PC_REC_MIN_XFER_SIZE___10 = 16,
    _PC_REC_XFER_ALIGN___10 = 17,
    _PC_ALLOC_SIZE_MIN___10 = 18,
    _PC_SYMLINK_MAX___10 = 19,
    _PC_2_SYMLINKS___10 = 20
} ;
enum __anonenum_315186338___10 {
    _SC_ARG_MAX___10 = 0,
    _SC_CHILD_MAX___10 = 1,
    _SC_CLK_TCK___10 = 2,
    _SC_NGROUPS_MAX___10 = 3,
    _SC_OPEN_MAX___10 = 4,
    _SC_STREAM_MAX___10 = 5,
    _SC_TZNAME_MAX___10 = 6,
    _SC_JOB_CONTROL___10 = 7,
    _SC_SAVED_IDS___10 = 8,
    _SC_REALTIME_SIGNALS___10 = 9,
    _SC_PRIORITY_SCHEDULING___10 = 10,
    _SC_TIMERS___10 = 11,
    _SC_ASYNCHRONOUS_IO___10 = 12,
    _SC_PRIORITIZED_IO___10 = 13,
    _SC_SYNCHRONIZED_IO___10 = 14,
    _SC_FSYNC___10 = 15,
    _SC_MAPPED_FILES___10 = 16,
    _SC_MEMLOCK___10 = 17,
    _SC_MEMLOCK_RANGE___10 = 18,
    _SC_MEMORY_PROTECTION___10 = 19,
    _SC_MESSAGE_PASSING___10 = 20,
    _SC_SEMAPHORES___10 = 21,
    _SC_SHARED_MEMORY_OBJECTS___10 = 22,
    _SC_AIO_LISTIO_MAX___10 = 23,
    _SC_AIO_MAX___10 = 24,
    _SC_AIO_PRIO_DELTA_MAX___10 = 25,
    _SC_DELAYTIMER_MAX___10 = 26,
    _SC_MQ_OPEN_MAX___10 = 27,
    _SC_MQ_PRIO_MAX___10 = 28,
    _SC_VERSION___10 = 29,
    _SC_PAGESIZE___10 = 30,
    _SC_RTSIG_MAX___10 = 31,
    _SC_SEM_NSEMS_MAX___10 = 32,
    _SC_SEM_VALUE_MAX___10 = 33,
    _SC_SIGQUEUE_MAX___10 = 34,
    _SC_TIMER_MAX___10 = 35,
    _SC_BC_BASE_MAX___10 = 36,
    _SC_BC_DIM_MAX___10 = 37,
    _SC_BC_SCALE_MAX___10 = 38,
    _SC_BC_STRING_MAX___10 = 39,
    _SC_COLL_WEIGHTS_MAX___10 = 40,
    _SC_EQUIV_CLASS_MAX___10 = 41,
    _SC_EXPR_NEST_MAX___10 = 42,
    _SC_LINE_MAX___10 = 43,
    _SC_RE_DUP_MAX___10 = 44,
    _SC_CHARCLASS_NAME_MAX___10 = 45,
    _SC_2_VERSION___10 = 46,
    _SC_2_C_BIND___10 = 47,
    _SC_2_C_DEV___10 = 48,
    _SC_2_FORT_DEV___10 = 49,
    _SC_2_FORT_RUN___10 = 50,
    _SC_2_SW_DEV___10 = 51,
    _SC_2_LOCALEDEF___10 = 52,
    _SC_PII___10 = 53,
    _SC_PII_XTI___10 = 54,
    _SC_PII_SOCKET___10 = 55,
    _SC_PII_INTERNET___10 = 56,
    _SC_PII_OSI___10 = 57,
    _SC_POLL___10 = 58,
    _SC_SELECT___10 = 59,
    _SC_UIO_MAXIOV___10 = 60,
    _SC_IOV_MAX___10 = 60,
    _SC_PII_INTERNET_STREAM___10 = 61,
    _SC_PII_INTERNET_DGRAM___10 = 62,
    _SC_PII_OSI_COTS___10 = 63,
    _SC_PII_OSI_CLTS___10 = 64,
    _SC_PII_OSI_M___10 = 65,
    _SC_T_IOV_MAX___10 = 66,
    _SC_THREADS___10 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___10 = 68,
    _SC_GETGR_R_SIZE_MAX___10 = 69,
    _SC_GETPW_R_SIZE_MAX___10 = 70,
    _SC_LOGIN_NAME_MAX___10 = 71,
    _SC_TTY_NAME_MAX___10 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___10 = 73,
    _SC_THREAD_KEYS_MAX___10 = 74,
    _SC_THREAD_STACK_MIN___10 = 75,
    _SC_THREAD_THREADS_MAX___10 = 76,
    _SC_THREAD_ATTR_STACKADDR___10 = 77,
    _SC_THREAD_ATTR_STACKSIZE___10 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___10 = 79,
    _SC_THREAD_PRIO_INHERIT___10 = 80,
    _SC_THREAD_PRIO_PROTECT___10 = 81,
    _SC_THREAD_PROCESS_SHARED___10 = 82,
    _SC_NPROCESSORS_CONF___10 = 83,
    _SC_NPROCESSORS_ONLN___10 = 84,
    _SC_PHYS_PAGES___10 = 85,
    _SC_AVPHYS_PAGES___10 = 86,
    _SC_ATEXIT_MAX___10 = 87,
    _SC_PASS_MAX___10 = 88,
    _SC_XOPEN_VERSION___10 = 89,
    _SC_XOPEN_XCU_VERSION___10 = 90,
    _SC_XOPEN_UNIX___10 = 91,
    _SC_XOPEN_CRYPT___10 = 92,
    _SC_XOPEN_ENH_I18N___10 = 93,
    _SC_XOPEN_SHM___10 = 94,
    _SC_2_CHAR_TERM___10 = 95,
    _SC_2_C_VERSION___10 = 96,
    _SC_2_UPE___10 = 97,
    _SC_XOPEN_XPG2___10 = 98,
    _SC_XOPEN_XPG3___10 = 99,
    _SC_XOPEN_XPG4___10 = 100,
    _SC_CHAR_BIT___10 = 101,
    _SC_CHAR_MAX___10 = 102,
    _SC_CHAR_MIN___10 = 103,
    _SC_INT_MAX___10 = 104,
    _SC_INT_MIN___10 = 105,
    _SC_LONG_BIT___10 = 106,
    _SC_WORD_BIT___10 = 107,
    _SC_MB_LEN_MAX___10 = 108,
    _SC_NZERO___10 = 109,
    _SC_SSIZE_MAX___10 = 110,
    _SC_SCHAR_MAX___10 = 111,
    _SC_SCHAR_MIN___10 = 112,
    _SC_SHRT_MAX___10 = 113,
    _SC_SHRT_MIN___10 = 114,
    _SC_UCHAR_MAX___10 = 115,
    _SC_UINT_MAX___10 = 116,
    _SC_ULONG_MAX___10 = 117,
    _SC_USHRT_MAX___10 = 118,
    _SC_NL_ARGMAX___10 = 119,
    _SC_NL_LANGMAX___10 = 120,
    _SC_NL_MSGMAX___10 = 121,
    _SC_NL_NMAX___10 = 122,
    _SC_NL_SETMAX___10 = 123,
    _SC_NL_TEXTMAX___10 = 124,
    _SC_XBS5_ILP32_OFF32___10 = 125,
    _SC_XBS5_ILP32_OFFBIG___10 = 126,
    _SC_XBS5_LP64_OFF64___10 = 127,
    _SC_XBS5_LPBIG_OFFBIG___10 = 128,
    _SC_XOPEN_LEGACY___10 = 129,
    _SC_XOPEN_REALTIME___10 = 130,
    _SC_XOPEN_REALTIME_THREADS___10 = 131,
    _SC_ADVISORY_INFO___10 = 132,
    _SC_BARRIERS___10 = 133,
    _SC_BASE___10 = 134,
    _SC_C_LANG_SUPPORT___10 = 135,
    _SC_C_LANG_SUPPORT_R___10 = 136,
    _SC_CLOCK_SELECTION___10 = 137,
    _SC_CPUTIME___10 = 138,
    _SC_THREAD_CPUTIME___10 = 139,
    _SC_DEVICE_IO___10 = 140,
    _SC_DEVICE_SPECIFIC___10 = 141,
    _SC_DEVICE_SPECIFIC_R___10 = 142,
    _SC_FD_MGMT___10 = 143,
    _SC_FIFO___10 = 144,
    _SC_PIPE___10 = 145,
    _SC_FILE_ATTRIBUTES___10 = 146,
    _SC_FILE_LOCKING___10 = 147,
    _SC_FILE_SYSTEM___10 = 148,
    _SC_MONOTONIC_CLOCK___10 = 149,
    _SC_MULTI_PROCESS___10 = 150,
    _SC_SINGLE_PROCESS___10 = 151,
    _SC_NETWORKING___10 = 152,
    _SC_READER_WRITER_LOCKS___10 = 153,
    _SC_SPIN_LOCKS___10 = 154,
    _SC_REGEXP___10 = 155,
    _SC_REGEX_VERSION___10 = 156,
    _SC_SHELL___10 = 157,
    _SC_SIGNALS___10 = 158,
    _SC_SPAWN___10 = 159,
    _SC_SPORADIC_SERVER___10 = 160,
    _SC_THREAD_SPORADIC_SERVER___10 = 161,
    _SC_SYSTEM_DATABASE___10 = 162,
    _SC_SYSTEM_DATABASE_R___10 = 163,
    _SC_TIMEOUTS___10 = 164,
    _SC_TYPED_MEMORY_OBJECTS___10 = 165,
    _SC_USER_GROUPS___10 = 166,
    _SC_USER_GROUPS_R___10 = 167,
    _SC_2_PBS___10 = 168,
    _SC_2_PBS_ACCOUNTING___10 = 169,
    _SC_2_PBS_LOCATE___10 = 170,
    _SC_2_PBS_MESSAGE___10 = 171,
    _SC_2_PBS_TRACK___10 = 172,
    _SC_SYMLOOP_MAX___10 = 173,
    _SC_STREAMS___10 = 174,
    _SC_2_PBS_CHECKPOINT___10 = 175,
    _SC_V6_ILP32_OFF32___10 = 176,
    _SC_V6_ILP32_OFFBIG___10 = 177,
    _SC_V6_LP64_OFF64___10 = 178,
    _SC_V6_LPBIG_OFFBIG___10 = 179,
    _SC_HOST_NAME_MAX___10 = 180,
    _SC_TRACE___10 = 181,
    _SC_TRACE_EVENT_FILTER___10 = 182,
    _SC_TRACE_INHERIT___10 = 183,
    _SC_TRACE_LOG___10 = 184,
    _SC_LEVEL1_ICACHE_SIZE___10 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___10 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___10 = 187,
    _SC_LEVEL1_DCACHE_SIZE___10 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___10 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___10 = 190,
    _SC_LEVEL2_CACHE_SIZE___10 = 191,
    _SC_LEVEL2_CACHE_ASSOC___10 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___10 = 193,
    _SC_LEVEL3_CACHE_SIZE___10 = 194,
    _SC_LEVEL3_CACHE_ASSOC___10 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___10 = 196,
    _SC_LEVEL4_CACHE_SIZE___10 = 197,
    _SC_LEVEL4_CACHE_ASSOC___10 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___10 = 199,
    _SC_IPV6___10 = 235,
    _SC_RAW_SOCKETS___10 = 236,
    _SC_V7_ILP32_OFF32___10 = 237,
    _SC_V7_ILP32_OFFBIG___10 = 238,
    _SC_V7_LP64_OFF64___10 = 239,
    _SC_V7_LPBIG_OFFBIG___10 = 240,
    _SC_SS_REPL_MAX___10 = 241,
    _SC_TRACE_EVENT_NAME_MAX___10 = 242,
    _SC_TRACE_NAME_MAX___10 = 243,
    _SC_TRACE_SYS_MAX___10 = 244,
    _SC_TRACE_USER_EVENT_MAX___10 = 245,
    _SC_XOPEN_STREAMS___10 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___10 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___10 = 248,
    _SC_MINSIGSTKSZ___10 = 249,
    _SC_SIGSTKSZ___10 = 250
} ;
enum __anonenum_875524036___10 {
    _CS_PATH___10 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___10 = 1,
    _CS_GNU_LIBC_VERSION___10 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___10 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___10 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___10 = 5,
    _CS_LFS_CFLAGS___10 = 1000,
    _CS_LFS_LDFLAGS___10 = 1001,
    _CS_LFS_LIBS___10 = 1002,
    _CS_LFS_LINTFLAGS___10 = 1003,
    _CS_LFS64_CFLAGS___10 = 1004,
    _CS_LFS64_LDFLAGS___10 = 1005,
    _CS_LFS64_LIBS___10 = 1006,
    _CS_LFS64_LINTFLAGS___10 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___10 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___10 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___10 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___10 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___10 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___10 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___10 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___10 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___10 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___10 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___10 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___10 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___10 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___10 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___10 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___10 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___10 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___10 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___10 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___10 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___10 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___10 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___10 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___10 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___10 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___10 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___10 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___10 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___10 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___10 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___10 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___10 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___10 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___10 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___10 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___10 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___10 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___10 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___10 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___10 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___10 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___10 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___10 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___10 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___10 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___10 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___10 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___10 = 1147,
    _CS_V6_ENV___10 = 1148,
    _CS_V7_ENV___10 = 1149
} ;
enum __anonenum_57186863___10 {
    SS_ONSTACK___10 = 1,
    SS_DISABLE___10 = 2
} ;
struct __anonstruct_FileHandlerEntry_364721617 {
   void (*handler)(int fd , int event , SCH_ArbitraryArgument ) ;
   SCH_ArbitraryArgument arg ;
   int events ;
};
typedef struct __anonstruct_FileHandlerEntry_364721617 FileHandlerEntry;
struct _TimerQueueEntry {
   struct _TimerQueueEntry *next ;
   struct _TimerQueueEntry *prev ;
   struct timespec ts ;
   SCH_TimeoutID id ;
   SCH_TimeoutClass class ;
   void (*handler)(SCH_ArbitraryArgument ) ;
   SCH_ArbitraryArgument arg ;
};
typedef struct _TimerQueueEntry TimerQueueEntry;
enum __anonenum_83571709___11 {
    MSG_OOB___11 = 1,
    MSG_PEEK___11 = 2,
    MSG_DONTROUTE___11 = 4,
    MSG_TRYHARD___11 = 4,
    MSG_CTRUNC___11 = 8,
    MSG_PROXY___11 = 16,
    MSG_TRUNC___11 = 32,
    MSG_DONTWAIT___11 = 64,
    MSG_EOR___11 = 128,
    MSG_WAITALL___11 = 256,
    MSG_FIN___11 = 512,
    MSG_SYN___11 = 1024,
    MSG_CONFIRM___11 = 2048,
    MSG_RST___11 = 4096,
    MSG_ERRQUEUE___11 = 8192,
    MSG_NOSIGNAL___11 = 16384,
    MSG_MORE___11 = 32768,
    MSG_WAITFORONE___11 = 65536,
    MSG_BATCH___11 = 262144,
    MSG_ZEROCOPY___11 = 67108864,
    MSG_FASTOPEN___11 = 536870912,
    MSG_CMSG_CLOEXEC___11 = 1073741824
} ;
enum __anonenum_617082774___11 {
    SCM_RIGHTS___11 = 1,
    SCM_CREDENTIALS___11 = 2
} ;
enum __anonenum_606441560___11 {
    SHUT_RD___11 = 0,
    SHUT_WR___11 = 1,
    SHUT_RDWR___11 = 2
} ;
enum __anonenum_264779956___11 {
    IPPROTO_IP___11 = 0,
    IPPROTO_ICMP___11 = 1,
    IPPROTO_IGMP___11 = 2,
    IPPROTO_IPIP___11 = 4,
    IPPROTO_TCP___11 = 6,
    IPPROTO_EGP___11 = 8,
    IPPROTO_PUP___11 = 12,
    IPPROTO_UDP___11 = 17,
    IPPROTO_IDP___11 = 22,
    IPPROTO_TP___11 = 29,
    IPPROTO_DCCP___11 = 33,
    IPPROTO_IPV6___11 = 41,
    IPPROTO_RSVP___11 = 46,
    IPPROTO_GRE___11 = 47,
    IPPROTO_ESP___11 = 50,
    IPPROTO_AH___11 = 51,
    IPPROTO_MTP___11 = 92,
    IPPROTO_BEETPH___11 = 94,
    IPPROTO_ENCAP___11 = 98,
    IPPROTO_PIM___11 = 103,
    IPPROTO_COMP___11 = 108,
    IPPROTO_SCTP___11 = 132,
    IPPROTO_UDPLITE___11 = 136,
    IPPROTO_MPLS___11 = 137,
    IPPROTO_ETHERNET___11 = 143,
    IPPROTO_RAW___11 = 255,
    IPPROTO_MPTCP___11 = 262,
    IPPROTO_MAX___11 = 263
} ;
enum __anonenum_218739988___11 {
    IPPROTO_HOPOPTS___11 = 0,
    IPPROTO_ROUTING___11 = 43,
    IPPROTO_FRAGMENT___11 = 44,
    IPPROTO_ICMPV6___11 = 58,
    IPPROTO_NONE___11 = 59,
    IPPROTO_DSTOPTS___11 = 60,
    IPPROTO_MH___11 = 135
} ;
enum __anonenum_662268580___11 {
    IPPORT_ECHO___11 = 7,
    IPPORT_DISCARD___11 = 9,
    IPPORT_SYSTAT___11 = 11,
    IPPORT_DAYTIME___11 = 13,
    IPPORT_NETSTAT___11 = 15,
    IPPORT_FTP___11 = 21,
    IPPORT_TELNET___11 = 23,
    IPPORT_SMTP___11 = 25,
    IPPORT_TIMESERVER___11 = 37,
    IPPORT_NAMESERVER___11 = 42,
    IPPORT_WHOIS___11 = 43,
    IPPORT_MTP___11 = 57,
    IPPORT_TFTP___11 = 69,
    IPPORT_RJE___11 = 77,
    IPPORT_FINGER___11 = 79,
    IPPORT_TTYLINK___11 = 87,
    IPPORT_SUPDUP___11 = 95,
    IPPORT_EXECSERVER___11 = 512,
    IPPORT_LOGINSERVER___11 = 513,
    IPPORT_CMDSERVER___11 = 514,
    IPPORT_EFSSERVER___11 = 520,
    IPPORT_BIFFUDP___11 = 512,
    IPPORT_WHOSERVER___11 = 513,
    IPPORT_ROUTESERVER___11 = 520,
    IPPORT_RESERVED___11 = 1024,
    IPPORT_USERRESERVED___11 = 5000
} ;
enum __anonenum_18926444___11 {
    _ISupper___11 = 256,
    _ISlower___11 = 512,
    _ISalpha___11 = 1024,
    _ISdigit___11 = 2048,
    _ISxdigit___11 = 4096,
    _ISspace___11 = 8192,
    _ISprint___11 = 16384,
    _ISgraph___11 = 32768,
    _ISblank___11 = 1,
    _IScntrl___11 = 2,
    _ISpunct___11 = 4,
    _ISalnum___11 = 8
} ;
enum __anonenum_913965969___11 {
    FP_INT_UPWARD___11 = 0,
    FP_INT_DOWNWARD___11 = 1,
    FP_INT_TOWARDZERO___11 = 2,
    FP_INT_TONEARESTFROMZERO___11 = 3,
    FP_INT_TONEAREST___11 = 4
} ;
enum __anonenum_1037408945___11 {
    FP_NAN___11 = 0,
    FP_INFINITE___11 = 1,
    FP_ZERO___11 = 2,
    FP_SUBNORMAL___11 = 3,
    FP_NORMAL___11 = 4
} ;
enum __anonenum_556971655___11 {
    SI_ASYNCNL___11 = -60,
    SI_DETHREAD___11 = -7,
    SI_TKILL___11 = -6,
    SI_SIGIO___11 = -5,
    SI_ASYNCIO___11 = -4,
    SI_MESGQ___11 = -3,
    SI_TIMER___11 = -2,
    SI_QUEUE___11 = -1,
    SI_USER___11 = 0,
    SI_KERNEL___11 = 128
} ;
enum __anonenum_640648963___11 {
    ILL_ILLOPC___11 = 1,
    ILL_ILLOPN___11 = 2,
    ILL_ILLADR___11 = 3,
    ILL_ILLTRP___11 = 4,
    ILL_PRVOPC___11 = 5,
    ILL_PRVREG___11 = 6,
    ILL_COPROC___11 = 7,
    ILL_BADSTK___11 = 8,
    ILL_BADIADDR___11 = 9
} ;
enum __anonenum_457704180___11 {
    FPE_INTDIV___11 = 1,
    FPE_INTOVF___11 = 2,
    FPE_FLTDIV___11 = 3,
    FPE_FLTOVF___11 = 4,
    FPE_FLTUND___11 = 5,
    FPE_FLTRES___11 = 6,
    FPE_FLTINV___11 = 7,
    FPE_FLTSUB___11 = 8,
    FPE_FLTUNK___11 = 14,
    FPE_CONDTRAP___11 = 15
} ;
enum __anonenum_180375148___11 {
    SEGV_MAPERR___11 = 1,
    SEGV_ACCERR___11 = 2,
    SEGV_BNDERR___11 = 3,
    SEGV_PKUERR___11 = 4,
    SEGV_ACCADI___11 = 5,
    SEGV_ADIDERR___11 = 6,
    SEGV_ADIPERR___11 = 7,
    SEGV_MTEAERR___11 = 8,
    SEGV_MTESERR___11 = 9
} ;
enum __anonenum_1036286214___11 {
    BUS_ADRALN___11 = 1,
    BUS_ADRERR___11 = 2,
    BUS_OBJERR___11 = 3,
    BUS_MCEERR_AR___11 = 4,
    BUS_MCEERR_AO___11 = 5
} ;
enum __anonenum_91015150___11 {
    TRAP_BRKPT___11 = 1,
    TRAP_TRACE___11 = 2,
    TRAP_BRANCH___11 = 3,
    TRAP_HWBKPT___11 = 4,
    TRAP_UNK___11 = 5
} ;
enum __anonenum_23175539___11 {
    CLD_EXITED___11 = 1,
    CLD_KILLED___11 = 2,
    CLD_DUMPED___11 = 3,
    CLD_TRAPPED___11 = 4,
    CLD_STOPPED___11 = 5,
    CLD_CONTINUED___11 = 6
} ;
enum __anonenum_111643124___11 {
    POLL_IN___11 = 1,
    POLL_OUT___11 = 2,
    POLL_MSG___11 = 3,
    POLL_ERR___11 = 4,
    POLL_PRI___11 = 5,
    POLL_HUP___11 = 6
} ;
enum __anonenum_852341087___11 {
    SIGEV_SIGNAL___11 = 0,
    SIGEV_NONE___11 = 1,
    SIGEV_THREAD___11 = 2,
    SIGEV_THREAD_ID___11 = 4
} ;
enum __anonenum_451154152___11 {
    REG_R8___11 = 0,
    REG_R9___11 = 1,
    REG_R10___11 = 2,
    REG_R11___11 = 3,
    REG_R12___11 = 4,
    REG_R13___11 = 5,
    REG_R14___11 = 6,
    REG_R15___11 = 7,
    REG_RDI___11 = 8,
    REG_RSI___11 = 9,
    REG_RBP___11 = 10,
    REG_RBX___11 = 11,
    REG_RDX___11 = 12,
    REG_RAX___11 = 13,
    REG_RCX___11 = 14,
    REG_RSP___11 = 15,
    REG_RIP___11 = 16,
    REG_EFL___11 = 17,
    REG_CSGSFS___11 = 18,
    REG_ERR___11 = 19,
    REG_TRAPNO___11 = 20,
    REG_OLDMASK___11 = 21,
    REG_CR2___11 = 22
} ;
enum __anonenum_437032235___11 {
    _PC_LINK_MAX___11 = 0,
    _PC_MAX_CANON___11 = 1,
    _PC_MAX_INPUT___11 = 2,
    _PC_NAME_MAX___11 = 3,
    _PC_PATH_MAX___11 = 4,
    _PC_PIPE_BUF___11 = 5,
    _PC_CHOWN_RESTRICTED___11 = 6,
    _PC_NO_TRUNC___11 = 7,
    _PC_VDISABLE___11 = 8,
    _PC_SYNC_IO___11 = 9,
    _PC_ASYNC_IO___11 = 10,
    _PC_PRIO_IO___11 = 11,
    _PC_SOCK_MAXBUF___11 = 12,
    _PC_FILESIZEBITS___11 = 13,
    _PC_REC_INCR_XFER_SIZE___11 = 14,
    _PC_REC_MAX_XFER_SIZE___11 = 15,
    _PC_REC_MIN_XFER_SIZE___11 = 16,
    _PC_REC_XFER_ALIGN___11 = 17,
    _PC_ALLOC_SIZE_MIN___11 = 18,
    _PC_SYMLINK_MAX___11 = 19,
    _PC_2_SYMLINKS___11 = 20
} ;
enum __anonenum_315186338___11 {
    _SC_ARG_MAX___11 = 0,
    _SC_CHILD_MAX___11 = 1,
    _SC_CLK_TCK___11 = 2,
    _SC_NGROUPS_MAX___11 = 3,
    _SC_OPEN_MAX___11 = 4,
    _SC_STREAM_MAX___11 = 5,
    _SC_TZNAME_MAX___11 = 6,
    _SC_JOB_CONTROL___11 = 7,
    _SC_SAVED_IDS___11 = 8,
    _SC_REALTIME_SIGNALS___11 = 9,
    _SC_PRIORITY_SCHEDULING___11 = 10,
    _SC_TIMERS___11 = 11,
    _SC_ASYNCHRONOUS_IO___11 = 12,
    _SC_PRIORITIZED_IO___11 = 13,
    _SC_SYNCHRONIZED_IO___11 = 14,
    _SC_FSYNC___11 = 15,
    _SC_MAPPED_FILES___11 = 16,
    _SC_MEMLOCK___11 = 17,
    _SC_MEMLOCK_RANGE___11 = 18,
    _SC_MEMORY_PROTECTION___11 = 19,
    _SC_MESSAGE_PASSING___11 = 20,
    _SC_SEMAPHORES___11 = 21,
    _SC_SHARED_MEMORY_OBJECTS___11 = 22,
    _SC_AIO_LISTIO_MAX___11 = 23,
    _SC_AIO_MAX___11 = 24,
    _SC_AIO_PRIO_DELTA_MAX___11 = 25,
    _SC_DELAYTIMER_MAX___11 = 26,
    _SC_MQ_OPEN_MAX___11 = 27,
    _SC_MQ_PRIO_MAX___11 = 28,
    _SC_VERSION___11 = 29,
    _SC_PAGESIZE___11 = 30,
    _SC_RTSIG_MAX___11 = 31,
    _SC_SEM_NSEMS_MAX___11 = 32,
    _SC_SEM_VALUE_MAX___11 = 33,
    _SC_SIGQUEUE_MAX___11 = 34,
    _SC_TIMER_MAX___11 = 35,
    _SC_BC_BASE_MAX___11 = 36,
    _SC_BC_DIM_MAX___11 = 37,
    _SC_BC_SCALE_MAX___11 = 38,
    _SC_BC_STRING_MAX___11 = 39,
    _SC_COLL_WEIGHTS_MAX___11 = 40,
    _SC_EQUIV_CLASS_MAX___11 = 41,
    _SC_EXPR_NEST_MAX___11 = 42,
    _SC_LINE_MAX___11 = 43,
    _SC_RE_DUP_MAX___11 = 44,
    _SC_CHARCLASS_NAME_MAX___11 = 45,
    _SC_2_VERSION___11 = 46,
    _SC_2_C_BIND___11 = 47,
    _SC_2_C_DEV___11 = 48,
    _SC_2_FORT_DEV___11 = 49,
    _SC_2_FORT_RUN___11 = 50,
    _SC_2_SW_DEV___11 = 51,
    _SC_2_LOCALEDEF___11 = 52,
    _SC_PII___11 = 53,
    _SC_PII_XTI___11 = 54,
    _SC_PII_SOCKET___11 = 55,
    _SC_PII_INTERNET___11 = 56,
    _SC_PII_OSI___11 = 57,
    _SC_POLL___11 = 58,
    _SC_SELECT___11 = 59,
    _SC_UIO_MAXIOV___11 = 60,
    _SC_IOV_MAX___11 = 60,
    _SC_PII_INTERNET_STREAM___11 = 61,
    _SC_PII_INTERNET_DGRAM___11 = 62,
    _SC_PII_OSI_COTS___11 = 63,
    _SC_PII_OSI_CLTS___11 = 64,
    _SC_PII_OSI_M___11 = 65,
    _SC_T_IOV_MAX___11 = 66,
    _SC_THREADS___11 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___11 = 68,
    _SC_GETGR_R_SIZE_MAX___11 = 69,
    _SC_GETPW_R_SIZE_MAX___11 = 70,
    _SC_LOGIN_NAME_MAX___11 = 71,
    _SC_TTY_NAME_MAX___11 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___11 = 73,
    _SC_THREAD_KEYS_MAX___11 = 74,
    _SC_THREAD_STACK_MIN___11 = 75,
    _SC_THREAD_THREADS_MAX___11 = 76,
    _SC_THREAD_ATTR_STACKADDR___11 = 77,
    _SC_THREAD_ATTR_STACKSIZE___11 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___11 = 79,
    _SC_THREAD_PRIO_INHERIT___11 = 80,
    _SC_THREAD_PRIO_PROTECT___11 = 81,
    _SC_THREAD_PROCESS_SHARED___11 = 82,
    _SC_NPROCESSORS_CONF___11 = 83,
    _SC_NPROCESSORS_ONLN___11 = 84,
    _SC_PHYS_PAGES___11 = 85,
    _SC_AVPHYS_PAGES___11 = 86,
    _SC_ATEXIT_MAX___11 = 87,
    _SC_PASS_MAX___11 = 88,
    _SC_XOPEN_VERSION___11 = 89,
    _SC_XOPEN_XCU_VERSION___11 = 90,
    _SC_XOPEN_UNIX___11 = 91,
    _SC_XOPEN_CRYPT___11 = 92,
    _SC_XOPEN_ENH_I18N___11 = 93,
    _SC_XOPEN_SHM___11 = 94,
    _SC_2_CHAR_TERM___11 = 95,
    _SC_2_C_VERSION___11 = 96,
    _SC_2_UPE___11 = 97,
    _SC_XOPEN_XPG2___11 = 98,
    _SC_XOPEN_XPG3___11 = 99,
    _SC_XOPEN_XPG4___11 = 100,
    _SC_CHAR_BIT___11 = 101,
    _SC_CHAR_MAX___11 = 102,
    _SC_CHAR_MIN___11 = 103,
    _SC_INT_MAX___11 = 104,
    _SC_INT_MIN___11 = 105,
    _SC_LONG_BIT___11 = 106,
    _SC_WORD_BIT___11 = 107,
    _SC_MB_LEN_MAX___11 = 108,
    _SC_NZERO___11 = 109,
    _SC_SSIZE_MAX___11 = 110,
    _SC_SCHAR_MAX___11 = 111,
    _SC_SCHAR_MIN___11 = 112,
    _SC_SHRT_MAX___11 = 113,
    _SC_SHRT_MIN___11 = 114,
    _SC_UCHAR_MAX___11 = 115,
    _SC_UINT_MAX___11 = 116,
    _SC_ULONG_MAX___11 = 117,
    _SC_USHRT_MAX___11 = 118,
    _SC_NL_ARGMAX___11 = 119,
    _SC_NL_LANGMAX___11 = 120,
    _SC_NL_MSGMAX___11 = 121,
    _SC_NL_NMAX___11 = 122,
    _SC_NL_SETMAX___11 = 123,
    _SC_NL_TEXTMAX___11 = 124,
    _SC_XBS5_ILP32_OFF32___11 = 125,
    _SC_XBS5_ILP32_OFFBIG___11 = 126,
    _SC_XBS5_LP64_OFF64___11 = 127,
    _SC_XBS5_LPBIG_OFFBIG___11 = 128,
    _SC_XOPEN_LEGACY___11 = 129,
    _SC_XOPEN_REALTIME___11 = 130,
    _SC_XOPEN_REALTIME_THREADS___11 = 131,
    _SC_ADVISORY_INFO___11 = 132,
    _SC_BARRIERS___11 = 133,
    _SC_BASE___11 = 134,
    _SC_C_LANG_SUPPORT___11 = 135,
    _SC_C_LANG_SUPPORT_R___11 = 136,
    _SC_CLOCK_SELECTION___11 = 137,
    _SC_CPUTIME___11 = 138,
    _SC_THREAD_CPUTIME___11 = 139,
    _SC_DEVICE_IO___11 = 140,
    _SC_DEVICE_SPECIFIC___11 = 141,
    _SC_DEVICE_SPECIFIC_R___11 = 142,
    _SC_FD_MGMT___11 = 143,
    _SC_FIFO___11 = 144,
    _SC_PIPE___11 = 145,
    _SC_FILE_ATTRIBUTES___11 = 146,
    _SC_FILE_LOCKING___11 = 147,
    _SC_FILE_SYSTEM___11 = 148,
    _SC_MONOTONIC_CLOCK___11 = 149,
    _SC_MULTI_PROCESS___11 = 150,
    _SC_SINGLE_PROCESS___11 = 151,
    _SC_NETWORKING___11 = 152,
    _SC_READER_WRITER_LOCKS___11 = 153,
    _SC_SPIN_LOCKS___11 = 154,
    _SC_REGEXP___11 = 155,
    _SC_REGEX_VERSION___11 = 156,
    _SC_SHELL___11 = 157,
    _SC_SIGNALS___11 = 158,
    _SC_SPAWN___11 = 159,
    _SC_SPORADIC_SERVER___11 = 160,
    _SC_THREAD_SPORADIC_SERVER___11 = 161,
    _SC_SYSTEM_DATABASE___11 = 162,
    _SC_SYSTEM_DATABASE_R___11 = 163,
    _SC_TIMEOUTS___11 = 164,
    _SC_TYPED_MEMORY_OBJECTS___11 = 165,
    _SC_USER_GROUPS___11 = 166,
    _SC_USER_GROUPS_R___11 = 167,
    _SC_2_PBS___11 = 168,
    _SC_2_PBS_ACCOUNTING___11 = 169,
    _SC_2_PBS_LOCATE___11 = 170,
    _SC_2_PBS_MESSAGE___11 = 171,
    _SC_2_PBS_TRACK___11 = 172,
    _SC_SYMLOOP_MAX___11 = 173,
    _SC_STREAMS___11 = 174,
    _SC_2_PBS_CHECKPOINT___11 = 175,
    _SC_V6_ILP32_OFF32___11 = 176,
    _SC_V6_ILP32_OFFBIG___11 = 177,
    _SC_V6_LP64_OFF64___11 = 178,
    _SC_V6_LPBIG_OFFBIG___11 = 179,
    _SC_HOST_NAME_MAX___11 = 180,
    _SC_TRACE___11 = 181,
    _SC_TRACE_EVENT_FILTER___11 = 182,
    _SC_TRACE_INHERIT___11 = 183,
    _SC_TRACE_LOG___11 = 184,
    _SC_LEVEL1_ICACHE_SIZE___11 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___11 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___11 = 187,
    _SC_LEVEL1_DCACHE_SIZE___11 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___11 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___11 = 190,
    _SC_LEVEL2_CACHE_SIZE___11 = 191,
    _SC_LEVEL2_CACHE_ASSOC___11 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___11 = 193,
    _SC_LEVEL3_CACHE_SIZE___11 = 194,
    _SC_LEVEL3_CACHE_ASSOC___11 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___11 = 196,
    _SC_LEVEL4_CACHE_SIZE___11 = 197,
    _SC_LEVEL4_CACHE_ASSOC___11 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___11 = 199,
    _SC_IPV6___11 = 235,
    _SC_RAW_SOCKETS___11 = 236,
    _SC_V7_ILP32_OFF32___11 = 237,
    _SC_V7_ILP32_OFFBIG___11 = 238,
    _SC_V7_LP64_OFF64___11 = 239,
    _SC_V7_LPBIG_OFFBIG___11 = 240,
    _SC_SS_REPL_MAX___11 = 241,
    _SC_TRACE_EVENT_NAME_MAX___11 = 242,
    _SC_TRACE_NAME_MAX___11 = 243,
    _SC_TRACE_SYS_MAX___11 = 244,
    _SC_TRACE_USER_EVENT_MAX___11 = 245,
    _SC_XOPEN_STREAMS___11 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___11 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___11 = 248,
    _SC_MINSIGSTKSZ___11 = 249,
    _SC_SIGSTKSZ___11 = 250
} ;
enum __anonenum_875524036___11 {
    _CS_PATH___11 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___11 = 1,
    _CS_GNU_LIBC_VERSION___11 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___11 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___11 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___11 = 5,
    _CS_LFS_CFLAGS___11 = 1000,
    _CS_LFS_LDFLAGS___11 = 1001,
    _CS_LFS_LIBS___11 = 1002,
    _CS_LFS_LINTFLAGS___11 = 1003,
    _CS_LFS64_CFLAGS___11 = 1004,
    _CS_LFS64_LDFLAGS___11 = 1005,
    _CS_LFS64_LIBS___11 = 1006,
    _CS_LFS64_LINTFLAGS___11 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___11 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___11 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___11 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___11 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___11 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___11 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___11 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___11 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___11 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___11 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___11 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___11 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___11 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___11 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___11 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___11 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___11 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___11 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___11 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___11 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___11 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___11 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___11 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___11 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___11 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___11 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___11 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___11 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___11 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___11 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___11 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___11 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___11 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___11 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___11 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___11 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___11 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___11 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___11 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___11 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___11 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___11 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___11 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___11 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___11 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___11 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___11 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___11 = 1147,
    _CS_V6_ENV___11 = 1148,
    _CS_V7_ENV___11 = 1149
} ;
enum __anonenum_57186863___11 {
    SS_ONSTACK___11 = 1,
    SS_DISABLE___11 = 2
} ;
struct __kernel_timespec {
   __kernel_time64_t tv_sec ;
   long long tv_nsec ;
};
struct __kernel_itimerspec {
   struct __kernel_timespec it_interval ;
   struct __kernel_timespec it_value ;
};
struct __kernel_old_timeval {
   __kernel_long_t tv_sec ;
   __kernel_long_t tv_usec ;
};
struct __kernel_old_timespec {
   __kernel_old_time_t tv_sec ;
   long tv_nsec ;
};
struct __kernel_old_itimerval {
   struct __kernel_old_timeval it_interval ;
   struct __kernel_old_timeval it_value ;
};
struct __kernel_sock_timeval {
   __s64 tv_sec ;
   __s64 tv_usec ;
};
struct sock_ee_data_rfc4884 {
   __u16 len ;
   __u8 flags ;
   __u8 reserved ;
};
union __anonunion____missing_field_name_374167152 {
   __u32 ee_data ;
   struct sock_ee_data_rfc4884 ee_rfc4884 ;
};
struct sock_extended_err {
   __u32 ee_errno ;
   __u8 ee_origin ;
   __u8 ee_type ;
   __u8 ee_code ;
   __u8 ee_pad ;
   __u32 ee_info ;
   union __anonunion____missing_field_name_374167152 __annonCompField2 ;
};
struct scm_timestamping {
   struct timespec ts[3] ;
};
struct scm_timestamping64 {
   struct __kernel_timespec ts[3] ;
};
enum __anonenum_856285304 {
    SCM_TSTAMP_SND = 0,
    SCM_TSTAMP_SCHED = 1,
    SCM_TSTAMP_ACK = 2
} ;
typedef unsigned short __kernel_sa_family_t;
struct __anonstruct____missing_field_name_543124871 {
   __kernel_sa_family_t ss_family ;
   char __data[128UL - sizeof(unsigned short )] ;
};
union __anonunion____missing_field_name_154599446 {
   struct __anonstruct____missing_field_name_543124871 __annonCompField3 ;
   void *__align ;
};
struct __kernel_sockaddr_storage {
   union __anonunion____missing_field_name_154599446 __annonCompField4 ;
};
enum __anonenum_363867873 {
    SOF_TIMESTAMPING_TX_HARDWARE = 1,
    SOF_TIMESTAMPING_TX_SOFTWARE = 2,
    SOF_TIMESTAMPING_RX_HARDWARE = 4,
    SOF_TIMESTAMPING_RX_SOFTWARE = 8,
    SOF_TIMESTAMPING_SOFTWARE = 16,
    SOF_TIMESTAMPING_SYS_HARDWARE = 32,
    SOF_TIMESTAMPING_RAW_HARDWARE = 64,
    SOF_TIMESTAMPING_OPT_ID = 128,
    SOF_TIMESTAMPING_TX_SCHED = 256,
    SOF_TIMESTAMPING_TX_ACK = 512,
    SOF_TIMESTAMPING_OPT_CMSG = 1024,
    SOF_TIMESTAMPING_OPT_TSONLY = 2048,
    SOF_TIMESTAMPING_OPT_STATS = 4096,
    SOF_TIMESTAMPING_OPT_PKTINFO = 8192,
    SOF_TIMESTAMPING_OPT_TX_SWHW = 16384,
    SOF_TIMESTAMPING_BIND_PHC = 32768,
    SOF_TIMESTAMPING_LAST = 32768,
    SOF_TIMESTAMPING_MASK = 65535
} ;
struct so_timestamping {
   int flags ;
   int bind_phc ;
};
struct hwtstamp_config {
   int flags ;
   int tx_type ;
   int rx_filter ;
};
enum hwtstamp_tx_types {
    HWTSTAMP_TX_OFF = 0,
    HWTSTAMP_TX_ON = 1,
    HWTSTAMP_TX_ONESTEP_SYNC = 2,
    HWTSTAMP_TX_ONESTEP_P2P = 3,
    __HWTSTAMP_TX_CNT = 4
} ;
enum hwtstamp_rx_filters {
    HWTSTAMP_FILTER_NONE = 0,
    HWTSTAMP_FILTER_ALL = 1,
    HWTSTAMP_FILTER_SOME = 2,
    HWTSTAMP_FILTER_PTP_V1_L4_EVENT = 3,
    HWTSTAMP_FILTER_PTP_V1_L4_SYNC = 4,
    HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ = 5,
    HWTSTAMP_FILTER_PTP_V2_L4_EVENT = 6,
    HWTSTAMP_FILTER_PTP_V2_L4_SYNC = 7,
    HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ = 8,
    HWTSTAMP_FILTER_PTP_V2_L2_EVENT = 9,
    HWTSTAMP_FILTER_PTP_V2_L2_SYNC = 10,
    HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ = 11,
    HWTSTAMP_FILTER_PTP_V2_EVENT = 12,
    HWTSTAMP_FILTER_PTP_V2_SYNC = 13,
    HWTSTAMP_FILTER_PTP_V2_DELAY_REQ = 14,
    HWTSTAMP_FILTER_NTP_ALL = 15,
    __HWTSTAMP_FILTER_CNT = 16
} ;
struct scm_ts_pktinfo {
   __u32 if_index ;
   __u32 pkt_length ;
   __u32 reserved[2] ;
};
enum txtime_flags {
    SOF_TXTIME_DEADLINE_MODE = 1,
    SOF_TXTIME_REPORT_ERRORS = 2,
    SOF_TXTIME_FLAGS_LAST = 2,
    SOF_TXTIME_FLAGS_MASK = 3
} ;
struct sock_txtime {
   __kernel_clockid_t clockid ;
   __u32 flags ;
};
struct __anonstruct_PTP_Header_645370686 {
   uint8_t type ;
   uint8_t version ;
   uint16_t length ;
   uint8_t domain ;
   uint8_t min_sdoid ;
   uint16_t flags ;
   uint8_t rest[26] ;
};
typedef struct __anonstruct_PTP_Header_645370686 PTP_Header;
struct __anonstruct_PTP_TlvHeader_753912357 {
   uint16_t type ;
   uint16_t length ;
};
typedef struct __anonstruct_PTP_TlvHeader_753912357 PTP_TlvHeader;
struct __anonstruct_PTP_NtpMessage_383841638 {
   PTP_Header header ;
   uint8_t origin_ts[10] ;
   PTP_TlvHeader tlv_header ;
   NTP_Packet ntp_msg ;
};
typedef struct __anonstruct_PTP_NtpMessage_383841638 PTP_NtpMessage;
union sockaddr_all {
   struct sockaddr_in in4 ;
   struct sockaddr_in6 in6 ;
   struct sockaddr_un un ;
   struct sockaddr sa ;
};
union __anonunion_msg_824312281 {
   NTP_Packet ntp_msg ;
   PTP_NtpMessage ptp_msg ;
   CMD_Request cmd_request ;
   CMD_Reply cmd_reply ;
};
struct __anonstruct_msg_buf_763782785 {
   uint8_t l234_headers[64] ;
   union __anonunion_msg_824312281 msg ;
};
struct Message {
   union sockaddr_all name ;
   struct iovec iov ;
   struct __anonstruct_msg_buf_763782785 msg_buf ;
   struct cmsghdr cmsg_buf[256UL / sizeof(struct cmsghdr )] ;
};
enum __anonenum_83571709___12 {
    MSG_OOB___12 = 1,
    MSG_PEEK___12 = 2,
    MSG_DONTROUTE___12 = 4,
    MSG_TRYHARD___12 = 4,
    MSG_CTRUNC___12 = 8,
    MSG_PROXY___12 = 16,
    MSG_TRUNC___12 = 32,
    MSG_DONTWAIT___12 = 64,
    MSG_EOR___12 = 128,
    MSG_WAITALL___12 = 256,
    MSG_FIN___12 = 512,
    MSG_SYN___12 = 1024,
    MSG_CONFIRM___12 = 2048,
    MSG_RST___12 = 4096,
    MSG_ERRQUEUE___12 = 8192,
    MSG_NOSIGNAL___12 = 16384,
    MSG_MORE___12 = 32768,
    MSG_WAITFORONE___12 = 65536,
    MSG_BATCH___12 = 262144,
    MSG_ZEROCOPY___12 = 67108864,
    MSG_FASTOPEN___12 = 536870912,
    MSG_CMSG_CLOEXEC___12 = 1073741824
} ;
enum __anonenum_617082774___12 {
    SCM_RIGHTS___12 = 1,
    SCM_CREDENTIALS___12 = 2
} ;
enum __anonenum_606441560___12 {
    SHUT_RD___12 = 0,
    SHUT_WR___12 = 1,
    SHUT_RDWR___12 = 2
} ;
enum __anonenum_264779956___12 {
    IPPROTO_IP___12 = 0,
    IPPROTO_ICMP___12 = 1,
    IPPROTO_IGMP___12 = 2,
    IPPROTO_IPIP___12 = 4,
    IPPROTO_TCP___12 = 6,
    IPPROTO_EGP___12 = 8,
    IPPROTO_PUP___12 = 12,
    IPPROTO_UDP___12 = 17,
    IPPROTO_IDP___12 = 22,
    IPPROTO_TP___12 = 29,
    IPPROTO_DCCP___12 = 33,
    IPPROTO_IPV6___12 = 41,
    IPPROTO_RSVP___12 = 46,
    IPPROTO_GRE___12 = 47,
    IPPROTO_ESP___12 = 50,
    IPPROTO_AH___12 = 51,
    IPPROTO_MTP___12 = 92,
    IPPROTO_BEETPH___12 = 94,
    IPPROTO_ENCAP___12 = 98,
    IPPROTO_PIM___12 = 103,
    IPPROTO_COMP___12 = 108,
    IPPROTO_SCTP___12 = 132,
    IPPROTO_UDPLITE___12 = 136,
    IPPROTO_MPLS___12 = 137,
    IPPROTO_ETHERNET___12 = 143,
    IPPROTO_RAW___12 = 255,
    IPPROTO_MPTCP___12 = 262,
    IPPROTO_MAX___12 = 263
} ;
enum __anonenum_218739988___12 {
    IPPROTO_HOPOPTS___12 = 0,
    IPPROTO_ROUTING___12 = 43,
    IPPROTO_FRAGMENT___12 = 44,
    IPPROTO_ICMPV6___12 = 58,
    IPPROTO_NONE___12 = 59,
    IPPROTO_DSTOPTS___12 = 60,
    IPPROTO_MH___12 = 135
} ;
enum __anonenum_662268580___12 {
    IPPORT_ECHO___12 = 7,
    IPPORT_DISCARD___12 = 9,
    IPPORT_SYSTAT___12 = 11,
    IPPORT_DAYTIME___12 = 13,
    IPPORT_NETSTAT___12 = 15,
    IPPORT_FTP___12 = 21,
    IPPORT_TELNET___12 = 23,
    IPPORT_SMTP___12 = 25,
    IPPORT_TIMESERVER___12 = 37,
    IPPORT_NAMESERVER___12 = 42,
    IPPORT_WHOIS___12 = 43,
    IPPORT_MTP___12 = 57,
    IPPORT_TFTP___12 = 69,
    IPPORT_RJE___12 = 77,
    IPPORT_FINGER___12 = 79,
    IPPORT_TTYLINK___12 = 87,
    IPPORT_SUPDUP___12 = 95,
    IPPORT_EXECSERVER___12 = 512,
    IPPORT_LOGINSERVER___12 = 513,
    IPPORT_CMDSERVER___12 = 514,
    IPPORT_EFSSERVER___12 = 520,
    IPPORT_BIFFUDP___12 = 512,
    IPPORT_WHOSERVER___12 = 513,
    IPPORT_ROUTESERVER___12 = 520,
    IPPORT_RESERVED___12 = 1024,
    IPPORT_USERRESERVED___12 = 5000
} ;
enum __anonenum_18926444___12 {
    _ISupper___12 = 256,
    _ISlower___12 = 512,
    _ISalpha___12 = 1024,
    _ISdigit___12 = 2048,
    _ISxdigit___12 = 4096,
    _ISspace___12 = 8192,
    _ISprint___12 = 16384,
    _ISgraph___12 = 32768,
    _ISblank___12 = 1,
    _IScntrl___12 = 2,
    _ISpunct___12 = 4,
    _ISalnum___12 = 8
} ;
enum __anonenum_913965969___12 {
    FP_INT_UPWARD___12 = 0,
    FP_INT_DOWNWARD___12 = 1,
    FP_INT_TOWARDZERO___12 = 2,
    FP_INT_TONEARESTFROMZERO___12 = 3,
    FP_INT_TONEAREST___12 = 4
} ;
enum __anonenum_1037408945___12 {
    FP_NAN___12 = 0,
    FP_INFINITE___12 = 1,
    FP_ZERO___12 = 2,
    FP_SUBNORMAL___12 = 3,
    FP_NORMAL___12 = 4
} ;
enum __anonenum_556971655___12 {
    SI_ASYNCNL___12 = -60,
    SI_DETHREAD___12 = -7,
    SI_TKILL___12 = -6,
    SI_SIGIO___12 = -5,
    SI_ASYNCIO___12 = -4,
    SI_MESGQ___12 = -3,
    SI_TIMER___12 = -2,
    SI_QUEUE___12 = -1,
    SI_USER___12 = 0,
    SI_KERNEL___12 = 128
} ;
enum __anonenum_640648963___12 {
    ILL_ILLOPC___12 = 1,
    ILL_ILLOPN___12 = 2,
    ILL_ILLADR___12 = 3,
    ILL_ILLTRP___12 = 4,
    ILL_PRVOPC___12 = 5,
    ILL_PRVREG___12 = 6,
    ILL_COPROC___12 = 7,
    ILL_BADSTK___12 = 8,
    ILL_BADIADDR___12 = 9
} ;
enum __anonenum_457704180___12 {
    FPE_INTDIV___12 = 1,
    FPE_INTOVF___12 = 2,
    FPE_FLTDIV___12 = 3,
    FPE_FLTOVF___12 = 4,
    FPE_FLTUND___12 = 5,
    FPE_FLTRES___12 = 6,
    FPE_FLTINV___12 = 7,
    FPE_FLTSUB___12 = 8,
    FPE_FLTUNK___12 = 14,
    FPE_CONDTRAP___12 = 15
} ;
enum __anonenum_180375148___12 {
    SEGV_MAPERR___12 = 1,
    SEGV_ACCERR___12 = 2,
    SEGV_BNDERR___12 = 3,
    SEGV_PKUERR___12 = 4,
    SEGV_ACCADI___12 = 5,
    SEGV_ADIDERR___12 = 6,
    SEGV_ADIPERR___12 = 7,
    SEGV_MTEAERR___12 = 8,
    SEGV_MTESERR___12 = 9
} ;
enum __anonenum_1036286214___12 {
    BUS_ADRALN___12 = 1,
    BUS_ADRERR___12 = 2,
    BUS_OBJERR___12 = 3,
    BUS_MCEERR_AR___12 = 4,
    BUS_MCEERR_AO___12 = 5
} ;
enum __anonenum_91015150___12 {
    TRAP_BRKPT___12 = 1,
    TRAP_TRACE___12 = 2,
    TRAP_BRANCH___12 = 3,
    TRAP_HWBKPT___12 = 4,
    TRAP_UNK___12 = 5
} ;
enum __anonenum_23175539___12 {
    CLD_EXITED___12 = 1,
    CLD_KILLED___12 = 2,
    CLD_DUMPED___12 = 3,
    CLD_TRAPPED___12 = 4,
    CLD_STOPPED___12 = 5,
    CLD_CONTINUED___12 = 6
} ;
enum __anonenum_111643124___12 {
    POLL_IN___12 = 1,
    POLL_OUT___12 = 2,
    POLL_MSG___12 = 3,
    POLL_ERR___12 = 4,
    POLL_PRI___12 = 5,
    POLL_HUP___12 = 6
} ;
enum __anonenum_852341087___12 {
    SIGEV_SIGNAL___12 = 0,
    SIGEV_NONE___12 = 1,
    SIGEV_THREAD___12 = 2,
    SIGEV_THREAD_ID___12 = 4
} ;
enum __anonenum_451154152___12 {
    REG_R8___12 = 0,
    REG_R9___12 = 1,
    REG_R10___12 = 2,
    REG_R11___12 = 3,
    REG_R12___12 = 4,
    REG_R13___12 = 5,
    REG_R14___12 = 6,
    REG_R15___12 = 7,
    REG_RDI___12 = 8,
    REG_RSI___12 = 9,
    REG_RBP___12 = 10,
    REG_RBX___12 = 11,
    REG_RDX___12 = 12,
    REG_RAX___12 = 13,
    REG_RCX___12 = 14,
    REG_RSP___12 = 15,
    REG_RIP___12 = 16,
    REG_EFL___12 = 17,
    REG_CSGSFS___12 = 18,
    REG_ERR___12 = 19,
    REG_TRAPNO___12 = 20,
    REG_OLDMASK___12 = 21,
    REG_CR2___12 = 22
} ;
enum __anonenum_437032235___12 {
    _PC_LINK_MAX___12 = 0,
    _PC_MAX_CANON___12 = 1,
    _PC_MAX_INPUT___12 = 2,
    _PC_NAME_MAX___12 = 3,
    _PC_PATH_MAX___12 = 4,
    _PC_PIPE_BUF___12 = 5,
    _PC_CHOWN_RESTRICTED___12 = 6,
    _PC_NO_TRUNC___12 = 7,
    _PC_VDISABLE___12 = 8,
    _PC_SYNC_IO___12 = 9,
    _PC_ASYNC_IO___12 = 10,
    _PC_PRIO_IO___12 = 11,
    _PC_SOCK_MAXBUF___12 = 12,
    _PC_FILESIZEBITS___12 = 13,
    _PC_REC_INCR_XFER_SIZE___12 = 14,
    _PC_REC_MAX_XFER_SIZE___12 = 15,
    _PC_REC_MIN_XFER_SIZE___12 = 16,
    _PC_REC_XFER_ALIGN___12 = 17,
    _PC_ALLOC_SIZE_MIN___12 = 18,
    _PC_SYMLINK_MAX___12 = 19,
    _PC_2_SYMLINKS___12 = 20
} ;
enum __anonenum_315186338___12 {
    _SC_ARG_MAX___12 = 0,
    _SC_CHILD_MAX___12 = 1,
    _SC_CLK_TCK___12 = 2,
    _SC_NGROUPS_MAX___12 = 3,
    _SC_OPEN_MAX___12 = 4,
    _SC_STREAM_MAX___12 = 5,
    _SC_TZNAME_MAX___12 = 6,
    _SC_JOB_CONTROL___12 = 7,
    _SC_SAVED_IDS___12 = 8,
    _SC_REALTIME_SIGNALS___12 = 9,
    _SC_PRIORITY_SCHEDULING___12 = 10,
    _SC_TIMERS___12 = 11,
    _SC_ASYNCHRONOUS_IO___12 = 12,
    _SC_PRIORITIZED_IO___12 = 13,
    _SC_SYNCHRONIZED_IO___12 = 14,
    _SC_FSYNC___12 = 15,
    _SC_MAPPED_FILES___12 = 16,
    _SC_MEMLOCK___12 = 17,
    _SC_MEMLOCK_RANGE___12 = 18,
    _SC_MEMORY_PROTECTION___12 = 19,
    _SC_MESSAGE_PASSING___12 = 20,
    _SC_SEMAPHORES___12 = 21,
    _SC_SHARED_MEMORY_OBJECTS___12 = 22,
    _SC_AIO_LISTIO_MAX___12 = 23,
    _SC_AIO_MAX___12 = 24,
    _SC_AIO_PRIO_DELTA_MAX___12 = 25,
    _SC_DELAYTIMER_MAX___12 = 26,
    _SC_MQ_OPEN_MAX___12 = 27,
    _SC_MQ_PRIO_MAX___12 = 28,
    _SC_VERSION___12 = 29,
    _SC_PAGESIZE___12 = 30,
    _SC_RTSIG_MAX___12 = 31,
    _SC_SEM_NSEMS_MAX___12 = 32,
    _SC_SEM_VALUE_MAX___12 = 33,
    _SC_SIGQUEUE_MAX___12 = 34,
    _SC_TIMER_MAX___12 = 35,
    _SC_BC_BASE_MAX___12 = 36,
    _SC_BC_DIM_MAX___12 = 37,
    _SC_BC_SCALE_MAX___12 = 38,
    _SC_BC_STRING_MAX___12 = 39,
    _SC_COLL_WEIGHTS_MAX___12 = 40,
    _SC_EQUIV_CLASS_MAX___12 = 41,
    _SC_EXPR_NEST_MAX___12 = 42,
    _SC_LINE_MAX___12 = 43,
    _SC_RE_DUP_MAX___12 = 44,
    _SC_CHARCLASS_NAME_MAX___12 = 45,
    _SC_2_VERSION___12 = 46,
    _SC_2_C_BIND___12 = 47,
    _SC_2_C_DEV___12 = 48,
    _SC_2_FORT_DEV___12 = 49,
    _SC_2_FORT_RUN___12 = 50,
    _SC_2_SW_DEV___12 = 51,
    _SC_2_LOCALEDEF___12 = 52,
    _SC_PII___12 = 53,
    _SC_PII_XTI___12 = 54,
    _SC_PII_SOCKET___12 = 55,
    _SC_PII_INTERNET___12 = 56,
    _SC_PII_OSI___12 = 57,
    _SC_POLL___12 = 58,
    _SC_SELECT___12 = 59,
    _SC_UIO_MAXIOV___12 = 60,
    _SC_IOV_MAX___12 = 60,
    _SC_PII_INTERNET_STREAM___12 = 61,
    _SC_PII_INTERNET_DGRAM___12 = 62,
    _SC_PII_OSI_COTS___12 = 63,
    _SC_PII_OSI_CLTS___12 = 64,
    _SC_PII_OSI_M___12 = 65,
    _SC_T_IOV_MAX___12 = 66,
    _SC_THREADS___12 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___12 = 68,
    _SC_GETGR_R_SIZE_MAX___12 = 69,
    _SC_GETPW_R_SIZE_MAX___12 = 70,
    _SC_LOGIN_NAME_MAX___12 = 71,
    _SC_TTY_NAME_MAX___12 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___12 = 73,
    _SC_THREAD_KEYS_MAX___12 = 74,
    _SC_THREAD_STACK_MIN___12 = 75,
    _SC_THREAD_THREADS_MAX___12 = 76,
    _SC_THREAD_ATTR_STACKADDR___12 = 77,
    _SC_THREAD_ATTR_STACKSIZE___12 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___12 = 79,
    _SC_THREAD_PRIO_INHERIT___12 = 80,
    _SC_THREAD_PRIO_PROTECT___12 = 81,
    _SC_THREAD_PROCESS_SHARED___12 = 82,
    _SC_NPROCESSORS_CONF___12 = 83,
    _SC_NPROCESSORS_ONLN___12 = 84,
    _SC_PHYS_PAGES___12 = 85,
    _SC_AVPHYS_PAGES___12 = 86,
    _SC_ATEXIT_MAX___12 = 87,
    _SC_PASS_MAX___12 = 88,
    _SC_XOPEN_VERSION___12 = 89,
    _SC_XOPEN_XCU_VERSION___12 = 90,
    _SC_XOPEN_UNIX___12 = 91,
    _SC_XOPEN_CRYPT___12 = 92,
    _SC_XOPEN_ENH_I18N___12 = 93,
    _SC_XOPEN_SHM___12 = 94,
    _SC_2_CHAR_TERM___12 = 95,
    _SC_2_C_VERSION___12 = 96,
    _SC_2_UPE___12 = 97,
    _SC_XOPEN_XPG2___12 = 98,
    _SC_XOPEN_XPG3___12 = 99,
    _SC_XOPEN_XPG4___12 = 100,
    _SC_CHAR_BIT___12 = 101,
    _SC_CHAR_MAX___12 = 102,
    _SC_CHAR_MIN___12 = 103,
    _SC_INT_MAX___12 = 104,
    _SC_INT_MIN___12 = 105,
    _SC_LONG_BIT___12 = 106,
    _SC_WORD_BIT___12 = 107,
    _SC_MB_LEN_MAX___12 = 108,
    _SC_NZERO___12 = 109,
    _SC_SSIZE_MAX___12 = 110,
    _SC_SCHAR_MAX___12 = 111,
    _SC_SCHAR_MIN___12 = 112,
    _SC_SHRT_MAX___12 = 113,
    _SC_SHRT_MIN___12 = 114,
    _SC_UCHAR_MAX___12 = 115,
    _SC_UINT_MAX___12 = 116,
    _SC_ULONG_MAX___12 = 117,
    _SC_USHRT_MAX___12 = 118,
    _SC_NL_ARGMAX___12 = 119,
    _SC_NL_LANGMAX___12 = 120,
    _SC_NL_MSGMAX___12 = 121,
    _SC_NL_NMAX___12 = 122,
    _SC_NL_SETMAX___12 = 123,
    _SC_NL_TEXTMAX___12 = 124,
    _SC_XBS5_ILP32_OFF32___12 = 125,
    _SC_XBS5_ILP32_OFFBIG___12 = 126,
    _SC_XBS5_LP64_OFF64___12 = 127,
    _SC_XBS5_LPBIG_OFFBIG___12 = 128,
    _SC_XOPEN_LEGACY___12 = 129,
    _SC_XOPEN_REALTIME___12 = 130,
    _SC_XOPEN_REALTIME_THREADS___12 = 131,
    _SC_ADVISORY_INFO___12 = 132,
    _SC_BARRIERS___12 = 133,
    _SC_BASE___12 = 134,
    _SC_C_LANG_SUPPORT___12 = 135,
    _SC_C_LANG_SUPPORT_R___12 = 136,
    _SC_CLOCK_SELECTION___12 = 137,
    _SC_CPUTIME___12 = 138,
    _SC_THREAD_CPUTIME___12 = 139,
    _SC_DEVICE_IO___12 = 140,
    _SC_DEVICE_SPECIFIC___12 = 141,
    _SC_DEVICE_SPECIFIC_R___12 = 142,
    _SC_FD_MGMT___12 = 143,
    _SC_FIFO___12 = 144,
    _SC_PIPE___12 = 145,
    _SC_FILE_ATTRIBUTES___12 = 146,
    _SC_FILE_LOCKING___12 = 147,
    _SC_FILE_SYSTEM___12 = 148,
    _SC_MONOTONIC_CLOCK___12 = 149,
    _SC_MULTI_PROCESS___12 = 150,
    _SC_SINGLE_PROCESS___12 = 151,
    _SC_NETWORKING___12 = 152,
    _SC_READER_WRITER_LOCKS___12 = 153,
    _SC_SPIN_LOCKS___12 = 154,
    _SC_REGEXP___12 = 155,
    _SC_REGEX_VERSION___12 = 156,
    _SC_SHELL___12 = 157,
    _SC_SIGNALS___12 = 158,
    _SC_SPAWN___12 = 159,
    _SC_SPORADIC_SERVER___12 = 160,
    _SC_THREAD_SPORADIC_SERVER___12 = 161,
    _SC_SYSTEM_DATABASE___12 = 162,
    _SC_SYSTEM_DATABASE_R___12 = 163,
    _SC_TIMEOUTS___12 = 164,
    _SC_TYPED_MEMORY_OBJECTS___12 = 165,
    _SC_USER_GROUPS___12 = 166,
    _SC_USER_GROUPS_R___12 = 167,
    _SC_2_PBS___12 = 168,
    _SC_2_PBS_ACCOUNTING___12 = 169,
    _SC_2_PBS_LOCATE___12 = 170,
    _SC_2_PBS_MESSAGE___12 = 171,
    _SC_2_PBS_TRACK___12 = 172,
    _SC_SYMLOOP_MAX___12 = 173,
    _SC_STREAMS___12 = 174,
    _SC_2_PBS_CHECKPOINT___12 = 175,
    _SC_V6_ILP32_OFF32___12 = 176,
    _SC_V6_ILP32_OFFBIG___12 = 177,
    _SC_V6_LP64_OFF64___12 = 178,
    _SC_V6_LPBIG_OFFBIG___12 = 179,
    _SC_HOST_NAME_MAX___12 = 180,
    _SC_TRACE___12 = 181,
    _SC_TRACE_EVENT_FILTER___12 = 182,
    _SC_TRACE_INHERIT___12 = 183,
    _SC_TRACE_LOG___12 = 184,
    _SC_LEVEL1_ICACHE_SIZE___12 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___12 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___12 = 187,
    _SC_LEVEL1_DCACHE_SIZE___12 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___12 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___12 = 190,
    _SC_LEVEL2_CACHE_SIZE___12 = 191,
    _SC_LEVEL2_CACHE_ASSOC___12 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___12 = 193,
    _SC_LEVEL3_CACHE_SIZE___12 = 194,
    _SC_LEVEL3_CACHE_ASSOC___12 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___12 = 196,
    _SC_LEVEL4_CACHE_SIZE___12 = 197,
    _SC_LEVEL4_CACHE_ASSOC___12 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___12 = 199,
    _SC_IPV6___12 = 235,
    _SC_RAW_SOCKETS___12 = 236,
    _SC_V7_ILP32_OFF32___12 = 237,
    _SC_V7_ILP32_OFFBIG___12 = 238,
    _SC_V7_LP64_OFF64___12 = 239,
    _SC_V7_LPBIG_OFFBIG___12 = 240,
    _SC_SS_REPL_MAX___12 = 241,
    _SC_TRACE_EVENT_NAME_MAX___12 = 242,
    _SC_TRACE_NAME_MAX___12 = 243,
    _SC_TRACE_SYS_MAX___12 = 244,
    _SC_TRACE_USER_EVENT_MAX___12 = 245,
    _SC_XOPEN_STREAMS___12 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___12 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___12 = 248,
    _SC_MINSIGSTKSZ___12 = 249,
    _SC_SIGSTKSZ___12 = 250
} ;
enum __anonenum_875524036___12 {
    _CS_PATH___12 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___12 = 1,
    _CS_GNU_LIBC_VERSION___12 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___12 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___12 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___12 = 5,
    _CS_LFS_CFLAGS___12 = 1000,
    _CS_LFS_LDFLAGS___12 = 1001,
    _CS_LFS_LIBS___12 = 1002,
    _CS_LFS_LINTFLAGS___12 = 1003,
    _CS_LFS64_CFLAGS___12 = 1004,
    _CS_LFS64_LDFLAGS___12 = 1005,
    _CS_LFS64_LIBS___12 = 1006,
    _CS_LFS64_LINTFLAGS___12 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___12 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___12 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___12 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___12 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___12 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___12 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___12 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___12 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___12 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___12 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___12 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___12 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___12 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___12 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___12 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___12 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___12 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___12 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___12 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___12 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___12 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___12 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___12 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___12 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___12 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___12 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___12 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___12 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___12 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___12 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___12 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___12 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___12 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___12 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___12 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___12 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___12 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___12 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___12 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___12 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___12 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___12 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___12 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___12 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___12 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___12 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___12 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___12 = 1147,
    _CS_V6_ENV___12 = 1148,
    _CS_V7_ENV___12 = 1149
} ;
enum __anonenum_57186863___12 {
    SS_ONSTACK___12 = 1,
    SS_DISABLE___12 = 2
} ;
struct SelectInfo {
   int select_ok ;
   double std_dev ;
   double root_distance ;
   double lo_limit ;
   double hi_limit ;
   double last_sample_ago ;
};
enum __anonenum_SRC_Status_20642363 {
    SRC_OK = 0,
    SRC_UNSELECTABLE = 1,
    SRC_BAD_STATS = 2,
    SRC_BAD_DISTANCE = 3,
    SRC_JITTERY = 4,
    SRC_WAITS_STATS = 5,
    SRC_STALE = 6,
    SRC_ORPHAN = 7,
    SRC_UNTRUSTED = 8,
    SRC_FALSETICKER = 9,
    SRC_WAITS_SOURCES = 10,
    SRC_NONPREFERRED = 11,
    SRC_WAITS_UPDATE = 12,
    SRC_DISTANT = 13,
    SRC_OUTLIER = 14,
    SRC_UNSELECTED = 15,
    SRC_SELECTED = 16
} ;
typedef enum __anonenum_SRC_Status_20642363 SRC_Status;
struct SRC_Instance_Record {
   SST_Stats stats ;
   int index ;
   uint32_t ref_id ;
   IPAddr *ip_addr ;
   int active ;
   int reachability ;
   int reachability_size ;
   int updates ;
   int distant ;
   SRC_Status status ;
   SRC_Type type ;
   int authenticated ;
   int conf_sel_options ;
   int sel_options ;
   double sel_score ;
   struct SelectInfo sel_info ;
   int stratum ;
   NTP_Leap leap ;
   int leap_vote ;
};
enum __anonenum_tag_1057593569 {
    LOW = -1,
    HIGH = 1
} ;
struct Sort_Element {
   int index ;
   double offset ;
   enum __anonenum_tag_1057593569 tag ;
};
enum __anonenum_83571709___13 {
    MSG_OOB___13 = 1,
    MSG_PEEK___13 = 2,
    MSG_DONTROUTE___13 = 4,
    MSG_TRYHARD___13 = 4,
    MSG_CTRUNC___13 = 8,
    MSG_PROXY___13 = 16,
    MSG_TRUNC___13 = 32,
    MSG_DONTWAIT___13 = 64,
    MSG_EOR___13 = 128,
    MSG_WAITALL___13 = 256,
    MSG_FIN___13 = 512,
    MSG_SYN___13 = 1024,
    MSG_CONFIRM___13 = 2048,
    MSG_RST___13 = 4096,
    MSG_ERRQUEUE___13 = 8192,
    MSG_NOSIGNAL___13 = 16384,
    MSG_MORE___13 = 32768,
    MSG_WAITFORONE___13 = 65536,
    MSG_BATCH___13 = 262144,
    MSG_ZEROCOPY___13 = 67108864,
    MSG_FASTOPEN___13 = 536870912,
    MSG_CMSG_CLOEXEC___13 = 1073741824
} ;
enum __anonenum_617082774___13 {
    SCM_RIGHTS___13 = 1,
    SCM_CREDENTIALS___13 = 2
} ;
enum __anonenum_606441560___13 {
    SHUT_RD___13 = 0,
    SHUT_WR___13 = 1,
    SHUT_RDWR___13 = 2
} ;
enum __anonenum_264779956___13 {
    IPPROTO_IP___13 = 0,
    IPPROTO_ICMP___13 = 1,
    IPPROTO_IGMP___13 = 2,
    IPPROTO_IPIP___13 = 4,
    IPPROTO_TCP___13 = 6,
    IPPROTO_EGP___13 = 8,
    IPPROTO_PUP___13 = 12,
    IPPROTO_UDP___13 = 17,
    IPPROTO_IDP___13 = 22,
    IPPROTO_TP___13 = 29,
    IPPROTO_DCCP___13 = 33,
    IPPROTO_IPV6___13 = 41,
    IPPROTO_RSVP___13 = 46,
    IPPROTO_GRE___13 = 47,
    IPPROTO_ESP___13 = 50,
    IPPROTO_AH___13 = 51,
    IPPROTO_MTP___13 = 92,
    IPPROTO_BEETPH___13 = 94,
    IPPROTO_ENCAP___13 = 98,
    IPPROTO_PIM___13 = 103,
    IPPROTO_COMP___13 = 108,
    IPPROTO_SCTP___13 = 132,
    IPPROTO_UDPLITE___13 = 136,
    IPPROTO_MPLS___13 = 137,
    IPPROTO_ETHERNET___13 = 143,
    IPPROTO_RAW___13 = 255,
    IPPROTO_MPTCP___13 = 262,
    IPPROTO_MAX___13 = 263
} ;
enum __anonenum_218739988___13 {
    IPPROTO_HOPOPTS___13 = 0,
    IPPROTO_ROUTING___13 = 43,
    IPPROTO_FRAGMENT___13 = 44,
    IPPROTO_ICMPV6___13 = 58,
    IPPROTO_NONE___13 = 59,
    IPPROTO_DSTOPTS___13 = 60,
    IPPROTO_MH___13 = 135
} ;
enum __anonenum_662268580___13 {
    IPPORT_ECHO___13 = 7,
    IPPORT_DISCARD___13 = 9,
    IPPORT_SYSTAT___13 = 11,
    IPPORT_DAYTIME___13 = 13,
    IPPORT_NETSTAT___13 = 15,
    IPPORT_FTP___13 = 21,
    IPPORT_TELNET___13 = 23,
    IPPORT_SMTP___13 = 25,
    IPPORT_TIMESERVER___13 = 37,
    IPPORT_NAMESERVER___13 = 42,
    IPPORT_WHOIS___13 = 43,
    IPPORT_MTP___13 = 57,
    IPPORT_TFTP___13 = 69,
    IPPORT_RJE___13 = 77,
    IPPORT_FINGER___13 = 79,
    IPPORT_TTYLINK___13 = 87,
    IPPORT_SUPDUP___13 = 95,
    IPPORT_EXECSERVER___13 = 512,
    IPPORT_LOGINSERVER___13 = 513,
    IPPORT_CMDSERVER___13 = 514,
    IPPORT_EFSSERVER___13 = 520,
    IPPORT_BIFFUDP___13 = 512,
    IPPORT_WHOSERVER___13 = 513,
    IPPORT_ROUTESERVER___13 = 520,
    IPPORT_RESERVED___13 = 1024,
    IPPORT_USERRESERVED___13 = 5000
} ;
enum __anonenum_18926444___13 {
    _ISupper___13 = 256,
    _ISlower___13 = 512,
    _ISalpha___13 = 1024,
    _ISdigit___13 = 2048,
    _ISxdigit___13 = 4096,
    _ISspace___13 = 8192,
    _ISprint___13 = 16384,
    _ISgraph___13 = 32768,
    _ISblank___13 = 1,
    _IScntrl___13 = 2,
    _ISpunct___13 = 4,
    _ISalnum___13 = 8
} ;
enum __anonenum_913965969___13 {
    FP_INT_UPWARD___13 = 0,
    FP_INT_DOWNWARD___13 = 1,
    FP_INT_TOWARDZERO___13 = 2,
    FP_INT_TONEARESTFROMZERO___13 = 3,
    FP_INT_TONEAREST___13 = 4
} ;
enum __anonenum_1037408945___13 {
    FP_NAN___13 = 0,
    FP_INFINITE___13 = 1,
    FP_ZERO___13 = 2,
    FP_SUBNORMAL___13 = 3,
    FP_NORMAL___13 = 4
} ;
enum __anonenum_556971655___13 {
    SI_ASYNCNL___13 = -60,
    SI_DETHREAD___13 = -7,
    SI_TKILL___13 = -6,
    SI_SIGIO___13 = -5,
    SI_ASYNCIO___13 = -4,
    SI_MESGQ___13 = -3,
    SI_TIMER___13 = -2,
    SI_QUEUE___13 = -1,
    SI_USER___13 = 0,
    SI_KERNEL___13 = 128
} ;
enum __anonenum_640648963___13 {
    ILL_ILLOPC___13 = 1,
    ILL_ILLOPN___13 = 2,
    ILL_ILLADR___13 = 3,
    ILL_ILLTRP___13 = 4,
    ILL_PRVOPC___13 = 5,
    ILL_PRVREG___13 = 6,
    ILL_COPROC___13 = 7,
    ILL_BADSTK___13 = 8,
    ILL_BADIADDR___13 = 9
} ;
enum __anonenum_457704180___13 {
    FPE_INTDIV___13 = 1,
    FPE_INTOVF___13 = 2,
    FPE_FLTDIV___13 = 3,
    FPE_FLTOVF___13 = 4,
    FPE_FLTUND___13 = 5,
    FPE_FLTRES___13 = 6,
    FPE_FLTINV___13 = 7,
    FPE_FLTSUB___13 = 8,
    FPE_FLTUNK___13 = 14,
    FPE_CONDTRAP___13 = 15
} ;
enum __anonenum_180375148___13 {
    SEGV_MAPERR___13 = 1,
    SEGV_ACCERR___13 = 2,
    SEGV_BNDERR___13 = 3,
    SEGV_PKUERR___13 = 4,
    SEGV_ACCADI___13 = 5,
    SEGV_ADIDERR___13 = 6,
    SEGV_ADIPERR___13 = 7,
    SEGV_MTEAERR___13 = 8,
    SEGV_MTESERR___13 = 9
} ;
enum __anonenum_1036286214___13 {
    BUS_ADRALN___13 = 1,
    BUS_ADRERR___13 = 2,
    BUS_OBJERR___13 = 3,
    BUS_MCEERR_AR___13 = 4,
    BUS_MCEERR_AO___13 = 5
} ;
enum __anonenum_91015150___13 {
    TRAP_BRKPT___13 = 1,
    TRAP_TRACE___13 = 2,
    TRAP_BRANCH___13 = 3,
    TRAP_HWBKPT___13 = 4,
    TRAP_UNK___13 = 5
} ;
enum __anonenum_23175539___13 {
    CLD_EXITED___13 = 1,
    CLD_KILLED___13 = 2,
    CLD_DUMPED___13 = 3,
    CLD_TRAPPED___13 = 4,
    CLD_STOPPED___13 = 5,
    CLD_CONTINUED___13 = 6
} ;
enum __anonenum_111643124___13 {
    POLL_IN___13 = 1,
    POLL_OUT___13 = 2,
    POLL_MSG___13 = 3,
    POLL_ERR___13 = 4,
    POLL_PRI___13 = 5,
    POLL_HUP___13 = 6
} ;
enum __anonenum_852341087___13 {
    SIGEV_SIGNAL___13 = 0,
    SIGEV_NONE___13 = 1,
    SIGEV_THREAD___13 = 2,
    SIGEV_THREAD_ID___13 = 4
} ;
enum __anonenum_451154152___13 {
    REG_R8___13 = 0,
    REG_R9___13 = 1,
    REG_R10___13 = 2,
    REG_R11___13 = 3,
    REG_R12___13 = 4,
    REG_R13___13 = 5,
    REG_R14___13 = 6,
    REG_R15___13 = 7,
    REG_RDI___13 = 8,
    REG_RSI___13 = 9,
    REG_RBP___13 = 10,
    REG_RBX___13 = 11,
    REG_RDX___13 = 12,
    REG_RAX___13 = 13,
    REG_RCX___13 = 14,
    REG_RSP___13 = 15,
    REG_RIP___13 = 16,
    REG_EFL___13 = 17,
    REG_CSGSFS___13 = 18,
    REG_ERR___13 = 19,
    REG_TRAPNO___13 = 20,
    REG_OLDMASK___13 = 21,
    REG_CR2___13 = 22
} ;
enum __anonenum_437032235___13 {
    _PC_LINK_MAX___13 = 0,
    _PC_MAX_CANON___13 = 1,
    _PC_MAX_INPUT___13 = 2,
    _PC_NAME_MAX___13 = 3,
    _PC_PATH_MAX___13 = 4,
    _PC_PIPE_BUF___13 = 5,
    _PC_CHOWN_RESTRICTED___13 = 6,
    _PC_NO_TRUNC___13 = 7,
    _PC_VDISABLE___13 = 8,
    _PC_SYNC_IO___13 = 9,
    _PC_ASYNC_IO___13 = 10,
    _PC_PRIO_IO___13 = 11,
    _PC_SOCK_MAXBUF___13 = 12,
    _PC_FILESIZEBITS___13 = 13,
    _PC_REC_INCR_XFER_SIZE___13 = 14,
    _PC_REC_MAX_XFER_SIZE___13 = 15,
    _PC_REC_MIN_XFER_SIZE___13 = 16,
    _PC_REC_XFER_ALIGN___13 = 17,
    _PC_ALLOC_SIZE_MIN___13 = 18,
    _PC_SYMLINK_MAX___13 = 19,
    _PC_2_SYMLINKS___13 = 20
} ;
enum __anonenum_315186338___13 {
    _SC_ARG_MAX___13 = 0,
    _SC_CHILD_MAX___13 = 1,
    _SC_CLK_TCK___13 = 2,
    _SC_NGROUPS_MAX___13 = 3,
    _SC_OPEN_MAX___13 = 4,
    _SC_STREAM_MAX___13 = 5,
    _SC_TZNAME_MAX___13 = 6,
    _SC_JOB_CONTROL___13 = 7,
    _SC_SAVED_IDS___13 = 8,
    _SC_REALTIME_SIGNALS___13 = 9,
    _SC_PRIORITY_SCHEDULING___13 = 10,
    _SC_TIMERS___13 = 11,
    _SC_ASYNCHRONOUS_IO___13 = 12,
    _SC_PRIORITIZED_IO___13 = 13,
    _SC_SYNCHRONIZED_IO___13 = 14,
    _SC_FSYNC___13 = 15,
    _SC_MAPPED_FILES___13 = 16,
    _SC_MEMLOCK___13 = 17,
    _SC_MEMLOCK_RANGE___13 = 18,
    _SC_MEMORY_PROTECTION___13 = 19,
    _SC_MESSAGE_PASSING___13 = 20,
    _SC_SEMAPHORES___13 = 21,
    _SC_SHARED_MEMORY_OBJECTS___13 = 22,
    _SC_AIO_LISTIO_MAX___13 = 23,
    _SC_AIO_MAX___13 = 24,
    _SC_AIO_PRIO_DELTA_MAX___13 = 25,
    _SC_DELAYTIMER_MAX___13 = 26,
    _SC_MQ_OPEN_MAX___13 = 27,
    _SC_MQ_PRIO_MAX___13 = 28,
    _SC_VERSION___13 = 29,
    _SC_PAGESIZE___13 = 30,
    _SC_RTSIG_MAX___13 = 31,
    _SC_SEM_NSEMS_MAX___13 = 32,
    _SC_SEM_VALUE_MAX___13 = 33,
    _SC_SIGQUEUE_MAX___13 = 34,
    _SC_TIMER_MAX___13 = 35,
    _SC_BC_BASE_MAX___13 = 36,
    _SC_BC_DIM_MAX___13 = 37,
    _SC_BC_SCALE_MAX___13 = 38,
    _SC_BC_STRING_MAX___13 = 39,
    _SC_COLL_WEIGHTS_MAX___13 = 40,
    _SC_EQUIV_CLASS_MAX___13 = 41,
    _SC_EXPR_NEST_MAX___13 = 42,
    _SC_LINE_MAX___13 = 43,
    _SC_RE_DUP_MAX___13 = 44,
    _SC_CHARCLASS_NAME_MAX___13 = 45,
    _SC_2_VERSION___13 = 46,
    _SC_2_C_BIND___13 = 47,
    _SC_2_C_DEV___13 = 48,
    _SC_2_FORT_DEV___13 = 49,
    _SC_2_FORT_RUN___13 = 50,
    _SC_2_SW_DEV___13 = 51,
    _SC_2_LOCALEDEF___13 = 52,
    _SC_PII___13 = 53,
    _SC_PII_XTI___13 = 54,
    _SC_PII_SOCKET___13 = 55,
    _SC_PII_INTERNET___13 = 56,
    _SC_PII_OSI___13 = 57,
    _SC_POLL___13 = 58,
    _SC_SELECT___13 = 59,
    _SC_UIO_MAXIOV___13 = 60,
    _SC_IOV_MAX___13 = 60,
    _SC_PII_INTERNET_STREAM___13 = 61,
    _SC_PII_INTERNET_DGRAM___13 = 62,
    _SC_PII_OSI_COTS___13 = 63,
    _SC_PII_OSI_CLTS___13 = 64,
    _SC_PII_OSI_M___13 = 65,
    _SC_T_IOV_MAX___13 = 66,
    _SC_THREADS___13 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___13 = 68,
    _SC_GETGR_R_SIZE_MAX___13 = 69,
    _SC_GETPW_R_SIZE_MAX___13 = 70,
    _SC_LOGIN_NAME_MAX___13 = 71,
    _SC_TTY_NAME_MAX___13 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___13 = 73,
    _SC_THREAD_KEYS_MAX___13 = 74,
    _SC_THREAD_STACK_MIN___13 = 75,
    _SC_THREAD_THREADS_MAX___13 = 76,
    _SC_THREAD_ATTR_STACKADDR___13 = 77,
    _SC_THREAD_ATTR_STACKSIZE___13 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___13 = 79,
    _SC_THREAD_PRIO_INHERIT___13 = 80,
    _SC_THREAD_PRIO_PROTECT___13 = 81,
    _SC_THREAD_PROCESS_SHARED___13 = 82,
    _SC_NPROCESSORS_CONF___13 = 83,
    _SC_NPROCESSORS_ONLN___13 = 84,
    _SC_PHYS_PAGES___13 = 85,
    _SC_AVPHYS_PAGES___13 = 86,
    _SC_ATEXIT_MAX___13 = 87,
    _SC_PASS_MAX___13 = 88,
    _SC_XOPEN_VERSION___13 = 89,
    _SC_XOPEN_XCU_VERSION___13 = 90,
    _SC_XOPEN_UNIX___13 = 91,
    _SC_XOPEN_CRYPT___13 = 92,
    _SC_XOPEN_ENH_I18N___13 = 93,
    _SC_XOPEN_SHM___13 = 94,
    _SC_2_CHAR_TERM___13 = 95,
    _SC_2_C_VERSION___13 = 96,
    _SC_2_UPE___13 = 97,
    _SC_XOPEN_XPG2___13 = 98,
    _SC_XOPEN_XPG3___13 = 99,
    _SC_XOPEN_XPG4___13 = 100,
    _SC_CHAR_BIT___13 = 101,
    _SC_CHAR_MAX___13 = 102,
    _SC_CHAR_MIN___13 = 103,
    _SC_INT_MAX___13 = 104,
    _SC_INT_MIN___13 = 105,
    _SC_LONG_BIT___13 = 106,
    _SC_WORD_BIT___13 = 107,
    _SC_MB_LEN_MAX___13 = 108,
    _SC_NZERO___13 = 109,
    _SC_SSIZE_MAX___13 = 110,
    _SC_SCHAR_MAX___13 = 111,
    _SC_SCHAR_MIN___13 = 112,
    _SC_SHRT_MAX___13 = 113,
    _SC_SHRT_MIN___13 = 114,
    _SC_UCHAR_MAX___13 = 115,
    _SC_UINT_MAX___13 = 116,
    _SC_ULONG_MAX___13 = 117,
    _SC_USHRT_MAX___13 = 118,
    _SC_NL_ARGMAX___13 = 119,
    _SC_NL_LANGMAX___13 = 120,
    _SC_NL_MSGMAX___13 = 121,
    _SC_NL_NMAX___13 = 122,
    _SC_NL_SETMAX___13 = 123,
    _SC_NL_TEXTMAX___13 = 124,
    _SC_XBS5_ILP32_OFF32___13 = 125,
    _SC_XBS5_ILP32_OFFBIG___13 = 126,
    _SC_XBS5_LP64_OFF64___13 = 127,
    _SC_XBS5_LPBIG_OFFBIG___13 = 128,
    _SC_XOPEN_LEGACY___13 = 129,
    _SC_XOPEN_REALTIME___13 = 130,
    _SC_XOPEN_REALTIME_THREADS___13 = 131,
    _SC_ADVISORY_INFO___13 = 132,
    _SC_BARRIERS___13 = 133,
    _SC_BASE___13 = 134,
    _SC_C_LANG_SUPPORT___13 = 135,
    _SC_C_LANG_SUPPORT_R___13 = 136,
    _SC_CLOCK_SELECTION___13 = 137,
    _SC_CPUTIME___13 = 138,
    _SC_THREAD_CPUTIME___13 = 139,
    _SC_DEVICE_IO___13 = 140,
    _SC_DEVICE_SPECIFIC___13 = 141,
    _SC_DEVICE_SPECIFIC_R___13 = 142,
    _SC_FD_MGMT___13 = 143,
    _SC_FIFO___13 = 144,
    _SC_PIPE___13 = 145,
    _SC_FILE_ATTRIBUTES___13 = 146,
    _SC_FILE_LOCKING___13 = 147,
    _SC_FILE_SYSTEM___13 = 148,
    _SC_MONOTONIC_CLOCK___13 = 149,
    _SC_MULTI_PROCESS___13 = 150,
    _SC_SINGLE_PROCESS___13 = 151,
    _SC_NETWORKING___13 = 152,
    _SC_READER_WRITER_LOCKS___13 = 153,
    _SC_SPIN_LOCKS___13 = 154,
    _SC_REGEXP___13 = 155,
    _SC_REGEX_VERSION___13 = 156,
    _SC_SHELL___13 = 157,
    _SC_SIGNALS___13 = 158,
    _SC_SPAWN___13 = 159,
    _SC_SPORADIC_SERVER___13 = 160,
    _SC_THREAD_SPORADIC_SERVER___13 = 161,
    _SC_SYSTEM_DATABASE___13 = 162,
    _SC_SYSTEM_DATABASE_R___13 = 163,
    _SC_TIMEOUTS___13 = 164,
    _SC_TYPED_MEMORY_OBJECTS___13 = 165,
    _SC_USER_GROUPS___13 = 166,
    _SC_USER_GROUPS_R___13 = 167,
    _SC_2_PBS___13 = 168,
    _SC_2_PBS_ACCOUNTING___13 = 169,
    _SC_2_PBS_LOCATE___13 = 170,
    _SC_2_PBS_MESSAGE___13 = 171,
    _SC_2_PBS_TRACK___13 = 172,
    _SC_SYMLOOP_MAX___13 = 173,
    _SC_STREAMS___13 = 174,
    _SC_2_PBS_CHECKPOINT___13 = 175,
    _SC_V6_ILP32_OFF32___13 = 176,
    _SC_V6_ILP32_OFFBIG___13 = 177,
    _SC_V6_LP64_OFF64___13 = 178,
    _SC_V6_LPBIG_OFFBIG___13 = 179,
    _SC_HOST_NAME_MAX___13 = 180,
    _SC_TRACE___13 = 181,
    _SC_TRACE_EVENT_FILTER___13 = 182,
    _SC_TRACE_INHERIT___13 = 183,
    _SC_TRACE_LOG___13 = 184,
    _SC_LEVEL1_ICACHE_SIZE___13 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___13 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___13 = 187,
    _SC_LEVEL1_DCACHE_SIZE___13 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___13 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___13 = 190,
    _SC_LEVEL2_CACHE_SIZE___13 = 191,
    _SC_LEVEL2_CACHE_ASSOC___13 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___13 = 193,
    _SC_LEVEL3_CACHE_SIZE___13 = 194,
    _SC_LEVEL3_CACHE_ASSOC___13 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___13 = 196,
    _SC_LEVEL4_CACHE_SIZE___13 = 197,
    _SC_LEVEL4_CACHE_ASSOC___13 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___13 = 199,
    _SC_IPV6___13 = 235,
    _SC_RAW_SOCKETS___13 = 236,
    _SC_V7_ILP32_OFF32___13 = 237,
    _SC_V7_ILP32_OFFBIG___13 = 238,
    _SC_V7_LP64_OFF64___13 = 239,
    _SC_V7_LPBIG_OFFBIG___13 = 240,
    _SC_SS_REPL_MAX___13 = 241,
    _SC_TRACE_EVENT_NAME_MAX___13 = 242,
    _SC_TRACE_NAME_MAX___13 = 243,
    _SC_TRACE_SYS_MAX___13 = 244,
    _SC_TRACE_USER_EVENT_MAX___13 = 245,
    _SC_XOPEN_STREAMS___13 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___13 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___13 = 248,
    _SC_MINSIGSTKSZ___13 = 249,
    _SC_SIGSTKSZ___13 = 250
} ;
enum __anonenum_875524036___13 {
    _CS_PATH___13 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___13 = 1,
    _CS_GNU_LIBC_VERSION___13 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___13 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___13 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___13 = 5,
    _CS_LFS_CFLAGS___13 = 1000,
    _CS_LFS_LDFLAGS___13 = 1001,
    _CS_LFS_LIBS___13 = 1002,
    _CS_LFS_LINTFLAGS___13 = 1003,
    _CS_LFS64_CFLAGS___13 = 1004,
    _CS_LFS64_LDFLAGS___13 = 1005,
    _CS_LFS64_LIBS___13 = 1006,
    _CS_LFS64_LINTFLAGS___13 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___13 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___13 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___13 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___13 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___13 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___13 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___13 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___13 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___13 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___13 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___13 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___13 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___13 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___13 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___13 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___13 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___13 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___13 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___13 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___13 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___13 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___13 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___13 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___13 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___13 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___13 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___13 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___13 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___13 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___13 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___13 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___13 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___13 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___13 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___13 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___13 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___13 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___13 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___13 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___13 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___13 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___13 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___13 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___13 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___13 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___13 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___13 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___13 = 1147,
    _CS_V6_ENV___13 = 1148,
    _CS_V7_ENV___13 = 1149
} ;
enum __anonenum_57186863___13 {
    SS_ONSTACK___13 = 1,
    SS_DISABLE___13 = 2
} ;
struct SST_Stats_Record {
   uint32_t refid ;
   IPAddr *ip_addr ;
   int min_samples ;
   int max_samples ;
   double fixed_min_delay ;
   double fixed_asymmetry ;
   int n_samples ;
   int runs_samples ;
   int last_sample ;
   int regression_ok ;
   int best_single_sample ;
   int min_delay_sample ;
   double estimated_offset ;
   double estimated_offset_sd ;
   struct timespec offset_time ;
   int nruns ;
   int asymmetry_run ;
   double asymmetry ;
   double estimated_frequency ;
   double estimated_frequency_sd ;
   double skew ;
   double std_dev ;
   struct timespec sample_times[128] ;
   double offsets[128] ;
   double orig_offsets[64] ;
   double peer_delays[128] ;
   double peer_dispersions[64] ;
   double root_delays[64] ;
   double root_dispersions[64] ;
};
enum __anonenum_83571709___14 {
    MSG_OOB___14 = 1,
    MSG_PEEK___14 = 2,
    MSG_DONTROUTE___14 = 4,
    MSG_TRYHARD___14 = 4,
    MSG_CTRUNC___14 = 8,
    MSG_PROXY___14 = 16,
    MSG_TRUNC___14 = 32,
    MSG_DONTWAIT___14 = 64,
    MSG_EOR___14 = 128,
    MSG_WAITALL___14 = 256,
    MSG_FIN___14 = 512,
    MSG_SYN___14 = 1024,
    MSG_CONFIRM___14 = 2048,
    MSG_RST___14 = 4096,
    MSG_ERRQUEUE___14 = 8192,
    MSG_NOSIGNAL___14 = 16384,
    MSG_MORE___14 = 32768,
    MSG_WAITFORONE___14 = 65536,
    MSG_BATCH___14 = 262144,
    MSG_ZEROCOPY___14 = 67108864,
    MSG_FASTOPEN___14 = 536870912,
    MSG_CMSG_CLOEXEC___14 = 1073741824
} ;
enum __anonenum_617082774___14 {
    SCM_RIGHTS___14 = 1,
    SCM_CREDENTIALS___14 = 2
} ;
enum __anonenum_606441560___14 {
    SHUT_RD___14 = 0,
    SHUT_WR___14 = 1,
    SHUT_RDWR___14 = 2
} ;
enum __anonenum_264779956___14 {
    IPPROTO_IP___14 = 0,
    IPPROTO_ICMP___14 = 1,
    IPPROTO_IGMP___14 = 2,
    IPPROTO_IPIP___14 = 4,
    IPPROTO_TCP___14 = 6,
    IPPROTO_EGP___14 = 8,
    IPPROTO_PUP___14 = 12,
    IPPROTO_UDP___14 = 17,
    IPPROTO_IDP___14 = 22,
    IPPROTO_TP___14 = 29,
    IPPROTO_DCCP___14 = 33,
    IPPROTO_IPV6___14 = 41,
    IPPROTO_RSVP___14 = 46,
    IPPROTO_GRE___14 = 47,
    IPPROTO_ESP___14 = 50,
    IPPROTO_AH___14 = 51,
    IPPROTO_MTP___14 = 92,
    IPPROTO_BEETPH___14 = 94,
    IPPROTO_ENCAP___14 = 98,
    IPPROTO_PIM___14 = 103,
    IPPROTO_COMP___14 = 108,
    IPPROTO_SCTP___14 = 132,
    IPPROTO_UDPLITE___14 = 136,
    IPPROTO_MPLS___14 = 137,
    IPPROTO_ETHERNET___14 = 143,
    IPPROTO_RAW___14 = 255,
    IPPROTO_MPTCP___14 = 262,
    IPPROTO_MAX___14 = 263
} ;
enum __anonenum_218739988___14 {
    IPPROTO_HOPOPTS___14 = 0,
    IPPROTO_ROUTING___14 = 43,
    IPPROTO_FRAGMENT___14 = 44,
    IPPROTO_ICMPV6___14 = 58,
    IPPROTO_NONE___14 = 59,
    IPPROTO_DSTOPTS___14 = 60,
    IPPROTO_MH___14 = 135
} ;
enum __anonenum_662268580___14 {
    IPPORT_ECHO___14 = 7,
    IPPORT_DISCARD___14 = 9,
    IPPORT_SYSTAT___14 = 11,
    IPPORT_DAYTIME___14 = 13,
    IPPORT_NETSTAT___14 = 15,
    IPPORT_FTP___14 = 21,
    IPPORT_TELNET___14 = 23,
    IPPORT_SMTP___14 = 25,
    IPPORT_TIMESERVER___14 = 37,
    IPPORT_NAMESERVER___14 = 42,
    IPPORT_WHOIS___14 = 43,
    IPPORT_MTP___14 = 57,
    IPPORT_TFTP___14 = 69,
    IPPORT_RJE___14 = 77,
    IPPORT_FINGER___14 = 79,
    IPPORT_TTYLINK___14 = 87,
    IPPORT_SUPDUP___14 = 95,
    IPPORT_EXECSERVER___14 = 512,
    IPPORT_LOGINSERVER___14 = 513,
    IPPORT_CMDSERVER___14 = 514,
    IPPORT_EFSSERVER___14 = 520,
    IPPORT_BIFFUDP___14 = 512,
    IPPORT_WHOSERVER___14 = 513,
    IPPORT_ROUTESERVER___14 = 520,
    IPPORT_RESERVED___14 = 1024,
    IPPORT_USERRESERVED___14 = 5000
} ;
enum __anonenum_18926444___14 {
    _ISupper___14 = 256,
    _ISlower___14 = 512,
    _ISalpha___14 = 1024,
    _ISdigit___14 = 2048,
    _ISxdigit___14 = 4096,
    _ISspace___14 = 8192,
    _ISprint___14 = 16384,
    _ISgraph___14 = 32768,
    _ISblank___14 = 1,
    _IScntrl___14 = 2,
    _ISpunct___14 = 4,
    _ISalnum___14 = 8
} ;
enum __anonenum_913965969___14 {
    FP_INT_UPWARD___14 = 0,
    FP_INT_DOWNWARD___14 = 1,
    FP_INT_TOWARDZERO___14 = 2,
    FP_INT_TONEARESTFROMZERO___14 = 3,
    FP_INT_TONEAREST___14 = 4
} ;
enum __anonenum_1037408945___14 {
    FP_NAN___14 = 0,
    FP_INFINITE___14 = 1,
    FP_ZERO___14 = 2,
    FP_SUBNORMAL___14 = 3,
    FP_NORMAL___14 = 4
} ;
enum __anonenum_556971655___14 {
    SI_ASYNCNL___14 = -60,
    SI_DETHREAD___14 = -7,
    SI_TKILL___14 = -6,
    SI_SIGIO___14 = -5,
    SI_ASYNCIO___14 = -4,
    SI_MESGQ___14 = -3,
    SI_TIMER___14 = -2,
    SI_QUEUE___14 = -1,
    SI_USER___14 = 0,
    SI_KERNEL___14 = 128
} ;
enum __anonenum_640648963___14 {
    ILL_ILLOPC___14 = 1,
    ILL_ILLOPN___14 = 2,
    ILL_ILLADR___14 = 3,
    ILL_ILLTRP___14 = 4,
    ILL_PRVOPC___14 = 5,
    ILL_PRVREG___14 = 6,
    ILL_COPROC___14 = 7,
    ILL_BADSTK___14 = 8,
    ILL_BADIADDR___14 = 9
} ;
enum __anonenum_457704180___14 {
    FPE_INTDIV___14 = 1,
    FPE_INTOVF___14 = 2,
    FPE_FLTDIV___14 = 3,
    FPE_FLTOVF___14 = 4,
    FPE_FLTUND___14 = 5,
    FPE_FLTRES___14 = 6,
    FPE_FLTINV___14 = 7,
    FPE_FLTSUB___14 = 8,
    FPE_FLTUNK___14 = 14,
    FPE_CONDTRAP___14 = 15
} ;
enum __anonenum_180375148___14 {
    SEGV_MAPERR___14 = 1,
    SEGV_ACCERR___14 = 2,
    SEGV_BNDERR___14 = 3,
    SEGV_PKUERR___14 = 4,
    SEGV_ACCADI___14 = 5,
    SEGV_ADIDERR___14 = 6,
    SEGV_ADIPERR___14 = 7,
    SEGV_MTEAERR___14 = 8,
    SEGV_MTESERR___14 = 9
} ;
enum __anonenum_1036286214___14 {
    BUS_ADRALN___14 = 1,
    BUS_ADRERR___14 = 2,
    BUS_OBJERR___14 = 3,
    BUS_MCEERR_AR___14 = 4,
    BUS_MCEERR_AO___14 = 5
} ;
enum __anonenum_91015150___14 {
    TRAP_BRKPT___14 = 1,
    TRAP_TRACE___14 = 2,
    TRAP_BRANCH___14 = 3,
    TRAP_HWBKPT___14 = 4,
    TRAP_UNK___14 = 5
} ;
enum __anonenum_23175539___14 {
    CLD_EXITED___14 = 1,
    CLD_KILLED___14 = 2,
    CLD_DUMPED___14 = 3,
    CLD_TRAPPED___14 = 4,
    CLD_STOPPED___14 = 5,
    CLD_CONTINUED___14 = 6
} ;
enum __anonenum_111643124___14 {
    POLL_IN___14 = 1,
    POLL_OUT___14 = 2,
    POLL_MSG___14 = 3,
    POLL_ERR___14 = 4,
    POLL_PRI___14 = 5,
    POLL_HUP___14 = 6
} ;
enum __anonenum_852341087___14 {
    SIGEV_SIGNAL___14 = 0,
    SIGEV_NONE___14 = 1,
    SIGEV_THREAD___14 = 2,
    SIGEV_THREAD_ID___14 = 4
} ;
enum __anonenum_451154152___14 {
    REG_R8___14 = 0,
    REG_R9___14 = 1,
    REG_R10___14 = 2,
    REG_R11___14 = 3,
    REG_R12___14 = 4,
    REG_R13___14 = 5,
    REG_R14___14 = 6,
    REG_R15___14 = 7,
    REG_RDI___14 = 8,
    REG_RSI___14 = 9,
    REG_RBP___14 = 10,
    REG_RBX___14 = 11,
    REG_RDX___14 = 12,
    REG_RAX___14 = 13,
    REG_RCX___14 = 14,
    REG_RSP___14 = 15,
    REG_RIP___14 = 16,
    REG_EFL___14 = 17,
    REG_CSGSFS___14 = 18,
    REG_ERR___14 = 19,
    REG_TRAPNO___14 = 20,
    REG_OLDMASK___14 = 21,
    REG_CR2___14 = 22
} ;
enum __anonenum_437032235___14 {
    _PC_LINK_MAX___14 = 0,
    _PC_MAX_CANON___14 = 1,
    _PC_MAX_INPUT___14 = 2,
    _PC_NAME_MAX___14 = 3,
    _PC_PATH_MAX___14 = 4,
    _PC_PIPE_BUF___14 = 5,
    _PC_CHOWN_RESTRICTED___14 = 6,
    _PC_NO_TRUNC___14 = 7,
    _PC_VDISABLE___14 = 8,
    _PC_SYNC_IO___14 = 9,
    _PC_ASYNC_IO___14 = 10,
    _PC_PRIO_IO___14 = 11,
    _PC_SOCK_MAXBUF___14 = 12,
    _PC_FILESIZEBITS___14 = 13,
    _PC_REC_INCR_XFER_SIZE___14 = 14,
    _PC_REC_MAX_XFER_SIZE___14 = 15,
    _PC_REC_MIN_XFER_SIZE___14 = 16,
    _PC_REC_XFER_ALIGN___14 = 17,
    _PC_ALLOC_SIZE_MIN___14 = 18,
    _PC_SYMLINK_MAX___14 = 19,
    _PC_2_SYMLINKS___14 = 20
} ;
enum __anonenum_315186338___14 {
    _SC_ARG_MAX___14 = 0,
    _SC_CHILD_MAX___14 = 1,
    _SC_CLK_TCK___14 = 2,
    _SC_NGROUPS_MAX___14 = 3,
    _SC_OPEN_MAX___14 = 4,
    _SC_STREAM_MAX___14 = 5,
    _SC_TZNAME_MAX___14 = 6,
    _SC_JOB_CONTROL___14 = 7,
    _SC_SAVED_IDS___14 = 8,
    _SC_REALTIME_SIGNALS___14 = 9,
    _SC_PRIORITY_SCHEDULING___14 = 10,
    _SC_TIMERS___14 = 11,
    _SC_ASYNCHRONOUS_IO___14 = 12,
    _SC_PRIORITIZED_IO___14 = 13,
    _SC_SYNCHRONIZED_IO___14 = 14,
    _SC_FSYNC___14 = 15,
    _SC_MAPPED_FILES___14 = 16,
    _SC_MEMLOCK___14 = 17,
    _SC_MEMLOCK_RANGE___14 = 18,
    _SC_MEMORY_PROTECTION___14 = 19,
    _SC_MESSAGE_PASSING___14 = 20,
    _SC_SEMAPHORES___14 = 21,
    _SC_SHARED_MEMORY_OBJECTS___14 = 22,
    _SC_AIO_LISTIO_MAX___14 = 23,
    _SC_AIO_MAX___14 = 24,
    _SC_AIO_PRIO_DELTA_MAX___14 = 25,
    _SC_DELAYTIMER_MAX___14 = 26,
    _SC_MQ_OPEN_MAX___14 = 27,
    _SC_MQ_PRIO_MAX___14 = 28,
    _SC_VERSION___14 = 29,
    _SC_PAGESIZE___14 = 30,
    _SC_RTSIG_MAX___14 = 31,
    _SC_SEM_NSEMS_MAX___14 = 32,
    _SC_SEM_VALUE_MAX___14 = 33,
    _SC_SIGQUEUE_MAX___14 = 34,
    _SC_TIMER_MAX___14 = 35,
    _SC_BC_BASE_MAX___14 = 36,
    _SC_BC_DIM_MAX___14 = 37,
    _SC_BC_SCALE_MAX___14 = 38,
    _SC_BC_STRING_MAX___14 = 39,
    _SC_COLL_WEIGHTS_MAX___14 = 40,
    _SC_EQUIV_CLASS_MAX___14 = 41,
    _SC_EXPR_NEST_MAX___14 = 42,
    _SC_LINE_MAX___14 = 43,
    _SC_RE_DUP_MAX___14 = 44,
    _SC_CHARCLASS_NAME_MAX___14 = 45,
    _SC_2_VERSION___14 = 46,
    _SC_2_C_BIND___14 = 47,
    _SC_2_C_DEV___14 = 48,
    _SC_2_FORT_DEV___14 = 49,
    _SC_2_FORT_RUN___14 = 50,
    _SC_2_SW_DEV___14 = 51,
    _SC_2_LOCALEDEF___14 = 52,
    _SC_PII___14 = 53,
    _SC_PII_XTI___14 = 54,
    _SC_PII_SOCKET___14 = 55,
    _SC_PII_INTERNET___14 = 56,
    _SC_PII_OSI___14 = 57,
    _SC_POLL___14 = 58,
    _SC_SELECT___14 = 59,
    _SC_UIO_MAXIOV___14 = 60,
    _SC_IOV_MAX___14 = 60,
    _SC_PII_INTERNET_STREAM___14 = 61,
    _SC_PII_INTERNET_DGRAM___14 = 62,
    _SC_PII_OSI_COTS___14 = 63,
    _SC_PII_OSI_CLTS___14 = 64,
    _SC_PII_OSI_M___14 = 65,
    _SC_T_IOV_MAX___14 = 66,
    _SC_THREADS___14 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___14 = 68,
    _SC_GETGR_R_SIZE_MAX___14 = 69,
    _SC_GETPW_R_SIZE_MAX___14 = 70,
    _SC_LOGIN_NAME_MAX___14 = 71,
    _SC_TTY_NAME_MAX___14 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___14 = 73,
    _SC_THREAD_KEYS_MAX___14 = 74,
    _SC_THREAD_STACK_MIN___14 = 75,
    _SC_THREAD_THREADS_MAX___14 = 76,
    _SC_THREAD_ATTR_STACKADDR___14 = 77,
    _SC_THREAD_ATTR_STACKSIZE___14 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___14 = 79,
    _SC_THREAD_PRIO_INHERIT___14 = 80,
    _SC_THREAD_PRIO_PROTECT___14 = 81,
    _SC_THREAD_PROCESS_SHARED___14 = 82,
    _SC_NPROCESSORS_CONF___14 = 83,
    _SC_NPROCESSORS_ONLN___14 = 84,
    _SC_PHYS_PAGES___14 = 85,
    _SC_AVPHYS_PAGES___14 = 86,
    _SC_ATEXIT_MAX___14 = 87,
    _SC_PASS_MAX___14 = 88,
    _SC_XOPEN_VERSION___14 = 89,
    _SC_XOPEN_XCU_VERSION___14 = 90,
    _SC_XOPEN_UNIX___14 = 91,
    _SC_XOPEN_CRYPT___14 = 92,
    _SC_XOPEN_ENH_I18N___14 = 93,
    _SC_XOPEN_SHM___14 = 94,
    _SC_2_CHAR_TERM___14 = 95,
    _SC_2_C_VERSION___14 = 96,
    _SC_2_UPE___14 = 97,
    _SC_XOPEN_XPG2___14 = 98,
    _SC_XOPEN_XPG3___14 = 99,
    _SC_XOPEN_XPG4___14 = 100,
    _SC_CHAR_BIT___14 = 101,
    _SC_CHAR_MAX___14 = 102,
    _SC_CHAR_MIN___14 = 103,
    _SC_INT_MAX___14 = 104,
    _SC_INT_MIN___14 = 105,
    _SC_LONG_BIT___14 = 106,
    _SC_WORD_BIT___14 = 107,
    _SC_MB_LEN_MAX___14 = 108,
    _SC_NZERO___14 = 109,
    _SC_SSIZE_MAX___14 = 110,
    _SC_SCHAR_MAX___14 = 111,
    _SC_SCHAR_MIN___14 = 112,
    _SC_SHRT_MAX___14 = 113,
    _SC_SHRT_MIN___14 = 114,
    _SC_UCHAR_MAX___14 = 115,
    _SC_UINT_MAX___14 = 116,
    _SC_ULONG_MAX___14 = 117,
    _SC_USHRT_MAX___14 = 118,
    _SC_NL_ARGMAX___14 = 119,
    _SC_NL_LANGMAX___14 = 120,
    _SC_NL_MSGMAX___14 = 121,
    _SC_NL_NMAX___14 = 122,
    _SC_NL_SETMAX___14 = 123,
    _SC_NL_TEXTMAX___14 = 124,
    _SC_XBS5_ILP32_OFF32___14 = 125,
    _SC_XBS5_ILP32_OFFBIG___14 = 126,
    _SC_XBS5_LP64_OFF64___14 = 127,
    _SC_XBS5_LPBIG_OFFBIG___14 = 128,
    _SC_XOPEN_LEGACY___14 = 129,
    _SC_XOPEN_REALTIME___14 = 130,
    _SC_XOPEN_REALTIME_THREADS___14 = 131,
    _SC_ADVISORY_INFO___14 = 132,
    _SC_BARRIERS___14 = 133,
    _SC_BASE___14 = 134,
    _SC_C_LANG_SUPPORT___14 = 135,
    _SC_C_LANG_SUPPORT_R___14 = 136,
    _SC_CLOCK_SELECTION___14 = 137,
    _SC_CPUTIME___14 = 138,
    _SC_THREAD_CPUTIME___14 = 139,
    _SC_DEVICE_IO___14 = 140,
    _SC_DEVICE_SPECIFIC___14 = 141,
    _SC_DEVICE_SPECIFIC_R___14 = 142,
    _SC_FD_MGMT___14 = 143,
    _SC_FIFO___14 = 144,
    _SC_PIPE___14 = 145,
    _SC_FILE_ATTRIBUTES___14 = 146,
    _SC_FILE_LOCKING___14 = 147,
    _SC_FILE_SYSTEM___14 = 148,
    _SC_MONOTONIC_CLOCK___14 = 149,
    _SC_MULTI_PROCESS___14 = 150,
    _SC_SINGLE_PROCESS___14 = 151,
    _SC_NETWORKING___14 = 152,
    _SC_READER_WRITER_LOCKS___14 = 153,
    _SC_SPIN_LOCKS___14 = 154,
    _SC_REGEXP___14 = 155,
    _SC_REGEX_VERSION___14 = 156,
    _SC_SHELL___14 = 157,
    _SC_SIGNALS___14 = 158,
    _SC_SPAWN___14 = 159,
    _SC_SPORADIC_SERVER___14 = 160,
    _SC_THREAD_SPORADIC_SERVER___14 = 161,
    _SC_SYSTEM_DATABASE___14 = 162,
    _SC_SYSTEM_DATABASE_R___14 = 163,
    _SC_TIMEOUTS___14 = 164,
    _SC_TYPED_MEMORY_OBJECTS___14 = 165,
    _SC_USER_GROUPS___14 = 166,
    _SC_USER_GROUPS_R___14 = 167,
    _SC_2_PBS___14 = 168,
    _SC_2_PBS_ACCOUNTING___14 = 169,
    _SC_2_PBS_LOCATE___14 = 170,
    _SC_2_PBS_MESSAGE___14 = 171,
    _SC_2_PBS_TRACK___14 = 172,
    _SC_SYMLOOP_MAX___14 = 173,
    _SC_STREAMS___14 = 174,
    _SC_2_PBS_CHECKPOINT___14 = 175,
    _SC_V6_ILP32_OFF32___14 = 176,
    _SC_V6_ILP32_OFFBIG___14 = 177,
    _SC_V6_LP64_OFF64___14 = 178,
    _SC_V6_LPBIG_OFFBIG___14 = 179,
    _SC_HOST_NAME_MAX___14 = 180,
    _SC_TRACE___14 = 181,
    _SC_TRACE_EVENT_FILTER___14 = 182,
    _SC_TRACE_INHERIT___14 = 183,
    _SC_TRACE_LOG___14 = 184,
    _SC_LEVEL1_ICACHE_SIZE___14 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___14 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___14 = 187,
    _SC_LEVEL1_DCACHE_SIZE___14 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___14 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___14 = 190,
    _SC_LEVEL2_CACHE_SIZE___14 = 191,
    _SC_LEVEL2_CACHE_ASSOC___14 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___14 = 193,
    _SC_LEVEL3_CACHE_SIZE___14 = 194,
    _SC_LEVEL3_CACHE_ASSOC___14 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___14 = 196,
    _SC_LEVEL4_CACHE_SIZE___14 = 197,
    _SC_LEVEL4_CACHE_ASSOC___14 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___14 = 199,
    _SC_IPV6___14 = 235,
    _SC_RAW_SOCKETS___14 = 236,
    _SC_V7_ILP32_OFF32___14 = 237,
    _SC_V7_ILP32_OFFBIG___14 = 238,
    _SC_V7_LP64_OFF64___14 = 239,
    _SC_V7_LPBIG_OFFBIG___14 = 240,
    _SC_SS_REPL_MAX___14 = 241,
    _SC_TRACE_EVENT_NAME_MAX___14 = 242,
    _SC_TRACE_NAME_MAX___14 = 243,
    _SC_TRACE_SYS_MAX___14 = 244,
    _SC_TRACE_USER_EVENT_MAX___14 = 245,
    _SC_XOPEN_STREAMS___14 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___14 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___14 = 248,
    _SC_MINSIGSTKSZ___14 = 249,
    _SC_SIGSTKSZ___14 = 250
} ;
enum __anonenum_875524036___14 {
    _CS_PATH___14 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___14 = 1,
    _CS_GNU_LIBC_VERSION___14 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___14 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___14 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___14 = 5,
    _CS_LFS_CFLAGS___14 = 1000,
    _CS_LFS_LDFLAGS___14 = 1001,
    _CS_LFS_LIBS___14 = 1002,
    _CS_LFS_LINTFLAGS___14 = 1003,
    _CS_LFS64_CFLAGS___14 = 1004,
    _CS_LFS64_LDFLAGS___14 = 1005,
    _CS_LFS64_LIBS___14 = 1006,
    _CS_LFS64_LINTFLAGS___14 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___14 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___14 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___14 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___14 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___14 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___14 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___14 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___14 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___14 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___14 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___14 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___14 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___14 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___14 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___14 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___14 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___14 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___14 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___14 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___14 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___14 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___14 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___14 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___14 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___14 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___14 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___14 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___14 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___14 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___14 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___14 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___14 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___14 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___14 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___14 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___14 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___14 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___14 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___14 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___14 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___14 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___14 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___14 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___14 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___14 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___14 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___14 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___14 = 1147,
    _CS_V6_ENV___14 = 1148,
    _CS_V7_ENV___14 = 1149
} ;
enum __anonenum_57186863___14 {
    SS_ONSTACK___14 = 1,
    SS_DISABLE___14 = 2
} ;
typedef void (*DNS_NameResolveHandler)(DNS_Status status , int n_addrs , IPAddr *ip_addrs ,
                                       void *anything );
struct NKC_Instance_Record ;
typedef struct NKC_Instance_Record *NKC_Instance;
struct NNC_Instance_Record ;
typedef struct NNC_Instance_Record *NNC_Instance;
enum __anonenum_83571709___15 {
    MSG_OOB___15 = 1,
    MSG_PEEK___15 = 2,
    MSG_DONTROUTE___15 = 4,
    MSG_TRYHARD___15 = 4,
    MSG_CTRUNC___15 = 8,
    MSG_PROXY___15 = 16,
    MSG_TRUNC___15 = 32,
    MSG_DONTWAIT___15 = 64,
    MSG_EOR___15 = 128,
    MSG_WAITALL___15 = 256,
    MSG_FIN___15 = 512,
    MSG_SYN___15 = 1024,
    MSG_CONFIRM___15 = 2048,
    MSG_RST___15 = 4096,
    MSG_ERRQUEUE___15 = 8192,
    MSG_NOSIGNAL___15 = 16384,
    MSG_MORE___15 = 32768,
    MSG_WAITFORONE___15 = 65536,
    MSG_BATCH___15 = 262144,
    MSG_ZEROCOPY___15 = 67108864,
    MSG_FASTOPEN___15 = 536870912,
    MSG_CMSG_CLOEXEC___15 = 1073741824
} ;
enum __anonenum_617082774___15 {
    SCM_RIGHTS___15 = 1,
    SCM_CREDENTIALS___15 = 2
} ;
enum __anonenum_606441560___15 {
    SHUT_RD___15 = 0,
    SHUT_WR___15 = 1,
    SHUT_RDWR___15 = 2
} ;
enum __anonenum_264779956___15 {
    IPPROTO_IP___15 = 0,
    IPPROTO_ICMP___15 = 1,
    IPPROTO_IGMP___15 = 2,
    IPPROTO_IPIP___15 = 4,
    IPPROTO_TCP___15 = 6,
    IPPROTO_EGP___15 = 8,
    IPPROTO_PUP___15 = 12,
    IPPROTO_UDP___15 = 17,
    IPPROTO_IDP___15 = 22,
    IPPROTO_TP___15 = 29,
    IPPROTO_DCCP___15 = 33,
    IPPROTO_IPV6___15 = 41,
    IPPROTO_RSVP___15 = 46,
    IPPROTO_GRE___15 = 47,
    IPPROTO_ESP___15 = 50,
    IPPROTO_AH___15 = 51,
    IPPROTO_MTP___15 = 92,
    IPPROTO_BEETPH___15 = 94,
    IPPROTO_ENCAP___15 = 98,
    IPPROTO_PIM___15 = 103,
    IPPROTO_COMP___15 = 108,
    IPPROTO_SCTP___15 = 132,
    IPPROTO_UDPLITE___15 = 136,
    IPPROTO_MPLS___15 = 137,
    IPPROTO_ETHERNET___15 = 143,
    IPPROTO_RAW___15 = 255,
    IPPROTO_MPTCP___15 = 262,
    IPPROTO_MAX___15 = 263
} ;
enum __anonenum_218739988___15 {
    IPPROTO_HOPOPTS___15 = 0,
    IPPROTO_ROUTING___15 = 43,
    IPPROTO_FRAGMENT___15 = 44,
    IPPROTO_ICMPV6___15 = 58,
    IPPROTO_NONE___15 = 59,
    IPPROTO_DSTOPTS___15 = 60,
    IPPROTO_MH___15 = 135
} ;
enum __anonenum_662268580___15 {
    IPPORT_ECHO___15 = 7,
    IPPORT_DISCARD___15 = 9,
    IPPORT_SYSTAT___15 = 11,
    IPPORT_DAYTIME___15 = 13,
    IPPORT_NETSTAT___15 = 15,
    IPPORT_FTP___15 = 21,
    IPPORT_TELNET___15 = 23,
    IPPORT_SMTP___15 = 25,
    IPPORT_TIMESERVER___15 = 37,
    IPPORT_NAMESERVER___15 = 42,
    IPPORT_WHOIS___15 = 43,
    IPPORT_MTP___15 = 57,
    IPPORT_TFTP___15 = 69,
    IPPORT_RJE___15 = 77,
    IPPORT_FINGER___15 = 79,
    IPPORT_TTYLINK___15 = 87,
    IPPORT_SUPDUP___15 = 95,
    IPPORT_EXECSERVER___15 = 512,
    IPPORT_LOGINSERVER___15 = 513,
    IPPORT_CMDSERVER___15 = 514,
    IPPORT_EFSSERVER___15 = 520,
    IPPORT_BIFFUDP___15 = 512,
    IPPORT_WHOSERVER___15 = 513,
    IPPORT_ROUTESERVER___15 = 520,
    IPPORT_RESERVED___15 = 1024,
    IPPORT_USERRESERVED___15 = 5000
} ;
enum __anonenum_18926444___15 {
    _ISupper___15 = 256,
    _ISlower___15 = 512,
    _ISalpha___15 = 1024,
    _ISdigit___15 = 2048,
    _ISxdigit___15 = 4096,
    _ISspace___15 = 8192,
    _ISprint___15 = 16384,
    _ISgraph___15 = 32768,
    _ISblank___15 = 1,
    _IScntrl___15 = 2,
    _ISpunct___15 = 4,
    _ISalnum___15 = 8
} ;
enum __anonenum_913965969___15 {
    FP_INT_UPWARD___15 = 0,
    FP_INT_DOWNWARD___15 = 1,
    FP_INT_TOWARDZERO___15 = 2,
    FP_INT_TONEARESTFROMZERO___15 = 3,
    FP_INT_TONEAREST___15 = 4
} ;
enum __anonenum_1037408945___15 {
    FP_NAN___15 = 0,
    FP_INFINITE___15 = 1,
    FP_ZERO___15 = 2,
    FP_SUBNORMAL___15 = 3,
    FP_NORMAL___15 = 4
} ;
enum __anonenum_556971655___15 {
    SI_ASYNCNL___15 = -60,
    SI_DETHREAD___15 = -7,
    SI_TKILL___15 = -6,
    SI_SIGIO___15 = -5,
    SI_ASYNCIO___15 = -4,
    SI_MESGQ___15 = -3,
    SI_TIMER___15 = -2,
    SI_QUEUE___15 = -1,
    SI_USER___15 = 0,
    SI_KERNEL___15 = 128
} ;
enum __anonenum_640648963___15 {
    ILL_ILLOPC___15 = 1,
    ILL_ILLOPN___15 = 2,
    ILL_ILLADR___15 = 3,
    ILL_ILLTRP___15 = 4,
    ILL_PRVOPC___15 = 5,
    ILL_PRVREG___15 = 6,
    ILL_COPROC___15 = 7,
    ILL_BADSTK___15 = 8,
    ILL_BADIADDR___15 = 9
} ;
enum __anonenum_457704180___15 {
    FPE_INTDIV___15 = 1,
    FPE_INTOVF___15 = 2,
    FPE_FLTDIV___15 = 3,
    FPE_FLTOVF___15 = 4,
    FPE_FLTUND___15 = 5,
    FPE_FLTRES___15 = 6,
    FPE_FLTINV___15 = 7,
    FPE_FLTSUB___15 = 8,
    FPE_FLTUNK___15 = 14,
    FPE_CONDTRAP___15 = 15
} ;
enum __anonenum_180375148___15 {
    SEGV_MAPERR___15 = 1,
    SEGV_ACCERR___15 = 2,
    SEGV_BNDERR___15 = 3,
    SEGV_PKUERR___15 = 4,
    SEGV_ACCADI___15 = 5,
    SEGV_ADIDERR___15 = 6,
    SEGV_ADIPERR___15 = 7,
    SEGV_MTEAERR___15 = 8,
    SEGV_MTESERR___15 = 9
} ;
enum __anonenum_1036286214___15 {
    BUS_ADRALN___15 = 1,
    BUS_ADRERR___15 = 2,
    BUS_OBJERR___15 = 3,
    BUS_MCEERR_AR___15 = 4,
    BUS_MCEERR_AO___15 = 5
} ;
enum __anonenum_91015150___15 {
    TRAP_BRKPT___15 = 1,
    TRAP_TRACE___15 = 2,
    TRAP_BRANCH___15 = 3,
    TRAP_HWBKPT___15 = 4,
    TRAP_UNK___15 = 5
} ;
enum __anonenum_23175539___15 {
    CLD_EXITED___15 = 1,
    CLD_KILLED___15 = 2,
    CLD_DUMPED___15 = 3,
    CLD_TRAPPED___15 = 4,
    CLD_STOPPED___15 = 5,
    CLD_CONTINUED___15 = 6
} ;
enum __anonenum_111643124___15 {
    POLL_IN___15 = 1,
    POLL_OUT___15 = 2,
    POLL_MSG___15 = 3,
    POLL_ERR___15 = 4,
    POLL_PRI___15 = 5,
    POLL_HUP___15 = 6
} ;
enum __anonenum_852341087___15 {
    SIGEV_SIGNAL___15 = 0,
    SIGEV_NONE___15 = 1,
    SIGEV_THREAD___15 = 2,
    SIGEV_THREAD_ID___15 = 4
} ;
enum __anonenum_451154152___15 {
    REG_R8___15 = 0,
    REG_R9___15 = 1,
    REG_R10___15 = 2,
    REG_R11___15 = 3,
    REG_R12___15 = 4,
    REG_R13___15 = 5,
    REG_R14___15 = 6,
    REG_R15___15 = 7,
    REG_RDI___15 = 8,
    REG_RSI___15 = 9,
    REG_RBP___15 = 10,
    REG_RBX___15 = 11,
    REG_RDX___15 = 12,
    REG_RAX___15 = 13,
    REG_RCX___15 = 14,
    REG_RSP___15 = 15,
    REG_RIP___15 = 16,
    REG_EFL___15 = 17,
    REG_CSGSFS___15 = 18,
    REG_ERR___15 = 19,
    REG_TRAPNO___15 = 20,
    REG_OLDMASK___15 = 21,
    REG_CR2___15 = 22
} ;
enum __anonenum_437032235___15 {
    _PC_LINK_MAX___15 = 0,
    _PC_MAX_CANON___15 = 1,
    _PC_MAX_INPUT___15 = 2,
    _PC_NAME_MAX___15 = 3,
    _PC_PATH_MAX___15 = 4,
    _PC_PIPE_BUF___15 = 5,
    _PC_CHOWN_RESTRICTED___15 = 6,
    _PC_NO_TRUNC___15 = 7,
    _PC_VDISABLE___15 = 8,
    _PC_SYNC_IO___15 = 9,
    _PC_ASYNC_IO___15 = 10,
    _PC_PRIO_IO___15 = 11,
    _PC_SOCK_MAXBUF___15 = 12,
    _PC_FILESIZEBITS___15 = 13,
    _PC_REC_INCR_XFER_SIZE___15 = 14,
    _PC_REC_MAX_XFER_SIZE___15 = 15,
    _PC_REC_MIN_XFER_SIZE___15 = 16,
    _PC_REC_XFER_ALIGN___15 = 17,
    _PC_ALLOC_SIZE_MIN___15 = 18,
    _PC_SYMLINK_MAX___15 = 19,
    _PC_2_SYMLINKS___15 = 20
} ;
enum __anonenum_315186338___15 {
    _SC_ARG_MAX___15 = 0,
    _SC_CHILD_MAX___15 = 1,
    _SC_CLK_TCK___15 = 2,
    _SC_NGROUPS_MAX___15 = 3,
    _SC_OPEN_MAX___15 = 4,
    _SC_STREAM_MAX___15 = 5,
    _SC_TZNAME_MAX___15 = 6,
    _SC_JOB_CONTROL___15 = 7,
    _SC_SAVED_IDS___15 = 8,
    _SC_REALTIME_SIGNALS___15 = 9,
    _SC_PRIORITY_SCHEDULING___15 = 10,
    _SC_TIMERS___15 = 11,
    _SC_ASYNCHRONOUS_IO___15 = 12,
    _SC_PRIORITIZED_IO___15 = 13,
    _SC_SYNCHRONIZED_IO___15 = 14,
    _SC_FSYNC___15 = 15,
    _SC_MAPPED_FILES___15 = 16,
    _SC_MEMLOCK___15 = 17,
    _SC_MEMLOCK_RANGE___15 = 18,
    _SC_MEMORY_PROTECTION___15 = 19,
    _SC_MESSAGE_PASSING___15 = 20,
    _SC_SEMAPHORES___15 = 21,
    _SC_SHARED_MEMORY_OBJECTS___15 = 22,
    _SC_AIO_LISTIO_MAX___15 = 23,
    _SC_AIO_MAX___15 = 24,
    _SC_AIO_PRIO_DELTA_MAX___15 = 25,
    _SC_DELAYTIMER_MAX___15 = 26,
    _SC_MQ_OPEN_MAX___15 = 27,
    _SC_MQ_PRIO_MAX___15 = 28,
    _SC_VERSION___15 = 29,
    _SC_PAGESIZE___15 = 30,
    _SC_RTSIG_MAX___15 = 31,
    _SC_SEM_NSEMS_MAX___15 = 32,
    _SC_SEM_VALUE_MAX___15 = 33,
    _SC_SIGQUEUE_MAX___15 = 34,
    _SC_TIMER_MAX___15 = 35,
    _SC_BC_BASE_MAX___15 = 36,
    _SC_BC_DIM_MAX___15 = 37,
    _SC_BC_SCALE_MAX___15 = 38,
    _SC_BC_STRING_MAX___15 = 39,
    _SC_COLL_WEIGHTS_MAX___15 = 40,
    _SC_EQUIV_CLASS_MAX___15 = 41,
    _SC_EXPR_NEST_MAX___15 = 42,
    _SC_LINE_MAX___15 = 43,
    _SC_RE_DUP_MAX___15 = 44,
    _SC_CHARCLASS_NAME_MAX___15 = 45,
    _SC_2_VERSION___15 = 46,
    _SC_2_C_BIND___15 = 47,
    _SC_2_C_DEV___15 = 48,
    _SC_2_FORT_DEV___15 = 49,
    _SC_2_FORT_RUN___15 = 50,
    _SC_2_SW_DEV___15 = 51,
    _SC_2_LOCALEDEF___15 = 52,
    _SC_PII___15 = 53,
    _SC_PII_XTI___15 = 54,
    _SC_PII_SOCKET___15 = 55,
    _SC_PII_INTERNET___15 = 56,
    _SC_PII_OSI___15 = 57,
    _SC_POLL___15 = 58,
    _SC_SELECT___15 = 59,
    _SC_UIO_MAXIOV___15 = 60,
    _SC_IOV_MAX___15 = 60,
    _SC_PII_INTERNET_STREAM___15 = 61,
    _SC_PII_INTERNET_DGRAM___15 = 62,
    _SC_PII_OSI_COTS___15 = 63,
    _SC_PII_OSI_CLTS___15 = 64,
    _SC_PII_OSI_M___15 = 65,
    _SC_T_IOV_MAX___15 = 66,
    _SC_THREADS___15 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___15 = 68,
    _SC_GETGR_R_SIZE_MAX___15 = 69,
    _SC_GETPW_R_SIZE_MAX___15 = 70,
    _SC_LOGIN_NAME_MAX___15 = 71,
    _SC_TTY_NAME_MAX___15 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___15 = 73,
    _SC_THREAD_KEYS_MAX___15 = 74,
    _SC_THREAD_STACK_MIN___15 = 75,
    _SC_THREAD_THREADS_MAX___15 = 76,
    _SC_THREAD_ATTR_STACKADDR___15 = 77,
    _SC_THREAD_ATTR_STACKSIZE___15 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___15 = 79,
    _SC_THREAD_PRIO_INHERIT___15 = 80,
    _SC_THREAD_PRIO_PROTECT___15 = 81,
    _SC_THREAD_PROCESS_SHARED___15 = 82,
    _SC_NPROCESSORS_CONF___15 = 83,
    _SC_NPROCESSORS_ONLN___15 = 84,
    _SC_PHYS_PAGES___15 = 85,
    _SC_AVPHYS_PAGES___15 = 86,
    _SC_ATEXIT_MAX___15 = 87,
    _SC_PASS_MAX___15 = 88,
    _SC_XOPEN_VERSION___15 = 89,
    _SC_XOPEN_XCU_VERSION___15 = 90,
    _SC_XOPEN_UNIX___15 = 91,
    _SC_XOPEN_CRYPT___15 = 92,
    _SC_XOPEN_ENH_I18N___15 = 93,
    _SC_XOPEN_SHM___15 = 94,
    _SC_2_CHAR_TERM___15 = 95,
    _SC_2_C_VERSION___15 = 96,
    _SC_2_UPE___15 = 97,
    _SC_XOPEN_XPG2___15 = 98,
    _SC_XOPEN_XPG3___15 = 99,
    _SC_XOPEN_XPG4___15 = 100,
    _SC_CHAR_BIT___15 = 101,
    _SC_CHAR_MAX___15 = 102,
    _SC_CHAR_MIN___15 = 103,
    _SC_INT_MAX___15 = 104,
    _SC_INT_MIN___15 = 105,
    _SC_LONG_BIT___15 = 106,
    _SC_WORD_BIT___15 = 107,
    _SC_MB_LEN_MAX___15 = 108,
    _SC_NZERO___15 = 109,
    _SC_SSIZE_MAX___15 = 110,
    _SC_SCHAR_MAX___15 = 111,
    _SC_SCHAR_MIN___15 = 112,
    _SC_SHRT_MAX___15 = 113,
    _SC_SHRT_MIN___15 = 114,
    _SC_UCHAR_MAX___15 = 115,
    _SC_UINT_MAX___15 = 116,
    _SC_ULONG_MAX___15 = 117,
    _SC_USHRT_MAX___15 = 118,
    _SC_NL_ARGMAX___15 = 119,
    _SC_NL_LANGMAX___15 = 120,
    _SC_NL_MSGMAX___15 = 121,
    _SC_NL_NMAX___15 = 122,
    _SC_NL_SETMAX___15 = 123,
    _SC_NL_TEXTMAX___15 = 124,
    _SC_XBS5_ILP32_OFF32___15 = 125,
    _SC_XBS5_ILP32_OFFBIG___15 = 126,
    _SC_XBS5_LP64_OFF64___15 = 127,
    _SC_XBS5_LPBIG_OFFBIG___15 = 128,
    _SC_XOPEN_LEGACY___15 = 129,
    _SC_XOPEN_REALTIME___15 = 130,
    _SC_XOPEN_REALTIME_THREADS___15 = 131,
    _SC_ADVISORY_INFO___15 = 132,
    _SC_BARRIERS___15 = 133,
    _SC_BASE___15 = 134,
    _SC_C_LANG_SUPPORT___15 = 135,
    _SC_C_LANG_SUPPORT_R___15 = 136,
    _SC_CLOCK_SELECTION___15 = 137,
    _SC_CPUTIME___15 = 138,
    _SC_THREAD_CPUTIME___15 = 139,
    _SC_DEVICE_IO___15 = 140,
    _SC_DEVICE_SPECIFIC___15 = 141,
    _SC_DEVICE_SPECIFIC_R___15 = 142,
    _SC_FD_MGMT___15 = 143,
    _SC_FIFO___15 = 144,
    _SC_PIPE___15 = 145,
    _SC_FILE_ATTRIBUTES___15 = 146,
    _SC_FILE_LOCKING___15 = 147,
    _SC_FILE_SYSTEM___15 = 148,
    _SC_MONOTONIC_CLOCK___15 = 149,
    _SC_MULTI_PROCESS___15 = 150,
    _SC_SINGLE_PROCESS___15 = 151,
    _SC_NETWORKING___15 = 152,
    _SC_READER_WRITER_LOCKS___15 = 153,
    _SC_SPIN_LOCKS___15 = 154,
    _SC_REGEXP___15 = 155,
    _SC_REGEX_VERSION___15 = 156,
    _SC_SHELL___15 = 157,
    _SC_SIGNALS___15 = 158,
    _SC_SPAWN___15 = 159,
    _SC_SPORADIC_SERVER___15 = 160,
    _SC_THREAD_SPORADIC_SERVER___15 = 161,
    _SC_SYSTEM_DATABASE___15 = 162,
    _SC_SYSTEM_DATABASE_R___15 = 163,
    _SC_TIMEOUTS___15 = 164,
    _SC_TYPED_MEMORY_OBJECTS___15 = 165,
    _SC_USER_GROUPS___15 = 166,
    _SC_USER_GROUPS_R___15 = 167,
    _SC_2_PBS___15 = 168,
    _SC_2_PBS_ACCOUNTING___15 = 169,
    _SC_2_PBS_LOCATE___15 = 170,
    _SC_2_PBS_MESSAGE___15 = 171,
    _SC_2_PBS_TRACK___15 = 172,
    _SC_SYMLOOP_MAX___15 = 173,
    _SC_STREAMS___15 = 174,
    _SC_2_PBS_CHECKPOINT___15 = 175,
    _SC_V6_ILP32_OFF32___15 = 176,
    _SC_V6_ILP32_OFFBIG___15 = 177,
    _SC_V6_LP64_OFF64___15 = 178,
    _SC_V6_LPBIG_OFFBIG___15 = 179,
    _SC_HOST_NAME_MAX___15 = 180,
    _SC_TRACE___15 = 181,
    _SC_TRACE_EVENT_FILTER___15 = 182,
    _SC_TRACE_INHERIT___15 = 183,
    _SC_TRACE_LOG___15 = 184,
    _SC_LEVEL1_ICACHE_SIZE___15 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___15 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___15 = 187,
    _SC_LEVEL1_DCACHE_SIZE___15 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___15 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___15 = 190,
    _SC_LEVEL2_CACHE_SIZE___15 = 191,
    _SC_LEVEL2_CACHE_ASSOC___15 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___15 = 193,
    _SC_LEVEL3_CACHE_SIZE___15 = 194,
    _SC_LEVEL3_CACHE_ASSOC___15 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___15 = 196,
    _SC_LEVEL4_CACHE_SIZE___15 = 197,
    _SC_LEVEL4_CACHE_ASSOC___15 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___15 = 199,
    _SC_IPV6___15 = 235,
    _SC_RAW_SOCKETS___15 = 236,
    _SC_V7_ILP32_OFF32___15 = 237,
    _SC_V7_ILP32_OFFBIG___15 = 238,
    _SC_V7_LP64_OFF64___15 = 239,
    _SC_V7_LPBIG_OFFBIG___15 = 240,
    _SC_SS_REPL_MAX___15 = 241,
    _SC_TRACE_EVENT_NAME_MAX___15 = 242,
    _SC_TRACE_NAME_MAX___15 = 243,
    _SC_TRACE_SYS_MAX___15 = 244,
    _SC_TRACE_USER_EVENT_MAX___15 = 245,
    _SC_XOPEN_STREAMS___15 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___15 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___15 = 248,
    _SC_MINSIGSTKSZ___15 = 249,
    _SC_SIGSTKSZ___15 = 250
} ;
enum __anonenum_875524036___15 {
    _CS_PATH___15 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___15 = 1,
    _CS_GNU_LIBC_VERSION___15 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___15 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___15 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___15 = 5,
    _CS_LFS_CFLAGS___15 = 1000,
    _CS_LFS_LDFLAGS___15 = 1001,
    _CS_LFS_LIBS___15 = 1002,
    _CS_LFS_LINTFLAGS___15 = 1003,
    _CS_LFS64_CFLAGS___15 = 1004,
    _CS_LFS64_LDFLAGS___15 = 1005,
    _CS_LFS64_LIBS___15 = 1006,
    _CS_LFS64_LINTFLAGS___15 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___15 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___15 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___15 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___15 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___15 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___15 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___15 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___15 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___15 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___15 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___15 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___15 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___15 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___15 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___15 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___15 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___15 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___15 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___15 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___15 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___15 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___15 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___15 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___15 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___15 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___15 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___15 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___15 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___15 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___15 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___15 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___15 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___15 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___15 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___15 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___15 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___15 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___15 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___15 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___15 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___15 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___15 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___15 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___15 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___15 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___15 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___15 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___15 = 1147,
    _CS_V6_ENV___15 = 1148,
    _CS_V7_ENV___15 = 1149
} ;
enum __anonenum_57186863___15 {
    SS_ONSTACK___15 = 1,
    SS_DISABLE___15 = 2
} ;
struct stage {
   double wander ;
   double length ;
};
enum __anonenum_83571709___16 {
    MSG_OOB___16 = 1,
    MSG_PEEK___16 = 2,
    MSG_DONTROUTE___16 = 4,
    MSG_TRYHARD___16 = 4,
    MSG_CTRUNC___16 = 8,
    MSG_PROXY___16 = 16,
    MSG_TRUNC___16 = 32,
    MSG_DONTWAIT___16 = 64,
    MSG_EOR___16 = 128,
    MSG_WAITALL___16 = 256,
    MSG_FIN___16 = 512,
    MSG_SYN___16 = 1024,
    MSG_CONFIRM___16 = 2048,
    MSG_RST___16 = 4096,
    MSG_ERRQUEUE___16 = 8192,
    MSG_NOSIGNAL___16 = 16384,
    MSG_MORE___16 = 32768,
    MSG_WAITFORONE___16 = 65536,
    MSG_BATCH___16 = 262144,
    MSG_ZEROCOPY___16 = 67108864,
    MSG_FASTOPEN___16 = 536870912,
    MSG_CMSG_CLOEXEC___16 = 1073741824
} ;
enum __anonenum_617082774___16 {
    SCM_RIGHTS___16 = 1,
    SCM_CREDENTIALS___16 = 2
} ;
enum __anonenum_606441560___16 {
    SHUT_RD___16 = 0,
    SHUT_WR___16 = 1,
    SHUT_RDWR___16 = 2
} ;
enum __anonenum_264779956___16 {
    IPPROTO_IP___16 = 0,
    IPPROTO_ICMP___16 = 1,
    IPPROTO_IGMP___16 = 2,
    IPPROTO_IPIP___16 = 4,
    IPPROTO_TCP___16 = 6,
    IPPROTO_EGP___16 = 8,
    IPPROTO_PUP___16 = 12,
    IPPROTO_UDP___16 = 17,
    IPPROTO_IDP___16 = 22,
    IPPROTO_TP___16 = 29,
    IPPROTO_DCCP___16 = 33,
    IPPROTO_IPV6___16 = 41,
    IPPROTO_RSVP___16 = 46,
    IPPROTO_GRE___16 = 47,
    IPPROTO_ESP___16 = 50,
    IPPROTO_AH___16 = 51,
    IPPROTO_MTP___16 = 92,
    IPPROTO_BEETPH___16 = 94,
    IPPROTO_ENCAP___16 = 98,
    IPPROTO_PIM___16 = 103,
    IPPROTO_COMP___16 = 108,
    IPPROTO_SCTP___16 = 132,
    IPPROTO_UDPLITE___16 = 136,
    IPPROTO_MPLS___16 = 137,
    IPPROTO_ETHERNET___16 = 143,
    IPPROTO_RAW___16 = 255,
    IPPROTO_MPTCP___16 = 262,
    IPPROTO_MAX___16 = 263
} ;
enum __anonenum_218739988___16 {
    IPPROTO_HOPOPTS___16 = 0,
    IPPROTO_ROUTING___16 = 43,
    IPPROTO_FRAGMENT___16 = 44,
    IPPROTO_ICMPV6___16 = 58,
    IPPROTO_NONE___16 = 59,
    IPPROTO_DSTOPTS___16 = 60,
    IPPROTO_MH___16 = 135
} ;
enum __anonenum_662268580___16 {
    IPPORT_ECHO___16 = 7,
    IPPORT_DISCARD___16 = 9,
    IPPORT_SYSTAT___16 = 11,
    IPPORT_DAYTIME___16 = 13,
    IPPORT_NETSTAT___16 = 15,
    IPPORT_FTP___16 = 21,
    IPPORT_TELNET___16 = 23,
    IPPORT_SMTP___16 = 25,
    IPPORT_TIMESERVER___16 = 37,
    IPPORT_NAMESERVER___16 = 42,
    IPPORT_WHOIS___16 = 43,
    IPPORT_MTP___16 = 57,
    IPPORT_TFTP___16 = 69,
    IPPORT_RJE___16 = 77,
    IPPORT_FINGER___16 = 79,
    IPPORT_TTYLINK___16 = 87,
    IPPORT_SUPDUP___16 = 95,
    IPPORT_EXECSERVER___16 = 512,
    IPPORT_LOGINSERVER___16 = 513,
    IPPORT_CMDSERVER___16 = 514,
    IPPORT_EFSSERVER___16 = 520,
    IPPORT_BIFFUDP___16 = 512,
    IPPORT_WHOSERVER___16 = 513,
    IPPORT_ROUTESERVER___16 = 520,
    IPPORT_RESERVED___16 = 1024,
    IPPORT_USERRESERVED___16 = 5000
} ;
enum __anonenum_18926444___16 {
    _ISupper___16 = 256,
    _ISlower___16 = 512,
    _ISalpha___16 = 1024,
    _ISdigit___16 = 2048,
    _ISxdigit___16 = 4096,
    _ISspace___16 = 8192,
    _ISprint___16 = 16384,
    _ISgraph___16 = 32768,
    _ISblank___16 = 1,
    _IScntrl___16 = 2,
    _ISpunct___16 = 4,
    _ISalnum___16 = 8
} ;
enum __anonenum_913965969___16 {
    FP_INT_UPWARD___16 = 0,
    FP_INT_DOWNWARD___16 = 1,
    FP_INT_TOWARDZERO___16 = 2,
    FP_INT_TONEARESTFROMZERO___16 = 3,
    FP_INT_TONEAREST___16 = 4
} ;
enum __anonenum_1037408945___16 {
    FP_NAN___16 = 0,
    FP_INFINITE___16 = 1,
    FP_ZERO___16 = 2,
    FP_SUBNORMAL___16 = 3,
    FP_NORMAL___16 = 4
} ;
enum __anonenum_556971655___16 {
    SI_ASYNCNL___16 = -60,
    SI_DETHREAD___16 = -7,
    SI_TKILL___16 = -6,
    SI_SIGIO___16 = -5,
    SI_ASYNCIO___16 = -4,
    SI_MESGQ___16 = -3,
    SI_TIMER___16 = -2,
    SI_QUEUE___16 = -1,
    SI_USER___16 = 0,
    SI_KERNEL___16 = 128
} ;
enum __anonenum_640648963___16 {
    ILL_ILLOPC___16 = 1,
    ILL_ILLOPN___16 = 2,
    ILL_ILLADR___16 = 3,
    ILL_ILLTRP___16 = 4,
    ILL_PRVOPC___16 = 5,
    ILL_PRVREG___16 = 6,
    ILL_COPROC___16 = 7,
    ILL_BADSTK___16 = 8,
    ILL_BADIADDR___16 = 9
} ;
enum __anonenum_457704180___16 {
    FPE_INTDIV___16 = 1,
    FPE_INTOVF___16 = 2,
    FPE_FLTDIV___16 = 3,
    FPE_FLTOVF___16 = 4,
    FPE_FLTUND___16 = 5,
    FPE_FLTRES___16 = 6,
    FPE_FLTINV___16 = 7,
    FPE_FLTSUB___16 = 8,
    FPE_FLTUNK___16 = 14,
    FPE_CONDTRAP___16 = 15
} ;
enum __anonenum_180375148___16 {
    SEGV_MAPERR___16 = 1,
    SEGV_ACCERR___16 = 2,
    SEGV_BNDERR___16 = 3,
    SEGV_PKUERR___16 = 4,
    SEGV_ACCADI___16 = 5,
    SEGV_ADIDERR___16 = 6,
    SEGV_ADIPERR___16 = 7,
    SEGV_MTEAERR___16 = 8,
    SEGV_MTESERR___16 = 9
} ;
enum __anonenum_1036286214___16 {
    BUS_ADRALN___16 = 1,
    BUS_ADRERR___16 = 2,
    BUS_OBJERR___16 = 3,
    BUS_MCEERR_AR___16 = 4,
    BUS_MCEERR_AO___16 = 5
} ;
enum __anonenum_91015150___16 {
    TRAP_BRKPT___16 = 1,
    TRAP_TRACE___16 = 2,
    TRAP_BRANCH___16 = 3,
    TRAP_HWBKPT___16 = 4,
    TRAP_UNK___16 = 5
} ;
enum __anonenum_23175539___16 {
    CLD_EXITED___16 = 1,
    CLD_KILLED___16 = 2,
    CLD_DUMPED___16 = 3,
    CLD_TRAPPED___16 = 4,
    CLD_STOPPED___16 = 5,
    CLD_CONTINUED___16 = 6
} ;
enum __anonenum_111643124___16 {
    POLL_IN___16 = 1,
    POLL_OUT___16 = 2,
    POLL_MSG___16 = 3,
    POLL_ERR___16 = 4,
    POLL_PRI___16 = 5,
    POLL_HUP___16 = 6
} ;
enum __anonenum_852341087___16 {
    SIGEV_SIGNAL___16 = 0,
    SIGEV_NONE___16 = 1,
    SIGEV_THREAD___16 = 2,
    SIGEV_THREAD_ID___16 = 4
} ;
enum __anonenum_451154152___16 {
    REG_R8___16 = 0,
    REG_R9___16 = 1,
    REG_R10___16 = 2,
    REG_R11___16 = 3,
    REG_R12___16 = 4,
    REG_R13___16 = 5,
    REG_R14___16 = 6,
    REG_R15___16 = 7,
    REG_RDI___16 = 8,
    REG_RSI___16 = 9,
    REG_RBP___16 = 10,
    REG_RBX___16 = 11,
    REG_RDX___16 = 12,
    REG_RAX___16 = 13,
    REG_RCX___16 = 14,
    REG_RSP___16 = 15,
    REG_RIP___16 = 16,
    REG_EFL___16 = 17,
    REG_CSGSFS___16 = 18,
    REG_ERR___16 = 19,
    REG_TRAPNO___16 = 20,
    REG_OLDMASK___16 = 21,
    REG_CR2___16 = 22
} ;
enum __anonenum_437032235___16 {
    _PC_LINK_MAX___16 = 0,
    _PC_MAX_CANON___16 = 1,
    _PC_MAX_INPUT___16 = 2,
    _PC_NAME_MAX___16 = 3,
    _PC_PATH_MAX___16 = 4,
    _PC_PIPE_BUF___16 = 5,
    _PC_CHOWN_RESTRICTED___16 = 6,
    _PC_NO_TRUNC___16 = 7,
    _PC_VDISABLE___16 = 8,
    _PC_SYNC_IO___16 = 9,
    _PC_ASYNC_IO___16 = 10,
    _PC_PRIO_IO___16 = 11,
    _PC_SOCK_MAXBUF___16 = 12,
    _PC_FILESIZEBITS___16 = 13,
    _PC_REC_INCR_XFER_SIZE___16 = 14,
    _PC_REC_MAX_XFER_SIZE___16 = 15,
    _PC_REC_MIN_XFER_SIZE___16 = 16,
    _PC_REC_XFER_ALIGN___16 = 17,
    _PC_ALLOC_SIZE_MIN___16 = 18,
    _PC_SYMLINK_MAX___16 = 19,
    _PC_2_SYMLINKS___16 = 20
} ;
enum __anonenum_315186338___16 {
    _SC_ARG_MAX___16 = 0,
    _SC_CHILD_MAX___16 = 1,
    _SC_CLK_TCK___16 = 2,
    _SC_NGROUPS_MAX___16 = 3,
    _SC_OPEN_MAX___16 = 4,
    _SC_STREAM_MAX___16 = 5,
    _SC_TZNAME_MAX___16 = 6,
    _SC_JOB_CONTROL___16 = 7,
    _SC_SAVED_IDS___16 = 8,
    _SC_REALTIME_SIGNALS___16 = 9,
    _SC_PRIORITY_SCHEDULING___16 = 10,
    _SC_TIMERS___16 = 11,
    _SC_ASYNCHRONOUS_IO___16 = 12,
    _SC_PRIORITIZED_IO___16 = 13,
    _SC_SYNCHRONIZED_IO___16 = 14,
    _SC_FSYNC___16 = 15,
    _SC_MAPPED_FILES___16 = 16,
    _SC_MEMLOCK___16 = 17,
    _SC_MEMLOCK_RANGE___16 = 18,
    _SC_MEMORY_PROTECTION___16 = 19,
    _SC_MESSAGE_PASSING___16 = 20,
    _SC_SEMAPHORES___16 = 21,
    _SC_SHARED_MEMORY_OBJECTS___16 = 22,
    _SC_AIO_LISTIO_MAX___16 = 23,
    _SC_AIO_MAX___16 = 24,
    _SC_AIO_PRIO_DELTA_MAX___16 = 25,
    _SC_DELAYTIMER_MAX___16 = 26,
    _SC_MQ_OPEN_MAX___16 = 27,
    _SC_MQ_PRIO_MAX___16 = 28,
    _SC_VERSION___16 = 29,
    _SC_PAGESIZE___16 = 30,
    _SC_RTSIG_MAX___16 = 31,
    _SC_SEM_NSEMS_MAX___16 = 32,
    _SC_SEM_VALUE_MAX___16 = 33,
    _SC_SIGQUEUE_MAX___16 = 34,
    _SC_TIMER_MAX___16 = 35,
    _SC_BC_BASE_MAX___16 = 36,
    _SC_BC_DIM_MAX___16 = 37,
    _SC_BC_SCALE_MAX___16 = 38,
    _SC_BC_STRING_MAX___16 = 39,
    _SC_COLL_WEIGHTS_MAX___16 = 40,
    _SC_EQUIV_CLASS_MAX___16 = 41,
    _SC_EXPR_NEST_MAX___16 = 42,
    _SC_LINE_MAX___16 = 43,
    _SC_RE_DUP_MAX___16 = 44,
    _SC_CHARCLASS_NAME_MAX___16 = 45,
    _SC_2_VERSION___16 = 46,
    _SC_2_C_BIND___16 = 47,
    _SC_2_C_DEV___16 = 48,
    _SC_2_FORT_DEV___16 = 49,
    _SC_2_FORT_RUN___16 = 50,
    _SC_2_SW_DEV___16 = 51,
    _SC_2_LOCALEDEF___16 = 52,
    _SC_PII___16 = 53,
    _SC_PII_XTI___16 = 54,
    _SC_PII_SOCKET___16 = 55,
    _SC_PII_INTERNET___16 = 56,
    _SC_PII_OSI___16 = 57,
    _SC_POLL___16 = 58,
    _SC_SELECT___16 = 59,
    _SC_UIO_MAXIOV___16 = 60,
    _SC_IOV_MAX___16 = 60,
    _SC_PII_INTERNET_STREAM___16 = 61,
    _SC_PII_INTERNET_DGRAM___16 = 62,
    _SC_PII_OSI_COTS___16 = 63,
    _SC_PII_OSI_CLTS___16 = 64,
    _SC_PII_OSI_M___16 = 65,
    _SC_T_IOV_MAX___16 = 66,
    _SC_THREADS___16 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___16 = 68,
    _SC_GETGR_R_SIZE_MAX___16 = 69,
    _SC_GETPW_R_SIZE_MAX___16 = 70,
    _SC_LOGIN_NAME_MAX___16 = 71,
    _SC_TTY_NAME_MAX___16 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___16 = 73,
    _SC_THREAD_KEYS_MAX___16 = 74,
    _SC_THREAD_STACK_MIN___16 = 75,
    _SC_THREAD_THREADS_MAX___16 = 76,
    _SC_THREAD_ATTR_STACKADDR___16 = 77,
    _SC_THREAD_ATTR_STACKSIZE___16 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___16 = 79,
    _SC_THREAD_PRIO_INHERIT___16 = 80,
    _SC_THREAD_PRIO_PROTECT___16 = 81,
    _SC_THREAD_PROCESS_SHARED___16 = 82,
    _SC_NPROCESSORS_CONF___16 = 83,
    _SC_NPROCESSORS_ONLN___16 = 84,
    _SC_PHYS_PAGES___16 = 85,
    _SC_AVPHYS_PAGES___16 = 86,
    _SC_ATEXIT_MAX___16 = 87,
    _SC_PASS_MAX___16 = 88,
    _SC_XOPEN_VERSION___16 = 89,
    _SC_XOPEN_XCU_VERSION___16 = 90,
    _SC_XOPEN_UNIX___16 = 91,
    _SC_XOPEN_CRYPT___16 = 92,
    _SC_XOPEN_ENH_I18N___16 = 93,
    _SC_XOPEN_SHM___16 = 94,
    _SC_2_CHAR_TERM___16 = 95,
    _SC_2_C_VERSION___16 = 96,
    _SC_2_UPE___16 = 97,
    _SC_XOPEN_XPG2___16 = 98,
    _SC_XOPEN_XPG3___16 = 99,
    _SC_XOPEN_XPG4___16 = 100,
    _SC_CHAR_BIT___16 = 101,
    _SC_CHAR_MAX___16 = 102,
    _SC_CHAR_MIN___16 = 103,
    _SC_INT_MAX___16 = 104,
    _SC_INT_MIN___16 = 105,
    _SC_LONG_BIT___16 = 106,
    _SC_WORD_BIT___16 = 107,
    _SC_MB_LEN_MAX___16 = 108,
    _SC_NZERO___16 = 109,
    _SC_SSIZE_MAX___16 = 110,
    _SC_SCHAR_MAX___16 = 111,
    _SC_SCHAR_MIN___16 = 112,
    _SC_SHRT_MAX___16 = 113,
    _SC_SHRT_MIN___16 = 114,
    _SC_UCHAR_MAX___16 = 115,
    _SC_UINT_MAX___16 = 116,
    _SC_ULONG_MAX___16 = 117,
    _SC_USHRT_MAX___16 = 118,
    _SC_NL_ARGMAX___16 = 119,
    _SC_NL_LANGMAX___16 = 120,
    _SC_NL_MSGMAX___16 = 121,
    _SC_NL_NMAX___16 = 122,
    _SC_NL_SETMAX___16 = 123,
    _SC_NL_TEXTMAX___16 = 124,
    _SC_XBS5_ILP32_OFF32___16 = 125,
    _SC_XBS5_ILP32_OFFBIG___16 = 126,
    _SC_XBS5_LP64_OFF64___16 = 127,
    _SC_XBS5_LPBIG_OFFBIG___16 = 128,
    _SC_XOPEN_LEGACY___16 = 129,
    _SC_XOPEN_REALTIME___16 = 130,
    _SC_XOPEN_REALTIME_THREADS___16 = 131,
    _SC_ADVISORY_INFO___16 = 132,
    _SC_BARRIERS___16 = 133,
    _SC_BASE___16 = 134,
    _SC_C_LANG_SUPPORT___16 = 135,
    _SC_C_LANG_SUPPORT_R___16 = 136,
    _SC_CLOCK_SELECTION___16 = 137,
    _SC_CPUTIME___16 = 138,
    _SC_THREAD_CPUTIME___16 = 139,
    _SC_DEVICE_IO___16 = 140,
    _SC_DEVICE_SPECIFIC___16 = 141,
    _SC_DEVICE_SPECIFIC_R___16 = 142,
    _SC_FD_MGMT___16 = 143,
    _SC_FIFO___16 = 144,
    _SC_PIPE___16 = 145,
    _SC_FILE_ATTRIBUTES___16 = 146,
    _SC_FILE_LOCKING___16 = 147,
    _SC_FILE_SYSTEM___16 = 148,
    _SC_MONOTONIC_CLOCK___16 = 149,
    _SC_MULTI_PROCESS___16 = 150,
    _SC_SINGLE_PROCESS___16 = 151,
    _SC_NETWORKING___16 = 152,
    _SC_READER_WRITER_LOCKS___16 = 153,
    _SC_SPIN_LOCKS___16 = 154,
    _SC_REGEXP___16 = 155,
    _SC_REGEX_VERSION___16 = 156,
    _SC_SHELL___16 = 157,
    _SC_SIGNALS___16 = 158,
    _SC_SPAWN___16 = 159,
    _SC_SPORADIC_SERVER___16 = 160,
    _SC_THREAD_SPORADIC_SERVER___16 = 161,
    _SC_SYSTEM_DATABASE___16 = 162,
    _SC_SYSTEM_DATABASE_R___16 = 163,
    _SC_TIMEOUTS___16 = 164,
    _SC_TYPED_MEMORY_OBJECTS___16 = 165,
    _SC_USER_GROUPS___16 = 166,
    _SC_USER_GROUPS_R___16 = 167,
    _SC_2_PBS___16 = 168,
    _SC_2_PBS_ACCOUNTING___16 = 169,
    _SC_2_PBS_LOCATE___16 = 170,
    _SC_2_PBS_MESSAGE___16 = 171,
    _SC_2_PBS_TRACK___16 = 172,
    _SC_SYMLOOP_MAX___16 = 173,
    _SC_STREAMS___16 = 174,
    _SC_2_PBS_CHECKPOINT___16 = 175,
    _SC_V6_ILP32_OFF32___16 = 176,
    _SC_V6_ILP32_OFFBIG___16 = 177,
    _SC_V6_LP64_OFF64___16 = 178,
    _SC_V6_LPBIG_OFFBIG___16 = 179,
    _SC_HOST_NAME_MAX___16 = 180,
    _SC_TRACE___16 = 181,
    _SC_TRACE_EVENT_FILTER___16 = 182,
    _SC_TRACE_INHERIT___16 = 183,
    _SC_TRACE_LOG___16 = 184,
    _SC_LEVEL1_ICACHE_SIZE___16 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___16 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___16 = 187,
    _SC_LEVEL1_DCACHE_SIZE___16 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___16 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___16 = 190,
    _SC_LEVEL2_CACHE_SIZE___16 = 191,
    _SC_LEVEL2_CACHE_ASSOC___16 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___16 = 193,
    _SC_LEVEL3_CACHE_SIZE___16 = 194,
    _SC_LEVEL3_CACHE_ASSOC___16 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___16 = 196,
    _SC_LEVEL4_CACHE_SIZE___16 = 197,
    _SC_LEVEL4_CACHE_ASSOC___16 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___16 = 199,
    _SC_IPV6___16 = 235,
    _SC_RAW_SOCKETS___16 = 236,
    _SC_V7_ILP32_OFF32___16 = 237,
    _SC_V7_ILP32_OFFBIG___16 = 238,
    _SC_V7_LP64_OFF64___16 = 239,
    _SC_V7_LPBIG_OFFBIG___16 = 240,
    _SC_SS_REPL_MAX___16 = 241,
    _SC_TRACE_EVENT_NAME_MAX___16 = 242,
    _SC_TRACE_NAME_MAX___16 = 243,
    _SC_TRACE_SYS_MAX___16 = 244,
    _SC_TRACE_USER_EVENT_MAX___16 = 245,
    _SC_XOPEN_STREAMS___16 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___16 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___16 = 248,
    _SC_MINSIGSTKSZ___16 = 249,
    _SC_SIGSTKSZ___16 = 250
} ;
enum __anonenum_875524036___16 {
    _CS_PATH___16 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___16 = 1,
    _CS_GNU_LIBC_VERSION___16 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___16 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___16 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___16 = 5,
    _CS_LFS_CFLAGS___16 = 1000,
    _CS_LFS_LDFLAGS___16 = 1001,
    _CS_LFS_LIBS___16 = 1002,
    _CS_LFS_LINTFLAGS___16 = 1003,
    _CS_LFS64_CFLAGS___16 = 1004,
    _CS_LFS64_LDFLAGS___16 = 1005,
    _CS_LFS64_LIBS___16 = 1006,
    _CS_LFS64_LINTFLAGS___16 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___16 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___16 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___16 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___16 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___16 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___16 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___16 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___16 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___16 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___16 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___16 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___16 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___16 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___16 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___16 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___16 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___16 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___16 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___16 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___16 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___16 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___16 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___16 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___16 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___16 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___16 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___16 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___16 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___16 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___16 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___16 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___16 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___16 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___16 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___16 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___16 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___16 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___16 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___16 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___16 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___16 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___16 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___16 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___16 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___16 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___16 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___16 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___16 = 1147,
    _CS_V6_ENV___16 = 1148,
    _CS_V7_ENV___16 = 1149
} ;
enum __anonenum_57186863___16 {
    SS_ONSTACK___16 = 1,
    SS_DISABLE___16 = 2
} ;
enum __anonenum_83571709___17 {
    MSG_OOB___17 = 1,
    MSG_PEEK___17 = 2,
    MSG_DONTROUTE___17 = 4,
    MSG_TRYHARD___17 = 4,
    MSG_CTRUNC___17 = 8,
    MSG_PROXY___17 = 16,
    MSG_TRUNC___17 = 32,
    MSG_DONTWAIT___17 = 64,
    MSG_EOR___17 = 128,
    MSG_WAITALL___17 = 256,
    MSG_FIN___17 = 512,
    MSG_SYN___17 = 1024,
    MSG_CONFIRM___17 = 2048,
    MSG_RST___17 = 4096,
    MSG_ERRQUEUE___17 = 8192,
    MSG_NOSIGNAL___17 = 16384,
    MSG_MORE___17 = 32768,
    MSG_WAITFORONE___17 = 65536,
    MSG_BATCH___17 = 262144,
    MSG_ZEROCOPY___17 = 67108864,
    MSG_FASTOPEN___17 = 536870912,
    MSG_CMSG_CLOEXEC___17 = 1073741824
} ;
enum __anonenum_617082774___17 {
    SCM_RIGHTS___17 = 1,
    SCM_CREDENTIALS___17 = 2
} ;
enum __anonenum_606441560___17 {
    SHUT_RD___17 = 0,
    SHUT_WR___17 = 1,
    SHUT_RDWR___17 = 2
} ;
enum __anonenum_264779956___17 {
    IPPROTO_IP___17 = 0,
    IPPROTO_ICMP___17 = 1,
    IPPROTO_IGMP___17 = 2,
    IPPROTO_IPIP___17 = 4,
    IPPROTO_TCP___17 = 6,
    IPPROTO_EGP___17 = 8,
    IPPROTO_PUP___17 = 12,
    IPPROTO_UDP___17 = 17,
    IPPROTO_IDP___17 = 22,
    IPPROTO_TP___17 = 29,
    IPPROTO_DCCP___17 = 33,
    IPPROTO_IPV6___17 = 41,
    IPPROTO_RSVP___17 = 46,
    IPPROTO_GRE___17 = 47,
    IPPROTO_ESP___17 = 50,
    IPPROTO_AH___17 = 51,
    IPPROTO_MTP___17 = 92,
    IPPROTO_BEETPH___17 = 94,
    IPPROTO_ENCAP___17 = 98,
    IPPROTO_PIM___17 = 103,
    IPPROTO_COMP___17 = 108,
    IPPROTO_SCTP___17 = 132,
    IPPROTO_UDPLITE___17 = 136,
    IPPROTO_MPLS___17 = 137,
    IPPROTO_ETHERNET___17 = 143,
    IPPROTO_RAW___17 = 255,
    IPPROTO_MPTCP___17 = 262,
    IPPROTO_MAX___17 = 263
} ;
enum __anonenum_218739988___17 {
    IPPROTO_HOPOPTS___17 = 0,
    IPPROTO_ROUTING___17 = 43,
    IPPROTO_FRAGMENT___17 = 44,
    IPPROTO_ICMPV6___17 = 58,
    IPPROTO_NONE___17 = 59,
    IPPROTO_DSTOPTS___17 = 60,
    IPPROTO_MH___17 = 135
} ;
enum __anonenum_662268580___17 {
    IPPORT_ECHO___17 = 7,
    IPPORT_DISCARD___17 = 9,
    IPPORT_SYSTAT___17 = 11,
    IPPORT_DAYTIME___17 = 13,
    IPPORT_NETSTAT___17 = 15,
    IPPORT_FTP___17 = 21,
    IPPORT_TELNET___17 = 23,
    IPPORT_SMTP___17 = 25,
    IPPORT_TIMESERVER___17 = 37,
    IPPORT_NAMESERVER___17 = 42,
    IPPORT_WHOIS___17 = 43,
    IPPORT_MTP___17 = 57,
    IPPORT_TFTP___17 = 69,
    IPPORT_RJE___17 = 77,
    IPPORT_FINGER___17 = 79,
    IPPORT_TTYLINK___17 = 87,
    IPPORT_SUPDUP___17 = 95,
    IPPORT_EXECSERVER___17 = 512,
    IPPORT_LOGINSERVER___17 = 513,
    IPPORT_CMDSERVER___17 = 514,
    IPPORT_EFSSERVER___17 = 520,
    IPPORT_BIFFUDP___17 = 512,
    IPPORT_WHOSERVER___17 = 513,
    IPPORT_ROUTESERVER___17 = 520,
    IPPORT_RESERVED___17 = 1024,
    IPPORT_USERRESERVED___17 = 5000
} ;
enum __anonenum_18926444___17 {
    _ISupper___17 = 256,
    _ISlower___17 = 512,
    _ISalpha___17 = 1024,
    _ISdigit___17 = 2048,
    _ISxdigit___17 = 4096,
    _ISspace___17 = 8192,
    _ISprint___17 = 16384,
    _ISgraph___17 = 32768,
    _ISblank___17 = 1,
    _IScntrl___17 = 2,
    _ISpunct___17 = 4,
    _ISalnum___17 = 8
} ;
enum __anonenum_913965969___17 {
    FP_INT_UPWARD___17 = 0,
    FP_INT_DOWNWARD___17 = 1,
    FP_INT_TOWARDZERO___17 = 2,
    FP_INT_TONEARESTFROMZERO___17 = 3,
    FP_INT_TONEAREST___17 = 4
} ;
enum __anonenum_1037408945___17 {
    FP_NAN___17 = 0,
    FP_INFINITE___17 = 1,
    FP_ZERO___17 = 2,
    FP_SUBNORMAL___17 = 3,
    FP_NORMAL___17 = 4
} ;
enum __anonenum_556971655___17 {
    SI_ASYNCNL___17 = -60,
    SI_DETHREAD___17 = -7,
    SI_TKILL___17 = -6,
    SI_SIGIO___17 = -5,
    SI_ASYNCIO___17 = -4,
    SI_MESGQ___17 = -3,
    SI_TIMER___17 = -2,
    SI_QUEUE___17 = -1,
    SI_USER___17 = 0,
    SI_KERNEL___17 = 128
} ;
enum __anonenum_640648963___17 {
    ILL_ILLOPC___17 = 1,
    ILL_ILLOPN___17 = 2,
    ILL_ILLADR___17 = 3,
    ILL_ILLTRP___17 = 4,
    ILL_PRVOPC___17 = 5,
    ILL_PRVREG___17 = 6,
    ILL_COPROC___17 = 7,
    ILL_BADSTK___17 = 8,
    ILL_BADIADDR___17 = 9
} ;
enum __anonenum_457704180___17 {
    FPE_INTDIV___17 = 1,
    FPE_INTOVF___17 = 2,
    FPE_FLTDIV___17 = 3,
    FPE_FLTOVF___17 = 4,
    FPE_FLTUND___17 = 5,
    FPE_FLTRES___17 = 6,
    FPE_FLTINV___17 = 7,
    FPE_FLTSUB___17 = 8,
    FPE_FLTUNK___17 = 14,
    FPE_CONDTRAP___17 = 15
} ;
enum __anonenum_180375148___17 {
    SEGV_MAPERR___17 = 1,
    SEGV_ACCERR___17 = 2,
    SEGV_BNDERR___17 = 3,
    SEGV_PKUERR___17 = 4,
    SEGV_ACCADI___17 = 5,
    SEGV_ADIDERR___17 = 6,
    SEGV_ADIPERR___17 = 7,
    SEGV_MTEAERR___17 = 8,
    SEGV_MTESERR___17 = 9
} ;
enum __anonenum_1036286214___17 {
    BUS_ADRALN___17 = 1,
    BUS_ADRERR___17 = 2,
    BUS_OBJERR___17 = 3,
    BUS_MCEERR_AR___17 = 4,
    BUS_MCEERR_AO___17 = 5
} ;
enum __anonenum_91015150___17 {
    TRAP_BRKPT___17 = 1,
    TRAP_TRACE___17 = 2,
    TRAP_BRANCH___17 = 3,
    TRAP_HWBKPT___17 = 4,
    TRAP_UNK___17 = 5
} ;
enum __anonenum_23175539___17 {
    CLD_EXITED___17 = 1,
    CLD_KILLED___17 = 2,
    CLD_DUMPED___17 = 3,
    CLD_TRAPPED___17 = 4,
    CLD_STOPPED___17 = 5,
    CLD_CONTINUED___17 = 6
} ;
enum __anonenum_111643124___17 {
    POLL_IN___17 = 1,
    POLL_OUT___17 = 2,
    POLL_MSG___17 = 3,
    POLL_ERR___17 = 4,
    POLL_PRI___17 = 5,
    POLL_HUP___17 = 6
} ;
enum __anonenum_852341087___17 {
    SIGEV_SIGNAL___17 = 0,
    SIGEV_NONE___17 = 1,
    SIGEV_THREAD___17 = 2,
    SIGEV_THREAD_ID___17 = 4
} ;
enum __anonenum_451154152___17 {
    REG_R8___17 = 0,
    REG_R9___17 = 1,
    REG_R10___17 = 2,
    REG_R11___17 = 3,
    REG_R12___17 = 4,
    REG_R13___17 = 5,
    REG_R14___17 = 6,
    REG_R15___17 = 7,
    REG_RDI___17 = 8,
    REG_RSI___17 = 9,
    REG_RBP___17 = 10,
    REG_RBX___17 = 11,
    REG_RDX___17 = 12,
    REG_RAX___17 = 13,
    REG_RCX___17 = 14,
    REG_RSP___17 = 15,
    REG_RIP___17 = 16,
    REG_EFL___17 = 17,
    REG_CSGSFS___17 = 18,
    REG_ERR___17 = 19,
    REG_TRAPNO___17 = 20,
    REG_OLDMASK___17 = 21,
    REG_CR2___17 = 22
} ;
enum __anonenum_437032235___17 {
    _PC_LINK_MAX___17 = 0,
    _PC_MAX_CANON___17 = 1,
    _PC_MAX_INPUT___17 = 2,
    _PC_NAME_MAX___17 = 3,
    _PC_PATH_MAX___17 = 4,
    _PC_PIPE_BUF___17 = 5,
    _PC_CHOWN_RESTRICTED___17 = 6,
    _PC_NO_TRUNC___17 = 7,
    _PC_VDISABLE___17 = 8,
    _PC_SYNC_IO___17 = 9,
    _PC_ASYNC_IO___17 = 10,
    _PC_PRIO_IO___17 = 11,
    _PC_SOCK_MAXBUF___17 = 12,
    _PC_FILESIZEBITS___17 = 13,
    _PC_REC_INCR_XFER_SIZE___17 = 14,
    _PC_REC_MAX_XFER_SIZE___17 = 15,
    _PC_REC_MIN_XFER_SIZE___17 = 16,
    _PC_REC_XFER_ALIGN___17 = 17,
    _PC_ALLOC_SIZE_MIN___17 = 18,
    _PC_SYMLINK_MAX___17 = 19,
    _PC_2_SYMLINKS___17 = 20
} ;
enum __anonenum_315186338___17 {
    _SC_ARG_MAX___17 = 0,
    _SC_CHILD_MAX___17 = 1,
    _SC_CLK_TCK___17 = 2,
    _SC_NGROUPS_MAX___17 = 3,
    _SC_OPEN_MAX___17 = 4,
    _SC_STREAM_MAX___17 = 5,
    _SC_TZNAME_MAX___17 = 6,
    _SC_JOB_CONTROL___17 = 7,
    _SC_SAVED_IDS___17 = 8,
    _SC_REALTIME_SIGNALS___17 = 9,
    _SC_PRIORITY_SCHEDULING___17 = 10,
    _SC_TIMERS___17 = 11,
    _SC_ASYNCHRONOUS_IO___17 = 12,
    _SC_PRIORITIZED_IO___17 = 13,
    _SC_SYNCHRONIZED_IO___17 = 14,
    _SC_FSYNC___17 = 15,
    _SC_MAPPED_FILES___17 = 16,
    _SC_MEMLOCK___17 = 17,
    _SC_MEMLOCK_RANGE___17 = 18,
    _SC_MEMORY_PROTECTION___17 = 19,
    _SC_MESSAGE_PASSING___17 = 20,
    _SC_SEMAPHORES___17 = 21,
    _SC_SHARED_MEMORY_OBJECTS___17 = 22,
    _SC_AIO_LISTIO_MAX___17 = 23,
    _SC_AIO_MAX___17 = 24,
    _SC_AIO_PRIO_DELTA_MAX___17 = 25,
    _SC_DELAYTIMER_MAX___17 = 26,
    _SC_MQ_OPEN_MAX___17 = 27,
    _SC_MQ_PRIO_MAX___17 = 28,
    _SC_VERSION___17 = 29,
    _SC_PAGESIZE___17 = 30,
    _SC_RTSIG_MAX___17 = 31,
    _SC_SEM_NSEMS_MAX___17 = 32,
    _SC_SEM_VALUE_MAX___17 = 33,
    _SC_SIGQUEUE_MAX___17 = 34,
    _SC_TIMER_MAX___17 = 35,
    _SC_BC_BASE_MAX___17 = 36,
    _SC_BC_DIM_MAX___17 = 37,
    _SC_BC_SCALE_MAX___17 = 38,
    _SC_BC_STRING_MAX___17 = 39,
    _SC_COLL_WEIGHTS_MAX___17 = 40,
    _SC_EQUIV_CLASS_MAX___17 = 41,
    _SC_EXPR_NEST_MAX___17 = 42,
    _SC_LINE_MAX___17 = 43,
    _SC_RE_DUP_MAX___17 = 44,
    _SC_CHARCLASS_NAME_MAX___17 = 45,
    _SC_2_VERSION___17 = 46,
    _SC_2_C_BIND___17 = 47,
    _SC_2_C_DEV___17 = 48,
    _SC_2_FORT_DEV___17 = 49,
    _SC_2_FORT_RUN___17 = 50,
    _SC_2_SW_DEV___17 = 51,
    _SC_2_LOCALEDEF___17 = 52,
    _SC_PII___17 = 53,
    _SC_PII_XTI___17 = 54,
    _SC_PII_SOCKET___17 = 55,
    _SC_PII_INTERNET___17 = 56,
    _SC_PII_OSI___17 = 57,
    _SC_POLL___17 = 58,
    _SC_SELECT___17 = 59,
    _SC_UIO_MAXIOV___17 = 60,
    _SC_IOV_MAX___17 = 60,
    _SC_PII_INTERNET_STREAM___17 = 61,
    _SC_PII_INTERNET_DGRAM___17 = 62,
    _SC_PII_OSI_COTS___17 = 63,
    _SC_PII_OSI_CLTS___17 = 64,
    _SC_PII_OSI_M___17 = 65,
    _SC_T_IOV_MAX___17 = 66,
    _SC_THREADS___17 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___17 = 68,
    _SC_GETGR_R_SIZE_MAX___17 = 69,
    _SC_GETPW_R_SIZE_MAX___17 = 70,
    _SC_LOGIN_NAME_MAX___17 = 71,
    _SC_TTY_NAME_MAX___17 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___17 = 73,
    _SC_THREAD_KEYS_MAX___17 = 74,
    _SC_THREAD_STACK_MIN___17 = 75,
    _SC_THREAD_THREADS_MAX___17 = 76,
    _SC_THREAD_ATTR_STACKADDR___17 = 77,
    _SC_THREAD_ATTR_STACKSIZE___17 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___17 = 79,
    _SC_THREAD_PRIO_INHERIT___17 = 80,
    _SC_THREAD_PRIO_PROTECT___17 = 81,
    _SC_THREAD_PROCESS_SHARED___17 = 82,
    _SC_NPROCESSORS_CONF___17 = 83,
    _SC_NPROCESSORS_ONLN___17 = 84,
    _SC_PHYS_PAGES___17 = 85,
    _SC_AVPHYS_PAGES___17 = 86,
    _SC_ATEXIT_MAX___17 = 87,
    _SC_PASS_MAX___17 = 88,
    _SC_XOPEN_VERSION___17 = 89,
    _SC_XOPEN_XCU_VERSION___17 = 90,
    _SC_XOPEN_UNIX___17 = 91,
    _SC_XOPEN_CRYPT___17 = 92,
    _SC_XOPEN_ENH_I18N___17 = 93,
    _SC_XOPEN_SHM___17 = 94,
    _SC_2_CHAR_TERM___17 = 95,
    _SC_2_C_VERSION___17 = 96,
    _SC_2_UPE___17 = 97,
    _SC_XOPEN_XPG2___17 = 98,
    _SC_XOPEN_XPG3___17 = 99,
    _SC_XOPEN_XPG4___17 = 100,
    _SC_CHAR_BIT___17 = 101,
    _SC_CHAR_MAX___17 = 102,
    _SC_CHAR_MIN___17 = 103,
    _SC_INT_MAX___17 = 104,
    _SC_INT_MIN___17 = 105,
    _SC_LONG_BIT___17 = 106,
    _SC_WORD_BIT___17 = 107,
    _SC_MB_LEN_MAX___17 = 108,
    _SC_NZERO___17 = 109,
    _SC_SSIZE_MAX___17 = 110,
    _SC_SCHAR_MAX___17 = 111,
    _SC_SCHAR_MIN___17 = 112,
    _SC_SHRT_MAX___17 = 113,
    _SC_SHRT_MIN___17 = 114,
    _SC_UCHAR_MAX___17 = 115,
    _SC_UINT_MAX___17 = 116,
    _SC_ULONG_MAX___17 = 117,
    _SC_USHRT_MAX___17 = 118,
    _SC_NL_ARGMAX___17 = 119,
    _SC_NL_LANGMAX___17 = 120,
    _SC_NL_MSGMAX___17 = 121,
    _SC_NL_NMAX___17 = 122,
    _SC_NL_SETMAX___17 = 123,
    _SC_NL_TEXTMAX___17 = 124,
    _SC_XBS5_ILP32_OFF32___17 = 125,
    _SC_XBS5_ILP32_OFFBIG___17 = 126,
    _SC_XBS5_LP64_OFF64___17 = 127,
    _SC_XBS5_LPBIG_OFFBIG___17 = 128,
    _SC_XOPEN_LEGACY___17 = 129,
    _SC_XOPEN_REALTIME___17 = 130,
    _SC_XOPEN_REALTIME_THREADS___17 = 131,
    _SC_ADVISORY_INFO___17 = 132,
    _SC_BARRIERS___17 = 133,
    _SC_BASE___17 = 134,
    _SC_C_LANG_SUPPORT___17 = 135,
    _SC_C_LANG_SUPPORT_R___17 = 136,
    _SC_CLOCK_SELECTION___17 = 137,
    _SC_CPUTIME___17 = 138,
    _SC_THREAD_CPUTIME___17 = 139,
    _SC_DEVICE_IO___17 = 140,
    _SC_DEVICE_SPECIFIC___17 = 141,
    _SC_DEVICE_SPECIFIC_R___17 = 142,
    _SC_FD_MGMT___17 = 143,
    _SC_FIFO___17 = 144,
    _SC_PIPE___17 = 145,
    _SC_FILE_ATTRIBUTES___17 = 146,
    _SC_FILE_LOCKING___17 = 147,
    _SC_FILE_SYSTEM___17 = 148,
    _SC_MONOTONIC_CLOCK___17 = 149,
    _SC_MULTI_PROCESS___17 = 150,
    _SC_SINGLE_PROCESS___17 = 151,
    _SC_NETWORKING___17 = 152,
    _SC_READER_WRITER_LOCKS___17 = 153,
    _SC_SPIN_LOCKS___17 = 154,
    _SC_REGEXP___17 = 155,
    _SC_REGEX_VERSION___17 = 156,
    _SC_SHELL___17 = 157,
    _SC_SIGNALS___17 = 158,
    _SC_SPAWN___17 = 159,
    _SC_SPORADIC_SERVER___17 = 160,
    _SC_THREAD_SPORADIC_SERVER___17 = 161,
    _SC_SYSTEM_DATABASE___17 = 162,
    _SC_SYSTEM_DATABASE_R___17 = 163,
    _SC_TIMEOUTS___17 = 164,
    _SC_TYPED_MEMORY_OBJECTS___17 = 165,
    _SC_USER_GROUPS___17 = 166,
    _SC_USER_GROUPS_R___17 = 167,
    _SC_2_PBS___17 = 168,
    _SC_2_PBS_ACCOUNTING___17 = 169,
    _SC_2_PBS_LOCATE___17 = 170,
    _SC_2_PBS_MESSAGE___17 = 171,
    _SC_2_PBS_TRACK___17 = 172,
    _SC_SYMLOOP_MAX___17 = 173,
    _SC_STREAMS___17 = 174,
    _SC_2_PBS_CHECKPOINT___17 = 175,
    _SC_V6_ILP32_OFF32___17 = 176,
    _SC_V6_ILP32_OFFBIG___17 = 177,
    _SC_V6_LP64_OFF64___17 = 178,
    _SC_V6_LPBIG_OFFBIG___17 = 179,
    _SC_HOST_NAME_MAX___17 = 180,
    _SC_TRACE___17 = 181,
    _SC_TRACE_EVENT_FILTER___17 = 182,
    _SC_TRACE_INHERIT___17 = 183,
    _SC_TRACE_LOG___17 = 184,
    _SC_LEVEL1_ICACHE_SIZE___17 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___17 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___17 = 187,
    _SC_LEVEL1_DCACHE_SIZE___17 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___17 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___17 = 190,
    _SC_LEVEL2_CACHE_SIZE___17 = 191,
    _SC_LEVEL2_CACHE_ASSOC___17 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___17 = 193,
    _SC_LEVEL3_CACHE_SIZE___17 = 194,
    _SC_LEVEL3_CACHE_ASSOC___17 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___17 = 196,
    _SC_LEVEL4_CACHE_SIZE___17 = 197,
    _SC_LEVEL4_CACHE_ASSOC___17 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___17 = 199,
    _SC_IPV6___17 = 235,
    _SC_RAW_SOCKETS___17 = 236,
    _SC_V7_ILP32_OFF32___17 = 237,
    _SC_V7_ILP32_OFFBIG___17 = 238,
    _SC_V7_LP64_OFF64___17 = 239,
    _SC_V7_LPBIG_OFFBIG___17 = 240,
    _SC_SS_REPL_MAX___17 = 241,
    _SC_TRACE_EVENT_NAME_MAX___17 = 242,
    _SC_TRACE_NAME_MAX___17 = 243,
    _SC_TRACE_SYS_MAX___17 = 244,
    _SC_TRACE_USER_EVENT_MAX___17 = 245,
    _SC_XOPEN_STREAMS___17 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___17 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___17 = 248,
    _SC_MINSIGSTKSZ___17 = 249,
    _SC_SIGSTKSZ___17 = 250
} ;
enum __anonenum_875524036___17 {
    _CS_PATH___17 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___17 = 1,
    _CS_GNU_LIBC_VERSION___17 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___17 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___17 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___17 = 5,
    _CS_LFS_CFLAGS___17 = 1000,
    _CS_LFS_LDFLAGS___17 = 1001,
    _CS_LFS_LIBS___17 = 1002,
    _CS_LFS_LINTFLAGS___17 = 1003,
    _CS_LFS64_CFLAGS___17 = 1004,
    _CS_LFS64_LDFLAGS___17 = 1005,
    _CS_LFS64_LIBS___17 = 1006,
    _CS_LFS64_LINTFLAGS___17 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___17 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___17 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___17 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___17 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___17 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___17 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___17 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___17 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___17 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___17 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___17 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___17 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___17 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___17 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___17 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___17 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___17 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___17 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___17 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___17 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___17 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___17 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___17 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___17 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___17 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___17 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___17 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___17 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___17 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___17 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___17 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___17 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___17 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___17 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___17 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___17 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___17 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___17 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___17 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___17 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___17 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___17 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___17 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___17 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___17 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___17 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___17 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___17 = 1147,
    _CS_V6_ENV___17 = 1148,
    _CS_V7_ENV___17 = 1149
} ;
enum __anonenum_57186863___17 {
    SS_ONSTACK___17 = 1,
    SS_DISABLE___17 = 2
} ;
enum __anonenum_83571709___18 {
    MSG_OOB___18 = 1,
    MSG_PEEK___18 = 2,
    MSG_DONTROUTE___18 = 4,
    MSG_TRYHARD___18 = 4,
    MSG_CTRUNC___18 = 8,
    MSG_PROXY___18 = 16,
    MSG_TRUNC___18 = 32,
    MSG_DONTWAIT___18 = 64,
    MSG_EOR___18 = 128,
    MSG_WAITALL___18 = 256,
    MSG_FIN___18 = 512,
    MSG_SYN___18 = 1024,
    MSG_CONFIRM___18 = 2048,
    MSG_RST___18 = 4096,
    MSG_ERRQUEUE___18 = 8192,
    MSG_NOSIGNAL___18 = 16384,
    MSG_MORE___18 = 32768,
    MSG_WAITFORONE___18 = 65536,
    MSG_BATCH___18 = 262144,
    MSG_ZEROCOPY___18 = 67108864,
    MSG_FASTOPEN___18 = 536870912,
    MSG_CMSG_CLOEXEC___18 = 1073741824
} ;
enum __anonenum_617082774___18 {
    SCM_RIGHTS___18 = 1,
    SCM_CREDENTIALS___18 = 2
} ;
enum __anonenum_606441560___18 {
    SHUT_RD___18 = 0,
    SHUT_WR___18 = 1,
    SHUT_RDWR___18 = 2
} ;
enum __anonenum_264779956___18 {
    IPPROTO_IP___18 = 0,
    IPPROTO_ICMP___18 = 1,
    IPPROTO_IGMP___18 = 2,
    IPPROTO_IPIP___18 = 4,
    IPPROTO_TCP___18 = 6,
    IPPROTO_EGP___18 = 8,
    IPPROTO_PUP___18 = 12,
    IPPROTO_UDP___18 = 17,
    IPPROTO_IDP___18 = 22,
    IPPROTO_TP___18 = 29,
    IPPROTO_DCCP___18 = 33,
    IPPROTO_IPV6___18 = 41,
    IPPROTO_RSVP___18 = 46,
    IPPROTO_GRE___18 = 47,
    IPPROTO_ESP___18 = 50,
    IPPROTO_AH___18 = 51,
    IPPROTO_MTP___18 = 92,
    IPPROTO_BEETPH___18 = 94,
    IPPROTO_ENCAP___18 = 98,
    IPPROTO_PIM___18 = 103,
    IPPROTO_COMP___18 = 108,
    IPPROTO_SCTP___18 = 132,
    IPPROTO_UDPLITE___18 = 136,
    IPPROTO_MPLS___18 = 137,
    IPPROTO_ETHERNET___18 = 143,
    IPPROTO_RAW___18 = 255,
    IPPROTO_MPTCP___18 = 262,
    IPPROTO_MAX___18 = 263
} ;
enum __anonenum_218739988___18 {
    IPPROTO_HOPOPTS___18 = 0,
    IPPROTO_ROUTING___18 = 43,
    IPPROTO_FRAGMENT___18 = 44,
    IPPROTO_ICMPV6___18 = 58,
    IPPROTO_NONE___18 = 59,
    IPPROTO_DSTOPTS___18 = 60,
    IPPROTO_MH___18 = 135
} ;
enum __anonenum_662268580___18 {
    IPPORT_ECHO___18 = 7,
    IPPORT_DISCARD___18 = 9,
    IPPORT_SYSTAT___18 = 11,
    IPPORT_DAYTIME___18 = 13,
    IPPORT_NETSTAT___18 = 15,
    IPPORT_FTP___18 = 21,
    IPPORT_TELNET___18 = 23,
    IPPORT_SMTP___18 = 25,
    IPPORT_TIMESERVER___18 = 37,
    IPPORT_NAMESERVER___18 = 42,
    IPPORT_WHOIS___18 = 43,
    IPPORT_MTP___18 = 57,
    IPPORT_TFTP___18 = 69,
    IPPORT_RJE___18 = 77,
    IPPORT_FINGER___18 = 79,
    IPPORT_TTYLINK___18 = 87,
    IPPORT_SUPDUP___18 = 95,
    IPPORT_EXECSERVER___18 = 512,
    IPPORT_LOGINSERVER___18 = 513,
    IPPORT_CMDSERVER___18 = 514,
    IPPORT_EFSSERVER___18 = 520,
    IPPORT_BIFFUDP___18 = 512,
    IPPORT_WHOSERVER___18 = 513,
    IPPORT_ROUTESERVER___18 = 520,
    IPPORT_RESERVED___18 = 1024,
    IPPORT_USERRESERVED___18 = 5000
} ;
enum __anonenum_18926444___18 {
    _ISupper___18 = 256,
    _ISlower___18 = 512,
    _ISalpha___18 = 1024,
    _ISdigit___18 = 2048,
    _ISxdigit___18 = 4096,
    _ISspace___18 = 8192,
    _ISprint___18 = 16384,
    _ISgraph___18 = 32768,
    _ISblank___18 = 1,
    _IScntrl___18 = 2,
    _ISpunct___18 = 4,
    _ISalnum___18 = 8
} ;
enum __anonenum_913965969___18 {
    FP_INT_UPWARD___18 = 0,
    FP_INT_DOWNWARD___18 = 1,
    FP_INT_TOWARDZERO___18 = 2,
    FP_INT_TONEARESTFROMZERO___18 = 3,
    FP_INT_TONEAREST___18 = 4
} ;
enum __anonenum_1037408945___18 {
    FP_NAN___18 = 0,
    FP_INFINITE___18 = 1,
    FP_ZERO___18 = 2,
    FP_SUBNORMAL___18 = 3,
    FP_NORMAL___18 = 4
} ;
enum __anonenum_556971655___18 {
    SI_ASYNCNL___18 = -60,
    SI_DETHREAD___18 = -7,
    SI_TKILL___18 = -6,
    SI_SIGIO___18 = -5,
    SI_ASYNCIO___18 = -4,
    SI_MESGQ___18 = -3,
    SI_TIMER___18 = -2,
    SI_QUEUE___18 = -1,
    SI_USER___18 = 0,
    SI_KERNEL___18 = 128
} ;
enum __anonenum_640648963___18 {
    ILL_ILLOPC___18 = 1,
    ILL_ILLOPN___18 = 2,
    ILL_ILLADR___18 = 3,
    ILL_ILLTRP___18 = 4,
    ILL_PRVOPC___18 = 5,
    ILL_PRVREG___18 = 6,
    ILL_COPROC___18 = 7,
    ILL_BADSTK___18 = 8,
    ILL_BADIADDR___18 = 9
} ;
enum __anonenum_457704180___18 {
    FPE_INTDIV___18 = 1,
    FPE_INTOVF___18 = 2,
    FPE_FLTDIV___18 = 3,
    FPE_FLTOVF___18 = 4,
    FPE_FLTUND___18 = 5,
    FPE_FLTRES___18 = 6,
    FPE_FLTINV___18 = 7,
    FPE_FLTSUB___18 = 8,
    FPE_FLTUNK___18 = 14,
    FPE_CONDTRAP___18 = 15
} ;
enum __anonenum_180375148___18 {
    SEGV_MAPERR___18 = 1,
    SEGV_ACCERR___18 = 2,
    SEGV_BNDERR___18 = 3,
    SEGV_PKUERR___18 = 4,
    SEGV_ACCADI___18 = 5,
    SEGV_ADIDERR___18 = 6,
    SEGV_ADIPERR___18 = 7,
    SEGV_MTEAERR___18 = 8,
    SEGV_MTESERR___18 = 9
} ;
enum __anonenum_1036286214___18 {
    BUS_ADRALN___18 = 1,
    BUS_ADRERR___18 = 2,
    BUS_OBJERR___18 = 3,
    BUS_MCEERR_AR___18 = 4,
    BUS_MCEERR_AO___18 = 5
} ;
enum __anonenum_91015150___18 {
    TRAP_BRKPT___18 = 1,
    TRAP_TRACE___18 = 2,
    TRAP_BRANCH___18 = 3,
    TRAP_HWBKPT___18 = 4,
    TRAP_UNK___18 = 5
} ;
enum __anonenum_23175539___18 {
    CLD_EXITED___18 = 1,
    CLD_KILLED___18 = 2,
    CLD_DUMPED___18 = 3,
    CLD_TRAPPED___18 = 4,
    CLD_STOPPED___18 = 5,
    CLD_CONTINUED___18 = 6
} ;
enum __anonenum_111643124___18 {
    POLL_IN___18 = 1,
    POLL_OUT___18 = 2,
    POLL_MSG___18 = 3,
    POLL_ERR___18 = 4,
    POLL_PRI___18 = 5,
    POLL_HUP___18 = 6
} ;
enum __anonenum_852341087___18 {
    SIGEV_SIGNAL___18 = 0,
    SIGEV_NONE___18 = 1,
    SIGEV_THREAD___18 = 2,
    SIGEV_THREAD_ID___18 = 4
} ;
enum __anonenum_451154152___18 {
    REG_R8___18 = 0,
    REG_R9___18 = 1,
    REG_R10___18 = 2,
    REG_R11___18 = 3,
    REG_R12___18 = 4,
    REG_R13___18 = 5,
    REG_R14___18 = 6,
    REG_R15___18 = 7,
    REG_RDI___18 = 8,
    REG_RSI___18 = 9,
    REG_RBP___18 = 10,
    REG_RBX___18 = 11,
    REG_RDX___18 = 12,
    REG_RAX___18 = 13,
    REG_RCX___18 = 14,
    REG_RSP___18 = 15,
    REG_RIP___18 = 16,
    REG_EFL___18 = 17,
    REG_CSGSFS___18 = 18,
    REG_ERR___18 = 19,
    REG_TRAPNO___18 = 20,
    REG_OLDMASK___18 = 21,
    REG_CR2___18 = 22
} ;
enum __anonenum_437032235___18 {
    _PC_LINK_MAX___18 = 0,
    _PC_MAX_CANON___18 = 1,
    _PC_MAX_INPUT___18 = 2,
    _PC_NAME_MAX___18 = 3,
    _PC_PATH_MAX___18 = 4,
    _PC_PIPE_BUF___18 = 5,
    _PC_CHOWN_RESTRICTED___18 = 6,
    _PC_NO_TRUNC___18 = 7,
    _PC_VDISABLE___18 = 8,
    _PC_SYNC_IO___18 = 9,
    _PC_ASYNC_IO___18 = 10,
    _PC_PRIO_IO___18 = 11,
    _PC_SOCK_MAXBUF___18 = 12,
    _PC_FILESIZEBITS___18 = 13,
    _PC_REC_INCR_XFER_SIZE___18 = 14,
    _PC_REC_MAX_XFER_SIZE___18 = 15,
    _PC_REC_MIN_XFER_SIZE___18 = 16,
    _PC_REC_XFER_ALIGN___18 = 17,
    _PC_ALLOC_SIZE_MIN___18 = 18,
    _PC_SYMLINK_MAX___18 = 19,
    _PC_2_SYMLINKS___18 = 20
} ;
enum __anonenum_315186338___18 {
    _SC_ARG_MAX___18 = 0,
    _SC_CHILD_MAX___18 = 1,
    _SC_CLK_TCK___18 = 2,
    _SC_NGROUPS_MAX___18 = 3,
    _SC_OPEN_MAX___18 = 4,
    _SC_STREAM_MAX___18 = 5,
    _SC_TZNAME_MAX___18 = 6,
    _SC_JOB_CONTROL___18 = 7,
    _SC_SAVED_IDS___18 = 8,
    _SC_REALTIME_SIGNALS___18 = 9,
    _SC_PRIORITY_SCHEDULING___18 = 10,
    _SC_TIMERS___18 = 11,
    _SC_ASYNCHRONOUS_IO___18 = 12,
    _SC_PRIORITIZED_IO___18 = 13,
    _SC_SYNCHRONIZED_IO___18 = 14,
    _SC_FSYNC___18 = 15,
    _SC_MAPPED_FILES___18 = 16,
    _SC_MEMLOCK___18 = 17,
    _SC_MEMLOCK_RANGE___18 = 18,
    _SC_MEMORY_PROTECTION___18 = 19,
    _SC_MESSAGE_PASSING___18 = 20,
    _SC_SEMAPHORES___18 = 21,
    _SC_SHARED_MEMORY_OBJECTS___18 = 22,
    _SC_AIO_LISTIO_MAX___18 = 23,
    _SC_AIO_MAX___18 = 24,
    _SC_AIO_PRIO_DELTA_MAX___18 = 25,
    _SC_DELAYTIMER_MAX___18 = 26,
    _SC_MQ_OPEN_MAX___18 = 27,
    _SC_MQ_PRIO_MAX___18 = 28,
    _SC_VERSION___18 = 29,
    _SC_PAGESIZE___18 = 30,
    _SC_RTSIG_MAX___18 = 31,
    _SC_SEM_NSEMS_MAX___18 = 32,
    _SC_SEM_VALUE_MAX___18 = 33,
    _SC_SIGQUEUE_MAX___18 = 34,
    _SC_TIMER_MAX___18 = 35,
    _SC_BC_BASE_MAX___18 = 36,
    _SC_BC_DIM_MAX___18 = 37,
    _SC_BC_SCALE_MAX___18 = 38,
    _SC_BC_STRING_MAX___18 = 39,
    _SC_COLL_WEIGHTS_MAX___18 = 40,
    _SC_EQUIV_CLASS_MAX___18 = 41,
    _SC_EXPR_NEST_MAX___18 = 42,
    _SC_LINE_MAX___18 = 43,
    _SC_RE_DUP_MAX___18 = 44,
    _SC_CHARCLASS_NAME_MAX___18 = 45,
    _SC_2_VERSION___18 = 46,
    _SC_2_C_BIND___18 = 47,
    _SC_2_C_DEV___18 = 48,
    _SC_2_FORT_DEV___18 = 49,
    _SC_2_FORT_RUN___18 = 50,
    _SC_2_SW_DEV___18 = 51,
    _SC_2_LOCALEDEF___18 = 52,
    _SC_PII___18 = 53,
    _SC_PII_XTI___18 = 54,
    _SC_PII_SOCKET___18 = 55,
    _SC_PII_INTERNET___18 = 56,
    _SC_PII_OSI___18 = 57,
    _SC_POLL___18 = 58,
    _SC_SELECT___18 = 59,
    _SC_UIO_MAXIOV___18 = 60,
    _SC_IOV_MAX___18 = 60,
    _SC_PII_INTERNET_STREAM___18 = 61,
    _SC_PII_INTERNET_DGRAM___18 = 62,
    _SC_PII_OSI_COTS___18 = 63,
    _SC_PII_OSI_CLTS___18 = 64,
    _SC_PII_OSI_M___18 = 65,
    _SC_T_IOV_MAX___18 = 66,
    _SC_THREADS___18 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___18 = 68,
    _SC_GETGR_R_SIZE_MAX___18 = 69,
    _SC_GETPW_R_SIZE_MAX___18 = 70,
    _SC_LOGIN_NAME_MAX___18 = 71,
    _SC_TTY_NAME_MAX___18 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___18 = 73,
    _SC_THREAD_KEYS_MAX___18 = 74,
    _SC_THREAD_STACK_MIN___18 = 75,
    _SC_THREAD_THREADS_MAX___18 = 76,
    _SC_THREAD_ATTR_STACKADDR___18 = 77,
    _SC_THREAD_ATTR_STACKSIZE___18 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___18 = 79,
    _SC_THREAD_PRIO_INHERIT___18 = 80,
    _SC_THREAD_PRIO_PROTECT___18 = 81,
    _SC_THREAD_PROCESS_SHARED___18 = 82,
    _SC_NPROCESSORS_CONF___18 = 83,
    _SC_NPROCESSORS_ONLN___18 = 84,
    _SC_PHYS_PAGES___18 = 85,
    _SC_AVPHYS_PAGES___18 = 86,
    _SC_ATEXIT_MAX___18 = 87,
    _SC_PASS_MAX___18 = 88,
    _SC_XOPEN_VERSION___18 = 89,
    _SC_XOPEN_XCU_VERSION___18 = 90,
    _SC_XOPEN_UNIX___18 = 91,
    _SC_XOPEN_CRYPT___18 = 92,
    _SC_XOPEN_ENH_I18N___18 = 93,
    _SC_XOPEN_SHM___18 = 94,
    _SC_2_CHAR_TERM___18 = 95,
    _SC_2_C_VERSION___18 = 96,
    _SC_2_UPE___18 = 97,
    _SC_XOPEN_XPG2___18 = 98,
    _SC_XOPEN_XPG3___18 = 99,
    _SC_XOPEN_XPG4___18 = 100,
    _SC_CHAR_BIT___18 = 101,
    _SC_CHAR_MAX___18 = 102,
    _SC_CHAR_MIN___18 = 103,
    _SC_INT_MAX___18 = 104,
    _SC_INT_MIN___18 = 105,
    _SC_LONG_BIT___18 = 106,
    _SC_WORD_BIT___18 = 107,
    _SC_MB_LEN_MAX___18 = 108,
    _SC_NZERO___18 = 109,
    _SC_SSIZE_MAX___18 = 110,
    _SC_SCHAR_MAX___18 = 111,
    _SC_SCHAR_MIN___18 = 112,
    _SC_SHRT_MAX___18 = 113,
    _SC_SHRT_MIN___18 = 114,
    _SC_UCHAR_MAX___18 = 115,
    _SC_UINT_MAX___18 = 116,
    _SC_ULONG_MAX___18 = 117,
    _SC_USHRT_MAX___18 = 118,
    _SC_NL_ARGMAX___18 = 119,
    _SC_NL_LANGMAX___18 = 120,
    _SC_NL_MSGMAX___18 = 121,
    _SC_NL_NMAX___18 = 122,
    _SC_NL_SETMAX___18 = 123,
    _SC_NL_TEXTMAX___18 = 124,
    _SC_XBS5_ILP32_OFF32___18 = 125,
    _SC_XBS5_ILP32_OFFBIG___18 = 126,
    _SC_XBS5_LP64_OFF64___18 = 127,
    _SC_XBS5_LPBIG_OFFBIG___18 = 128,
    _SC_XOPEN_LEGACY___18 = 129,
    _SC_XOPEN_REALTIME___18 = 130,
    _SC_XOPEN_REALTIME_THREADS___18 = 131,
    _SC_ADVISORY_INFO___18 = 132,
    _SC_BARRIERS___18 = 133,
    _SC_BASE___18 = 134,
    _SC_C_LANG_SUPPORT___18 = 135,
    _SC_C_LANG_SUPPORT_R___18 = 136,
    _SC_CLOCK_SELECTION___18 = 137,
    _SC_CPUTIME___18 = 138,
    _SC_THREAD_CPUTIME___18 = 139,
    _SC_DEVICE_IO___18 = 140,
    _SC_DEVICE_SPECIFIC___18 = 141,
    _SC_DEVICE_SPECIFIC_R___18 = 142,
    _SC_FD_MGMT___18 = 143,
    _SC_FIFO___18 = 144,
    _SC_PIPE___18 = 145,
    _SC_FILE_ATTRIBUTES___18 = 146,
    _SC_FILE_LOCKING___18 = 147,
    _SC_FILE_SYSTEM___18 = 148,
    _SC_MONOTONIC_CLOCK___18 = 149,
    _SC_MULTI_PROCESS___18 = 150,
    _SC_SINGLE_PROCESS___18 = 151,
    _SC_NETWORKING___18 = 152,
    _SC_READER_WRITER_LOCKS___18 = 153,
    _SC_SPIN_LOCKS___18 = 154,
    _SC_REGEXP___18 = 155,
    _SC_REGEX_VERSION___18 = 156,
    _SC_SHELL___18 = 157,
    _SC_SIGNALS___18 = 158,
    _SC_SPAWN___18 = 159,
    _SC_SPORADIC_SERVER___18 = 160,
    _SC_THREAD_SPORADIC_SERVER___18 = 161,
    _SC_SYSTEM_DATABASE___18 = 162,
    _SC_SYSTEM_DATABASE_R___18 = 163,
    _SC_TIMEOUTS___18 = 164,
    _SC_TYPED_MEMORY_OBJECTS___18 = 165,
    _SC_USER_GROUPS___18 = 166,
    _SC_USER_GROUPS_R___18 = 167,
    _SC_2_PBS___18 = 168,
    _SC_2_PBS_ACCOUNTING___18 = 169,
    _SC_2_PBS_LOCATE___18 = 170,
    _SC_2_PBS_MESSAGE___18 = 171,
    _SC_2_PBS_TRACK___18 = 172,
    _SC_SYMLOOP_MAX___18 = 173,
    _SC_STREAMS___18 = 174,
    _SC_2_PBS_CHECKPOINT___18 = 175,
    _SC_V6_ILP32_OFF32___18 = 176,
    _SC_V6_ILP32_OFFBIG___18 = 177,
    _SC_V6_LP64_OFF64___18 = 178,
    _SC_V6_LPBIG_OFFBIG___18 = 179,
    _SC_HOST_NAME_MAX___18 = 180,
    _SC_TRACE___18 = 181,
    _SC_TRACE_EVENT_FILTER___18 = 182,
    _SC_TRACE_INHERIT___18 = 183,
    _SC_TRACE_LOG___18 = 184,
    _SC_LEVEL1_ICACHE_SIZE___18 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___18 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___18 = 187,
    _SC_LEVEL1_DCACHE_SIZE___18 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___18 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___18 = 190,
    _SC_LEVEL2_CACHE_SIZE___18 = 191,
    _SC_LEVEL2_CACHE_ASSOC___18 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___18 = 193,
    _SC_LEVEL3_CACHE_SIZE___18 = 194,
    _SC_LEVEL3_CACHE_ASSOC___18 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___18 = 196,
    _SC_LEVEL4_CACHE_SIZE___18 = 197,
    _SC_LEVEL4_CACHE_ASSOC___18 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___18 = 199,
    _SC_IPV6___18 = 235,
    _SC_RAW_SOCKETS___18 = 236,
    _SC_V7_ILP32_OFF32___18 = 237,
    _SC_V7_ILP32_OFFBIG___18 = 238,
    _SC_V7_LP64_OFF64___18 = 239,
    _SC_V7_LPBIG_OFFBIG___18 = 240,
    _SC_SS_REPL_MAX___18 = 241,
    _SC_TRACE_EVENT_NAME_MAX___18 = 242,
    _SC_TRACE_NAME_MAX___18 = 243,
    _SC_TRACE_SYS_MAX___18 = 244,
    _SC_TRACE_USER_EVENT_MAX___18 = 245,
    _SC_XOPEN_STREAMS___18 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___18 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___18 = 248,
    _SC_MINSIGSTKSZ___18 = 249,
    _SC_SIGSTKSZ___18 = 250
} ;
enum __anonenum_875524036___18 {
    _CS_PATH___18 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___18 = 1,
    _CS_GNU_LIBC_VERSION___18 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___18 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___18 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___18 = 5,
    _CS_LFS_CFLAGS___18 = 1000,
    _CS_LFS_LDFLAGS___18 = 1001,
    _CS_LFS_LIBS___18 = 1002,
    _CS_LFS_LINTFLAGS___18 = 1003,
    _CS_LFS64_CFLAGS___18 = 1004,
    _CS_LFS64_LDFLAGS___18 = 1005,
    _CS_LFS64_LIBS___18 = 1006,
    _CS_LFS64_LINTFLAGS___18 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___18 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___18 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___18 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___18 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___18 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___18 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___18 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___18 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___18 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___18 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___18 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___18 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___18 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___18 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___18 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___18 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___18 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___18 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___18 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___18 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___18 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___18 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___18 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___18 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___18 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___18 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___18 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___18 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___18 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___18 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___18 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___18 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___18 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___18 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___18 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___18 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___18 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___18 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___18 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___18 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___18 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___18 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___18 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___18 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___18 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___18 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___18 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___18 = 1147,
    _CS_V6_ENV___18 = 1148,
    _CS_V7_ENV___18 = 1149
} ;
enum __anonenum_57186863___18 {
    SS_ONSTACK___18 = 1,
    SS_DISABLE___18 = 2
} ;
struct Point {
   double temp ;
   double comp ;
};
enum __anonenum_83571709___19 {
    MSG_OOB___19 = 1,
    MSG_PEEK___19 = 2,
    MSG_DONTROUTE___19 = 4,
    MSG_TRYHARD___19 = 4,
    MSG_CTRUNC___19 = 8,
    MSG_PROXY___19 = 16,
    MSG_TRUNC___19 = 32,
    MSG_DONTWAIT___19 = 64,
    MSG_EOR___19 = 128,
    MSG_WAITALL___19 = 256,
    MSG_FIN___19 = 512,
    MSG_SYN___19 = 1024,
    MSG_CONFIRM___19 = 2048,
    MSG_RST___19 = 4096,
    MSG_ERRQUEUE___19 = 8192,
    MSG_NOSIGNAL___19 = 16384,
    MSG_MORE___19 = 32768,
    MSG_WAITFORONE___19 = 65536,
    MSG_BATCH___19 = 262144,
    MSG_ZEROCOPY___19 = 67108864,
    MSG_FASTOPEN___19 = 536870912,
    MSG_CMSG_CLOEXEC___19 = 1073741824
} ;
enum __anonenum_617082774___19 {
    SCM_RIGHTS___19 = 1,
    SCM_CREDENTIALS___19 = 2
} ;
enum __anonenum_606441560___19 {
    SHUT_RD___19 = 0,
    SHUT_WR___19 = 1,
    SHUT_RDWR___19 = 2
} ;
enum __anonenum_264779956___19 {
    IPPROTO_IP___19 = 0,
    IPPROTO_ICMP___19 = 1,
    IPPROTO_IGMP___19 = 2,
    IPPROTO_IPIP___19 = 4,
    IPPROTO_TCP___19 = 6,
    IPPROTO_EGP___19 = 8,
    IPPROTO_PUP___19 = 12,
    IPPROTO_UDP___19 = 17,
    IPPROTO_IDP___19 = 22,
    IPPROTO_TP___19 = 29,
    IPPROTO_DCCP___19 = 33,
    IPPROTO_IPV6___19 = 41,
    IPPROTO_RSVP___19 = 46,
    IPPROTO_GRE___19 = 47,
    IPPROTO_ESP___19 = 50,
    IPPROTO_AH___19 = 51,
    IPPROTO_MTP___19 = 92,
    IPPROTO_BEETPH___19 = 94,
    IPPROTO_ENCAP___19 = 98,
    IPPROTO_PIM___19 = 103,
    IPPROTO_COMP___19 = 108,
    IPPROTO_SCTP___19 = 132,
    IPPROTO_UDPLITE___19 = 136,
    IPPROTO_MPLS___19 = 137,
    IPPROTO_ETHERNET___19 = 143,
    IPPROTO_RAW___19 = 255,
    IPPROTO_MPTCP___19 = 262,
    IPPROTO_MAX___19 = 263
} ;
enum __anonenum_218739988___19 {
    IPPROTO_HOPOPTS___19 = 0,
    IPPROTO_ROUTING___19 = 43,
    IPPROTO_FRAGMENT___19 = 44,
    IPPROTO_ICMPV6___19 = 58,
    IPPROTO_NONE___19 = 59,
    IPPROTO_DSTOPTS___19 = 60,
    IPPROTO_MH___19 = 135
} ;
enum __anonenum_662268580___19 {
    IPPORT_ECHO___19 = 7,
    IPPORT_DISCARD___19 = 9,
    IPPORT_SYSTAT___19 = 11,
    IPPORT_DAYTIME___19 = 13,
    IPPORT_NETSTAT___19 = 15,
    IPPORT_FTP___19 = 21,
    IPPORT_TELNET___19 = 23,
    IPPORT_SMTP___19 = 25,
    IPPORT_TIMESERVER___19 = 37,
    IPPORT_NAMESERVER___19 = 42,
    IPPORT_WHOIS___19 = 43,
    IPPORT_MTP___19 = 57,
    IPPORT_TFTP___19 = 69,
    IPPORT_RJE___19 = 77,
    IPPORT_FINGER___19 = 79,
    IPPORT_TTYLINK___19 = 87,
    IPPORT_SUPDUP___19 = 95,
    IPPORT_EXECSERVER___19 = 512,
    IPPORT_LOGINSERVER___19 = 513,
    IPPORT_CMDSERVER___19 = 514,
    IPPORT_EFSSERVER___19 = 520,
    IPPORT_BIFFUDP___19 = 512,
    IPPORT_WHOSERVER___19 = 513,
    IPPORT_ROUTESERVER___19 = 520,
    IPPORT_RESERVED___19 = 1024,
    IPPORT_USERRESERVED___19 = 5000
} ;
enum __anonenum_18926444___19 {
    _ISupper___19 = 256,
    _ISlower___19 = 512,
    _ISalpha___19 = 1024,
    _ISdigit___19 = 2048,
    _ISxdigit___19 = 4096,
    _ISspace___19 = 8192,
    _ISprint___19 = 16384,
    _ISgraph___19 = 32768,
    _ISblank___19 = 1,
    _IScntrl___19 = 2,
    _ISpunct___19 = 4,
    _ISalnum___19 = 8
} ;
enum __anonenum_913965969___19 {
    FP_INT_UPWARD___19 = 0,
    FP_INT_DOWNWARD___19 = 1,
    FP_INT_TOWARDZERO___19 = 2,
    FP_INT_TONEARESTFROMZERO___19 = 3,
    FP_INT_TONEAREST___19 = 4
} ;
enum __anonenum_1037408945___19 {
    FP_NAN___19 = 0,
    FP_INFINITE___19 = 1,
    FP_ZERO___19 = 2,
    FP_SUBNORMAL___19 = 3,
    FP_NORMAL___19 = 4
} ;
enum __anonenum_556971655___19 {
    SI_ASYNCNL___19 = -60,
    SI_DETHREAD___19 = -7,
    SI_TKILL___19 = -6,
    SI_SIGIO___19 = -5,
    SI_ASYNCIO___19 = -4,
    SI_MESGQ___19 = -3,
    SI_TIMER___19 = -2,
    SI_QUEUE___19 = -1,
    SI_USER___19 = 0,
    SI_KERNEL___19 = 128
} ;
enum __anonenum_640648963___19 {
    ILL_ILLOPC___19 = 1,
    ILL_ILLOPN___19 = 2,
    ILL_ILLADR___19 = 3,
    ILL_ILLTRP___19 = 4,
    ILL_PRVOPC___19 = 5,
    ILL_PRVREG___19 = 6,
    ILL_COPROC___19 = 7,
    ILL_BADSTK___19 = 8,
    ILL_BADIADDR___19 = 9
} ;
enum __anonenum_457704180___19 {
    FPE_INTDIV___19 = 1,
    FPE_INTOVF___19 = 2,
    FPE_FLTDIV___19 = 3,
    FPE_FLTOVF___19 = 4,
    FPE_FLTUND___19 = 5,
    FPE_FLTRES___19 = 6,
    FPE_FLTINV___19 = 7,
    FPE_FLTSUB___19 = 8,
    FPE_FLTUNK___19 = 14,
    FPE_CONDTRAP___19 = 15
} ;
enum __anonenum_180375148___19 {
    SEGV_MAPERR___19 = 1,
    SEGV_ACCERR___19 = 2,
    SEGV_BNDERR___19 = 3,
    SEGV_PKUERR___19 = 4,
    SEGV_ACCADI___19 = 5,
    SEGV_ADIDERR___19 = 6,
    SEGV_ADIPERR___19 = 7,
    SEGV_MTEAERR___19 = 8,
    SEGV_MTESERR___19 = 9
} ;
enum __anonenum_1036286214___19 {
    BUS_ADRALN___19 = 1,
    BUS_ADRERR___19 = 2,
    BUS_OBJERR___19 = 3,
    BUS_MCEERR_AR___19 = 4,
    BUS_MCEERR_AO___19 = 5
} ;
enum __anonenum_91015150___19 {
    TRAP_BRKPT___19 = 1,
    TRAP_TRACE___19 = 2,
    TRAP_BRANCH___19 = 3,
    TRAP_HWBKPT___19 = 4,
    TRAP_UNK___19 = 5
} ;
enum __anonenum_23175539___19 {
    CLD_EXITED___19 = 1,
    CLD_KILLED___19 = 2,
    CLD_DUMPED___19 = 3,
    CLD_TRAPPED___19 = 4,
    CLD_STOPPED___19 = 5,
    CLD_CONTINUED___19 = 6
} ;
enum __anonenum_111643124___19 {
    POLL_IN___19 = 1,
    POLL_OUT___19 = 2,
    POLL_MSG___19 = 3,
    POLL_ERR___19 = 4,
    POLL_PRI___19 = 5,
    POLL_HUP___19 = 6
} ;
enum __anonenum_852341087___19 {
    SIGEV_SIGNAL___19 = 0,
    SIGEV_NONE___19 = 1,
    SIGEV_THREAD___19 = 2,
    SIGEV_THREAD_ID___19 = 4
} ;
enum __anonenum_451154152___19 {
    REG_R8___19 = 0,
    REG_R9___19 = 1,
    REG_R10___19 = 2,
    REG_R11___19 = 3,
    REG_R12___19 = 4,
    REG_R13___19 = 5,
    REG_R14___19 = 6,
    REG_R15___19 = 7,
    REG_RDI___19 = 8,
    REG_RSI___19 = 9,
    REG_RBP___19 = 10,
    REG_RBX___19 = 11,
    REG_RDX___19 = 12,
    REG_RAX___19 = 13,
    REG_RCX___19 = 14,
    REG_RSP___19 = 15,
    REG_RIP___19 = 16,
    REG_EFL___19 = 17,
    REG_CSGSFS___19 = 18,
    REG_ERR___19 = 19,
    REG_TRAPNO___19 = 20,
    REG_OLDMASK___19 = 21,
    REG_CR2___19 = 22
} ;
enum __anonenum_437032235___19 {
    _PC_LINK_MAX___19 = 0,
    _PC_MAX_CANON___19 = 1,
    _PC_MAX_INPUT___19 = 2,
    _PC_NAME_MAX___19 = 3,
    _PC_PATH_MAX___19 = 4,
    _PC_PIPE_BUF___19 = 5,
    _PC_CHOWN_RESTRICTED___19 = 6,
    _PC_NO_TRUNC___19 = 7,
    _PC_VDISABLE___19 = 8,
    _PC_SYNC_IO___19 = 9,
    _PC_ASYNC_IO___19 = 10,
    _PC_PRIO_IO___19 = 11,
    _PC_SOCK_MAXBUF___19 = 12,
    _PC_FILESIZEBITS___19 = 13,
    _PC_REC_INCR_XFER_SIZE___19 = 14,
    _PC_REC_MAX_XFER_SIZE___19 = 15,
    _PC_REC_MIN_XFER_SIZE___19 = 16,
    _PC_REC_XFER_ALIGN___19 = 17,
    _PC_ALLOC_SIZE_MIN___19 = 18,
    _PC_SYMLINK_MAX___19 = 19,
    _PC_2_SYMLINKS___19 = 20
} ;
enum __anonenum_315186338___19 {
    _SC_ARG_MAX___19 = 0,
    _SC_CHILD_MAX___19 = 1,
    _SC_CLK_TCK___19 = 2,
    _SC_NGROUPS_MAX___19 = 3,
    _SC_OPEN_MAX___19 = 4,
    _SC_STREAM_MAX___19 = 5,
    _SC_TZNAME_MAX___19 = 6,
    _SC_JOB_CONTROL___19 = 7,
    _SC_SAVED_IDS___19 = 8,
    _SC_REALTIME_SIGNALS___19 = 9,
    _SC_PRIORITY_SCHEDULING___19 = 10,
    _SC_TIMERS___19 = 11,
    _SC_ASYNCHRONOUS_IO___19 = 12,
    _SC_PRIORITIZED_IO___19 = 13,
    _SC_SYNCHRONIZED_IO___19 = 14,
    _SC_FSYNC___19 = 15,
    _SC_MAPPED_FILES___19 = 16,
    _SC_MEMLOCK___19 = 17,
    _SC_MEMLOCK_RANGE___19 = 18,
    _SC_MEMORY_PROTECTION___19 = 19,
    _SC_MESSAGE_PASSING___19 = 20,
    _SC_SEMAPHORES___19 = 21,
    _SC_SHARED_MEMORY_OBJECTS___19 = 22,
    _SC_AIO_LISTIO_MAX___19 = 23,
    _SC_AIO_MAX___19 = 24,
    _SC_AIO_PRIO_DELTA_MAX___19 = 25,
    _SC_DELAYTIMER_MAX___19 = 26,
    _SC_MQ_OPEN_MAX___19 = 27,
    _SC_MQ_PRIO_MAX___19 = 28,
    _SC_VERSION___19 = 29,
    _SC_PAGESIZE___19 = 30,
    _SC_RTSIG_MAX___19 = 31,
    _SC_SEM_NSEMS_MAX___19 = 32,
    _SC_SEM_VALUE_MAX___19 = 33,
    _SC_SIGQUEUE_MAX___19 = 34,
    _SC_TIMER_MAX___19 = 35,
    _SC_BC_BASE_MAX___19 = 36,
    _SC_BC_DIM_MAX___19 = 37,
    _SC_BC_SCALE_MAX___19 = 38,
    _SC_BC_STRING_MAX___19 = 39,
    _SC_COLL_WEIGHTS_MAX___19 = 40,
    _SC_EQUIV_CLASS_MAX___19 = 41,
    _SC_EXPR_NEST_MAX___19 = 42,
    _SC_LINE_MAX___19 = 43,
    _SC_RE_DUP_MAX___19 = 44,
    _SC_CHARCLASS_NAME_MAX___19 = 45,
    _SC_2_VERSION___19 = 46,
    _SC_2_C_BIND___19 = 47,
    _SC_2_C_DEV___19 = 48,
    _SC_2_FORT_DEV___19 = 49,
    _SC_2_FORT_RUN___19 = 50,
    _SC_2_SW_DEV___19 = 51,
    _SC_2_LOCALEDEF___19 = 52,
    _SC_PII___19 = 53,
    _SC_PII_XTI___19 = 54,
    _SC_PII_SOCKET___19 = 55,
    _SC_PII_INTERNET___19 = 56,
    _SC_PII_OSI___19 = 57,
    _SC_POLL___19 = 58,
    _SC_SELECT___19 = 59,
    _SC_UIO_MAXIOV___19 = 60,
    _SC_IOV_MAX___19 = 60,
    _SC_PII_INTERNET_STREAM___19 = 61,
    _SC_PII_INTERNET_DGRAM___19 = 62,
    _SC_PII_OSI_COTS___19 = 63,
    _SC_PII_OSI_CLTS___19 = 64,
    _SC_PII_OSI_M___19 = 65,
    _SC_T_IOV_MAX___19 = 66,
    _SC_THREADS___19 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___19 = 68,
    _SC_GETGR_R_SIZE_MAX___19 = 69,
    _SC_GETPW_R_SIZE_MAX___19 = 70,
    _SC_LOGIN_NAME_MAX___19 = 71,
    _SC_TTY_NAME_MAX___19 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___19 = 73,
    _SC_THREAD_KEYS_MAX___19 = 74,
    _SC_THREAD_STACK_MIN___19 = 75,
    _SC_THREAD_THREADS_MAX___19 = 76,
    _SC_THREAD_ATTR_STACKADDR___19 = 77,
    _SC_THREAD_ATTR_STACKSIZE___19 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___19 = 79,
    _SC_THREAD_PRIO_INHERIT___19 = 80,
    _SC_THREAD_PRIO_PROTECT___19 = 81,
    _SC_THREAD_PROCESS_SHARED___19 = 82,
    _SC_NPROCESSORS_CONF___19 = 83,
    _SC_NPROCESSORS_ONLN___19 = 84,
    _SC_PHYS_PAGES___19 = 85,
    _SC_AVPHYS_PAGES___19 = 86,
    _SC_ATEXIT_MAX___19 = 87,
    _SC_PASS_MAX___19 = 88,
    _SC_XOPEN_VERSION___19 = 89,
    _SC_XOPEN_XCU_VERSION___19 = 90,
    _SC_XOPEN_UNIX___19 = 91,
    _SC_XOPEN_CRYPT___19 = 92,
    _SC_XOPEN_ENH_I18N___19 = 93,
    _SC_XOPEN_SHM___19 = 94,
    _SC_2_CHAR_TERM___19 = 95,
    _SC_2_C_VERSION___19 = 96,
    _SC_2_UPE___19 = 97,
    _SC_XOPEN_XPG2___19 = 98,
    _SC_XOPEN_XPG3___19 = 99,
    _SC_XOPEN_XPG4___19 = 100,
    _SC_CHAR_BIT___19 = 101,
    _SC_CHAR_MAX___19 = 102,
    _SC_CHAR_MIN___19 = 103,
    _SC_INT_MAX___19 = 104,
    _SC_INT_MIN___19 = 105,
    _SC_LONG_BIT___19 = 106,
    _SC_WORD_BIT___19 = 107,
    _SC_MB_LEN_MAX___19 = 108,
    _SC_NZERO___19 = 109,
    _SC_SSIZE_MAX___19 = 110,
    _SC_SCHAR_MAX___19 = 111,
    _SC_SCHAR_MIN___19 = 112,
    _SC_SHRT_MAX___19 = 113,
    _SC_SHRT_MIN___19 = 114,
    _SC_UCHAR_MAX___19 = 115,
    _SC_UINT_MAX___19 = 116,
    _SC_ULONG_MAX___19 = 117,
    _SC_USHRT_MAX___19 = 118,
    _SC_NL_ARGMAX___19 = 119,
    _SC_NL_LANGMAX___19 = 120,
    _SC_NL_MSGMAX___19 = 121,
    _SC_NL_NMAX___19 = 122,
    _SC_NL_SETMAX___19 = 123,
    _SC_NL_TEXTMAX___19 = 124,
    _SC_XBS5_ILP32_OFF32___19 = 125,
    _SC_XBS5_ILP32_OFFBIG___19 = 126,
    _SC_XBS5_LP64_OFF64___19 = 127,
    _SC_XBS5_LPBIG_OFFBIG___19 = 128,
    _SC_XOPEN_LEGACY___19 = 129,
    _SC_XOPEN_REALTIME___19 = 130,
    _SC_XOPEN_REALTIME_THREADS___19 = 131,
    _SC_ADVISORY_INFO___19 = 132,
    _SC_BARRIERS___19 = 133,
    _SC_BASE___19 = 134,
    _SC_C_LANG_SUPPORT___19 = 135,
    _SC_C_LANG_SUPPORT_R___19 = 136,
    _SC_CLOCK_SELECTION___19 = 137,
    _SC_CPUTIME___19 = 138,
    _SC_THREAD_CPUTIME___19 = 139,
    _SC_DEVICE_IO___19 = 140,
    _SC_DEVICE_SPECIFIC___19 = 141,
    _SC_DEVICE_SPECIFIC_R___19 = 142,
    _SC_FD_MGMT___19 = 143,
    _SC_FIFO___19 = 144,
    _SC_PIPE___19 = 145,
    _SC_FILE_ATTRIBUTES___19 = 146,
    _SC_FILE_LOCKING___19 = 147,
    _SC_FILE_SYSTEM___19 = 148,
    _SC_MONOTONIC_CLOCK___19 = 149,
    _SC_MULTI_PROCESS___19 = 150,
    _SC_SINGLE_PROCESS___19 = 151,
    _SC_NETWORKING___19 = 152,
    _SC_READER_WRITER_LOCKS___19 = 153,
    _SC_SPIN_LOCKS___19 = 154,
    _SC_REGEXP___19 = 155,
    _SC_REGEX_VERSION___19 = 156,
    _SC_SHELL___19 = 157,
    _SC_SIGNALS___19 = 158,
    _SC_SPAWN___19 = 159,
    _SC_SPORADIC_SERVER___19 = 160,
    _SC_THREAD_SPORADIC_SERVER___19 = 161,
    _SC_SYSTEM_DATABASE___19 = 162,
    _SC_SYSTEM_DATABASE_R___19 = 163,
    _SC_TIMEOUTS___19 = 164,
    _SC_TYPED_MEMORY_OBJECTS___19 = 165,
    _SC_USER_GROUPS___19 = 166,
    _SC_USER_GROUPS_R___19 = 167,
    _SC_2_PBS___19 = 168,
    _SC_2_PBS_ACCOUNTING___19 = 169,
    _SC_2_PBS_LOCATE___19 = 170,
    _SC_2_PBS_MESSAGE___19 = 171,
    _SC_2_PBS_TRACK___19 = 172,
    _SC_SYMLOOP_MAX___19 = 173,
    _SC_STREAMS___19 = 174,
    _SC_2_PBS_CHECKPOINT___19 = 175,
    _SC_V6_ILP32_OFF32___19 = 176,
    _SC_V6_ILP32_OFFBIG___19 = 177,
    _SC_V6_LP64_OFF64___19 = 178,
    _SC_V6_LPBIG_OFFBIG___19 = 179,
    _SC_HOST_NAME_MAX___19 = 180,
    _SC_TRACE___19 = 181,
    _SC_TRACE_EVENT_FILTER___19 = 182,
    _SC_TRACE_INHERIT___19 = 183,
    _SC_TRACE_LOG___19 = 184,
    _SC_LEVEL1_ICACHE_SIZE___19 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___19 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___19 = 187,
    _SC_LEVEL1_DCACHE_SIZE___19 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___19 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___19 = 190,
    _SC_LEVEL2_CACHE_SIZE___19 = 191,
    _SC_LEVEL2_CACHE_ASSOC___19 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___19 = 193,
    _SC_LEVEL3_CACHE_SIZE___19 = 194,
    _SC_LEVEL3_CACHE_ASSOC___19 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___19 = 196,
    _SC_LEVEL4_CACHE_SIZE___19 = 197,
    _SC_LEVEL4_CACHE_ASSOC___19 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___19 = 199,
    _SC_IPV6___19 = 235,
    _SC_RAW_SOCKETS___19 = 236,
    _SC_V7_ILP32_OFF32___19 = 237,
    _SC_V7_ILP32_OFFBIG___19 = 238,
    _SC_V7_LP64_OFF64___19 = 239,
    _SC_V7_LPBIG_OFFBIG___19 = 240,
    _SC_SS_REPL_MAX___19 = 241,
    _SC_TRACE_EVENT_NAME_MAX___19 = 242,
    _SC_TRACE_NAME_MAX___19 = 243,
    _SC_TRACE_SYS_MAX___19 = 244,
    _SC_TRACE_USER_EVENT_MAX___19 = 245,
    _SC_XOPEN_STREAMS___19 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___19 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___19 = 248,
    _SC_MINSIGSTKSZ___19 = 249,
    _SC_SIGSTKSZ___19 = 250
} ;
enum __anonenum_875524036___19 {
    _CS_PATH___19 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___19 = 1,
    _CS_GNU_LIBC_VERSION___19 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___19 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___19 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___19 = 5,
    _CS_LFS_CFLAGS___19 = 1000,
    _CS_LFS_LDFLAGS___19 = 1001,
    _CS_LFS_LIBS___19 = 1002,
    _CS_LFS_LINTFLAGS___19 = 1003,
    _CS_LFS64_CFLAGS___19 = 1004,
    _CS_LFS64_LDFLAGS___19 = 1005,
    _CS_LFS64_LIBS___19 = 1006,
    _CS_LFS64_LINTFLAGS___19 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___19 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___19 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___19 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___19 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___19 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___19 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___19 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___19 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___19 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___19 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___19 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___19 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___19 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___19 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___19 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___19 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___19 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___19 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___19 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___19 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___19 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___19 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___19 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___19 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___19 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___19 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___19 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___19 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___19 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___19 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___19 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___19 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___19 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___19 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___19 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___19 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___19 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___19 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___19 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___19 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___19 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___19 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___19 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___19 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___19 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___19 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___19 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___19 = 1147,
    _CS_V6_ENV___19 = 1148,
    _CS_V7_ENV___19 = 1149
} ;
enum __anonenum_57186863___19 {
    SS_ONSTACK___19 = 1,
    SS_DISABLE___19 = 2
} ;
enum __anonenum_83571709___20 {
    MSG_OOB___20 = 1,
    MSG_PEEK___20 = 2,
    MSG_DONTROUTE___20 = 4,
    MSG_TRYHARD___20 = 4,
    MSG_CTRUNC___20 = 8,
    MSG_PROXY___20 = 16,
    MSG_TRUNC___20 = 32,
    MSG_DONTWAIT___20 = 64,
    MSG_EOR___20 = 128,
    MSG_WAITALL___20 = 256,
    MSG_FIN___20 = 512,
    MSG_SYN___20 = 1024,
    MSG_CONFIRM___20 = 2048,
    MSG_RST___20 = 4096,
    MSG_ERRQUEUE___20 = 8192,
    MSG_NOSIGNAL___20 = 16384,
    MSG_MORE___20 = 32768,
    MSG_WAITFORONE___20 = 65536,
    MSG_BATCH___20 = 262144,
    MSG_ZEROCOPY___20 = 67108864,
    MSG_FASTOPEN___20 = 536870912,
    MSG_CMSG_CLOEXEC___20 = 1073741824
} ;
enum __anonenum_617082774___20 {
    SCM_RIGHTS___20 = 1,
    SCM_CREDENTIALS___20 = 2
} ;
enum __anonenum_606441560___20 {
    SHUT_RD___20 = 0,
    SHUT_WR___20 = 1,
    SHUT_RDWR___20 = 2
} ;
enum __anonenum_264779956___20 {
    IPPROTO_IP___20 = 0,
    IPPROTO_ICMP___20 = 1,
    IPPROTO_IGMP___20 = 2,
    IPPROTO_IPIP___20 = 4,
    IPPROTO_TCP___20 = 6,
    IPPROTO_EGP___20 = 8,
    IPPROTO_PUP___20 = 12,
    IPPROTO_UDP___20 = 17,
    IPPROTO_IDP___20 = 22,
    IPPROTO_TP___20 = 29,
    IPPROTO_DCCP___20 = 33,
    IPPROTO_IPV6___20 = 41,
    IPPROTO_RSVP___20 = 46,
    IPPROTO_GRE___20 = 47,
    IPPROTO_ESP___20 = 50,
    IPPROTO_AH___20 = 51,
    IPPROTO_MTP___20 = 92,
    IPPROTO_BEETPH___20 = 94,
    IPPROTO_ENCAP___20 = 98,
    IPPROTO_PIM___20 = 103,
    IPPROTO_COMP___20 = 108,
    IPPROTO_SCTP___20 = 132,
    IPPROTO_UDPLITE___20 = 136,
    IPPROTO_MPLS___20 = 137,
    IPPROTO_ETHERNET___20 = 143,
    IPPROTO_RAW___20 = 255,
    IPPROTO_MPTCP___20 = 262,
    IPPROTO_MAX___20 = 263
} ;
enum __anonenum_218739988___20 {
    IPPROTO_HOPOPTS___20 = 0,
    IPPROTO_ROUTING___20 = 43,
    IPPROTO_FRAGMENT___20 = 44,
    IPPROTO_ICMPV6___20 = 58,
    IPPROTO_NONE___20 = 59,
    IPPROTO_DSTOPTS___20 = 60,
    IPPROTO_MH___20 = 135
} ;
enum __anonenum_662268580___20 {
    IPPORT_ECHO___20 = 7,
    IPPORT_DISCARD___20 = 9,
    IPPORT_SYSTAT___20 = 11,
    IPPORT_DAYTIME___20 = 13,
    IPPORT_NETSTAT___20 = 15,
    IPPORT_FTP___20 = 21,
    IPPORT_TELNET___20 = 23,
    IPPORT_SMTP___20 = 25,
    IPPORT_TIMESERVER___20 = 37,
    IPPORT_NAMESERVER___20 = 42,
    IPPORT_WHOIS___20 = 43,
    IPPORT_MTP___20 = 57,
    IPPORT_TFTP___20 = 69,
    IPPORT_RJE___20 = 77,
    IPPORT_FINGER___20 = 79,
    IPPORT_TTYLINK___20 = 87,
    IPPORT_SUPDUP___20 = 95,
    IPPORT_EXECSERVER___20 = 512,
    IPPORT_LOGINSERVER___20 = 513,
    IPPORT_CMDSERVER___20 = 514,
    IPPORT_EFSSERVER___20 = 520,
    IPPORT_BIFFUDP___20 = 512,
    IPPORT_WHOSERVER___20 = 513,
    IPPORT_ROUTESERVER___20 = 520,
    IPPORT_RESERVED___20 = 1024,
    IPPORT_USERRESERVED___20 = 5000
} ;
enum __anonenum_18926444___20 {
    _ISupper___20 = 256,
    _ISlower___20 = 512,
    _ISalpha___20 = 1024,
    _ISdigit___20 = 2048,
    _ISxdigit___20 = 4096,
    _ISspace___20 = 8192,
    _ISprint___20 = 16384,
    _ISgraph___20 = 32768,
    _ISblank___20 = 1,
    _IScntrl___20 = 2,
    _ISpunct___20 = 4,
    _ISalnum___20 = 8
} ;
enum __anonenum_913965969___20 {
    FP_INT_UPWARD___20 = 0,
    FP_INT_DOWNWARD___20 = 1,
    FP_INT_TOWARDZERO___20 = 2,
    FP_INT_TONEARESTFROMZERO___20 = 3,
    FP_INT_TONEAREST___20 = 4
} ;
enum __anonenum_1037408945___20 {
    FP_NAN___20 = 0,
    FP_INFINITE___20 = 1,
    FP_ZERO___20 = 2,
    FP_SUBNORMAL___20 = 3,
    FP_NORMAL___20 = 4
} ;
enum __anonenum_556971655___20 {
    SI_ASYNCNL___20 = -60,
    SI_DETHREAD___20 = -7,
    SI_TKILL___20 = -6,
    SI_SIGIO___20 = -5,
    SI_ASYNCIO___20 = -4,
    SI_MESGQ___20 = -3,
    SI_TIMER___20 = -2,
    SI_QUEUE___20 = -1,
    SI_USER___20 = 0,
    SI_KERNEL___20 = 128
} ;
enum __anonenum_640648963___20 {
    ILL_ILLOPC___20 = 1,
    ILL_ILLOPN___20 = 2,
    ILL_ILLADR___20 = 3,
    ILL_ILLTRP___20 = 4,
    ILL_PRVOPC___20 = 5,
    ILL_PRVREG___20 = 6,
    ILL_COPROC___20 = 7,
    ILL_BADSTK___20 = 8,
    ILL_BADIADDR___20 = 9
} ;
enum __anonenum_457704180___20 {
    FPE_INTDIV___20 = 1,
    FPE_INTOVF___20 = 2,
    FPE_FLTDIV___20 = 3,
    FPE_FLTOVF___20 = 4,
    FPE_FLTUND___20 = 5,
    FPE_FLTRES___20 = 6,
    FPE_FLTINV___20 = 7,
    FPE_FLTSUB___20 = 8,
    FPE_FLTUNK___20 = 14,
    FPE_CONDTRAP___20 = 15
} ;
enum __anonenum_180375148___20 {
    SEGV_MAPERR___20 = 1,
    SEGV_ACCERR___20 = 2,
    SEGV_BNDERR___20 = 3,
    SEGV_PKUERR___20 = 4,
    SEGV_ACCADI___20 = 5,
    SEGV_ADIDERR___20 = 6,
    SEGV_ADIPERR___20 = 7,
    SEGV_MTEAERR___20 = 8,
    SEGV_MTESERR___20 = 9
} ;
enum __anonenum_1036286214___20 {
    BUS_ADRALN___20 = 1,
    BUS_ADRERR___20 = 2,
    BUS_OBJERR___20 = 3,
    BUS_MCEERR_AR___20 = 4,
    BUS_MCEERR_AO___20 = 5
} ;
enum __anonenum_91015150___20 {
    TRAP_BRKPT___20 = 1,
    TRAP_TRACE___20 = 2,
    TRAP_BRANCH___20 = 3,
    TRAP_HWBKPT___20 = 4,
    TRAP_UNK___20 = 5
} ;
enum __anonenum_23175539___20 {
    CLD_EXITED___20 = 1,
    CLD_KILLED___20 = 2,
    CLD_DUMPED___20 = 3,
    CLD_TRAPPED___20 = 4,
    CLD_STOPPED___20 = 5,
    CLD_CONTINUED___20 = 6
} ;
enum __anonenum_111643124___20 {
    POLL_IN___20 = 1,
    POLL_OUT___20 = 2,
    POLL_MSG___20 = 3,
    POLL_ERR___20 = 4,
    POLL_PRI___20 = 5,
    POLL_HUP___20 = 6
} ;
enum __anonenum_852341087___20 {
    SIGEV_SIGNAL___20 = 0,
    SIGEV_NONE___20 = 1,
    SIGEV_THREAD___20 = 2,
    SIGEV_THREAD_ID___20 = 4
} ;
enum __anonenum_451154152___20 {
    REG_R8___20 = 0,
    REG_R9___20 = 1,
    REG_R10___20 = 2,
    REG_R11___20 = 3,
    REG_R12___20 = 4,
    REG_R13___20 = 5,
    REG_R14___20 = 6,
    REG_R15___20 = 7,
    REG_RDI___20 = 8,
    REG_RSI___20 = 9,
    REG_RBP___20 = 10,
    REG_RBX___20 = 11,
    REG_RDX___20 = 12,
    REG_RAX___20 = 13,
    REG_RCX___20 = 14,
    REG_RSP___20 = 15,
    REG_RIP___20 = 16,
    REG_EFL___20 = 17,
    REG_CSGSFS___20 = 18,
    REG_ERR___20 = 19,
    REG_TRAPNO___20 = 20,
    REG_OLDMASK___20 = 21,
    REG_CR2___20 = 22
} ;
enum __anonenum_437032235___20 {
    _PC_LINK_MAX___20 = 0,
    _PC_MAX_CANON___20 = 1,
    _PC_MAX_INPUT___20 = 2,
    _PC_NAME_MAX___20 = 3,
    _PC_PATH_MAX___20 = 4,
    _PC_PIPE_BUF___20 = 5,
    _PC_CHOWN_RESTRICTED___20 = 6,
    _PC_NO_TRUNC___20 = 7,
    _PC_VDISABLE___20 = 8,
    _PC_SYNC_IO___20 = 9,
    _PC_ASYNC_IO___20 = 10,
    _PC_PRIO_IO___20 = 11,
    _PC_SOCK_MAXBUF___20 = 12,
    _PC_FILESIZEBITS___20 = 13,
    _PC_REC_INCR_XFER_SIZE___20 = 14,
    _PC_REC_MAX_XFER_SIZE___20 = 15,
    _PC_REC_MIN_XFER_SIZE___20 = 16,
    _PC_REC_XFER_ALIGN___20 = 17,
    _PC_ALLOC_SIZE_MIN___20 = 18,
    _PC_SYMLINK_MAX___20 = 19,
    _PC_2_SYMLINKS___20 = 20
} ;
enum __anonenum_315186338___20 {
    _SC_ARG_MAX___20 = 0,
    _SC_CHILD_MAX___20 = 1,
    _SC_CLK_TCK___20 = 2,
    _SC_NGROUPS_MAX___20 = 3,
    _SC_OPEN_MAX___20 = 4,
    _SC_STREAM_MAX___20 = 5,
    _SC_TZNAME_MAX___20 = 6,
    _SC_JOB_CONTROL___20 = 7,
    _SC_SAVED_IDS___20 = 8,
    _SC_REALTIME_SIGNALS___20 = 9,
    _SC_PRIORITY_SCHEDULING___20 = 10,
    _SC_TIMERS___20 = 11,
    _SC_ASYNCHRONOUS_IO___20 = 12,
    _SC_PRIORITIZED_IO___20 = 13,
    _SC_SYNCHRONIZED_IO___20 = 14,
    _SC_FSYNC___20 = 15,
    _SC_MAPPED_FILES___20 = 16,
    _SC_MEMLOCK___20 = 17,
    _SC_MEMLOCK_RANGE___20 = 18,
    _SC_MEMORY_PROTECTION___20 = 19,
    _SC_MESSAGE_PASSING___20 = 20,
    _SC_SEMAPHORES___20 = 21,
    _SC_SHARED_MEMORY_OBJECTS___20 = 22,
    _SC_AIO_LISTIO_MAX___20 = 23,
    _SC_AIO_MAX___20 = 24,
    _SC_AIO_PRIO_DELTA_MAX___20 = 25,
    _SC_DELAYTIMER_MAX___20 = 26,
    _SC_MQ_OPEN_MAX___20 = 27,
    _SC_MQ_PRIO_MAX___20 = 28,
    _SC_VERSION___20 = 29,
    _SC_PAGESIZE___20 = 30,
    _SC_RTSIG_MAX___20 = 31,
    _SC_SEM_NSEMS_MAX___20 = 32,
    _SC_SEM_VALUE_MAX___20 = 33,
    _SC_SIGQUEUE_MAX___20 = 34,
    _SC_TIMER_MAX___20 = 35,
    _SC_BC_BASE_MAX___20 = 36,
    _SC_BC_DIM_MAX___20 = 37,
    _SC_BC_SCALE_MAX___20 = 38,
    _SC_BC_STRING_MAX___20 = 39,
    _SC_COLL_WEIGHTS_MAX___20 = 40,
    _SC_EQUIV_CLASS_MAX___20 = 41,
    _SC_EXPR_NEST_MAX___20 = 42,
    _SC_LINE_MAX___20 = 43,
    _SC_RE_DUP_MAX___20 = 44,
    _SC_CHARCLASS_NAME_MAX___20 = 45,
    _SC_2_VERSION___20 = 46,
    _SC_2_C_BIND___20 = 47,
    _SC_2_C_DEV___20 = 48,
    _SC_2_FORT_DEV___20 = 49,
    _SC_2_FORT_RUN___20 = 50,
    _SC_2_SW_DEV___20 = 51,
    _SC_2_LOCALEDEF___20 = 52,
    _SC_PII___20 = 53,
    _SC_PII_XTI___20 = 54,
    _SC_PII_SOCKET___20 = 55,
    _SC_PII_INTERNET___20 = 56,
    _SC_PII_OSI___20 = 57,
    _SC_POLL___20 = 58,
    _SC_SELECT___20 = 59,
    _SC_UIO_MAXIOV___20 = 60,
    _SC_IOV_MAX___20 = 60,
    _SC_PII_INTERNET_STREAM___20 = 61,
    _SC_PII_INTERNET_DGRAM___20 = 62,
    _SC_PII_OSI_COTS___20 = 63,
    _SC_PII_OSI_CLTS___20 = 64,
    _SC_PII_OSI_M___20 = 65,
    _SC_T_IOV_MAX___20 = 66,
    _SC_THREADS___20 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___20 = 68,
    _SC_GETGR_R_SIZE_MAX___20 = 69,
    _SC_GETPW_R_SIZE_MAX___20 = 70,
    _SC_LOGIN_NAME_MAX___20 = 71,
    _SC_TTY_NAME_MAX___20 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___20 = 73,
    _SC_THREAD_KEYS_MAX___20 = 74,
    _SC_THREAD_STACK_MIN___20 = 75,
    _SC_THREAD_THREADS_MAX___20 = 76,
    _SC_THREAD_ATTR_STACKADDR___20 = 77,
    _SC_THREAD_ATTR_STACKSIZE___20 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___20 = 79,
    _SC_THREAD_PRIO_INHERIT___20 = 80,
    _SC_THREAD_PRIO_PROTECT___20 = 81,
    _SC_THREAD_PROCESS_SHARED___20 = 82,
    _SC_NPROCESSORS_CONF___20 = 83,
    _SC_NPROCESSORS_ONLN___20 = 84,
    _SC_PHYS_PAGES___20 = 85,
    _SC_AVPHYS_PAGES___20 = 86,
    _SC_ATEXIT_MAX___20 = 87,
    _SC_PASS_MAX___20 = 88,
    _SC_XOPEN_VERSION___20 = 89,
    _SC_XOPEN_XCU_VERSION___20 = 90,
    _SC_XOPEN_UNIX___20 = 91,
    _SC_XOPEN_CRYPT___20 = 92,
    _SC_XOPEN_ENH_I18N___20 = 93,
    _SC_XOPEN_SHM___20 = 94,
    _SC_2_CHAR_TERM___20 = 95,
    _SC_2_C_VERSION___20 = 96,
    _SC_2_UPE___20 = 97,
    _SC_XOPEN_XPG2___20 = 98,
    _SC_XOPEN_XPG3___20 = 99,
    _SC_XOPEN_XPG4___20 = 100,
    _SC_CHAR_BIT___20 = 101,
    _SC_CHAR_MAX___20 = 102,
    _SC_CHAR_MIN___20 = 103,
    _SC_INT_MAX___20 = 104,
    _SC_INT_MIN___20 = 105,
    _SC_LONG_BIT___20 = 106,
    _SC_WORD_BIT___20 = 107,
    _SC_MB_LEN_MAX___20 = 108,
    _SC_NZERO___20 = 109,
    _SC_SSIZE_MAX___20 = 110,
    _SC_SCHAR_MAX___20 = 111,
    _SC_SCHAR_MIN___20 = 112,
    _SC_SHRT_MAX___20 = 113,
    _SC_SHRT_MIN___20 = 114,
    _SC_UCHAR_MAX___20 = 115,
    _SC_UINT_MAX___20 = 116,
    _SC_ULONG_MAX___20 = 117,
    _SC_USHRT_MAX___20 = 118,
    _SC_NL_ARGMAX___20 = 119,
    _SC_NL_LANGMAX___20 = 120,
    _SC_NL_MSGMAX___20 = 121,
    _SC_NL_NMAX___20 = 122,
    _SC_NL_SETMAX___20 = 123,
    _SC_NL_TEXTMAX___20 = 124,
    _SC_XBS5_ILP32_OFF32___20 = 125,
    _SC_XBS5_ILP32_OFFBIG___20 = 126,
    _SC_XBS5_LP64_OFF64___20 = 127,
    _SC_XBS5_LPBIG_OFFBIG___20 = 128,
    _SC_XOPEN_LEGACY___20 = 129,
    _SC_XOPEN_REALTIME___20 = 130,
    _SC_XOPEN_REALTIME_THREADS___20 = 131,
    _SC_ADVISORY_INFO___20 = 132,
    _SC_BARRIERS___20 = 133,
    _SC_BASE___20 = 134,
    _SC_C_LANG_SUPPORT___20 = 135,
    _SC_C_LANG_SUPPORT_R___20 = 136,
    _SC_CLOCK_SELECTION___20 = 137,
    _SC_CPUTIME___20 = 138,
    _SC_THREAD_CPUTIME___20 = 139,
    _SC_DEVICE_IO___20 = 140,
    _SC_DEVICE_SPECIFIC___20 = 141,
    _SC_DEVICE_SPECIFIC_R___20 = 142,
    _SC_FD_MGMT___20 = 143,
    _SC_FIFO___20 = 144,
    _SC_PIPE___20 = 145,
    _SC_FILE_ATTRIBUTES___20 = 146,
    _SC_FILE_LOCKING___20 = 147,
    _SC_FILE_SYSTEM___20 = 148,
    _SC_MONOTONIC_CLOCK___20 = 149,
    _SC_MULTI_PROCESS___20 = 150,
    _SC_SINGLE_PROCESS___20 = 151,
    _SC_NETWORKING___20 = 152,
    _SC_READER_WRITER_LOCKS___20 = 153,
    _SC_SPIN_LOCKS___20 = 154,
    _SC_REGEXP___20 = 155,
    _SC_REGEX_VERSION___20 = 156,
    _SC_SHELL___20 = 157,
    _SC_SIGNALS___20 = 158,
    _SC_SPAWN___20 = 159,
    _SC_SPORADIC_SERVER___20 = 160,
    _SC_THREAD_SPORADIC_SERVER___20 = 161,
    _SC_SYSTEM_DATABASE___20 = 162,
    _SC_SYSTEM_DATABASE_R___20 = 163,
    _SC_TIMEOUTS___20 = 164,
    _SC_TYPED_MEMORY_OBJECTS___20 = 165,
    _SC_USER_GROUPS___20 = 166,
    _SC_USER_GROUPS_R___20 = 167,
    _SC_2_PBS___20 = 168,
    _SC_2_PBS_ACCOUNTING___20 = 169,
    _SC_2_PBS_LOCATE___20 = 170,
    _SC_2_PBS_MESSAGE___20 = 171,
    _SC_2_PBS_TRACK___20 = 172,
    _SC_SYMLOOP_MAX___20 = 173,
    _SC_STREAMS___20 = 174,
    _SC_2_PBS_CHECKPOINT___20 = 175,
    _SC_V6_ILP32_OFF32___20 = 176,
    _SC_V6_ILP32_OFFBIG___20 = 177,
    _SC_V6_LP64_OFF64___20 = 178,
    _SC_V6_LPBIG_OFFBIG___20 = 179,
    _SC_HOST_NAME_MAX___20 = 180,
    _SC_TRACE___20 = 181,
    _SC_TRACE_EVENT_FILTER___20 = 182,
    _SC_TRACE_INHERIT___20 = 183,
    _SC_TRACE_LOG___20 = 184,
    _SC_LEVEL1_ICACHE_SIZE___20 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___20 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___20 = 187,
    _SC_LEVEL1_DCACHE_SIZE___20 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___20 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___20 = 190,
    _SC_LEVEL2_CACHE_SIZE___20 = 191,
    _SC_LEVEL2_CACHE_ASSOC___20 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___20 = 193,
    _SC_LEVEL3_CACHE_SIZE___20 = 194,
    _SC_LEVEL3_CACHE_ASSOC___20 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___20 = 196,
    _SC_LEVEL4_CACHE_SIZE___20 = 197,
    _SC_LEVEL4_CACHE_ASSOC___20 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___20 = 199,
    _SC_IPV6___20 = 235,
    _SC_RAW_SOCKETS___20 = 236,
    _SC_V7_ILP32_OFF32___20 = 237,
    _SC_V7_ILP32_OFFBIG___20 = 238,
    _SC_V7_LP64_OFF64___20 = 239,
    _SC_V7_LPBIG_OFFBIG___20 = 240,
    _SC_SS_REPL_MAX___20 = 241,
    _SC_TRACE_EVENT_NAME_MAX___20 = 242,
    _SC_TRACE_NAME_MAX___20 = 243,
    _SC_TRACE_SYS_MAX___20 = 244,
    _SC_TRACE_USER_EVENT_MAX___20 = 245,
    _SC_XOPEN_STREAMS___20 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___20 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___20 = 248,
    _SC_MINSIGSTKSZ___20 = 249,
    _SC_SIGSTKSZ___20 = 250
} ;
enum __anonenum_875524036___20 {
    _CS_PATH___20 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___20 = 1,
    _CS_GNU_LIBC_VERSION___20 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___20 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___20 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___20 = 5,
    _CS_LFS_CFLAGS___20 = 1000,
    _CS_LFS_LDFLAGS___20 = 1001,
    _CS_LFS_LIBS___20 = 1002,
    _CS_LFS_LINTFLAGS___20 = 1003,
    _CS_LFS64_CFLAGS___20 = 1004,
    _CS_LFS64_LDFLAGS___20 = 1005,
    _CS_LFS64_LIBS___20 = 1006,
    _CS_LFS64_LINTFLAGS___20 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___20 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___20 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___20 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___20 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___20 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___20 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___20 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___20 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___20 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___20 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___20 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___20 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___20 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___20 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___20 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___20 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___20 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___20 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___20 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___20 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___20 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___20 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___20 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___20 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___20 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___20 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___20 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___20 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___20 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___20 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___20 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___20 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___20 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___20 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___20 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___20 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___20 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___20 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___20 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___20 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___20 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___20 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___20 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___20 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___20 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___20 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___20 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___20 = 1147,
    _CS_V6_ENV___20 = 1148,
    _CS_V7_ENV___20 = 1149
} ;
enum __anonenum_57186863___20 {
    SS_ONSTACK___20 = 1,
    SS_DISABLE___20 = 2
} ;
enum __anonenum_83571709___21 {
    MSG_OOB___21 = 1,
    MSG_PEEK___21 = 2,
    MSG_DONTROUTE___21 = 4,
    MSG_TRYHARD___21 = 4,
    MSG_CTRUNC___21 = 8,
    MSG_PROXY___21 = 16,
    MSG_TRUNC___21 = 32,
    MSG_DONTWAIT___21 = 64,
    MSG_EOR___21 = 128,
    MSG_WAITALL___21 = 256,
    MSG_FIN___21 = 512,
    MSG_SYN___21 = 1024,
    MSG_CONFIRM___21 = 2048,
    MSG_RST___21 = 4096,
    MSG_ERRQUEUE___21 = 8192,
    MSG_NOSIGNAL___21 = 16384,
    MSG_MORE___21 = 32768,
    MSG_WAITFORONE___21 = 65536,
    MSG_BATCH___21 = 262144,
    MSG_ZEROCOPY___21 = 67108864,
    MSG_FASTOPEN___21 = 536870912,
    MSG_CMSG_CLOEXEC___21 = 1073741824
} ;
enum __anonenum_617082774___21 {
    SCM_RIGHTS___21 = 1,
    SCM_CREDENTIALS___21 = 2
} ;
enum __anonenum_606441560___21 {
    SHUT_RD___21 = 0,
    SHUT_WR___21 = 1,
    SHUT_RDWR___21 = 2
} ;
enum __anonenum_264779956___21 {
    IPPROTO_IP___21 = 0,
    IPPROTO_ICMP___21 = 1,
    IPPROTO_IGMP___21 = 2,
    IPPROTO_IPIP___21 = 4,
    IPPROTO_TCP___21 = 6,
    IPPROTO_EGP___21 = 8,
    IPPROTO_PUP___21 = 12,
    IPPROTO_UDP___21 = 17,
    IPPROTO_IDP___21 = 22,
    IPPROTO_TP___21 = 29,
    IPPROTO_DCCP___21 = 33,
    IPPROTO_IPV6___21 = 41,
    IPPROTO_RSVP___21 = 46,
    IPPROTO_GRE___21 = 47,
    IPPROTO_ESP___21 = 50,
    IPPROTO_AH___21 = 51,
    IPPROTO_MTP___21 = 92,
    IPPROTO_BEETPH___21 = 94,
    IPPROTO_ENCAP___21 = 98,
    IPPROTO_PIM___21 = 103,
    IPPROTO_COMP___21 = 108,
    IPPROTO_SCTP___21 = 132,
    IPPROTO_UDPLITE___21 = 136,
    IPPROTO_MPLS___21 = 137,
    IPPROTO_ETHERNET___21 = 143,
    IPPROTO_RAW___21 = 255,
    IPPROTO_MPTCP___21 = 262,
    IPPROTO_MAX___21 = 263
} ;
enum __anonenum_218739988___21 {
    IPPROTO_HOPOPTS___21 = 0,
    IPPROTO_ROUTING___21 = 43,
    IPPROTO_FRAGMENT___21 = 44,
    IPPROTO_ICMPV6___21 = 58,
    IPPROTO_NONE___21 = 59,
    IPPROTO_DSTOPTS___21 = 60,
    IPPROTO_MH___21 = 135
} ;
enum __anonenum_662268580___21 {
    IPPORT_ECHO___21 = 7,
    IPPORT_DISCARD___21 = 9,
    IPPORT_SYSTAT___21 = 11,
    IPPORT_DAYTIME___21 = 13,
    IPPORT_NETSTAT___21 = 15,
    IPPORT_FTP___21 = 21,
    IPPORT_TELNET___21 = 23,
    IPPORT_SMTP___21 = 25,
    IPPORT_TIMESERVER___21 = 37,
    IPPORT_NAMESERVER___21 = 42,
    IPPORT_WHOIS___21 = 43,
    IPPORT_MTP___21 = 57,
    IPPORT_TFTP___21 = 69,
    IPPORT_RJE___21 = 77,
    IPPORT_FINGER___21 = 79,
    IPPORT_TTYLINK___21 = 87,
    IPPORT_SUPDUP___21 = 95,
    IPPORT_EXECSERVER___21 = 512,
    IPPORT_LOGINSERVER___21 = 513,
    IPPORT_CMDSERVER___21 = 514,
    IPPORT_EFSSERVER___21 = 520,
    IPPORT_BIFFUDP___21 = 512,
    IPPORT_WHOSERVER___21 = 513,
    IPPORT_ROUTESERVER___21 = 520,
    IPPORT_RESERVED___21 = 1024,
    IPPORT_USERRESERVED___21 = 5000
} ;
enum __anonenum_18926444___21 {
    _ISupper___21 = 256,
    _ISlower___21 = 512,
    _ISalpha___21 = 1024,
    _ISdigit___21 = 2048,
    _ISxdigit___21 = 4096,
    _ISspace___21 = 8192,
    _ISprint___21 = 16384,
    _ISgraph___21 = 32768,
    _ISblank___21 = 1,
    _IScntrl___21 = 2,
    _ISpunct___21 = 4,
    _ISalnum___21 = 8
} ;
enum __anonenum_913965969___21 {
    FP_INT_UPWARD___21 = 0,
    FP_INT_DOWNWARD___21 = 1,
    FP_INT_TOWARDZERO___21 = 2,
    FP_INT_TONEARESTFROMZERO___21 = 3,
    FP_INT_TONEAREST___21 = 4
} ;
enum __anonenum_1037408945___21 {
    FP_NAN___21 = 0,
    FP_INFINITE___21 = 1,
    FP_ZERO___21 = 2,
    FP_SUBNORMAL___21 = 3,
    FP_NORMAL___21 = 4
} ;
enum __anonenum_556971655___21 {
    SI_ASYNCNL___21 = -60,
    SI_DETHREAD___21 = -7,
    SI_TKILL___21 = -6,
    SI_SIGIO___21 = -5,
    SI_ASYNCIO___21 = -4,
    SI_MESGQ___21 = -3,
    SI_TIMER___21 = -2,
    SI_QUEUE___21 = -1,
    SI_USER___21 = 0,
    SI_KERNEL___21 = 128
} ;
enum __anonenum_640648963___21 {
    ILL_ILLOPC___21 = 1,
    ILL_ILLOPN___21 = 2,
    ILL_ILLADR___21 = 3,
    ILL_ILLTRP___21 = 4,
    ILL_PRVOPC___21 = 5,
    ILL_PRVREG___21 = 6,
    ILL_COPROC___21 = 7,
    ILL_BADSTK___21 = 8,
    ILL_BADIADDR___21 = 9
} ;
enum __anonenum_457704180___21 {
    FPE_INTDIV___21 = 1,
    FPE_INTOVF___21 = 2,
    FPE_FLTDIV___21 = 3,
    FPE_FLTOVF___21 = 4,
    FPE_FLTUND___21 = 5,
    FPE_FLTRES___21 = 6,
    FPE_FLTINV___21 = 7,
    FPE_FLTSUB___21 = 8,
    FPE_FLTUNK___21 = 14,
    FPE_CONDTRAP___21 = 15
} ;
enum __anonenum_180375148___21 {
    SEGV_MAPERR___21 = 1,
    SEGV_ACCERR___21 = 2,
    SEGV_BNDERR___21 = 3,
    SEGV_PKUERR___21 = 4,
    SEGV_ACCADI___21 = 5,
    SEGV_ADIDERR___21 = 6,
    SEGV_ADIPERR___21 = 7,
    SEGV_MTEAERR___21 = 8,
    SEGV_MTESERR___21 = 9
} ;
enum __anonenum_1036286214___21 {
    BUS_ADRALN___21 = 1,
    BUS_ADRERR___21 = 2,
    BUS_OBJERR___21 = 3,
    BUS_MCEERR_AR___21 = 4,
    BUS_MCEERR_AO___21 = 5
} ;
enum __anonenum_91015150___21 {
    TRAP_BRKPT___21 = 1,
    TRAP_TRACE___21 = 2,
    TRAP_BRANCH___21 = 3,
    TRAP_HWBKPT___21 = 4,
    TRAP_UNK___21 = 5
} ;
enum __anonenum_23175539___21 {
    CLD_EXITED___21 = 1,
    CLD_KILLED___21 = 2,
    CLD_DUMPED___21 = 3,
    CLD_TRAPPED___21 = 4,
    CLD_STOPPED___21 = 5,
    CLD_CONTINUED___21 = 6
} ;
enum __anonenum_111643124___21 {
    POLL_IN___21 = 1,
    POLL_OUT___21 = 2,
    POLL_MSG___21 = 3,
    POLL_ERR___21 = 4,
    POLL_PRI___21 = 5,
    POLL_HUP___21 = 6
} ;
enum __anonenum_852341087___21 {
    SIGEV_SIGNAL___21 = 0,
    SIGEV_NONE___21 = 1,
    SIGEV_THREAD___21 = 2,
    SIGEV_THREAD_ID___21 = 4
} ;
enum __anonenum_451154152___21 {
    REG_R8___21 = 0,
    REG_R9___21 = 1,
    REG_R10___21 = 2,
    REG_R11___21 = 3,
    REG_R12___21 = 4,
    REG_R13___21 = 5,
    REG_R14___21 = 6,
    REG_R15___21 = 7,
    REG_RDI___21 = 8,
    REG_RSI___21 = 9,
    REG_RBP___21 = 10,
    REG_RBX___21 = 11,
    REG_RDX___21 = 12,
    REG_RAX___21 = 13,
    REG_RCX___21 = 14,
    REG_RSP___21 = 15,
    REG_RIP___21 = 16,
    REG_EFL___21 = 17,
    REG_CSGSFS___21 = 18,
    REG_ERR___21 = 19,
    REG_TRAPNO___21 = 20,
    REG_OLDMASK___21 = 21,
    REG_CR2___21 = 22
} ;
enum __anonenum_437032235___21 {
    _PC_LINK_MAX___21 = 0,
    _PC_MAX_CANON___21 = 1,
    _PC_MAX_INPUT___21 = 2,
    _PC_NAME_MAX___21 = 3,
    _PC_PATH_MAX___21 = 4,
    _PC_PIPE_BUF___21 = 5,
    _PC_CHOWN_RESTRICTED___21 = 6,
    _PC_NO_TRUNC___21 = 7,
    _PC_VDISABLE___21 = 8,
    _PC_SYNC_IO___21 = 9,
    _PC_ASYNC_IO___21 = 10,
    _PC_PRIO_IO___21 = 11,
    _PC_SOCK_MAXBUF___21 = 12,
    _PC_FILESIZEBITS___21 = 13,
    _PC_REC_INCR_XFER_SIZE___21 = 14,
    _PC_REC_MAX_XFER_SIZE___21 = 15,
    _PC_REC_MIN_XFER_SIZE___21 = 16,
    _PC_REC_XFER_ALIGN___21 = 17,
    _PC_ALLOC_SIZE_MIN___21 = 18,
    _PC_SYMLINK_MAX___21 = 19,
    _PC_2_SYMLINKS___21 = 20
} ;
enum __anonenum_315186338___21 {
    _SC_ARG_MAX___21 = 0,
    _SC_CHILD_MAX___21 = 1,
    _SC_CLK_TCK___21 = 2,
    _SC_NGROUPS_MAX___21 = 3,
    _SC_OPEN_MAX___21 = 4,
    _SC_STREAM_MAX___21 = 5,
    _SC_TZNAME_MAX___21 = 6,
    _SC_JOB_CONTROL___21 = 7,
    _SC_SAVED_IDS___21 = 8,
    _SC_REALTIME_SIGNALS___21 = 9,
    _SC_PRIORITY_SCHEDULING___21 = 10,
    _SC_TIMERS___21 = 11,
    _SC_ASYNCHRONOUS_IO___21 = 12,
    _SC_PRIORITIZED_IO___21 = 13,
    _SC_SYNCHRONIZED_IO___21 = 14,
    _SC_FSYNC___21 = 15,
    _SC_MAPPED_FILES___21 = 16,
    _SC_MEMLOCK___21 = 17,
    _SC_MEMLOCK_RANGE___21 = 18,
    _SC_MEMORY_PROTECTION___21 = 19,
    _SC_MESSAGE_PASSING___21 = 20,
    _SC_SEMAPHORES___21 = 21,
    _SC_SHARED_MEMORY_OBJECTS___21 = 22,
    _SC_AIO_LISTIO_MAX___21 = 23,
    _SC_AIO_MAX___21 = 24,
    _SC_AIO_PRIO_DELTA_MAX___21 = 25,
    _SC_DELAYTIMER_MAX___21 = 26,
    _SC_MQ_OPEN_MAX___21 = 27,
    _SC_MQ_PRIO_MAX___21 = 28,
    _SC_VERSION___21 = 29,
    _SC_PAGESIZE___21 = 30,
    _SC_RTSIG_MAX___21 = 31,
    _SC_SEM_NSEMS_MAX___21 = 32,
    _SC_SEM_VALUE_MAX___21 = 33,
    _SC_SIGQUEUE_MAX___21 = 34,
    _SC_TIMER_MAX___21 = 35,
    _SC_BC_BASE_MAX___21 = 36,
    _SC_BC_DIM_MAX___21 = 37,
    _SC_BC_SCALE_MAX___21 = 38,
    _SC_BC_STRING_MAX___21 = 39,
    _SC_COLL_WEIGHTS_MAX___21 = 40,
    _SC_EQUIV_CLASS_MAX___21 = 41,
    _SC_EXPR_NEST_MAX___21 = 42,
    _SC_LINE_MAX___21 = 43,
    _SC_RE_DUP_MAX___21 = 44,
    _SC_CHARCLASS_NAME_MAX___21 = 45,
    _SC_2_VERSION___21 = 46,
    _SC_2_C_BIND___21 = 47,
    _SC_2_C_DEV___21 = 48,
    _SC_2_FORT_DEV___21 = 49,
    _SC_2_FORT_RUN___21 = 50,
    _SC_2_SW_DEV___21 = 51,
    _SC_2_LOCALEDEF___21 = 52,
    _SC_PII___21 = 53,
    _SC_PII_XTI___21 = 54,
    _SC_PII_SOCKET___21 = 55,
    _SC_PII_INTERNET___21 = 56,
    _SC_PII_OSI___21 = 57,
    _SC_POLL___21 = 58,
    _SC_SELECT___21 = 59,
    _SC_UIO_MAXIOV___21 = 60,
    _SC_IOV_MAX___21 = 60,
    _SC_PII_INTERNET_STREAM___21 = 61,
    _SC_PII_INTERNET_DGRAM___21 = 62,
    _SC_PII_OSI_COTS___21 = 63,
    _SC_PII_OSI_CLTS___21 = 64,
    _SC_PII_OSI_M___21 = 65,
    _SC_T_IOV_MAX___21 = 66,
    _SC_THREADS___21 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___21 = 68,
    _SC_GETGR_R_SIZE_MAX___21 = 69,
    _SC_GETPW_R_SIZE_MAX___21 = 70,
    _SC_LOGIN_NAME_MAX___21 = 71,
    _SC_TTY_NAME_MAX___21 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___21 = 73,
    _SC_THREAD_KEYS_MAX___21 = 74,
    _SC_THREAD_STACK_MIN___21 = 75,
    _SC_THREAD_THREADS_MAX___21 = 76,
    _SC_THREAD_ATTR_STACKADDR___21 = 77,
    _SC_THREAD_ATTR_STACKSIZE___21 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___21 = 79,
    _SC_THREAD_PRIO_INHERIT___21 = 80,
    _SC_THREAD_PRIO_PROTECT___21 = 81,
    _SC_THREAD_PROCESS_SHARED___21 = 82,
    _SC_NPROCESSORS_CONF___21 = 83,
    _SC_NPROCESSORS_ONLN___21 = 84,
    _SC_PHYS_PAGES___21 = 85,
    _SC_AVPHYS_PAGES___21 = 86,
    _SC_ATEXIT_MAX___21 = 87,
    _SC_PASS_MAX___21 = 88,
    _SC_XOPEN_VERSION___21 = 89,
    _SC_XOPEN_XCU_VERSION___21 = 90,
    _SC_XOPEN_UNIX___21 = 91,
    _SC_XOPEN_CRYPT___21 = 92,
    _SC_XOPEN_ENH_I18N___21 = 93,
    _SC_XOPEN_SHM___21 = 94,
    _SC_2_CHAR_TERM___21 = 95,
    _SC_2_C_VERSION___21 = 96,
    _SC_2_UPE___21 = 97,
    _SC_XOPEN_XPG2___21 = 98,
    _SC_XOPEN_XPG3___21 = 99,
    _SC_XOPEN_XPG4___21 = 100,
    _SC_CHAR_BIT___21 = 101,
    _SC_CHAR_MAX___21 = 102,
    _SC_CHAR_MIN___21 = 103,
    _SC_INT_MAX___21 = 104,
    _SC_INT_MIN___21 = 105,
    _SC_LONG_BIT___21 = 106,
    _SC_WORD_BIT___21 = 107,
    _SC_MB_LEN_MAX___21 = 108,
    _SC_NZERO___21 = 109,
    _SC_SSIZE_MAX___21 = 110,
    _SC_SCHAR_MAX___21 = 111,
    _SC_SCHAR_MIN___21 = 112,
    _SC_SHRT_MAX___21 = 113,
    _SC_SHRT_MIN___21 = 114,
    _SC_UCHAR_MAX___21 = 115,
    _SC_UINT_MAX___21 = 116,
    _SC_ULONG_MAX___21 = 117,
    _SC_USHRT_MAX___21 = 118,
    _SC_NL_ARGMAX___21 = 119,
    _SC_NL_LANGMAX___21 = 120,
    _SC_NL_MSGMAX___21 = 121,
    _SC_NL_NMAX___21 = 122,
    _SC_NL_SETMAX___21 = 123,
    _SC_NL_TEXTMAX___21 = 124,
    _SC_XBS5_ILP32_OFF32___21 = 125,
    _SC_XBS5_ILP32_OFFBIG___21 = 126,
    _SC_XBS5_LP64_OFF64___21 = 127,
    _SC_XBS5_LPBIG_OFFBIG___21 = 128,
    _SC_XOPEN_LEGACY___21 = 129,
    _SC_XOPEN_REALTIME___21 = 130,
    _SC_XOPEN_REALTIME_THREADS___21 = 131,
    _SC_ADVISORY_INFO___21 = 132,
    _SC_BARRIERS___21 = 133,
    _SC_BASE___21 = 134,
    _SC_C_LANG_SUPPORT___21 = 135,
    _SC_C_LANG_SUPPORT_R___21 = 136,
    _SC_CLOCK_SELECTION___21 = 137,
    _SC_CPUTIME___21 = 138,
    _SC_THREAD_CPUTIME___21 = 139,
    _SC_DEVICE_IO___21 = 140,
    _SC_DEVICE_SPECIFIC___21 = 141,
    _SC_DEVICE_SPECIFIC_R___21 = 142,
    _SC_FD_MGMT___21 = 143,
    _SC_FIFO___21 = 144,
    _SC_PIPE___21 = 145,
    _SC_FILE_ATTRIBUTES___21 = 146,
    _SC_FILE_LOCKING___21 = 147,
    _SC_FILE_SYSTEM___21 = 148,
    _SC_MONOTONIC_CLOCK___21 = 149,
    _SC_MULTI_PROCESS___21 = 150,
    _SC_SINGLE_PROCESS___21 = 151,
    _SC_NETWORKING___21 = 152,
    _SC_READER_WRITER_LOCKS___21 = 153,
    _SC_SPIN_LOCKS___21 = 154,
    _SC_REGEXP___21 = 155,
    _SC_REGEX_VERSION___21 = 156,
    _SC_SHELL___21 = 157,
    _SC_SIGNALS___21 = 158,
    _SC_SPAWN___21 = 159,
    _SC_SPORADIC_SERVER___21 = 160,
    _SC_THREAD_SPORADIC_SERVER___21 = 161,
    _SC_SYSTEM_DATABASE___21 = 162,
    _SC_SYSTEM_DATABASE_R___21 = 163,
    _SC_TIMEOUTS___21 = 164,
    _SC_TYPED_MEMORY_OBJECTS___21 = 165,
    _SC_USER_GROUPS___21 = 166,
    _SC_USER_GROUPS_R___21 = 167,
    _SC_2_PBS___21 = 168,
    _SC_2_PBS_ACCOUNTING___21 = 169,
    _SC_2_PBS_LOCATE___21 = 170,
    _SC_2_PBS_MESSAGE___21 = 171,
    _SC_2_PBS_TRACK___21 = 172,
    _SC_SYMLOOP_MAX___21 = 173,
    _SC_STREAMS___21 = 174,
    _SC_2_PBS_CHECKPOINT___21 = 175,
    _SC_V6_ILP32_OFF32___21 = 176,
    _SC_V6_ILP32_OFFBIG___21 = 177,
    _SC_V6_LP64_OFF64___21 = 178,
    _SC_V6_LPBIG_OFFBIG___21 = 179,
    _SC_HOST_NAME_MAX___21 = 180,
    _SC_TRACE___21 = 181,
    _SC_TRACE_EVENT_FILTER___21 = 182,
    _SC_TRACE_INHERIT___21 = 183,
    _SC_TRACE_LOG___21 = 184,
    _SC_LEVEL1_ICACHE_SIZE___21 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___21 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___21 = 187,
    _SC_LEVEL1_DCACHE_SIZE___21 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___21 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___21 = 190,
    _SC_LEVEL2_CACHE_SIZE___21 = 191,
    _SC_LEVEL2_CACHE_ASSOC___21 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___21 = 193,
    _SC_LEVEL3_CACHE_SIZE___21 = 194,
    _SC_LEVEL3_CACHE_ASSOC___21 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___21 = 196,
    _SC_LEVEL4_CACHE_SIZE___21 = 197,
    _SC_LEVEL4_CACHE_ASSOC___21 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___21 = 199,
    _SC_IPV6___21 = 235,
    _SC_RAW_SOCKETS___21 = 236,
    _SC_V7_ILP32_OFF32___21 = 237,
    _SC_V7_ILP32_OFFBIG___21 = 238,
    _SC_V7_LP64_OFF64___21 = 239,
    _SC_V7_LPBIG_OFFBIG___21 = 240,
    _SC_SS_REPL_MAX___21 = 241,
    _SC_TRACE_EVENT_NAME_MAX___21 = 242,
    _SC_TRACE_NAME_MAX___21 = 243,
    _SC_TRACE_SYS_MAX___21 = 244,
    _SC_TRACE_USER_EVENT_MAX___21 = 245,
    _SC_XOPEN_STREAMS___21 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___21 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___21 = 248,
    _SC_MINSIGSTKSZ___21 = 249,
    _SC_SIGSTKSZ___21 = 250
} ;
enum __anonenum_875524036___21 {
    _CS_PATH___21 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___21 = 1,
    _CS_GNU_LIBC_VERSION___21 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___21 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___21 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___21 = 5,
    _CS_LFS_CFLAGS___21 = 1000,
    _CS_LFS_LDFLAGS___21 = 1001,
    _CS_LFS_LIBS___21 = 1002,
    _CS_LFS_LINTFLAGS___21 = 1003,
    _CS_LFS64_CFLAGS___21 = 1004,
    _CS_LFS64_LDFLAGS___21 = 1005,
    _CS_LFS64_LIBS___21 = 1006,
    _CS_LFS64_LINTFLAGS___21 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___21 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___21 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___21 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___21 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___21 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___21 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___21 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___21 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___21 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___21 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___21 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___21 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___21 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___21 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___21 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___21 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___21 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___21 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___21 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___21 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___21 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___21 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___21 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___21 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___21 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___21 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___21 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___21 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___21 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___21 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___21 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___21 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___21 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___21 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___21 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___21 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___21 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___21 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___21 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___21 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___21 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___21 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___21 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___21 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___21 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___21 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___21 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___21 = 1147,
    _CS_V6_ENV___21 = 1148,
    _CS_V7_ENV___21 = 1149
} ;
enum __anonenum_57186863___21 {
    SS_ONSTACK___21 = 1,
    SS_DISABLE___21 = 2
} ;
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char domainname[65] ;
};
struct ptp_clock_time {
   __s64 sec ;
   __u32 nsec ;
   __u32 reserved ;
};
struct ptp_clock_caps {
   int max_adj ;
   int n_alarm ;
   int n_ext_ts ;
   int n_per_out ;
   int pps ;
   int n_pins ;
   int cross_timestamping ;
   int adjust_phase ;
   int rsv[12] ;
};
struct ptp_extts_request {
   unsigned int index ;
   unsigned int flags ;
   unsigned int rsv[2] ;
};
union __anonunion____missing_field_name_419755100 {
   struct ptp_clock_time start ;
   struct ptp_clock_time phase ;
};
union __anonunion____missing_field_name_897667944 {
   struct ptp_clock_time on ;
   unsigned int rsv[4] ;
};
struct ptp_perout_request {
   union __anonunion____missing_field_name_419755100 __annonCompField2 ;
   struct ptp_clock_time period ;
   unsigned int index ;
   unsigned int flags ;
   union __anonunion____missing_field_name_897667944 __annonCompField3 ;
};
struct ptp_sys_offset {
   unsigned int n_samples ;
   unsigned int rsv[3] ;
   struct ptp_clock_time ts[51] ;
};
struct ptp_sys_offset_extended {
   unsigned int n_samples ;
   unsigned int rsv[3] ;
   struct ptp_clock_time ts[25][3] ;
};
struct ptp_sys_offset_precise {
   struct ptp_clock_time device ;
   struct ptp_clock_time sys_realtime ;
   struct ptp_clock_time sys_monoraw ;
   unsigned int rsv[4] ;
};
enum ptp_pin_function {
    PTP_PF_NONE = 0,
    PTP_PF_EXTTS = 1,
    PTP_PF_PEROUT = 2,
    PTP_PF_PHYSYNC = 3
} ;
struct ptp_pin_desc {
   char name[64] ;
   unsigned int index ;
   unsigned int func ;
   unsigned int chan ;
   unsigned int rsv[5] ;
};
struct ptp_extts_event {
   struct ptp_clock_time t ;
   unsigned int index ;
   unsigned int flags ;
   unsigned int rsv[2] ;
};
enum __anonenum_83571709___22 {
    MSG_OOB___22 = 1,
    MSG_PEEK___22 = 2,
    MSG_DONTROUTE___22 = 4,
    MSG_TRYHARD___22 = 4,
    MSG_CTRUNC___22 = 8,
    MSG_PROXY___22 = 16,
    MSG_TRUNC___22 = 32,
    MSG_DONTWAIT___22 = 64,
    MSG_EOR___22 = 128,
    MSG_WAITALL___22 = 256,
    MSG_FIN___22 = 512,
    MSG_SYN___22 = 1024,
    MSG_CONFIRM___22 = 2048,
    MSG_RST___22 = 4096,
    MSG_ERRQUEUE___22 = 8192,
    MSG_NOSIGNAL___22 = 16384,
    MSG_MORE___22 = 32768,
    MSG_WAITFORONE___22 = 65536,
    MSG_BATCH___22 = 262144,
    MSG_ZEROCOPY___22 = 67108864,
    MSG_FASTOPEN___22 = 536870912,
    MSG_CMSG_CLOEXEC___22 = 1073741824
} ;
enum __anonenum_617082774___22 {
    SCM_RIGHTS___22 = 1,
    SCM_CREDENTIALS___22 = 2
} ;
enum __anonenum_606441560___22 {
    SHUT_RD___22 = 0,
    SHUT_WR___22 = 1,
    SHUT_RDWR___22 = 2
} ;
enum __anonenum_264779956___22 {
    IPPROTO_IP___22 = 0,
    IPPROTO_ICMP___22 = 1,
    IPPROTO_IGMP___22 = 2,
    IPPROTO_IPIP___22 = 4,
    IPPROTO_TCP___22 = 6,
    IPPROTO_EGP___22 = 8,
    IPPROTO_PUP___22 = 12,
    IPPROTO_UDP___22 = 17,
    IPPROTO_IDP___22 = 22,
    IPPROTO_TP___22 = 29,
    IPPROTO_DCCP___22 = 33,
    IPPROTO_IPV6___22 = 41,
    IPPROTO_RSVP___22 = 46,
    IPPROTO_GRE___22 = 47,
    IPPROTO_ESP___22 = 50,
    IPPROTO_AH___22 = 51,
    IPPROTO_MTP___22 = 92,
    IPPROTO_BEETPH___22 = 94,
    IPPROTO_ENCAP___22 = 98,
    IPPROTO_PIM___22 = 103,
    IPPROTO_COMP___22 = 108,
    IPPROTO_SCTP___22 = 132,
    IPPROTO_UDPLITE___22 = 136,
    IPPROTO_MPLS___22 = 137,
    IPPROTO_ETHERNET___22 = 143,
    IPPROTO_RAW___22 = 255,
    IPPROTO_MPTCP___22 = 262,
    IPPROTO_MAX___22 = 263
} ;
enum __anonenum_218739988___22 {
    IPPROTO_HOPOPTS___22 = 0,
    IPPROTO_ROUTING___22 = 43,
    IPPROTO_FRAGMENT___22 = 44,
    IPPROTO_ICMPV6___22 = 58,
    IPPROTO_NONE___22 = 59,
    IPPROTO_DSTOPTS___22 = 60,
    IPPROTO_MH___22 = 135
} ;
enum __anonenum_662268580___22 {
    IPPORT_ECHO___22 = 7,
    IPPORT_DISCARD___22 = 9,
    IPPORT_SYSTAT___22 = 11,
    IPPORT_DAYTIME___22 = 13,
    IPPORT_NETSTAT___22 = 15,
    IPPORT_FTP___22 = 21,
    IPPORT_TELNET___22 = 23,
    IPPORT_SMTP___22 = 25,
    IPPORT_TIMESERVER___22 = 37,
    IPPORT_NAMESERVER___22 = 42,
    IPPORT_WHOIS___22 = 43,
    IPPORT_MTP___22 = 57,
    IPPORT_TFTP___22 = 69,
    IPPORT_RJE___22 = 77,
    IPPORT_FINGER___22 = 79,
    IPPORT_TTYLINK___22 = 87,
    IPPORT_SUPDUP___22 = 95,
    IPPORT_EXECSERVER___22 = 512,
    IPPORT_LOGINSERVER___22 = 513,
    IPPORT_CMDSERVER___22 = 514,
    IPPORT_EFSSERVER___22 = 520,
    IPPORT_BIFFUDP___22 = 512,
    IPPORT_WHOSERVER___22 = 513,
    IPPORT_ROUTESERVER___22 = 520,
    IPPORT_RESERVED___22 = 1024,
    IPPORT_USERRESERVED___22 = 5000
} ;
enum __anonenum_18926444___22 {
    _ISupper___22 = 256,
    _ISlower___22 = 512,
    _ISalpha___22 = 1024,
    _ISdigit___22 = 2048,
    _ISxdigit___22 = 4096,
    _ISspace___22 = 8192,
    _ISprint___22 = 16384,
    _ISgraph___22 = 32768,
    _ISblank___22 = 1,
    _IScntrl___22 = 2,
    _ISpunct___22 = 4,
    _ISalnum___22 = 8
} ;
enum __anonenum_913965969___22 {
    FP_INT_UPWARD___22 = 0,
    FP_INT_DOWNWARD___22 = 1,
    FP_INT_TOWARDZERO___22 = 2,
    FP_INT_TONEARESTFROMZERO___22 = 3,
    FP_INT_TONEAREST___22 = 4
} ;
enum __anonenum_1037408945___22 {
    FP_NAN___22 = 0,
    FP_INFINITE___22 = 1,
    FP_ZERO___22 = 2,
    FP_SUBNORMAL___22 = 3,
    FP_NORMAL___22 = 4
} ;
enum __anonenum_556971655___22 {
    SI_ASYNCNL___22 = -60,
    SI_DETHREAD___22 = -7,
    SI_TKILL___22 = -6,
    SI_SIGIO___22 = -5,
    SI_ASYNCIO___22 = -4,
    SI_MESGQ___22 = -3,
    SI_TIMER___22 = -2,
    SI_QUEUE___22 = -1,
    SI_USER___22 = 0,
    SI_KERNEL___22 = 128
} ;
enum __anonenum_640648963___22 {
    ILL_ILLOPC___22 = 1,
    ILL_ILLOPN___22 = 2,
    ILL_ILLADR___22 = 3,
    ILL_ILLTRP___22 = 4,
    ILL_PRVOPC___22 = 5,
    ILL_PRVREG___22 = 6,
    ILL_COPROC___22 = 7,
    ILL_BADSTK___22 = 8,
    ILL_BADIADDR___22 = 9
} ;
enum __anonenum_457704180___22 {
    FPE_INTDIV___22 = 1,
    FPE_INTOVF___22 = 2,
    FPE_FLTDIV___22 = 3,
    FPE_FLTOVF___22 = 4,
    FPE_FLTUND___22 = 5,
    FPE_FLTRES___22 = 6,
    FPE_FLTINV___22 = 7,
    FPE_FLTSUB___22 = 8,
    FPE_FLTUNK___22 = 14,
    FPE_CONDTRAP___22 = 15
} ;
enum __anonenum_180375148___22 {
    SEGV_MAPERR___22 = 1,
    SEGV_ACCERR___22 = 2,
    SEGV_BNDERR___22 = 3,
    SEGV_PKUERR___22 = 4,
    SEGV_ACCADI___22 = 5,
    SEGV_ADIDERR___22 = 6,
    SEGV_ADIPERR___22 = 7,
    SEGV_MTEAERR___22 = 8,
    SEGV_MTESERR___22 = 9
} ;
enum __anonenum_1036286214___22 {
    BUS_ADRALN___22 = 1,
    BUS_ADRERR___22 = 2,
    BUS_OBJERR___22 = 3,
    BUS_MCEERR_AR___22 = 4,
    BUS_MCEERR_AO___22 = 5
} ;
enum __anonenum_91015150___22 {
    TRAP_BRKPT___22 = 1,
    TRAP_TRACE___22 = 2,
    TRAP_BRANCH___22 = 3,
    TRAP_HWBKPT___22 = 4,
    TRAP_UNK___22 = 5
} ;
enum __anonenum_23175539___22 {
    CLD_EXITED___22 = 1,
    CLD_KILLED___22 = 2,
    CLD_DUMPED___22 = 3,
    CLD_TRAPPED___22 = 4,
    CLD_STOPPED___22 = 5,
    CLD_CONTINUED___22 = 6
} ;
enum __anonenum_111643124___22 {
    POLL_IN___22 = 1,
    POLL_OUT___22 = 2,
    POLL_MSG___22 = 3,
    POLL_ERR___22 = 4,
    POLL_PRI___22 = 5,
    POLL_HUP___22 = 6
} ;
enum __anonenum_852341087___22 {
    SIGEV_SIGNAL___22 = 0,
    SIGEV_NONE___22 = 1,
    SIGEV_THREAD___22 = 2,
    SIGEV_THREAD_ID___22 = 4
} ;
enum __anonenum_451154152___22 {
    REG_R8___22 = 0,
    REG_R9___22 = 1,
    REG_R10___22 = 2,
    REG_R11___22 = 3,
    REG_R12___22 = 4,
    REG_R13___22 = 5,
    REG_R14___22 = 6,
    REG_R15___22 = 7,
    REG_RDI___22 = 8,
    REG_RSI___22 = 9,
    REG_RBP___22 = 10,
    REG_RBX___22 = 11,
    REG_RDX___22 = 12,
    REG_RAX___22 = 13,
    REG_RCX___22 = 14,
    REG_RSP___22 = 15,
    REG_RIP___22 = 16,
    REG_EFL___22 = 17,
    REG_CSGSFS___22 = 18,
    REG_ERR___22 = 19,
    REG_TRAPNO___22 = 20,
    REG_OLDMASK___22 = 21,
    REG_CR2___22 = 22
} ;
enum __anonenum_437032235___22 {
    _PC_LINK_MAX___22 = 0,
    _PC_MAX_CANON___22 = 1,
    _PC_MAX_INPUT___22 = 2,
    _PC_NAME_MAX___22 = 3,
    _PC_PATH_MAX___22 = 4,
    _PC_PIPE_BUF___22 = 5,
    _PC_CHOWN_RESTRICTED___22 = 6,
    _PC_NO_TRUNC___22 = 7,
    _PC_VDISABLE___22 = 8,
    _PC_SYNC_IO___22 = 9,
    _PC_ASYNC_IO___22 = 10,
    _PC_PRIO_IO___22 = 11,
    _PC_SOCK_MAXBUF___22 = 12,
    _PC_FILESIZEBITS___22 = 13,
    _PC_REC_INCR_XFER_SIZE___22 = 14,
    _PC_REC_MAX_XFER_SIZE___22 = 15,
    _PC_REC_MIN_XFER_SIZE___22 = 16,
    _PC_REC_XFER_ALIGN___22 = 17,
    _PC_ALLOC_SIZE_MIN___22 = 18,
    _PC_SYMLINK_MAX___22 = 19,
    _PC_2_SYMLINKS___22 = 20
} ;
enum __anonenum_315186338___22 {
    _SC_ARG_MAX___22 = 0,
    _SC_CHILD_MAX___22 = 1,
    _SC_CLK_TCK___22 = 2,
    _SC_NGROUPS_MAX___22 = 3,
    _SC_OPEN_MAX___22 = 4,
    _SC_STREAM_MAX___22 = 5,
    _SC_TZNAME_MAX___22 = 6,
    _SC_JOB_CONTROL___22 = 7,
    _SC_SAVED_IDS___22 = 8,
    _SC_REALTIME_SIGNALS___22 = 9,
    _SC_PRIORITY_SCHEDULING___22 = 10,
    _SC_TIMERS___22 = 11,
    _SC_ASYNCHRONOUS_IO___22 = 12,
    _SC_PRIORITIZED_IO___22 = 13,
    _SC_SYNCHRONIZED_IO___22 = 14,
    _SC_FSYNC___22 = 15,
    _SC_MAPPED_FILES___22 = 16,
    _SC_MEMLOCK___22 = 17,
    _SC_MEMLOCK_RANGE___22 = 18,
    _SC_MEMORY_PROTECTION___22 = 19,
    _SC_MESSAGE_PASSING___22 = 20,
    _SC_SEMAPHORES___22 = 21,
    _SC_SHARED_MEMORY_OBJECTS___22 = 22,
    _SC_AIO_LISTIO_MAX___22 = 23,
    _SC_AIO_MAX___22 = 24,
    _SC_AIO_PRIO_DELTA_MAX___22 = 25,
    _SC_DELAYTIMER_MAX___22 = 26,
    _SC_MQ_OPEN_MAX___22 = 27,
    _SC_MQ_PRIO_MAX___22 = 28,
    _SC_VERSION___22 = 29,
    _SC_PAGESIZE___22 = 30,
    _SC_RTSIG_MAX___22 = 31,
    _SC_SEM_NSEMS_MAX___22 = 32,
    _SC_SEM_VALUE_MAX___22 = 33,
    _SC_SIGQUEUE_MAX___22 = 34,
    _SC_TIMER_MAX___22 = 35,
    _SC_BC_BASE_MAX___22 = 36,
    _SC_BC_DIM_MAX___22 = 37,
    _SC_BC_SCALE_MAX___22 = 38,
    _SC_BC_STRING_MAX___22 = 39,
    _SC_COLL_WEIGHTS_MAX___22 = 40,
    _SC_EQUIV_CLASS_MAX___22 = 41,
    _SC_EXPR_NEST_MAX___22 = 42,
    _SC_LINE_MAX___22 = 43,
    _SC_RE_DUP_MAX___22 = 44,
    _SC_CHARCLASS_NAME_MAX___22 = 45,
    _SC_2_VERSION___22 = 46,
    _SC_2_C_BIND___22 = 47,
    _SC_2_C_DEV___22 = 48,
    _SC_2_FORT_DEV___22 = 49,
    _SC_2_FORT_RUN___22 = 50,
    _SC_2_SW_DEV___22 = 51,
    _SC_2_LOCALEDEF___22 = 52,
    _SC_PII___22 = 53,
    _SC_PII_XTI___22 = 54,
    _SC_PII_SOCKET___22 = 55,
    _SC_PII_INTERNET___22 = 56,
    _SC_PII_OSI___22 = 57,
    _SC_POLL___22 = 58,
    _SC_SELECT___22 = 59,
    _SC_UIO_MAXIOV___22 = 60,
    _SC_IOV_MAX___22 = 60,
    _SC_PII_INTERNET_STREAM___22 = 61,
    _SC_PII_INTERNET_DGRAM___22 = 62,
    _SC_PII_OSI_COTS___22 = 63,
    _SC_PII_OSI_CLTS___22 = 64,
    _SC_PII_OSI_M___22 = 65,
    _SC_T_IOV_MAX___22 = 66,
    _SC_THREADS___22 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___22 = 68,
    _SC_GETGR_R_SIZE_MAX___22 = 69,
    _SC_GETPW_R_SIZE_MAX___22 = 70,
    _SC_LOGIN_NAME_MAX___22 = 71,
    _SC_TTY_NAME_MAX___22 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___22 = 73,
    _SC_THREAD_KEYS_MAX___22 = 74,
    _SC_THREAD_STACK_MIN___22 = 75,
    _SC_THREAD_THREADS_MAX___22 = 76,
    _SC_THREAD_ATTR_STACKADDR___22 = 77,
    _SC_THREAD_ATTR_STACKSIZE___22 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___22 = 79,
    _SC_THREAD_PRIO_INHERIT___22 = 80,
    _SC_THREAD_PRIO_PROTECT___22 = 81,
    _SC_THREAD_PROCESS_SHARED___22 = 82,
    _SC_NPROCESSORS_CONF___22 = 83,
    _SC_NPROCESSORS_ONLN___22 = 84,
    _SC_PHYS_PAGES___22 = 85,
    _SC_AVPHYS_PAGES___22 = 86,
    _SC_ATEXIT_MAX___22 = 87,
    _SC_PASS_MAX___22 = 88,
    _SC_XOPEN_VERSION___22 = 89,
    _SC_XOPEN_XCU_VERSION___22 = 90,
    _SC_XOPEN_UNIX___22 = 91,
    _SC_XOPEN_CRYPT___22 = 92,
    _SC_XOPEN_ENH_I18N___22 = 93,
    _SC_XOPEN_SHM___22 = 94,
    _SC_2_CHAR_TERM___22 = 95,
    _SC_2_C_VERSION___22 = 96,
    _SC_2_UPE___22 = 97,
    _SC_XOPEN_XPG2___22 = 98,
    _SC_XOPEN_XPG3___22 = 99,
    _SC_XOPEN_XPG4___22 = 100,
    _SC_CHAR_BIT___22 = 101,
    _SC_CHAR_MAX___22 = 102,
    _SC_CHAR_MIN___22 = 103,
    _SC_INT_MAX___22 = 104,
    _SC_INT_MIN___22 = 105,
    _SC_LONG_BIT___22 = 106,
    _SC_WORD_BIT___22 = 107,
    _SC_MB_LEN_MAX___22 = 108,
    _SC_NZERO___22 = 109,
    _SC_SSIZE_MAX___22 = 110,
    _SC_SCHAR_MAX___22 = 111,
    _SC_SCHAR_MIN___22 = 112,
    _SC_SHRT_MAX___22 = 113,
    _SC_SHRT_MIN___22 = 114,
    _SC_UCHAR_MAX___22 = 115,
    _SC_UINT_MAX___22 = 116,
    _SC_ULONG_MAX___22 = 117,
    _SC_USHRT_MAX___22 = 118,
    _SC_NL_ARGMAX___22 = 119,
    _SC_NL_LANGMAX___22 = 120,
    _SC_NL_MSGMAX___22 = 121,
    _SC_NL_NMAX___22 = 122,
    _SC_NL_SETMAX___22 = 123,
    _SC_NL_TEXTMAX___22 = 124,
    _SC_XBS5_ILP32_OFF32___22 = 125,
    _SC_XBS5_ILP32_OFFBIG___22 = 126,
    _SC_XBS5_LP64_OFF64___22 = 127,
    _SC_XBS5_LPBIG_OFFBIG___22 = 128,
    _SC_XOPEN_LEGACY___22 = 129,
    _SC_XOPEN_REALTIME___22 = 130,
    _SC_XOPEN_REALTIME_THREADS___22 = 131,
    _SC_ADVISORY_INFO___22 = 132,
    _SC_BARRIERS___22 = 133,
    _SC_BASE___22 = 134,
    _SC_C_LANG_SUPPORT___22 = 135,
    _SC_C_LANG_SUPPORT_R___22 = 136,
    _SC_CLOCK_SELECTION___22 = 137,
    _SC_CPUTIME___22 = 138,
    _SC_THREAD_CPUTIME___22 = 139,
    _SC_DEVICE_IO___22 = 140,
    _SC_DEVICE_SPECIFIC___22 = 141,
    _SC_DEVICE_SPECIFIC_R___22 = 142,
    _SC_FD_MGMT___22 = 143,
    _SC_FIFO___22 = 144,
    _SC_PIPE___22 = 145,
    _SC_FILE_ATTRIBUTES___22 = 146,
    _SC_FILE_LOCKING___22 = 147,
    _SC_FILE_SYSTEM___22 = 148,
    _SC_MONOTONIC_CLOCK___22 = 149,
    _SC_MULTI_PROCESS___22 = 150,
    _SC_SINGLE_PROCESS___22 = 151,
    _SC_NETWORKING___22 = 152,
    _SC_READER_WRITER_LOCKS___22 = 153,
    _SC_SPIN_LOCKS___22 = 154,
    _SC_REGEXP___22 = 155,
    _SC_REGEX_VERSION___22 = 156,
    _SC_SHELL___22 = 157,
    _SC_SIGNALS___22 = 158,
    _SC_SPAWN___22 = 159,
    _SC_SPORADIC_SERVER___22 = 160,
    _SC_THREAD_SPORADIC_SERVER___22 = 161,
    _SC_SYSTEM_DATABASE___22 = 162,
    _SC_SYSTEM_DATABASE_R___22 = 163,
    _SC_TIMEOUTS___22 = 164,
    _SC_TYPED_MEMORY_OBJECTS___22 = 165,
    _SC_USER_GROUPS___22 = 166,
    _SC_USER_GROUPS_R___22 = 167,
    _SC_2_PBS___22 = 168,
    _SC_2_PBS_ACCOUNTING___22 = 169,
    _SC_2_PBS_LOCATE___22 = 170,
    _SC_2_PBS_MESSAGE___22 = 171,
    _SC_2_PBS_TRACK___22 = 172,
    _SC_SYMLOOP_MAX___22 = 173,
    _SC_STREAMS___22 = 174,
    _SC_2_PBS_CHECKPOINT___22 = 175,
    _SC_V6_ILP32_OFF32___22 = 176,
    _SC_V6_ILP32_OFFBIG___22 = 177,
    _SC_V6_LP64_OFF64___22 = 178,
    _SC_V6_LPBIG_OFFBIG___22 = 179,
    _SC_HOST_NAME_MAX___22 = 180,
    _SC_TRACE___22 = 181,
    _SC_TRACE_EVENT_FILTER___22 = 182,
    _SC_TRACE_INHERIT___22 = 183,
    _SC_TRACE_LOG___22 = 184,
    _SC_LEVEL1_ICACHE_SIZE___22 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___22 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___22 = 187,
    _SC_LEVEL1_DCACHE_SIZE___22 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___22 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___22 = 190,
    _SC_LEVEL2_CACHE_SIZE___22 = 191,
    _SC_LEVEL2_CACHE_ASSOC___22 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___22 = 193,
    _SC_LEVEL3_CACHE_SIZE___22 = 194,
    _SC_LEVEL3_CACHE_ASSOC___22 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___22 = 196,
    _SC_LEVEL4_CACHE_SIZE___22 = 197,
    _SC_LEVEL4_CACHE_ASSOC___22 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___22 = 199,
    _SC_IPV6___22 = 235,
    _SC_RAW_SOCKETS___22 = 236,
    _SC_V7_ILP32_OFF32___22 = 237,
    _SC_V7_ILP32_OFFBIG___22 = 238,
    _SC_V7_LP64_OFF64___22 = 239,
    _SC_V7_LPBIG_OFFBIG___22 = 240,
    _SC_SS_REPL_MAX___22 = 241,
    _SC_TRACE_EVENT_NAME_MAX___22 = 242,
    _SC_TRACE_NAME_MAX___22 = 243,
    _SC_TRACE_SYS_MAX___22 = 244,
    _SC_TRACE_USER_EVENT_MAX___22 = 245,
    _SC_XOPEN_STREAMS___22 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___22 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___22 = 248,
    _SC_MINSIGSTKSZ___22 = 249,
    _SC_SIGSTKSZ___22 = 250
} ;
enum __anonenum_875524036___22 {
    _CS_PATH___22 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___22 = 1,
    _CS_GNU_LIBC_VERSION___22 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___22 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___22 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___22 = 5,
    _CS_LFS_CFLAGS___22 = 1000,
    _CS_LFS_LDFLAGS___22 = 1001,
    _CS_LFS_LIBS___22 = 1002,
    _CS_LFS_LINTFLAGS___22 = 1003,
    _CS_LFS64_CFLAGS___22 = 1004,
    _CS_LFS64_LDFLAGS___22 = 1005,
    _CS_LFS64_LIBS___22 = 1006,
    _CS_LFS64_LINTFLAGS___22 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___22 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___22 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___22 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___22 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___22 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___22 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___22 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___22 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___22 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___22 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___22 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___22 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___22 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___22 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___22 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___22 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___22 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___22 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___22 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___22 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___22 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___22 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___22 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___22 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___22 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___22 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___22 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___22 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___22 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___22 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___22 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___22 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___22 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___22 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___22 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___22 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___22 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___22 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___22 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___22 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___22 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___22 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___22 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___22 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___22 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___22 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___22 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___22 = 1147,
    _CS_V6_ENV___22 = 1148,
    _CS_V7_ENV___22 = 1149
} ;
enum __anonenum_57186863___22 {
    SS_ONSTACK___22 = 1,
    SS_DISABLE___22 = 2
} ;
enum __anonenum_83571709___23 {
    MSG_OOB___23 = 1,
    MSG_PEEK___23 = 2,
    MSG_DONTROUTE___23 = 4,
    MSG_TRYHARD___23 = 4,
    MSG_CTRUNC___23 = 8,
    MSG_PROXY___23 = 16,
    MSG_TRUNC___23 = 32,
    MSG_DONTWAIT___23 = 64,
    MSG_EOR___23 = 128,
    MSG_WAITALL___23 = 256,
    MSG_FIN___23 = 512,
    MSG_SYN___23 = 1024,
    MSG_CONFIRM___23 = 2048,
    MSG_RST___23 = 4096,
    MSG_ERRQUEUE___23 = 8192,
    MSG_NOSIGNAL___23 = 16384,
    MSG_MORE___23 = 32768,
    MSG_WAITFORONE___23 = 65536,
    MSG_BATCH___23 = 262144,
    MSG_ZEROCOPY___23 = 67108864,
    MSG_FASTOPEN___23 = 536870912,
    MSG_CMSG_CLOEXEC___23 = 1073741824
} ;
enum __anonenum_617082774___23 {
    SCM_RIGHTS___23 = 1,
    SCM_CREDENTIALS___23 = 2
} ;
enum __anonenum_606441560___23 {
    SHUT_RD___23 = 0,
    SHUT_WR___23 = 1,
    SHUT_RDWR___23 = 2
} ;
enum __anonenum_264779956___23 {
    IPPROTO_IP___23 = 0,
    IPPROTO_ICMP___23 = 1,
    IPPROTO_IGMP___23 = 2,
    IPPROTO_IPIP___23 = 4,
    IPPROTO_TCP___23 = 6,
    IPPROTO_EGP___23 = 8,
    IPPROTO_PUP___23 = 12,
    IPPROTO_UDP___23 = 17,
    IPPROTO_IDP___23 = 22,
    IPPROTO_TP___23 = 29,
    IPPROTO_DCCP___23 = 33,
    IPPROTO_IPV6___23 = 41,
    IPPROTO_RSVP___23 = 46,
    IPPROTO_GRE___23 = 47,
    IPPROTO_ESP___23 = 50,
    IPPROTO_AH___23 = 51,
    IPPROTO_MTP___23 = 92,
    IPPROTO_BEETPH___23 = 94,
    IPPROTO_ENCAP___23 = 98,
    IPPROTO_PIM___23 = 103,
    IPPROTO_COMP___23 = 108,
    IPPROTO_SCTP___23 = 132,
    IPPROTO_UDPLITE___23 = 136,
    IPPROTO_MPLS___23 = 137,
    IPPROTO_ETHERNET___23 = 143,
    IPPROTO_RAW___23 = 255,
    IPPROTO_MPTCP___23 = 262,
    IPPROTO_MAX___23 = 263
} ;
enum __anonenum_218739988___23 {
    IPPROTO_HOPOPTS___23 = 0,
    IPPROTO_ROUTING___23 = 43,
    IPPROTO_FRAGMENT___23 = 44,
    IPPROTO_ICMPV6___23 = 58,
    IPPROTO_NONE___23 = 59,
    IPPROTO_DSTOPTS___23 = 60,
    IPPROTO_MH___23 = 135
} ;
enum __anonenum_662268580___23 {
    IPPORT_ECHO___23 = 7,
    IPPORT_DISCARD___23 = 9,
    IPPORT_SYSTAT___23 = 11,
    IPPORT_DAYTIME___23 = 13,
    IPPORT_NETSTAT___23 = 15,
    IPPORT_FTP___23 = 21,
    IPPORT_TELNET___23 = 23,
    IPPORT_SMTP___23 = 25,
    IPPORT_TIMESERVER___23 = 37,
    IPPORT_NAMESERVER___23 = 42,
    IPPORT_WHOIS___23 = 43,
    IPPORT_MTP___23 = 57,
    IPPORT_TFTP___23 = 69,
    IPPORT_RJE___23 = 77,
    IPPORT_FINGER___23 = 79,
    IPPORT_TTYLINK___23 = 87,
    IPPORT_SUPDUP___23 = 95,
    IPPORT_EXECSERVER___23 = 512,
    IPPORT_LOGINSERVER___23 = 513,
    IPPORT_CMDSERVER___23 = 514,
    IPPORT_EFSSERVER___23 = 520,
    IPPORT_BIFFUDP___23 = 512,
    IPPORT_WHOSERVER___23 = 513,
    IPPORT_ROUTESERVER___23 = 520,
    IPPORT_RESERVED___23 = 1024,
    IPPORT_USERRESERVED___23 = 5000
} ;
enum __anonenum_18926444___23 {
    _ISupper___23 = 256,
    _ISlower___23 = 512,
    _ISalpha___23 = 1024,
    _ISdigit___23 = 2048,
    _ISxdigit___23 = 4096,
    _ISspace___23 = 8192,
    _ISprint___23 = 16384,
    _ISgraph___23 = 32768,
    _ISblank___23 = 1,
    _IScntrl___23 = 2,
    _ISpunct___23 = 4,
    _ISalnum___23 = 8
} ;
enum __anonenum_913965969___23 {
    FP_INT_UPWARD___23 = 0,
    FP_INT_DOWNWARD___23 = 1,
    FP_INT_TOWARDZERO___23 = 2,
    FP_INT_TONEARESTFROMZERO___23 = 3,
    FP_INT_TONEAREST___23 = 4
} ;
enum __anonenum_1037408945___23 {
    FP_NAN___23 = 0,
    FP_INFINITE___23 = 1,
    FP_ZERO___23 = 2,
    FP_SUBNORMAL___23 = 3,
    FP_NORMAL___23 = 4
} ;
enum __anonenum_556971655___23 {
    SI_ASYNCNL___23 = -60,
    SI_DETHREAD___23 = -7,
    SI_TKILL___23 = -6,
    SI_SIGIO___23 = -5,
    SI_ASYNCIO___23 = -4,
    SI_MESGQ___23 = -3,
    SI_TIMER___23 = -2,
    SI_QUEUE___23 = -1,
    SI_USER___23 = 0,
    SI_KERNEL___23 = 128
} ;
enum __anonenum_640648963___23 {
    ILL_ILLOPC___23 = 1,
    ILL_ILLOPN___23 = 2,
    ILL_ILLADR___23 = 3,
    ILL_ILLTRP___23 = 4,
    ILL_PRVOPC___23 = 5,
    ILL_PRVREG___23 = 6,
    ILL_COPROC___23 = 7,
    ILL_BADSTK___23 = 8,
    ILL_BADIADDR___23 = 9
} ;
enum __anonenum_457704180___23 {
    FPE_INTDIV___23 = 1,
    FPE_INTOVF___23 = 2,
    FPE_FLTDIV___23 = 3,
    FPE_FLTOVF___23 = 4,
    FPE_FLTUND___23 = 5,
    FPE_FLTRES___23 = 6,
    FPE_FLTINV___23 = 7,
    FPE_FLTSUB___23 = 8,
    FPE_FLTUNK___23 = 14,
    FPE_CONDTRAP___23 = 15
} ;
enum __anonenum_180375148___23 {
    SEGV_MAPERR___23 = 1,
    SEGV_ACCERR___23 = 2,
    SEGV_BNDERR___23 = 3,
    SEGV_PKUERR___23 = 4,
    SEGV_ACCADI___23 = 5,
    SEGV_ADIDERR___23 = 6,
    SEGV_ADIPERR___23 = 7,
    SEGV_MTEAERR___23 = 8,
    SEGV_MTESERR___23 = 9
} ;
enum __anonenum_1036286214___23 {
    BUS_ADRALN___23 = 1,
    BUS_ADRERR___23 = 2,
    BUS_OBJERR___23 = 3,
    BUS_MCEERR_AR___23 = 4,
    BUS_MCEERR_AO___23 = 5
} ;
enum __anonenum_91015150___23 {
    TRAP_BRKPT___23 = 1,
    TRAP_TRACE___23 = 2,
    TRAP_BRANCH___23 = 3,
    TRAP_HWBKPT___23 = 4,
    TRAP_UNK___23 = 5
} ;
enum __anonenum_23175539___23 {
    CLD_EXITED___23 = 1,
    CLD_KILLED___23 = 2,
    CLD_DUMPED___23 = 3,
    CLD_TRAPPED___23 = 4,
    CLD_STOPPED___23 = 5,
    CLD_CONTINUED___23 = 6
} ;
enum __anonenum_111643124___23 {
    POLL_IN___23 = 1,
    POLL_OUT___23 = 2,
    POLL_MSG___23 = 3,
    POLL_ERR___23 = 4,
    POLL_PRI___23 = 5,
    POLL_HUP___23 = 6
} ;
enum __anonenum_852341087___23 {
    SIGEV_SIGNAL___23 = 0,
    SIGEV_NONE___23 = 1,
    SIGEV_THREAD___23 = 2,
    SIGEV_THREAD_ID___23 = 4
} ;
enum __anonenum_451154152___23 {
    REG_R8___23 = 0,
    REG_R9___23 = 1,
    REG_R10___23 = 2,
    REG_R11___23 = 3,
    REG_R12___23 = 4,
    REG_R13___23 = 5,
    REG_R14___23 = 6,
    REG_R15___23 = 7,
    REG_RDI___23 = 8,
    REG_RSI___23 = 9,
    REG_RBP___23 = 10,
    REG_RBX___23 = 11,
    REG_RDX___23 = 12,
    REG_RAX___23 = 13,
    REG_RCX___23 = 14,
    REG_RSP___23 = 15,
    REG_RIP___23 = 16,
    REG_EFL___23 = 17,
    REG_CSGSFS___23 = 18,
    REG_ERR___23 = 19,
    REG_TRAPNO___23 = 20,
    REG_OLDMASK___23 = 21,
    REG_CR2___23 = 22
} ;
enum __anonenum_437032235___23 {
    _PC_LINK_MAX___23 = 0,
    _PC_MAX_CANON___23 = 1,
    _PC_MAX_INPUT___23 = 2,
    _PC_NAME_MAX___23 = 3,
    _PC_PATH_MAX___23 = 4,
    _PC_PIPE_BUF___23 = 5,
    _PC_CHOWN_RESTRICTED___23 = 6,
    _PC_NO_TRUNC___23 = 7,
    _PC_VDISABLE___23 = 8,
    _PC_SYNC_IO___23 = 9,
    _PC_ASYNC_IO___23 = 10,
    _PC_PRIO_IO___23 = 11,
    _PC_SOCK_MAXBUF___23 = 12,
    _PC_FILESIZEBITS___23 = 13,
    _PC_REC_INCR_XFER_SIZE___23 = 14,
    _PC_REC_MAX_XFER_SIZE___23 = 15,
    _PC_REC_MIN_XFER_SIZE___23 = 16,
    _PC_REC_XFER_ALIGN___23 = 17,
    _PC_ALLOC_SIZE_MIN___23 = 18,
    _PC_SYMLINK_MAX___23 = 19,
    _PC_2_SYMLINKS___23 = 20
} ;
enum __anonenum_315186338___23 {
    _SC_ARG_MAX___23 = 0,
    _SC_CHILD_MAX___23 = 1,
    _SC_CLK_TCK___23 = 2,
    _SC_NGROUPS_MAX___23 = 3,
    _SC_OPEN_MAX___23 = 4,
    _SC_STREAM_MAX___23 = 5,
    _SC_TZNAME_MAX___23 = 6,
    _SC_JOB_CONTROL___23 = 7,
    _SC_SAVED_IDS___23 = 8,
    _SC_REALTIME_SIGNALS___23 = 9,
    _SC_PRIORITY_SCHEDULING___23 = 10,
    _SC_TIMERS___23 = 11,
    _SC_ASYNCHRONOUS_IO___23 = 12,
    _SC_PRIORITIZED_IO___23 = 13,
    _SC_SYNCHRONIZED_IO___23 = 14,
    _SC_FSYNC___23 = 15,
    _SC_MAPPED_FILES___23 = 16,
    _SC_MEMLOCK___23 = 17,
    _SC_MEMLOCK_RANGE___23 = 18,
    _SC_MEMORY_PROTECTION___23 = 19,
    _SC_MESSAGE_PASSING___23 = 20,
    _SC_SEMAPHORES___23 = 21,
    _SC_SHARED_MEMORY_OBJECTS___23 = 22,
    _SC_AIO_LISTIO_MAX___23 = 23,
    _SC_AIO_MAX___23 = 24,
    _SC_AIO_PRIO_DELTA_MAX___23 = 25,
    _SC_DELAYTIMER_MAX___23 = 26,
    _SC_MQ_OPEN_MAX___23 = 27,
    _SC_MQ_PRIO_MAX___23 = 28,
    _SC_VERSION___23 = 29,
    _SC_PAGESIZE___23 = 30,
    _SC_RTSIG_MAX___23 = 31,
    _SC_SEM_NSEMS_MAX___23 = 32,
    _SC_SEM_VALUE_MAX___23 = 33,
    _SC_SIGQUEUE_MAX___23 = 34,
    _SC_TIMER_MAX___23 = 35,
    _SC_BC_BASE_MAX___23 = 36,
    _SC_BC_DIM_MAX___23 = 37,
    _SC_BC_SCALE_MAX___23 = 38,
    _SC_BC_STRING_MAX___23 = 39,
    _SC_COLL_WEIGHTS_MAX___23 = 40,
    _SC_EQUIV_CLASS_MAX___23 = 41,
    _SC_EXPR_NEST_MAX___23 = 42,
    _SC_LINE_MAX___23 = 43,
    _SC_RE_DUP_MAX___23 = 44,
    _SC_CHARCLASS_NAME_MAX___23 = 45,
    _SC_2_VERSION___23 = 46,
    _SC_2_C_BIND___23 = 47,
    _SC_2_C_DEV___23 = 48,
    _SC_2_FORT_DEV___23 = 49,
    _SC_2_FORT_RUN___23 = 50,
    _SC_2_SW_DEV___23 = 51,
    _SC_2_LOCALEDEF___23 = 52,
    _SC_PII___23 = 53,
    _SC_PII_XTI___23 = 54,
    _SC_PII_SOCKET___23 = 55,
    _SC_PII_INTERNET___23 = 56,
    _SC_PII_OSI___23 = 57,
    _SC_POLL___23 = 58,
    _SC_SELECT___23 = 59,
    _SC_UIO_MAXIOV___23 = 60,
    _SC_IOV_MAX___23 = 60,
    _SC_PII_INTERNET_STREAM___23 = 61,
    _SC_PII_INTERNET_DGRAM___23 = 62,
    _SC_PII_OSI_COTS___23 = 63,
    _SC_PII_OSI_CLTS___23 = 64,
    _SC_PII_OSI_M___23 = 65,
    _SC_T_IOV_MAX___23 = 66,
    _SC_THREADS___23 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___23 = 68,
    _SC_GETGR_R_SIZE_MAX___23 = 69,
    _SC_GETPW_R_SIZE_MAX___23 = 70,
    _SC_LOGIN_NAME_MAX___23 = 71,
    _SC_TTY_NAME_MAX___23 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___23 = 73,
    _SC_THREAD_KEYS_MAX___23 = 74,
    _SC_THREAD_STACK_MIN___23 = 75,
    _SC_THREAD_THREADS_MAX___23 = 76,
    _SC_THREAD_ATTR_STACKADDR___23 = 77,
    _SC_THREAD_ATTR_STACKSIZE___23 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___23 = 79,
    _SC_THREAD_PRIO_INHERIT___23 = 80,
    _SC_THREAD_PRIO_PROTECT___23 = 81,
    _SC_THREAD_PROCESS_SHARED___23 = 82,
    _SC_NPROCESSORS_CONF___23 = 83,
    _SC_NPROCESSORS_ONLN___23 = 84,
    _SC_PHYS_PAGES___23 = 85,
    _SC_AVPHYS_PAGES___23 = 86,
    _SC_ATEXIT_MAX___23 = 87,
    _SC_PASS_MAX___23 = 88,
    _SC_XOPEN_VERSION___23 = 89,
    _SC_XOPEN_XCU_VERSION___23 = 90,
    _SC_XOPEN_UNIX___23 = 91,
    _SC_XOPEN_CRYPT___23 = 92,
    _SC_XOPEN_ENH_I18N___23 = 93,
    _SC_XOPEN_SHM___23 = 94,
    _SC_2_CHAR_TERM___23 = 95,
    _SC_2_C_VERSION___23 = 96,
    _SC_2_UPE___23 = 97,
    _SC_XOPEN_XPG2___23 = 98,
    _SC_XOPEN_XPG3___23 = 99,
    _SC_XOPEN_XPG4___23 = 100,
    _SC_CHAR_BIT___23 = 101,
    _SC_CHAR_MAX___23 = 102,
    _SC_CHAR_MIN___23 = 103,
    _SC_INT_MAX___23 = 104,
    _SC_INT_MIN___23 = 105,
    _SC_LONG_BIT___23 = 106,
    _SC_WORD_BIT___23 = 107,
    _SC_MB_LEN_MAX___23 = 108,
    _SC_NZERO___23 = 109,
    _SC_SSIZE_MAX___23 = 110,
    _SC_SCHAR_MAX___23 = 111,
    _SC_SCHAR_MIN___23 = 112,
    _SC_SHRT_MAX___23 = 113,
    _SC_SHRT_MIN___23 = 114,
    _SC_UCHAR_MAX___23 = 115,
    _SC_UINT_MAX___23 = 116,
    _SC_ULONG_MAX___23 = 117,
    _SC_USHRT_MAX___23 = 118,
    _SC_NL_ARGMAX___23 = 119,
    _SC_NL_LANGMAX___23 = 120,
    _SC_NL_MSGMAX___23 = 121,
    _SC_NL_NMAX___23 = 122,
    _SC_NL_SETMAX___23 = 123,
    _SC_NL_TEXTMAX___23 = 124,
    _SC_XBS5_ILP32_OFF32___23 = 125,
    _SC_XBS5_ILP32_OFFBIG___23 = 126,
    _SC_XBS5_LP64_OFF64___23 = 127,
    _SC_XBS5_LPBIG_OFFBIG___23 = 128,
    _SC_XOPEN_LEGACY___23 = 129,
    _SC_XOPEN_REALTIME___23 = 130,
    _SC_XOPEN_REALTIME_THREADS___23 = 131,
    _SC_ADVISORY_INFO___23 = 132,
    _SC_BARRIERS___23 = 133,
    _SC_BASE___23 = 134,
    _SC_C_LANG_SUPPORT___23 = 135,
    _SC_C_LANG_SUPPORT_R___23 = 136,
    _SC_CLOCK_SELECTION___23 = 137,
    _SC_CPUTIME___23 = 138,
    _SC_THREAD_CPUTIME___23 = 139,
    _SC_DEVICE_IO___23 = 140,
    _SC_DEVICE_SPECIFIC___23 = 141,
    _SC_DEVICE_SPECIFIC_R___23 = 142,
    _SC_FD_MGMT___23 = 143,
    _SC_FIFO___23 = 144,
    _SC_PIPE___23 = 145,
    _SC_FILE_ATTRIBUTES___23 = 146,
    _SC_FILE_LOCKING___23 = 147,
    _SC_FILE_SYSTEM___23 = 148,
    _SC_MONOTONIC_CLOCK___23 = 149,
    _SC_MULTI_PROCESS___23 = 150,
    _SC_SINGLE_PROCESS___23 = 151,
    _SC_NETWORKING___23 = 152,
    _SC_READER_WRITER_LOCKS___23 = 153,
    _SC_SPIN_LOCKS___23 = 154,
    _SC_REGEXP___23 = 155,
    _SC_REGEX_VERSION___23 = 156,
    _SC_SHELL___23 = 157,
    _SC_SIGNALS___23 = 158,
    _SC_SPAWN___23 = 159,
    _SC_SPORADIC_SERVER___23 = 160,
    _SC_THREAD_SPORADIC_SERVER___23 = 161,
    _SC_SYSTEM_DATABASE___23 = 162,
    _SC_SYSTEM_DATABASE_R___23 = 163,
    _SC_TIMEOUTS___23 = 164,
    _SC_TYPED_MEMORY_OBJECTS___23 = 165,
    _SC_USER_GROUPS___23 = 166,
    _SC_USER_GROUPS_R___23 = 167,
    _SC_2_PBS___23 = 168,
    _SC_2_PBS_ACCOUNTING___23 = 169,
    _SC_2_PBS_LOCATE___23 = 170,
    _SC_2_PBS_MESSAGE___23 = 171,
    _SC_2_PBS_TRACK___23 = 172,
    _SC_SYMLOOP_MAX___23 = 173,
    _SC_STREAMS___23 = 174,
    _SC_2_PBS_CHECKPOINT___23 = 175,
    _SC_V6_ILP32_OFF32___23 = 176,
    _SC_V6_ILP32_OFFBIG___23 = 177,
    _SC_V6_LP64_OFF64___23 = 178,
    _SC_V6_LPBIG_OFFBIG___23 = 179,
    _SC_HOST_NAME_MAX___23 = 180,
    _SC_TRACE___23 = 181,
    _SC_TRACE_EVENT_FILTER___23 = 182,
    _SC_TRACE_INHERIT___23 = 183,
    _SC_TRACE_LOG___23 = 184,
    _SC_LEVEL1_ICACHE_SIZE___23 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___23 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___23 = 187,
    _SC_LEVEL1_DCACHE_SIZE___23 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___23 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___23 = 190,
    _SC_LEVEL2_CACHE_SIZE___23 = 191,
    _SC_LEVEL2_CACHE_ASSOC___23 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___23 = 193,
    _SC_LEVEL3_CACHE_SIZE___23 = 194,
    _SC_LEVEL3_CACHE_ASSOC___23 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___23 = 196,
    _SC_LEVEL4_CACHE_SIZE___23 = 197,
    _SC_LEVEL4_CACHE_ASSOC___23 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___23 = 199,
    _SC_IPV6___23 = 235,
    _SC_RAW_SOCKETS___23 = 236,
    _SC_V7_ILP32_OFF32___23 = 237,
    _SC_V7_ILP32_OFFBIG___23 = 238,
    _SC_V7_LP64_OFF64___23 = 239,
    _SC_V7_LPBIG_OFFBIG___23 = 240,
    _SC_SS_REPL_MAX___23 = 241,
    _SC_TRACE_EVENT_NAME_MAX___23 = 242,
    _SC_TRACE_NAME_MAX___23 = 243,
    _SC_TRACE_SYS_MAX___23 = 244,
    _SC_TRACE_USER_EVENT_MAX___23 = 245,
    _SC_XOPEN_STREAMS___23 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___23 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___23 = 248,
    _SC_MINSIGSTKSZ___23 = 249,
    _SC_SIGSTKSZ___23 = 250
} ;
enum __anonenum_875524036___23 {
    _CS_PATH___23 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___23 = 1,
    _CS_GNU_LIBC_VERSION___23 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___23 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___23 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___23 = 5,
    _CS_LFS_CFLAGS___23 = 1000,
    _CS_LFS_LDFLAGS___23 = 1001,
    _CS_LFS_LIBS___23 = 1002,
    _CS_LFS_LINTFLAGS___23 = 1003,
    _CS_LFS64_CFLAGS___23 = 1004,
    _CS_LFS64_LDFLAGS___23 = 1005,
    _CS_LFS64_LIBS___23 = 1006,
    _CS_LFS64_LINTFLAGS___23 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___23 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___23 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___23 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___23 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___23 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___23 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___23 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___23 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___23 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___23 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___23 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___23 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___23 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___23 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___23 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___23 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___23 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___23 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___23 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___23 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___23 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___23 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___23 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___23 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___23 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___23 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___23 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___23 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___23 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___23 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___23 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___23 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___23 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___23 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___23 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___23 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___23 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___23 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___23 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___23 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___23 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___23 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___23 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___23 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___23 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___23 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___23 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___23 = 1147,
    _CS_V6_ENV___23 = 1148,
    _CS_V7_ENV___23 = 1149
} ;
enum __anonenum_57186863___23 {
    SS_ONSTACK___23 = 1,
    SS_DISABLE___23 = 2
} ;
enum __anonenum_34415463___0 {
    PTHREAD_CREATE_JOINABLE___0 = 0,
    PTHREAD_CREATE_DETACHED___0 = 1
} ;
enum __anonenum_303612439 {
    PTHREAD_MUTEX_TIMED_NP___0 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___0 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___0 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___0 = 3,
    PTHREAD_MUTEX_NORMAL___0 = 0,
    PTHREAD_MUTEX_RECURSIVE___0 = 1,
    PTHREAD_MUTEX_ERRORCHECK___0 = 2,
    PTHREAD_MUTEX_DEFAULT___0 = 0,
    PTHREAD_MUTEX_FAST_NP = 0
} ;
enum __anonenum_931900394___0 {
    PTHREAD_MUTEX_STALLED___0 = 0,
    PTHREAD_MUTEX_STALLED_NP___0 = 0,
    PTHREAD_MUTEX_ROBUST___0 = 1,
    PTHREAD_MUTEX_ROBUST_NP___0 = 1
} ;
enum __anonenum_205214487___0 {
    PTHREAD_PRIO_NONE___0 = 0,
    PTHREAD_PRIO_INHERIT___0 = 1,
    PTHREAD_PRIO_PROTECT___0 = 2
} ;
enum __anonenum_25043950___0 {
    PTHREAD_RWLOCK_PREFER_READER_NP___0 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___0 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___0 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___0 = 0
} ;
enum __anonenum_436439511___0 {
    PTHREAD_INHERIT_SCHED___0 = 0,
    PTHREAD_EXPLICIT_SCHED___0 = 1
} ;
enum __anonenum_998661166___0 {
    PTHREAD_SCOPE_SYSTEM___0 = 0,
    PTHREAD_SCOPE_PROCESS___0 = 1
} ;
enum __anonenum_146137331___0 {
    PTHREAD_PROCESS_PRIVATE___0 = 0,
    PTHREAD_PROCESS_SHARED___0 = 1
} ;
enum __anonenum_53396917___0 {
    PTHREAD_CANCEL_ENABLE___0 = 0,
    PTHREAD_CANCEL_DISABLE___0 = 1
} ;
enum __anonenum_904563783___0 {
    PTHREAD_CANCEL_DEFERRED___0 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___0 = 1
} ;
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_RTTIME = 15,
    __RLIMIT_NLIMITS = 16,
    __RLIM_NLIMITS = 16
} ;
typedef __rlim_t rlim_t;
typedef __rlim64_t rlim64_t;
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
struct rlimit64 {
   rlim64_t rlim_cur ;
   rlim64_t rlim_max ;
};
enum __rusage_who {
    RUSAGE_SELF = 0,
    RUSAGE_CHILDREN = -1,
    RUSAGE_THREAD = 1
} ;
union __anonunion____missing_field_name_1036346496 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
union __anonunion____missing_field_name_1036346497 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
union __anonunion____missing_field_name_1036346498 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
union __anonunion____missing_field_name_1036346499 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
union __anonunion____missing_field_name_1036346500 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
union __anonunion____missing_field_name_1036346501 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
union __anonunion____missing_field_name_1036346502 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
union __anonunion____missing_field_name_1036346503 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
union __anonunion____missing_field_name_1036346504 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
union __anonunion____missing_field_name_1036346505 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
union __anonunion____missing_field_name_1036346506 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
union __anonunion____missing_field_name_1036346507 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
union __anonunion____missing_field_name_1036346508 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
union __anonunion____missing_field_name_1036346509 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion____missing_field_name_1036346496 __annonCompField2 ;
   union __anonunion____missing_field_name_1036346497 __annonCompField3 ;
   union __anonunion____missing_field_name_1036346498 __annonCompField4 ;
   union __anonunion____missing_field_name_1036346499 __annonCompField5 ;
   union __anonunion____missing_field_name_1036346500 __annonCompField6 ;
   union __anonunion____missing_field_name_1036346501 __annonCompField7 ;
   union __anonunion____missing_field_name_1036346502 __annonCompField8 ;
   union __anonunion____missing_field_name_1036346503 __annonCompField9 ;
   union __anonunion____missing_field_name_1036346504 __annonCompField10 ;
   union __anonunion____missing_field_name_1036346505 __annonCompField11 ;
   union __anonunion____missing_field_name_1036346506 __annonCompField12 ;
   union __anonunion____missing_field_name_1036346507 __annonCompField13 ;
   union __anonunion____missing_field_name_1036346508 __annonCompField14 ;
   union __anonunion____missing_field_name_1036346509 __annonCompField15 ;
};
enum __priority_which {
    PRIO_PROCESS = 0,
    PRIO_PGRP = 1,
    PRIO_USER = 2
} ;
typedef enum __rlimit_resource __rlimit_resource_t;
typedef enum __rusage_who __rusage_who_t;
typedef enum __priority_which __priority_which_t;
enum __anonenum_83571709___24 {
    MSG_OOB___24 = 1,
    MSG_PEEK___24 = 2,
    MSG_DONTROUTE___24 = 4,
    MSG_TRYHARD___24 = 4,
    MSG_CTRUNC___24 = 8,
    MSG_PROXY___24 = 16,
    MSG_TRUNC___24 = 32,
    MSG_DONTWAIT___24 = 64,
    MSG_EOR___24 = 128,
    MSG_WAITALL___24 = 256,
    MSG_FIN___24 = 512,
    MSG_SYN___24 = 1024,
    MSG_CONFIRM___24 = 2048,
    MSG_RST___24 = 4096,
    MSG_ERRQUEUE___24 = 8192,
    MSG_NOSIGNAL___24 = 16384,
    MSG_MORE___24 = 32768,
    MSG_WAITFORONE___24 = 65536,
    MSG_BATCH___24 = 262144,
    MSG_ZEROCOPY___24 = 67108864,
    MSG_FASTOPEN___24 = 536870912,
    MSG_CMSG_CLOEXEC___24 = 1073741824
} ;
enum __anonenum_617082774___24 {
    SCM_RIGHTS___24 = 1,
    SCM_CREDENTIALS___24 = 2
} ;
enum __anonenum_606441560___24 {
    SHUT_RD___24 = 0,
    SHUT_WR___24 = 1,
    SHUT_RDWR___24 = 2
} ;
enum __anonenum_264779956___24 {
    IPPROTO_IP___24 = 0,
    IPPROTO_ICMP___24 = 1,
    IPPROTO_IGMP___24 = 2,
    IPPROTO_IPIP___24 = 4,
    IPPROTO_TCP___24 = 6,
    IPPROTO_EGP___24 = 8,
    IPPROTO_PUP___24 = 12,
    IPPROTO_UDP___24 = 17,
    IPPROTO_IDP___24 = 22,
    IPPROTO_TP___24 = 29,
    IPPROTO_DCCP___24 = 33,
    IPPROTO_IPV6___24 = 41,
    IPPROTO_RSVP___24 = 46,
    IPPROTO_GRE___24 = 47,
    IPPROTO_ESP___24 = 50,
    IPPROTO_AH___24 = 51,
    IPPROTO_MTP___24 = 92,
    IPPROTO_BEETPH___24 = 94,
    IPPROTO_ENCAP___24 = 98,
    IPPROTO_PIM___24 = 103,
    IPPROTO_COMP___24 = 108,
    IPPROTO_SCTP___24 = 132,
    IPPROTO_UDPLITE___24 = 136,
    IPPROTO_MPLS___24 = 137,
    IPPROTO_ETHERNET___24 = 143,
    IPPROTO_RAW___24 = 255,
    IPPROTO_MPTCP___24 = 262,
    IPPROTO_MAX___24 = 263
} ;
enum __anonenum_218739988___24 {
    IPPROTO_HOPOPTS___24 = 0,
    IPPROTO_ROUTING___24 = 43,
    IPPROTO_FRAGMENT___24 = 44,
    IPPROTO_ICMPV6___24 = 58,
    IPPROTO_NONE___24 = 59,
    IPPROTO_DSTOPTS___24 = 60,
    IPPROTO_MH___24 = 135
} ;
enum __anonenum_662268580___24 {
    IPPORT_ECHO___24 = 7,
    IPPORT_DISCARD___24 = 9,
    IPPORT_SYSTAT___24 = 11,
    IPPORT_DAYTIME___24 = 13,
    IPPORT_NETSTAT___24 = 15,
    IPPORT_FTP___24 = 21,
    IPPORT_TELNET___24 = 23,
    IPPORT_SMTP___24 = 25,
    IPPORT_TIMESERVER___24 = 37,
    IPPORT_NAMESERVER___24 = 42,
    IPPORT_WHOIS___24 = 43,
    IPPORT_MTP___24 = 57,
    IPPORT_TFTP___24 = 69,
    IPPORT_RJE___24 = 77,
    IPPORT_FINGER___24 = 79,
    IPPORT_TTYLINK___24 = 87,
    IPPORT_SUPDUP___24 = 95,
    IPPORT_EXECSERVER___24 = 512,
    IPPORT_LOGINSERVER___24 = 513,
    IPPORT_CMDSERVER___24 = 514,
    IPPORT_EFSSERVER___24 = 520,
    IPPORT_BIFFUDP___24 = 512,
    IPPORT_WHOSERVER___24 = 513,
    IPPORT_ROUTESERVER___24 = 520,
    IPPORT_RESERVED___24 = 1024,
    IPPORT_USERRESERVED___24 = 5000
} ;
enum __anonenum_18926444___24 {
    _ISupper___24 = 256,
    _ISlower___24 = 512,
    _ISalpha___24 = 1024,
    _ISdigit___24 = 2048,
    _ISxdigit___24 = 4096,
    _ISspace___24 = 8192,
    _ISprint___24 = 16384,
    _ISgraph___24 = 32768,
    _ISblank___24 = 1,
    _IScntrl___24 = 2,
    _ISpunct___24 = 4,
    _ISalnum___24 = 8
} ;
enum __anonenum_913965969___24 {
    FP_INT_UPWARD___24 = 0,
    FP_INT_DOWNWARD___24 = 1,
    FP_INT_TOWARDZERO___24 = 2,
    FP_INT_TONEARESTFROMZERO___24 = 3,
    FP_INT_TONEAREST___24 = 4
} ;
enum __anonenum_1037408945___24 {
    FP_NAN___24 = 0,
    FP_INFINITE___24 = 1,
    FP_ZERO___24 = 2,
    FP_SUBNORMAL___24 = 3,
    FP_NORMAL___24 = 4
} ;
enum __anonenum_556971655___24 {
    SI_ASYNCNL___24 = -60,
    SI_DETHREAD___24 = -7,
    SI_TKILL___24 = -6,
    SI_SIGIO___24 = -5,
    SI_ASYNCIO___24 = -4,
    SI_MESGQ___24 = -3,
    SI_TIMER___24 = -2,
    SI_QUEUE___24 = -1,
    SI_USER___24 = 0,
    SI_KERNEL___24 = 128
} ;
enum __anonenum_640648963___24 {
    ILL_ILLOPC___24 = 1,
    ILL_ILLOPN___24 = 2,
    ILL_ILLADR___24 = 3,
    ILL_ILLTRP___24 = 4,
    ILL_PRVOPC___24 = 5,
    ILL_PRVREG___24 = 6,
    ILL_COPROC___24 = 7,
    ILL_BADSTK___24 = 8,
    ILL_BADIADDR___24 = 9
} ;
enum __anonenum_457704180___24 {
    FPE_INTDIV___24 = 1,
    FPE_INTOVF___24 = 2,
    FPE_FLTDIV___24 = 3,
    FPE_FLTOVF___24 = 4,
    FPE_FLTUND___24 = 5,
    FPE_FLTRES___24 = 6,
    FPE_FLTINV___24 = 7,
    FPE_FLTSUB___24 = 8,
    FPE_FLTUNK___24 = 14,
    FPE_CONDTRAP___24 = 15
} ;
enum __anonenum_180375148___24 {
    SEGV_MAPERR___24 = 1,
    SEGV_ACCERR___24 = 2,
    SEGV_BNDERR___24 = 3,
    SEGV_PKUERR___24 = 4,
    SEGV_ACCADI___24 = 5,
    SEGV_ADIDERR___24 = 6,
    SEGV_ADIPERR___24 = 7,
    SEGV_MTEAERR___24 = 8,
    SEGV_MTESERR___24 = 9
} ;
enum __anonenum_1036286214___24 {
    BUS_ADRALN___24 = 1,
    BUS_ADRERR___24 = 2,
    BUS_OBJERR___24 = 3,
    BUS_MCEERR_AR___24 = 4,
    BUS_MCEERR_AO___24 = 5
} ;
enum __anonenum_91015150___24 {
    TRAP_BRKPT___24 = 1,
    TRAP_TRACE___24 = 2,
    TRAP_BRANCH___24 = 3,
    TRAP_HWBKPT___24 = 4,
    TRAP_UNK___24 = 5
} ;
enum __anonenum_23175539___24 {
    CLD_EXITED___24 = 1,
    CLD_KILLED___24 = 2,
    CLD_DUMPED___24 = 3,
    CLD_TRAPPED___24 = 4,
    CLD_STOPPED___24 = 5,
    CLD_CONTINUED___24 = 6
} ;
enum __anonenum_111643124___24 {
    POLL_IN___24 = 1,
    POLL_OUT___24 = 2,
    POLL_MSG___24 = 3,
    POLL_ERR___24 = 4,
    POLL_PRI___24 = 5,
    POLL_HUP___24 = 6
} ;
enum __anonenum_852341087___24 {
    SIGEV_SIGNAL___24 = 0,
    SIGEV_NONE___24 = 1,
    SIGEV_THREAD___24 = 2,
    SIGEV_THREAD_ID___24 = 4
} ;
enum __anonenum_451154152___24 {
    REG_R8___24 = 0,
    REG_R9___24 = 1,
    REG_R10___24 = 2,
    REG_R11___24 = 3,
    REG_R12___24 = 4,
    REG_R13___24 = 5,
    REG_R14___24 = 6,
    REG_R15___24 = 7,
    REG_RDI___24 = 8,
    REG_RSI___24 = 9,
    REG_RBP___24 = 10,
    REG_RBX___24 = 11,
    REG_RDX___24 = 12,
    REG_RAX___24 = 13,
    REG_RCX___24 = 14,
    REG_RSP___24 = 15,
    REG_RIP___24 = 16,
    REG_EFL___24 = 17,
    REG_CSGSFS___24 = 18,
    REG_ERR___24 = 19,
    REG_TRAPNO___24 = 20,
    REG_OLDMASK___24 = 21,
    REG_CR2___24 = 22
} ;
enum __anonenum_437032235___24 {
    _PC_LINK_MAX___24 = 0,
    _PC_MAX_CANON___24 = 1,
    _PC_MAX_INPUT___24 = 2,
    _PC_NAME_MAX___24 = 3,
    _PC_PATH_MAX___24 = 4,
    _PC_PIPE_BUF___24 = 5,
    _PC_CHOWN_RESTRICTED___24 = 6,
    _PC_NO_TRUNC___24 = 7,
    _PC_VDISABLE___24 = 8,
    _PC_SYNC_IO___24 = 9,
    _PC_ASYNC_IO___24 = 10,
    _PC_PRIO_IO___24 = 11,
    _PC_SOCK_MAXBUF___24 = 12,
    _PC_FILESIZEBITS___24 = 13,
    _PC_REC_INCR_XFER_SIZE___24 = 14,
    _PC_REC_MAX_XFER_SIZE___24 = 15,
    _PC_REC_MIN_XFER_SIZE___24 = 16,
    _PC_REC_XFER_ALIGN___24 = 17,
    _PC_ALLOC_SIZE_MIN___24 = 18,
    _PC_SYMLINK_MAX___24 = 19,
    _PC_2_SYMLINKS___24 = 20
} ;
enum __anonenum_315186338___24 {
    _SC_ARG_MAX___24 = 0,
    _SC_CHILD_MAX___24 = 1,
    _SC_CLK_TCK___24 = 2,
    _SC_NGROUPS_MAX___24 = 3,
    _SC_OPEN_MAX___24 = 4,
    _SC_STREAM_MAX___24 = 5,
    _SC_TZNAME_MAX___24 = 6,
    _SC_JOB_CONTROL___24 = 7,
    _SC_SAVED_IDS___24 = 8,
    _SC_REALTIME_SIGNALS___24 = 9,
    _SC_PRIORITY_SCHEDULING___24 = 10,
    _SC_TIMERS___24 = 11,
    _SC_ASYNCHRONOUS_IO___24 = 12,
    _SC_PRIORITIZED_IO___24 = 13,
    _SC_SYNCHRONIZED_IO___24 = 14,
    _SC_FSYNC___24 = 15,
    _SC_MAPPED_FILES___24 = 16,
    _SC_MEMLOCK___24 = 17,
    _SC_MEMLOCK_RANGE___24 = 18,
    _SC_MEMORY_PROTECTION___24 = 19,
    _SC_MESSAGE_PASSING___24 = 20,
    _SC_SEMAPHORES___24 = 21,
    _SC_SHARED_MEMORY_OBJECTS___24 = 22,
    _SC_AIO_LISTIO_MAX___24 = 23,
    _SC_AIO_MAX___24 = 24,
    _SC_AIO_PRIO_DELTA_MAX___24 = 25,
    _SC_DELAYTIMER_MAX___24 = 26,
    _SC_MQ_OPEN_MAX___24 = 27,
    _SC_MQ_PRIO_MAX___24 = 28,
    _SC_VERSION___24 = 29,
    _SC_PAGESIZE___24 = 30,
    _SC_RTSIG_MAX___24 = 31,
    _SC_SEM_NSEMS_MAX___24 = 32,
    _SC_SEM_VALUE_MAX___24 = 33,
    _SC_SIGQUEUE_MAX___24 = 34,
    _SC_TIMER_MAX___24 = 35,
    _SC_BC_BASE_MAX___24 = 36,
    _SC_BC_DIM_MAX___24 = 37,
    _SC_BC_SCALE_MAX___24 = 38,
    _SC_BC_STRING_MAX___24 = 39,
    _SC_COLL_WEIGHTS_MAX___24 = 40,
    _SC_EQUIV_CLASS_MAX___24 = 41,
    _SC_EXPR_NEST_MAX___24 = 42,
    _SC_LINE_MAX___24 = 43,
    _SC_RE_DUP_MAX___24 = 44,
    _SC_CHARCLASS_NAME_MAX___24 = 45,
    _SC_2_VERSION___24 = 46,
    _SC_2_C_BIND___24 = 47,
    _SC_2_C_DEV___24 = 48,
    _SC_2_FORT_DEV___24 = 49,
    _SC_2_FORT_RUN___24 = 50,
    _SC_2_SW_DEV___24 = 51,
    _SC_2_LOCALEDEF___24 = 52,
    _SC_PII___24 = 53,
    _SC_PII_XTI___24 = 54,
    _SC_PII_SOCKET___24 = 55,
    _SC_PII_INTERNET___24 = 56,
    _SC_PII_OSI___24 = 57,
    _SC_POLL___24 = 58,
    _SC_SELECT___24 = 59,
    _SC_UIO_MAXIOV___24 = 60,
    _SC_IOV_MAX___24 = 60,
    _SC_PII_INTERNET_STREAM___24 = 61,
    _SC_PII_INTERNET_DGRAM___24 = 62,
    _SC_PII_OSI_COTS___24 = 63,
    _SC_PII_OSI_CLTS___24 = 64,
    _SC_PII_OSI_M___24 = 65,
    _SC_T_IOV_MAX___24 = 66,
    _SC_THREADS___24 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___24 = 68,
    _SC_GETGR_R_SIZE_MAX___24 = 69,
    _SC_GETPW_R_SIZE_MAX___24 = 70,
    _SC_LOGIN_NAME_MAX___24 = 71,
    _SC_TTY_NAME_MAX___24 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___24 = 73,
    _SC_THREAD_KEYS_MAX___24 = 74,
    _SC_THREAD_STACK_MIN___24 = 75,
    _SC_THREAD_THREADS_MAX___24 = 76,
    _SC_THREAD_ATTR_STACKADDR___24 = 77,
    _SC_THREAD_ATTR_STACKSIZE___24 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___24 = 79,
    _SC_THREAD_PRIO_INHERIT___24 = 80,
    _SC_THREAD_PRIO_PROTECT___24 = 81,
    _SC_THREAD_PROCESS_SHARED___24 = 82,
    _SC_NPROCESSORS_CONF___24 = 83,
    _SC_NPROCESSORS_ONLN___24 = 84,
    _SC_PHYS_PAGES___24 = 85,
    _SC_AVPHYS_PAGES___24 = 86,
    _SC_ATEXIT_MAX___24 = 87,
    _SC_PASS_MAX___24 = 88,
    _SC_XOPEN_VERSION___24 = 89,
    _SC_XOPEN_XCU_VERSION___24 = 90,
    _SC_XOPEN_UNIX___24 = 91,
    _SC_XOPEN_CRYPT___24 = 92,
    _SC_XOPEN_ENH_I18N___24 = 93,
    _SC_XOPEN_SHM___24 = 94,
    _SC_2_CHAR_TERM___24 = 95,
    _SC_2_C_VERSION___24 = 96,
    _SC_2_UPE___24 = 97,
    _SC_XOPEN_XPG2___24 = 98,
    _SC_XOPEN_XPG3___24 = 99,
    _SC_XOPEN_XPG4___24 = 100,
    _SC_CHAR_BIT___24 = 101,
    _SC_CHAR_MAX___24 = 102,
    _SC_CHAR_MIN___24 = 103,
    _SC_INT_MAX___24 = 104,
    _SC_INT_MIN___24 = 105,
    _SC_LONG_BIT___24 = 106,
    _SC_WORD_BIT___24 = 107,
    _SC_MB_LEN_MAX___24 = 108,
    _SC_NZERO___24 = 109,
    _SC_SSIZE_MAX___24 = 110,
    _SC_SCHAR_MAX___24 = 111,
    _SC_SCHAR_MIN___24 = 112,
    _SC_SHRT_MAX___24 = 113,
    _SC_SHRT_MIN___24 = 114,
    _SC_UCHAR_MAX___24 = 115,
    _SC_UINT_MAX___24 = 116,
    _SC_ULONG_MAX___24 = 117,
    _SC_USHRT_MAX___24 = 118,
    _SC_NL_ARGMAX___24 = 119,
    _SC_NL_LANGMAX___24 = 120,
    _SC_NL_MSGMAX___24 = 121,
    _SC_NL_NMAX___24 = 122,
    _SC_NL_SETMAX___24 = 123,
    _SC_NL_TEXTMAX___24 = 124,
    _SC_XBS5_ILP32_OFF32___24 = 125,
    _SC_XBS5_ILP32_OFFBIG___24 = 126,
    _SC_XBS5_LP64_OFF64___24 = 127,
    _SC_XBS5_LPBIG_OFFBIG___24 = 128,
    _SC_XOPEN_LEGACY___24 = 129,
    _SC_XOPEN_REALTIME___24 = 130,
    _SC_XOPEN_REALTIME_THREADS___24 = 131,
    _SC_ADVISORY_INFO___24 = 132,
    _SC_BARRIERS___24 = 133,
    _SC_BASE___24 = 134,
    _SC_C_LANG_SUPPORT___24 = 135,
    _SC_C_LANG_SUPPORT_R___24 = 136,
    _SC_CLOCK_SELECTION___24 = 137,
    _SC_CPUTIME___24 = 138,
    _SC_THREAD_CPUTIME___24 = 139,
    _SC_DEVICE_IO___24 = 140,
    _SC_DEVICE_SPECIFIC___24 = 141,
    _SC_DEVICE_SPECIFIC_R___24 = 142,
    _SC_FD_MGMT___24 = 143,
    _SC_FIFO___24 = 144,
    _SC_PIPE___24 = 145,
    _SC_FILE_ATTRIBUTES___24 = 146,
    _SC_FILE_LOCKING___24 = 147,
    _SC_FILE_SYSTEM___24 = 148,
    _SC_MONOTONIC_CLOCK___24 = 149,
    _SC_MULTI_PROCESS___24 = 150,
    _SC_SINGLE_PROCESS___24 = 151,
    _SC_NETWORKING___24 = 152,
    _SC_READER_WRITER_LOCKS___24 = 153,
    _SC_SPIN_LOCKS___24 = 154,
    _SC_REGEXP___24 = 155,
    _SC_REGEX_VERSION___24 = 156,
    _SC_SHELL___24 = 157,
    _SC_SIGNALS___24 = 158,
    _SC_SPAWN___24 = 159,
    _SC_SPORADIC_SERVER___24 = 160,
    _SC_THREAD_SPORADIC_SERVER___24 = 161,
    _SC_SYSTEM_DATABASE___24 = 162,
    _SC_SYSTEM_DATABASE_R___24 = 163,
    _SC_TIMEOUTS___24 = 164,
    _SC_TYPED_MEMORY_OBJECTS___24 = 165,
    _SC_USER_GROUPS___24 = 166,
    _SC_USER_GROUPS_R___24 = 167,
    _SC_2_PBS___24 = 168,
    _SC_2_PBS_ACCOUNTING___24 = 169,
    _SC_2_PBS_LOCATE___24 = 170,
    _SC_2_PBS_MESSAGE___24 = 171,
    _SC_2_PBS_TRACK___24 = 172,
    _SC_SYMLOOP_MAX___24 = 173,
    _SC_STREAMS___24 = 174,
    _SC_2_PBS_CHECKPOINT___24 = 175,
    _SC_V6_ILP32_OFF32___24 = 176,
    _SC_V6_ILP32_OFFBIG___24 = 177,
    _SC_V6_LP64_OFF64___24 = 178,
    _SC_V6_LPBIG_OFFBIG___24 = 179,
    _SC_HOST_NAME_MAX___24 = 180,
    _SC_TRACE___24 = 181,
    _SC_TRACE_EVENT_FILTER___24 = 182,
    _SC_TRACE_INHERIT___24 = 183,
    _SC_TRACE_LOG___24 = 184,
    _SC_LEVEL1_ICACHE_SIZE___24 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___24 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___24 = 187,
    _SC_LEVEL1_DCACHE_SIZE___24 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___24 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___24 = 190,
    _SC_LEVEL2_CACHE_SIZE___24 = 191,
    _SC_LEVEL2_CACHE_ASSOC___24 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___24 = 193,
    _SC_LEVEL3_CACHE_SIZE___24 = 194,
    _SC_LEVEL3_CACHE_ASSOC___24 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___24 = 196,
    _SC_LEVEL4_CACHE_SIZE___24 = 197,
    _SC_LEVEL4_CACHE_ASSOC___24 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___24 = 199,
    _SC_IPV6___24 = 235,
    _SC_RAW_SOCKETS___24 = 236,
    _SC_V7_ILP32_OFF32___24 = 237,
    _SC_V7_ILP32_OFFBIG___24 = 238,
    _SC_V7_LP64_OFF64___24 = 239,
    _SC_V7_LPBIG_OFFBIG___24 = 240,
    _SC_SS_REPL_MAX___24 = 241,
    _SC_TRACE_EVENT_NAME_MAX___24 = 242,
    _SC_TRACE_NAME_MAX___24 = 243,
    _SC_TRACE_SYS_MAX___24 = 244,
    _SC_TRACE_USER_EVENT_MAX___24 = 245,
    _SC_XOPEN_STREAMS___24 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___24 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___24 = 248,
    _SC_MINSIGSTKSZ___24 = 249,
    _SC_SIGSTKSZ___24 = 250
} ;
enum __anonenum_875524036___24 {
    _CS_PATH___24 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___24 = 1,
    _CS_GNU_LIBC_VERSION___24 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___24 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___24 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___24 = 5,
    _CS_LFS_CFLAGS___24 = 1000,
    _CS_LFS_LDFLAGS___24 = 1001,
    _CS_LFS_LIBS___24 = 1002,
    _CS_LFS_LINTFLAGS___24 = 1003,
    _CS_LFS64_CFLAGS___24 = 1004,
    _CS_LFS64_LDFLAGS___24 = 1005,
    _CS_LFS64_LIBS___24 = 1006,
    _CS_LFS64_LINTFLAGS___24 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___24 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___24 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___24 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___24 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___24 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___24 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___24 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___24 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___24 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___24 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___24 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___24 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___24 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___24 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___24 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___24 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___24 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___24 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___24 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___24 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___24 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___24 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___24 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___24 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___24 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___24 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___24 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___24 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___24 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___24 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___24 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___24 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___24 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___24 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___24 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___24 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___24 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___24 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___24 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___24 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___24 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___24 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___24 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___24 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___24 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___24 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___24 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___24 = 1147,
    _CS_V6_ENV___24 = 1148,
    _CS_V7_ENV___24 = 1149
} ;
enum __anonenum_57186863___24 {
    SS_ONSTACK___24 = 1,
    SS_DISABLE___24 = 2
} ;
struct ADF_AuthTableInst ;
typedef struct ADF_AuthTableInst *ADF_AuthTable;
enum __anonenum_ADF_Status_459173375 {
    ADF_SUCCESS = 0,
    ADF_BADSUBNET = 1
} ;
typedef enum __anonenum_ADF_Status_459173375 ADF_Status;
enum __anonenum_83571709___25 {
    MSG_OOB___25 = 1,
    MSG_PEEK___25 = 2,
    MSG_DONTROUTE___25 = 4,
    MSG_TRYHARD___25 = 4,
    MSG_CTRUNC___25 = 8,
    MSG_PROXY___25 = 16,
    MSG_TRUNC___25 = 32,
    MSG_DONTWAIT___25 = 64,
    MSG_EOR___25 = 128,
    MSG_WAITALL___25 = 256,
    MSG_FIN___25 = 512,
    MSG_SYN___25 = 1024,
    MSG_CONFIRM___25 = 2048,
    MSG_RST___25 = 4096,
    MSG_ERRQUEUE___25 = 8192,
    MSG_NOSIGNAL___25 = 16384,
    MSG_MORE___25 = 32768,
    MSG_WAITFORONE___25 = 65536,
    MSG_BATCH___25 = 262144,
    MSG_ZEROCOPY___25 = 67108864,
    MSG_FASTOPEN___25 = 536870912,
    MSG_CMSG_CLOEXEC___25 = 1073741824
} ;
enum __anonenum_617082774___25 {
    SCM_RIGHTS___25 = 1,
    SCM_CREDENTIALS___25 = 2
} ;
enum __anonenum_606441560___25 {
    SHUT_RD___25 = 0,
    SHUT_WR___25 = 1,
    SHUT_RDWR___25 = 2
} ;
enum __anonenum_264779956___25 {
    IPPROTO_IP___25 = 0,
    IPPROTO_ICMP___25 = 1,
    IPPROTO_IGMP___25 = 2,
    IPPROTO_IPIP___25 = 4,
    IPPROTO_TCP___25 = 6,
    IPPROTO_EGP___25 = 8,
    IPPROTO_PUP___25 = 12,
    IPPROTO_UDP___25 = 17,
    IPPROTO_IDP___25 = 22,
    IPPROTO_TP___25 = 29,
    IPPROTO_DCCP___25 = 33,
    IPPROTO_IPV6___25 = 41,
    IPPROTO_RSVP___25 = 46,
    IPPROTO_GRE___25 = 47,
    IPPROTO_ESP___25 = 50,
    IPPROTO_AH___25 = 51,
    IPPROTO_MTP___25 = 92,
    IPPROTO_BEETPH___25 = 94,
    IPPROTO_ENCAP___25 = 98,
    IPPROTO_PIM___25 = 103,
    IPPROTO_COMP___25 = 108,
    IPPROTO_SCTP___25 = 132,
    IPPROTO_UDPLITE___25 = 136,
    IPPROTO_MPLS___25 = 137,
    IPPROTO_ETHERNET___25 = 143,
    IPPROTO_RAW___25 = 255,
    IPPROTO_MPTCP___25 = 262,
    IPPROTO_MAX___25 = 263
} ;
enum __anonenum_218739988___25 {
    IPPROTO_HOPOPTS___25 = 0,
    IPPROTO_ROUTING___25 = 43,
    IPPROTO_FRAGMENT___25 = 44,
    IPPROTO_ICMPV6___25 = 58,
    IPPROTO_NONE___25 = 59,
    IPPROTO_DSTOPTS___25 = 60,
    IPPROTO_MH___25 = 135
} ;
enum __anonenum_662268580___25 {
    IPPORT_ECHO___25 = 7,
    IPPORT_DISCARD___25 = 9,
    IPPORT_SYSTAT___25 = 11,
    IPPORT_DAYTIME___25 = 13,
    IPPORT_NETSTAT___25 = 15,
    IPPORT_FTP___25 = 21,
    IPPORT_TELNET___25 = 23,
    IPPORT_SMTP___25 = 25,
    IPPORT_TIMESERVER___25 = 37,
    IPPORT_NAMESERVER___25 = 42,
    IPPORT_WHOIS___25 = 43,
    IPPORT_MTP___25 = 57,
    IPPORT_TFTP___25 = 69,
    IPPORT_RJE___25 = 77,
    IPPORT_FINGER___25 = 79,
    IPPORT_TTYLINK___25 = 87,
    IPPORT_SUPDUP___25 = 95,
    IPPORT_EXECSERVER___25 = 512,
    IPPORT_LOGINSERVER___25 = 513,
    IPPORT_CMDSERVER___25 = 514,
    IPPORT_EFSSERVER___25 = 520,
    IPPORT_BIFFUDP___25 = 512,
    IPPORT_WHOSERVER___25 = 513,
    IPPORT_ROUTESERVER___25 = 520,
    IPPORT_RESERVED___25 = 1024,
    IPPORT_USERRESERVED___25 = 5000
} ;
enum __anonenum_18926444___25 {
    _ISupper___25 = 256,
    _ISlower___25 = 512,
    _ISalpha___25 = 1024,
    _ISdigit___25 = 2048,
    _ISxdigit___25 = 4096,
    _ISspace___25 = 8192,
    _ISprint___25 = 16384,
    _ISgraph___25 = 32768,
    _ISblank___25 = 1,
    _IScntrl___25 = 2,
    _ISpunct___25 = 4,
    _ISalnum___25 = 8
} ;
enum __anonenum_913965969___25 {
    FP_INT_UPWARD___25 = 0,
    FP_INT_DOWNWARD___25 = 1,
    FP_INT_TOWARDZERO___25 = 2,
    FP_INT_TONEARESTFROMZERO___25 = 3,
    FP_INT_TONEAREST___25 = 4
} ;
enum __anonenum_1037408945___25 {
    FP_NAN___25 = 0,
    FP_INFINITE___25 = 1,
    FP_ZERO___25 = 2,
    FP_SUBNORMAL___25 = 3,
    FP_NORMAL___25 = 4
} ;
enum __anonenum_556971655___25 {
    SI_ASYNCNL___25 = -60,
    SI_DETHREAD___25 = -7,
    SI_TKILL___25 = -6,
    SI_SIGIO___25 = -5,
    SI_ASYNCIO___25 = -4,
    SI_MESGQ___25 = -3,
    SI_TIMER___25 = -2,
    SI_QUEUE___25 = -1,
    SI_USER___25 = 0,
    SI_KERNEL___25 = 128
} ;
enum __anonenum_640648963___25 {
    ILL_ILLOPC___25 = 1,
    ILL_ILLOPN___25 = 2,
    ILL_ILLADR___25 = 3,
    ILL_ILLTRP___25 = 4,
    ILL_PRVOPC___25 = 5,
    ILL_PRVREG___25 = 6,
    ILL_COPROC___25 = 7,
    ILL_BADSTK___25 = 8,
    ILL_BADIADDR___25 = 9
} ;
enum __anonenum_457704180___25 {
    FPE_INTDIV___25 = 1,
    FPE_INTOVF___25 = 2,
    FPE_FLTDIV___25 = 3,
    FPE_FLTOVF___25 = 4,
    FPE_FLTUND___25 = 5,
    FPE_FLTRES___25 = 6,
    FPE_FLTINV___25 = 7,
    FPE_FLTSUB___25 = 8,
    FPE_FLTUNK___25 = 14,
    FPE_CONDTRAP___25 = 15
} ;
enum __anonenum_180375148___25 {
    SEGV_MAPERR___25 = 1,
    SEGV_ACCERR___25 = 2,
    SEGV_BNDERR___25 = 3,
    SEGV_PKUERR___25 = 4,
    SEGV_ACCADI___25 = 5,
    SEGV_ADIDERR___25 = 6,
    SEGV_ADIPERR___25 = 7,
    SEGV_MTEAERR___25 = 8,
    SEGV_MTESERR___25 = 9
} ;
enum __anonenum_1036286214___25 {
    BUS_ADRALN___25 = 1,
    BUS_ADRERR___25 = 2,
    BUS_OBJERR___25 = 3,
    BUS_MCEERR_AR___25 = 4,
    BUS_MCEERR_AO___25 = 5
} ;
enum __anonenum_91015150___25 {
    TRAP_BRKPT___25 = 1,
    TRAP_TRACE___25 = 2,
    TRAP_BRANCH___25 = 3,
    TRAP_HWBKPT___25 = 4,
    TRAP_UNK___25 = 5
} ;
enum __anonenum_23175539___25 {
    CLD_EXITED___25 = 1,
    CLD_KILLED___25 = 2,
    CLD_DUMPED___25 = 3,
    CLD_TRAPPED___25 = 4,
    CLD_STOPPED___25 = 5,
    CLD_CONTINUED___25 = 6
} ;
enum __anonenum_111643124___25 {
    POLL_IN___25 = 1,
    POLL_OUT___25 = 2,
    POLL_MSG___25 = 3,
    POLL_ERR___25 = 4,
    POLL_PRI___25 = 5,
    POLL_HUP___25 = 6
} ;
enum __anonenum_852341087___25 {
    SIGEV_SIGNAL___25 = 0,
    SIGEV_NONE___25 = 1,
    SIGEV_THREAD___25 = 2,
    SIGEV_THREAD_ID___25 = 4
} ;
enum __anonenum_451154152___25 {
    REG_R8___25 = 0,
    REG_R9___25 = 1,
    REG_R10___25 = 2,
    REG_R11___25 = 3,
    REG_R12___25 = 4,
    REG_R13___25 = 5,
    REG_R14___25 = 6,
    REG_R15___25 = 7,
    REG_RDI___25 = 8,
    REG_RSI___25 = 9,
    REG_RBP___25 = 10,
    REG_RBX___25 = 11,
    REG_RDX___25 = 12,
    REG_RAX___25 = 13,
    REG_RCX___25 = 14,
    REG_RSP___25 = 15,
    REG_RIP___25 = 16,
    REG_EFL___25 = 17,
    REG_CSGSFS___25 = 18,
    REG_ERR___25 = 19,
    REG_TRAPNO___25 = 20,
    REG_OLDMASK___25 = 21,
    REG_CR2___25 = 22
} ;
enum __anonenum_437032235___25 {
    _PC_LINK_MAX___25 = 0,
    _PC_MAX_CANON___25 = 1,
    _PC_MAX_INPUT___25 = 2,
    _PC_NAME_MAX___25 = 3,
    _PC_PATH_MAX___25 = 4,
    _PC_PIPE_BUF___25 = 5,
    _PC_CHOWN_RESTRICTED___25 = 6,
    _PC_NO_TRUNC___25 = 7,
    _PC_VDISABLE___25 = 8,
    _PC_SYNC_IO___25 = 9,
    _PC_ASYNC_IO___25 = 10,
    _PC_PRIO_IO___25 = 11,
    _PC_SOCK_MAXBUF___25 = 12,
    _PC_FILESIZEBITS___25 = 13,
    _PC_REC_INCR_XFER_SIZE___25 = 14,
    _PC_REC_MAX_XFER_SIZE___25 = 15,
    _PC_REC_MIN_XFER_SIZE___25 = 16,
    _PC_REC_XFER_ALIGN___25 = 17,
    _PC_ALLOC_SIZE_MIN___25 = 18,
    _PC_SYMLINK_MAX___25 = 19,
    _PC_2_SYMLINKS___25 = 20
} ;
enum __anonenum_315186338___25 {
    _SC_ARG_MAX___25 = 0,
    _SC_CHILD_MAX___25 = 1,
    _SC_CLK_TCK___25 = 2,
    _SC_NGROUPS_MAX___25 = 3,
    _SC_OPEN_MAX___25 = 4,
    _SC_STREAM_MAX___25 = 5,
    _SC_TZNAME_MAX___25 = 6,
    _SC_JOB_CONTROL___25 = 7,
    _SC_SAVED_IDS___25 = 8,
    _SC_REALTIME_SIGNALS___25 = 9,
    _SC_PRIORITY_SCHEDULING___25 = 10,
    _SC_TIMERS___25 = 11,
    _SC_ASYNCHRONOUS_IO___25 = 12,
    _SC_PRIORITIZED_IO___25 = 13,
    _SC_SYNCHRONIZED_IO___25 = 14,
    _SC_FSYNC___25 = 15,
    _SC_MAPPED_FILES___25 = 16,
    _SC_MEMLOCK___25 = 17,
    _SC_MEMLOCK_RANGE___25 = 18,
    _SC_MEMORY_PROTECTION___25 = 19,
    _SC_MESSAGE_PASSING___25 = 20,
    _SC_SEMAPHORES___25 = 21,
    _SC_SHARED_MEMORY_OBJECTS___25 = 22,
    _SC_AIO_LISTIO_MAX___25 = 23,
    _SC_AIO_MAX___25 = 24,
    _SC_AIO_PRIO_DELTA_MAX___25 = 25,
    _SC_DELAYTIMER_MAX___25 = 26,
    _SC_MQ_OPEN_MAX___25 = 27,
    _SC_MQ_PRIO_MAX___25 = 28,
    _SC_VERSION___25 = 29,
    _SC_PAGESIZE___25 = 30,
    _SC_RTSIG_MAX___25 = 31,
    _SC_SEM_NSEMS_MAX___25 = 32,
    _SC_SEM_VALUE_MAX___25 = 33,
    _SC_SIGQUEUE_MAX___25 = 34,
    _SC_TIMER_MAX___25 = 35,
    _SC_BC_BASE_MAX___25 = 36,
    _SC_BC_DIM_MAX___25 = 37,
    _SC_BC_SCALE_MAX___25 = 38,
    _SC_BC_STRING_MAX___25 = 39,
    _SC_COLL_WEIGHTS_MAX___25 = 40,
    _SC_EQUIV_CLASS_MAX___25 = 41,
    _SC_EXPR_NEST_MAX___25 = 42,
    _SC_LINE_MAX___25 = 43,
    _SC_RE_DUP_MAX___25 = 44,
    _SC_CHARCLASS_NAME_MAX___25 = 45,
    _SC_2_VERSION___25 = 46,
    _SC_2_C_BIND___25 = 47,
    _SC_2_C_DEV___25 = 48,
    _SC_2_FORT_DEV___25 = 49,
    _SC_2_FORT_RUN___25 = 50,
    _SC_2_SW_DEV___25 = 51,
    _SC_2_LOCALEDEF___25 = 52,
    _SC_PII___25 = 53,
    _SC_PII_XTI___25 = 54,
    _SC_PII_SOCKET___25 = 55,
    _SC_PII_INTERNET___25 = 56,
    _SC_PII_OSI___25 = 57,
    _SC_POLL___25 = 58,
    _SC_SELECT___25 = 59,
    _SC_UIO_MAXIOV___25 = 60,
    _SC_IOV_MAX___25 = 60,
    _SC_PII_INTERNET_STREAM___25 = 61,
    _SC_PII_INTERNET_DGRAM___25 = 62,
    _SC_PII_OSI_COTS___25 = 63,
    _SC_PII_OSI_CLTS___25 = 64,
    _SC_PII_OSI_M___25 = 65,
    _SC_T_IOV_MAX___25 = 66,
    _SC_THREADS___25 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___25 = 68,
    _SC_GETGR_R_SIZE_MAX___25 = 69,
    _SC_GETPW_R_SIZE_MAX___25 = 70,
    _SC_LOGIN_NAME_MAX___25 = 71,
    _SC_TTY_NAME_MAX___25 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___25 = 73,
    _SC_THREAD_KEYS_MAX___25 = 74,
    _SC_THREAD_STACK_MIN___25 = 75,
    _SC_THREAD_THREADS_MAX___25 = 76,
    _SC_THREAD_ATTR_STACKADDR___25 = 77,
    _SC_THREAD_ATTR_STACKSIZE___25 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___25 = 79,
    _SC_THREAD_PRIO_INHERIT___25 = 80,
    _SC_THREAD_PRIO_PROTECT___25 = 81,
    _SC_THREAD_PROCESS_SHARED___25 = 82,
    _SC_NPROCESSORS_CONF___25 = 83,
    _SC_NPROCESSORS_ONLN___25 = 84,
    _SC_PHYS_PAGES___25 = 85,
    _SC_AVPHYS_PAGES___25 = 86,
    _SC_ATEXIT_MAX___25 = 87,
    _SC_PASS_MAX___25 = 88,
    _SC_XOPEN_VERSION___25 = 89,
    _SC_XOPEN_XCU_VERSION___25 = 90,
    _SC_XOPEN_UNIX___25 = 91,
    _SC_XOPEN_CRYPT___25 = 92,
    _SC_XOPEN_ENH_I18N___25 = 93,
    _SC_XOPEN_SHM___25 = 94,
    _SC_2_CHAR_TERM___25 = 95,
    _SC_2_C_VERSION___25 = 96,
    _SC_2_UPE___25 = 97,
    _SC_XOPEN_XPG2___25 = 98,
    _SC_XOPEN_XPG3___25 = 99,
    _SC_XOPEN_XPG4___25 = 100,
    _SC_CHAR_BIT___25 = 101,
    _SC_CHAR_MAX___25 = 102,
    _SC_CHAR_MIN___25 = 103,
    _SC_INT_MAX___25 = 104,
    _SC_INT_MIN___25 = 105,
    _SC_LONG_BIT___25 = 106,
    _SC_WORD_BIT___25 = 107,
    _SC_MB_LEN_MAX___25 = 108,
    _SC_NZERO___25 = 109,
    _SC_SSIZE_MAX___25 = 110,
    _SC_SCHAR_MAX___25 = 111,
    _SC_SCHAR_MIN___25 = 112,
    _SC_SHRT_MAX___25 = 113,
    _SC_SHRT_MIN___25 = 114,
    _SC_UCHAR_MAX___25 = 115,
    _SC_UINT_MAX___25 = 116,
    _SC_ULONG_MAX___25 = 117,
    _SC_USHRT_MAX___25 = 118,
    _SC_NL_ARGMAX___25 = 119,
    _SC_NL_LANGMAX___25 = 120,
    _SC_NL_MSGMAX___25 = 121,
    _SC_NL_NMAX___25 = 122,
    _SC_NL_SETMAX___25 = 123,
    _SC_NL_TEXTMAX___25 = 124,
    _SC_XBS5_ILP32_OFF32___25 = 125,
    _SC_XBS5_ILP32_OFFBIG___25 = 126,
    _SC_XBS5_LP64_OFF64___25 = 127,
    _SC_XBS5_LPBIG_OFFBIG___25 = 128,
    _SC_XOPEN_LEGACY___25 = 129,
    _SC_XOPEN_REALTIME___25 = 130,
    _SC_XOPEN_REALTIME_THREADS___25 = 131,
    _SC_ADVISORY_INFO___25 = 132,
    _SC_BARRIERS___25 = 133,
    _SC_BASE___25 = 134,
    _SC_C_LANG_SUPPORT___25 = 135,
    _SC_C_LANG_SUPPORT_R___25 = 136,
    _SC_CLOCK_SELECTION___25 = 137,
    _SC_CPUTIME___25 = 138,
    _SC_THREAD_CPUTIME___25 = 139,
    _SC_DEVICE_IO___25 = 140,
    _SC_DEVICE_SPECIFIC___25 = 141,
    _SC_DEVICE_SPECIFIC_R___25 = 142,
    _SC_FD_MGMT___25 = 143,
    _SC_FIFO___25 = 144,
    _SC_PIPE___25 = 145,
    _SC_FILE_ATTRIBUTES___25 = 146,
    _SC_FILE_LOCKING___25 = 147,
    _SC_FILE_SYSTEM___25 = 148,
    _SC_MONOTONIC_CLOCK___25 = 149,
    _SC_MULTI_PROCESS___25 = 150,
    _SC_SINGLE_PROCESS___25 = 151,
    _SC_NETWORKING___25 = 152,
    _SC_READER_WRITER_LOCKS___25 = 153,
    _SC_SPIN_LOCKS___25 = 154,
    _SC_REGEXP___25 = 155,
    _SC_REGEX_VERSION___25 = 156,
    _SC_SHELL___25 = 157,
    _SC_SIGNALS___25 = 158,
    _SC_SPAWN___25 = 159,
    _SC_SPORADIC_SERVER___25 = 160,
    _SC_THREAD_SPORADIC_SERVER___25 = 161,
    _SC_SYSTEM_DATABASE___25 = 162,
    _SC_SYSTEM_DATABASE_R___25 = 163,
    _SC_TIMEOUTS___25 = 164,
    _SC_TYPED_MEMORY_OBJECTS___25 = 165,
    _SC_USER_GROUPS___25 = 166,
    _SC_USER_GROUPS_R___25 = 167,
    _SC_2_PBS___25 = 168,
    _SC_2_PBS_ACCOUNTING___25 = 169,
    _SC_2_PBS_LOCATE___25 = 170,
    _SC_2_PBS_MESSAGE___25 = 171,
    _SC_2_PBS_TRACK___25 = 172,
    _SC_SYMLOOP_MAX___25 = 173,
    _SC_STREAMS___25 = 174,
    _SC_2_PBS_CHECKPOINT___25 = 175,
    _SC_V6_ILP32_OFF32___25 = 176,
    _SC_V6_ILP32_OFFBIG___25 = 177,
    _SC_V6_LP64_OFF64___25 = 178,
    _SC_V6_LPBIG_OFFBIG___25 = 179,
    _SC_HOST_NAME_MAX___25 = 180,
    _SC_TRACE___25 = 181,
    _SC_TRACE_EVENT_FILTER___25 = 182,
    _SC_TRACE_INHERIT___25 = 183,
    _SC_TRACE_LOG___25 = 184,
    _SC_LEVEL1_ICACHE_SIZE___25 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___25 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___25 = 187,
    _SC_LEVEL1_DCACHE_SIZE___25 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___25 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___25 = 190,
    _SC_LEVEL2_CACHE_SIZE___25 = 191,
    _SC_LEVEL2_CACHE_ASSOC___25 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___25 = 193,
    _SC_LEVEL3_CACHE_SIZE___25 = 194,
    _SC_LEVEL3_CACHE_ASSOC___25 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___25 = 196,
    _SC_LEVEL4_CACHE_SIZE___25 = 197,
    _SC_LEVEL4_CACHE_ASSOC___25 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___25 = 199,
    _SC_IPV6___25 = 235,
    _SC_RAW_SOCKETS___25 = 236,
    _SC_V7_ILP32_OFF32___25 = 237,
    _SC_V7_ILP32_OFFBIG___25 = 238,
    _SC_V7_LP64_OFF64___25 = 239,
    _SC_V7_LPBIG_OFFBIG___25 = 240,
    _SC_SS_REPL_MAX___25 = 241,
    _SC_TRACE_EVENT_NAME_MAX___25 = 242,
    _SC_TRACE_NAME_MAX___25 = 243,
    _SC_TRACE_SYS_MAX___25 = 244,
    _SC_TRACE_USER_EVENT_MAX___25 = 245,
    _SC_XOPEN_STREAMS___25 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___25 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___25 = 248,
    _SC_MINSIGSTKSZ___25 = 249,
    _SC_SIGSTKSZ___25 = 250
} ;
enum __anonenum_875524036___25 {
    _CS_PATH___25 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___25 = 1,
    _CS_GNU_LIBC_VERSION___25 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___25 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___25 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___25 = 5,
    _CS_LFS_CFLAGS___25 = 1000,
    _CS_LFS_LDFLAGS___25 = 1001,
    _CS_LFS_LIBS___25 = 1002,
    _CS_LFS_LINTFLAGS___25 = 1003,
    _CS_LFS64_CFLAGS___25 = 1004,
    _CS_LFS64_LDFLAGS___25 = 1005,
    _CS_LFS64_LIBS___25 = 1006,
    _CS_LFS64_LINTFLAGS___25 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___25 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___25 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___25 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___25 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___25 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___25 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___25 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___25 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___25 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___25 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___25 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___25 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___25 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___25 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___25 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___25 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___25 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___25 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___25 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___25 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___25 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___25 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___25 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___25 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___25 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___25 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___25 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___25 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___25 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___25 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___25 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___25 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___25 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___25 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___25 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___25 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___25 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___25 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___25 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___25 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___25 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___25 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___25 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___25 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___25 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___25 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___25 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___25 = 1147,
    _CS_V6_ENV___25 = 1148,
    _CS_V7_ENV___25 = 1149
} ;
enum __anonenum_57186863___25 {
    SS_ONSTACK___25 = 1,
    SS_DISABLE___25 = 2
} ;
struct __anonstruct_Sample_1072063707 {
   struct timespec when ;
   double orig_offset ;
   double offset ;
   double residual ;
};
typedef struct __anonstruct_Sample_1072063707 Sample;
enum __anonenum_83571709___26 {
    MSG_OOB___26 = 1,
    MSG_PEEK___26 = 2,
    MSG_DONTROUTE___26 = 4,
    MSG_TRYHARD___26 = 4,
    MSG_CTRUNC___26 = 8,
    MSG_PROXY___26 = 16,
    MSG_TRUNC___26 = 32,
    MSG_DONTWAIT___26 = 64,
    MSG_EOR___26 = 128,
    MSG_WAITALL___26 = 256,
    MSG_FIN___26 = 512,
    MSG_SYN___26 = 1024,
    MSG_CONFIRM___26 = 2048,
    MSG_RST___26 = 4096,
    MSG_ERRQUEUE___26 = 8192,
    MSG_NOSIGNAL___26 = 16384,
    MSG_MORE___26 = 32768,
    MSG_WAITFORONE___26 = 65536,
    MSG_BATCH___26 = 262144,
    MSG_ZEROCOPY___26 = 67108864,
    MSG_FASTOPEN___26 = 536870912,
    MSG_CMSG_CLOEXEC___26 = 1073741824
} ;
enum __anonenum_617082774___26 {
    SCM_RIGHTS___26 = 1,
    SCM_CREDENTIALS___26 = 2
} ;
enum __anonenum_606441560___26 {
    SHUT_RD___26 = 0,
    SHUT_WR___26 = 1,
    SHUT_RDWR___26 = 2
} ;
enum __anonenum_264779956___26 {
    IPPROTO_IP___26 = 0,
    IPPROTO_ICMP___26 = 1,
    IPPROTO_IGMP___26 = 2,
    IPPROTO_IPIP___26 = 4,
    IPPROTO_TCP___26 = 6,
    IPPROTO_EGP___26 = 8,
    IPPROTO_PUP___26 = 12,
    IPPROTO_UDP___26 = 17,
    IPPROTO_IDP___26 = 22,
    IPPROTO_TP___26 = 29,
    IPPROTO_DCCP___26 = 33,
    IPPROTO_IPV6___26 = 41,
    IPPROTO_RSVP___26 = 46,
    IPPROTO_GRE___26 = 47,
    IPPROTO_ESP___26 = 50,
    IPPROTO_AH___26 = 51,
    IPPROTO_MTP___26 = 92,
    IPPROTO_BEETPH___26 = 94,
    IPPROTO_ENCAP___26 = 98,
    IPPROTO_PIM___26 = 103,
    IPPROTO_COMP___26 = 108,
    IPPROTO_SCTP___26 = 132,
    IPPROTO_UDPLITE___26 = 136,
    IPPROTO_MPLS___26 = 137,
    IPPROTO_ETHERNET___26 = 143,
    IPPROTO_RAW___26 = 255,
    IPPROTO_MPTCP___26 = 262,
    IPPROTO_MAX___26 = 263
} ;
enum __anonenum_218739988___26 {
    IPPROTO_HOPOPTS___26 = 0,
    IPPROTO_ROUTING___26 = 43,
    IPPROTO_FRAGMENT___26 = 44,
    IPPROTO_ICMPV6___26 = 58,
    IPPROTO_NONE___26 = 59,
    IPPROTO_DSTOPTS___26 = 60,
    IPPROTO_MH___26 = 135
} ;
enum __anonenum_662268580___26 {
    IPPORT_ECHO___26 = 7,
    IPPORT_DISCARD___26 = 9,
    IPPORT_SYSTAT___26 = 11,
    IPPORT_DAYTIME___26 = 13,
    IPPORT_NETSTAT___26 = 15,
    IPPORT_FTP___26 = 21,
    IPPORT_TELNET___26 = 23,
    IPPORT_SMTP___26 = 25,
    IPPORT_TIMESERVER___26 = 37,
    IPPORT_NAMESERVER___26 = 42,
    IPPORT_WHOIS___26 = 43,
    IPPORT_MTP___26 = 57,
    IPPORT_TFTP___26 = 69,
    IPPORT_RJE___26 = 77,
    IPPORT_FINGER___26 = 79,
    IPPORT_TTYLINK___26 = 87,
    IPPORT_SUPDUP___26 = 95,
    IPPORT_EXECSERVER___26 = 512,
    IPPORT_LOGINSERVER___26 = 513,
    IPPORT_CMDSERVER___26 = 514,
    IPPORT_EFSSERVER___26 = 520,
    IPPORT_BIFFUDP___26 = 512,
    IPPORT_WHOSERVER___26 = 513,
    IPPORT_ROUTESERVER___26 = 520,
    IPPORT_RESERVED___26 = 1024,
    IPPORT_USERRESERVED___26 = 5000
} ;
enum __anonenum_18926444___26 {
    _ISupper___26 = 256,
    _ISlower___26 = 512,
    _ISalpha___26 = 1024,
    _ISdigit___26 = 2048,
    _ISxdigit___26 = 4096,
    _ISspace___26 = 8192,
    _ISprint___26 = 16384,
    _ISgraph___26 = 32768,
    _ISblank___26 = 1,
    _IScntrl___26 = 2,
    _ISpunct___26 = 4,
    _ISalnum___26 = 8
} ;
enum __anonenum_913965969___26 {
    FP_INT_UPWARD___26 = 0,
    FP_INT_DOWNWARD___26 = 1,
    FP_INT_TOWARDZERO___26 = 2,
    FP_INT_TONEARESTFROMZERO___26 = 3,
    FP_INT_TONEAREST___26 = 4
} ;
enum __anonenum_1037408945___26 {
    FP_NAN___26 = 0,
    FP_INFINITE___26 = 1,
    FP_ZERO___26 = 2,
    FP_SUBNORMAL___26 = 3,
    FP_NORMAL___26 = 4
} ;
enum __anonenum_556971655___26 {
    SI_ASYNCNL___26 = -60,
    SI_DETHREAD___26 = -7,
    SI_TKILL___26 = -6,
    SI_SIGIO___26 = -5,
    SI_ASYNCIO___26 = -4,
    SI_MESGQ___26 = -3,
    SI_TIMER___26 = -2,
    SI_QUEUE___26 = -1,
    SI_USER___26 = 0,
    SI_KERNEL___26 = 128
} ;
enum __anonenum_640648963___26 {
    ILL_ILLOPC___26 = 1,
    ILL_ILLOPN___26 = 2,
    ILL_ILLADR___26 = 3,
    ILL_ILLTRP___26 = 4,
    ILL_PRVOPC___26 = 5,
    ILL_PRVREG___26 = 6,
    ILL_COPROC___26 = 7,
    ILL_BADSTK___26 = 8,
    ILL_BADIADDR___26 = 9
} ;
enum __anonenum_457704180___26 {
    FPE_INTDIV___26 = 1,
    FPE_INTOVF___26 = 2,
    FPE_FLTDIV___26 = 3,
    FPE_FLTOVF___26 = 4,
    FPE_FLTUND___26 = 5,
    FPE_FLTRES___26 = 6,
    FPE_FLTINV___26 = 7,
    FPE_FLTSUB___26 = 8,
    FPE_FLTUNK___26 = 14,
    FPE_CONDTRAP___26 = 15
} ;
enum __anonenum_180375148___26 {
    SEGV_MAPERR___26 = 1,
    SEGV_ACCERR___26 = 2,
    SEGV_BNDERR___26 = 3,
    SEGV_PKUERR___26 = 4,
    SEGV_ACCADI___26 = 5,
    SEGV_ADIDERR___26 = 6,
    SEGV_ADIPERR___26 = 7,
    SEGV_MTEAERR___26 = 8,
    SEGV_MTESERR___26 = 9
} ;
enum __anonenum_1036286214___26 {
    BUS_ADRALN___26 = 1,
    BUS_ADRERR___26 = 2,
    BUS_OBJERR___26 = 3,
    BUS_MCEERR_AR___26 = 4,
    BUS_MCEERR_AO___26 = 5
} ;
enum __anonenum_91015150___26 {
    TRAP_BRKPT___26 = 1,
    TRAP_TRACE___26 = 2,
    TRAP_BRANCH___26 = 3,
    TRAP_HWBKPT___26 = 4,
    TRAP_UNK___26 = 5
} ;
enum __anonenum_23175539___26 {
    CLD_EXITED___26 = 1,
    CLD_KILLED___26 = 2,
    CLD_DUMPED___26 = 3,
    CLD_TRAPPED___26 = 4,
    CLD_STOPPED___26 = 5,
    CLD_CONTINUED___26 = 6
} ;
enum __anonenum_111643124___26 {
    POLL_IN___26 = 1,
    POLL_OUT___26 = 2,
    POLL_MSG___26 = 3,
    POLL_ERR___26 = 4,
    POLL_PRI___26 = 5,
    POLL_HUP___26 = 6
} ;
enum __anonenum_852341087___26 {
    SIGEV_SIGNAL___26 = 0,
    SIGEV_NONE___26 = 1,
    SIGEV_THREAD___26 = 2,
    SIGEV_THREAD_ID___26 = 4
} ;
enum __anonenum_451154152___26 {
    REG_R8___26 = 0,
    REG_R9___26 = 1,
    REG_R10___26 = 2,
    REG_R11___26 = 3,
    REG_R12___26 = 4,
    REG_R13___26 = 5,
    REG_R14___26 = 6,
    REG_R15___26 = 7,
    REG_RDI___26 = 8,
    REG_RSI___26 = 9,
    REG_RBP___26 = 10,
    REG_RBX___26 = 11,
    REG_RDX___26 = 12,
    REG_RAX___26 = 13,
    REG_RCX___26 = 14,
    REG_RSP___26 = 15,
    REG_RIP___26 = 16,
    REG_EFL___26 = 17,
    REG_CSGSFS___26 = 18,
    REG_ERR___26 = 19,
    REG_TRAPNO___26 = 20,
    REG_OLDMASK___26 = 21,
    REG_CR2___26 = 22
} ;
enum __anonenum_437032235___26 {
    _PC_LINK_MAX___26 = 0,
    _PC_MAX_CANON___26 = 1,
    _PC_MAX_INPUT___26 = 2,
    _PC_NAME_MAX___26 = 3,
    _PC_PATH_MAX___26 = 4,
    _PC_PIPE_BUF___26 = 5,
    _PC_CHOWN_RESTRICTED___26 = 6,
    _PC_NO_TRUNC___26 = 7,
    _PC_VDISABLE___26 = 8,
    _PC_SYNC_IO___26 = 9,
    _PC_ASYNC_IO___26 = 10,
    _PC_PRIO_IO___26 = 11,
    _PC_SOCK_MAXBUF___26 = 12,
    _PC_FILESIZEBITS___26 = 13,
    _PC_REC_INCR_XFER_SIZE___26 = 14,
    _PC_REC_MAX_XFER_SIZE___26 = 15,
    _PC_REC_MIN_XFER_SIZE___26 = 16,
    _PC_REC_XFER_ALIGN___26 = 17,
    _PC_ALLOC_SIZE_MIN___26 = 18,
    _PC_SYMLINK_MAX___26 = 19,
    _PC_2_SYMLINKS___26 = 20
} ;
enum __anonenum_315186338___26 {
    _SC_ARG_MAX___26 = 0,
    _SC_CHILD_MAX___26 = 1,
    _SC_CLK_TCK___26 = 2,
    _SC_NGROUPS_MAX___26 = 3,
    _SC_OPEN_MAX___26 = 4,
    _SC_STREAM_MAX___26 = 5,
    _SC_TZNAME_MAX___26 = 6,
    _SC_JOB_CONTROL___26 = 7,
    _SC_SAVED_IDS___26 = 8,
    _SC_REALTIME_SIGNALS___26 = 9,
    _SC_PRIORITY_SCHEDULING___26 = 10,
    _SC_TIMERS___26 = 11,
    _SC_ASYNCHRONOUS_IO___26 = 12,
    _SC_PRIORITIZED_IO___26 = 13,
    _SC_SYNCHRONIZED_IO___26 = 14,
    _SC_FSYNC___26 = 15,
    _SC_MAPPED_FILES___26 = 16,
    _SC_MEMLOCK___26 = 17,
    _SC_MEMLOCK_RANGE___26 = 18,
    _SC_MEMORY_PROTECTION___26 = 19,
    _SC_MESSAGE_PASSING___26 = 20,
    _SC_SEMAPHORES___26 = 21,
    _SC_SHARED_MEMORY_OBJECTS___26 = 22,
    _SC_AIO_LISTIO_MAX___26 = 23,
    _SC_AIO_MAX___26 = 24,
    _SC_AIO_PRIO_DELTA_MAX___26 = 25,
    _SC_DELAYTIMER_MAX___26 = 26,
    _SC_MQ_OPEN_MAX___26 = 27,
    _SC_MQ_PRIO_MAX___26 = 28,
    _SC_VERSION___26 = 29,
    _SC_PAGESIZE___26 = 30,
    _SC_RTSIG_MAX___26 = 31,
    _SC_SEM_NSEMS_MAX___26 = 32,
    _SC_SEM_VALUE_MAX___26 = 33,
    _SC_SIGQUEUE_MAX___26 = 34,
    _SC_TIMER_MAX___26 = 35,
    _SC_BC_BASE_MAX___26 = 36,
    _SC_BC_DIM_MAX___26 = 37,
    _SC_BC_SCALE_MAX___26 = 38,
    _SC_BC_STRING_MAX___26 = 39,
    _SC_COLL_WEIGHTS_MAX___26 = 40,
    _SC_EQUIV_CLASS_MAX___26 = 41,
    _SC_EXPR_NEST_MAX___26 = 42,
    _SC_LINE_MAX___26 = 43,
    _SC_RE_DUP_MAX___26 = 44,
    _SC_CHARCLASS_NAME_MAX___26 = 45,
    _SC_2_VERSION___26 = 46,
    _SC_2_C_BIND___26 = 47,
    _SC_2_C_DEV___26 = 48,
    _SC_2_FORT_DEV___26 = 49,
    _SC_2_FORT_RUN___26 = 50,
    _SC_2_SW_DEV___26 = 51,
    _SC_2_LOCALEDEF___26 = 52,
    _SC_PII___26 = 53,
    _SC_PII_XTI___26 = 54,
    _SC_PII_SOCKET___26 = 55,
    _SC_PII_INTERNET___26 = 56,
    _SC_PII_OSI___26 = 57,
    _SC_POLL___26 = 58,
    _SC_SELECT___26 = 59,
    _SC_UIO_MAXIOV___26 = 60,
    _SC_IOV_MAX___26 = 60,
    _SC_PII_INTERNET_STREAM___26 = 61,
    _SC_PII_INTERNET_DGRAM___26 = 62,
    _SC_PII_OSI_COTS___26 = 63,
    _SC_PII_OSI_CLTS___26 = 64,
    _SC_PII_OSI_M___26 = 65,
    _SC_T_IOV_MAX___26 = 66,
    _SC_THREADS___26 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___26 = 68,
    _SC_GETGR_R_SIZE_MAX___26 = 69,
    _SC_GETPW_R_SIZE_MAX___26 = 70,
    _SC_LOGIN_NAME_MAX___26 = 71,
    _SC_TTY_NAME_MAX___26 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___26 = 73,
    _SC_THREAD_KEYS_MAX___26 = 74,
    _SC_THREAD_STACK_MIN___26 = 75,
    _SC_THREAD_THREADS_MAX___26 = 76,
    _SC_THREAD_ATTR_STACKADDR___26 = 77,
    _SC_THREAD_ATTR_STACKSIZE___26 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___26 = 79,
    _SC_THREAD_PRIO_INHERIT___26 = 80,
    _SC_THREAD_PRIO_PROTECT___26 = 81,
    _SC_THREAD_PROCESS_SHARED___26 = 82,
    _SC_NPROCESSORS_CONF___26 = 83,
    _SC_NPROCESSORS_ONLN___26 = 84,
    _SC_PHYS_PAGES___26 = 85,
    _SC_AVPHYS_PAGES___26 = 86,
    _SC_ATEXIT_MAX___26 = 87,
    _SC_PASS_MAX___26 = 88,
    _SC_XOPEN_VERSION___26 = 89,
    _SC_XOPEN_XCU_VERSION___26 = 90,
    _SC_XOPEN_UNIX___26 = 91,
    _SC_XOPEN_CRYPT___26 = 92,
    _SC_XOPEN_ENH_I18N___26 = 93,
    _SC_XOPEN_SHM___26 = 94,
    _SC_2_CHAR_TERM___26 = 95,
    _SC_2_C_VERSION___26 = 96,
    _SC_2_UPE___26 = 97,
    _SC_XOPEN_XPG2___26 = 98,
    _SC_XOPEN_XPG3___26 = 99,
    _SC_XOPEN_XPG4___26 = 100,
    _SC_CHAR_BIT___26 = 101,
    _SC_CHAR_MAX___26 = 102,
    _SC_CHAR_MIN___26 = 103,
    _SC_INT_MAX___26 = 104,
    _SC_INT_MIN___26 = 105,
    _SC_LONG_BIT___26 = 106,
    _SC_WORD_BIT___26 = 107,
    _SC_MB_LEN_MAX___26 = 108,
    _SC_NZERO___26 = 109,
    _SC_SSIZE_MAX___26 = 110,
    _SC_SCHAR_MAX___26 = 111,
    _SC_SCHAR_MIN___26 = 112,
    _SC_SHRT_MAX___26 = 113,
    _SC_SHRT_MIN___26 = 114,
    _SC_UCHAR_MAX___26 = 115,
    _SC_UINT_MAX___26 = 116,
    _SC_ULONG_MAX___26 = 117,
    _SC_USHRT_MAX___26 = 118,
    _SC_NL_ARGMAX___26 = 119,
    _SC_NL_LANGMAX___26 = 120,
    _SC_NL_MSGMAX___26 = 121,
    _SC_NL_NMAX___26 = 122,
    _SC_NL_SETMAX___26 = 123,
    _SC_NL_TEXTMAX___26 = 124,
    _SC_XBS5_ILP32_OFF32___26 = 125,
    _SC_XBS5_ILP32_OFFBIG___26 = 126,
    _SC_XBS5_LP64_OFF64___26 = 127,
    _SC_XBS5_LPBIG_OFFBIG___26 = 128,
    _SC_XOPEN_LEGACY___26 = 129,
    _SC_XOPEN_REALTIME___26 = 130,
    _SC_XOPEN_REALTIME_THREADS___26 = 131,
    _SC_ADVISORY_INFO___26 = 132,
    _SC_BARRIERS___26 = 133,
    _SC_BASE___26 = 134,
    _SC_C_LANG_SUPPORT___26 = 135,
    _SC_C_LANG_SUPPORT_R___26 = 136,
    _SC_CLOCK_SELECTION___26 = 137,
    _SC_CPUTIME___26 = 138,
    _SC_THREAD_CPUTIME___26 = 139,
    _SC_DEVICE_IO___26 = 140,
    _SC_DEVICE_SPECIFIC___26 = 141,
    _SC_DEVICE_SPECIFIC_R___26 = 142,
    _SC_FD_MGMT___26 = 143,
    _SC_FIFO___26 = 144,
    _SC_PIPE___26 = 145,
    _SC_FILE_ATTRIBUTES___26 = 146,
    _SC_FILE_LOCKING___26 = 147,
    _SC_FILE_SYSTEM___26 = 148,
    _SC_MONOTONIC_CLOCK___26 = 149,
    _SC_MULTI_PROCESS___26 = 150,
    _SC_SINGLE_PROCESS___26 = 151,
    _SC_NETWORKING___26 = 152,
    _SC_READER_WRITER_LOCKS___26 = 153,
    _SC_SPIN_LOCKS___26 = 154,
    _SC_REGEXP___26 = 155,
    _SC_REGEX_VERSION___26 = 156,
    _SC_SHELL___26 = 157,
    _SC_SIGNALS___26 = 158,
    _SC_SPAWN___26 = 159,
    _SC_SPORADIC_SERVER___26 = 160,
    _SC_THREAD_SPORADIC_SERVER___26 = 161,
    _SC_SYSTEM_DATABASE___26 = 162,
    _SC_SYSTEM_DATABASE_R___26 = 163,
    _SC_TIMEOUTS___26 = 164,
    _SC_TYPED_MEMORY_OBJECTS___26 = 165,
    _SC_USER_GROUPS___26 = 166,
    _SC_USER_GROUPS_R___26 = 167,
    _SC_2_PBS___26 = 168,
    _SC_2_PBS_ACCOUNTING___26 = 169,
    _SC_2_PBS_LOCATE___26 = 170,
    _SC_2_PBS_MESSAGE___26 = 171,
    _SC_2_PBS_TRACK___26 = 172,
    _SC_SYMLOOP_MAX___26 = 173,
    _SC_STREAMS___26 = 174,
    _SC_2_PBS_CHECKPOINT___26 = 175,
    _SC_V6_ILP32_OFF32___26 = 176,
    _SC_V6_ILP32_OFFBIG___26 = 177,
    _SC_V6_LP64_OFF64___26 = 178,
    _SC_V6_LPBIG_OFFBIG___26 = 179,
    _SC_HOST_NAME_MAX___26 = 180,
    _SC_TRACE___26 = 181,
    _SC_TRACE_EVENT_FILTER___26 = 182,
    _SC_TRACE_INHERIT___26 = 183,
    _SC_TRACE_LOG___26 = 184,
    _SC_LEVEL1_ICACHE_SIZE___26 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___26 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___26 = 187,
    _SC_LEVEL1_DCACHE_SIZE___26 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___26 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___26 = 190,
    _SC_LEVEL2_CACHE_SIZE___26 = 191,
    _SC_LEVEL2_CACHE_ASSOC___26 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___26 = 193,
    _SC_LEVEL3_CACHE_SIZE___26 = 194,
    _SC_LEVEL3_CACHE_ASSOC___26 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___26 = 196,
    _SC_LEVEL4_CACHE_SIZE___26 = 197,
    _SC_LEVEL4_CACHE_ASSOC___26 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___26 = 199,
    _SC_IPV6___26 = 235,
    _SC_RAW_SOCKETS___26 = 236,
    _SC_V7_ILP32_OFF32___26 = 237,
    _SC_V7_ILP32_OFFBIG___26 = 238,
    _SC_V7_LP64_OFF64___26 = 239,
    _SC_V7_LPBIG_OFFBIG___26 = 240,
    _SC_SS_REPL_MAX___26 = 241,
    _SC_TRACE_EVENT_NAME_MAX___26 = 242,
    _SC_TRACE_NAME_MAX___26 = 243,
    _SC_TRACE_SYS_MAX___26 = 244,
    _SC_TRACE_USER_EVENT_MAX___26 = 245,
    _SC_XOPEN_STREAMS___26 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___26 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___26 = 248,
    _SC_MINSIGSTKSZ___26 = 249,
    _SC_SIGSTKSZ___26 = 250
} ;
enum __anonenum_875524036___26 {
    _CS_PATH___26 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___26 = 1,
    _CS_GNU_LIBC_VERSION___26 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___26 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___26 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___26 = 5,
    _CS_LFS_CFLAGS___26 = 1000,
    _CS_LFS_LDFLAGS___26 = 1001,
    _CS_LFS_LIBS___26 = 1002,
    _CS_LFS_LINTFLAGS___26 = 1003,
    _CS_LFS64_CFLAGS___26 = 1004,
    _CS_LFS64_LDFLAGS___26 = 1005,
    _CS_LFS64_LIBS___26 = 1006,
    _CS_LFS64_LINTFLAGS___26 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___26 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___26 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___26 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___26 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___26 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___26 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___26 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___26 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___26 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___26 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___26 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___26 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___26 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___26 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___26 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___26 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___26 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___26 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___26 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___26 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___26 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___26 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___26 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___26 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___26 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___26 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___26 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___26 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___26 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___26 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___26 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___26 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___26 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___26 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___26 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___26 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___26 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___26 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___26 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___26 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___26 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___26 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___26 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___26 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___26 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___26 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___26 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___26 = 1147,
    _CS_V6_ENV___26 = 1148,
    _CS_V7_ENV___26 = 1149
} ;
enum __anonenum_57186863___26 {
    SS_ONSTACK___26 = 1,
    SS_DISABLE___26 = 2
} ;
struct request_length {
   uint16_t command ;
   uint16_t padding ;
};
enum __anonenum_83571709___27 {
    MSG_OOB___27 = 1,
    MSG_PEEK___27 = 2,
    MSG_DONTROUTE___27 = 4,
    MSG_TRYHARD___27 = 4,
    MSG_CTRUNC___27 = 8,
    MSG_PROXY___27 = 16,
    MSG_TRUNC___27 = 32,
    MSG_DONTWAIT___27 = 64,
    MSG_EOR___27 = 128,
    MSG_WAITALL___27 = 256,
    MSG_FIN___27 = 512,
    MSG_SYN___27 = 1024,
    MSG_CONFIRM___27 = 2048,
    MSG_RST___27 = 4096,
    MSG_ERRQUEUE___27 = 8192,
    MSG_NOSIGNAL___27 = 16384,
    MSG_MORE___27 = 32768,
    MSG_WAITFORONE___27 = 65536,
    MSG_BATCH___27 = 262144,
    MSG_ZEROCOPY___27 = 67108864,
    MSG_FASTOPEN___27 = 536870912,
    MSG_CMSG_CLOEXEC___27 = 1073741824
} ;
enum __anonenum_617082774___27 {
    SCM_RIGHTS___27 = 1,
    SCM_CREDENTIALS___27 = 2
} ;
enum __anonenum_606441560___27 {
    SHUT_RD___27 = 0,
    SHUT_WR___27 = 1,
    SHUT_RDWR___27 = 2
} ;
enum __anonenum_264779956___27 {
    IPPROTO_IP___27 = 0,
    IPPROTO_ICMP___27 = 1,
    IPPROTO_IGMP___27 = 2,
    IPPROTO_IPIP___27 = 4,
    IPPROTO_TCP___27 = 6,
    IPPROTO_EGP___27 = 8,
    IPPROTO_PUP___27 = 12,
    IPPROTO_UDP___27 = 17,
    IPPROTO_IDP___27 = 22,
    IPPROTO_TP___27 = 29,
    IPPROTO_DCCP___27 = 33,
    IPPROTO_IPV6___27 = 41,
    IPPROTO_RSVP___27 = 46,
    IPPROTO_GRE___27 = 47,
    IPPROTO_ESP___27 = 50,
    IPPROTO_AH___27 = 51,
    IPPROTO_MTP___27 = 92,
    IPPROTO_BEETPH___27 = 94,
    IPPROTO_ENCAP___27 = 98,
    IPPROTO_PIM___27 = 103,
    IPPROTO_COMP___27 = 108,
    IPPROTO_SCTP___27 = 132,
    IPPROTO_UDPLITE___27 = 136,
    IPPROTO_MPLS___27 = 137,
    IPPROTO_ETHERNET___27 = 143,
    IPPROTO_RAW___27 = 255,
    IPPROTO_MPTCP___27 = 262,
    IPPROTO_MAX___27 = 263
} ;
enum __anonenum_218739988___27 {
    IPPROTO_HOPOPTS___27 = 0,
    IPPROTO_ROUTING___27 = 43,
    IPPROTO_FRAGMENT___27 = 44,
    IPPROTO_ICMPV6___27 = 58,
    IPPROTO_NONE___27 = 59,
    IPPROTO_DSTOPTS___27 = 60,
    IPPROTO_MH___27 = 135
} ;
enum __anonenum_662268580___27 {
    IPPORT_ECHO___27 = 7,
    IPPORT_DISCARD___27 = 9,
    IPPORT_SYSTAT___27 = 11,
    IPPORT_DAYTIME___27 = 13,
    IPPORT_NETSTAT___27 = 15,
    IPPORT_FTP___27 = 21,
    IPPORT_TELNET___27 = 23,
    IPPORT_SMTP___27 = 25,
    IPPORT_TIMESERVER___27 = 37,
    IPPORT_NAMESERVER___27 = 42,
    IPPORT_WHOIS___27 = 43,
    IPPORT_MTP___27 = 57,
    IPPORT_TFTP___27 = 69,
    IPPORT_RJE___27 = 77,
    IPPORT_FINGER___27 = 79,
    IPPORT_TTYLINK___27 = 87,
    IPPORT_SUPDUP___27 = 95,
    IPPORT_EXECSERVER___27 = 512,
    IPPORT_LOGINSERVER___27 = 513,
    IPPORT_CMDSERVER___27 = 514,
    IPPORT_EFSSERVER___27 = 520,
    IPPORT_BIFFUDP___27 = 512,
    IPPORT_WHOSERVER___27 = 513,
    IPPORT_ROUTESERVER___27 = 520,
    IPPORT_RESERVED___27 = 1024,
    IPPORT_USERRESERVED___27 = 5000
} ;
enum __anonenum_18926444___27 {
    _ISupper___27 = 256,
    _ISlower___27 = 512,
    _ISalpha___27 = 1024,
    _ISdigit___27 = 2048,
    _ISxdigit___27 = 4096,
    _ISspace___27 = 8192,
    _ISprint___27 = 16384,
    _ISgraph___27 = 32768,
    _ISblank___27 = 1,
    _IScntrl___27 = 2,
    _ISpunct___27 = 4,
    _ISalnum___27 = 8
} ;
enum __anonenum_913965969___27 {
    FP_INT_UPWARD___27 = 0,
    FP_INT_DOWNWARD___27 = 1,
    FP_INT_TOWARDZERO___27 = 2,
    FP_INT_TONEARESTFROMZERO___27 = 3,
    FP_INT_TONEAREST___27 = 4
} ;
enum __anonenum_1037408945___27 {
    FP_NAN___27 = 0,
    FP_INFINITE___27 = 1,
    FP_ZERO___27 = 2,
    FP_SUBNORMAL___27 = 3,
    FP_NORMAL___27 = 4
} ;
enum __anonenum_556971655___27 {
    SI_ASYNCNL___27 = -60,
    SI_DETHREAD___27 = -7,
    SI_TKILL___27 = -6,
    SI_SIGIO___27 = -5,
    SI_ASYNCIO___27 = -4,
    SI_MESGQ___27 = -3,
    SI_TIMER___27 = -2,
    SI_QUEUE___27 = -1,
    SI_USER___27 = 0,
    SI_KERNEL___27 = 128
} ;
enum __anonenum_640648963___27 {
    ILL_ILLOPC___27 = 1,
    ILL_ILLOPN___27 = 2,
    ILL_ILLADR___27 = 3,
    ILL_ILLTRP___27 = 4,
    ILL_PRVOPC___27 = 5,
    ILL_PRVREG___27 = 6,
    ILL_COPROC___27 = 7,
    ILL_BADSTK___27 = 8,
    ILL_BADIADDR___27 = 9
} ;
enum __anonenum_457704180___27 {
    FPE_INTDIV___27 = 1,
    FPE_INTOVF___27 = 2,
    FPE_FLTDIV___27 = 3,
    FPE_FLTOVF___27 = 4,
    FPE_FLTUND___27 = 5,
    FPE_FLTRES___27 = 6,
    FPE_FLTINV___27 = 7,
    FPE_FLTSUB___27 = 8,
    FPE_FLTUNK___27 = 14,
    FPE_CONDTRAP___27 = 15
} ;
enum __anonenum_180375148___27 {
    SEGV_MAPERR___27 = 1,
    SEGV_ACCERR___27 = 2,
    SEGV_BNDERR___27 = 3,
    SEGV_PKUERR___27 = 4,
    SEGV_ACCADI___27 = 5,
    SEGV_ADIDERR___27 = 6,
    SEGV_ADIPERR___27 = 7,
    SEGV_MTEAERR___27 = 8,
    SEGV_MTESERR___27 = 9
} ;
enum __anonenum_1036286214___27 {
    BUS_ADRALN___27 = 1,
    BUS_ADRERR___27 = 2,
    BUS_OBJERR___27 = 3,
    BUS_MCEERR_AR___27 = 4,
    BUS_MCEERR_AO___27 = 5
} ;
enum __anonenum_91015150___27 {
    TRAP_BRKPT___27 = 1,
    TRAP_TRACE___27 = 2,
    TRAP_BRANCH___27 = 3,
    TRAP_HWBKPT___27 = 4,
    TRAP_UNK___27 = 5
} ;
enum __anonenum_23175539___27 {
    CLD_EXITED___27 = 1,
    CLD_KILLED___27 = 2,
    CLD_DUMPED___27 = 3,
    CLD_TRAPPED___27 = 4,
    CLD_STOPPED___27 = 5,
    CLD_CONTINUED___27 = 6
} ;
enum __anonenum_111643124___27 {
    POLL_IN___27 = 1,
    POLL_OUT___27 = 2,
    POLL_MSG___27 = 3,
    POLL_ERR___27 = 4,
    POLL_PRI___27 = 5,
    POLL_HUP___27 = 6
} ;
enum __anonenum_852341087___27 {
    SIGEV_SIGNAL___27 = 0,
    SIGEV_NONE___27 = 1,
    SIGEV_THREAD___27 = 2,
    SIGEV_THREAD_ID___27 = 4
} ;
enum __anonenum_451154152___27 {
    REG_R8___27 = 0,
    REG_R9___27 = 1,
    REG_R10___27 = 2,
    REG_R11___27 = 3,
    REG_R12___27 = 4,
    REG_R13___27 = 5,
    REG_R14___27 = 6,
    REG_R15___27 = 7,
    REG_RDI___27 = 8,
    REG_RSI___27 = 9,
    REG_RBP___27 = 10,
    REG_RBX___27 = 11,
    REG_RDX___27 = 12,
    REG_RAX___27 = 13,
    REG_RCX___27 = 14,
    REG_RSP___27 = 15,
    REG_RIP___27 = 16,
    REG_EFL___27 = 17,
    REG_CSGSFS___27 = 18,
    REG_ERR___27 = 19,
    REG_TRAPNO___27 = 20,
    REG_OLDMASK___27 = 21,
    REG_CR2___27 = 22
} ;
enum __anonenum_437032235___27 {
    _PC_LINK_MAX___27 = 0,
    _PC_MAX_CANON___27 = 1,
    _PC_MAX_INPUT___27 = 2,
    _PC_NAME_MAX___27 = 3,
    _PC_PATH_MAX___27 = 4,
    _PC_PIPE_BUF___27 = 5,
    _PC_CHOWN_RESTRICTED___27 = 6,
    _PC_NO_TRUNC___27 = 7,
    _PC_VDISABLE___27 = 8,
    _PC_SYNC_IO___27 = 9,
    _PC_ASYNC_IO___27 = 10,
    _PC_PRIO_IO___27 = 11,
    _PC_SOCK_MAXBUF___27 = 12,
    _PC_FILESIZEBITS___27 = 13,
    _PC_REC_INCR_XFER_SIZE___27 = 14,
    _PC_REC_MAX_XFER_SIZE___27 = 15,
    _PC_REC_MIN_XFER_SIZE___27 = 16,
    _PC_REC_XFER_ALIGN___27 = 17,
    _PC_ALLOC_SIZE_MIN___27 = 18,
    _PC_SYMLINK_MAX___27 = 19,
    _PC_2_SYMLINKS___27 = 20
} ;
enum __anonenum_315186338___27 {
    _SC_ARG_MAX___27 = 0,
    _SC_CHILD_MAX___27 = 1,
    _SC_CLK_TCK___27 = 2,
    _SC_NGROUPS_MAX___27 = 3,
    _SC_OPEN_MAX___27 = 4,
    _SC_STREAM_MAX___27 = 5,
    _SC_TZNAME_MAX___27 = 6,
    _SC_JOB_CONTROL___27 = 7,
    _SC_SAVED_IDS___27 = 8,
    _SC_REALTIME_SIGNALS___27 = 9,
    _SC_PRIORITY_SCHEDULING___27 = 10,
    _SC_TIMERS___27 = 11,
    _SC_ASYNCHRONOUS_IO___27 = 12,
    _SC_PRIORITIZED_IO___27 = 13,
    _SC_SYNCHRONIZED_IO___27 = 14,
    _SC_FSYNC___27 = 15,
    _SC_MAPPED_FILES___27 = 16,
    _SC_MEMLOCK___27 = 17,
    _SC_MEMLOCK_RANGE___27 = 18,
    _SC_MEMORY_PROTECTION___27 = 19,
    _SC_MESSAGE_PASSING___27 = 20,
    _SC_SEMAPHORES___27 = 21,
    _SC_SHARED_MEMORY_OBJECTS___27 = 22,
    _SC_AIO_LISTIO_MAX___27 = 23,
    _SC_AIO_MAX___27 = 24,
    _SC_AIO_PRIO_DELTA_MAX___27 = 25,
    _SC_DELAYTIMER_MAX___27 = 26,
    _SC_MQ_OPEN_MAX___27 = 27,
    _SC_MQ_PRIO_MAX___27 = 28,
    _SC_VERSION___27 = 29,
    _SC_PAGESIZE___27 = 30,
    _SC_RTSIG_MAX___27 = 31,
    _SC_SEM_NSEMS_MAX___27 = 32,
    _SC_SEM_VALUE_MAX___27 = 33,
    _SC_SIGQUEUE_MAX___27 = 34,
    _SC_TIMER_MAX___27 = 35,
    _SC_BC_BASE_MAX___27 = 36,
    _SC_BC_DIM_MAX___27 = 37,
    _SC_BC_SCALE_MAX___27 = 38,
    _SC_BC_STRING_MAX___27 = 39,
    _SC_COLL_WEIGHTS_MAX___27 = 40,
    _SC_EQUIV_CLASS_MAX___27 = 41,
    _SC_EXPR_NEST_MAX___27 = 42,
    _SC_LINE_MAX___27 = 43,
    _SC_RE_DUP_MAX___27 = 44,
    _SC_CHARCLASS_NAME_MAX___27 = 45,
    _SC_2_VERSION___27 = 46,
    _SC_2_C_BIND___27 = 47,
    _SC_2_C_DEV___27 = 48,
    _SC_2_FORT_DEV___27 = 49,
    _SC_2_FORT_RUN___27 = 50,
    _SC_2_SW_DEV___27 = 51,
    _SC_2_LOCALEDEF___27 = 52,
    _SC_PII___27 = 53,
    _SC_PII_XTI___27 = 54,
    _SC_PII_SOCKET___27 = 55,
    _SC_PII_INTERNET___27 = 56,
    _SC_PII_OSI___27 = 57,
    _SC_POLL___27 = 58,
    _SC_SELECT___27 = 59,
    _SC_UIO_MAXIOV___27 = 60,
    _SC_IOV_MAX___27 = 60,
    _SC_PII_INTERNET_STREAM___27 = 61,
    _SC_PII_INTERNET_DGRAM___27 = 62,
    _SC_PII_OSI_COTS___27 = 63,
    _SC_PII_OSI_CLTS___27 = 64,
    _SC_PII_OSI_M___27 = 65,
    _SC_T_IOV_MAX___27 = 66,
    _SC_THREADS___27 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___27 = 68,
    _SC_GETGR_R_SIZE_MAX___27 = 69,
    _SC_GETPW_R_SIZE_MAX___27 = 70,
    _SC_LOGIN_NAME_MAX___27 = 71,
    _SC_TTY_NAME_MAX___27 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___27 = 73,
    _SC_THREAD_KEYS_MAX___27 = 74,
    _SC_THREAD_STACK_MIN___27 = 75,
    _SC_THREAD_THREADS_MAX___27 = 76,
    _SC_THREAD_ATTR_STACKADDR___27 = 77,
    _SC_THREAD_ATTR_STACKSIZE___27 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___27 = 79,
    _SC_THREAD_PRIO_INHERIT___27 = 80,
    _SC_THREAD_PRIO_PROTECT___27 = 81,
    _SC_THREAD_PROCESS_SHARED___27 = 82,
    _SC_NPROCESSORS_CONF___27 = 83,
    _SC_NPROCESSORS_ONLN___27 = 84,
    _SC_PHYS_PAGES___27 = 85,
    _SC_AVPHYS_PAGES___27 = 86,
    _SC_ATEXIT_MAX___27 = 87,
    _SC_PASS_MAX___27 = 88,
    _SC_XOPEN_VERSION___27 = 89,
    _SC_XOPEN_XCU_VERSION___27 = 90,
    _SC_XOPEN_UNIX___27 = 91,
    _SC_XOPEN_CRYPT___27 = 92,
    _SC_XOPEN_ENH_I18N___27 = 93,
    _SC_XOPEN_SHM___27 = 94,
    _SC_2_CHAR_TERM___27 = 95,
    _SC_2_C_VERSION___27 = 96,
    _SC_2_UPE___27 = 97,
    _SC_XOPEN_XPG2___27 = 98,
    _SC_XOPEN_XPG3___27 = 99,
    _SC_XOPEN_XPG4___27 = 100,
    _SC_CHAR_BIT___27 = 101,
    _SC_CHAR_MAX___27 = 102,
    _SC_CHAR_MIN___27 = 103,
    _SC_INT_MAX___27 = 104,
    _SC_INT_MIN___27 = 105,
    _SC_LONG_BIT___27 = 106,
    _SC_WORD_BIT___27 = 107,
    _SC_MB_LEN_MAX___27 = 108,
    _SC_NZERO___27 = 109,
    _SC_SSIZE_MAX___27 = 110,
    _SC_SCHAR_MAX___27 = 111,
    _SC_SCHAR_MIN___27 = 112,
    _SC_SHRT_MAX___27 = 113,
    _SC_SHRT_MIN___27 = 114,
    _SC_UCHAR_MAX___27 = 115,
    _SC_UINT_MAX___27 = 116,
    _SC_ULONG_MAX___27 = 117,
    _SC_USHRT_MAX___27 = 118,
    _SC_NL_ARGMAX___27 = 119,
    _SC_NL_LANGMAX___27 = 120,
    _SC_NL_MSGMAX___27 = 121,
    _SC_NL_NMAX___27 = 122,
    _SC_NL_SETMAX___27 = 123,
    _SC_NL_TEXTMAX___27 = 124,
    _SC_XBS5_ILP32_OFF32___27 = 125,
    _SC_XBS5_ILP32_OFFBIG___27 = 126,
    _SC_XBS5_LP64_OFF64___27 = 127,
    _SC_XBS5_LPBIG_OFFBIG___27 = 128,
    _SC_XOPEN_LEGACY___27 = 129,
    _SC_XOPEN_REALTIME___27 = 130,
    _SC_XOPEN_REALTIME_THREADS___27 = 131,
    _SC_ADVISORY_INFO___27 = 132,
    _SC_BARRIERS___27 = 133,
    _SC_BASE___27 = 134,
    _SC_C_LANG_SUPPORT___27 = 135,
    _SC_C_LANG_SUPPORT_R___27 = 136,
    _SC_CLOCK_SELECTION___27 = 137,
    _SC_CPUTIME___27 = 138,
    _SC_THREAD_CPUTIME___27 = 139,
    _SC_DEVICE_IO___27 = 140,
    _SC_DEVICE_SPECIFIC___27 = 141,
    _SC_DEVICE_SPECIFIC_R___27 = 142,
    _SC_FD_MGMT___27 = 143,
    _SC_FIFO___27 = 144,
    _SC_PIPE___27 = 145,
    _SC_FILE_ATTRIBUTES___27 = 146,
    _SC_FILE_LOCKING___27 = 147,
    _SC_FILE_SYSTEM___27 = 148,
    _SC_MONOTONIC_CLOCK___27 = 149,
    _SC_MULTI_PROCESS___27 = 150,
    _SC_SINGLE_PROCESS___27 = 151,
    _SC_NETWORKING___27 = 152,
    _SC_READER_WRITER_LOCKS___27 = 153,
    _SC_SPIN_LOCKS___27 = 154,
    _SC_REGEXP___27 = 155,
    _SC_REGEX_VERSION___27 = 156,
    _SC_SHELL___27 = 157,
    _SC_SIGNALS___27 = 158,
    _SC_SPAWN___27 = 159,
    _SC_SPORADIC_SERVER___27 = 160,
    _SC_THREAD_SPORADIC_SERVER___27 = 161,
    _SC_SYSTEM_DATABASE___27 = 162,
    _SC_SYSTEM_DATABASE_R___27 = 163,
    _SC_TIMEOUTS___27 = 164,
    _SC_TYPED_MEMORY_OBJECTS___27 = 165,
    _SC_USER_GROUPS___27 = 166,
    _SC_USER_GROUPS_R___27 = 167,
    _SC_2_PBS___27 = 168,
    _SC_2_PBS_ACCOUNTING___27 = 169,
    _SC_2_PBS_LOCATE___27 = 170,
    _SC_2_PBS_MESSAGE___27 = 171,
    _SC_2_PBS_TRACK___27 = 172,
    _SC_SYMLOOP_MAX___27 = 173,
    _SC_STREAMS___27 = 174,
    _SC_2_PBS_CHECKPOINT___27 = 175,
    _SC_V6_ILP32_OFF32___27 = 176,
    _SC_V6_ILP32_OFFBIG___27 = 177,
    _SC_V6_LP64_OFF64___27 = 178,
    _SC_V6_LPBIG_OFFBIG___27 = 179,
    _SC_HOST_NAME_MAX___27 = 180,
    _SC_TRACE___27 = 181,
    _SC_TRACE_EVENT_FILTER___27 = 182,
    _SC_TRACE_INHERIT___27 = 183,
    _SC_TRACE_LOG___27 = 184,
    _SC_LEVEL1_ICACHE_SIZE___27 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___27 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___27 = 187,
    _SC_LEVEL1_DCACHE_SIZE___27 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___27 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___27 = 190,
    _SC_LEVEL2_CACHE_SIZE___27 = 191,
    _SC_LEVEL2_CACHE_ASSOC___27 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___27 = 193,
    _SC_LEVEL3_CACHE_SIZE___27 = 194,
    _SC_LEVEL3_CACHE_ASSOC___27 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___27 = 196,
    _SC_LEVEL4_CACHE_SIZE___27 = 197,
    _SC_LEVEL4_CACHE_ASSOC___27 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___27 = 199,
    _SC_IPV6___27 = 235,
    _SC_RAW_SOCKETS___27 = 236,
    _SC_V7_ILP32_OFF32___27 = 237,
    _SC_V7_ILP32_OFFBIG___27 = 238,
    _SC_V7_LP64_OFF64___27 = 239,
    _SC_V7_LPBIG_OFFBIG___27 = 240,
    _SC_SS_REPL_MAX___27 = 241,
    _SC_TRACE_EVENT_NAME_MAX___27 = 242,
    _SC_TRACE_NAME_MAX___27 = 243,
    _SC_TRACE_SYS_MAX___27 = 244,
    _SC_TRACE_USER_EVENT_MAX___27 = 245,
    _SC_XOPEN_STREAMS___27 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___27 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___27 = 248,
    _SC_MINSIGSTKSZ___27 = 249,
    _SC_SIGSTKSZ___27 = 250
} ;
enum __anonenum_875524036___27 {
    _CS_PATH___27 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___27 = 1,
    _CS_GNU_LIBC_VERSION___27 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___27 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___27 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___27 = 5,
    _CS_LFS_CFLAGS___27 = 1000,
    _CS_LFS_LDFLAGS___27 = 1001,
    _CS_LFS_LIBS___27 = 1002,
    _CS_LFS_LINTFLAGS___27 = 1003,
    _CS_LFS64_CFLAGS___27 = 1004,
    _CS_LFS64_LDFLAGS___27 = 1005,
    _CS_LFS64_LIBS___27 = 1006,
    _CS_LFS64_LINTFLAGS___27 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___27 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___27 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___27 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___27 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___27 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___27 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___27 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___27 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___27 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___27 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___27 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___27 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___27 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___27 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___27 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___27 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___27 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___27 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___27 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___27 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___27 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___27 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___27 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___27 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___27 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___27 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___27 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___27 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___27 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___27 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___27 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___27 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___27 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___27 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___27 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___27 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___27 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___27 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___27 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___27 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___27 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___27 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___27 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___27 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___27 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___27 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___27 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___27 = 1147,
    _CS_V6_ENV___27 = 1148,
    _CS_V7_ENV___27 = 1149
} ;
enum __anonenum_57186863___27 {
    SS_ONSTACK___27 = 1,
    SS_DISABLE___27 = 2
} ;
struct NAU_Instance_Record ;
typedef struct NAU_Instance_Record *NAU_Instance;
struct NAU_Instance_Record {
   NTP_AuthMode mode ;
   uint32_t key_id ;
   NNC_Instance nts ;
};
enum __anonenum_83571709___28 {
    MSG_OOB___28 = 1,
    MSG_PEEK___28 = 2,
    MSG_DONTROUTE___28 = 4,
    MSG_TRYHARD___28 = 4,
    MSG_CTRUNC___28 = 8,
    MSG_PROXY___28 = 16,
    MSG_TRUNC___28 = 32,
    MSG_DONTWAIT___28 = 64,
    MSG_EOR___28 = 128,
    MSG_WAITALL___28 = 256,
    MSG_FIN___28 = 512,
    MSG_SYN___28 = 1024,
    MSG_CONFIRM___28 = 2048,
    MSG_RST___28 = 4096,
    MSG_ERRQUEUE___28 = 8192,
    MSG_NOSIGNAL___28 = 16384,
    MSG_MORE___28 = 32768,
    MSG_WAITFORONE___28 = 65536,
    MSG_BATCH___28 = 262144,
    MSG_ZEROCOPY___28 = 67108864,
    MSG_FASTOPEN___28 = 536870912,
    MSG_CMSG_CLOEXEC___28 = 1073741824
} ;
enum __anonenum_617082774___28 {
    SCM_RIGHTS___28 = 1,
    SCM_CREDENTIALS___28 = 2
} ;
enum __anonenum_606441560___28 {
    SHUT_RD___28 = 0,
    SHUT_WR___28 = 1,
    SHUT_RDWR___28 = 2
} ;
enum __anonenum_264779956___28 {
    IPPROTO_IP___28 = 0,
    IPPROTO_ICMP___28 = 1,
    IPPROTO_IGMP___28 = 2,
    IPPROTO_IPIP___28 = 4,
    IPPROTO_TCP___28 = 6,
    IPPROTO_EGP___28 = 8,
    IPPROTO_PUP___28 = 12,
    IPPROTO_UDP___28 = 17,
    IPPROTO_IDP___28 = 22,
    IPPROTO_TP___28 = 29,
    IPPROTO_DCCP___28 = 33,
    IPPROTO_IPV6___28 = 41,
    IPPROTO_RSVP___28 = 46,
    IPPROTO_GRE___28 = 47,
    IPPROTO_ESP___28 = 50,
    IPPROTO_AH___28 = 51,
    IPPROTO_MTP___28 = 92,
    IPPROTO_BEETPH___28 = 94,
    IPPROTO_ENCAP___28 = 98,
    IPPROTO_PIM___28 = 103,
    IPPROTO_COMP___28 = 108,
    IPPROTO_SCTP___28 = 132,
    IPPROTO_UDPLITE___28 = 136,
    IPPROTO_MPLS___28 = 137,
    IPPROTO_ETHERNET___28 = 143,
    IPPROTO_RAW___28 = 255,
    IPPROTO_MPTCP___28 = 262,
    IPPROTO_MAX___28 = 263
} ;
enum __anonenum_218739988___28 {
    IPPROTO_HOPOPTS___28 = 0,
    IPPROTO_ROUTING___28 = 43,
    IPPROTO_FRAGMENT___28 = 44,
    IPPROTO_ICMPV6___28 = 58,
    IPPROTO_NONE___28 = 59,
    IPPROTO_DSTOPTS___28 = 60,
    IPPROTO_MH___28 = 135
} ;
enum __anonenum_662268580___28 {
    IPPORT_ECHO___28 = 7,
    IPPORT_DISCARD___28 = 9,
    IPPORT_SYSTAT___28 = 11,
    IPPORT_DAYTIME___28 = 13,
    IPPORT_NETSTAT___28 = 15,
    IPPORT_FTP___28 = 21,
    IPPORT_TELNET___28 = 23,
    IPPORT_SMTP___28 = 25,
    IPPORT_TIMESERVER___28 = 37,
    IPPORT_NAMESERVER___28 = 42,
    IPPORT_WHOIS___28 = 43,
    IPPORT_MTP___28 = 57,
    IPPORT_TFTP___28 = 69,
    IPPORT_RJE___28 = 77,
    IPPORT_FINGER___28 = 79,
    IPPORT_TTYLINK___28 = 87,
    IPPORT_SUPDUP___28 = 95,
    IPPORT_EXECSERVER___28 = 512,
    IPPORT_LOGINSERVER___28 = 513,
    IPPORT_CMDSERVER___28 = 514,
    IPPORT_EFSSERVER___28 = 520,
    IPPORT_BIFFUDP___28 = 512,
    IPPORT_WHOSERVER___28 = 513,
    IPPORT_ROUTESERVER___28 = 520,
    IPPORT_RESERVED___28 = 1024,
    IPPORT_USERRESERVED___28 = 5000
} ;
enum __anonenum_18926444___28 {
    _ISupper___28 = 256,
    _ISlower___28 = 512,
    _ISalpha___28 = 1024,
    _ISdigit___28 = 2048,
    _ISxdigit___28 = 4096,
    _ISspace___28 = 8192,
    _ISprint___28 = 16384,
    _ISgraph___28 = 32768,
    _ISblank___28 = 1,
    _IScntrl___28 = 2,
    _ISpunct___28 = 4,
    _ISalnum___28 = 8
} ;
enum __anonenum_913965969___28 {
    FP_INT_UPWARD___28 = 0,
    FP_INT_DOWNWARD___28 = 1,
    FP_INT_TOWARDZERO___28 = 2,
    FP_INT_TONEARESTFROMZERO___28 = 3,
    FP_INT_TONEAREST___28 = 4
} ;
enum __anonenum_1037408945___28 {
    FP_NAN___28 = 0,
    FP_INFINITE___28 = 1,
    FP_ZERO___28 = 2,
    FP_SUBNORMAL___28 = 3,
    FP_NORMAL___28 = 4
} ;
enum __anonenum_556971655___28 {
    SI_ASYNCNL___28 = -60,
    SI_DETHREAD___28 = -7,
    SI_TKILL___28 = -6,
    SI_SIGIO___28 = -5,
    SI_ASYNCIO___28 = -4,
    SI_MESGQ___28 = -3,
    SI_TIMER___28 = -2,
    SI_QUEUE___28 = -1,
    SI_USER___28 = 0,
    SI_KERNEL___28 = 128
} ;
enum __anonenum_640648963___28 {
    ILL_ILLOPC___28 = 1,
    ILL_ILLOPN___28 = 2,
    ILL_ILLADR___28 = 3,
    ILL_ILLTRP___28 = 4,
    ILL_PRVOPC___28 = 5,
    ILL_PRVREG___28 = 6,
    ILL_COPROC___28 = 7,
    ILL_BADSTK___28 = 8,
    ILL_BADIADDR___28 = 9
} ;
enum __anonenum_457704180___28 {
    FPE_INTDIV___28 = 1,
    FPE_INTOVF___28 = 2,
    FPE_FLTDIV___28 = 3,
    FPE_FLTOVF___28 = 4,
    FPE_FLTUND___28 = 5,
    FPE_FLTRES___28 = 6,
    FPE_FLTINV___28 = 7,
    FPE_FLTSUB___28 = 8,
    FPE_FLTUNK___28 = 14,
    FPE_CONDTRAP___28 = 15
} ;
enum __anonenum_180375148___28 {
    SEGV_MAPERR___28 = 1,
    SEGV_ACCERR___28 = 2,
    SEGV_BNDERR___28 = 3,
    SEGV_PKUERR___28 = 4,
    SEGV_ACCADI___28 = 5,
    SEGV_ADIDERR___28 = 6,
    SEGV_ADIPERR___28 = 7,
    SEGV_MTEAERR___28 = 8,
    SEGV_MTESERR___28 = 9
} ;
enum __anonenum_1036286214___28 {
    BUS_ADRALN___28 = 1,
    BUS_ADRERR___28 = 2,
    BUS_OBJERR___28 = 3,
    BUS_MCEERR_AR___28 = 4,
    BUS_MCEERR_AO___28 = 5
} ;
enum __anonenum_91015150___28 {
    TRAP_BRKPT___28 = 1,
    TRAP_TRACE___28 = 2,
    TRAP_BRANCH___28 = 3,
    TRAP_HWBKPT___28 = 4,
    TRAP_UNK___28 = 5
} ;
enum __anonenum_23175539___28 {
    CLD_EXITED___28 = 1,
    CLD_KILLED___28 = 2,
    CLD_DUMPED___28 = 3,
    CLD_TRAPPED___28 = 4,
    CLD_STOPPED___28 = 5,
    CLD_CONTINUED___28 = 6
} ;
enum __anonenum_111643124___28 {
    POLL_IN___28 = 1,
    POLL_OUT___28 = 2,
    POLL_MSG___28 = 3,
    POLL_ERR___28 = 4,
    POLL_PRI___28 = 5,
    POLL_HUP___28 = 6
} ;
enum __anonenum_852341087___28 {
    SIGEV_SIGNAL___28 = 0,
    SIGEV_NONE___28 = 1,
    SIGEV_THREAD___28 = 2,
    SIGEV_THREAD_ID___28 = 4
} ;
enum __anonenum_451154152___28 {
    REG_R8___28 = 0,
    REG_R9___28 = 1,
    REG_R10___28 = 2,
    REG_R11___28 = 3,
    REG_R12___28 = 4,
    REG_R13___28 = 5,
    REG_R14___28 = 6,
    REG_R15___28 = 7,
    REG_RDI___28 = 8,
    REG_RSI___28 = 9,
    REG_RBP___28 = 10,
    REG_RBX___28 = 11,
    REG_RDX___28 = 12,
    REG_RAX___28 = 13,
    REG_RCX___28 = 14,
    REG_RSP___28 = 15,
    REG_RIP___28 = 16,
    REG_EFL___28 = 17,
    REG_CSGSFS___28 = 18,
    REG_ERR___28 = 19,
    REG_TRAPNO___28 = 20,
    REG_OLDMASK___28 = 21,
    REG_CR2___28 = 22
} ;
enum __anonenum_437032235___28 {
    _PC_LINK_MAX___28 = 0,
    _PC_MAX_CANON___28 = 1,
    _PC_MAX_INPUT___28 = 2,
    _PC_NAME_MAX___28 = 3,
    _PC_PATH_MAX___28 = 4,
    _PC_PIPE_BUF___28 = 5,
    _PC_CHOWN_RESTRICTED___28 = 6,
    _PC_NO_TRUNC___28 = 7,
    _PC_VDISABLE___28 = 8,
    _PC_SYNC_IO___28 = 9,
    _PC_ASYNC_IO___28 = 10,
    _PC_PRIO_IO___28 = 11,
    _PC_SOCK_MAXBUF___28 = 12,
    _PC_FILESIZEBITS___28 = 13,
    _PC_REC_INCR_XFER_SIZE___28 = 14,
    _PC_REC_MAX_XFER_SIZE___28 = 15,
    _PC_REC_MIN_XFER_SIZE___28 = 16,
    _PC_REC_XFER_ALIGN___28 = 17,
    _PC_ALLOC_SIZE_MIN___28 = 18,
    _PC_SYMLINK_MAX___28 = 19,
    _PC_2_SYMLINKS___28 = 20
} ;
enum __anonenum_315186338___28 {
    _SC_ARG_MAX___28 = 0,
    _SC_CHILD_MAX___28 = 1,
    _SC_CLK_TCK___28 = 2,
    _SC_NGROUPS_MAX___28 = 3,
    _SC_OPEN_MAX___28 = 4,
    _SC_STREAM_MAX___28 = 5,
    _SC_TZNAME_MAX___28 = 6,
    _SC_JOB_CONTROL___28 = 7,
    _SC_SAVED_IDS___28 = 8,
    _SC_REALTIME_SIGNALS___28 = 9,
    _SC_PRIORITY_SCHEDULING___28 = 10,
    _SC_TIMERS___28 = 11,
    _SC_ASYNCHRONOUS_IO___28 = 12,
    _SC_PRIORITIZED_IO___28 = 13,
    _SC_SYNCHRONIZED_IO___28 = 14,
    _SC_FSYNC___28 = 15,
    _SC_MAPPED_FILES___28 = 16,
    _SC_MEMLOCK___28 = 17,
    _SC_MEMLOCK_RANGE___28 = 18,
    _SC_MEMORY_PROTECTION___28 = 19,
    _SC_MESSAGE_PASSING___28 = 20,
    _SC_SEMAPHORES___28 = 21,
    _SC_SHARED_MEMORY_OBJECTS___28 = 22,
    _SC_AIO_LISTIO_MAX___28 = 23,
    _SC_AIO_MAX___28 = 24,
    _SC_AIO_PRIO_DELTA_MAX___28 = 25,
    _SC_DELAYTIMER_MAX___28 = 26,
    _SC_MQ_OPEN_MAX___28 = 27,
    _SC_MQ_PRIO_MAX___28 = 28,
    _SC_VERSION___28 = 29,
    _SC_PAGESIZE___28 = 30,
    _SC_RTSIG_MAX___28 = 31,
    _SC_SEM_NSEMS_MAX___28 = 32,
    _SC_SEM_VALUE_MAX___28 = 33,
    _SC_SIGQUEUE_MAX___28 = 34,
    _SC_TIMER_MAX___28 = 35,
    _SC_BC_BASE_MAX___28 = 36,
    _SC_BC_DIM_MAX___28 = 37,
    _SC_BC_SCALE_MAX___28 = 38,
    _SC_BC_STRING_MAX___28 = 39,
    _SC_COLL_WEIGHTS_MAX___28 = 40,
    _SC_EQUIV_CLASS_MAX___28 = 41,
    _SC_EXPR_NEST_MAX___28 = 42,
    _SC_LINE_MAX___28 = 43,
    _SC_RE_DUP_MAX___28 = 44,
    _SC_CHARCLASS_NAME_MAX___28 = 45,
    _SC_2_VERSION___28 = 46,
    _SC_2_C_BIND___28 = 47,
    _SC_2_C_DEV___28 = 48,
    _SC_2_FORT_DEV___28 = 49,
    _SC_2_FORT_RUN___28 = 50,
    _SC_2_SW_DEV___28 = 51,
    _SC_2_LOCALEDEF___28 = 52,
    _SC_PII___28 = 53,
    _SC_PII_XTI___28 = 54,
    _SC_PII_SOCKET___28 = 55,
    _SC_PII_INTERNET___28 = 56,
    _SC_PII_OSI___28 = 57,
    _SC_POLL___28 = 58,
    _SC_SELECT___28 = 59,
    _SC_UIO_MAXIOV___28 = 60,
    _SC_IOV_MAX___28 = 60,
    _SC_PII_INTERNET_STREAM___28 = 61,
    _SC_PII_INTERNET_DGRAM___28 = 62,
    _SC_PII_OSI_COTS___28 = 63,
    _SC_PII_OSI_CLTS___28 = 64,
    _SC_PII_OSI_M___28 = 65,
    _SC_T_IOV_MAX___28 = 66,
    _SC_THREADS___28 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___28 = 68,
    _SC_GETGR_R_SIZE_MAX___28 = 69,
    _SC_GETPW_R_SIZE_MAX___28 = 70,
    _SC_LOGIN_NAME_MAX___28 = 71,
    _SC_TTY_NAME_MAX___28 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___28 = 73,
    _SC_THREAD_KEYS_MAX___28 = 74,
    _SC_THREAD_STACK_MIN___28 = 75,
    _SC_THREAD_THREADS_MAX___28 = 76,
    _SC_THREAD_ATTR_STACKADDR___28 = 77,
    _SC_THREAD_ATTR_STACKSIZE___28 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___28 = 79,
    _SC_THREAD_PRIO_INHERIT___28 = 80,
    _SC_THREAD_PRIO_PROTECT___28 = 81,
    _SC_THREAD_PROCESS_SHARED___28 = 82,
    _SC_NPROCESSORS_CONF___28 = 83,
    _SC_NPROCESSORS_ONLN___28 = 84,
    _SC_PHYS_PAGES___28 = 85,
    _SC_AVPHYS_PAGES___28 = 86,
    _SC_ATEXIT_MAX___28 = 87,
    _SC_PASS_MAX___28 = 88,
    _SC_XOPEN_VERSION___28 = 89,
    _SC_XOPEN_XCU_VERSION___28 = 90,
    _SC_XOPEN_UNIX___28 = 91,
    _SC_XOPEN_CRYPT___28 = 92,
    _SC_XOPEN_ENH_I18N___28 = 93,
    _SC_XOPEN_SHM___28 = 94,
    _SC_2_CHAR_TERM___28 = 95,
    _SC_2_C_VERSION___28 = 96,
    _SC_2_UPE___28 = 97,
    _SC_XOPEN_XPG2___28 = 98,
    _SC_XOPEN_XPG3___28 = 99,
    _SC_XOPEN_XPG4___28 = 100,
    _SC_CHAR_BIT___28 = 101,
    _SC_CHAR_MAX___28 = 102,
    _SC_CHAR_MIN___28 = 103,
    _SC_INT_MAX___28 = 104,
    _SC_INT_MIN___28 = 105,
    _SC_LONG_BIT___28 = 106,
    _SC_WORD_BIT___28 = 107,
    _SC_MB_LEN_MAX___28 = 108,
    _SC_NZERO___28 = 109,
    _SC_SSIZE_MAX___28 = 110,
    _SC_SCHAR_MAX___28 = 111,
    _SC_SCHAR_MIN___28 = 112,
    _SC_SHRT_MAX___28 = 113,
    _SC_SHRT_MIN___28 = 114,
    _SC_UCHAR_MAX___28 = 115,
    _SC_UINT_MAX___28 = 116,
    _SC_ULONG_MAX___28 = 117,
    _SC_USHRT_MAX___28 = 118,
    _SC_NL_ARGMAX___28 = 119,
    _SC_NL_LANGMAX___28 = 120,
    _SC_NL_MSGMAX___28 = 121,
    _SC_NL_NMAX___28 = 122,
    _SC_NL_SETMAX___28 = 123,
    _SC_NL_TEXTMAX___28 = 124,
    _SC_XBS5_ILP32_OFF32___28 = 125,
    _SC_XBS5_ILP32_OFFBIG___28 = 126,
    _SC_XBS5_LP64_OFF64___28 = 127,
    _SC_XBS5_LPBIG_OFFBIG___28 = 128,
    _SC_XOPEN_LEGACY___28 = 129,
    _SC_XOPEN_REALTIME___28 = 130,
    _SC_XOPEN_REALTIME_THREADS___28 = 131,
    _SC_ADVISORY_INFO___28 = 132,
    _SC_BARRIERS___28 = 133,
    _SC_BASE___28 = 134,
    _SC_C_LANG_SUPPORT___28 = 135,
    _SC_C_LANG_SUPPORT_R___28 = 136,
    _SC_CLOCK_SELECTION___28 = 137,
    _SC_CPUTIME___28 = 138,
    _SC_THREAD_CPUTIME___28 = 139,
    _SC_DEVICE_IO___28 = 140,
    _SC_DEVICE_SPECIFIC___28 = 141,
    _SC_DEVICE_SPECIFIC_R___28 = 142,
    _SC_FD_MGMT___28 = 143,
    _SC_FIFO___28 = 144,
    _SC_PIPE___28 = 145,
    _SC_FILE_ATTRIBUTES___28 = 146,
    _SC_FILE_LOCKING___28 = 147,
    _SC_FILE_SYSTEM___28 = 148,
    _SC_MONOTONIC_CLOCK___28 = 149,
    _SC_MULTI_PROCESS___28 = 150,
    _SC_SINGLE_PROCESS___28 = 151,
    _SC_NETWORKING___28 = 152,
    _SC_READER_WRITER_LOCKS___28 = 153,
    _SC_SPIN_LOCKS___28 = 154,
    _SC_REGEXP___28 = 155,
    _SC_REGEX_VERSION___28 = 156,
    _SC_SHELL___28 = 157,
    _SC_SIGNALS___28 = 158,
    _SC_SPAWN___28 = 159,
    _SC_SPORADIC_SERVER___28 = 160,
    _SC_THREAD_SPORADIC_SERVER___28 = 161,
    _SC_SYSTEM_DATABASE___28 = 162,
    _SC_SYSTEM_DATABASE_R___28 = 163,
    _SC_TIMEOUTS___28 = 164,
    _SC_TYPED_MEMORY_OBJECTS___28 = 165,
    _SC_USER_GROUPS___28 = 166,
    _SC_USER_GROUPS_R___28 = 167,
    _SC_2_PBS___28 = 168,
    _SC_2_PBS_ACCOUNTING___28 = 169,
    _SC_2_PBS_LOCATE___28 = 170,
    _SC_2_PBS_MESSAGE___28 = 171,
    _SC_2_PBS_TRACK___28 = 172,
    _SC_SYMLOOP_MAX___28 = 173,
    _SC_STREAMS___28 = 174,
    _SC_2_PBS_CHECKPOINT___28 = 175,
    _SC_V6_ILP32_OFF32___28 = 176,
    _SC_V6_ILP32_OFFBIG___28 = 177,
    _SC_V6_LP64_OFF64___28 = 178,
    _SC_V6_LPBIG_OFFBIG___28 = 179,
    _SC_HOST_NAME_MAX___28 = 180,
    _SC_TRACE___28 = 181,
    _SC_TRACE_EVENT_FILTER___28 = 182,
    _SC_TRACE_INHERIT___28 = 183,
    _SC_TRACE_LOG___28 = 184,
    _SC_LEVEL1_ICACHE_SIZE___28 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___28 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___28 = 187,
    _SC_LEVEL1_DCACHE_SIZE___28 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___28 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___28 = 190,
    _SC_LEVEL2_CACHE_SIZE___28 = 191,
    _SC_LEVEL2_CACHE_ASSOC___28 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___28 = 193,
    _SC_LEVEL3_CACHE_SIZE___28 = 194,
    _SC_LEVEL3_CACHE_ASSOC___28 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___28 = 196,
    _SC_LEVEL4_CACHE_SIZE___28 = 197,
    _SC_LEVEL4_CACHE_ASSOC___28 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___28 = 199,
    _SC_IPV6___28 = 235,
    _SC_RAW_SOCKETS___28 = 236,
    _SC_V7_ILP32_OFF32___28 = 237,
    _SC_V7_ILP32_OFFBIG___28 = 238,
    _SC_V7_LP64_OFF64___28 = 239,
    _SC_V7_LPBIG_OFFBIG___28 = 240,
    _SC_SS_REPL_MAX___28 = 241,
    _SC_TRACE_EVENT_NAME_MAX___28 = 242,
    _SC_TRACE_NAME_MAX___28 = 243,
    _SC_TRACE_SYS_MAX___28 = 244,
    _SC_TRACE_USER_EVENT_MAX___28 = 245,
    _SC_XOPEN_STREAMS___28 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___28 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___28 = 248,
    _SC_MINSIGSTKSZ___28 = 249,
    _SC_SIGSTKSZ___28 = 250
} ;
enum __anonenum_875524036___28 {
    _CS_PATH___28 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___28 = 1,
    _CS_GNU_LIBC_VERSION___28 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___28 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___28 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___28 = 5,
    _CS_LFS_CFLAGS___28 = 1000,
    _CS_LFS_LDFLAGS___28 = 1001,
    _CS_LFS_LIBS___28 = 1002,
    _CS_LFS_LINTFLAGS___28 = 1003,
    _CS_LFS64_CFLAGS___28 = 1004,
    _CS_LFS64_LDFLAGS___28 = 1005,
    _CS_LFS64_LIBS___28 = 1006,
    _CS_LFS64_LINTFLAGS___28 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___28 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___28 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___28 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___28 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___28 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___28 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___28 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___28 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___28 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___28 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___28 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___28 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___28 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___28 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___28 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___28 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___28 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___28 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___28 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___28 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___28 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___28 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___28 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___28 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___28 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___28 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___28 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___28 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___28 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___28 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___28 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___28 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___28 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___28 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___28 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___28 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___28 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___28 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___28 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___28 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___28 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___28 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___28 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___28 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___28 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___28 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___28 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___28 = 1147,
    _CS_V6_ENV___28 = 1148,
    _CS_V7_ENV___28 = 1149
} ;
enum __anonenum_57186863___28 {
    SS_ONSTACK___28 = 1,
    SS_DISABLE___28 = 2
} ;
typedef int OperatingMode;
struct NCR_Instance_Record {
   NTP_Remote_Address remote_addr ;
   NTP_Local_Address local_addr ;
   NTP_Mode mode ;
   int interleaved ;
   OperatingMode opmode ;
   SCH_TimeoutID rx_timeout_id ;
   SCH_TimeoutID tx_timeout_id ;
   int tx_suspended ;
   int auto_iburst ;
   int auto_burst ;
   int auto_offline ;
   int local_poll ;
   int remote_poll ;
   int remote_stratum ;
   double remote_root_delay ;
   double remote_root_dispersion ;
   int presend_minpoll ;
   int presend_done ;
   int minpoll ;
   int maxpoll ;
   int min_stratum ;
   int copy ;
   int poll_target ;
   int version ;
   double poll_score ;
   double max_delay ;
   double max_delay_ratio ;
   double max_delay_dev_ratio ;
   double offset_correction ;
   int ext_field_flags ;
   uint32_t remote_mono_epoch ;
   double mono_doffset ;
   NAU_Instance auth ;
   unsigned int tx_count ;
   int valid_rx ;
   int valid_timestamps ;
   NTP_int64 remote_ntp_monorx ;
   NTP_int64 remote_ntp_rx ;
   NTP_int64 remote_ntp_tx ;
   NTP_int64 local_ntp_rx ;
   NTP_Local_Timestamp local_rx ;
   NTP_int64 local_ntp_tx ;
   NTP_Local_Timestamp local_tx ;
   NTP_Local_Timestamp prev_local_tx ;
   int prev_local_poll ;
   unsigned int prev_tx_count ;
   int updated_init_timestamps ;
   NTP_int64 init_remote_ntp_tx ;
   NTP_Local_Timestamp init_local_rx ;
   SRC_Instance source ;
   SPF_Instance filter ;
   int burst_good_samples_to_go ;
   int burst_total_samples_to_go ;
   RPT_NTPReport report ;
};
struct __anonstruct_BroadcastDestination_993981681 {
   NTP_Remote_Address addr ;
   NTP_Local_Address local_addr ;
   NAU_Instance auth ;
   int interval ;
};
typedef struct __anonstruct_BroadcastDestination_993981681 BroadcastDestination;
enum __anonenum_83571709___29 {
    MSG_OOB___29 = 1,
    MSG_PEEK___29 = 2,
    MSG_DONTROUTE___29 = 4,
    MSG_TRYHARD___29 = 4,
    MSG_CTRUNC___29 = 8,
    MSG_PROXY___29 = 16,
    MSG_TRUNC___29 = 32,
    MSG_DONTWAIT___29 = 64,
    MSG_EOR___29 = 128,
    MSG_WAITALL___29 = 256,
    MSG_FIN___29 = 512,
    MSG_SYN___29 = 1024,
    MSG_CONFIRM___29 = 2048,
    MSG_RST___29 = 4096,
    MSG_ERRQUEUE___29 = 8192,
    MSG_NOSIGNAL___29 = 16384,
    MSG_MORE___29 = 32768,
    MSG_WAITFORONE___29 = 65536,
    MSG_BATCH___29 = 262144,
    MSG_ZEROCOPY___29 = 67108864,
    MSG_FASTOPEN___29 = 536870912,
    MSG_CMSG_CLOEXEC___29 = 1073741824
} ;
enum __anonenum_617082774___29 {
    SCM_RIGHTS___29 = 1,
    SCM_CREDENTIALS___29 = 2
} ;
enum __anonenum_606441560___29 {
    SHUT_RD___29 = 0,
    SHUT_WR___29 = 1,
    SHUT_RDWR___29 = 2
} ;
enum __anonenum_264779956___29 {
    IPPROTO_IP___29 = 0,
    IPPROTO_ICMP___29 = 1,
    IPPROTO_IGMP___29 = 2,
    IPPROTO_IPIP___29 = 4,
    IPPROTO_TCP___29 = 6,
    IPPROTO_EGP___29 = 8,
    IPPROTO_PUP___29 = 12,
    IPPROTO_UDP___29 = 17,
    IPPROTO_IDP___29 = 22,
    IPPROTO_TP___29 = 29,
    IPPROTO_DCCP___29 = 33,
    IPPROTO_IPV6___29 = 41,
    IPPROTO_RSVP___29 = 46,
    IPPROTO_GRE___29 = 47,
    IPPROTO_ESP___29 = 50,
    IPPROTO_AH___29 = 51,
    IPPROTO_MTP___29 = 92,
    IPPROTO_BEETPH___29 = 94,
    IPPROTO_ENCAP___29 = 98,
    IPPROTO_PIM___29 = 103,
    IPPROTO_COMP___29 = 108,
    IPPROTO_SCTP___29 = 132,
    IPPROTO_UDPLITE___29 = 136,
    IPPROTO_MPLS___29 = 137,
    IPPROTO_ETHERNET___29 = 143,
    IPPROTO_RAW___29 = 255,
    IPPROTO_MPTCP___29 = 262,
    IPPROTO_MAX___29 = 263
} ;
enum __anonenum_218739988___29 {
    IPPROTO_HOPOPTS___29 = 0,
    IPPROTO_ROUTING___29 = 43,
    IPPROTO_FRAGMENT___29 = 44,
    IPPROTO_ICMPV6___29 = 58,
    IPPROTO_NONE___29 = 59,
    IPPROTO_DSTOPTS___29 = 60,
    IPPROTO_MH___29 = 135
} ;
enum __anonenum_662268580___29 {
    IPPORT_ECHO___29 = 7,
    IPPORT_DISCARD___29 = 9,
    IPPORT_SYSTAT___29 = 11,
    IPPORT_DAYTIME___29 = 13,
    IPPORT_NETSTAT___29 = 15,
    IPPORT_FTP___29 = 21,
    IPPORT_TELNET___29 = 23,
    IPPORT_SMTP___29 = 25,
    IPPORT_TIMESERVER___29 = 37,
    IPPORT_NAMESERVER___29 = 42,
    IPPORT_WHOIS___29 = 43,
    IPPORT_MTP___29 = 57,
    IPPORT_TFTP___29 = 69,
    IPPORT_RJE___29 = 77,
    IPPORT_FINGER___29 = 79,
    IPPORT_TTYLINK___29 = 87,
    IPPORT_SUPDUP___29 = 95,
    IPPORT_EXECSERVER___29 = 512,
    IPPORT_LOGINSERVER___29 = 513,
    IPPORT_CMDSERVER___29 = 514,
    IPPORT_EFSSERVER___29 = 520,
    IPPORT_BIFFUDP___29 = 512,
    IPPORT_WHOSERVER___29 = 513,
    IPPORT_ROUTESERVER___29 = 520,
    IPPORT_RESERVED___29 = 1024,
    IPPORT_USERRESERVED___29 = 5000
} ;
enum __anonenum_18926444___29 {
    _ISupper___29 = 256,
    _ISlower___29 = 512,
    _ISalpha___29 = 1024,
    _ISdigit___29 = 2048,
    _ISxdigit___29 = 4096,
    _ISspace___29 = 8192,
    _ISprint___29 = 16384,
    _ISgraph___29 = 32768,
    _ISblank___29 = 1,
    _IScntrl___29 = 2,
    _ISpunct___29 = 4,
    _ISalnum___29 = 8
} ;
enum __anonenum_913965969___29 {
    FP_INT_UPWARD___29 = 0,
    FP_INT_DOWNWARD___29 = 1,
    FP_INT_TOWARDZERO___29 = 2,
    FP_INT_TONEARESTFROMZERO___29 = 3,
    FP_INT_TONEAREST___29 = 4
} ;
enum __anonenum_1037408945___29 {
    FP_NAN___29 = 0,
    FP_INFINITE___29 = 1,
    FP_ZERO___29 = 2,
    FP_SUBNORMAL___29 = 3,
    FP_NORMAL___29 = 4
} ;
enum __anonenum_556971655___29 {
    SI_ASYNCNL___29 = -60,
    SI_DETHREAD___29 = -7,
    SI_TKILL___29 = -6,
    SI_SIGIO___29 = -5,
    SI_ASYNCIO___29 = -4,
    SI_MESGQ___29 = -3,
    SI_TIMER___29 = -2,
    SI_QUEUE___29 = -1,
    SI_USER___29 = 0,
    SI_KERNEL___29 = 128
} ;
enum __anonenum_640648963___29 {
    ILL_ILLOPC___29 = 1,
    ILL_ILLOPN___29 = 2,
    ILL_ILLADR___29 = 3,
    ILL_ILLTRP___29 = 4,
    ILL_PRVOPC___29 = 5,
    ILL_PRVREG___29 = 6,
    ILL_COPROC___29 = 7,
    ILL_BADSTK___29 = 8,
    ILL_BADIADDR___29 = 9
} ;
enum __anonenum_457704180___29 {
    FPE_INTDIV___29 = 1,
    FPE_INTOVF___29 = 2,
    FPE_FLTDIV___29 = 3,
    FPE_FLTOVF___29 = 4,
    FPE_FLTUND___29 = 5,
    FPE_FLTRES___29 = 6,
    FPE_FLTINV___29 = 7,
    FPE_FLTSUB___29 = 8,
    FPE_FLTUNK___29 = 14,
    FPE_CONDTRAP___29 = 15
} ;
enum __anonenum_180375148___29 {
    SEGV_MAPERR___29 = 1,
    SEGV_ACCERR___29 = 2,
    SEGV_BNDERR___29 = 3,
    SEGV_PKUERR___29 = 4,
    SEGV_ACCADI___29 = 5,
    SEGV_ADIDERR___29 = 6,
    SEGV_ADIPERR___29 = 7,
    SEGV_MTEAERR___29 = 8,
    SEGV_MTESERR___29 = 9
} ;
enum __anonenum_1036286214___29 {
    BUS_ADRALN___29 = 1,
    BUS_ADRERR___29 = 2,
    BUS_OBJERR___29 = 3,
    BUS_MCEERR_AR___29 = 4,
    BUS_MCEERR_AO___29 = 5
} ;
enum __anonenum_91015150___29 {
    TRAP_BRKPT___29 = 1,
    TRAP_TRACE___29 = 2,
    TRAP_BRANCH___29 = 3,
    TRAP_HWBKPT___29 = 4,
    TRAP_UNK___29 = 5
} ;
enum __anonenum_23175539___29 {
    CLD_EXITED___29 = 1,
    CLD_KILLED___29 = 2,
    CLD_DUMPED___29 = 3,
    CLD_TRAPPED___29 = 4,
    CLD_STOPPED___29 = 5,
    CLD_CONTINUED___29 = 6
} ;
enum __anonenum_111643124___29 {
    POLL_IN___29 = 1,
    POLL_OUT___29 = 2,
    POLL_MSG___29 = 3,
    POLL_ERR___29 = 4,
    POLL_PRI___29 = 5,
    POLL_HUP___29 = 6
} ;
enum __anonenum_852341087___29 {
    SIGEV_SIGNAL___29 = 0,
    SIGEV_NONE___29 = 1,
    SIGEV_THREAD___29 = 2,
    SIGEV_THREAD_ID___29 = 4
} ;
enum __anonenum_451154152___29 {
    REG_R8___29 = 0,
    REG_R9___29 = 1,
    REG_R10___29 = 2,
    REG_R11___29 = 3,
    REG_R12___29 = 4,
    REG_R13___29 = 5,
    REG_R14___29 = 6,
    REG_R15___29 = 7,
    REG_RDI___29 = 8,
    REG_RSI___29 = 9,
    REG_RBP___29 = 10,
    REG_RBX___29 = 11,
    REG_RDX___29 = 12,
    REG_RAX___29 = 13,
    REG_RCX___29 = 14,
    REG_RSP___29 = 15,
    REG_RIP___29 = 16,
    REG_EFL___29 = 17,
    REG_CSGSFS___29 = 18,
    REG_ERR___29 = 19,
    REG_TRAPNO___29 = 20,
    REG_OLDMASK___29 = 21,
    REG_CR2___29 = 22
} ;
enum __anonenum_437032235___29 {
    _PC_LINK_MAX___29 = 0,
    _PC_MAX_CANON___29 = 1,
    _PC_MAX_INPUT___29 = 2,
    _PC_NAME_MAX___29 = 3,
    _PC_PATH_MAX___29 = 4,
    _PC_PIPE_BUF___29 = 5,
    _PC_CHOWN_RESTRICTED___29 = 6,
    _PC_NO_TRUNC___29 = 7,
    _PC_VDISABLE___29 = 8,
    _PC_SYNC_IO___29 = 9,
    _PC_ASYNC_IO___29 = 10,
    _PC_PRIO_IO___29 = 11,
    _PC_SOCK_MAXBUF___29 = 12,
    _PC_FILESIZEBITS___29 = 13,
    _PC_REC_INCR_XFER_SIZE___29 = 14,
    _PC_REC_MAX_XFER_SIZE___29 = 15,
    _PC_REC_MIN_XFER_SIZE___29 = 16,
    _PC_REC_XFER_ALIGN___29 = 17,
    _PC_ALLOC_SIZE_MIN___29 = 18,
    _PC_SYMLINK_MAX___29 = 19,
    _PC_2_SYMLINKS___29 = 20
} ;
enum __anonenum_315186338___29 {
    _SC_ARG_MAX___29 = 0,
    _SC_CHILD_MAX___29 = 1,
    _SC_CLK_TCK___29 = 2,
    _SC_NGROUPS_MAX___29 = 3,
    _SC_OPEN_MAX___29 = 4,
    _SC_STREAM_MAX___29 = 5,
    _SC_TZNAME_MAX___29 = 6,
    _SC_JOB_CONTROL___29 = 7,
    _SC_SAVED_IDS___29 = 8,
    _SC_REALTIME_SIGNALS___29 = 9,
    _SC_PRIORITY_SCHEDULING___29 = 10,
    _SC_TIMERS___29 = 11,
    _SC_ASYNCHRONOUS_IO___29 = 12,
    _SC_PRIORITIZED_IO___29 = 13,
    _SC_SYNCHRONIZED_IO___29 = 14,
    _SC_FSYNC___29 = 15,
    _SC_MAPPED_FILES___29 = 16,
    _SC_MEMLOCK___29 = 17,
    _SC_MEMLOCK_RANGE___29 = 18,
    _SC_MEMORY_PROTECTION___29 = 19,
    _SC_MESSAGE_PASSING___29 = 20,
    _SC_SEMAPHORES___29 = 21,
    _SC_SHARED_MEMORY_OBJECTS___29 = 22,
    _SC_AIO_LISTIO_MAX___29 = 23,
    _SC_AIO_MAX___29 = 24,
    _SC_AIO_PRIO_DELTA_MAX___29 = 25,
    _SC_DELAYTIMER_MAX___29 = 26,
    _SC_MQ_OPEN_MAX___29 = 27,
    _SC_MQ_PRIO_MAX___29 = 28,
    _SC_VERSION___29 = 29,
    _SC_PAGESIZE___29 = 30,
    _SC_RTSIG_MAX___29 = 31,
    _SC_SEM_NSEMS_MAX___29 = 32,
    _SC_SEM_VALUE_MAX___29 = 33,
    _SC_SIGQUEUE_MAX___29 = 34,
    _SC_TIMER_MAX___29 = 35,
    _SC_BC_BASE_MAX___29 = 36,
    _SC_BC_DIM_MAX___29 = 37,
    _SC_BC_SCALE_MAX___29 = 38,
    _SC_BC_STRING_MAX___29 = 39,
    _SC_COLL_WEIGHTS_MAX___29 = 40,
    _SC_EQUIV_CLASS_MAX___29 = 41,
    _SC_EXPR_NEST_MAX___29 = 42,
    _SC_LINE_MAX___29 = 43,
    _SC_RE_DUP_MAX___29 = 44,
    _SC_CHARCLASS_NAME_MAX___29 = 45,
    _SC_2_VERSION___29 = 46,
    _SC_2_C_BIND___29 = 47,
    _SC_2_C_DEV___29 = 48,
    _SC_2_FORT_DEV___29 = 49,
    _SC_2_FORT_RUN___29 = 50,
    _SC_2_SW_DEV___29 = 51,
    _SC_2_LOCALEDEF___29 = 52,
    _SC_PII___29 = 53,
    _SC_PII_XTI___29 = 54,
    _SC_PII_SOCKET___29 = 55,
    _SC_PII_INTERNET___29 = 56,
    _SC_PII_OSI___29 = 57,
    _SC_POLL___29 = 58,
    _SC_SELECT___29 = 59,
    _SC_UIO_MAXIOV___29 = 60,
    _SC_IOV_MAX___29 = 60,
    _SC_PII_INTERNET_STREAM___29 = 61,
    _SC_PII_INTERNET_DGRAM___29 = 62,
    _SC_PII_OSI_COTS___29 = 63,
    _SC_PII_OSI_CLTS___29 = 64,
    _SC_PII_OSI_M___29 = 65,
    _SC_T_IOV_MAX___29 = 66,
    _SC_THREADS___29 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___29 = 68,
    _SC_GETGR_R_SIZE_MAX___29 = 69,
    _SC_GETPW_R_SIZE_MAX___29 = 70,
    _SC_LOGIN_NAME_MAX___29 = 71,
    _SC_TTY_NAME_MAX___29 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___29 = 73,
    _SC_THREAD_KEYS_MAX___29 = 74,
    _SC_THREAD_STACK_MIN___29 = 75,
    _SC_THREAD_THREADS_MAX___29 = 76,
    _SC_THREAD_ATTR_STACKADDR___29 = 77,
    _SC_THREAD_ATTR_STACKSIZE___29 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___29 = 79,
    _SC_THREAD_PRIO_INHERIT___29 = 80,
    _SC_THREAD_PRIO_PROTECT___29 = 81,
    _SC_THREAD_PROCESS_SHARED___29 = 82,
    _SC_NPROCESSORS_CONF___29 = 83,
    _SC_NPROCESSORS_ONLN___29 = 84,
    _SC_PHYS_PAGES___29 = 85,
    _SC_AVPHYS_PAGES___29 = 86,
    _SC_ATEXIT_MAX___29 = 87,
    _SC_PASS_MAX___29 = 88,
    _SC_XOPEN_VERSION___29 = 89,
    _SC_XOPEN_XCU_VERSION___29 = 90,
    _SC_XOPEN_UNIX___29 = 91,
    _SC_XOPEN_CRYPT___29 = 92,
    _SC_XOPEN_ENH_I18N___29 = 93,
    _SC_XOPEN_SHM___29 = 94,
    _SC_2_CHAR_TERM___29 = 95,
    _SC_2_C_VERSION___29 = 96,
    _SC_2_UPE___29 = 97,
    _SC_XOPEN_XPG2___29 = 98,
    _SC_XOPEN_XPG3___29 = 99,
    _SC_XOPEN_XPG4___29 = 100,
    _SC_CHAR_BIT___29 = 101,
    _SC_CHAR_MAX___29 = 102,
    _SC_CHAR_MIN___29 = 103,
    _SC_INT_MAX___29 = 104,
    _SC_INT_MIN___29 = 105,
    _SC_LONG_BIT___29 = 106,
    _SC_WORD_BIT___29 = 107,
    _SC_MB_LEN_MAX___29 = 108,
    _SC_NZERO___29 = 109,
    _SC_SSIZE_MAX___29 = 110,
    _SC_SCHAR_MAX___29 = 111,
    _SC_SCHAR_MIN___29 = 112,
    _SC_SHRT_MAX___29 = 113,
    _SC_SHRT_MIN___29 = 114,
    _SC_UCHAR_MAX___29 = 115,
    _SC_UINT_MAX___29 = 116,
    _SC_ULONG_MAX___29 = 117,
    _SC_USHRT_MAX___29 = 118,
    _SC_NL_ARGMAX___29 = 119,
    _SC_NL_LANGMAX___29 = 120,
    _SC_NL_MSGMAX___29 = 121,
    _SC_NL_NMAX___29 = 122,
    _SC_NL_SETMAX___29 = 123,
    _SC_NL_TEXTMAX___29 = 124,
    _SC_XBS5_ILP32_OFF32___29 = 125,
    _SC_XBS5_ILP32_OFFBIG___29 = 126,
    _SC_XBS5_LP64_OFF64___29 = 127,
    _SC_XBS5_LPBIG_OFFBIG___29 = 128,
    _SC_XOPEN_LEGACY___29 = 129,
    _SC_XOPEN_REALTIME___29 = 130,
    _SC_XOPEN_REALTIME_THREADS___29 = 131,
    _SC_ADVISORY_INFO___29 = 132,
    _SC_BARRIERS___29 = 133,
    _SC_BASE___29 = 134,
    _SC_C_LANG_SUPPORT___29 = 135,
    _SC_C_LANG_SUPPORT_R___29 = 136,
    _SC_CLOCK_SELECTION___29 = 137,
    _SC_CPUTIME___29 = 138,
    _SC_THREAD_CPUTIME___29 = 139,
    _SC_DEVICE_IO___29 = 140,
    _SC_DEVICE_SPECIFIC___29 = 141,
    _SC_DEVICE_SPECIFIC_R___29 = 142,
    _SC_FD_MGMT___29 = 143,
    _SC_FIFO___29 = 144,
    _SC_PIPE___29 = 145,
    _SC_FILE_ATTRIBUTES___29 = 146,
    _SC_FILE_LOCKING___29 = 147,
    _SC_FILE_SYSTEM___29 = 148,
    _SC_MONOTONIC_CLOCK___29 = 149,
    _SC_MULTI_PROCESS___29 = 150,
    _SC_SINGLE_PROCESS___29 = 151,
    _SC_NETWORKING___29 = 152,
    _SC_READER_WRITER_LOCKS___29 = 153,
    _SC_SPIN_LOCKS___29 = 154,
    _SC_REGEXP___29 = 155,
    _SC_REGEX_VERSION___29 = 156,
    _SC_SHELL___29 = 157,
    _SC_SIGNALS___29 = 158,
    _SC_SPAWN___29 = 159,
    _SC_SPORADIC_SERVER___29 = 160,
    _SC_THREAD_SPORADIC_SERVER___29 = 161,
    _SC_SYSTEM_DATABASE___29 = 162,
    _SC_SYSTEM_DATABASE_R___29 = 163,
    _SC_TIMEOUTS___29 = 164,
    _SC_TYPED_MEMORY_OBJECTS___29 = 165,
    _SC_USER_GROUPS___29 = 166,
    _SC_USER_GROUPS_R___29 = 167,
    _SC_2_PBS___29 = 168,
    _SC_2_PBS_ACCOUNTING___29 = 169,
    _SC_2_PBS_LOCATE___29 = 170,
    _SC_2_PBS_MESSAGE___29 = 171,
    _SC_2_PBS_TRACK___29 = 172,
    _SC_SYMLOOP_MAX___29 = 173,
    _SC_STREAMS___29 = 174,
    _SC_2_PBS_CHECKPOINT___29 = 175,
    _SC_V6_ILP32_OFF32___29 = 176,
    _SC_V6_ILP32_OFFBIG___29 = 177,
    _SC_V6_LP64_OFF64___29 = 178,
    _SC_V6_LPBIG_OFFBIG___29 = 179,
    _SC_HOST_NAME_MAX___29 = 180,
    _SC_TRACE___29 = 181,
    _SC_TRACE_EVENT_FILTER___29 = 182,
    _SC_TRACE_INHERIT___29 = 183,
    _SC_TRACE_LOG___29 = 184,
    _SC_LEVEL1_ICACHE_SIZE___29 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___29 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___29 = 187,
    _SC_LEVEL1_DCACHE_SIZE___29 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___29 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___29 = 190,
    _SC_LEVEL2_CACHE_SIZE___29 = 191,
    _SC_LEVEL2_CACHE_ASSOC___29 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___29 = 193,
    _SC_LEVEL3_CACHE_SIZE___29 = 194,
    _SC_LEVEL3_CACHE_ASSOC___29 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___29 = 196,
    _SC_LEVEL4_CACHE_SIZE___29 = 197,
    _SC_LEVEL4_CACHE_ASSOC___29 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___29 = 199,
    _SC_IPV6___29 = 235,
    _SC_RAW_SOCKETS___29 = 236,
    _SC_V7_ILP32_OFF32___29 = 237,
    _SC_V7_ILP32_OFFBIG___29 = 238,
    _SC_V7_LP64_OFF64___29 = 239,
    _SC_V7_LPBIG_OFFBIG___29 = 240,
    _SC_SS_REPL_MAX___29 = 241,
    _SC_TRACE_EVENT_NAME_MAX___29 = 242,
    _SC_TRACE_NAME_MAX___29 = 243,
    _SC_TRACE_SYS_MAX___29 = 244,
    _SC_TRACE_USER_EVENT_MAX___29 = 245,
    _SC_XOPEN_STREAMS___29 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___29 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___29 = 248,
    _SC_MINSIGSTKSZ___29 = 249,
    _SC_SIGSTKSZ___29 = 250
} ;
enum __anonenum_875524036___29 {
    _CS_PATH___29 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___29 = 1,
    _CS_GNU_LIBC_VERSION___29 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___29 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___29 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___29 = 5,
    _CS_LFS_CFLAGS___29 = 1000,
    _CS_LFS_LDFLAGS___29 = 1001,
    _CS_LFS_LIBS___29 = 1002,
    _CS_LFS_LINTFLAGS___29 = 1003,
    _CS_LFS64_CFLAGS___29 = 1004,
    _CS_LFS64_LDFLAGS___29 = 1005,
    _CS_LFS64_LIBS___29 = 1006,
    _CS_LFS64_LINTFLAGS___29 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___29 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___29 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___29 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___29 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___29 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___29 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___29 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___29 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___29 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___29 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___29 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___29 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___29 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___29 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___29 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___29 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___29 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___29 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___29 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___29 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___29 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___29 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___29 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___29 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___29 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___29 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___29 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___29 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___29 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___29 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___29 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___29 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___29 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___29 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___29 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___29 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___29 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___29 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___29 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___29 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___29 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___29 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___29 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___29 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___29 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___29 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___29 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___29 = 1147,
    _CS_V6_ENV___29 = 1148,
    _CS_V7_ENV___29 = 1149
} ;
enum __anonenum_57186863___29 {
    SS_ONSTACK___29 = 1,
    SS_DISABLE___29 = 2
} ;
struct ExtFieldHeader {
   uint16_t type ;
   uint16_t length ;
};
enum __anonenum_83571709___30 {
    MSG_OOB___30 = 1,
    MSG_PEEK___30 = 2,
    MSG_DONTROUTE___30 = 4,
    MSG_TRYHARD___30 = 4,
    MSG_CTRUNC___30 = 8,
    MSG_PROXY___30 = 16,
    MSG_TRUNC___30 = 32,
    MSG_DONTWAIT___30 = 64,
    MSG_EOR___30 = 128,
    MSG_WAITALL___30 = 256,
    MSG_FIN___30 = 512,
    MSG_SYN___30 = 1024,
    MSG_CONFIRM___30 = 2048,
    MSG_RST___30 = 4096,
    MSG_ERRQUEUE___30 = 8192,
    MSG_NOSIGNAL___30 = 16384,
    MSG_MORE___30 = 32768,
    MSG_WAITFORONE___30 = 65536,
    MSG_BATCH___30 = 262144,
    MSG_ZEROCOPY___30 = 67108864,
    MSG_FASTOPEN___30 = 536870912,
    MSG_CMSG_CLOEXEC___30 = 1073741824
} ;
enum __anonenum_617082774___30 {
    SCM_RIGHTS___30 = 1,
    SCM_CREDENTIALS___30 = 2
} ;
enum __anonenum_606441560___30 {
    SHUT_RD___30 = 0,
    SHUT_WR___30 = 1,
    SHUT_RDWR___30 = 2
} ;
enum __anonenum_264779956___30 {
    IPPROTO_IP___30 = 0,
    IPPROTO_ICMP___30 = 1,
    IPPROTO_IGMP___30 = 2,
    IPPROTO_IPIP___30 = 4,
    IPPROTO_TCP___30 = 6,
    IPPROTO_EGP___30 = 8,
    IPPROTO_PUP___30 = 12,
    IPPROTO_UDP___30 = 17,
    IPPROTO_IDP___30 = 22,
    IPPROTO_TP___30 = 29,
    IPPROTO_DCCP___30 = 33,
    IPPROTO_IPV6___30 = 41,
    IPPROTO_RSVP___30 = 46,
    IPPROTO_GRE___30 = 47,
    IPPROTO_ESP___30 = 50,
    IPPROTO_AH___30 = 51,
    IPPROTO_MTP___30 = 92,
    IPPROTO_BEETPH___30 = 94,
    IPPROTO_ENCAP___30 = 98,
    IPPROTO_PIM___30 = 103,
    IPPROTO_COMP___30 = 108,
    IPPROTO_SCTP___30 = 132,
    IPPROTO_UDPLITE___30 = 136,
    IPPROTO_MPLS___30 = 137,
    IPPROTO_ETHERNET___30 = 143,
    IPPROTO_RAW___30 = 255,
    IPPROTO_MPTCP___30 = 262,
    IPPROTO_MAX___30 = 263
} ;
enum __anonenum_218739988___30 {
    IPPROTO_HOPOPTS___30 = 0,
    IPPROTO_ROUTING___30 = 43,
    IPPROTO_FRAGMENT___30 = 44,
    IPPROTO_ICMPV6___30 = 58,
    IPPROTO_NONE___30 = 59,
    IPPROTO_DSTOPTS___30 = 60,
    IPPROTO_MH___30 = 135
} ;
enum __anonenum_662268580___30 {
    IPPORT_ECHO___30 = 7,
    IPPORT_DISCARD___30 = 9,
    IPPORT_SYSTAT___30 = 11,
    IPPORT_DAYTIME___30 = 13,
    IPPORT_NETSTAT___30 = 15,
    IPPORT_FTP___30 = 21,
    IPPORT_TELNET___30 = 23,
    IPPORT_SMTP___30 = 25,
    IPPORT_TIMESERVER___30 = 37,
    IPPORT_NAMESERVER___30 = 42,
    IPPORT_WHOIS___30 = 43,
    IPPORT_MTP___30 = 57,
    IPPORT_TFTP___30 = 69,
    IPPORT_RJE___30 = 77,
    IPPORT_FINGER___30 = 79,
    IPPORT_TTYLINK___30 = 87,
    IPPORT_SUPDUP___30 = 95,
    IPPORT_EXECSERVER___30 = 512,
    IPPORT_LOGINSERVER___30 = 513,
    IPPORT_CMDSERVER___30 = 514,
    IPPORT_EFSSERVER___30 = 520,
    IPPORT_BIFFUDP___30 = 512,
    IPPORT_WHOSERVER___30 = 513,
    IPPORT_ROUTESERVER___30 = 520,
    IPPORT_RESERVED___30 = 1024,
    IPPORT_USERRESERVED___30 = 5000
} ;
enum __anonenum_18926444___30 {
    _ISupper___30 = 256,
    _ISlower___30 = 512,
    _ISalpha___30 = 1024,
    _ISdigit___30 = 2048,
    _ISxdigit___30 = 4096,
    _ISspace___30 = 8192,
    _ISprint___30 = 16384,
    _ISgraph___30 = 32768,
    _ISblank___30 = 1,
    _IScntrl___30 = 2,
    _ISpunct___30 = 4,
    _ISalnum___30 = 8
} ;
enum __anonenum_913965969___30 {
    FP_INT_UPWARD___30 = 0,
    FP_INT_DOWNWARD___30 = 1,
    FP_INT_TOWARDZERO___30 = 2,
    FP_INT_TONEARESTFROMZERO___30 = 3,
    FP_INT_TONEAREST___30 = 4
} ;
enum __anonenum_1037408945___30 {
    FP_NAN___30 = 0,
    FP_INFINITE___30 = 1,
    FP_ZERO___30 = 2,
    FP_SUBNORMAL___30 = 3,
    FP_NORMAL___30 = 4
} ;
enum __anonenum_556971655___30 {
    SI_ASYNCNL___30 = -60,
    SI_DETHREAD___30 = -7,
    SI_TKILL___30 = -6,
    SI_SIGIO___30 = -5,
    SI_ASYNCIO___30 = -4,
    SI_MESGQ___30 = -3,
    SI_TIMER___30 = -2,
    SI_QUEUE___30 = -1,
    SI_USER___30 = 0,
    SI_KERNEL___30 = 128
} ;
enum __anonenum_640648963___30 {
    ILL_ILLOPC___30 = 1,
    ILL_ILLOPN___30 = 2,
    ILL_ILLADR___30 = 3,
    ILL_ILLTRP___30 = 4,
    ILL_PRVOPC___30 = 5,
    ILL_PRVREG___30 = 6,
    ILL_COPROC___30 = 7,
    ILL_BADSTK___30 = 8,
    ILL_BADIADDR___30 = 9
} ;
enum __anonenum_457704180___30 {
    FPE_INTDIV___30 = 1,
    FPE_INTOVF___30 = 2,
    FPE_FLTDIV___30 = 3,
    FPE_FLTOVF___30 = 4,
    FPE_FLTUND___30 = 5,
    FPE_FLTRES___30 = 6,
    FPE_FLTINV___30 = 7,
    FPE_FLTSUB___30 = 8,
    FPE_FLTUNK___30 = 14,
    FPE_CONDTRAP___30 = 15
} ;
enum __anonenum_180375148___30 {
    SEGV_MAPERR___30 = 1,
    SEGV_ACCERR___30 = 2,
    SEGV_BNDERR___30 = 3,
    SEGV_PKUERR___30 = 4,
    SEGV_ACCADI___30 = 5,
    SEGV_ADIDERR___30 = 6,
    SEGV_ADIPERR___30 = 7,
    SEGV_MTEAERR___30 = 8,
    SEGV_MTESERR___30 = 9
} ;
enum __anonenum_1036286214___30 {
    BUS_ADRALN___30 = 1,
    BUS_ADRERR___30 = 2,
    BUS_OBJERR___30 = 3,
    BUS_MCEERR_AR___30 = 4,
    BUS_MCEERR_AO___30 = 5
} ;
enum __anonenum_91015150___30 {
    TRAP_BRKPT___30 = 1,
    TRAP_TRACE___30 = 2,
    TRAP_BRANCH___30 = 3,
    TRAP_HWBKPT___30 = 4,
    TRAP_UNK___30 = 5
} ;
enum __anonenum_23175539___30 {
    CLD_EXITED___30 = 1,
    CLD_KILLED___30 = 2,
    CLD_DUMPED___30 = 3,
    CLD_TRAPPED___30 = 4,
    CLD_STOPPED___30 = 5,
    CLD_CONTINUED___30 = 6
} ;
enum __anonenum_111643124___30 {
    POLL_IN___30 = 1,
    POLL_OUT___30 = 2,
    POLL_MSG___30 = 3,
    POLL_ERR___30 = 4,
    POLL_PRI___30 = 5,
    POLL_HUP___30 = 6
} ;
enum __anonenum_852341087___30 {
    SIGEV_SIGNAL___30 = 0,
    SIGEV_NONE___30 = 1,
    SIGEV_THREAD___30 = 2,
    SIGEV_THREAD_ID___30 = 4
} ;
enum __anonenum_451154152___30 {
    REG_R8___30 = 0,
    REG_R9___30 = 1,
    REG_R10___30 = 2,
    REG_R11___30 = 3,
    REG_R12___30 = 4,
    REG_R13___30 = 5,
    REG_R14___30 = 6,
    REG_R15___30 = 7,
    REG_RDI___30 = 8,
    REG_RSI___30 = 9,
    REG_RBP___30 = 10,
    REG_RBX___30 = 11,
    REG_RDX___30 = 12,
    REG_RAX___30 = 13,
    REG_RCX___30 = 14,
    REG_RSP___30 = 15,
    REG_RIP___30 = 16,
    REG_EFL___30 = 17,
    REG_CSGSFS___30 = 18,
    REG_ERR___30 = 19,
    REG_TRAPNO___30 = 20,
    REG_OLDMASK___30 = 21,
    REG_CR2___30 = 22
} ;
enum __anonenum_437032235___30 {
    _PC_LINK_MAX___30 = 0,
    _PC_MAX_CANON___30 = 1,
    _PC_MAX_INPUT___30 = 2,
    _PC_NAME_MAX___30 = 3,
    _PC_PATH_MAX___30 = 4,
    _PC_PIPE_BUF___30 = 5,
    _PC_CHOWN_RESTRICTED___30 = 6,
    _PC_NO_TRUNC___30 = 7,
    _PC_VDISABLE___30 = 8,
    _PC_SYNC_IO___30 = 9,
    _PC_ASYNC_IO___30 = 10,
    _PC_PRIO_IO___30 = 11,
    _PC_SOCK_MAXBUF___30 = 12,
    _PC_FILESIZEBITS___30 = 13,
    _PC_REC_INCR_XFER_SIZE___30 = 14,
    _PC_REC_MAX_XFER_SIZE___30 = 15,
    _PC_REC_MIN_XFER_SIZE___30 = 16,
    _PC_REC_XFER_ALIGN___30 = 17,
    _PC_ALLOC_SIZE_MIN___30 = 18,
    _PC_SYMLINK_MAX___30 = 19,
    _PC_2_SYMLINKS___30 = 20
} ;
enum __anonenum_315186338___30 {
    _SC_ARG_MAX___30 = 0,
    _SC_CHILD_MAX___30 = 1,
    _SC_CLK_TCK___30 = 2,
    _SC_NGROUPS_MAX___30 = 3,
    _SC_OPEN_MAX___30 = 4,
    _SC_STREAM_MAX___30 = 5,
    _SC_TZNAME_MAX___30 = 6,
    _SC_JOB_CONTROL___30 = 7,
    _SC_SAVED_IDS___30 = 8,
    _SC_REALTIME_SIGNALS___30 = 9,
    _SC_PRIORITY_SCHEDULING___30 = 10,
    _SC_TIMERS___30 = 11,
    _SC_ASYNCHRONOUS_IO___30 = 12,
    _SC_PRIORITIZED_IO___30 = 13,
    _SC_SYNCHRONIZED_IO___30 = 14,
    _SC_FSYNC___30 = 15,
    _SC_MAPPED_FILES___30 = 16,
    _SC_MEMLOCK___30 = 17,
    _SC_MEMLOCK_RANGE___30 = 18,
    _SC_MEMORY_PROTECTION___30 = 19,
    _SC_MESSAGE_PASSING___30 = 20,
    _SC_SEMAPHORES___30 = 21,
    _SC_SHARED_MEMORY_OBJECTS___30 = 22,
    _SC_AIO_LISTIO_MAX___30 = 23,
    _SC_AIO_MAX___30 = 24,
    _SC_AIO_PRIO_DELTA_MAX___30 = 25,
    _SC_DELAYTIMER_MAX___30 = 26,
    _SC_MQ_OPEN_MAX___30 = 27,
    _SC_MQ_PRIO_MAX___30 = 28,
    _SC_VERSION___30 = 29,
    _SC_PAGESIZE___30 = 30,
    _SC_RTSIG_MAX___30 = 31,
    _SC_SEM_NSEMS_MAX___30 = 32,
    _SC_SEM_VALUE_MAX___30 = 33,
    _SC_SIGQUEUE_MAX___30 = 34,
    _SC_TIMER_MAX___30 = 35,
    _SC_BC_BASE_MAX___30 = 36,
    _SC_BC_DIM_MAX___30 = 37,
    _SC_BC_SCALE_MAX___30 = 38,
    _SC_BC_STRING_MAX___30 = 39,
    _SC_COLL_WEIGHTS_MAX___30 = 40,
    _SC_EQUIV_CLASS_MAX___30 = 41,
    _SC_EXPR_NEST_MAX___30 = 42,
    _SC_LINE_MAX___30 = 43,
    _SC_RE_DUP_MAX___30 = 44,
    _SC_CHARCLASS_NAME_MAX___30 = 45,
    _SC_2_VERSION___30 = 46,
    _SC_2_C_BIND___30 = 47,
    _SC_2_C_DEV___30 = 48,
    _SC_2_FORT_DEV___30 = 49,
    _SC_2_FORT_RUN___30 = 50,
    _SC_2_SW_DEV___30 = 51,
    _SC_2_LOCALEDEF___30 = 52,
    _SC_PII___30 = 53,
    _SC_PII_XTI___30 = 54,
    _SC_PII_SOCKET___30 = 55,
    _SC_PII_INTERNET___30 = 56,
    _SC_PII_OSI___30 = 57,
    _SC_POLL___30 = 58,
    _SC_SELECT___30 = 59,
    _SC_UIO_MAXIOV___30 = 60,
    _SC_IOV_MAX___30 = 60,
    _SC_PII_INTERNET_STREAM___30 = 61,
    _SC_PII_INTERNET_DGRAM___30 = 62,
    _SC_PII_OSI_COTS___30 = 63,
    _SC_PII_OSI_CLTS___30 = 64,
    _SC_PII_OSI_M___30 = 65,
    _SC_T_IOV_MAX___30 = 66,
    _SC_THREADS___30 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___30 = 68,
    _SC_GETGR_R_SIZE_MAX___30 = 69,
    _SC_GETPW_R_SIZE_MAX___30 = 70,
    _SC_LOGIN_NAME_MAX___30 = 71,
    _SC_TTY_NAME_MAX___30 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___30 = 73,
    _SC_THREAD_KEYS_MAX___30 = 74,
    _SC_THREAD_STACK_MIN___30 = 75,
    _SC_THREAD_THREADS_MAX___30 = 76,
    _SC_THREAD_ATTR_STACKADDR___30 = 77,
    _SC_THREAD_ATTR_STACKSIZE___30 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___30 = 79,
    _SC_THREAD_PRIO_INHERIT___30 = 80,
    _SC_THREAD_PRIO_PROTECT___30 = 81,
    _SC_THREAD_PROCESS_SHARED___30 = 82,
    _SC_NPROCESSORS_CONF___30 = 83,
    _SC_NPROCESSORS_ONLN___30 = 84,
    _SC_PHYS_PAGES___30 = 85,
    _SC_AVPHYS_PAGES___30 = 86,
    _SC_ATEXIT_MAX___30 = 87,
    _SC_PASS_MAX___30 = 88,
    _SC_XOPEN_VERSION___30 = 89,
    _SC_XOPEN_XCU_VERSION___30 = 90,
    _SC_XOPEN_UNIX___30 = 91,
    _SC_XOPEN_CRYPT___30 = 92,
    _SC_XOPEN_ENH_I18N___30 = 93,
    _SC_XOPEN_SHM___30 = 94,
    _SC_2_CHAR_TERM___30 = 95,
    _SC_2_C_VERSION___30 = 96,
    _SC_2_UPE___30 = 97,
    _SC_XOPEN_XPG2___30 = 98,
    _SC_XOPEN_XPG3___30 = 99,
    _SC_XOPEN_XPG4___30 = 100,
    _SC_CHAR_BIT___30 = 101,
    _SC_CHAR_MAX___30 = 102,
    _SC_CHAR_MIN___30 = 103,
    _SC_INT_MAX___30 = 104,
    _SC_INT_MIN___30 = 105,
    _SC_LONG_BIT___30 = 106,
    _SC_WORD_BIT___30 = 107,
    _SC_MB_LEN_MAX___30 = 108,
    _SC_NZERO___30 = 109,
    _SC_SSIZE_MAX___30 = 110,
    _SC_SCHAR_MAX___30 = 111,
    _SC_SCHAR_MIN___30 = 112,
    _SC_SHRT_MAX___30 = 113,
    _SC_SHRT_MIN___30 = 114,
    _SC_UCHAR_MAX___30 = 115,
    _SC_UINT_MAX___30 = 116,
    _SC_ULONG_MAX___30 = 117,
    _SC_USHRT_MAX___30 = 118,
    _SC_NL_ARGMAX___30 = 119,
    _SC_NL_LANGMAX___30 = 120,
    _SC_NL_MSGMAX___30 = 121,
    _SC_NL_NMAX___30 = 122,
    _SC_NL_SETMAX___30 = 123,
    _SC_NL_TEXTMAX___30 = 124,
    _SC_XBS5_ILP32_OFF32___30 = 125,
    _SC_XBS5_ILP32_OFFBIG___30 = 126,
    _SC_XBS5_LP64_OFF64___30 = 127,
    _SC_XBS5_LPBIG_OFFBIG___30 = 128,
    _SC_XOPEN_LEGACY___30 = 129,
    _SC_XOPEN_REALTIME___30 = 130,
    _SC_XOPEN_REALTIME_THREADS___30 = 131,
    _SC_ADVISORY_INFO___30 = 132,
    _SC_BARRIERS___30 = 133,
    _SC_BASE___30 = 134,
    _SC_C_LANG_SUPPORT___30 = 135,
    _SC_C_LANG_SUPPORT_R___30 = 136,
    _SC_CLOCK_SELECTION___30 = 137,
    _SC_CPUTIME___30 = 138,
    _SC_THREAD_CPUTIME___30 = 139,
    _SC_DEVICE_IO___30 = 140,
    _SC_DEVICE_SPECIFIC___30 = 141,
    _SC_DEVICE_SPECIFIC_R___30 = 142,
    _SC_FD_MGMT___30 = 143,
    _SC_FIFO___30 = 144,
    _SC_PIPE___30 = 145,
    _SC_FILE_ATTRIBUTES___30 = 146,
    _SC_FILE_LOCKING___30 = 147,
    _SC_FILE_SYSTEM___30 = 148,
    _SC_MONOTONIC_CLOCK___30 = 149,
    _SC_MULTI_PROCESS___30 = 150,
    _SC_SINGLE_PROCESS___30 = 151,
    _SC_NETWORKING___30 = 152,
    _SC_READER_WRITER_LOCKS___30 = 153,
    _SC_SPIN_LOCKS___30 = 154,
    _SC_REGEXP___30 = 155,
    _SC_REGEX_VERSION___30 = 156,
    _SC_SHELL___30 = 157,
    _SC_SIGNALS___30 = 158,
    _SC_SPAWN___30 = 159,
    _SC_SPORADIC_SERVER___30 = 160,
    _SC_THREAD_SPORADIC_SERVER___30 = 161,
    _SC_SYSTEM_DATABASE___30 = 162,
    _SC_SYSTEM_DATABASE_R___30 = 163,
    _SC_TIMEOUTS___30 = 164,
    _SC_TYPED_MEMORY_OBJECTS___30 = 165,
    _SC_USER_GROUPS___30 = 166,
    _SC_USER_GROUPS_R___30 = 167,
    _SC_2_PBS___30 = 168,
    _SC_2_PBS_ACCOUNTING___30 = 169,
    _SC_2_PBS_LOCATE___30 = 170,
    _SC_2_PBS_MESSAGE___30 = 171,
    _SC_2_PBS_TRACK___30 = 172,
    _SC_SYMLOOP_MAX___30 = 173,
    _SC_STREAMS___30 = 174,
    _SC_2_PBS_CHECKPOINT___30 = 175,
    _SC_V6_ILP32_OFF32___30 = 176,
    _SC_V6_ILP32_OFFBIG___30 = 177,
    _SC_V6_LP64_OFF64___30 = 178,
    _SC_V6_LPBIG_OFFBIG___30 = 179,
    _SC_HOST_NAME_MAX___30 = 180,
    _SC_TRACE___30 = 181,
    _SC_TRACE_EVENT_FILTER___30 = 182,
    _SC_TRACE_INHERIT___30 = 183,
    _SC_TRACE_LOG___30 = 184,
    _SC_LEVEL1_ICACHE_SIZE___30 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___30 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___30 = 187,
    _SC_LEVEL1_DCACHE_SIZE___30 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___30 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___30 = 190,
    _SC_LEVEL2_CACHE_SIZE___30 = 191,
    _SC_LEVEL2_CACHE_ASSOC___30 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___30 = 193,
    _SC_LEVEL3_CACHE_SIZE___30 = 194,
    _SC_LEVEL3_CACHE_ASSOC___30 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___30 = 196,
    _SC_LEVEL4_CACHE_SIZE___30 = 197,
    _SC_LEVEL4_CACHE_ASSOC___30 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___30 = 199,
    _SC_IPV6___30 = 235,
    _SC_RAW_SOCKETS___30 = 236,
    _SC_V7_ILP32_OFF32___30 = 237,
    _SC_V7_ILP32_OFFBIG___30 = 238,
    _SC_V7_LP64_OFF64___30 = 239,
    _SC_V7_LPBIG_OFFBIG___30 = 240,
    _SC_SS_REPL_MAX___30 = 241,
    _SC_TRACE_EVENT_NAME_MAX___30 = 242,
    _SC_TRACE_NAME_MAX___30 = 243,
    _SC_TRACE_SYS_MAX___30 = 244,
    _SC_TRACE_USER_EVENT_MAX___30 = 245,
    _SC_XOPEN_STREAMS___30 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___30 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___30 = 248,
    _SC_MINSIGSTKSZ___30 = 249,
    _SC_SIGSTKSZ___30 = 250
} ;
enum __anonenum_875524036___30 {
    _CS_PATH___30 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___30 = 1,
    _CS_GNU_LIBC_VERSION___30 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___30 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___30 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___30 = 5,
    _CS_LFS_CFLAGS___30 = 1000,
    _CS_LFS_LDFLAGS___30 = 1001,
    _CS_LFS_LIBS___30 = 1002,
    _CS_LFS_LINTFLAGS___30 = 1003,
    _CS_LFS64_CFLAGS___30 = 1004,
    _CS_LFS64_LDFLAGS___30 = 1005,
    _CS_LFS64_LIBS___30 = 1006,
    _CS_LFS64_LINTFLAGS___30 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___30 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___30 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___30 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___30 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___30 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___30 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___30 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___30 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___30 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___30 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___30 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___30 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___30 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___30 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___30 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___30 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___30 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___30 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___30 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___30 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___30 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___30 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___30 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___30 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___30 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___30 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___30 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___30 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___30 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___30 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___30 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___30 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___30 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___30 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___30 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___30 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___30 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___30 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___30 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___30 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___30 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___30 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___30 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___30 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___30 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___30 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___30 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___30 = 1147,
    _CS_V6_ENV___30 = 1148,
    _CS_V7_ENV___30 = 1149
} ;
enum __anonenum_57186863___30 {
    SS_ONSTACK___30 = 1,
    SS_DISABLE___30 = 2
} ;
enum __anonenum_83571709___31 {
    MSG_OOB___31 = 1,
    MSG_PEEK___31 = 2,
    MSG_DONTROUTE___31 = 4,
    MSG_TRYHARD___31 = 4,
    MSG_CTRUNC___31 = 8,
    MSG_PROXY___31 = 16,
    MSG_TRUNC___31 = 32,
    MSG_DONTWAIT___31 = 64,
    MSG_EOR___31 = 128,
    MSG_WAITALL___31 = 256,
    MSG_FIN___31 = 512,
    MSG_SYN___31 = 1024,
    MSG_CONFIRM___31 = 2048,
    MSG_RST___31 = 4096,
    MSG_ERRQUEUE___31 = 8192,
    MSG_NOSIGNAL___31 = 16384,
    MSG_MORE___31 = 32768,
    MSG_WAITFORONE___31 = 65536,
    MSG_BATCH___31 = 262144,
    MSG_ZEROCOPY___31 = 67108864,
    MSG_FASTOPEN___31 = 536870912,
    MSG_CMSG_CLOEXEC___31 = 1073741824
} ;
enum __anonenum_617082774___31 {
    SCM_RIGHTS___31 = 1,
    SCM_CREDENTIALS___31 = 2
} ;
enum __anonenum_606441560___31 {
    SHUT_RD___31 = 0,
    SHUT_WR___31 = 1,
    SHUT_RDWR___31 = 2
} ;
enum __anonenum_264779956___31 {
    IPPROTO_IP___31 = 0,
    IPPROTO_ICMP___31 = 1,
    IPPROTO_IGMP___31 = 2,
    IPPROTO_IPIP___31 = 4,
    IPPROTO_TCP___31 = 6,
    IPPROTO_EGP___31 = 8,
    IPPROTO_PUP___31 = 12,
    IPPROTO_UDP___31 = 17,
    IPPROTO_IDP___31 = 22,
    IPPROTO_TP___31 = 29,
    IPPROTO_DCCP___31 = 33,
    IPPROTO_IPV6___31 = 41,
    IPPROTO_RSVP___31 = 46,
    IPPROTO_GRE___31 = 47,
    IPPROTO_ESP___31 = 50,
    IPPROTO_AH___31 = 51,
    IPPROTO_MTP___31 = 92,
    IPPROTO_BEETPH___31 = 94,
    IPPROTO_ENCAP___31 = 98,
    IPPROTO_PIM___31 = 103,
    IPPROTO_COMP___31 = 108,
    IPPROTO_SCTP___31 = 132,
    IPPROTO_UDPLITE___31 = 136,
    IPPROTO_MPLS___31 = 137,
    IPPROTO_ETHERNET___31 = 143,
    IPPROTO_RAW___31 = 255,
    IPPROTO_MPTCP___31 = 262,
    IPPROTO_MAX___31 = 263
} ;
enum __anonenum_218739988___31 {
    IPPROTO_HOPOPTS___31 = 0,
    IPPROTO_ROUTING___31 = 43,
    IPPROTO_FRAGMENT___31 = 44,
    IPPROTO_ICMPV6___31 = 58,
    IPPROTO_NONE___31 = 59,
    IPPROTO_DSTOPTS___31 = 60,
    IPPROTO_MH___31 = 135
} ;
enum __anonenum_662268580___31 {
    IPPORT_ECHO___31 = 7,
    IPPORT_DISCARD___31 = 9,
    IPPORT_SYSTAT___31 = 11,
    IPPORT_DAYTIME___31 = 13,
    IPPORT_NETSTAT___31 = 15,
    IPPORT_FTP___31 = 21,
    IPPORT_TELNET___31 = 23,
    IPPORT_SMTP___31 = 25,
    IPPORT_TIMESERVER___31 = 37,
    IPPORT_NAMESERVER___31 = 42,
    IPPORT_WHOIS___31 = 43,
    IPPORT_MTP___31 = 57,
    IPPORT_TFTP___31 = 69,
    IPPORT_RJE___31 = 77,
    IPPORT_FINGER___31 = 79,
    IPPORT_TTYLINK___31 = 87,
    IPPORT_SUPDUP___31 = 95,
    IPPORT_EXECSERVER___31 = 512,
    IPPORT_LOGINSERVER___31 = 513,
    IPPORT_CMDSERVER___31 = 514,
    IPPORT_EFSSERVER___31 = 520,
    IPPORT_BIFFUDP___31 = 512,
    IPPORT_WHOSERVER___31 = 513,
    IPPORT_ROUTESERVER___31 = 520,
    IPPORT_RESERVED___31 = 1024,
    IPPORT_USERRESERVED___31 = 5000
} ;
enum __anonenum_18926444___31 {
    _ISupper___31 = 256,
    _ISlower___31 = 512,
    _ISalpha___31 = 1024,
    _ISdigit___31 = 2048,
    _ISxdigit___31 = 4096,
    _ISspace___31 = 8192,
    _ISprint___31 = 16384,
    _ISgraph___31 = 32768,
    _ISblank___31 = 1,
    _IScntrl___31 = 2,
    _ISpunct___31 = 4,
    _ISalnum___31 = 8
} ;
enum __anonenum_913965969___31 {
    FP_INT_UPWARD___31 = 0,
    FP_INT_DOWNWARD___31 = 1,
    FP_INT_TOWARDZERO___31 = 2,
    FP_INT_TONEARESTFROMZERO___31 = 3,
    FP_INT_TONEAREST___31 = 4
} ;
enum __anonenum_1037408945___31 {
    FP_NAN___31 = 0,
    FP_INFINITE___31 = 1,
    FP_ZERO___31 = 2,
    FP_SUBNORMAL___31 = 3,
    FP_NORMAL___31 = 4
} ;
enum __anonenum_556971655___31 {
    SI_ASYNCNL___31 = -60,
    SI_DETHREAD___31 = -7,
    SI_TKILL___31 = -6,
    SI_SIGIO___31 = -5,
    SI_ASYNCIO___31 = -4,
    SI_MESGQ___31 = -3,
    SI_TIMER___31 = -2,
    SI_QUEUE___31 = -1,
    SI_USER___31 = 0,
    SI_KERNEL___31 = 128
} ;
enum __anonenum_640648963___31 {
    ILL_ILLOPC___31 = 1,
    ILL_ILLOPN___31 = 2,
    ILL_ILLADR___31 = 3,
    ILL_ILLTRP___31 = 4,
    ILL_PRVOPC___31 = 5,
    ILL_PRVREG___31 = 6,
    ILL_COPROC___31 = 7,
    ILL_BADSTK___31 = 8,
    ILL_BADIADDR___31 = 9
} ;
enum __anonenum_457704180___31 {
    FPE_INTDIV___31 = 1,
    FPE_INTOVF___31 = 2,
    FPE_FLTDIV___31 = 3,
    FPE_FLTOVF___31 = 4,
    FPE_FLTUND___31 = 5,
    FPE_FLTRES___31 = 6,
    FPE_FLTINV___31 = 7,
    FPE_FLTSUB___31 = 8,
    FPE_FLTUNK___31 = 14,
    FPE_CONDTRAP___31 = 15
} ;
enum __anonenum_180375148___31 {
    SEGV_MAPERR___31 = 1,
    SEGV_ACCERR___31 = 2,
    SEGV_BNDERR___31 = 3,
    SEGV_PKUERR___31 = 4,
    SEGV_ACCADI___31 = 5,
    SEGV_ADIDERR___31 = 6,
    SEGV_ADIPERR___31 = 7,
    SEGV_MTEAERR___31 = 8,
    SEGV_MTESERR___31 = 9
} ;
enum __anonenum_1036286214___31 {
    BUS_ADRALN___31 = 1,
    BUS_ADRERR___31 = 2,
    BUS_OBJERR___31 = 3,
    BUS_MCEERR_AR___31 = 4,
    BUS_MCEERR_AO___31 = 5
} ;
enum __anonenum_91015150___31 {
    TRAP_BRKPT___31 = 1,
    TRAP_TRACE___31 = 2,
    TRAP_BRANCH___31 = 3,
    TRAP_HWBKPT___31 = 4,
    TRAP_UNK___31 = 5
} ;
enum __anonenum_23175539___31 {
    CLD_EXITED___31 = 1,
    CLD_KILLED___31 = 2,
    CLD_DUMPED___31 = 3,
    CLD_TRAPPED___31 = 4,
    CLD_STOPPED___31 = 5,
    CLD_CONTINUED___31 = 6
} ;
enum __anonenum_111643124___31 {
    POLL_IN___31 = 1,
    POLL_OUT___31 = 2,
    POLL_MSG___31 = 3,
    POLL_ERR___31 = 4,
    POLL_PRI___31 = 5,
    POLL_HUP___31 = 6
} ;
enum __anonenum_852341087___31 {
    SIGEV_SIGNAL___31 = 0,
    SIGEV_NONE___31 = 1,
    SIGEV_THREAD___31 = 2,
    SIGEV_THREAD_ID___31 = 4
} ;
enum __anonenum_451154152___31 {
    REG_R8___31 = 0,
    REG_R9___31 = 1,
    REG_R10___31 = 2,
    REG_R11___31 = 3,
    REG_R12___31 = 4,
    REG_R13___31 = 5,
    REG_R14___31 = 6,
    REG_R15___31 = 7,
    REG_RDI___31 = 8,
    REG_RSI___31 = 9,
    REG_RBP___31 = 10,
    REG_RBX___31 = 11,
    REG_RDX___31 = 12,
    REG_RAX___31 = 13,
    REG_RCX___31 = 14,
    REG_RSP___31 = 15,
    REG_RIP___31 = 16,
    REG_EFL___31 = 17,
    REG_CSGSFS___31 = 18,
    REG_ERR___31 = 19,
    REG_TRAPNO___31 = 20,
    REG_OLDMASK___31 = 21,
    REG_CR2___31 = 22
} ;
enum __anonenum_437032235___31 {
    _PC_LINK_MAX___31 = 0,
    _PC_MAX_CANON___31 = 1,
    _PC_MAX_INPUT___31 = 2,
    _PC_NAME_MAX___31 = 3,
    _PC_PATH_MAX___31 = 4,
    _PC_PIPE_BUF___31 = 5,
    _PC_CHOWN_RESTRICTED___31 = 6,
    _PC_NO_TRUNC___31 = 7,
    _PC_VDISABLE___31 = 8,
    _PC_SYNC_IO___31 = 9,
    _PC_ASYNC_IO___31 = 10,
    _PC_PRIO_IO___31 = 11,
    _PC_SOCK_MAXBUF___31 = 12,
    _PC_FILESIZEBITS___31 = 13,
    _PC_REC_INCR_XFER_SIZE___31 = 14,
    _PC_REC_MAX_XFER_SIZE___31 = 15,
    _PC_REC_MIN_XFER_SIZE___31 = 16,
    _PC_REC_XFER_ALIGN___31 = 17,
    _PC_ALLOC_SIZE_MIN___31 = 18,
    _PC_SYMLINK_MAX___31 = 19,
    _PC_2_SYMLINKS___31 = 20
} ;
enum __anonenum_315186338___31 {
    _SC_ARG_MAX___31 = 0,
    _SC_CHILD_MAX___31 = 1,
    _SC_CLK_TCK___31 = 2,
    _SC_NGROUPS_MAX___31 = 3,
    _SC_OPEN_MAX___31 = 4,
    _SC_STREAM_MAX___31 = 5,
    _SC_TZNAME_MAX___31 = 6,
    _SC_JOB_CONTROL___31 = 7,
    _SC_SAVED_IDS___31 = 8,
    _SC_REALTIME_SIGNALS___31 = 9,
    _SC_PRIORITY_SCHEDULING___31 = 10,
    _SC_TIMERS___31 = 11,
    _SC_ASYNCHRONOUS_IO___31 = 12,
    _SC_PRIORITIZED_IO___31 = 13,
    _SC_SYNCHRONIZED_IO___31 = 14,
    _SC_FSYNC___31 = 15,
    _SC_MAPPED_FILES___31 = 16,
    _SC_MEMLOCK___31 = 17,
    _SC_MEMLOCK_RANGE___31 = 18,
    _SC_MEMORY_PROTECTION___31 = 19,
    _SC_MESSAGE_PASSING___31 = 20,
    _SC_SEMAPHORES___31 = 21,
    _SC_SHARED_MEMORY_OBJECTS___31 = 22,
    _SC_AIO_LISTIO_MAX___31 = 23,
    _SC_AIO_MAX___31 = 24,
    _SC_AIO_PRIO_DELTA_MAX___31 = 25,
    _SC_DELAYTIMER_MAX___31 = 26,
    _SC_MQ_OPEN_MAX___31 = 27,
    _SC_MQ_PRIO_MAX___31 = 28,
    _SC_VERSION___31 = 29,
    _SC_PAGESIZE___31 = 30,
    _SC_RTSIG_MAX___31 = 31,
    _SC_SEM_NSEMS_MAX___31 = 32,
    _SC_SEM_VALUE_MAX___31 = 33,
    _SC_SIGQUEUE_MAX___31 = 34,
    _SC_TIMER_MAX___31 = 35,
    _SC_BC_BASE_MAX___31 = 36,
    _SC_BC_DIM_MAX___31 = 37,
    _SC_BC_SCALE_MAX___31 = 38,
    _SC_BC_STRING_MAX___31 = 39,
    _SC_COLL_WEIGHTS_MAX___31 = 40,
    _SC_EQUIV_CLASS_MAX___31 = 41,
    _SC_EXPR_NEST_MAX___31 = 42,
    _SC_LINE_MAX___31 = 43,
    _SC_RE_DUP_MAX___31 = 44,
    _SC_CHARCLASS_NAME_MAX___31 = 45,
    _SC_2_VERSION___31 = 46,
    _SC_2_C_BIND___31 = 47,
    _SC_2_C_DEV___31 = 48,
    _SC_2_FORT_DEV___31 = 49,
    _SC_2_FORT_RUN___31 = 50,
    _SC_2_SW_DEV___31 = 51,
    _SC_2_LOCALEDEF___31 = 52,
    _SC_PII___31 = 53,
    _SC_PII_XTI___31 = 54,
    _SC_PII_SOCKET___31 = 55,
    _SC_PII_INTERNET___31 = 56,
    _SC_PII_OSI___31 = 57,
    _SC_POLL___31 = 58,
    _SC_SELECT___31 = 59,
    _SC_UIO_MAXIOV___31 = 60,
    _SC_IOV_MAX___31 = 60,
    _SC_PII_INTERNET_STREAM___31 = 61,
    _SC_PII_INTERNET_DGRAM___31 = 62,
    _SC_PII_OSI_COTS___31 = 63,
    _SC_PII_OSI_CLTS___31 = 64,
    _SC_PII_OSI_M___31 = 65,
    _SC_T_IOV_MAX___31 = 66,
    _SC_THREADS___31 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___31 = 68,
    _SC_GETGR_R_SIZE_MAX___31 = 69,
    _SC_GETPW_R_SIZE_MAX___31 = 70,
    _SC_LOGIN_NAME_MAX___31 = 71,
    _SC_TTY_NAME_MAX___31 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___31 = 73,
    _SC_THREAD_KEYS_MAX___31 = 74,
    _SC_THREAD_STACK_MIN___31 = 75,
    _SC_THREAD_THREADS_MAX___31 = 76,
    _SC_THREAD_ATTR_STACKADDR___31 = 77,
    _SC_THREAD_ATTR_STACKSIZE___31 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___31 = 79,
    _SC_THREAD_PRIO_INHERIT___31 = 80,
    _SC_THREAD_PRIO_PROTECT___31 = 81,
    _SC_THREAD_PROCESS_SHARED___31 = 82,
    _SC_NPROCESSORS_CONF___31 = 83,
    _SC_NPROCESSORS_ONLN___31 = 84,
    _SC_PHYS_PAGES___31 = 85,
    _SC_AVPHYS_PAGES___31 = 86,
    _SC_ATEXIT_MAX___31 = 87,
    _SC_PASS_MAX___31 = 88,
    _SC_XOPEN_VERSION___31 = 89,
    _SC_XOPEN_XCU_VERSION___31 = 90,
    _SC_XOPEN_UNIX___31 = 91,
    _SC_XOPEN_CRYPT___31 = 92,
    _SC_XOPEN_ENH_I18N___31 = 93,
    _SC_XOPEN_SHM___31 = 94,
    _SC_2_CHAR_TERM___31 = 95,
    _SC_2_C_VERSION___31 = 96,
    _SC_2_UPE___31 = 97,
    _SC_XOPEN_XPG2___31 = 98,
    _SC_XOPEN_XPG3___31 = 99,
    _SC_XOPEN_XPG4___31 = 100,
    _SC_CHAR_BIT___31 = 101,
    _SC_CHAR_MAX___31 = 102,
    _SC_CHAR_MIN___31 = 103,
    _SC_INT_MAX___31 = 104,
    _SC_INT_MIN___31 = 105,
    _SC_LONG_BIT___31 = 106,
    _SC_WORD_BIT___31 = 107,
    _SC_MB_LEN_MAX___31 = 108,
    _SC_NZERO___31 = 109,
    _SC_SSIZE_MAX___31 = 110,
    _SC_SCHAR_MAX___31 = 111,
    _SC_SCHAR_MIN___31 = 112,
    _SC_SHRT_MAX___31 = 113,
    _SC_SHRT_MIN___31 = 114,
    _SC_UCHAR_MAX___31 = 115,
    _SC_UINT_MAX___31 = 116,
    _SC_ULONG_MAX___31 = 117,
    _SC_USHRT_MAX___31 = 118,
    _SC_NL_ARGMAX___31 = 119,
    _SC_NL_LANGMAX___31 = 120,
    _SC_NL_MSGMAX___31 = 121,
    _SC_NL_NMAX___31 = 122,
    _SC_NL_SETMAX___31 = 123,
    _SC_NL_TEXTMAX___31 = 124,
    _SC_XBS5_ILP32_OFF32___31 = 125,
    _SC_XBS5_ILP32_OFFBIG___31 = 126,
    _SC_XBS5_LP64_OFF64___31 = 127,
    _SC_XBS5_LPBIG_OFFBIG___31 = 128,
    _SC_XOPEN_LEGACY___31 = 129,
    _SC_XOPEN_REALTIME___31 = 130,
    _SC_XOPEN_REALTIME_THREADS___31 = 131,
    _SC_ADVISORY_INFO___31 = 132,
    _SC_BARRIERS___31 = 133,
    _SC_BASE___31 = 134,
    _SC_C_LANG_SUPPORT___31 = 135,
    _SC_C_LANG_SUPPORT_R___31 = 136,
    _SC_CLOCK_SELECTION___31 = 137,
    _SC_CPUTIME___31 = 138,
    _SC_THREAD_CPUTIME___31 = 139,
    _SC_DEVICE_IO___31 = 140,
    _SC_DEVICE_SPECIFIC___31 = 141,
    _SC_DEVICE_SPECIFIC_R___31 = 142,
    _SC_FD_MGMT___31 = 143,
    _SC_FIFO___31 = 144,
    _SC_PIPE___31 = 145,
    _SC_FILE_ATTRIBUTES___31 = 146,
    _SC_FILE_LOCKING___31 = 147,
    _SC_FILE_SYSTEM___31 = 148,
    _SC_MONOTONIC_CLOCK___31 = 149,
    _SC_MULTI_PROCESS___31 = 150,
    _SC_SINGLE_PROCESS___31 = 151,
    _SC_NETWORKING___31 = 152,
    _SC_READER_WRITER_LOCKS___31 = 153,
    _SC_SPIN_LOCKS___31 = 154,
    _SC_REGEXP___31 = 155,
    _SC_REGEX_VERSION___31 = 156,
    _SC_SHELL___31 = 157,
    _SC_SIGNALS___31 = 158,
    _SC_SPAWN___31 = 159,
    _SC_SPORADIC_SERVER___31 = 160,
    _SC_THREAD_SPORADIC_SERVER___31 = 161,
    _SC_SYSTEM_DATABASE___31 = 162,
    _SC_SYSTEM_DATABASE_R___31 = 163,
    _SC_TIMEOUTS___31 = 164,
    _SC_TYPED_MEMORY_OBJECTS___31 = 165,
    _SC_USER_GROUPS___31 = 166,
    _SC_USER_GROUPS_R___31 = 167,
    _SC_2_PBS___31 = 168,
    _SC_2_PBS_ACCOUNTING___31 = 169,
    _SC_2_PBS_LOCATE___31 = 170,
    _SC_2_PBS_MESSAGE___31 = 171,
    _SC_2_PBS_TRACK___31 = 172,
    _SC_SYMLOOP_MAX___31 = 173,
    _SC_STREAMS___31 = 174,
    _SC_2_PBS_CHECKPOINT___31 = 175,
    _SC_V6_ILP32_OFF32___31 = 176,
    _SC_V6_ILP32_OFFBIG___31 = 177,
    _SC_V6_LP64_OFF64___31 = 178,
    _SC_V6_LPBIG_OFFBIG___31 = 179,
    _SC_HOST_NAME_MAX___31 = 180,
    _SC_TRACE___31 = 181,
    _SC_TRACE_EVENT_FILTER___31 = 182,
    _SC_TRACE_INHERIT___31 = 183,
    _SC_TRACE_LOG___31 = 184,
    _SC_LEVEL1_ICACHE_SIZE___31 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___31 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___31 = 187,
    _SC_LEVEL1_DCACHE_SIZE___31 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___31 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___31 = 190,
    _SC_LEVEL2_CACHE_SIZE___31 = 191,
    _SC_LEVEL2_CACHE_ASSOC___31 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___31 = 193,
    _SC_LEVEL3_CACHE_SIZE___31 = 194,
    _SC_LEVEL3_CACHE_ASSOC___31 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___31 = 196,
    _SC_LEVEL4_CACHE_SIZE___31 = 197,
    _SC_LEVEL4_CACHE_ASSOC___31 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___31 = 199,
    _SC_IPV6___31 = 235,
    _SC_RAW_SOCKETS___31 = 236,
    _SC_V7_ILP32_OFF32___31 = 237,
    _SC_V7_ILP32_OFFBIG___31 = 238,
    _SC_V7_LP64_OFF64___31 = 239,
    _SC_V7_LPBIG_OFFBIG___31 = 240,
    _SC_SS_REPL_MAX___31 = 241,
    _SC_TRACE_EVENT_NAME_MAX___31 = 242,
    _SC_TRACE_NAME_MAX___31 = 243,
    _SC_TRACE_SYS_MAX___31 = 244,
    _SC_TRACE_USER_EVENT_MAX___31 = 245,
    _SC_XOPEN_STREAMS___31 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___31 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___31 = 248,
    _SC_MINSIGSTKSZ___31 = 249,
    _SC_SIGSTKSZ___31 = 250
} ;
enum __anonenum_875524036___31 {
    _CS_PATH___31 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___31 = 1,
    _CS_GNU_LIBC_VERSION___31 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___31 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___31 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___31 = 5,
    _CS_LFS_CFLAGS___31 = 1000,
    _CS_LFS_LDFLAGS___31 = 1001,
    _CS_LFS_LIBS___31 = 1002,
    _CS_LFS_LINTFLAGS___31 = 1003,
    _CS_LFS64_CFLAGS___31 = 1004,
    _CS_LFS64_LDFLAGS___31 = 1005,
    _CS_LFS64_LIBS___31 = 1006,
    _CS_LFS64_LINTFLAGS___31 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___31 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___31 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___31 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___31 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___31 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___31 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___31 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___31 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___31 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___31 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___31 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___31 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___31 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___31 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___31 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___31 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___31 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___31 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___31 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___31 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___31 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___31 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___31 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___31 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___31 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___31 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___31 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___31 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___31 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___31 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___31 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___31 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___31 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___31 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___31 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___31 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___31 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___31 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___31 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___31 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___31 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___31 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___31 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___31 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___31 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___31 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___31 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___31 = 1147,
    _CS_V6_ENV___31 = 1148,
    _CS_V7_ENV___31 = 1149
} ;
enum __anonenum_57186863___31 {
    SS_ONSTACK___31 = 1,
    SS_DISABLE___31 = 2
} ;
struct __anonstruct_SourceRecord_777368037 {
   NTP_Remote_Address *remote_addr ;
   NCR_Instance data ;
   char *name ;
   int pool_id ;
   int tentative ;
   uint32_t conf_id ;
};
typedef struct __anonstruct_SourceRecord_777368037 SourceRecord;
struct UnresolvedSource {
   NTP_Remote_Address address ;
   int pool_id ;
   char *name ;
   int random_order ;
   struct UnresolvedSource *next ;
};
struct SourcePool {
   int sources ;
   int unresolved_sources ;
   int confirmed_sources ;
   int max_sources ;
};
struct AddressUpdate {
   NTP_Remote_Address old_address ;
   NTP_Remote_Address new_address ;
};
enum __anonenum_83571709___32 {
    MSG_OOB___32 = 1,
    MSG_PEEK___32 = 2,
    MSG_DONTROUTE___32 = 4,
    MSG_TRYHARD___32 = 4,
    MSG_CTRUNC___32 = 8,
    MSG_PROXY___32 = 16,
    MSG_TRUNC___32 = 32,
    MSG_DONTWAIT___32 = 64,
    MSG_EOR___32 = 128,
    MSG_WAITALL___32 = 256,
    MSG_FIN___32 = 512,
    MSG_SYN___32 = 1024,
    MSG_CONFIRM___32 = 2048,
    MSG_RST___32 = 4096,
    MSG_ERRQUEUE___32 = 8192,
    MSG_NOSIGNAL___32 = 16384,
    MSG_MORE___32 = 32768,
    MSG_WAITFORONE___32 = 65536,
    MSG_BATCH___32 = 262144,
    MSG_ZEROCOPY___32 = 67108864,
    MSG_FASTOPEN___32 = 536870912,
    MSG_CMSG_CLOEXEC___32 = 1073741824
} ;
enum __anonenum_617082774___32 {
    SCM_RIGHTS___32 = 1,
    SCM_CREDENTIALS___32 = 2
} ;
enum __anonenum_606441560___32 {
    SHUT_RD___32 = 0,
    SHUT_WR___32 = 1,
    SHUT_RDWR___32 = 2
} ;
enum __anonenum_264779956___32 {
    IPPROTO_IP___32 = 0,
    IPPROTO_ICMP___32 = 1,
    IPPROTO_IGMP___32 = 2,
    IPPROTO_IPIP___32 = 4,
    IPPROTO_TCP___32 = 6,
    IPPROTO_EGP___32 = 8,
    IPPROTO_PUP___32 = 12,
    IPPROTO_UDP___32 = 17,
    IPPROTO_IDP___32 = 22,
    IPPROTO_TP___32 = 29,
    IPPROTO_DCCP___32 = 33,
    IPPROTO_IPV6___32 = 41,
    IPPROTO_RSVP___32 = 46,
    IPPROTO_GRE___32 = 47,
    IPPROTO_ESP___32 = 50,
    IPPROTO_AH___32 = 51,
    IPPROTO_MTP___32 = 92,
    IPPROTO_BEETPH___32 = 94,
    IPPROTO_ENCAP___32 = 98,
    IPPROTO_PIM___32 = 103,
    IPPROTO_COMP___32 = 108,
    IPPROTO_SCTP___32 = 132,
    IPPROTO_UDPLITE___32 = 136,
    IPPROTO_MPLS___32 = 137,
    IPPROTO_ETHERNET___32 = 143,
    IPPROTO_RAW___32 = 255,
    IPPROTO_MPTCP___32 = 262,
    IPPROTO_MAX___32 = 263
} ;
enum __anonenum_218739988___32 {
    IPPROTO_HOPOPTS___32 = 0,
    IPPROTO_ROUTING___32 = 43,
    IPPROTO_FRAGMENT___32 = 44,
    IPPROTO_ICMPV6___32 = 58,
    IPPROTO_NONE___32 = 59,
    IPPROTO_DSTOPTS___32 = 60,
    IPPROTO_MH___32 = 135
} ;
enum __anonenum_662268580___32 {
    IPPORT_ECHO___32 = 7,
    IPPORT_DISCARD___32 = 9,
    IPPORT_SYSTAT___32 = 11,
    IPPORT_DAYTIME___32 = 13,
    IPPORT_NETSTAT___32 = 15,
    IPPORT_FTP___32 = 21,
    IPPORT_TELNET___32 = 23,
    IPPORT_SMTP___32 = 25,
    IPPORT_TIMESERVER___32 = 37,
    IPPORT_NAMESERVER___32 = 42,
    IPPORT_WHOIS___32 = 43,
    IPPORT_MTP___32 = 57,
    IPPORT_TFTP___32 = 69,
    IPPORT_RJE___32 = 77,
    IPPORT_FINGER___32 = 79,
    IPPORT_TTYLINK___32 = 87,
    IPPORT_SUPDUP___32 = 95,
    IPPORT_EXECSERVER___32 = 512,
    IPPORT_LOGINSERVER___32 = 513,
    IPPORT_CMDSERVER___32 = 514,
    IPPORT_EFSSERVER___32 = 520,
    IPPORT_BIFFUDP___32 = 512,
    IPPORT_WHOSERVER___32 = 513,
    IPPORT_ROUTESERVER___32 = 520,
    IPPORT_RESERVED___32 = 1024,
    IPPORT_USERRESERVED___32 = 5000
} ;
enum __anonenum_18926444___32 {
    _ISupper___32 = 256,
    _ISlower___32 = 512,
    _ISalpha___32 = 1024,
    _ISdigit___32 = 2048,
    _ISxdigit___32 = 4096,
    _ISspace___32 = 8192,
    _ISprint___32 = 16384,
    _ISgraph___32 = 32768,
    _ISblank___32 = 1,
    _IScntrl___32 = 2,
    _ISpunct___32 = 4,
    _ISalnum___32 = 8
} ;
enum __anonenum_913965969___32 {
    FP_INT_UPWARD___32 = 0,
    FP_INT_DOWNWARD___32 = 1,
    FP_INT_TOWARDZERO___32 = 2,
    FP_INT_TONEARESTFROMZERO___32 = 3,
    FP_INT_TONEAREST___32 = 4
} ;
enum __anonenum_1037408945___32 {
    FP_NAN___32 = 0,
    FP_INFINITE___32 = 1,
    FP_ZERO___32 = 2,
    FP_SUBNORMAL___32 = 3,
    FP_NORMAL___32 = 4
} ;
enum __anonenum_556971655___32 {
    SI_ASYNCNL___32 = -60,
    SI_DETHREAD___32 = -7,
    SI_TKILL___32 = -6,
    SI_SIGIO___32 = -5,
    SI_ASYNCIO___32 = -4,
    SI_MESGQ___32 = -3,
    SI_TIMER___32 = -2,
    SI_QUEUE___32 = -1,
    SI_USER___32 = 0,
    SI_KERNEL___32 = 128
} ;
enum __anonenum_640648963___32 {
    ILL_ILLOPC___32 = 1,
    ILL_ILLOPN___32 = 2,
    ILL_ILLADR___32 = 3,
    ILL_ILLTRP___32 = 4,
    ILL_PRVOPC___32 = 5,
    ILL_PRVREG___32 = 6,
    ILL_COPROC___32 = 7,
    ILL_BADSTK___32 = 8,
    ILL_BADIADDR___32 = 9
} ;
enum __anonenum_457704180___32 {
    FPE_INTDIV___32 = 1,
    FPE_INTOVF___32 = 2,
    FPE_FLTDIV___32 = 3,
    FPE_FLTOVF___32 = 4,
    FPE_FLTUND___32 = 5,
    FPE_FLTRES___32 = 6,
    FPE_FLTINV___32 = 7,
    FPE_FLTSUB___32 = 8,
    FPE_FLTUNK___32 = 14,
    FPE_CONDTRAP___32 = 15
} ;
enum __anonenum_180375148___32 {
    SEGV_MAPERR___32 = 1,
    SEGV_ACCERR___32 = 2,
    SEGV_BNDERR___32 = 3,
    SEGV_PKUERR___32 = 4,
    SEGV_ACCADI___32 = 5,
    SEGV_ADIDERR___32 = 6,
    SEGV_ADIPERR___32 = 7,
    SEGV_MTEAERR___32 = 8,
    SEGV_MTESERR___32 = 9
} ;
enum __anonenum_1036286214___32 {
    BUS_ADRALN___32 = 1,
    BUS_ADRERR___32 = 2,
    BUS_OBJERR___32 = 3,
    BUS_MCEERR_AR___32 = 4,
    BUS_MCEERR_AO___32 = 5
} ;
enum __anonenum_91015150___32 {
    TRAP_BRKPT___32 = 1,
    TRAP_TRACE___32 = 2,
    TRAP_BRANCH___32 = 3,
    TRAP_HWBKPT___32 = 4,
    TRAP_UNK___32 = 5
} ;
enum __anonenum_23175539___32 {
    CLD_EXITED___32 = 1,
    CLD_KILLED___32 = 2,
    CLD_DUMPED___32 = 3,
    CLD_TRAPPED___32 = 4,
    CLD_STOPPED___32 = 5,
    CLD_CONTINUED___32 = 6
} ;
enum __anonenum_111643124___32 {
    POLL_IN___32 = 1,
    POLL_OUT___32 = 2,
    POLL_MSG___32 = 3,
    POLL_ERR___32 = 4,
    POLL_PRI___32 = 5,
    POLL_HUP___32 = 6
} ;
enum __anonenum_852341087___32 {
    SIGEV_SIGNAL___32 = 0,
    SIGEV_NONE___32 = 1,
    SIGEV_THREAD___32 = 2,
    SIGEV_THREAD_ID___32 = 4
} ;
enum __anonenum_451154152___32 {
    REG_R8___32 = 0,
    REG_R9___32 = 1,
    REG_R10___32 = 2,
    REG_R11___32 = 3,
    REG_R12___32 = 4,
    REG_R13___32 = 5,
    REG_R14___32 = 6,
    REG_R15___32 = 7,
    REG_RDI___32 = 8,
    REG_RSI___32 = 9,
    REG_RBP___32 = 10,
    REG_RBX___32 = 11,
    REG_RDX___32 = 12,
    REG_RAX___32 = 13,
    REG_RCX___32 = 14,
    REG_RSP___32 = 15,
    REG_RIP___32 = 16,
    REG_EFL___32 = 17,
    REG_CSGSFS___32 = 18,
    REG_ERR___32 = 19,
    REG_TRAPNO___32 = 20,
    REG_OLDMASK___32 = 21,
    REG_CR2___32 = 22
} ;
enum __anonenum_437032235___32 {
    _PC_LINK_MAX___32 = 0,
    _PC_MAX_CANON___32 = 1,
    _PC_MAX_INPUT___32 = 2,
    _PC_NAME_MAX___32 = 3,
    _PC_PATH_MAX___32 = 4,
    _PC_PIPE_BUF___32 = 5,
    _PC_CHOWN_RESTRICTED___32 = 6,
    _PC_NO_TRUNC___32 = 7,
    _PC_VDISABLE___32 = 8,
    _PC_SYNC_IO___32 = 9,
    _PC_ASYNC_IO___32 = 10,
    _PC_PRIO_IO___32 = 11,
    _PC_SOCK_MAXBUF___32 = 12,
    _PC_FILESIZEBITS___32 = 13,
    _PC_REC_INCR_XFER_SIZE___32 = 14,
    _PC_REC_MAX_XFER_SIZE___32 = 15,
    _PC_REC_MIN_XFER_SIZE___32 = 16,
    _PC_REC_XFER_ALIGN___32 = 17,
    _PC_ALLOC_SIZE_MIN___32 = 18,
    _PC_SYMLINK_MAX___32 = 19,
    _PC_2_SYMLINKS___32 = 20
} ;
enum __anonenum_315186338___32 {
    _SC_ARG_MAX___32 = 0,
    _SC_CHILD_MAX___32 = 1,
    _SC_CLK_TCK___32 = 2,
    _SC_NGROUPS_MAX___32 = 3,
    _SC_OPEN_MAX___32 = 4,
    _SC_STREAM_MAX___32 = 5,
    _SC_TZNAME_MAX___32 = 6,
    _SC_JOB_CONTROL___32 = 7,
    _SC_SAVED_IDS___32 = 8,
    _SC_REALTIME_SIGNALS___32 = 9,
    _SC_PRIORITY_SCHEDULING___32 = 10,
    _SC_TIMERS___32 = 11,
    _SC_ASYNCHRONOUS_IO___32 = 12,
    _SC_PRIORITIZED_IO___32 = 13,
    _SC_SYNCHRONIZED_IO___32 = 14,
    _SC_FSYNC___32 = 15,
    _SC_MAPPED_FILES___32 = 16,
    _SC_MEMLOCK___32 = 17,
    _SC_MEMLOCK_RANGE___32 = 18,
    _SC_MEMORY_PROTECTION___32 = 19,
    _SC_MESSAGE_PASSING___32 = 20,
    _SC_SEMAPHORES___32 = 21,
    _SC_SHARED_MEMORY_OBJECTS___32 = 22,
    _SC_AIO_LISTIO_MAX___32 = 23,
    _SC_AIO_MAX___32 = 24,
    _SC_AIO_PRIO_DELTA_MAX___32 = 25,
    _SC_DELAYTIMER_MAX___32 = 26,
    _SC_MQ_OPEN_MAX___32 = 27,
    _SC_MQ_PRIO_MAX___32 = 28,
    _SC_VERSION___32 = 29,
    _SC_PAGESIZE___32 = 30,
    _SC_RTSIG_MAX___32 = 31,
    _SC_SEM_NSEMS_MAX___32 = 32,
    _SC_SEM_VALUE_MAX___32 = 33,
    _SC_SIGQUEUE_MAX___32 = 34,
    _SC_TIMER_MAX___32 = 35,
    _SC_BC_BASE_MAX___32 = 36,
    _SC_BC_DIM_MAX___32 = 37,
    _SC_BC_SCALE_MAX___32 = 38,
    _SC_BC_STRING_MAX___32 = 39,
    _SC_COLL_WEIGHTS_MAX___32 = 40,
    _SC_EQUIV_CLASS_MAX___32 = 41,
    _SC_EXPR_NEST_MAX___32 = 42,
    _SC_LINE_MAX___32 = 43,
    _SC_RE_DUP_MAX___32 = 44,
    _SC_CHARCLASS_NAME_MAX___32 = 45,
    _SC_2_VERSION___32 = 46,
    _SC_2_C_BIND___32 = 47,
    _SC_2_C_DEV___32 = 48,
    _SC_2_FORT_DEV___32 = 49,
    _SC_2_FORT_RUN___32 = 50,
    _SC_2_SW_DEV___32 = 51,
    _SC_2_LOCALEDEF___32 = 52,
    _SC_PII___32 = 53,
    _SC_PII_XTI___32 = 54,
    _SC_PII_SOCKET___32 = 55,
    _SC_PII_INTERNET___32 = 56,
    _SC_PII_OSI___32 = 57,
    _SC_POLL___32 = 58,
    _SC_SELECT___32 = 59,
    _SC_UIO_MAXIOV___32 = 60,
    _SC_IOV_MAX___32 = 60,
    _SC_PII_INTERNET_STREAM___32 = 61,
    _SC_PII_INTERNET_DGRAM___32 = 62,
    _SC_PII_OSI_COTS___32 = 63,
    _SC_PII_OSI_CLTS___32 = 64,
    _SC_PII_OSI_M___32 = 65,
    _SC_T_IOV_MAX___32 = 66,
    _SC_THREADS___32 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___32 = 68,
    _SC_GETGR_R_SIZE_MAX___32 = 69,
    _SC_GETPW_R_SIZE_MAX___32 = 70,
    _SC_LOGIN_NAME_MAX___32 = 71,
    _SC_TTY_NAME_MAX___32 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___32 = 73,
    _SC_THREAD_KEYS_MAX___32 = 74,
    _SC_THREAD_STACK_MIN___32 = 75,
    _SC_THREAD_THREADS_MAX___32 = 76,
    _SC_THREAD_ATTR_STACKADDR___32 = 77,
    _SC_THREAD_ATTR_STACKSIZE___32 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___32 = 79,
    _SC_THREAD_PRIO_INHERIT___32 = 80,
    _SC_THREAD_PRIO_PROTECT___32 = 81,
    _SC_THREAD_PROCESS_SHARED___32 = 82,
    _SC_NPROCESSORS_CONF___32 = 83,
    _SC_NPROCESSORS_ONLN___32 = 84,
    _SC_PHYS_PAGES___32 = 85,
    _SC_AVPHYS_PAGES___32 = 86,
    _SC_ATEXIT_MAX___32 = 87,
    _SC_PASS_MAX___32 = 88,
    _SC_XOPEN_VERSION___32 = 89,
    _SC_XOPEN_XCU_VERSION___32 = 90,
    _SC_XOPEN_UNIX___32 = 91,
    _SC_XOPEN_CRYPT___32 = 92,
    _SC_XOPEN_ENH_I18N___32 = 93,
    _SC_XOPEN_SHM___32 = 94,
    _SC_2_CHAR_TERM___32 = 95,
    _SC_2_C_VERSION___32 = 96,
    _SC_2_UPE___32 = 97,
    _SC_XOPEN_XPG2___32 = 98,
    _SC_XOPEN_XPG3___32 = 99,
    _SC_XOPEN_XPG4___32 = 100,
    _SC_CHAR_BIT___32 = 101,
    _SC_CHAR_MAX___32 = 102,
    _SC_CHAR_MIN___32 = 103,
    _SC_INT_MAX___32 = 104,
    _SC_INT_MIN___32 = 105,
    _SC_LONG_BIT___32 = 106,
    _SC_WORD_BIT___32 = 107,
    _SC_MB_LEN_MAX___32 = 108,
    _SC_NZERO___32 = 109,
    _SC_SSIZE_MAX___32 = 110,
    _SC_SCHAR_MAX___32 = 111,
    _SC_SCHAR_MIN___32 = 112,
    _SC_SHRT_MAX___32 = 113,
    _SC_SHRT_MIN___32 = 114,
    _SC_UCHAR_MAX___32 = 115,
    _SC_UINT_MAX___32 = 116,
    _SC_ULONG_MAX___32 = 117,
    _SC_USHRT_MAX___32 = 118,
    _SC_NL_ARGMAX___32 = 119,
    _SC_NL_LANGMAX___32 = 120,
    _SC_NL_MSGMAX___32 = 121,
    _SC_NL_NMAX___32 = 122,
    _SC_NL_SETMAX___32 = 123,
    _SC_NL_TEXTMAX___32 = 124,
    _SC_XBS5_ILP32_OFF32___32 = 125,
    _SC_XBS5_ILP32_OFFBIG___32 = 126,
    _SC_XBS5_LP64_OFF64___32 = 127,
    _SC_XBS5_LPBIG_OFFBIG___32 = 128,
    _SC_XOPEN_LEGACY___32 = 129,
    _SC_XOPEN_REALTIME___32 = 130,
    _SC_XOPEN_REALTIME_THREADS___32 = 131,
    _SC_ADVISORY_INFO___32 = 132,
    _SC_BARRIERS___32 = 133,
    _SC_BASE___32 = 134,
    _SC_C_LANG_SUPPORT___32 = 135,
    _SC_C_LANG_SUPPORT_R___32 = 136,
    _SC_CLOCK_SELECTION___32 = 137,
    _SC_CPUTIME___32 = 138,
    _SC_THREAD_CPUTIME___32 = 139,
    _SC_DEVICE_IO___32 = 140,
    _SC_DEVICE_SPECIFIC___32 = 141,
    _SC_DEVICE_SPECIFIC_R___32 = 142,
    _SC_FD_MGMT___32 = 143,
    _SC_FIFO___32 = 144,
    _SC_PIPE___32 = 145,
    _SC_FILE_ATTRIBUTES___32 = 146,
    _SC_FILE_LOCKING___32 = 147,
    _SC_FILE_SYSTEM___32 = 148,
    _SC_MONOTONIC_CLOCK___32 = 149,
    _SC_MULTI_PROCESS___32 = 150,
    _SC_SINGLE_PROCESS___32 = 151,
    _SC_NETWORKING___32 = 152,
    _SC_READER_WRITER_LOCKS___32 = 153,
    _SC_SPIN_LOCKS___32 = 154,
    _SC_REGEXP___32 = 155,
    _SC_REGEX_VERSION___32 = 156,
    _SC_SHELL___32 = 157,
    _SC_SIGNALS___32 = 158,
    _SC_SPAWN___32 = 159,
    _SC_SPORADIC_SERVER___32 = 160,
    _SC_THREAD_SPORADIC_SERVER___32 = 161,
    _SC_SYSTEM_DATABASE___32 = 162,
    _SC_SYSTEM_DATABASE_R___32 = 163,
    _SC_TIMEOUTS___32 = 164,
    _SC_TYPED_MEMORY_OBJECTS___32 = 165,
    _SC_USER_GROUPS___32 = 166,
    _SC_USER_GROUPS_R___32 = 167,
    _SC_2_PBS___32 = 168,
    _SC_2_PBS_ACCOUNTING___32 = 169,
    _SC_2_PBS_LOCATE___32 = 170,
    _SC_2_PBS_MESSAGE___32 = 171,
    _SC_2_PBS_TRACK___32 = 172,
    _SC_SYMLOOP_MAX___32 = 173,
    _SC_STREAMS___32 = 174,
    _SC_2_PBS_CHECKPOINT___32 = 175,
    _SC_V6_ILP32_OFF32___32 = 176,
    _SC_V6_ILP32_OFFBIG___32 = 177,
    _SC_V6_LP64_OFF64___32 = 178,
    _SC_V6_LPBIG_OFFBIG___32 = 179,
    _SC_HOST_NAME_MAX___32 = 180,
    _SC_TRACE___32 = 181,
    _SC_TRACE_EVENT_FILTER___32 = 182,
    _SC_TRACE_INHERIT___32 = 183,
    _SC_TRACE_LOG___32 = 184,
    _SC_LEVEL1_ICACHE_SIZE___32 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___32 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___32 = 187,
    _SC_LEVEL1_DCACHE_SIZE___32 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___32 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___32 = 190,
    _SC_LEVEL2_CACHE_SIZE___32 = 191,
    _SC_LEVEL2_CACHE_ASSOC___32 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___32 = 193,
    _SC_LEVEL3_CACHE_SIZE___32 = 194,
    _SC_LEVEL3_CACHE_ASSOC___32 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___32 = 196,
    _SC_LEVEL4_CACHE_SIZE___32 = 197,
    _SC_LEVEL4_CACHE_ASSOC___32 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___32 = 199,
    _SC_IPV6___32 = 235,
    _SC_RAW_SOCKETS___32 = 236,
    _SC_V7_ILP32_OFF32___32 = 237,
    _SC_V7_ILP32_OFFBIG___32 = 238,
    _SC_V7_LP64_OFF64___32 = 239,
    _SC_V7_LPBIG_OFFBIG___32 = 240,
    _SC_SS_REPL_MAX___32 = 241,
    _SC_TRACE_EVENT_NAME_MAX___32 = 242,
    _SC_TRACE_NAME_MAX___32 = 243,
    _SC_TRACE_SYS_MAX___32 = 244,
    _SC_TRACE_USER_EVENT_MAX___32 = 245,
    _SC_XOPEN_STREAMS___32 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___32 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___32 = 248,
    _SC_MINSIGSTKSZ___32 = 249,
    _SC_SIGSTKSZ___32 = 250
} ;
enum __anonenum_875524036___32 {
    _CS_PATH___32 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___32 = 1,
    _CS_GNU_LIBC_VERSION___32 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___32 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___32 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___32 = 5,
    _CS_LFS_CFLAGS___32 = 1000,
    _CS_LFS_LDFLAGS___32 = 1001,
    _CS_LFS_LIBS___32 = 1002,
    _CS_LFS_LINTFLAGS___32 = 1003,
    _CS_LFS64_CFLAGS___32 = 1004,
    _CS_LFS64_LDFLAGS___32 = 1005,
    _CS_LFS64_LIBS___32 = 1006,
    _CS_LFS64_LINTFLAGS___32 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___32 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___32 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___32 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___32 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___32 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___32 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___32 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___32 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___32 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___32 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___32 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___32 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___32 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___32 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___32 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___32 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___32 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___32 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___32 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___32 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___32 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___32 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___32 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___32 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___32 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___32 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___32 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___32 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___32 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___32 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___32 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___32 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___32 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___32 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___32 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___32 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___32 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___32 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___32 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___32 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___32 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___32 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___32 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___32 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___32 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___32 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___32 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___32 = 1147,
    _CS_V6_ENV___32 = 1148,
    _CS_V7_ENV___32 = 1149
} ;
enum __anonenum_57186863___32 {
    SS_ONSTACK___32 = 1,
    SS_DISABLE___32 = 2
} ;
enum __anonenum_State_404766145 {
    DENY = 0,
    ALLOW = 1,
    AS_PARENT = 2
} ;
typedef enum __anonenum_State_404766145 State;
struct _TableNode {
   State state ;
   struct _TableNode *extended ;
};
typedef struct _TableNode TableNode;
struct ADF_AuthTableInst {
   TableNode base4 ;
   TableNode base6 ;
};
enum __anonenum_83571709___33 {
    MSG_OOB___33 = 1,
    MSG_PEEK___33 = 2,
    MSG_DONTROUTE___33 = 4,
    MSG_TRYHARD___33 = 4,
    MSG_CTRUNC___33 = 8,
    MSG_PROXY___33 = 16,
    MSG_TRUNC___33 = 32,
    MSG_DONTWAIT___33 = 64,
    MSG_EOR___33 = 128,
    MSG_WAITALL___33 = 256,
    MSG_FIN___33 = 512,
    MSG_SYN___33 = 1024,
    MSG_CONFIRM___33 = 2048,
    MSG_RST___33 = 4096,
    MSG_ERRQUEUE___33 = 8192,
    MSG_NOSIGNAL___33 = 16384,
    MSG_MORE___33 = 32768,
    MSG_WAITFORONE___33 = 65536,
    MSG_BATCH___33 = 262144,
    MSG_ZEROCOPY___33 = 67108864,
    MSG_FASTOPEN___33 = 536870912,
    MSG_CMSG_CLOEXEC___33 = 1073741824
} ;
enum __anonenum_617082774___33 {
    SCM_RIGHTS___33 = 1,
    SCM_CREDENTIALS___33 = 2
} ;
enum __anonenum_606441560___33 {
    SHUT_RD___33 = 0,
    SHUT_WR___33 = 1,
    SHUT_RDWR___33 = 2
} ;
enum __anonenum_264779956___33 {
    IPPROTO_IP___33 = 0,
    IPPROTO_ICMP___33 = 1,
    IPPROTO_IGMP___33 = 2,
    IPPROTO_IPIP___33 = 4,
    IPPROTO_TCP___33 = 6,
    IPPROTO_EGP___33 = 8,
    IPPROTO_PUP___33 = 12,
    IPPROTO_UDP___33 = 17,
    IPPROTO_IDP___33 = 22,
    IPPROTO_TP___33 = 29,
    IPPROTO_DCCP___33 = 33,
    IPPROTO_IPV6___33 = 41,
    IPPROTO_RSVP___33 = 46,
    IPPROTO_GRE___33 = 47,
    IPPROTO_ESP___33 = 50,
    IPPROTO_AH___33 = 51,
    IPPROTO_MTP___33 = 92,
    IPPROTO_BEETPH___33 = 94,
    IPPROTO_ENCAP___33 = 98,
    IPPROTO_PIM___33 = 103,
    IPPROTO_COMP___33 = 108,
    IPPROTO_SCTP___33 = 132,
    IPPROTO_UDPLITE___33 = 136,
    IPPROTO_MPLS___33 = 137,
    IPPROTO_ETHERNET___33 = 143,
    IPPROTO_RAW___33 = 255,
    IPPROTO_MPTCP___33 = 262,
    IPPROTO_MAX___33 = 263
} ;
enum __anonenum_218739988___33 {
    IPPROTO_HOPOPTS___33 = 0,
    IPPROTO_ROUTING___33 = 43,
    IPPROTO_FRAGMENT___33 = 44,
    IPPROTO_ICMPV6___33 = 58,
    IPPROTO_NONE___33 = 59,
    IPPROTO_DSTOPTS___33 = 60,
    IPPROTO_MH___33 = 135
} ;
enum __anonenum_662268580___33 {
    IPPORT_ECHO___33 = 7,
    IPPORT_DISCARD___33 = 9,
    IPPORT_SYSTAT___33 = 11,
    IPPORT_DAYTIME___33 = 13,
    IPPORT_NETSTAT___33 = 15,
    IPPORT_FTP___33 = 21,
    IPPORT_TELNET___33 = 23,
    IPPORT_SMTP___33 = 25,
    IPPORT_TIMESERVER___33 = 37,
    IPPORT_NAMESERVER___33 = 42,
    IPPORT_WHOIS___33 = 43,
    IPPORT_MTP___33 = 57,
    IPPORT_TFTP___33 = 69,
    IPPORT_RJE___33 = 77,
    IPPORT_FINGER___33 = 79,
    IPPORT_TTYLINK___33 = 87,
    IPPORT_SUPDUP___33 = 95,
    IPPORT_EXECSERVER___33 = 512,
    IPPORT_LOGINSERVER___33 = 513,
    IPPORT_CMDSERVER___33 = 514,
    IPPORT_EFSSERVER___33 = 520,
    IPPORT_BIFFUDP___33 = 512,
    IPPORT_WHOSERVER___33 = 513,
    IPPORT_ROUTESERVER___33 = 520,
    IPPORT_RESERVED___33 = 1024,
    IPPORT_USERRESERVED___33 = 5000
} ;
enum __anonenum_18926444___33 {
    _ISupper___33 = 256,
    _ISlower___33 = 512,
    _ISalpha___33 = 1024,
    _ISdigit___33 = 2048,
    _ISxdigit___33 = 4096,
    _ISspace___33 = 8192,
    _ISprint___33 = 16384,
    _ISgraph___33 = 32768,
    _ISblank___33 = 1,
    _IScntrl___33 = 2,
    _ISpunct___33 = 4,
    _ISalnum___33 = 8
} ;
enum __anonenum_913965969___33 {
    FP_INT_UPWARD___33 = 0,
    FP_INT_DOWNWARD___33 = 1,
    FP_INT_TOWARDZERO___33 = 2,
    FP_INT_TONEARESTFROMZERO___33 = 3,
    FP_INT_TONEAREST___33 = 4
} ;
enum __anonenum_1037408945___33 {
    FP_NAN___33 = 0,
    FP_INFINITE___33 = 1,
    FP_ZERO___33 = 2,
    FP_SUBNORMAL___33 = 3,
    FP_NORMAL___33 = 4
} ;
enum __anonenum_556971655___33 {
    SI_ASYNCNL___33 = -60,
    SI_DETHREAD___33 = -7,
    SI_TKILL___33 = -6,
    SI_SIGIO___33 = -5,
    SI_ASYNCIO___33 = -4,
    SI_MESGQ___33 = -3,
    SI_TIMER___33 = -2,
    SI_QUEUE___33 = -1,
    SI_USER___33 = 0,
    SI_KERNEL___33 = 128
} ;
enum __anonenum_640648963___33 {
    ILL_ILLOPC___33 = 1,
    ILL_ILLOPN___33 = 2,
    ILL_ILLADR___33 = 3,
    ILL_ILLTRP___33 = 4,
    ILL_PRVOPC___33 = 5,
    ILL_PRVREG___33 = 6,
    ILL_COPROC___33 = 7,
    ILL_BADSTK___33 = 8,
    ILL_BADIADDR___33 = 9
} ;
enum __anonenum_457704180___33 {
    FPE_INTDIV___33 = 1,
    FPE_INTOVF___33 = 2,
    FPE_FLTDIV___33 = 3,
    FPE_FLTOVF___33 = 4,
    FPE_FLTUND___33 = 5,
    FPE_FLTRES___33 = 6,
    FPE_FLTINV___33 = 7,
    FPE_FLTSUB___33 = 8,
    FPE_FLTUNK___33 = 14,
    FPE_CONDTRAP___33 = 15
} ;
enum __anonenum_180375148___33 {
    SEGV_MAPERR___33 = 1,
    SEGV_ACCERR___33 = 2,
    SEGV_BNDERR___33 = 3,
    SEGV_PKUERR___33 = 4,
    SEGV_ACCADI___33 = 5,
    SEGV_ADIDERR___33 = 6,
    SEGV_ADIPERR___33 = 7,
    SEGV_MTEAERR___33 = 8,
    SEGV_MTESERR___33 = 9
} ;
enum __anonenum_1036286214___33 {
    BUS_ADRALN___33 = 1,
    BUS_ADRERR___33 = 2,
    BUS_OBJERR___33 = 3,
    BUS_MCEERR_AR___33 = 4,
    BUS_MCEERR_AO___33 = 5
} ;
enum __anonenum_91015150___33 {
    TRAP_BRKPT___33 = 1,
    TRAP_TRACE___33 = 2,
    TRAP_BRANCH___33 = 3,
    TRAP_HWBKPT___33 = 4,
    TRAP_UNK___33 = 5
} ;
enum __anonenum_23175539___33 {
    CLD_EXITED___33 = 1,
    CLD_KILLED___33 = 2,
    CLD_DUMPED___33 = 3,
    CLD_TRAPPED___33 = 4,
    CLD_STOPPED___33 = 5,
    CLD_CONTINUED___33 = 6
} ;
enum __anonenum_111643124___33 {
    POLL_IN___33 = 1,
    POLL_OUT___33 = 2,
    POLL_MSG___33 = 3,
    POLL_ERR___33 = 4,
    POLL_PRI___33 = 5,
    POLL_HUP___33 = 6
} ;
enum __anonenum_852341087___33 {
    SIGEV_SIGNAL___33 = 0,
    SIGEV_NONE___33 = 1,
    SIGEV_THREAD___33 = 2,
    SIGEV_THREAD_ID___33 = 4
} ;
enum __anonenum_451154152___33 {
    REG_R8___33 = 0,
    REG_R9___33 = 1,
    REG_R10___33 = 2,
    REG_R11___33 = 3,
    REG_R12___33 = 4,
    REG_R13___33 = 5,
    REG_R14___33 = 6,
    REG_R15___33 = 7,
    REG_RDI___33 = 8,
    REG_RSI___33 = 9,
    REG_RBP___33 = 10,
    REG_RBX___33 = 11,
    REG_RDX___33 = 12,
    REG_RAX___33 = 13,
    REG_RCX___33 = 14,
    REG_RSP___33 = 15,
    REG_RIP___33 = 16,
    REG_EFL___33 = 17,
    REG_CSGSFS___33 = 18,
    REG_ERR___33 = 19,
    REG_TRAPNO___33 = 20,
    REG_OLDMASK___33 = 21,
    REG_CR2___33 = 22
} ;
enum __anonenum_437032235___33 {
    _PC_LINK_MAX___33 = 0,
    _PC_MAX_CANON___33 = 1,
    _PC_MAX_INPUT___33 = 2,
    _PC_NAME_MAX___33 = 3,
    _PC_PATH_MAX___33 = 4,
    _PC_PIPE_BUF___33 = 5,
    _PC_CHOWN_RESTRICTED___33 = 6,
    _PC_NO_TRUNC___33 = 7,
    _PC_VDISABLE___33 = 8,
    _PC_SYNC_IO___33 = 9,
    _PC_ASYNC_IO___33 = 10,
    _PC_PRIO_IO___33 = 11,
    _PC_SOCK_MAXBUF___33 = 12,
    _PC_FILESIZEBITS___33 = 13,
    _PC_REC_INCR_XFER_SIZE___33 = 14,
    _PC_REC_MAX_XFER_SIZE___33 = 15,
    _PC_REC_MIN_XFER_SIZE___33 = 16,
    _PC_REC_XFER_ALIGN___33 = 17,
    _PC_ALLOC_SIZE_MIN___33 = 18,
    _PC_SYMLINK_MAX___33 = 19,
    _PC_2_SYMLINKS___33 = 20
} ;
enum __anonenum_315186338___33 {
    _SC_ARG_MAX___33 = 0,
    _SC_CHILD_MAX___33 = 1,
    _SC_CLK_TCK___33 = 2,
    _SC_NGROUPS_MAX___33 = 3,
    _SC_OPEN_MAX___33 = 4,
    _SC_STREAM_MAX___33 = 5,
    _SC_TZNAME_MAX___33 = 6,
    _SC_JOB_CONTROL___33 = 7,
    _SC_SAVED_IDS___33 = 8,
    _SC_REALTIME_SIGNALS___33 = 9,
    _SC_PRIORITY_SCHEDULING___33 = 10,
    _SC_TIMERS___33 = 11,
    _SC_ASYNCHRONOUS_IO___33 = 12,
    _SC_PRIORITIZED_IO___33 = 13,
    _SC_SYNCHRONIZED_IO___33 = 14,
    _SC_FSYNC___33 = 15,
    _SC_MAPPED_FILES___33 = 16,
    _SC_MEMLOCK___33 = 17,
    _SC_MEMLOCK_RANGE___33 = 18,
    _SC_MEMORY_PROTECTION___33 = 19,
    _SC_MESSAGE_PASSING___33 = 20,
    _SC_SEMAPHORES___33 = 21,
    _SC_SHARED_MEMORY_OBJECTS___33 = 22,
    _SC_AIO_LISTIO_MAX___33 = 23,
    _SC_AIO_MAX___33 = 24,
    _SC_AIO_PRIO_DELTA_MAX___33 = 25,
    _SC_DELAYTIMER_MAX___33 = 26,
    _SC_MQ_OPEN_MAX___33 = 27,
    _SC_MQ_PRIO_MAX___33 = 28,
    _SC_VERSION___33 = 29,
    _SC_PAGESIZE___33 = 30,
    _SC_RTSIG_MAX___33 = 31,
    _SC_SEM_NSEMS_MAX___33 = 32,
    _SC_SEM_VALUE_MAX___33 = 33,
    _SC_SIGQUEUE_MAX___33 = 34,
    _SC_TIMER_MAX___33 = 35,
    _SC_BC_BASE_MAX___33 = 36,
    _SC_BC_DIM_MAX___33 = 37,
    _SC_BC_SCALE_MAX___33 = 38,
    _SC_BC_STRING_MAX___33 = 39,
    _SC_COLL_WEIGHTS_MAX___33 = 40,
    _SC_EQUIV_CLASS_MAX___33 = 41,
    _SC_EXPR_NEST_MAX___33 = 42,
    _SC_LINE_MAX___33 = 43,
    _SC_RE_DUP_MAX___33 = 44,
    _SC_CHARCLASS_NAME_MAX___33 = 45,
    _SC_2_VERSION___33 = 46,
    _SC_2_C_BIND___33 = 47,
    _SC_2_C_DEV___33 = 48,
    _SC_2_FORT_DEV___33 = 49,
    _SC_2_FORT_RUN___33 = 50,
    _SC_2_SW_DEV___33 = 51,
    _SC_2_LOCALEDEF___33 = 52,
    _SC_PII___33 = 53,
    _SC_PII_XTI___33 = 54,
    _SC_PII_SOCKET___33 = 55,
    _SC_PII_INTERNET___33 = 56,
    _SC_PII_OSI___33 = 57,
    _SC_POLL___33 = 58,
    _SC_SELECT___33 = 59,
    _SC_UIO_MAXIOV___33 = 60,
    _SC_IOV_MAX___33 = 60,
    _SC_PII_INTERNET_STREAM___33 = 61,
    _SC_PII_INTERNET_DGRAM___33 = 62,
    _SC_PII_OSI_COTS___33 = 63,
    _SC_PII_OSI_CLTS___33 = 64,
    _SC_PII_OSI_M___33 = 65,
    _SC_T_IOV_MAX___33 = 66,
    _SC_THREADS___33 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___33 = 68,
    _SC_GETGR_R_SIZE_MAX___33 = 69,
    _SC_GETPW_R_SIZE_MAX___33 = 70,
    _SC_LOGIN_NAME_MAX___33 = 71,
    _SC_TTY_NAME_MAX___33 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___33 = 73,
    _SC_THREAD_KEYS_MAX___33 = 74,
    _SC_THREAD_STACK_MIN___33 = 75,
    _SC_THREAD_THREADS_MAX___33 = 76,
    _SC_THREAD_ATTR_STACKADDR___33 = 77,
    _SC_THREAD_ATTR_STACKSIZE___33 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___33 = 79,
    _SC_THREAD_PRIO_INHERIT___33 = 80,
    _SC_THREAD_PRIO_PROTECT___33 = 81,
    _SC_THREAD_PROCESS_SHARED___33 = 82,
    _SC_NPROCESSORS_CONF___33 = 83,
    _SC_NPROCESSORS_ONLN___33 = 84,
    _SC_PHYS_PAGES___33 = 85,
    _SC_AVPHYS_PAGES___33 = 86,
    _SC_ATEXIT_MAX___33 = 87,
    _SC_PASS_MAX___33 = 88,
    _SC_XOPEN_VERSION___33 = 89,
    _SC_XOPEN_XCU_VERSION___33 = 90,
    _SC_XOPEN_UNIX___33 = 91,
    _SC_XOPEN_CRYPT___33 = 92,
    _SC_XOPEN_ENH_I18N___33 = 93,
    _SC_XOPEN_SHM___33 = 94,
    _SC_2_CHAR_TERM___33 = 95,
    _SC_2_C_VERSION___33 = 96,
    _SC_2_UPE___33 = 97,
    _SC_XOPEN_XPG2___33 = 98,
    _SC_XOPEN_XPG3___33 = 99,
    _SC_XOPEN_XPG4___33 = 100,
    _SC_CHAR_BIT___33 = 101,
    _SC_CHAR_MAX___33 = 102,
    _SC_CHAR_MIN___33 = 103,
    _SC_INT_MAX___33 = 104,
    _SC_INT_MIN___33 = 105,
    _SC_LONG_BIT___33 = 106,
    _SC_WORD_BIT___33 = 107,
    _SC_MB_LEN_MAX___33 = 108,
    _SC_NZERO___33 = 109,
    _SC_SSIZE_MAX___33 = 110,
    _SC_SCHAR_MAX___33 = 111,
    _SC_SCHAR_MIN___33 = 112,
    _SC_SHRT_MAX___33 = 113,
    _SC_SHRT_MIN___33 = 114,
    _SC_UCHAR_MAX___33 = 115,
    _SC_UINT_MAX___33 = 116,
    _SC_ULONG_MAX___33 = 117,
    _SC_USHRT_MAX___33 = 118,
    _SC_NL_ARGMAX___33 = 119,
    _SC_NL_LANGMAX___33 = 120,
    _SC_NL_MSGMAX___33 = 121,
    _SC_NL_NMAX___33 = 122,
    _SC_NL_SETMAX___33 = 123,
    _SC_NL_TEXTMAX___33 = 124,
    _SC_XBS5_ILP32_OFF32___33 = 125,
    _SC_XBS5_ILP32_OFFBIG___33 = 126,
    _SC_XBS5_LP64_OFF64___33 = 127,
    _SC_XBS5_LPBIG_OFFBIG___33 = 128,
    _SC_XOPEN_LEGACY___33 = 129,
    _SC_XOPEN_REALTIME___33 = 130,
    _SC_XOPEN_REALTIME_THREADS___33 = 131,
    _SC_ADVISORY_INFO___33 = 132,
    _SC_BARRIERS___33 = 133,
    _SC_BASE___33 = 134,
    _SC_C_LANG_SUPPORT___33 = 135,
    _SC_C_LANG_SUPPORT_R___33 = 136,
    _SC_CLOCK_SELECTION___33 = 137,
    _SC_CPUTIME___33 = 138,
    _SC_THREAD_CPUTIME___33 = 139,
    _SC_DEVICE_IO___33 = 140,
    _SC_DEVICE_SPECIFIC___33 = 141,
    _SC_DEVICE_SPECIFIC_R___33 = 142,
    _SC_FD_MGMT___33 = 143,
    _SC_FIFO___33 = 144,
    _SC_PIPE___33 = 145,
    _SC_FILE_ATTRIBUTES___33 = 146,
    _SC_FILE_LOCKING___33 = 147,
    _SC_FILE_SYSTEM___33 = 148,
    _SC_MONOTONIC_CLOCK___33 = 149,
    _SC_MULTI_PROCESS___33 = 150,
    _SC_SINGLE_PROCESS___33 = 151,
    _SC_NETWORKING___33 = 152,
    _SC_READER_WRITER_LOCKS___33 = 153,
    _SC_SPIN_LOCKS___33 = 154,
    _SC_REGEXP___33 = 155,
    _SC_REGEX_VERSION___33 = 156,
    _SC_SHELL___33 = 157,
    _SC_SIGNALS___33 = 158,
    _SC_SPAWN___33 = 159,
    _SC_SPORADIC_SERVER___33 = 160,
    _SC_THREAD_SPORADIC_SERVER___33 = 161,
    _SC_SYSTEM_DATABASE___33 = 162,
    _SC_SYSTEM_DATABASE_R___33 = 163,
    _SC_TIMEOUTS___33 = 164,
    _SC_TYPED_MEMORY_OBJECTS___33 = 165,
    _SC_USER_GROUPS___33 = 166,
    _SC_USER_GROUPS_R___33 = 167,
    _SC_2_PBS___33 = 168,
    _SC_2_PBS_ACCOUNTING___33 = 169,
    _SC_2_PBS_LOCATE___33 = 170,
    _SC_2_PBS_MESSAGE___33 = 171,
    _SC_2_PBS_TRACK___33 = 172,
    _SC_SYMLOOP_MAX___33 = 173,
    _SC_STREAMS___33 = 174,
    _SC_2_PBS_CHECKPOINT___33 = 175,
    _SC_V6_ILP32_OFF32___33 = 176,
    _SC_V6_ILP32_OFFBIG___33 = 177,
    _SC_V6_LP64_OFF64___33 = 178,
    _SC_V6_LPBIG_OFFBIG___33 = 179,
    _SC_HOST_NAME_MAX___33 = 180,
    _SC_TRACE___33 = 181,
    _SC_TRACE_EVENT_FILTER___33 = 182,
    _SC_TRACE_INHERIT___33 = 183,
    _SC_TRACE_LOG___33 = 184,
    _SC_LEVEL1_ICACHE_SIZE___33 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___33 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___33 = 187,
    _SC_LEVEL1_DCACHE_SIZE___33 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___33 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___33 = 190,
    _SC_LEVEL2_CACHE_SIZE___33 = 191,
    _SC_LEVEL2_CACHE_ASSOC___33 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___33 = 193,
    _SC_LEVEL3_CACHE_SIZE___33 = 194,
    _SC_LEVEL3_CACHE_ASSOC___33 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___33 = 196,
    _SC_LEVEL4_CACHE_SIZE___33 = 197,
    _SC_LEVEL4_CACHE_ASSOC___33 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___33 = 199,
    _SC_IPV6___33 = 235,
    _SC_RAW_SOCKETS___33 = 236,
    _SC_V7_ILP32_OFF32___33 = 237,
    _SC_V7_ILP32_OFFBIG___33 = 238,
    _SC_V7_LP64_OFF64___33 = 239,
    _SC_V7_LPBIG_OFFBIG___33 = 240,
    _SC_SS_REPL_MAX___33 = 241,
    _SC_TRACE_EVENT_NAME_MAX___33 = 242,
    _SC_TRACE_NAME_MAX___33 = 243,
    _SC_TRACE_SYS_MAX___33 = 244,
    _SC_TRACE_USER_EVENT_MAX___33 = 245,
    _SC_XOPEN_STREAMS___33 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___33 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___33 = 248,
    _SC_MINSIGSTKSZ___33 = 249,
    _SC_SIGSTKSZ___33 = 250
} ;
enum __anonenum_875524036___33 {
    _CS_PATH___33 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___33 = 1,
    _CS_GNU_LIBC_VERSION___33 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___33 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___33 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___33 = 5,
    _CS_LFS_CFLAGS___33 = 1000,
    _CS_LFS_LDFLAGS___33 = 1001,
    _CS_LFS_LIBS___33 = 1002,
    _CS_LFS_LINTFLAGS___33 = 1003,
    _CS_LFS64_CFLAGS___33 = 1004,
    _CS_LFS64_LDFLAGS___33 = 1005,
    _CS_LFS64_LIBS___33 = 1006,
    _CS_LFS64_LINTFLAGS___33 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___33 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___33 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___33 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___33 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___33 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___33 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___33 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___33 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___33 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___33 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___33 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___33 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___33 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___33 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___33 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___33 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___33 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___33 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___33 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___33 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___33 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___33 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___33 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___33 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___33 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___33 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___33 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___33 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___33 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___33 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___33 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___33 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___33 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___33 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___33 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___33 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___33 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___33 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___33 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___33 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___33 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___33 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___33 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___33 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___33 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___33 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___33 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___33 = 1147,
    _CS_V6_ENV___33 = 1148,
    _CS_V7_ENV___33 = 1149
} ;
enum __anonenum_57186863___33 {
    SS_ONSTACK___33 = 1,
    SS_DISABLE___33 = 2
} ;
struct __anonstruct_Record_403763747 {
   IPAddr ip_addr ;
   uint32_t last_hit[3] ;
   uint32_t hits[3] ;
   uint16_t drops[3] ;
   uint16_t tokens[3] ;
   int8_t rate[3] ;
   int8_t ntp_timeout_rate ;
   uint8_t drop_flags ;
};
typedef struct __anonstruct_Record_403763747 Record;
struct __anonstruct_NtpTimestamps_273571777 {
   uint64_t rx_ts ;
   uint16_t flags ;
   uint16_t slew_epoch ;
   int32_t tx_ts_offset ;
};
typedef struct __anonstruct_NtpTimestamps_273571777 NtpTimestamps;
struct __anonstruct_NtpTimestampMap_841515927 {
   ARR_Instance timestamps ;
   uint32_t first ;
   uint32_t size ;
   uint32_t max_size ;
   uint32_t cached_index ;
   uint64_t cached_rx_ts ;
   uint16_t slew_epoch ;
   double slew_offset ;
};
typedef struct __anonstruct_NtpTimestampMap_841515927 NtpTimestampMap;
enum __anonenum_83571709___34 {
    MSG_OOB___34 = 1,
    MSG_PEEK___34 = 2,
    MSG_DONTROUTE___34 = 4,
    MSG_TRYHARD___34 = 4,
    MSG_CTRUNC___34 = 8,
    MSG_PROXY___34 = 16,
    MSG_TRUNC___34 = 32,
    MSG_DONTWAIT___34 = 64,
    MSG_EOR___34 = 128,
    MSG_WAITALL___34 = 256,
    MSG_FIN___34 = 512,
    MSG_SYN___34 = 1024,
    MSG_CONFIRM___34 = 2048,
    MSG_RST___34 = 4096,
    MSG_ERRQUEUE___34 = 8192,
    MSG_NOSIGNAL___34 = 16384,
    MSG_MORE___34 = 32768,
    MSG_WAITFORONE___34 = 65536,
    MSG_BATCH___34 = 262144,
    MSG_ZEROCOPY___34 = 67108864,
    MSG_FASTOPEN___34 = 536870912,
    MSG_CMSG_CLOEXEC___34 = 1073741824
} ;
enum __anonenum_617082774___34 {
    SCM_RIGHTS___34 = 1,
    SCM_CREDENTIALS___34 = 2
} ;
enum __anonenum_606441560___34 {
    SHUT_RD___34 = 0,
    SHUT_WR___34 = 1,
    SHUT_RDWR___34 = 2
} ;
enum __anonenum_264779956___34 {
    IPPROTO_IP___34 = 0,
    IPPROTO_ICMP___34 = 1,
    IPPROTO_IGMP___34 = 2,
    IPPROTO_IPIP___34 = 4,
    IPPROTO_TCP___34 = 6,
    IPPROTO_EGP___34 = 8,
    IPPROTO_PUP___34 = 12,
    IPPROTO_UDP___34 = 17,
    IPPROTO_IDP___34 = 22,
    IPPROTO_TP___34 = 29,
    IPPROTO_DCCP___34 = 33,
    IPPROTO_IPV6___34 = 41,
    IPPROTO_RSVP___34 = 46,
    IPPROTO_GRE___34 = 47,
    IPPROTO_ESP___34 = 50,
    IPPROTO_AH___34 = 51,
    IPPROTO_MTP___34 = 92,
    IPPROTO_BEETPH___34 = 94,
    IPPROTO_ENCAP___34 = 98,
    IPPROTO_PIM___34 = 103,
    IPPROTO_COMP___34 = 108,
    IPPROTO_SCTP___34 = 132,
    IPPROTO_UDPLITE___34 = 136,
    IPPROTO_MPLS___34 = 137,
    IPPROTO_ETHERNET___34 = 143,
    IPPROTO_RAW___34 = 255,
    IPPROTO_MPTCP___34 = 262,
    IPPROTO_MAX___34 = 263
} ;
enum __anonenum_218739988___34 {
    IPPROTO_HOPOPTS___34 = 0,
    IPPROTO_ROUTING___34 = 43,
    IPPROTO_FRAGMENT___34 = 44,
    IPPROTO_ICMPV6___34 = 58,
    IPPROTO_NONE___34 = 59,
    IPPROTO_DSTOPTS___34 = 60,
    IPPROTO_MH___34 = 135
} ;
enum __anonenum_662268580___34 {
    IPPORT_ECHO___34 = 7,
    IPPORT_DISCARD___34 = 9,
    IPPORT_SYSTAT___34 = 11,
    IPPORT_DAYTIME___34 = 13,
    IPPORT_NETSTAT___34 = 15,
    IPPORT_FTP___34 = 21,
    IPPORT_TELNET___34 = 23,
    IPPORT_SMTP___34 = 25,
    IPPORT_TIMESERVER___34 = 37,
    IPPORT_NAMESERVER___34 = 42,
    IPPORT_WHOIS___34 = 43,
    IPPORT_MTP___34 = 57,
    IPPORT_TFTP___34 = 69,
    IPPORT_RJE___34 = 77,
    IPPORT_FINGER___34 = 79,
    IPPORT_TTYLINK___34 = 87,
    IPPORT_SUPDUP___34 = 95,
    IPPORT_EXECSERVER___34 = 512,
    IPPORT_LOGINSERVER___34 = 513,
    IPPORT_CMDSERVER___34 = 514,
    IPPORT_EFSSERVER___34 = 520,
    IPPORT_BIFFUDP___34 = 512,
    IPPORT_WHOSERVER___34 = 513,
    IPPORT_ROUTESERVER___34 = 520,
    IPPORT_RESERVED___34 = 1024,
    IPPORT_USERRESERVED___34 = 5000
} ;
enum __anonenum_18926444___34 {
    _ISupper___34 = 256,
    _ISlower___34 = 512,
    _ISalpha___34 = 1024,
    _ISdigit___34 = 2048,
    _ISxdigit___34 = 4096,
    _ISspace___34 = 8192,
    _ISprint___34 = 16384,
    _ISgraph___34 = 32768,
    _ISblank___34 = 1,
    _IScntrl___34 = 2,
    _ISpunct___34 = 4,
    _ISalnum___34 = 8
} ;
enum __anonenum_913965969___34 {
    FP_INT_UPWARD___34 = 0,
    FP_INT_DOWNWARD___34 = 1,
    FP_INT_TOWARDZERO___34 = 2,
    FP_INT_TONEARESTFROMZERO___34 = 3,
    FP_INT_TONEAREST___34 = 4
} ;
enum __anonenum_1037408945___34 {
    FP_NAN___34 = 0,
    FP_INFINITE___34 = 1,
    FP_ZERO___34 = 2,
    FP_SUBNORMAL___34 = 3,
    FP_NORMAL___34 = 4
} ;
enum __anonenum_556971655___34 {
    SI_ASYNCNL___34 = -60,
    SI_DETHREAD___34 = -7,
    SI_TKILL___34 = -6,
    SI_SIGIO___34 = -5,
    SI_ASYNCIO___34 = -4,
    SI_MESGQ___34 = -3,
    SI_TIMER___34 = -2,
    SI_QUEUE___34 = -1,
    SI_USER___34 = 0,
    SI_KERNEL___34 = 128
} ;
enum __anonenum_640648963___34 {
    ILL_ILLOPC___34 = 1,
    ILL_ILLOPN___34 = 2,
    ILL_ILLADR___34 = 3,
    ILL_ILLTRP___34 = 4,
    ILL_PRVOPC___34 = 5,
    ILL_PRVREG___34 = 6,
    ILL_COPROC___34 = 7,
    ILL_BADSTK___34 = 8,
    ILL_BADIADDR___34 = 9
} ;
enum __anonenum_457704180___34 {
    FPE_INTDIV___34 = 1,
    FPE_INTOVF___34 = 2,
    FPE_FLTDIV___34 = 3,
    FPE_FLTOVF___34 = 4,
    FPE_FLTUND___34 = 5,
    FPE_FLTRES___34 = 6,
    FPE_FLTINV___34 = 7,
    FPE_FLTSUB___34 = 8,
    FPE_FLTUNK___34 = 14,
    FPE_CONDTRAP___34 = 15
} ;
enum __anonenum_180375148___34 {
    SEGV_MAPERR___34 = 1,
    SEGV_ACCERR___34 = 2,
    SEGV_BNDERR___34 = 3,
    SEGV_PKUERR___34 = 4,
    SEGV_ACCADI___34 = 5,
    SEGV_ADIDERR___34 = 6,
    SEGV_ADIPERR___34 = 7,
    SEGV_MTEAERR___34 = 8,
    SEGV_MTESERR___34 = 9
} ;
enum __anonenum_1036286214___34 {
    BUS_ADRALN___34 = 1,
    BUS_ADRERR___34 = 2,
    BUS_OBJERR___34 = 3,
    BUS_MCEERR_AR___34 = 4,
    BUS_MCEERR_AO___34 = 5
} ;
enum __anonenum_91015150___34 {
    TRAP_BRKPT___34 = 1,
    TRAP_TRACE___34 = 2,
    TRAP_BRANCH___34 = 3,
    TRAP_HWBKPT___34 = 4,
    TRAP_UNK___34 = 5
} ;
enum __anonenum_23175539___34 {
    CLD_EXITED___34 = 1,
    CLD_KILLED___34 = 2,
    CLD_DUMPED___34 = 3,
    CLD_TRAPPED___34 = 4,
    CLD_STOPPED___34 = 5,
    CLD_CONTINUED___34 = 6
} ;
enum __anonenum_111643124___34 {
    POLL_IN___34 = 1,
    POLL_OUT___34 = 2,
    POLL_MSG___34 = 3,
    POLL_ERR___34 = 4,
    POLL_PRI___34 = 5,
    POLL_HUP___34 = 6
} ;
enum __anonenum_852341087___34 {
    SIGEV_SIGNAL___34 = 0,
    SIGEV_NONE___34 = 1,
    SIGEV_THREAD___34 = 2,
    SIGEV_THREAD_ID___34 = 4
} ;
enum __anonenum_451154152___34 {
    REG_R8___34 = 0,
    REG_R9___34 = 1,
    REG_R10___34 = 2,
    REG_R11___34 = 3,
    REG_R12___34 = 4,
    REG_R13___34 = 5,
    REG_R14___34 = 6,
    REG_R15___34 = 7,
    REG_RDI___34 = 8,
    REG_RSI___34 = 9,
    REG_RBP___34 = 10,
    REG_RBX___34 = 11,
    REG_RDX___34 = 12,
    REG_RAX___34 = 13,
    REG_RCX___34 = 14,
    REG_RSP___34 = 15,
    REG_RIP___34 = 16,
    REG_EFL___34 = 17,
    REG_CSGSFS___34 = 18,
    REG_ERR___34 = 19,
    REG_TRAPNO___34 = 20,
    REG_OLDMASK___34 = 21,
    REG_CR2___34 = 22
} ;
enum __anonenum_437032235___34 {
    _PC_LINK_MAX___34 = 0,
    _PC_MAX_CANON___34 = 1,
    _PC_MAX_INPUT___34 = 2,
    _PC_NAME_MAX___34 = 3,
    _PC_PATH_MAX___34 = 4,
    _PC_PIPE_BUF___34 = 5,
    _PC_CHOWN_RESTRICTED___34 = 6,
    _PC_NO_TRUNC___34 = 7,
    _PC_VDISABLE___34 = 8,
    _PC_SYNC_IO___34 = 9,
    _PC_ASYNC_IO___34 = 10,
    _PC_PRIO_IO___34 = 11,
    _PC_SOCK_MAXBUF___34 = 12,
    _PC_FILESIZEBITS___34 = 13,
    _PC_REC_INCR_XFER_SIZE___34 = 14,
    _PC_REC_MAX_XFER_SIZE___34 = 15,
    _PC_REC_MIN_XFER_SIZE___34 = 16,
    _PC_REC_XFER_ALIGN___34 = 17,
    _PC_ALLOC_SIZE_MIN___34 = 18,
    _PC_SYMLINK_MAX___34 = 19,
    _PC_2_SYMLINKS___34 = 20
} ;
enum __anonenum_315186338___34 {
    _SC_ARG_MAX___34 = 0,
    _SC_CHILD_MAX___34 = 1,
    _SC_CLK_TCK___34 = 2,
    _SC_NGROUPS_MAX___34 = 3,
    _SC_OPEN_MAX___34 = 4,
    _SC_STREAM_MAX___34 = 5,
    _SC_TZNAME_MAX___34 = 6,
    _SC_JOB_CONTROL___34 = 7,
    _SC_SAVED_IDS___34 = 8,
    _SC_REALTIME_SIGNALS___34 = 9,
    _SC_PRIORITY_SCHEDULING___34 = 10,
    _SC_TIMERS___34 = 11,
    _SC_ASYNCHRONOUS_IO___34 = 12,
    _SC_PRIORITIZED_IO___34 = 13,
    _SC_SYNCHRONIZED_IO___34 = 14,
    _SC_FSYNC___34 = 15,
    _SC_MAPPED_FILES___34 = 16,
    _SC_MEMLOCK___34 = 17,
    _SC_MEMLOCK_RANGE___34 = 18,
    _SC_MEMORY_PROTECTION___34 = 19,
    _SC_MESSAGE_PASSING___34 = 20,
    _SC_SEMAPHORES___34 = 21,
    _SC_SHARED_MEMORY_OBJECTS___34 = 22,
    _SC_AIO_LISTIO_MAX___34 = 23,
    _SC_AIO_MAX___34 = 24,
    _SC_AIO_PRIO_DELTA_MAX___34 = 25,
    _SC_DELAYTIMER_MAX___34 = 26,
    _SC_MQ_OPEN_MAX___34 = 27,
    _SC_MQ_PRIO_MAX___34 = 28,
    _SC_VERSION___34 = 29,
    _SC_PAGESIZE___34 = 30,
    _SC_RTSIG_MAX___34 = 31,
    _SC_SEM_NSEMS_MAX___34 = 32,
    _SC_SEM_VALUE_MAX___34 = 33,
    _SC_SIGQUEUE_MAX___34 = 34,
    _SC_TIMER_MAX___34 = 35,
    _SC_BC_BASE_MAX___34 = 36,
    _SC_BC_DIM_MAX___34 = 37,
    _SC_BC_SCALE_MAX___34 = 38,
    _SC_BC_STRING_MAX___34 = 39,
    _SC_COLL_WEIGHTS_MAX___34 = 40,
    _SC_EQUIV_CLASS_MAX___34 = 41,
    _SC_EXPR_NEST_MAX___34 = 42,
    _SC_LINE_MAX___34 = 43,
    _SC_RE_DUP_MAX___34 = 44,
    _SC_CHARCLASS_NAME_MAX___34 = 45,
    _SC_2_VERSION___34 = 46,
    _SC_2_C_BIND___34 = 47,
    _SC_2_C_DEV___34 = 48,
    _SC_2_FORT_DEV___34 = 49,
    _SC_2_FORT_RUN___34 = 50,
    _SC_2_SW_DEV___34 = 51,
    _SC_2_LOCALEDEF___34 = 52,
    _SC_PII___34 = 53,
    _SC_PII_XTI___34 = 54,
    _SC_PII_SOCKET___34 = 55,
    _SC_PII_INTERNET___34 = 56,
    _SC_PII_OSI___34 = 57,
    _SC_POLL___34 = 58,
    _SC_SELECT___34 = 59,
    _SC_UIO_MAXIOV___34 = 60,
    _SC_IOV_MAX___34 = 60,
    _SC_PII_INTERNET_STREAM___34 = 61,
    _SC_PII_INTERNET_DGRAM___34 = 62,
    _SC_PII_OSI_COTS___34 = 63,
    _SC_PII_OSI_CLTS___34 = 64,
    _SC_PII_OSI_M___34 = 65,
    _SC_T_IOV_MAX___34 = 66,
    _SC_THREADS___34 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___34 = 68,
    _SC_GETGR_R_SIZE_MAX___34 = 69,
    _SC_GETPW_R_SIZE_MAX___34 = 70,
    _SC_LOGIN_NAME_MAX___34 = 71,
    _SC_TTY_NAME_MAX___34 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___34 = 73,
    _SC_THREAD_KEYS_MAX___34 = 74,
    _SC_THREAD_STACK_MIN___34 = 75,
    _SC_THREAD_THREADS_MAX___34 = 76,
    _SC_THREAD_ATTR_STACKADDR___34 = 77,
    _SC_THREAD_ATTR_STACKSIZE___34 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___34 = 79,
    _SC_THREAD_PRIO_INHERIT___34 = 80,
    _SC_THREAD_PRIO_PROTECT___34 = 81,
    _SC_THREAD_PROCESS_SHARED___34 = 82,
    _SC_NPROCESSORS_CONF___34 = 83,
    _SC_NPROCESSORS_ONLN___34 = 84,
    _SC_PHYS_PAGES___34 = 85,
    _SC_AVPHYS_PAGES___34 = 86,
    _SC_ATEXIT_MAX___34 = 87,
    _SC_PASS_MAX___34 = 88,
    _SC_XOPEN_VERSION___34 = 89,
    _SC_XOPEN_XCU_VERSION___34 = 90,
    _SC_XOPEN_UNIX___34 = 91,
    _SC_XOPEN_CRYPT___34 = 92,
    _SC_XOPEN_ENH_I18N___34 = 93,
    _SC_XOPEN_SHM___34 = 94,
    _SC_2_CHAR_TERM___34 = 95,
    _SC_2_C_VERSION___34 = 96,
    _SC_2_UPE___34 = 97,
    _SC_XOPEN_XPG2___34 = 98,
    _SC_XOPEN_XPG3___34 = 99,
    _SC_XOPEN_XPG4___34 = 100,
    _SC_CHAR_BIT___34 = 101,
    _SC_CHAR_MAX___34 = 102,
    _SC_CHAR_MIN___34 = 103,
    _SC_INT_MAX___34 = 104,
    _SC_INT_MIN___34 = 105,
    _SC_LONG_BIT___34 = 106,
    _SC_WORD_BIT___34 = 107,
    _SC_MB_LEN_MAX___34 = 108,
    _SC_NZERO___34 = 109,
    _SC_SSIZE_MAX___34 = 110,
    _SC_SCHAR_MAX___34 = 111,
    _SC_SCHAR_MIN___34 = 112,
    _SC_SHRT_MAX___34 = 113,
    _SC_SHRT_MIN___34 = 114,
    _SC_UCHAR_MAX___34 = 115,
    _SC_UINT_MAX___34 = 116,
    _SC_ULONG_MAX___34 = 117,
    _SC_USHRT_MAX___34 = 118,
    _SC_NL_ARGMAX___34 = 119,
    _SC_NL_LANGMAX___34 = 120,
    _SC_NL_MSGMAX___34 = 121,
    _SC_NL_NMAX___34 = 122,
    _SC_NL_SETMAX___34 = 123,
    _SC_NL_TEXTMAX___34 = 124,
    _SC_XBS5_ILP32_OFF32___34 = 125,
    _SC_XBS5_ILP32_OFFBIG___34 = 126,
    _SC_XBS5_LP64_OFF64___34 = 127,
    _SC_XBS5_LPBIG_OFFBIG___34 = 128,
    _SC_XOPEN_LEGACY___34 = 129,
    _SC_XOPEN_REALTIME___34 = 130,
    _SC_XOPEN_REALTIME_THREADS___34 = 131,
    _SC_ADVISORY_INFO___34 = 132,
    _SC_BARRIERS___34 = 133,
    _SC_BASE___34 = 134,
    _SC_C_LANG_SUPPORT___34 = 135,
    _SC_C_LANG_SUPPORT_R___34 = 136,
    _SC_CLOCK_SELECTION___34 = 137,
    _SC_CPUTIME___34 = 138,
    _SC_THREAD_CPUTIME___34 = 139,
    _SC_DEVICE_IO___34 = 140,
    _SC_DEVICE_SPECIFIC___34 = 141,
    _SC_DEVICE_SPECIFIC_R___34 = 142,
    _SC_FD_MGMT___34 = 143,
    _SC_FIFO___34 = 144,
    _SC_PIPE___34 = 145,
    _SC_FILE_ATTRIBUTES___34 = 146,
    _SC_FILE_LOCKING___34 = 147,
    _SC_FILE_SYSTEM___34 = 148,
    _SC_MONOTONIC_CLOCK___34 = 149,
    _SC_MULTI_PROCESS___34 = 150,
    _SC_SINGLE_PROCESS___34 = 151,
    _SC_NETWORKING___34 = 152,
    _SC_READER_WRITER_LOCKS___34 = 153,
    _SC_SPIN_LOCKS___34 = 154,
    _SC_REGEXP___34 = 155,
    _SC_REGEX_VERSION___34 = 156,
    _SC_SHELL___34 = 157,
    _SC_SIGNALS___34 = 158,
    _SC_SPAWN___34 = 159,
    _SC_SPORADIC_SERVER___34 = 160,
    _SC_THREAD_SPORADIC_SERVER___34 = 161,
    _SC_SYSTEM_DATABASE___34 = 162,
    _SC_SYSTEM_DATABASE_R___34 = 163,
    _SC_TIMEOUTS___34 = 164,
    _SC_TYPED_MEMORY_OBJECTS___34 = 165,
    _SC_USER_GROUPS___34 = 166,
    _SC_USER_GROUPS_R___34 = 167,
    _SC_2_PBS___34 = 168,
    _SC_2_PBS_ACCOUNTING___34 = 169,
    _SC_2_PBS_LOCATE___34 = 170,
    _SC_2_PBS_MESSAGE___34 = 171,
    _SC_2_PBS_TRACK___34 = 172,
    _SC_SYMLOOP_MAX___34 = 173,
    _SC_STREAMS___34 = 174,
    _SC_2_PBS_CHECKPOINT___34 = 175,
    _SC_V6_ILP32_OFF32___34 = 176,
    _SC_V6_ILP32_OFFBIG___34 = 177,
    _SC_V6_LP64_OFF64___34 = 178,
    _SC_V6_LPBIG_OFFBIG___34 = 179,
    _SC_HOST_NAME_MAX___34 = 180,
    _SC_TRACE___34 = 181,
    _SC_TRACE_EVENT_FILTER___34 = 182,
    _SC_TRACE_INHERIT___34 = 183,
    _SC_TRACE_LOG___34 = 184,
    _SC_LEVEL1_ICACHE_SIZE___34 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___34 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___34 = 187,
    _SC_LEVEL1_DCACHE_SIZE___34 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___34 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___34 = 190,
    _SC_LEVEL2_CACHE_SIZE___34 = 191,
    _SC_LEVEL2_CACHE_ASSOC___34 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___34 = 193,
    _SC_LEVEL3_CACHE_SIZE___34 = 194,
    _SC_LEVEL3_CACHE_ASSOC___34 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___34 = 196,
    _SC_LEVEL4_CACHE_SIZE___34 = 197,
    _SC_LEVEL4_CACHE_ASSOC___34 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___34 = 199,
    _SC_IPV6___34 = 235,
    _SC_RAW_SOCKETS___34 = 236,
    _SC_V7_ILP32_OFF32___34 = 237,
    _SC_V7_ILP32_OFFBIG___34 = 238,
    _SC_V7_LP64_OFF64___34 = 239,
    _SC_V7_LPBIG_OFFBIG___34 = 240,
    _SC_SS_REPL_MAX___34 = 241,
    _SC_TRACE_EVENT_NAME_MAX___34 = 242,
    _SC_TRACE_NAME_MAX___34 = 243,
    _SC_TRACE_SYS_MAX___34 = 244,
    _SC_TRACE_USER_EVENT_MAX___34 = 245,
    _SC_XOPEN_STREAMS___34 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___34 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___34 = 248,
    _SC_MINSIGSTKSZ___34 = 249,
    _SC_SIGSTKSZ___34 = 250
} ;
enum __anonenum_875524036___34 {
    _CS_PATH___34 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___34 = 1,
    _CS_GNU_LIBC_VERSION___34 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___34 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___34 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___34 = 5,
    _CS_LFS_CFLAGS___34 = 1000,
    _CS_LFS_LDFLAGS___34 = 1001,
    _CS_LFS_LIBS___34 = 1002,
    _CS_LFS_LINTFLAGS___34 = 1003,
    _CS_LFS64_CFLAGS___34 = 1004,
    _CS_LFS64_LDFLAGS___34 = 1005,
    _CS_LFS64_LIBS___34 = 1006,
    _CS_LFS64_LINTFLAGS___34 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___34 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___34 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___34 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___34 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___34 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___34 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___34 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___34 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___34 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___34 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___34 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___34 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___34 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___34 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___34 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___34 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___34 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___34 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___34 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___34 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___34 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___34 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___34 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___34 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___34 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___34 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___34 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___34 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___34 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___34 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___34 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___34 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___34 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___34 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___34 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___34 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___34 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___34 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___34 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___34 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___34 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___34 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___34 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___34 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___34 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___34 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___34 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___34 = 1147,
    _CS_V6_ENV___34 = 1148,
    _CS_V7_ENV___34 = 1149
} ;
enum __anonenum_57186863___34 {
    SS_ONSTACK___34 = 1,
    SS_DISABLE___34 = 2
} ;
enum __anonenum_KeyClass_677233922 {
    NTP_MAC = 0,
    CMAC = 1
} ;
typedef enum __anonenum_KeyClass_677233922 KeyClass;
struct __anonstruct_ntp_mac_975500623 {
   unsigned char *value ;
   int hash_id ;
};
union __anonunion_data_145719562 {
   struct __anonstruct_ntp_mac_975500623 ntp_mac ;
   CMC_Instance cmac ;
};
struct __anonstruct_Key_79092009 {
   uint32_t id ;
   int type ;
   int length ;
   KeyClass class ;
   union __anonunion_data_145719562 data ;
};
typedef struct __anonstruct_Key_79092009 Key;
enum __anonenum_83571709___35 {
    MSG_OOB___35 = 1,
    MSG_PEEK___35 = 2,
    MSG_DONTROUTE___35 = 4,
    MSG_TRYHARD___35 = 4,
    MSG_CTRUNC___35 = 8,
    MSG_PROXY___35 = 16,
    MSG_TRUNC___35 = 32,
    MSG_DONTWAIT___35 = 64,
    MSG_EOR___35 = 128,
    MSG_WAITALL___35 = 256,
    MSG_FIN___35 = 512,
    MSG_SYN___35 = 1024,
    MSG_CONFIRM___35 = 2048,
    MSG_RST___35 = 4096,
    MSG_ERRQUEUE___35 = 8192,
    MSG_NOSIGNAL___35 = 16384,
    MSG_MORE___35 = 32768,
    MSG_WAITFORONE___35 = 65536,
    MSG_BATCH___35 = 262144,
    MSG_ZEROCOPY___35 = 67108864,
    MSG_FASTOPEN___35 = 536870912,
    MSG_CMSG_CLOEXEC___35 = 1073741824
} ;
enum __anonenum_617082774___35 {
    SCM_RIGHTS___35 = 1,
    SCM_CREDENTIALS___35 = 2
} ;
enum __anonenum_606441560___35 {
    SHUT_RD___35 = 0,
    SHUT_WR___35 = 1,
    SHUT_RDWR___35 = 2
} ;
enum __anonenum_264779956___35 {
    IPPROTO_IP___35 = 0,
    IPPROTO_ICMP___35 = 1,
    IPPROTO_IGMP___35 = 2,
    IPPROTO_IPIP___35 = 4,
    IPPROTO_TCP___35 = 6,
    IPPROTO_EGP___35 = 8,
    IPPROTO_PUP___35 = 12,
    IPPROTO_UDP___35 = 17,
    IPPROTO_IDP___35 = 22,
    IPPROTO_TP___35 = 29,
    IPPROTO_DCCP___35 = 33,
    IPPROTO_IPV6___35 = 41,
    IPPROTO_RSVP___35 = 46,
    IPPROTO_GRE___35 = 47,
    IPPROTO_ESP___35 = 50,
    IPPROTO_AH___35 = 51,
    IPPROTO_MTP___35 = 92,
    IPPROTO_BEETPH___35 = 94,
    IPPROTO_ENCAP___35 = 98,
    IPPROTO_PIM___35 = 103,
    IPPROTO_COMP___35 = 108,
    IPPROTO_SCTP___35 = 132,
    IPPROTO_UDPLITE___35 = 136,
    IPPROTO_MPLS___35 = 137,
    IPPROTO_ETHERNET___35 = 143,
    IPPROTO_RAW___35 = 255,
    IPPROTO_MPTCP___35 = 262,
    IPPROTO_MAX___35 = 263
} ;
enum __anonenum_218739988___35 {
    IPPROTO_HOPOPTS___35 = 0,
    IPPROTO_ROUTING___35 = 43,
    IPPROTO_FRAGMENT___35 = 44,
    IPPROTO_ICMPV6___35 = 58,
    IPPROTO_NONE___35 = 59,
    IPPROTO_DSTOPTS___35 = 60,
    IPPROTO_MH___35 = 135
} ;
enum __anonenum_662268580___35 {
    IPPORT_ECHO___35 = 7,
    IPPORT_DISCARD___35 = 9,
    IPPORT_SYSTAT___35 = 11,
    IPPORT_DAYTIME___35 = 13,
    IPPORT_NETSTAT___35 = 15,
    IPPORT_FTP___35 = 21,
    IPPORT_TELNET___35 = 23,
    IPPORT_SMTP___35 = 25,
    IPPORT_TIMESERVER___35 = 37,
    IPPORT_NAMESERVER___35 = 42,
    IPPORT_WHOIS___35 = 43,
    IPPORT_MTP___35 = 57,
    IPPORT_TFTP___35 = 69,
    IPPORT_RJE___35 = 77,
    IPPORT_FINGER___35 = 79,
    IPPORT_TTYLINK___35 = 87,
    IPPORT_SUPDUP___35 = 95,
    IPPORT_EXECSERVER___35 = 512,
    IPPORT_LOGINSERVER___35 = 513,
    IPPORT_CMDSERVER___35 = 514,
    IPPORT_EFSSERVER___35 = 520,
    IPPORT_BIFFUDP___35 = 512,
    IPPORT_WHOSERVER___35 = 513,
    IPPORT_ROUTESERVER___35 = 520,
    IPPORT_RESERVED___35 = 1024,
    IPPORT_USERRESERVED___35 = 5000
} ;
enum __anonenum_18926444___35 {
    _ISupper___35 = 256,
    _ISlower___35 = 512,
    _ISalpha___35 = 1024,
    _ISdigit___35 = 2048,
    _ISxdigit___35 = 4096,
    _ISspace___35 = 8192,
    _ISprint___35 = 16384,
    _ISgraph___35 = 32768,
    _ISblank___35 = 1,
    _IScntrl___35 = 2,
    _ISpunct___35 = 4,
    _ISalnum___35 = 8
} ;
enum __anonenum_913965969___35 {
    FP_INT_UPWARD___35 = 0,
    FP_INT_DOWNWARD___35 = 1,
    FP_INT_TOWARDZERO___35 = 2,
    FP_INT_TONEARESTFROMZERO___35 = 3,
    FP_INT_TONEAREST___35 = 4
} ;
enum __anonenum_1037408945___35 {
    FP_NAN___35 = 0,
    FP_INFINITE___35 = 1,
    FP_ZERO___35 = 2,
    FP_SUBNORMAL___35 = 3,
    FP_NORMAL___35 = 4
} ;
enum __anonenum_556971655___35 {
    SI_ASYNCNL___35 = -60,
    SI_DETHREAD___35 = -7,
    SI_TKILL___35 = -6,
    SI_SIGIO___35 = -5,
    SI_ASYNCIO___35 = -4,
    SI_MESGQ___35 = -3,
    SI_TIMER___35 = -2,
    SI_QUEUE___35 = -1,
    SI_USER___35 = 0,
    SI_KERNEL___35 = 128
} ;
enum __anonenum_640648963___35 {
    ILL_ILLOPC___35 = 1,
    ILL_ILLOPN___35 = 2,
    ILL_ILLADR___35 = 3,
    ILL_ILLTRP___35 = 4,
    ILL_PRVOPC___35 = 5,
    ILL_PRVREG___35 = 6,
    ILL_COPROC___35 = 7,
    ILL_BADSTK___35 = 8,
    ILL_BADIADDR___35 = 9
} ;
enum __anonenum_457704180___35 {
    FPE_INTDIV___35 = 1,
    FPE_INTOVF___35 = 2,
    FPE_FLTDIV___35 = 3,
    FPE_FLTOVF___35 = 4,
    FPE_FLTUND___35 = 5,
    FPE_FLTRES___35 = 6,
    FPE_FLTINV___35 = 7,
    FPE_FLTSUB___35 = 8,
    FPE_FLTUNK___35 = 14,
    FPE_CONDTRAP___35 = 15
} ;
enum __anonenum_180375148___35 {
    SEGV_MAPERR___35 = 1,
    SEGV_ACCERR___35 = 2,
    SEGV_BNDERR___35 = 3,
    SEGV_PKUERR___35 = 4,
    SEGV_ACCADI___35 = 5,
    SEGV_ADIDERR___35 = 6,
    SEGV_ADIPERR___35 = 7,
    SEGV_MTEAERR___35 = 8,
    SEGV_MTESERR___35 = 9
} ;
enum __anonenum_1036286214___35 {
    BUS_ADRALN___35 = 1,
    BUS_ADRERR___35 = 2,
    BUS_OBJERR___35 = 3,
    BUS_MCEERR_AR___35 = 4,
    BUS_MCEERR_AO___35 = 5
} ;
enum __anonenum_91015150___35 {
    TRAP_BRKPT___35 = 1,
    TRAP_TRACE___35 = 2,
    TRAP_BRANCH___35 = 3,
    TRAP_HWBKPT___35 = 4,
    TRAP_UNK___35 = 5
} ;
enum __anonenum_23175539___35 {
    CLD_EXITED___35 = 1,
    CLD_KILLED___35 = 2,
    CLD_DUMPED___35 = 3,
    CLD_TRAPPED___35 = 4,
    CLD_STOPPED___35 = 5,
    CLD_CONTINUED___35 = 6
} ;
enum __anonenum_111643124___35 {
    POLL_IN___35 = 1,
    POLL_OUT___35 = 2,
    POLL_MSG___35 = 3,
    POLL_ERR___35 = 4,
    POLL_PRI___35 = 5,
    POLL_HUP___35 = 6
} ;
enum __anonenum_852341087___35 {
    SIGEV_SIGNAL___35 = 0,
    SIGEV_NONE___35 = 1,
    SIGEV_THREAD___35 = 2,
    SIGEV_THREAD_ID___35 = 4
} ;
enum __anonenum_451154152___35 {
    REG_R8___35 = 0,
    REG_R9___35 = 1,
    REG_R10___35 = 2,
    REG_R11___35 = 3,
    REG_R12___35 = 4,
    REG_R13___35 = 5,
    REG_R14___35 = 6,
    REG_R15___35 = 7,
    REG_RDI___35 = 8,
    REG_RSI___35 = 9,
    REG_RBP___35 = 10,
    REG_RBX___35 = 11,
    REG_RDX___35 = 12,
    REG_RAX___35 = 13,
    REG_RCX___35 = 14,
    REG_RSP___35 = 15,
    REG_RIP___35 = 16,
    REG_EFL___35 = 17,
    REG_CSGSFS___35 = 18,
    REG_ERR___35 = 19,
    REG_TRAPNO___35 = 20,
    REG_OLDMASK___35 = 21,
    REG_CR2___35 = 22
} ;
enum __anonenum_437032235___35 {
    _PC_LINK_MAX___35 = 0,
    _PC_MAX_CANON___35 = 1,
    _PC_MAX_INPUT___35 = 2,
    _PC_NAME_MAX___35 = 3,
    _PC_PATH_MAX___35 = 4,
    _PC_PIPE_BUF___35 = 5,
    _PC_CHOWN_RESTRICTED___35 = 6,
    _PC_NO_TRUNC___35 = 7,
    _PC_VDISABLE___35 = 8,
    _PC_SYNC_IO___35 = 9,
    _PC_ASYNC_IO___35 = 10,
    _PC_PRIO_IO___35 = 11,
    _PC_SOCK_MAXBUF___35 = 12,
    _PC_FILESIZEBITS___35 = 13,
    _PC_REC_INCR_XFER_SIZE___35 = 14,
    _PC_REC_MAX_XFER_SIZE___35 = 15,
    _PC_REC_MIN_XFER_SIZE___35 = 16,
    _PC_REC_XFER_ALIGN___35 = 17,
    _PC_ALLOC_SIZE_MIN___35 = 18,
    _PC_SYMLINK_MAX___35 = 19,
    _PC_2_SYMLINKS___35 = 20
} ;
enum __anonenum_315186338___35 {
    _SC_ARG_MAX___35 = 0,
    _SC_CHILD_MAX___35 = 1,
    _SC_CLK_TCK___35 = 2,
    _SC_NGROUPS_MAX___35 = 3,
    _SC_OPEN_MAX___35 = 4,
    _SC_STREAM_MAX___35 = 5,
    _SC_TZNAME_MAX___35 = 6,
    _SC_JOB_CONTROL___35 = 7,
    _SC_SAVED_IDS___35 = 8,
    _SC_REALTIME_SIGNALS___35 = 9,
    _SC_PRIORITY_SCHEDULING___35 = 10,
    _SC_TIMERS___35 = 11,
    _SC_ASYNCHRONOUS_IO___35 = 12,
    _SC_PRIORITIZED_IO___35 = 13,
    _SC_SYNCHRONIZED_IO___35 = 14,
    _SC_FSYNC___35 = 15,
    _SC_MAPPED_FILES___35 = 16,
    _SC_MEMLOCK___35 = 17,
    _SC_MEMLOCK_RANGE___35 = 18,
    _SC_MEMORY_PROTECTION___35 = 19,
    _SC_MESSAGE_PASSING___35 = 20,
    _SC_SEMAPHORES___35 = 21,
    _SC_SHARED_MEMORY_OBJECTS___35 = 22,
    _SC_AIO_LISTIO_MAX___35 = 23,
    _SC_AIO_MAX___35 = 24,
    _SC_AIO_PRIO_DELTA_MAX___35 = 25,
    _SC_DELAYTIMER_MAX___35 = 26,
    _SC_MQ_OPEN_MAX___35 = 27,
    _SC_MQ_PRIO_MAX___35 = 28,
    _SC_VERSION___35 = 29,
    _SC_PAGESIZE___35 = 30,
    _SC_RTSIG_MAX___35 = 31,
    _SC_SEM_NSEMS_MAX___35 = 32,
    _SC_SEM_VALUE_MAX___35 = 33,
    _SC_SIGQUEUE_MAX___35 = 34,
    _SC_TIMER_MAX___35 = 35,
    _SC_BC_BASE_MAX___35 = 36,
    _SC_BC_DIM_MAX___35 = 37,
    _SC_BC_SCALE_MAX___35 = 38,
    _SC_BC_STRING_MAX___35 = 39,
    _SC_COLL_WEIGHTS_MAX___35 = 40,
    _SC_EQUIV_CLASS_MAX___35 = 41,
    _SC_EXPR_NEST_MAX___35 = 42,
    _SC_LINE_MAX___35 = 43,
    _SC_RE_DUP_MAX___35 = 44,
    _SC_CHARCLASS_NAME_MAX___35 = 45,
    _SC_2_VERSION___35 = 46,
    _SC_2_C_BIND___35 = 47,
    _SC_2_C_DEV___35 = 48,
    _SC_2_FORT_DEV___35 = 49,
    _SC_2_FORT_RUN___35 = 50,
    _SC_2_SW_DEV___35 = 51,
    _SC_2_LOCALEDEF___35 = 52,
    _SC_PII___35 = 53,
    _SC_PII_XTI___35 = 54,
    _SC_PII_SOCKET___35 = 55,
    _SC_PII_INTERNET___35 = 56,
    _SC_PII_OSI___35 = 57,
    _SC_POLL___35 = 58,
    _SC_SELECT___35 = 59,
    _SC_UIO_MAXIOV___35 = 60,
    _SC_IOV_MAX___35 = 60,
    _SC_PII_INTERNET_STREAM___35 = 61,
    _SC_PII_INTERNET_DGRAM___35 = 62,
    _SC_PII_OSI_COTS___35 = 63,
    _SC_PII_OSI_CLTS___35 = 64,
    _SC_PII_OSI_M___35 = 65,
    _SC_T_IOV_MAX___35 = 66,
    _SC_THREADS___35 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___35 = 68,
    _SC_GETGR_R_SIZE_MAX___35 = 69,
    _SC_GETPW_R_SIZE_MAX___35 = 70,
    _SC_LOGIN_NAME_MAX___35 = 71,
    _SC_TTY_NAME_MAX___35 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___35 = 73,
    _SC_THREAD_KEYS_MAX___35 = 74,
    _SC_THREAD_STACK_MIN___35 = 75,
    _SC_THREAD_THREADS_MAX___35 = 76,
    _SC_THREAD_ATTR_STACKADDR___35 = 77,
    _SC_THREAD_ATTR_STACKSIZE___35 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___35 = 79,
    _SC_THREAD_PRIO_INHERIT___35 = 80,
    _SC_THREAD_PRIO_PROTECT___35 = 81,
    _SC_THREAD_PROCESS_SHARED___35 = 82,
    _SC_NPROCESSORS_CONF___35 = 83,
    _SC_NPROCESSORS_ONLN___35 = 84,
    _SC_PHYS_PAGES___35 = 85,
    _SC_AVPHYS_PAGES___35 = 86,
    _SC_ATEXIT_MAX___35 = 87,
    _SC_PASS_MAX___35 = 88,
    _SC_XOPEN_VERSION___35 = 89,
    _SC_XOPEN_XCU_VERSION___35 = 90,
    _SC_XOPEN_UNIX___35 = 91,
    _SC_XOPEN_CRYPT___35 = 92,
    _SC_XOPEN_ENH_I18N___35 = 93,
    _SC_XOPEN_SHM___35 = 94,
    _SC_2_CHAR_TERM___35 = 95,
    _SC_2_C_VERSION___35 = 96,
    _SC_2_UPE___35 = 97,
    _SC_XOPEN_XPG2___35 = 98,
    _SC_XOPEN_XPG3___35 = 99,
    _SC_XOPEN_XPG4___35 = 100,
    _SC_CHAR_BIT___35 = 101,
    _SC_CHAR_MAX___35 = 102,
    _SC_CHAR_MIN___35 = 103,
    _SC_INT_MAX___35 = 104,
    _SC_INT_MIN___35 = 105,
    _SC_LONG_BIT___35 = 106,
    _SC_WORD_BIT___35 = 107,
    _SC_MB_LEN_MAX___35 = 108,
    _SC_NZERO___35 = 109,
    _SC_SSIZE_MAX___35 = 110,
    _SC_SCHAR_MAX___35 = 111,
    _SC_SCHAR_MIN___35 = 112,
    _SC_SHRT_MAX___35 = 113,
    _SC_SHRT_MIN___35 = 114,
    _SC_UCHAR_MAX___35 = 115,
    _SC_UINT_MAX___35 = 116,
    _SC_ULONG_MAX___35 = 117,
    _SC_USHRT_MAX___35 = 118,
    _SC_NL_ARGMAX___35 = 119,
    _SC_NL_LANGMAX___35 = 120,
    _SC_NL_MSGMAX___35 = 121,
    _SC_NL_NMAX___35 = 122,
    _SC_NL_SETMAX___35 = 123,
    _SC_NL_TEXTMAX___35 = 124,
    _SC_XBS5_ILP32_OFF32___35 = 125,
    _SC_XBS5_ILP32_OFFBIG___35 = 126,
    _SC_XBS5_LP64_OFF64___35 = 127,
    _SC_XBS5_LPBIG_OFFBIG___35 = 128,
    _SC_XOPEN_LEGACY___35 = 129,
    _SC_XOPEN_REALTIME___35 = 130,
    _SC_XOPEN_REALTIME_THREADS___35 = 131,
    _SC_ADVISORY_INFO___35 = 132,
    _SC_BARRIERS___35 = 133,
    _SC_BASE___35 = 134,
    _SC_C_LANG_SUPPORT___35 = 135,
    _SC_C_LANG_SUPPORT_R___35 = 136,
    _SC_CLOCK_SELECTION___35 = 137,
    _SC_CPUTIME___35 = 138,
    _SC_THREAD_CPUTIME___35 = 139,
    _SC_DEVICE_IO___35 = 140,
    _SC_DEVICE_SPECIFIC___35 = 141,
    _SC_DEVICE_SPECIFIC_R___35 = 142,
    _SC_FD_MGMT___35 = 143,
    _SC_FIFO___35 = 144,
    _SC_PIPE___35 = 145,
    _SC_FILE_ATTRIBUTES___35 = 146,
    _SC_FILE_LOCKING___35 = 147,
    _SC_FILE_SYSTEM___35 = 148,
    _SC_MONOTONIC_CLOCK___35 = 149,
    _SC_MULTI_PROCESS___35 = 150,
    _SC_SINGLE_PROCESS___35 = 151,
    _SC_NETWORKING___35 = 152,
    _SC_READER_WRITER_LOCKS___35 = 153,
    _SC_SPIN_LOCKS___35 = 154,
    _SC_REGEXP___35 = 155,
    _SC_REGEX_VERSION___35 = 156,
    _SC_SHELL___35 = 157,
    _SC_SIGNALS___35 = 158,
    _SC_SPAWN___35 = 159,
    _SC_SPORADIC_SERVER___35 = 160,
    _SC_THREAD_SPORADIC_SERVER___35 = 161,
    _SC_SYSTEM_DATABASE___35 = 162,
    _SC_SYSTEM_DATABASE_R___35 = 163,
    _SC_TIMEOUTS___35 = 164,
    _SC_TYPED_MEMORY_OBJECTS___35 = 165,
    _SC_USER_GROUPS___35 = 166,
    _SC_USER_GROUPS_R___35 = 167,
    _SC_2_PBS___35 = 168,
    _SC_2_PBS_ACCOUNTING___35 = 169,
    _SC_2_PBS_LOCATE___35 = 170,
    _SC_2_PBS_MESSAGE___35 = 171,
    _SC_2_PBS_TRACK___35 = 172,
    _SC_SYMLOOP_MAX___35 = 173,
    _SC_STREAMS___35 = 174,
    _SC_2_PBS_CHECKPOINT___35 = 175,
    _SC_V6_ILP32_OFF32___35 = 176,
    _SC_V6_ILP32_OFFBIG___35 = 177,
    _SC_V6_LP64_OFF64___35 = 178,
    _SC_V6_LPBIG_OFFBIG___35 = 179,
    _SC_HOST_NAME_MAX___35 = 180,
    _SC_TRACE___35 = 181,
    _SC_TRACE_EVENT_FILTER___35 = 182,
    _SC_TRACE_INHERIT___35 = 183,
    _SC_TRACE_LOG___35 = 184,
    _SC_LEVEL1_ICACHE_SIZE___35 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___35 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___35 = 187,
    _SC_LEVEL1_DCACHE_SIZE___35 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___35 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___35 = 190,
    _SC_LEVEL2_CACHE_SIZE___35 = 191,
    _SC_LEVEL2_CACHE_ASSOC___35 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___35 = 193,
    _SC_LEVEL3_CACHE_SIZE___35 = 194,
    _SC_LEVEL3_CACHE_ASSOC___35 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___35 = 196,
    _SC_LEVEL4_CACHE_SIZE___35 = 197,
    _SC_LEVEL4_CACHE_ASSOC___35 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___35 = 199,
    _SC_IPV6___35 = 235,
    _SC_RAW_SOCKETS___35 = 236,
    _SC_V7_ILP32_OFF32___35 = 237,
    _SC_V7_ILP32_OFFBIG___35 = 238,
    _SC_V7_LP64_OFF64___35 = 239,
    _SC_V7_LPBIG_OFFBIG___35 = 240,
    _SC_SS_REPL_MAX___35 = 241,
    _SC_TRACE_EVENT_NAME_MAX___35 = 242,
    _SC_TRACE_NAME_MAX___35 = 243,
    _SC_TRACE_SYS_MAX___35 = 244,
    _SC_TRACE_USER_EVENT_MAX___35 = 245,
    _SC_XOPEN_STREAMS___35 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___35 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___35 = 248,
    _SC_MINSIGSTKSZ___35 = 249,
    _SC_SIGSTKSZ___35 = 250
} ;
enum __anonenum_875524036___35 {
    _CS_PATH___35 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___35 = 1,
    _CS_GNU_LIBC_VERSION___35 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___35 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___35 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___35 = 5,
    _CS_LFS_CFLAGS___35 = 1000,
    _CS_LFS_LDFLAGS___35 = 1001,
    _CS_LFS_LIBS___35 = 1002,
    _CS_LFS_LINTFLAGS___35 = 1003,
    _CS_LFS64_CFLAGS___35 = 1004,
    _CS_LFS64_LDFLAGS___35 = 1005,
    _CS_LFS64_LIBS___35 = 1006,
    _CS_LFS64_LINTFLAGS___35 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___35 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___35 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___35 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___35 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___35 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___35 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___35 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___35 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___35 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___35 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___35 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___35 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___35 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___35 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___35 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___35 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___35 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___35 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___35 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___35 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___35 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___35 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___35 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___35 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___35 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___35 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___35 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___35 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___35 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___35 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___35 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___35 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___35 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___35 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___35 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___35 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___35 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___35 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___35 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___35 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___35 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___35 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___35 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___35 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___35 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___35 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___35 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___35 = 1147,
    _CS_V6_ENV___35 = 1148,
    _CS_V7_ENV___35 = 1149
} ;
enum __anonenum_57186863___35 {
    SS_ONSTACK___35 = 1,
    SS_DISABLE___35 = 2
} ;
struct rpcent {
   char *r_name ;
   char **r_aliases ;
   int r_number ;
};
struct netent {
   char *n_name ;
   char **n_aliases ;
   int n_addrtype ;
   uint32_t n_net ;
};
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
struct gaicb {
   char const *ar_name ;
   char const *ar_service ;
   struct addrinfo const *ar_request ;
   struct addrinfo *ar_result ;
   int __return ;
   int __glibc_reserved[5] ;
};
enum __ns_sect {
    ns_s_qd = 0,
    ns_s_zn = 0,
    ns_s_an = 1,
    ns_s_pr = 1,
    ns_s_ns = 2,
    ns_s_ud = 2,
    ns_s_ar = 3,
    ns_s_max = 4
} ;
typedef enum __ns_sect ns_sect;
struct __ns_msg {
   unsigned char const *_msg ;
   unsigned char const *_eom ;
   uint16_t _id ;
   uint16_t _flags ;
   uint16_t _counts[4] ;
   unsigned char const *_sections[4] ;
   ns_sect _sect ;
   int _rrnum ;
   unsigned char const *_msg_ptr ;
};
typedef struct __ns_msg ns_msg;
struct _ns_flagdata {
   int mask ;
   int shift ;
};
struct __ns_rr {
   char name[1025] ;
   uint16_t type ;
   uint16_t rr_class ;
   uint32_t ttl ;
   uint16_t rdlength ;
   unsigned char const *rdata ;
};
typedef struct __ns_rr ns_rr;
enum __ns_flag {
    ns_f_qr = 0,
    ns_f_opcode = 1,
    ns_f_aa = 2,
    ns_f_tc = 3,
    ns_f_rd = 4,
    ns_f_ra = 5,
    ns_f_z = 6,
    ns_f_ad = 7,
    ns_f_cd = 8,
    ns_f_rcode = 9,
    ns_f_max = 10
} ;
typedef enum __ns_flag ns_flag;
enum __ns_opcode {
    ns_o_query = 0,
    ns_o_iquery = 1,
    ns_o_status = 2,
    ns_o_notify = 4,
    ns_o_update = 5,
    ns_o_max = 6
} ;
typedef enum __ns_opcode ns_opcode;
enum __ns_rcode {
    ns_r_noerror = 0,
    ns_r_formerr = 1,
    ns_r_servfail = 2,
    ns_r_nxdomain = 3,
    ns_r_notimpl = 4,
    ns_r_refused = 5,
    ns_r_yxdomain = 6,
    ns_r_yxrrset = 7,
    ns_r_nxrrset = 8,
    ns_r_notauth = 9,
    ns_r_notzone = 10,
    ns_r_max = 11,
    ns_r_badvers = 16,
    ns_r_badsig = 16,
    ns_r_badkey = 17,
    ns_r_badtime = 18
} ;
typedef enum __ns_rcode ns_rcode;
enum __ns_update_operation {
    ns_uop_delete = 0,
    ns_uop_add = 1,
    ns_uop_max = 2
} ;
typedef enum __ns_update_operation ns_update_operation;
struct ns_tsig_key {
   char name[1025] ;
   char alg[1025] ;
   unsigned char *data ;
   int len ;
};
typedef struct ns_tsig_key ns_tsig_key;
struct dst_key ;
struct ns_tcp_tsig_state {
   int counter ;
   struct dst_key *key ;
   void *ctx ;
   unsigned char sig[512] ;
   int siglen ;
};
typedef struct ns_tcp_tsig_state ns_tcp_tsig_state;
enum __ns_type {
    ns_t_invalid = 0,
    ns_t_a = 1,
    ns_t_ns = 2,
    ns_t_md = 3,
    ns_t_mf = 4,
    ns_t_cname = 5,
    ns_t_soa = 6,
    ns_t_mb = 7,
    ns_t_mg = 8,
    ns_t_mr = 9,
    ns_t_null = 10,
    ns_t_wks = 11,
    ns_t_ptr = 12,
    ns_t_hinfo = 13,
    ns_t_minfo = 14,
    ns_t_mx = 15,
    ns_t_txt = 16,
    ns_t_rp = 17,
    ns_t_afsdb = 18,
    ns_t_x25 = 19,
    ns_t_isdn = 20,
    ns_t_rt = 21,
    ns_t_nsap = 22,
    ns_t_nsap_ptr = 23,
    ns_t_sig = 24,
    ns_t_key = 25,
    ns_t_px = 26,
    ns_t_gpos = 27,
    ns_t_aaaa = 28,
    ns_t_loc = 29,
    ns_t_nxt = 30,
    ns_t_eid = 31,
    ns_t_nimloc = 32,
    ns_t_srv = 33,
    ns_t_atma = 34,
    ns_t_naptr = 35,
    ns_t_kx = 36,
    ns_t_cert = 37,
    ns_t_a6 = 38,
    ns_t_dname = 39,
    ns_t_sink = 40,
    ns_t_opt = 41,
    ns_t_apl = 42,
    ns_t_ds = 43,
    ns_t_sshfp = 44,
    ns_t_ipseckey = 45,
    ns_t_rrsig = 46,
    ns_t_nsec = 47,
    ns_t_dnskey = 48,
    ns_t_dhcid = 49,
    ns_t_nsec3 = 50,
    ns_t_nsec3param = 51,
    ns_t_tlsa = 52,
    ns_t_smimea = 53,
    ns_t_hip = 55,
    ns_t_ninfo = 56,
    ns_t_rkey = 57,
    ns_t_talink = 58,
    ns_t_cds = 59,
    ns_t_cdnskey = 60,
    ns_t_openpgpkey = 61,
    ns_t_csync = 62,
    ns_t_spf = 99,
    ns_t_uinfo = 100,
    ns_t_uid = 101,
    ns_t_gid = 102,
    ns_t_unspec = 103,
    ns_t_nid = 104,
    ns_t_l32 = 105,
    ns_t_l64 = 106,
    ns_t_lp = 107,
    ns_t_eui48 = 108,
    ns_t_eui64 = 109,
    ns_t_tkey = 249,
    ns_t_tsig = 250,
    ns_t_ixfr = 251,
    ns_t_axfr = 252,
    ns_t_mailb = 253,
    ns_t_maila = 254,
    ns_t_any = 255,
    ns_t_uri = 256,
    ns_t_caa = 257,
    ns_t_avc = 258,
    ns_t_ta = 32768,
    ns_t_dlv = 32769,
    ns_t_max = 65536
} ;
typedef enum __ns_type ns_type;
enum __ns_class {
    ns_c_invalid = 0,
    ns_c_in = 1,
    ns_c_2 = 2,
    ns_c_chaos = 3,
    ns_c_hs = 4,
    ns_c_none = 254,
    ns_c_any = 255,
    ns_c_max = 65536
} ;
typedef enum __ns_class ns_class;
enum __ns_cert_types {
    cert_t_pkix = 1,
    cert_t_spki = 2,
    cert_t_pgp = 3,
    cert_t_url = 253,
    cert_t_oid = 254
} ;
typedef enum __ns_cert_types ns_cert_types;
struct __anonstruct_HEADER_619549238 {
   unsigned int id : 16 ;
   unsigned int rd : 1 ;
   unsigned int tc : 1 ;
   unsigned int aa : 1 ;
   unsigned int opcode : 4 ;
   unsigned int qr : 1 ;
   unsigned int rcode : 4 ;
   unsigned int cd : 1 ;
   unsigned int ad : 1 ;
   unsigned int unused : 1 ;
   unsigned int ra : 1 ;
   unsigned int qdcount : 16 ;
   unsigned int ancount : 16 ;
   unsigned int nscount : 16 ;
   unsigned int arcount : 16 ;
};
typedef struct __anonstruct_HEADER_619549238 HEADER;
struct __anonstruct_sort_list_863697614 {
   struct in_addr addr ;
   uint32_t mask ;
};
struct __anonstruct__ext_956883211 {
   uint16_t nscount ;
   uint16_t nsmap[3] ;
   int nssocks[3] ;
   uint16_t nscount6 ;
   uint16_t nsinit ;
   struct sockaddr_in6 *nsaddrs[3] ;
   unsigned int __glibc_reserved[2] ;
};
union __anonunion__u_52847346 {
   char pad[52] ;
   struct __anonstruct__ext_956883211 _ext ;
};
struct __res_state {
   int retrans ;
   int retry ;
   unsigned long options ;
   int nscount ;
   struct sockaddr_in nsaddr_list[3] ;
   unsigned short id ;
   char *dnsrch[7] ;
   char defdname[256] ;
   unsigned long pfcode ;
   unsigned int ndots : 4 ;
   unsigned int nsort : 4 ;
   unsigned int ipv6_unavail : 1 ;
   unsigned int unused : 23 ;
   struct __anonstruct_sort_list_863697614 sort_list[10] ;
   void *__glibc_unused_qhook ;
   void *__glibc_unused_rhook ;
   int res_h_errno ;
   int _vcsock ;
   unsigned int _flags ;
   union __anonunion__u_52847346 _u ;
};
typedef struct __res_state *res_state;
struct res_sym {
   int number ;
   char *name ;
   char *humanname ;
};
enum __anonenum_83571709___36 {
    MSG_OOB___36 = 1,
    MSG_PEEK___36 = 2,
    MSG_DONTROUTE___36 = 4,
    MSG_TRYHARD___36 = 4,
    MSG_CTRUNC___36 = 8,
    MSG_PROXY___36 = 16,
    MSG_TRUNC___36 = 32,
    MSG_DONTWAIT___36 = 64,
    MSG_EOR___36 = 128,
    MSG_WAITALL___36 = 256,
    MSG_FIN___36 = 512,
    MSG_SYN___36 = 1024,
    MSG_CONFIRM___36 = 2048,
    MSG_RST___36 = 4096,
    MSG_ERRQUEUE___36 = 8192,
    MSG_NOSIGNAL___36 = 16384,
    MSG_MORE___36 = 32768,
    MSG_WAITFORONE___36 = 65536,
    MSG_BATCH___36 = 262144,
    MSG_ZEROCOPY___36 = 67108864,
    MSG_FASTOPEN___36 = 536870912,
    MSG_CMSG_CLOEXEC___36 = 1073741824
} ;
enum __anonenum_617082774___36 {
    SCM_RIGHTS___36 = 1,
    SCM_CREDENTIALS___36 = 2
} ;
enum __anonenum_606441560___36 {
    SHUT_RD___36 = 0,
    SHUT_WR___36 = 1,
    SHUT_RDWR___36 = 2
} ;
enum __anonenum_264779956___36 {
    IPPROTO_IP___36 = 0,
    IPPROTO_ICMP___36 = 1,
    IPPROTO_IGMP___36 = 2,
    IPPROTO_IPIP___36 = 4,
    IPPROTO_TCP___36 = 6,
    IPPROTO_EGP___36 = 8,
    IPPROTO_PUP___36 = 12,
    IPPROTO_UDP___36 = 17,
    IPPROTO_IDP___36 = 22,
    IPPROTO_TP___36 = 29,
    IPPROTO_DCCP___36 = 33,
    IPPROTO_IPV6___36 = 41,
    IPPROTO_RSVP___36 = 46,
    IPPROTO_GRE___36 = 47,
    IPPROTO_ESP___36 = 50,
    IPPROTO_AH___36 = 51,
    IPPROTO_MTP___36 = 92,
    IPPROTO_BEETPH___36 = 94,
    IPPROTO_ENCAP___36 = 98,
    IPPROTO_PIM___36 = 103,
    IPPROTO_COMP___36 = 108,
    IPPROTO_SCTP___36 = 132,
    IPPROTO_UDPLITE___36 = 136,
    IPPROTO_MPLS___36 = 137,
    IPPROTO_ETHERNET___36 = 143,
    IPPROTO_RAW___36 = 255,
    IPPROTO_MPTCP___36 = 262,
    IPPROTO_MAX___36 = 263
} ;
enum __anonenum_218739988___36 {
    IPPROTO_HOPOPTS___36 = 0,
    IPPROTO_ROUTING___36 = 43,
    IPPROTO_FRAGMENT___36 = 44,
    IPPROTO_ICMPV6___36 = 58,
    IPPROTO_NONE___36 = 59,
    IPPROTO_DSTOPTS___36 = 60,
    IPPROTO_MH___36 = 135
} ;
enum __anonenum_662268580___36 {
    IPPORT_ECHO___36 = 7,
    IPPORT_DISCARD___36 = 9,
    IPPORT_SYSTAT___36 = 11,
    IPPORT_DAYTIME___36 = 13,
    IPPORT_NETSTAT___36 = 15,
    IPPORT_FTP___36 = 21,
    IPPORT_TELNET___36 = 23,
    IPPORT_SMTP___36 = 25,
    IPPORT_TIMESERVER___36 = 37,
    IPPORT_NAMESERVER___36 = 42,
    IPPORT_WHOIS___36 = 43,
    IPPORT_MTP___36 = 57,
    IPPORT_TFTP___36 = 69,
    IPPORT_RJE___36 = 77,
    IPPORT_FINGER___36 = 79,
    IPPORT_TTYLINK___36 = 87,
    IPPORT_SUPDUP___36 = 95,
    IPPORT_EXECSERVER___36 = 512,
    IPPORT_LOGINSERVER___36 = 513,
    IPPORT_CMDSERVER___36 = 514,
    IPPORT_EFSSERVER___36 = 520,
    IPPORT_BIFFUDP___36 = 512,
    IPPORT_WHOSERVER___36 = 513,
    IPPORT_ROUTESERVER___36 = 520,
    IPPORT_RESERVED___36 = 1024,
    IPPORT_USERRESERVED___36 = 5000
} ;
enum __anonenum_18926444___36 {
    _ISupper___36 = 256,
    _ISlower___36 = 512,
    _ISalpha___36 = 1024,
    _ISdigit___36 = 2048,
    _ISxdigit___36 = 4096,
    _ISspace___36 = 8192,
    _ISprint___36 = 16384,
    _ISgraph___36 = 32768,
    _ISblank___36 = 1,
    _IScntrl___36 = 2,
    _ISpunct___36 = 4,
    _ISalnum___36 = 8
} ;
enum __anonenum_913965969___36 {
    FP_INT_UPWARD___36 = 0,
    FP_INT_DOWNWARD___36 = 1,
    FP_INT_TOWARDZERO___36 = 2,
    FP_INT_TONEARESTFROMZERO___36 = 3,
    FP_INT_TONEAREST___36 = 4
} ;
enum __anonenum_1037408945___36 {
    FP_NAN___36 = 0,
    FP_INFINITE___36 = 1,
    FP_ZERO___36 = 2,
    FP_SUBNORMAL___36 = 3,
    FP_NORMAL___36 = 4
} ;
enum __anonenum_556971655___36 {
    SI_ASYNCNL___36 = -60,
    SI_DETHREAD___36 = -7,
    SI_TKILL___36 = -6,
    SI_SIGIO___36 = -5,
    SI_ASYNCIO___36 = -4,
    SI_MESGQ___36 = -3,
    SI_TIMER___36 = -2,
    SI_QUEUE___36 = -1,
    SI_USER___36 = 0,
    SI_KERNEL___36 = 128
} ;
enum __anonenum_640648963___36 {
    ILL_ILLOPC___36 = 1,
    ILL_ILLOPN___36 = 2,
    ILL_ILLADR___36 = 3,
    ILL_ILLTRP___36 = 4,
    ILL_PRVOPC___36 = 5,
    ILL_PRVREG___36 = 6,
    ILL_COPROC___36 = 7,
    ILL_BADSTK___36 = 8,
    ILL_BADIADDR___36 = 9
} ;
enum __anonenum_457704180___36 {
    FPE_INTDIV___36 = 1,
    FPE_INTOVF___36 = 2,
    FPE_FLTDIV___36 = 3,
    FPE_FLTOVF___36 = 4,
    FPE_FLTUND___36 = 5,
    FPE_FLTRES___36 = 6,
    FPE_FLTINV___36 = 7,
    FPE_FLTSUB___36 = 8,
    FPE_FLTUNK___36 = 14,
    FPE_CONDTRAP___36 = 15
} ;
enum __anonenum_180375148___36 {
    SEGV_MAPERR___36 = 1,
    SEGV_ACCERR___36 = 2,
    SEGV_BNDERR___36 = 3,
    SEGV_PKUERR___36 = 4,
    SEGV_ACCADI___36 = 5,
    SEGV_ADIDERR___36 = 6,
    SEGV_ADIPERR___36 = 7,
    SEGV_MTEAERR___36 = 8,
    SEGV_MTESERR___36 = 9
} ;
enum __anonenum_1036286214___36 {
    BUS_ADRALN___36 = 1,
    BUS_ADRERR___36 = 2,
    BUS_OBJERR___36 = 3,
    BUS_MCEERR_AR___36 = 4,
    BUS_MCEERR_AO___36 = 5
} ;
enum __anonenum_91015150___36 {
    TRAP_BRKPT___36 = 1,
    TRAP_TRACE___36 = 2,
    TRAP_BRANCH___36 = 3,
    TRAP_HWBKPT___36 = 4,
    TRAP_UNK___36 = 5
} ;
enum __anonenum_23175539___36 {
    CLD_EXITED___36 = 1,
    CLD_KILLED___36 = 2,
    CLD_DUMPED___36 = 3,
    CLD_TRAPPED___36 = 4,
    CLD_STOPPED___36 = 5,
    CLD_CONTINUED___36 = 6
} ;
enum __anonenum_111643124___36 {
    POLL_IN___36 = 1,
    POLL_OUT___36 = 2,
    POLL_MSG___36 = 3,
    POLL_ERR___36 = 4,
    POLL_PRI___36 = 5,
    POLL_HUP___36 = 6
} ;
enum __anonenum_852341087___36 {
    SIGEV_SIGNAL___36 = 0,
    SIGEV_NONE___36 = 1,
    SIGEV_THREAD___36 = 2,
    SIGEV_THREAD_ID___36 = 4
} ;
enum __anonenum_451154152___36 {
    REG_R8___36 = 0,
    REG_R9___36 = 1,
    REG_R10___36 = 2,
    REG_R11___36 = 3,
    REG_R12___36 = 4,
    REG_R13___36 = 5,
    REG_R14___36 = 6,
    REG_R15___36 = 7,
    REG_RDI___36 = 8,
    REG_RSI___36 = 9,
    REG_RBP___36 = 10,
    REG_RBX___36 = 11,
    REG_RDX___36 = 12,
    REG_RAX___36 = 13,
    REG_RCX___36 = 14,
    REG_RSP___36 = 15,
    REG_RIP___36 = 16,
    REG_EFL___36 = 17,
    REG_CSGSFS___36 = 18,
    REG_ERR___36 = 19,
    REG_TRAPNO___36 = 20,
    REG_OLDMASK___36 = 21,
    REG_CR2___36 = 22
} ;
enum __anonenum_437032235___36 {
    _PC_LINK_MAX___36 = 0,
    _PC_MAX_CANON___36 = 1,
    _PC_MAX_INPUT___36 = 2,
    _PC_NAME_MAX___36 = 3,
    _PC_PATH_MAX___36 = 4,
    _PC_PIPE_BUF___36 = 5,
    _PC_CHOWN_RESTRICTED___36 = 6,
    _PC_NO_TRUNC___36 = 7,
    _PC_VDISABLE___36 = 8,
    _PC_SYNC_IO___36 = 9,
    _PC_ASYNC_IO___36 = 10,
    _PC_PRIO_IO___36 = 11,
    _PC_SOCK_MAXBUF___36 = 12,
    _PC_FILESIZEBITS___36 = 13,
    _PC_REC_INCR_XFER_SIZE___36 = 14,
    _PC_REC_MAX_XFER_SIZE___36 = 15,
    _PC_REC_MIN_XFER_SIZE___36 = 16,
    _PC_REC_XFER_ALIGN___36 = 17,
    _PC_ALLOC_SIZE_MIN___36 = 18,
    _PC_SYMLINK_MAX___36 = 19,
    _PC_2_SYMLINKS___36 = 20
} ;
enum __anonenum_315186338___36 {
    _SC_ARG_MAX___36 = 0,
    _SC_CHILD_MAX___36 = 1,
    _SC_CLK_TCK___36 = 2,
    _SC_NGROUPS_MAX___36 = 3,
    _SC_OPEN_MAX___36 = 4,
    _SC_STREAM_MAX___36 = 5,
    _SC_TZNAME_MAX___36 = 6,
    _SC_JOB_CONTROL___36 = 7,
    _SC_SAVED_IDS___36 = 8,
    _SC_REALTIME_SIGNALS___36 = 9,
    _SC_PRIORITY_SCHEDULING___36 = 10,
    _SC_TIMERS___36 = 11,
    _SC_ASYNCHRONOUS_IO___36 = 12,
    _SC_PRIORITIZED_IO___36 = 13,
    _SC_SYNCHRONIZED_IO___36 = 14,
    _SC_FSYNC___36 = 15,
    _SC_MAPPED_FILES___36 = 16,
    _SC_MEMLOCK___36 = 17,
    _SC_MEMLOCK_RANGE___36 = 18,
    _SC_MEMORY_PROTECTION___36 = 19,
    _SC_MESSAGE_PASSING___36 = 20,
    _SC_SEMAPHORES___36 = 21,
    _SC_SHARED_MEMORY_OBJECTS___36 = 22,
    _SC_AIO_LISTIO_MAX___36 = 23,
    _SC_AIO_MAX___36 = 24,
    _SC_AIO_PRIO_DELTA_MAX___36 = 25,
    _SC_DELAYTIMER_MAX___36 = 26,
    _SC_MQ_OPEN_MAX___36 = 27,
    _SC_MQ_PRIO_MAX___36 = 28,
    _SC_VERSION___36 = 29,
    _SC_PAGESIZE___36 = 30,
    _SC_RTSIG_MAX___36 = 31,
    _SC_SEM_NSEMS_MAX___36 = 32,
    _SC_SEM_VALUE_MAX___36 = 33,
    _SC_SIGQUEUE_MAX___36 = 34,
    _SC_TIMER_MAX___36 = 35,
    _SC_BC_BASE_MAX___36 = 36,
    _SC_BC_DIM_MAX___36 = 37,
    _SC_BC_SCALE_MAX___36 = 38,
    _SC_BC_STRING_MAX___36 = 39,
    _SC_COLL_WEIGHTS_MAX___36 = 40,
    _SC_EQUIV_CLASS_MAX___36 = 41,
    _SC_EXPR_NEST_MAX___36 = 42,
    _SC_LINE_MAX___36 = 43,
    _SC_RE_DUP_MAX___36 = 44,
    _SC_CHARCLASS_NAME_MAX___36 = 45,
    _SC_2_VERSION___36 = 46,
    _SC_2_C_BIND___36 = 47,
    _SC_2_C_DEV___36 = 48,
    _SC_2_FORT_DEV___36 = 49,
    _SC_2_FORT_RUN___36 = 50,
    _SC_2_SW_DEV___36 = 51,
    _SC_2_LOCALEDEF___36 = 52,
    _SC_PII___36 = 53,
    _SC_PII_XTI___36 = 54,
    _SC_PII_SOCKET___36 = 55,
    _SC_PII_INTERNET___36 = 56,
    _SC_PII_OSI___36 = 57,
    _SC_POLL___36 = 58,
    _SC_SELECT___36 = 59,
    _SC_UIO_MAXIOV___36 = 60,
    _SC_IOV_MAX___36 = 60,
    _SC_PII_INTERNET_STREAM___36 = 61,
    _SC_PII_INTERNET_DGRAM___36 = 62,
    _SC_PII_OSI_COTS___36 = 63,
    _SC_PII_OSI_CLTS___36 = 64,
    _SC_PII_OSI_M___36 = 65,
    _SC_T_IOV_MAX___36 = 66,
    _SC_THREADS___36 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___36 = 68,
    _SC_GETGR_R_SIZE_MAX___36 = 69,
    _SC_GETPW_R_SIZE_MAX___36 = 70,
    _SC_LOGIN_NAME_MAX___36 = 71,
    _SC_TTY_NAME_MAX___36 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___36 = 73,
    _SC_THREAD_KEYS_MAX___36 = 74,
    _SC_THREAD_STACK_MIN___36 = 75,
    _SC_THREAD_THREADS_MAX___36 = 76,
    _SC_THREAD_ATTR_STACKADDR___36 = 77,
    _SC_THREAD_ATTR_STACKSIZE___36 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___36 = 79,
    _SC_THREAD_PRIO_INHERIT___36 = 80,
    _SC_THREAD_PRIO_PROTECT___36 = 81,
    _SC_THREAD_PROCESS_SHARED___36 = 82,
    _SC_NPROCESSORS_CONF___36 = 83,
    _SC_NPROCESSORS_ONLN___36 = 84,
    _SC_PHYS_PAGES___36 = 85,
    _SC_AVPHYS_PAGES___36 = 86,
    _SC_ATEXIT_MAX___36 = 87,
    _SC_PASS_MAX___36 = 88,
    _SC_XOPEN_VERSION___36 = 89,
    _SC_XOPEN_XCU_VERSION___36 = 90,
    _SC_XOPEN_UNIX___36 = 91,
    _SC_XOPEN_CRYPT___36 = 92,
    _SC_XOPEN_ENH_I18N___36 = 93,
    _SC_XOPEN_SHM___36 = 94,
    _SC_2_CHAR_TERM___36 = 95,
    _SC_2_C_VERSION___36 = 96,
    _SC_2_UPE___36 = 97,
    _SC_XOPEN_XPG2___36 = 98,
    _SC_XOPEN_XPG3___36 = 99,
    _SC_XOPEN_XPG4___36 = 100,
    _SC_CHAR_BIT___36 = 101,
    _SC_CHAR_MAX___36 = 102,
    _SC_CHAR_MIN___36 = 103,
    _SC_INT_MAX___36 = 104,
    _SC_INT_MIN___36 = 105,
    _SC_LONG_BIT___36 = 106,
    _SC_WORD_BIT___36 = 107,
    _SC_MB_LEN_MAX___36 = 108,
    _SC_NZERO___36 = 109,
    _SC_SSIZE_MAX___36 = 110,
    _SC_SCHAR_MAX___36 = 111,
    _SC_SCHAR_MIN___36 = 112,
    _SC_SHRT_MAX___36 = 113,
    _SC_SHRT_MIN___36 = 114,
    _SC_UCHAR_MAX___36 = 115,
    _SC_UINT_MAX___36 = 116,
    _SC_ULONG_MAX___36 = 117,
    _SC_USHRT_MAX___36 = 118,
    _SC_NL_ARGMAX___36 = 119,
    _SC_NL_LANGMAX___36 = 120,
    _SC_NL_MSGMAX___36 = 121,
    _SC_NL_NMAX___36 = 122,
    _SC_NL_SETMAX___36 = 123,
    _SC_NL_TEXTMAX___36 = 124,
    _SC_XBS5_ILP32_OFF32___36 = 125,
    _SC_XBS5_ILP32_OFFBIG___36 = 126,
    _SC_XBS5_LP64_OFF64___36 = 127,
    _SC_XBS5_LPBIG_OFFBIG___36 = 128,
    _SC_XOPEN_LEGACY___36 = 129,
    _SC_XOPEN_REALTIME___36 = 130,
    _SC_XOPEN_REALTIME_THREADS___36 = 131,
    _SC_ADVISORY_INFO___36 = 132,
    _SC_BARRIERS___36 = 133,
    _SC_BASE___36 = 134,
    _SC_C_LANG_SUPPORT___36 = 135,
    _SC_C_LANG_SUPPORT_R___36 = 136,
    _SC_CLOCK_SELECTION___36 = 137,
    _SC_CPUTIME___36 = 138,
    _SC_THREAD_CPUTIME___36 = 139,
    _SC_DEVICE_IO___36 = 140,
    _SC_DEVICE_SPECIFIC___36 = 141,
    _SC_DEVICE_SPECIFIC_R___36 = 142,
    _SC_FD_MGMT___36 = 143,
    _SC_FIFO___36 = 144,
    _SC_PIPE___36 = 145,
    _SC_FILE_ATTRIBUTES___36 = 146,
    _SC_FILE_LOCKING___36 = 147,
    _SC_FILE_SYSTEM___36 = 148,
    _SC_MONOTONIC_CLOCK___36 = 149,
    _SC_MULTI_PROCESS___36 = 150,
    _SC_SINGLE_PROCESS___36 = 151,
    _SC_NETWORKING___36 = 152,
    _SC_READER_WRITER_LOCKS___36 = 153,
    _SC_SPIN_LOCKS___36 = 154,
    _SC_REGEXP___36 = 155,
    _SC_REGEX_VERSION___36 = 156,
    _SC_SHELL___36 = 157,
    _SC_SIGNALS___36 = 158,
    _SC_SPAWN___36 = 159,
    _SC_SPORADIC_SERVER___36 = 160,
    _SC_THREAD_SPORADIC_SERVER___36 = 161,
    _SC_SYSTEM_DATABASE___36 = 162,
    _SC_SYSTEM_DATABASE_R___36 = 163,
    _SC_TIMEOUTS___36 = 164,
    _SC_TYPED_MEMORY_OBJECTS___36 = 165,
    _SC_USER_GROUPS___36 = 166,
    _SC_USER_GROUPS_R___36 = 167,
    _SC_2_PBS___36 = 168,
    _SC_2_PBS_ACCOUNTING___36 = 169,
    _SC_2_PBS_LOCATE___36 = 170,
    _SC_2_PBS_MESSAGE___36 = 171,
    _SC_2_PBS_TRACK___36 = 172,
    _SC_SYMLOOP_MAX___36 = 173,
    _SC_STREAMS___36 = 174,
    _SC_2_PBS_CHECKPOINT___36 = 175,
    _SC_V6_ILP32_OFF32___36 = 176,
    _SC_V6_ILP32_OFFBIG___36 = 177,
    _SC_V6_LP64_OFF64___36 = 178,
    _SC_V6_LPBIG_OFFBIG___36 = 179,
    _SC_HOST_NAME_MAX___36 = 180,
    _SC_TRACE___36 = 181,
    _SC_TRACE_EVENT_FILTER___36 = 182,
    _SC_TRACE_INHERIT___36 = 183,
    _SC_TRACE_LOG___36 = 184,
    _SC_LEVEL1_ICACHE_SIZE___36 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___36 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___36 = 187,
    _SC_LEVEL1_DCACHE_SIZE___36 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___36 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___36 = 190,
    _SC_LEVEL2_CACHE_SIZE___36 = 191,
    _SC_LEVEL2_CACHE_ASSOC___36 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___36 = 193,
    _SC_LEVEL3_CACHE_SIZE___36 = 194,
    _SC_LEVEL3_CACHE_ASSOC___36 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___36 = 196,
    _SC_LEVEL4_CACHE_SIZE___36 = 197,
    _SC_LEVEL4_CACHE_ASSOC___36 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___36 = 199,
    _SC_IPV6___36 = 235,
    _SC_RAW_SOCKETS___36 = 236,
    _SC_V7_ILP32_OFF32___36 = 237,
    _SC_V7_ILP32_OFFBIG___36 = 238,
    _SC_V7_LP64_OFF64___36 = 239,
    _SC_V7_LPBIG_OFFBIG___36 = 240,
    _SC_SS_REPL_MAX___36 = 241,
    _SC_TRACE_EVENT_NAME_MAX___36 = 242,
    _SC_TRACE_NAME_MAX___36 = 243,
    _SC_TRACE_SYS_MAX___36 = 244,
    _SC_TRACE_USER_EVENT_MAX___36 = 245,
    _SC_XOPEN_STREAMS___36 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___36 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___36 = 248,
    _SC_MINSIGSTKSZ___36 = 249,
    _SC_SIGSTKSZ___36 = 250
} ;
enum __anonenum_875524036___36 {
    _CS_PATH___36 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___36 = 1,
    _CS_GNU_LIBC_VERSION___36 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___36 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___36 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___36 = 5,
    _CS_LFS_CFLAGS___36 = 1000,
    _CS_LFS_LDFLAGS___36 = 1001,
    _CS_LFS_LIBS___36 = 1002,
    _CS_LFS_LINTFLAGS___36 = 1003,
    _CS_LFS64_CFLAGS___36 = 1004,
    _CS_LFS64_LDFLAGS___36 = 1005,
    _CS_LFS64_LIBS___36 = 1006,
    _CS_LFS64_LINTFLAGS___36 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___36 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___36 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___36 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___36 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___36 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___36 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___36 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___36 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___36 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___36 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___36 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___36 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___36 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___36 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___36 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___36 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___36 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___36 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___36 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___36 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___36 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___36 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___36 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___36 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___36 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___36 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___36 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___36 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___36 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___36 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___36 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___36 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___36 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___36 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___36 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___36 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___36 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___36 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___36 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___36 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___36 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___36 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___36 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___36 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___36 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___36 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___36 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___36 = 1147,
    _CS_V6_ENV___36 = 1148,
    _CS_V7_ENV___36 = 1149
} ;
enum __anonenum_57186863___36 {
    SS_ONSTACK___36 = 1,
    SS_DISABLE___36 = 2
} ;
struct FilterSample {
   double offset ;
   double dispersion ;
   struct timespec sample_time ;
};
struct MedianFilter {
   int length ;
   int index ;
   int used ;
   int last ;
   int avg_var_n ;
   double avg_var ;
   double max_var ;
   struct FilterSample *samples ;
   int *selected ;
   double *x_data ;
   double *y_data ;
   double *w_data ;
};
struct RCL_Instance_Record {
   RefclockDriver *driver ;
   void *data ;
   char *driver_parameter ;
   int driver_parameter_length ;
   int driver_poll ;
   int driver_polled ;
   int poll ;
   int leap_status ;
   int pps_forced ;
   int pps_rate ;
   int pps_active ;
   int max_lock_age ;
   int stratum ;
   int tai ;
   uint32_t ref_id ;
   uint32_t lock_ref ;
   double offset ;
   double delay ;
   double precision ;
   double pulse_width ;
   SPF_Instance filter ;
   SCH_TimeoutID timeout_id ;
   SRC_Instance source ;
};
enum __anonenum_83571709___37 {
    MSG_OOB___37 = 1,
    MSG_PEEK___37 = 2,
    MSG_DONTROUTE___37 = 4,
    MSG_TRYHARD___37 = 4,
    MSG_CTRUNC___37 = 8,
    MSG_PROXY___37 = 16,
    MSG_TRUNC___37 = 32,
    MSG_DONTWAIT___37 = 64,
    MSG_EOR___37 = 128,
    MSG_WAITALL___37 = 256,
    MSG_FIN___37 = 512,
    MSG_SYN___37 = 1024,
    MSG_CONFIRM___37 = 2048,
    MSG_RST___37 = 4096,
    MSG_ERRQUEUE___37 = 8192,
    MSG_NOSIGNAL___37 = 16384,
    MSG_MORE___37 = 32768,
    MSG_WAITFORONE___37 = 65536,
    MSG_BATCH___37 = 262144,
    MSG_ZEROCOPY___37 = 67108864,
    MSG_FASTOPEN___37 = 536870912,
    MSG_CMSG_CLOEXEC___37 = 1073741824
} ;
enum __anonenum_617082774___37 {
    SCM_RIGHTS___37 = 1,
    SCM_CREDENTIALS___37 = 2
} ;
enum __anonenum_606441560___37 {
    SHUT_RD___37 = 0,
    SHUT_WR___37 = 1,
    SHUT_RDWR___37 = 2
} ;
enum __anonenum_264779956___37 {
    IPPROTO_IP___37 = 0,
    IPPROTO_ICMP___37 = 1,
    IPPROTO_IGMP___37 = 2,
    IPPROTO_IPIP___37 = 4,
    IPPROTO_TCP___37 = 6,
    IPPROTO_EGP___37 = 8,
    IPPROTO_PUP___37 = 12,
    IPPROTO_UDP___37 = 17,
    IPPROTO_IDP___37 = 22,
    IPPROTO_TP___37 = 29,
    IPPROTO_DCCP___37 = 33,
    IPPROTO_IPV6___37 = 41,
    IPPROTO_RSVP___37 = 46,
    IPPROTO_GRE___37 = 47,
    IPPROTO_ESP___37 = 50,
    IPPROTO_AH___37 = 51,
    IPPROTO_MTP___37 = 92,
    IPPROTO_BEETPH___37 = 94,
    IPPROTO_ENCAP___37 = 98,
    IPPROTO_PIM___37 = 103,
    IPPROTO_COMP___37 = 108,
    IPPROTO_SCTP___37 = 132,
    IPPROTO_UDPLITE___37 = 136,
    IPPROTO_MPLS___37 = 137,
    IPPROTO_ETHERNET___37 = 143,
    IPPROTO_RAW___37 = 255,
    IPPROTO_MPTCP___37 = 262,
    IPPROTO_MAX___37 = 263
} ;
enum __anonenum_218739988___37 {
    IPPROTO_HOPOPTS___37 = 0,
    IPPROTO_ROUTING___37 = 43,
    IPPROTO_FRAGMENT___37 = 44,
    IPPROTO_ICMPV6___37 = 58,
    IPPROTO_NONE___37 = 59,
    IPPROTO_DSTOPTS___37 = 60,
    IPPROTO_MH___37 = 135
} ;
enum __anonenum_662268580___37 {
    IPPORT_ECHO___37 = 7,
    IPPORT_DISCARD___37 = 9,
    IPPORT_SYSTAT___37 = 11,
    IPPORT_DAYTIME___37 = 13,
    IPPORT_NETSTAT___37 = 15,
    IPPORT_FTP___37 = 21,
    IPPORT_TELNET___37 = 23,
    IPPORT_SMTP___37 = 25,
    IPPORT_TIMESERVER___37 = 37,
    IPPORT_NAMESERVER___37 = 42,
    IPPORT_WHOIS___37 = 43,
    IPPORT_MTP___37 = 57,
    IPPORT_TFTP___37 = 69,
    IPPORT_RJE___37 = 77,
    IPPORT_FINGER___37 = 79,
    IPPORT_TTYLINK___37 = 87,
    IPPORT_SUPDUP___37 = 95,
    IPPORT_EXECSERVER___37 = 512,
    IPPORT_LOGINSERVER___37 = 513,
    IPPORT_CMDSERVER___37 = 514,
    IPPORT_EFSSERVER___37 = 520,
    IPPORT_BIFFUDP___37 = 512,
    IPPORT_WHOSERVER___37 = 513,
    IPPORT_ROUTESERVER___37 = 520,
    IPPORT_RESERVED___37 = 1024,
    IPPORT_USERRESERVED___37 = 5000
} ;
enum __anonenum_18926444___37 {
    _ISupper___37 = 256,
    _ISlower___37 = 512,
    _ISalpha___37 = 1024,
    _ISdigit___37 = 2048,
    _ISxdigit___37 = 4096,
    _ISspace___37 = 8192,
    _ISprint___37 = 16384,
    _ISgraph___37 = 32768,
    _ISblank___37 = 1,
    _IScntrl___37 = 2,
    _ISpunct___37 = 4,
    _ISalnum___37 = 8
} ;
enum __anonenum_913965969___37 {
    FP_INT_UPWARD___37 = 0,
    FP_INT_DOWNWARD___37 = 1,
    FP_INT_TOWARDZERO___37 = 2,
    FP_INT_TONEARESTFROMZERO___37 = 3,
    FP_INT_TONEAREST___37 = 4
} ;
enum __anonenum_1037408945___37 {
    FP_NAN___37 = 0,
    FP_INFINITE___37 = 1,
    FP_ZERO___37 = 2,
    FP_SUBNORMAL___37 = 3,
    FP_NORMAL___37 = 4
} ;
enum __anonenum_556971655___37 {
    SI_ASYNCNL___37 = -60,
    SI_DETHREAD___37 = -7,
    SI_TKILL___37 = -6,
    SI_SIGIO___37 = -5,
    SI_ASYNCIO___37 = -4,
    SI_MESGQ___37 = -3,
    SI_TIMER___37 = -2,
    SI_QUEUE___37 = -1,
    SI_USER___37 = 0,
    SI_KERNEL___37 = 128
} ;
enum __anonenum_640648963___37 {
    ILL_ILLOPC___37 = 1,
    ILL_ILLOPN___37 = 2,
    ILL_ILLADR___37 = 3,
    ILL_ILLTRP___37 = 4,
    ILL_PRVOPC___37 = 5,
    ILL_PRVREG___37 = 6,
    ILL_COPROC___37 = 7,
    ILL_BADSTK___37 = 8,
    ILL_BADIADDR___37 = 9
} ;
enum __anonenum_457704180___37 {
    FPE_INTDIV___37 = 1,
    FPE_INTOVF___37 = 2,
    FPE_FLTDIV___37 = 3,
    FPE_FLTOVF___37 = 4,
    FPE_FLTUND___37 = 5,
    FPE_FLTRES___37 = 6,
    FPE_FLTINV___37 = 7,
    FPE_FLTSUB___37 = 8,
    FPE_FLTUNK___37 = 14,
    FPE_CONDTRAP___37 = 15
} ;
enum __anonenum_180375148___37 {
    SEGV_MAPERR___37 = 1,
    SEGV_ACCERR___37 = 2,
    SEGV_BNDERR___37 = 3,
    SEGV_PKUERR___37 = 4,
    SEGV_ACCADI___37 = 5,
    SEGV_ADIDERR___37 = 6,
    SEGV_ADIPERR___37 = 7,
    SEGV_MTEAERR___37 = 8,
    SEGV_MTESERR___37 = 9
} ;
enum __anonenum_1036286214___37 {
    BUS_ADRALN___37 = 1,
    BUS_ADRERR___37 = 2,
    BUS_OBJERR___37 = 3,
    BUS_MCEERR_AR___37 = 4,
    BUS_MCEERR_AO___37 = 5
} ;
enum __anonenum_91015150___37 {
    TRAP_BRKPT___37 = 1,
    TRAP_TRACE___37 = 2,
    TRAP_BRANCH___37 = 3,
    TRAP_HWBKPT___37 = 4,
    TRAP_UNK___37 = 5
} ;
enum __anonenum_23175539___37 {
    CLD_EXITED___37 = 1,
    CLD_KILLED___37 = 2,
    CLD_DUMPED___37 = 3,
    CLD_TRAPPED___37 = 4,
    CLD_STOPPED___37 = 5,
    CLD_CONTINUED___37 = 6
} ;
enum __anonenum_111643124___37 {
    POLL_IN___37 = 1,
    POLL_OUT___37 = 2,
    POLL_MSG___37 = 3,
    POLL_ERR___37 = 4,
    POLL_PRI___37 = 5,
    POLL_HUP___37 = 6
} ;
enum __anonenum_852341087___37 {
    SIGEV_SIGNAL___37 = 0,
    SIGEV_NONE___37 = 1,
    SIGEV_THREAD___37 = 2,
    SIGEV_THREAD_ID___37 = 4
} ;
enum __anonenum_451154152___37 {
    REG_R8___37 = 0,
    REG_R9___37 = 1,
    REG_R10___37 = 2,
    REG_R11___37 = 3,
    REG_R12___37 = 4,
    REG_R13___37 = 5,
    REG_R14___37 = 6,
    REG_R15___37 = 7,
    REG_RDI___37 = 8,
    REG_RSI___37 = 9,
    REG_RBP___37 = 10,
    REG_RBX___37 = 11,
    REG_RDX___37 = 12,
    REG_RAX___37 = 13,
    REG_RCX___37 = 14,
    REG_RSP___37 = 15,
    REG_RIP___37 = 16,
    REG_EFL___37 = 17,
    REG_CSGSFS___37 = 18,
    REG_ERR___37 = 19,
    REG_TRAPNO___37 = 20,
    REG_OLDMASK___37 = 21,
    REG_CR2___37 = 22
} ;
enum __anonenum_437032235___37 {
    _PC_LINK_MAX___37 = 0,
    _PC_MAX_CANON___37 = 1,
    _PC_MAX_INPUT___37 = 2,
    _PC_NAME_MAX___37 = 3,
    _PC_PATH_MAX___37 = 4,
    _PC_PIPE_BUF___37 = 5,
    _PC_CHOWN_RESTRICTED___37 = 6,
    _PC_NO_TRUNC___37 = 7,
    _PC_VDISABLE___37 = 8,
    _PC_SYNC_IO___37 = 9,
    _PC_ASYNC_IO___37 = 10,
    _PC_PRIO_IO___37 = 11,
    _PC_SOCK_MAXBUF___37 = 12,
    _PC_FILESIZEBITS___37 = 13,
    _PC_REC_INCR_XFER_SIZE___37 = 14,
    _PC_REC_MAX_XFER_SIZE___37 = 15,
    _PC_REC_MIN_XFER_SIZE___37 = 16,
    _PC_REC_XFER_ALIGN___37 = 17,
    _PC_ALLOC_SIZE_MIN___37 = 18,
    _PC_SYMLINK_MAX___37 = 19,
    _PC_2_SYMLINKS___37 = 20
} ;
enum __anonenum_315186338___37 {
    _SC_ARG_MAX___37 = 0,
    _SC_CHILD_MAX___37 = 1,
    _SC_CLK_TCK___37 = 2,
    _SC_NGROUPS_MAX___37 = 3,
    _SC_OPEN_MAX___37 = 4,
    _SC_STREAM_MAX___37 = 5,
    _SC_TZNAME_MAX___37 = 6,
    _SC_JOB_CONTROL___37 = 7,
    _SC_SAVED_IDS___37 = 8,
    _SC_REALTIME_SIGNALS___37 = 9,
    _SC_PRIORITY_SCHEDULING___37 = 10,
    _SC_TIMERS___37 = 11,
    _SC_ASYNCHRONOUS_IO___37 = 12,
    _SC_PRIORITIZED_IO___37 = 13,
    _SC_SYNCHRONIZED_IO___37 = 14,
    _SC_FSYNC___37 = 15,
    _SC_MAPPED_FILES___37 = 16,
    _SC_MEMLOCK___37 = 17,
    _SC_MEMLOCK_RANGE___37 = 18,
    _SC_MEMORY_PROTECTION___37 = 19,
    _SC_MESSAGE_PASSING___37 = 20,
    _SC_SEMAPHORES___37 = 21,
    _SC_SHARED_MEMORY_OBJECTS___37 = 22,
    _SC_AIO_LISTIO_MAX___37 = 23,
    _SC_AIO_MAX___37 = 24,
    _SC_AIO_PRIO_DELTA_MAX___37 = 25,
    _SC_DELAYTIMER_MAX___37 = 26,
    _SC_MQ_OPEN_MAX___37 = 27,
    _SC_MQ_PRIO_MAX___37 = 28,
    _SC_VERSION___37 = 29,
    _SC_PAGESIZE___37 = 30,
    _SC_RTSIG_MAX___37 = 31,
    _SC_SEM_NSEMS_MAX___37 = 32,
    _SC_SEM_VALUE_MAX___37 = 33,
    _SC_SIGQUEUE_MAX___37 = 34,
    _SC_TIMER_MAX___37 = 35,
    _SC_BC_BASE_MAX___37 = 36,
    _SC_BC_DIM_MAX___37 = 37,
    _SC_BC_SCALE_MAX___37 = 38,
    _SC_BC_STRING_MAX___37 = 39,
    _SC_COLL_WEIGHTS_MAX___37 = 40,
    _SC_EQUIV_CLASS_MAX___37 = 41,
    _SC_EXPR_NEST_MAX___37 = 42,
    _SC_LINE_MAX___37 = 43,
    _SC_RE_DUP_MAX___37 = 44,
    _SC_CHARCLASS_NAME_MAX___37 = 45,
    _SC_2_VERSION___37 = 46,
    _SC_2_C_BIND___37 = 47,
    _SC_2_C_DEV___37 = 48,
    _SC_2_FORT_DEV___37 = 49,
    _SC_2_FORT_RUN___37 = 50,
    _SC_2_SW_DEV___37 = 51,
    _SC_2_LOCALEDEF___37 = 52,
    _SC_PII___37 = 53,
    _SC_PII_XTI___37 = 54,
    _SC_PII_SOCKET___37 = 55,
    _SC_PII_INTERNET___37 = 56,
    _SC_PII_OSI___37 = 57,
    _SC_POLL___37 = 58,
    _SC_SELECT___37 = 59,
    _SC_UIO_MAXIOV___37 = 60,
    _SC_IOV_MAX___37 = 60,
    _SC_PII_INTERNET_STREAM___37 = 61,
    _SC_PII_INTERNET_DGRAM___37 = 62,
    _SC_PII_OSI_COTS___37 = 63,
    _SC_PII_OSI_CLTS___37 = 64,
    _SC_PII_OSI_M___37 = 65,
    _SC_T_IOV_MAX___37 = 66,
    _SC_THREADS___37 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___37 = 68,
    _SC_GETGR_R_SIZE_MAX___37 = 69,
    _SC_GETPW_R_SIZE_MAX___37 = 70,
    _SC_LOGIN_NAME_MAX___37 = 71,
    _SC_TTY_NAME_MAX___37 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___37 = 73,
    _SC_THREAD_KEYS_MAX___37 = 74,
    _SC_THREAD_STACK_MIN___37 = 75,
    _SC_THREAD_THREADS_MAX___37 = 76,
    _SC_THREAD_ATTR_STACKADDR___37 = 77,
    _SC_THREAD_ATTR_STACKSIZE___37 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___37 = 79,
    _SC_THREAD_PRIO_INHERIT___37 = 80,
    _SC_THREAD_PRIO_PROTECT___37 = 81,
    _SC_THREAD_PROCESS_SHARED___37 = 82,
    _SC_NPROCESSORS_CONF___37 = 83,
    _SC_NPROCESSORS_ONLN___37 = 84,
    _SC_PHYS_PAGES___37 = 85,
    _SC_AVPHYS_PAGES___37 = 86,
    _SC_ATEXIT_MAX___37 = 87,
    _SC_PASS_MAX___37 = 88,
    _SC_XOPEN_VERSION___37 = 89,
    _SC_XOPEN_XCU_VERSION___37 = 90,
    _SC_XOPEN_UNIX___37 = 91,
    _SC_XOPEN_CRYPT___37 = 92,
    _SC_XOPEN_ENH_I18N___37 = 93,
    _SC_XOPEN_SHM___37 = 94,
    _SC_2_CHAR_TERM___37 = 95,
    _SC_2_C_VERSION___37 = 96,
    _SC_2_UPE___37 = 97,
    _SC_XOPEN_XPG2___37 = 98,
    _SC_XOPEN_XPG3___37 = 99,
    _SC_XOPEN_XPG4___37 = 100,
    _SC_CHAR_BIT___37 = 101,
    _SC_CHAR_MAX___37 = 102,
    _SC_CHAR_MIN___37 = 103,
    _SC_INT_MAX___37 = 104,
    _SC_INT_MIN___37 = 105,
    _SC_LONG_BIT___37 = 106,
    _SC_WORD_BIT___37 = 107,
    _SC_MB_LEN_MAX___37 = 108,
    _SC_NZERO___37 = 109,
    _SC_SSIZE_MAX___37 = 110,
    _SC_SCHAR_MAX___37 = 111,
    _SC_SCHAR_MIN___37 = 112,
    _SC_SHRT_MAX___37 = 113,
    _SC_SHRT_MIN___37 = 114,
    _SC_UCHAR_MAX___37 = 115,
    _SC_UINT_MAX___37 = 116,
    _SC_ULONG_MAX___37 = 117,
    _SC_USHRT_MAX___37 = 118,
    _SC_NL_ARGMAX___37 = 119,
    _SC_NL_LANGMAX___37 = 120,
    _SC_NL_MSGMAX___37 = 121,
    _SC_NL_NMAX___37 = 122,
    _SC_NL_SETMAX___37 = 123,
    _SC_NL_TEXTMAX___37 = 124,
    _SC_XBS5_ILP32_OFF32___37 = 125,
    _SC_XBS5_ILP32_OFFBIG___37 = 126,
    _SC_XBS5_LP64_OFF64___37 = 127,
    _SC_XBS5_LPBIG_OFFBIG___37 = 128,
    _SC_XOPEN_LEGACY___37 = 129,
    _SC_XOPEN_REALTIME___37 = 130,
    _SC_XOPEN_REALTIME_THREADS___37 = 131,
    _SC_ADVISORY_INFO___37 = 132,
    _SC_BARRIERS___37 = 133,
    _SC_BASE___37 = 134,
    _SC_C_LANG_SUPPORT___37 = 135,
    _SC_C_LANG_SUPPORT_R___37 = 136,
    _SC_CLOCK_SELECTION___37 = 137,
    _SC_CPUTIME___37 = 138,
    _SC_THREAD_CPUTIME___37 = 139,
    _SC_DEVICE_IO___37 = 140,
    _SC_DEVICE_SPECIFIC___37 = 141,
    _SC_DEVICE_SPECIFIC_R___37 = 142,
    _SC_FD_MGMT___37 = 143,
    _SC_FIFO___37 = 144,
    _SC_PIPE___37 = 145,
    _SC_FILE_ATTRIBUTES___37 = 146,
    _SC_FILE_LOCKING___37 = 147,
    _SC_FILE_SYSTEM___37 = 148,
    _SC_MONOTONIC_CLOCK___37 = 149,
    _SC_MULTI_PROCESS___37 = 150,
    _SC_SINGLE_PROCESS___37 = 151,
    _SC_NETWORKING___37 = 152,
    _SC_READER_WRITER_LOCKS___37 = 153,
    _SC_SPIN_LOCKS___37 = 154,
    _SC_REGEXP___37 = 155,
    _SC_REGEX_VERSION___37 = 156,
    _SC_SHELL___37 = 157,
    _SC_SIGNALS___37 = 158,
    _SC_SPAWN___37 = 159,
    _SC_SPORADIC_SERVER___37 = 160,
    _SC_THREAD_SPORADIC_SERVER___37 = 161,
    _SC_SYSTEM_DATABASE___37 = 162,
    _SC_SYSTEM_DATABASE_R___37 = 163,
    _SC_TIMEOUTS___37 = 164,
    _SC_TYPED_MEMORY_OBJECTS___37 = 165,
    _SC_USER_GROUPS___37 = 166,
    _SC_USER_GROUPS_R___37 = 167,
    _SC_2_PBS___37 = 168,
    _SC_2_PBS_ACCOUNTING___37 = 169,
    _SC_2_PBS_LOCATE___37 = 170,
    _SC_2_PBS_MESSAGE___37 = 171,
    _SC_2_PBS_TRACK___37 = 172,
    _SC_SYMLOOP_MAX___37 = 173,
    _SC_STREAMS___37 = 174,
    _SC_2_PBS_CHECKPOINT___37 = 175,
    _SC_V6_ILP32_OFF32___37 = 176,
    _SC_V6_ILP32_OFFBIG___37 = 177,
    _SC_V6_LP64_OFF64___37 = 178,
    _SC_V6_LPBIG_OFFBIG___37 = 179,
    _SC_HOST_NAME_MAX___37 = 180,
    _SC_TRACE___37 = 181,
    _SC_TRACE_EVENT_FILTER___37 = 182,
    _SC_TRACE_INHERIT___37 = 183,
    _SC_TRACE_LOG___37 = 184,
    _SC_LEVEL1_ICACHE_SIZE___37 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___37 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___37 = 187,
    _SC_LEVEL1_DCACHE_SIZE___37 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___37 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___37 = 190,
    _SC_LEVEL2_CACHE_SIZE___37 = 191,
    _SC_LEVEL2_CACHE_ASSOC___37 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___37 = 193,
    _SC_LEVEL3_CACHE_SIZE___37 = 194,
    _SC_LEVEL3_CACHE_ASSOC___37 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___37 = 196,
    _SC_LEVEL4_CACHE_SIZE___37 = 197,
    _SC_LEVEL4_CACHE_ASSOC___37 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___37 = 199,
    _SC_IPV6___37 = 235,
    _SC_RAW_SOCKETS___37 = 236,
    _SC_V7_ILP32_OFF32___37 = 237,
    _SC_V7_ILP32_OFFBIG___37 = 238,
    _SC_V7_LP64_OFF64___37 = 239,
    _SC_V7_LPBIG_OFFBIG___37 = 240,
    _SC_SS_REPL_MAX___37 = 241,
    _SC_TRACE_EVENT_NAME_MAX___37 = 242,
    _SC_TRACE_NAME_MAX___37 = 243,
    _SC_TRACE_SYS_MAX___37 = 244,
    _SC_TRACE_USER_EVENT_MAX___37 = 245,
    _SC_XOPEN_STREAMS___37 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___37 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___37 = 248,
    _SC_MINSIGSTKSZ___37 = 249,
    _SC_SIGSTKSZ___37 = 250
} ;
enum __anonenum_875524036___37 {
    _CS_PATH___37 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___37 = 1,
    _CS_GNU_LIBC_VERSION___37 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___37 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___37 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___37 = 5,
    _CS_LFS_CFLAGS___37 = 1000,
    _CS_LFS_LDFLAGS___37 = 1001,
    _CS_LFS_LIBS___37 = 1002,
    _CS_LFS_LINTFLAGS___37 = 1003,
    _CS_LFS64_CFLAGS___37 = 1004,
    _CS_LFS64_LDFLAGS___37 = 1005,
    _CS_LFS64_LIBS___37 = 1006,
    _CS_LFS64_LINTFLAGS___37 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___37 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___37 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___37 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___37 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___37 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___37 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___37 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___37 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___37 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___37 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___37 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___37 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___37 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___37 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___37 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___37 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___37 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___37 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___37 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___37 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___37 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___37 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___37 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___37 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___37 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___37 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___37 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___37 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___37 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___37 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___37 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___37 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___37 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___37 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___37 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___37 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___37 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___37 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___37 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___37 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___37 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___37 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___37 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___37 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___37 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___37 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___37 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___37 = 1147,
    _CS_V6_ENV___37 = 1148,
    _CS_V7_ENV___37 = 1149
} ;
enum __anonenum_57186863___37 {
    SS_ONSTACK___37 = 1,
    SS_DISABLE___37 = 2
} ;
struct HCL_Instance_Record ;
typedef struct HCL_Instance_Record *HCL_Instance;
struct phc_instance {
   int fd ;
   int mode ;
   int nocrossts ;
   int extpps ;
   int pin ;
   int channel ;
   HCL_Instance clock ;
};
enum __anonenum_83571709___38 {
    MSG_OOB___38 = 1,
    MSG_PEEK___38 = 2,
    MSG_DONTROUTE___38 = 4,
    MSG_TRYHARD___38 = 4,
    MSG_CTRUNC___38 = 8,
    MSG_PROXY___38 = 16,
    MSG_TRUNC___38 = 32,
    MSG_DONTWAIT___38 = 64,
    MSG_EOR___38 = 128,
    MSG_WAITALL___38 = 256,
    MSG_FIN___38 = 512,
    MSG_SYN___38 = 1024,
    MSG_CONFIRM___38 = 2048,
    MSG_RST___38 = 4096,
    MSG_ERRQUEUE___38 = 8192,
    MSG_NOSIGNAL___38 = 16384,
    MSG_MORE___38 = 32768,
    MSG_WAITFORONE___38 = 65536,
    MSG_BATCH___38 = 262144,
    MSG_ZEROCOPY___38 = 67108864,
    MSG_FASTOPEN___38 = 536870912,
    MSG_CMSG_CLOEXEC___38 = 1073741824
} ;
enum __anonenum_617082774___38 {
    SCM_RIGHTS___38 = 1,
    SCM_CREDENTIALS___38 = 2
} ;
enum __anonenum_606441560___38 {
    SHUT_RD___38 = 0,
    SHUT_WR___38 = 1,
    SHUT_RDWR___38 = 2
} ;
enum __anonenum_264779956___38 {
    IPPROTO_IP___38 = 0,
    IPPROTO_ICMP___38 = 1,
    IPPROTO_IGMP___38 = 2,
    IPPROTO_IPIP___38 = 4,
    IPPROTO_TCP___38 = 6,
    IPPROTO_EGP___38 = 8,
    IPPROTO_PUP___38 = 12,
    IPPROTO_UDP___38 = 17,
    IPPROTO_IDP___38 = 22,
    IPPROTO_TP___38 = 29,
    IPPROTO_DCCP___38 = 33,
    IPPROTO_IPV6___38 = 41,
    IPPROTO_RSVP___38 = 46,
    IPPROTO_GRE___38 = 47,
    IPPROTO_ESP___38 = 50,
    IPPROTO_AH___38 = 51,
    IPPROTO_MTP___38 = 92,
    IPPROTO_BEETPH___38 = 94,
    IPPROTO_ENCAP___38 = 98,
    IPPROTO_PIM___38 = 103,
    IPPROTO_COMP___38 = 108,
    IPPROTO_SCTP___38 = 132,
    IPPROTO_UDPLITE___38 = 136,
    IPPROTO_MPLS___38 = 137,
    IPPROTO_ETHERNET___38 = 143,
    IPPROTO_RAW___38 = 255,
    IPPROTO_MPTCP___38 = 262,
    IPPROTO_MAX___38 = 263
} ;
enum __anonenum_218739988___38 {
    IPPROTO_HOPOPTS___38 = 0,
    IPPROTO_ROUTING___38 = 43,
    IPPROTO_FRAGMENT___38 = 44,
    IPPROTO_ICMPV6___38 = 58,
    IPPROTO_NONE___38 = 59,
    IPPROTO_DSTOPTS___38 = 60,
    IPPROTO_MH___38 = 135
} ;
enum __anonenum_662268580___38 {
    IPPORT_ECHO___38 = 7,
    IPPORT_DISCARD___38 = 9,
    IPPORT_SYSTAT___38 = 11,
    IPPORT_DAYTIME___38 = 13,
    IPPORT_NETSTAT___38 = 15,
    IPPORT_FTP___38 = 21,
    IPPORT_TELNET___38 = 23,
    IPPORT_SMTP___38 = 25,
    IPPORT_TIMESERVER___38 = 37,
    IPPORT_NAMESERVER___38 = 42,
    IPPORT_WHOIS___38 = 43,
    IPPORT_MTP___38 = 57,
    IPPORT_TFTP___38 = 69,
    IPPORT_RJE___38 = 77,
    IPPORT_FINGER___38 = 79,
    IPPORT_TTYLINK___38 = 87,
    IPPORT_SUPDUP___38 = 95,
    IPPORT_EXECSERVER___38 = 512,
    IPPORT_LOGINSERVER___38 = 513,
    IPPORT_CMDSERVER___38 = 514,
    IPPORT_EFSSERVER___38 = 520,
    IPPORT_BIFFUDP___38 = 512,
    IPPORT_WHOSERVER___38 = 513,
    IPPORT_ROUTESERVER___38 = 520,
    IPPORT_RESERVED___38 = 1024,
    IPPORT_USERRESERVED___38 = 5000
} ;
enum __anonenum_18926444___38 {
    _ISupper___38 = 256,
    _ISlower___38 = 512,
    _ISalpha___38 = 1024,
    _ISdigit___38 = 2048,
    _ISxdigit___38 = 4096,
    _ISspace___38 = 8192,
    _ISprint___38 = 16384,
    _ISgraph___38 = 32768,
    _ISblank___38 = 1,
    _IScntrl___38 = 2,
    _ISpunct___38 = 4,
    _ISalnum___38 = 8
} ;
enum __anonenum_913965969___38 {
    FP_INT_UPWARD___38 = 0,
    FP_INT_DOWNWARD___38 = 1,
    FP_INT_TOWARDZERO___38 = 2,
    FP_INT_TONEARESTFROMZERO___38 = 3,
    FP_INT_TONEAREST___38 = 4
} ;
enum __anonenum_1037408945___38 {
    FP_NAN___38 = 0,
    FP_INFINITE___38 = 1,
    FP_ZERO___38 = 2,
    FP_SUBNORMAL___38 = 3,
    FP_NORMAL___38 = 4
} ;
enum __anonenum_556971655___38 {
    SI_ASYNCNL___38 = -60,
    SI_DETHREAD___38 = -7,
    SI_TKILL___38 = -6,
    SI_SIGIO___38 = -5,
    SI_ASYNCIO___38 = -4,
    SI_MESGQ___38 = -3,
    SI_TIMER___38 = -2,
    SI_QUEUE___38 = -1,
    SI_USER___38 = 0,
    SI_KERNEL___38 = 128
} ;
enum __anonenum_640648963___38 {
    ILL_ILLOPC___38 = 1,
    ILL_ILLOPN___38 = 2,
    ILL_ILLADR___38 = 3,
    ILL_ILLTRP___38 = 4,
    ILL_PRVOPC___38 = 5,
    ILL_PRVREG___38 = 6,
    ILL_COPROC___38 = 7,
    ILL_BADSTK___38 = 8,
    ILL_BADIADDR___38 = 9
} ;
enum __anonenum_457704180___38 {
    FPE_INTDIV___38 = 1,
    FPE_INTOVF___38 = 2,
    FPE_FLTDIV___38 = 3,
    FPE_FLTOVF___38 = 4,
    FPE_FLTUND___38 = 5,
    FPE_FLTRES___38 = 6,
    FPE_FLTINV___38 = 7,
    FPE_FLTSUB___38 = 8,
    FPE_FLTUNK___38 = 14,
    FPE_CONDTRAP___38 = 15
} ;
enum __anonenum_180375148___38 {
    SEGV_MAPERR___38 = 1,
    SEGV_ACCERR___38 = 2,
    SEGV_BNDERR___38 = 3,
    SEGV_PKUERR___38 = 4,
    SEGV_ACCADI___38 = 5,
    SEGV_ADIDERR___38 = 6,
    SEGV_ADIPERR___38 = 7,
    SEGV_MTEAERR___38 = 8,
    SEGV_MTESERR___38 = 9
} ;
enum __anonenum_1036286214___38 {
    BUS_ADRALN___38 = 1,
    BUS_ADRERR___38 = 2,
    BUS_OBJERR___38 = 3,
    BUS_MCEERR_AR___38 = 4,
    BUS_MCEERR_AO___38 = 5
} ;
enum __anonenum_91015150___38 {
    TRAP_BRKPT___38 = 1,
    TRAP_TRACE___38 = 2,
    TRAP_BRANCH___38 = 3,
    TRAP_HWBKPT___38 = 4,
    TRAP_UNK___38 = 5
} ;
enum __anonenum_23175539___38 {
    CLD_EXITED___38 = 1,
    CLD_KILLED___38 = 2,
    CLD_DUMPED___38 = 3,
    CLD_TRAPPED___38 = 4,
    CLD_STOPPED___38 = 5,
    CLD_CONTINUED___38 = 6
} ;
enum __anonenum_111643124___38 {
    POLL_IN___38 = 1,
    POLL_OUT___38 = 2,
    POLL_MSG___38 = 3,
    POLL_ERR___38 = 4,
    POLL_PRI___38 = 5,
    POLL_HUP___38 = 6
} ;
enum __anonenum_852341087___38 {
    SIGEV_SIGNAL___38 = 0,
    SIGEV_NONE___38 = 1,
    SIGEV_THREAD___38 = 2,
    SIGEV_THREAD_ID___38 = 4
} ;
enum __anonenum_451154152___38 {
    REG_R8___38 = 0,
    REG_R9___38 = 1,
    REG_R10___38 = 2,
    REG_R11___38 = 3,
    REG_R12___38 = 4,
    REG_R13___38 = 5,
    REG_R14___38 = 6,
    REG_R15___38 = 7,
    REG_RDI___38 = 8,
    REG_RSI___38 = 9,
    REG_RBP___38 = 10,
    REG_RBX___38 = 11,
    REG_RDX___38 = 12,
    REG_RAX___38 = 13,
    REG_RCX___38 = 14,
    REG_RSP___38 = 15,
    REG_RIP___38 = 16,
    REG_EFL___38 = 17,
    REG_CSGSFS___38 = 18,
    REG_ERR___38 = 19,
    REG_TRAPNO___38 = 20,
    REG_OLDMASK___38 = 21,
    REG_CR2___38 = 22
} ;
enum __anonenum_437032235___38 {
    _PC_LINK_MAX___38 = 0,
    _PC_MAX_CANON___38 = 1,
    _PC_MAX_INPUT___38 = 2,
    _PC_NAME_MAX___38 = 3,
    _PC_PATH_MAX___38 = 4,
    _PC_PIPE_BUF___38 = 5,
    _PC_CHOWN_RESTRICTED___38 = 6,
    _PC_NO_TRUNC___38 = 7,
    _PC_VDISABLE___38 = 8,
    _PC_SYNC_IO___38 = 9,
    _PC_ASYNC_IO___38 = 10,
    _PC_PRIO_IO___38 = 11,
    _PC_SOCK_MAXBUF___38 = 12,
    _PC_FILESIZEBITS___38 = 13,
    _PC_REC_INCR_XFER_SIZE___38 = 14,
    _PC_REC_MAX_XFER_SIZE___38 = 15,
    _PC_REC_MIN_XFER_SIZE___38 = 16,
    _PC_REC_XFER_ALIGN___38 = 17,
    _PC_ALLOC_SIZE_MIN___38 = 18,
    _PC_SYMLINK_MAX___38 = 19,
    _PC_2_SYMLINKS___38 = 20
} ;
enum __anonenum_315186338___38 {
    _SC_ARG_MAX___38 = 0,
    _SC_CHILD_MAX___38 = 1,
    _SC_CLK_TCK___38 = 2,
    _SC_NGROUPS_MAX___38 = 3,
    _SC_OPEN_MAX___38 = 4,
    _SC_STREAM_MAX___38 = 5,
    _SC_TZNAME_MAX___38 = 6,
    _SC_JOB_CONTROL___38 = 7,
    _SC_SAVED_IDS___38 = 8,
    _SC_REALTIME_SIGNALS___38 = 9,
    _SC_PRIORITY_SCHEDULING___38 = 10,
    _SC_TIMERS___38 = 11,
    _SC_ASYNCHRONOUS_IO___38 = 12,
    _SC_PRIORITIZED_IO___38 = 13,
    _SC_SYNCHRONIZED_IO___38 = 14,
    _SC_FSYNC___38 = 15,
    _SC_MAPPED_FILES___38 = 16,
    _SC_MEMLOCK___38 = 17,
    _SC_MEMLOCK_RANGE___38 = 18,
    _SC_MEMORY_PROTECTION___38 = 19,
    _SC_MESSAGE_PASSING___38 = 20,
    _SC_SEMAPHORES___38 = 21,
    _SC_SHARED_MEMORY_OBJECTS___38 = 22,
    _SC_AIO_LISTIO_MAX___38 = 23,
    _SC_AIO_MAX___38 = 24,
    _SC_AIO_PRIO_DELTA_MAX___38 = 25,
    _SC_DELAYTIMER_MAX___38 = 26,
    _SC_MQ_OPEN_MAX___38 = 27,
    _SC_MQ_PRIO_MAX___38 = 28,
    _SC_VERSION___38 = 29,
    _SC_PAGESIZE___38 = 30,
    _SC_RTSIG_MAX___38 = 31,
    _SC_SEM_NSEMS_MAX___38 = 32,
    _SC_SEM_VALUE_MAX___38 = 33,
    _SC_SIGQUEUE_MAX___38 = 34,
    _SC_TIMER_MAX___38 = 35,
    _SC_BC_BASE_MAX___38 = 36,
    _SC_BC_DIM_MAX___38 = 37,
    _SC_BC_SCALE_MAX___38 = 38,
    _SC_BC_STRING_MAX___38 = 39,
    _SC_COLL_WEIGHTS_MAX___38 = 40,
    _SC_EQUIV_CLASS_MAX___38 = 41,
    _SC_EXPR_NEST_MAX___38 = 42,
    _SC_LINE_MAX___38 = 43,
    _SC_RE_DUP_MAX___38 = 44,
    _SC_CHARCLASS_NAME_MAX___38 = 45,
    _SC_2_VERSION___38 = 46,
    _SC_2_C_BIND___38 = 47,
    _SC_2_C_DEV___38 = 48,
    _SC_2_FORT_DEV___38 = 49,
    _SC_2_FORT_RUN___38 = 50,
    _SC_2_SW_DEV___38 = 51,
    _SC_2_LOCALEDEF___38 = 52,
    _SC_PII___38 = 53,
    _SC_PII_XTI___38 = 54,
    _SC_PII_SOCKET___38 = 55,
    _SC_PII_INTERNET___38 = 56,
    _SC_PII_OSI___38 = 57,
    _SC_POLL___38 = 58,
    _SC_SELECT___38 = 59,
    _SC_UIO_MAXIOV___38 = 60,
    _SC_IOV_MAX___38 = 60,
    _SC_PII_INTERNET_STREAM___38 = 61,
    _SC_PII_INTERNET_DGRAM___38 = 62,
    _SC_PII_OSI_COTS___38 = 63,
    _SC_PII_OSI_CLTS___38 = 64,
    _SC_PII_OSI_M___38 = 65,
    _SC_T_IOV_MAX___38 = 66,
    _SC_THREADS___38 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___38 = 68,
    _SC_GETGR_R_SIZE_MAX___38 = 69,
    _SC_GETPW_R_SIZE_MAX___38 = 70,
    _SC_LOGIN_NAME_MAX___38 = 71,
    _SC_TTY_NAME_MAX___38 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___38 = 73,
    _SC_THREAD_KEYS_MAX___38 = 74,
    _SC_THREAD_STACK_MIN___38 = 75,
    _SC_THREAD_THREADS_MAX___38 = 76,
    _SC_THREAD_ATTR_STACKADDR___38 = 77,
    _SC_THREAD_ATTR_STACKSIZE___38 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___38 = 79,
    _SC_THREAD_PRIO_INHERIT___38 = 80,
    _SC_THREAD_PRIO_PROTECT___38 = 81,
    _SC_THREAD_PROCESS_SHARED___38 = 82,
    _SC_NPROCESSORS_CONF___38 = 83,
    _SC_NPROCESSORS_ONLN___38 = 84,
    _SC_PHYS_PAGES___38 = 85,
    _SC_AVPHYS_PAGES___38 = 86,
    _SC_ATEXIT_MAX___38 = 87,
    _SC_PASS_MAX___38 = 88,
    _SC_XOPEN_VERSION___38 = 89,
    _SC_XOPEN_XCU_VERSION___38 = 90,
    _SC_XOPEN_UNIX___38 = 91,
    _SC_XOPEN_CRYPT___38 = 92,
    _SC_XOPEN_ENH_I18N___38 = 93,
    _SC_XOPEN_SHM___38 = 94,
    _SC_2_CHAR_TERM___38 = 95,
    _SC_2_C_VERSION___38 = 96,
    _SC_2_UPE___38 = 97,
    _SC_XOPEN_XPG2___38 = 98,
    _SC_XOPEN_XPG3___38 = 99,
    _SC_XOPEN_XPG4___38 = 100,
    _SC_CHAR_BIT___38 = 101,
    _SC_CHAR_MAX___38 = 102,
    _SC_CHAR_MIN___38 = 103,
    _SC_INT_MAX___38 = 104,
    _SC_INT_MIN___38 = 105,
    _SC_LONG_BIT___38 = 106,
    _SC_WORD_BIT___38 = 107,
    _SC_MB_LEN_MAX___38 = 108,
    _SC_NZERO___38 = 109,
    _SC_SSIZE_MAX___38 = 110,
    _SC_SCHAR_MAX___38 = 111,
    _SC_SCHAR_MIN___38 = 112,
    _SC_SHRT_MAX___38 = 113,
    _SC_SHRT_MIN___38 = 114,
    _SC_UCHAR_MAX___38 = 115,
    _SC_UINT_MAX___38 = 116,
    _SC_ULONG_MAX___38 = 117,
    _SC_USHRT_MAX___38 = 118,
    _SC_NL_ARGMAX___38 = 119,
    _SC_NL_LANGMAX___38 = 120,
    _SC_NL_MSGMAX___38 = 121,
    _SC_NL_NMAX___38 = 122,
    _SC_NL_SETMAX___38 = 123,
    _SC_NL_TEXTMAX___38 = 124,
    _SC_XBS5_ILP32_OFF32___38 = 125,
    _SC_XBS5_ILP32_OFFBIG___38 = 126,
    _SC_XBS5_LP64_OFF64___38 = 127,
    _SC_XBS5_LPBIG_OFFBIG___38 = 128,
    _SC_XOPEN_LEGACY___38 = 129,
    _SC_XOPEN_REALTIME___38 = 130,
    _SC_XOPEN_REALTIME_THREADS___38 = 131,
    _SC_ADVISORY_INFO___38 = 132,
    _SC_BARRIERS___38 = 133,
    _SC_BASE___38 = 134,
    _SC_C_LANG_SUPPORT___38 = 135,
    _SC_C_LANG_SUPPORT_R___38 = 136,
    _SC_CLOCK_SELECTION___38 = 137,
    _SC_CPUTIME___38 = 138,
    _SC_THREAD_CPUTIME___38 = 139,
    _SC_DEVICE_IO___38 = 140,
    _SC_DEVICE_SPECIFIC___38 = 141,
    _SC_DEVICE_SPECIFIC_R___38 = 142,
    _SC_FD_MGMT___38 = 143,
    _SC_FIFO___38 = 144,
    _SC_PIPE___38 = 145,
    _SC_FILE_ATTRIBUTES___38 = 146,
    _SC_FILE_LOCKING___38 = 147,
    _SC_FILE_SYSTEM___38 = 148,
    _SC_MONOTONIC_CLOCK___38 = 149,
    _SC_MULTI_PROCESS___38 = 150,
    _SC_SINGLE_PROCESS___38 = 151,
    _SC_NETWORKING___38 = 152,
    _SC_READER_WRITER_LOCKS___38 = 153,
    _SC_SPIN_LOCKS___38 = 154,
    _SC_REGEXP___38 = 155,
    _SC_REGEX_VERSION___38 = 156,
    _SC_SHELL___38 = 157,
    _SC_SIGNALS___38 = 158,
    _SC_SPAWN___38 = 159,
    _SC_SPORADIC_SERVER___38 = 160,
    _SC_THREAD_SPORADIC_SERVER___38 = 161,
    _SC_SYSTEM_DATABASE___38 = 162,
    _SC_SYSTEM_DATABASE_R___38 = 163,
    _SC_TIMEOUTS___38 = 164,
    _SC_TYPED_MEMORY_OBJECTS___38 = 165,
    _SC_USER_GROUPS___38 = 166,
    _SC_USER_GROUPS_R___38 = 167,
    _SC_2_PBS___38 = 168,
    _SC_2_PBS_ACCOUNTING___38 = 169,
    _SC_2_PBS_LOCATE___38 = 170,
    _SC_2_PBS_MESSAGE___38 = 171,
    _SC_2_PBS_TRACK___38 = 172,
    _SC_SYMLOOP_MAX___38 = 173,
    _SC_STREAMS___38 = 174,
    _SC_2_PBS_CHECKPOINT___38 = 175,
    _SC_V6_ILP32_OFF32___38 = 176,
    _SC_V6_ILP32_OFFBIG___38 = 177,
    _SC_V6_LP64_OFF64___38 = 178,
    _SC_V6_LPBIG_OFFBIG___38 = 179,
    _SC_HOST_NAME_MAX___38 = 180,
    _SC_TRACE___38 = 181,
    _SC_TRACE_EVENT_FILTER___38 = 182,
    _SC_TRACE_INHERIT___38 = 183,
    _SC_TRACE_LOG___38 = 184,
    _SC_LEVEL1_ICACHE_SIZE___38 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___38 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___38 = 187,
    _SC_LEVEL1_DCACHE_SIZE___38 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___38 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___38 = 190,
    _SC_LEVEL2_CACHE_SIZE___38 = 191,
    _SC_LEVEL2_CACHE_ASSOC___38 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___38 = 193,
    _SC_LEVEL3_CACHE_SIZE___38 = 194,
    _SC_LEVEL3_CACHE_ASSOC___38 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___38 = 196,
    _SC_LEVEL4_CACHE_SIZE___38 = 197,
    _SC_LEVEL4_CACHE_ASSOC___38 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___38 = 199,
    _SC_IPV6___38 = 235,
    _SC_RAW_SOCKETS___38 = 236,
    _SC_V7_ILP32_OFF32___38 = 237,
    _SC_V7_ILP32_OFFBIG___38 = 238,
    _SC_V7_LP64_OFF64___38 = 239,
    _SC_V7_LPBIG_OFFBIG___38 = 240,
    _SC_SS_REPL_MAX___38 = 241,
    _SC_TRACE_EVENT_NAME_MAX___38 = 242,
    _SC_TRACE_NAME_MAX___38 = 243,
    _SC_TRACE_SYS_MAX___38 = 244,
    _SC_TRACE_USER_EVENT_MAX___38 = 245,
    _SC_XOPEN_STREAMS___38 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___38 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___38 = 248,
    _SC_MINSIGSTKSZ___38 = 249,
    _SC_SIGSTKSZ___38 = 250
} ;
enum __anonenum_875524036___38 {
    _CS_PATH___38 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___38 = 1,
    _CS_GNU_LIBC_VERSION___38 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___38 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___38 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___38 = 5,
    _CS_LFS_CFLAGS___38 = 1000,
    _CS_LFS_LDFLAGS___38 = 1001,
    _CS_LFS_LIBS___38 = 1002,
    _CS_LFS_LINTFLAGS___38 = 1003,
    _CS_LFS64_CFLAGS___38 = 1004,
    _CS_LFS64_LDFLAGS___38 = 1005,
    _CS_LFS64_LIBS___38 = 1006,
    _CS_LFS64_LINTFLAGS___38 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___38 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___38 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___38 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___38 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___38 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___38 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___38 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___38 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___38 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___38 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___38 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___38 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___38 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___38 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___38 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___38 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___38 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___38 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___38 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___38 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___38 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___38 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___38 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___38 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___38 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___38 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___38 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___38 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___38 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___38 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___38 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___38 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___38 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___38 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___38 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___38 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___38 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___38 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___38 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___38 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___38 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___38 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___38 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___38 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___38 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___38 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___38 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___38 = 1147,
    _CS_V6_ENV___38 = 1148,
    _CS_V7_ENV___38 = 1149
} ;
enum __anonenum_57186863___38 {
    SS_ONSTACK___38 = 1,
    SS_DISABLE___38 = 2
} ;
enum __anonenum_83571709___39 {
    MSG_OOB___39 = 1,
    MSG_PEEK___39 = 2,
    MSG_DONTROUTE___39 = 4,
    MSG_TRYHARD___39 = 4,
    MSG_CTRUNC___39 = 8,
    MSG_PROXY___39 = 16,
    MSG_TRUNC___39 = 32,
    MSG_DONTWAIT___39 = 64,
    MSG_EOR___39 = 128,
    MSG_WAITALL___39 = 256,
    MSG_FIN___39 = 512,
    MSG_SYN___39 = 1024,
    MSG_CONFIRM___39 = 2048,
    MSG_RST___39 = 4096,
    MSG_ERRQUEUE___39 = 8192,
    MSG_NOSIGNAL___39 = 16384,
    MSG_MORE___39 = 32768,
    MSG_WAITFORONE___39 = 65536,
    MSG_BATCH___39 = 262144,
    MSG_ZEROCOPY___39 = 67108864,
    MSG_FASTOPEN___39 = 536870912,
    MSG_CMSG_CLOEXEC___39 = 1073741824
} ;
enum __anonenum_617082774___39 {
    SCM_RIGHTS___39 = 1,
    SCM_CREDENTIALS___39 = 2
} ;
enum __anonenum_606441560___39 {
    SHUT_RD___39 = 0,
    SHUT_WR___39 = 1,
    SHUT_RDWR___39 = 2
} ;
enum __anonenum_264779956___39 {
    IPPROTO_IP___39 = 0,
    IPPROTO_ICMP___39 = 1,
    IPPROTO_IGMP___39 = 2,
    IPPROTO_IPIP___39 = 4,
    IPPROTO_TCP___39 = 6,
    IPPROTO_EGP___39 = 8,
    IPPROTO_PUP___39 = 12,
    IPPROTO_UDP___39 = 17,
    IPPROTO_IDP___39 = 22,
    IPPROTO_TP___39 = 29,
    IPPROTO_DCCP___39 = 33,
    IPPROTO_IPV6___39 = 41,
    IPPROTO_RSVP___39 = 46,
    IPPROTO_GRE___39 = 47,
    IPPROTO_ESP___39 = 50,
    IPPROTO_AH___39 = 51,
    IPPROTO_MTP___39 = 92,
    IPPROTO_BEETPH___39 = 94,
    IPPROTO_ENCAP___39 = 98,
    IPPROTO_PIM___39 = 103,
    IPPROTO_COMP___39 = 108,
    IPPROTO_SCTP___39 = 132,
    IPPROTO_UDPLITE___39 = 136,
    IPPROTO_MPLS___39 = 137,
    IPPROTO_ETHERNET___39 = 143,
    IPPROTO_RAW___39 = 255,
    IPPROTO_MPTCP___39 = 262,
    IPPROTO_MAX___39 = 263
} ;
enum __anonenum_218739988___39 {
    IPPROTO_HOPOPTS___39 = 0,
    IPPROTO_ROUTING___39 = 43,
    IPPROTO_FRAGMENT___39 = 44,
    IPPROTO_ICMPV6___39 = 58,
    IPPROTO_NONE___39 = 59,
    IPPROTO_DSTOPTS___39 = 60,
    IPPROTO_MH___39 = 135
} ;
enum __anonenum_662268580___39 {
    IPPORT_ECHO___39 = 7,
    IPPORT_DISCARD___39 = 9,
    IPPORT_SYSTAT___39 = 11,
    IPPORT_DAYTIME___39 = 13,
    IPPORT_NETSTAT___39 = 15,
    IPPORT_FTP___39 = 21,
    IPPORT_TELNET___39 = 23,
    IPPORT_SMTP___39 = 25,
    IPPORT_TIMESERVER___39 = 37,
    IPPORT_NAMESERVER___39 = 42,
    IPPORT_WHOIS___39 = 43,
    IPPORT_MTP___39 = 57,
    IPPORT_TFTP___39 = 69,
    IPPORT_RJE___39 = 77,
    IPPORT_FINGER___39 = 79,
    IPPORT_TTYLINK___39 = 87,
    IPPORT_SUPDUP___39 = 95,
    IPPORT_EXECSERVER___39 = 512,
    IPPORT_LOGINSERVER___39 = 513,
    IPPORT_CMDSERVER___39 = 514,
    IPPORT_EFSSERVER___39 = 520,
    IPPORT_BIFFUDP___39 = 512,
    IPPORT_WHOSERVER___39 = 513,
    IPPORT_ROUTESERVER___39 = 520,
    IPPORT_RESERVED___39 = 1024,
    IPPORT_USERRESERVED___39 = 5000
} ;
enum __anonenum_18926444___39 {
    _ISupper___39 = 256,
    _ISlower___39 = 512,
    _ISalpha___39 = 1024,
    _ISdigit___39 = 2048,
    _ISxdigit___39 = 4096,
    _ISspace___39 = 8192,
    _ISprint___39 = 16384,
    _ISgraph___39 = 32768,
    _ISblank___39 = 1,
    _IScntrl___39 = 2,
    _ISpunct___39 = 4,
    _ISalnum___39 = 8
} ;
enum __anonenum_913965969___39 {
    FP_INT_UPWARD___39 = 0,
    FP_INT_DOWNWARD___39 = 1,
    FP_INT_TOWARDZERO___39 = 2,
    FP_INT_TONEARESTFROMZERO___39 = 3,
    FP_INT_TONEAREST___39 = 4
} ;
enum __anonenum_1037408945___39 {
    FP_NAN___39 = 0,
    FP_INFINITE___39 = 1,
    FP_ZERO___39 = 2,
    FP_SUBNORMAL___39 = 3,
    FP_NORMAL___39 = 4
} ;
enum __anonenum_556971655___39 {
    SI_ASYNCNL___39 = -60,
    SI_DETHREAD___39 = -7,
    SI_TKILL___39 = -6,
    SI_SIGIO___39 = -5,
    SI_ASYNCIO___39 = -4,
    SI_MESGQ___39 = -3,
    SI_TIMER___39 = -2,
    SI_QUEUE___39 = -1,
    SI_USER___39 = 0,
    SI_KERNEL___39 = 128
} ;
enum __anonenum_640648963___39 {
    ILL_ILLOPC___39 = 1,
    ILL_ILLOPN___39 = 2,
    ILL_ILLADR___39 = 3,
    ILL_ILLTRP___39 = 4,
    ILL_PRVOPC___39 = 5,
    ILL_PRVREG___39 = 6,
    ILL_COPROC___39 = 7,
    ILL_BADSTK___39 = 8,
    ILL_BADIADDR___39 = 9
} ;
enum __anonenum_457704180___39 {
    FPE_INTDIV___39 = 1,
    FPE_INTOVF___39 = 2,
    FPE_FLTDIV___39 = 3,
    FPE_FLTOVF___39 = 4,
    FPE_FLTUND___39 = 5,
    FPE_FLTRES___39 = 6,
    FPE_FLTINV___39 = 7,
    FPE_FLTSUB___39 = 8,
    FPE_FLTUNK___39 = 14,
    FPE_CONDTRAP___39 = 15
} ;
enum __anonenum_180375148___39 {
    SEGV_MAPERR___39 = 1,
    SEGV_ACCERR___39 = 2,
    SEGV_BNDERR___39 = 3,
    SEGV_PKUERR___39 = 4,
    SEGV_ACCADI___39 = 5,
    SEGV_ADIDERR___39 = 6,
    SEGV_ADIPERR___39 = 7,
    SEGV_MTEAERR___39 = 8,
    SEGV_MTESERR___39 = 9
} ;
enum __anonenum_1036286214___39 {
    BUS_ADRALN___39 = 1,
    BUS_ADRERR___39 = 2,
    BUS_OBJERR___39 = 3,
    BUS_MCEERR_AR___39 = 4,
    BUS_MCEERR_AO___39 = 5
} ;
enum __anonenum_91015150___39 {
    TRAP_BRKPT___39 = 1,
    TRAP_TRACE___39 = 2,
    TRAP_BRANCH___39 = 3,
    TRAP_HWBKPT___39 = 4,
    TRAP_UNK___39 = 5
} ;
enum __anonenum_23175539___39 {
    CLD_EXITED___39 = 1,
    CLD_KILLED___39 = 2,
    CLD_DUMPED___39 = 3,
    CLD_TRAPPED___39 = 4,
    CLD_STOPPED___39 = 5,
    CLD_CONTINUED___39 = 6
} ;
enum __anonenum_111643124___39 {
    POLL_IN___39 = 1,
    POLL_OUT___39 = 2,
    POLL_MSG___39 = 3,
    POLL_ERR___39 = 4,
    POLL_PRI___39 = 5,
    POLL_HUP___39 = 6
} ;
enum __anonenum_852341087___39 {
    SIGEV_SIGNAL___39 = 0,
    SIGEV_NONE___39 = 1,
    SIGEV_THREAD___39 = 2,
    SIGEV_THREAD_ID___39 = 4
} ;
enum __anonenum_451154152___39 {
    REG_R8___39 = 0,
    REG_R9___39 = 1,
    REG_R10___39 = 2,
    REG_R11___39 = 3,
    REG_R12___39 = 4,
    REG_R13___39 = 5,
    REG_R14___39 = 6,
    REG_R15___39 = 7,
    REG_RDI___39 = 8,
    REG_RSI___39 = 9,
    REG_RBP___39 = 10,
    REG_RBX___39 = 11,
    REG_RDX___39 = 12,
    REG_RAX___39 = 13,
    REG_RCX___39 = 14,
    REG_RSP___39 = 15,
    REG_RIP___39 = 16,
    REG_EFL___39 = 17,
    REG_CSGSFS___39 = 18,
    REG_ERR___39 = 19,
    REG_TRAPNO___39 = 20,
    REG_OLDMASK___39 = 21,
    REG_CR2___39 = 22
} ;
enum __anonenum_437032235___39 {
    _PC_LINK_MAX___39 = 0,
    _PC_MAX_CANON___39 = 1,
    _PC_MAX_INPUT___39 = 2,
    _PC_NAME_MAX___39 = 3,
    _PC_PATH_MAX___39 = 4,
    _PC_PIPE_BUF___39 = 5,
    _PC_CHOWN_RESTRICTED___39 = 6,
    _PC_NO_TRUNC___39 = 7,
    _PC_VDISABLE___39 = 8,
    _PC_SYNC_IO___39 = 9,
    _PC_ASYNC_IO___39 = 10,
    _PC_PRIO_IO___39 = 11,
    _PC_SOCK_MAXBUF___39 = 12,
    _PC_FILESIZEBITS___39 = 13,
    _PC_REC_INCR_XFER_SIZE___39 = 14,
    _PC_REC_MAX_XFER_SIZE___39 = 15,
    _PC_REC_MIN_XFER_SIZE___39 = 16,
    _PC_REC_XFER_ALIGN___39 = 17,
    _PC_ALLOC_SIZE_MIN___39 = 18,
    _PC_SYMLINK_MAX___39 = 19,
    _PC_2_SYMLINKS___39 = 20
} ;
enum __anonenum_315186338___39 {
    _SC_ARG_MAX___39 = 0,
    _SC_CHILD_MAX___39 = 1,
    _SC_CLK_TCK___39 = 2,
    _SC_NGROUPS_MAX___39 = 3,
    _SC_OPEN_MAX___39 = 4,
    _SC_STREAM_MAX___39 = 5,
    _SC_TZNAME_MAX___39 = 6,
    _SC_JOB_CONTROL___39 = 7,
    _SC_SAVED_IDS___39 = 8,
    _SC_REALTIME_SIGNALS___39 = 9,
    _SC_PRIORITY_SCHEDULING___39 = 10,
    _SC_TIMERS___39 = 11,
    _SC_ASYNCHRONOUS_IO___39 = 12,
    _SC_PRIORITIZED_IO___39 = 13,
    _SC_SYNCHRONIZED_IO___39 = 14,
    _SC_FSYNC___39 = 15,
    _SC_MAPPED_FILES___39 = 16,
    _SC_MEMLOCK___39 = 17,
    _SC_MEMLOCK_RANGE___39 = 18,
    _SC_MEMORY_PROTECTION___39 = 19,
    _SC_MESSAGE_PASSING___39 = 20,
    _SC_SEMAPHORES___39 = 21,
    _SC_SHARED_MEMORY_OBJECTS___39 = 22,
    _SC_AIO_LISTIO_MAX___39 = 23,
    _SC_AIO_MAX___39 = 24,
    _SC_AIO_PRIO_DELTA_MAX___39 = 25,
    _SC_DELAYTIMER_MAX___39 = 26,
    _SC_MQ_OPEN_MAX___39 = 27,
    _SC_MQ_PRIO_MAX___39 = 28,
    _SC_VERSION___39 = 29,
    _SC_PAGESIZE___39 = 30,
    _SC_RTSIG_MAX___39 = 31,
    _SC_SEM_NSEMS_MAX___39 = 32,
    _SC_SEM_VALUE_MAX___39 = 33,
    _SC_SIGQUEUE_MAX___39 = 34,
    _SC_TIMER_MAX___39 = 35,
    _SC_BC_BASE_MAX___39 = 36,
    _SC_BC_DIM_MAX___39 = 37,
    _SC_BC_SCALE_MAX___39 = 38,
    _SC_BC_STRING_MAX___39 = 39,
    _SC_COLL_WEIGHTS_MAX___39 = 40,
    _SC_EQUIV_CLASS_MAX___39 = 41,
    _SC_EXPR_NEST_MAX___39 = 42,
    _SC_LINE_MAX___39 = 43,
    _SC_RE_DUP_MAX___39 = 44,
    _SC_CHARCLASS_NAME_MAX___39 = 45,
    _SC_2_VERSION___39 = 46,
    _SC_2_C_BIND___39 = 47,
    _SC_2_C_DEV___39 = 48,
    _SC_2_FORT_DEV___39 = 49,
    _SC_2_FORT_RUN___39 = 50,
    _SC_2_SW_DEV___39 = 51,
    _SC_2_LOCALEDEF___39 = 52,
    _SC_PII___39 = 53,
    _SC_PII_XTI___39 = 54,
    _SC_PII_SOCKET___39 = 55,
    _SC_PII_INTERNET___39 = 56,
    _SC_PII_OSI___39 = 57,
    _SC_POLL___39 = 58,
    _SC_SELECT___39 = 59,
    _SC_UIO_MAXIOV___39 = 60,
    _SC_IOV_MAX___39 = 60,
    _SC_PII_INTERNET_STREAM___39 = 61,
    _SC_PII_INTERNET_DGRAM___39 = 62,
    _SC_PII_OSI_COTS___39 = 63,
    _SC_PII_OSI_CLTS___39 = 64,
    _SC_PII_OSI_M___39 = 65,
    _SC_T_IOV_MAX___39 = 66,
    _SC_THREADS___39 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___39 = 68,
    _SC_GETGR_R_SIZE_MAX___39 = 69,
    _SC_GETPW_R_SIZE_MAX___39 = 70,
    _SC_LOGIN_NAME_MAX___39 = 71,
    _SC_TTY_NAME_MAX___39 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___39 = 73,
    _SC_THREAD_KEYS_MAX___39 = 74,
    _SC_THREAD_STACK_MIN___39 = 75,
    _SC_THREAD_THREADS_MAX___39 = 76,
    _SC_THREAD_ATTR_STACKADDR___39 = 77,
    _SC_THREAD_ATTR_STACKSIZE___39 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___39 = 79,
    _SC_THREAD_PRIO_INHERIT___39 = 80,
    _SC_THREAD_PRIO_PROTECT___39 = 81,
    _SC_THREAD_PROCESS_SHARED___39 = 82,
    _SC_NPROCESSORS_CONF___39 = 83,
    _SC_NPROCESSORS_ONLN___39 = 84,
    _SC_PHYS_PAGES___39 = 85,
    _SC_AVPHYS_PAGES___39 = 86,
    _SC_ATEXIT_MAX___39 = 87,
    _SC_PASS_MAX___39 = 88,
    _SC_XOPEN_VERSION___39 = 89,
    _SC_XOPEN_XCU_VERSION___39 = 90,
    _SC_XOPEN_UNIX___39 = 91,
    _SC_XOPEN_CRYPT___39 = 92,
    _SC_XOPEN_ENH_I18N___39 = 93,
    _SC_XOPEN_SHM___39 = 94,
    _SC_2_CHAR_TERM___39 = 95,
    _SC_2_C_VERSION___39 = 96,
    _SC_2_UPE___39 = 97,
    _SC_XOPEN_XPG2___39 = 98,
    _SC_XOPEN_XPG3___39 = 99,
    _SC_XOPEN_XPG4___39 = 100,
    _SC_CHAR_BIT___39 = 101,
    _SC_CHAR_MAX___39 = 102,
    _SC_CHAR_MIN___39 = 103,
    _SC_INT_MAX___39 = 104,
    _SC_INT_MIN___39 = 105,
    _SC_LONG_BIT___39 = 106,
    _SC_WORD_BIT___39 = 107,
    _SC_MB_LEN_MAX___39 = 108,
    _SC_NZERO___39 = 109,
    _SC_SSIZE_MAX___39 = 110,
    _SC_SCHAR_MAX___39 = 111,
    _SC_SCHAR_MIN___39 = 112,
    _SC_SHRT_MAX___39 = 113,
    _SC_SHRT_MIN___39 = 114,
    _SC_UCHAR_MAX___39 = 115,
    _SC_UINT_MAX___39 = 116,
    _SC_ULONG_MAX___39 = 117,
    _SC_USHRT_MAX___39 = 118,
    _SC_NL_ARGMAX___39 = 119,
    _SC_NL_LANGMAX___39 = 120,
    _SC_NL_MSGMAX___39 = 121,
    _SC_NL_NMAX___39 = 122,
    _SC_NL_SETMAX___39 = 123,
    _SC_NL_TEXTMAX___39 = 124,
    _SC_XBS5_ILP32_OFF32___39 = 125,
    _SC_XBS5_ILP32_OFFBIG___39 = 126,
    _SC_XBS5_LP64_OFF64___39 = 127,
    _SC_XBS5_LPBIG_OFFBIG___39 = 128,
    _SC_XOPEN_LEGACY___39 = 129,
    _SC_XOPEN_REALTIME___39 = 130,
    _SC_XOPEN_REALTIME_THREADS___39 = 131,
    _SC_ADVISORY_INFO___39 = 132,
    _SC_BARRIERS___39 = 133,
    _SC_BASE___39 = 134,
    _SC_C_LANG_SUPPORT___39 = 135,
    _SC_C_LANG_SUPPORT_R___39 = 136,
    _SC_CLOCK_SELECTION___39 = 137,
    _SC_CPUTIME___39 = 138,
    _SC_THREAD_CPUTIME___39 = 139,
    _SC_DEVICE_IO___39 = 140,
    _SC_DEVICE_SPECIFIC___39 = 141,
    _SC_DEVICE_SPECIFIC_R___39 = 142,
    _SC_FD_MGMT___39 = 143,
    _SC_FIFO___39 = 144,
    _SC_PIPE___39 = 145,
    _SC_FILE_ATTRIBUTES___39 = 146,
    _SC_FILE_LOCKING___39 = 147,
    _SC_FILE_SYSTEM___39 = 148,
    _SC_MONOTONIC_CLOCK___39 = 149,
    _SC_MULTI_PROCESS___39 = 150,
    _SC_SINGLE_PROCESS___39 = 151,
    _SC_NETWORKING___39 = 152,
    _SC_READER_WRITER_LOCKS___39 = 153,
    _SC_SPIN_LOCKS___39 = 154,
    _SC_REGEXP___39 = 155,
    _SC_REGEX_VERSION___39 = 156,
    _SC_SHELL___39 = 157,
    _SC_SIGNALS___39 = 158,
    _SC_SPAWN___39 = 159,
    _SC_SPORADIC_SERVER___39 = 160,
    _SC_THREAD_SPORADIC_SERVER___39 = 161,
    _SC_SYSTEM_DATABASE___39 = 162,
    _SC_SYSTEM_DATABASE_R___39 = 163,
    _SC_TIMEOUTS___39 = 164,
    _SC_TYPED_MEMORY_OBJECTS___39 = 165,
    _SC_USER_GROUPS___39 = 166,
    _SC_USER_GROUPS_R___39 = 167,
    _SC_2_PBS___39 = 168,
    _SC_2_PBS_ACCOUNTING___39 = 169,
    _SC_2_PBS_LOCATE___39 = 170,
    _SC_2_PBS_MESSAGE___39 = 171,
    _SC_2_PBS_TRACK___39 = 172,
    _SC_SYMLOOP_MAX___39 = 173,
    _SC_STREAMS___39 = 174,
    _SC_2_PBS_CHECKPOINT___39 = 175,
    _SC_V6_ILP32_OFF32___39 = 176,
    _SC_V6_ILP32_OFFBIG___39 = 177,
    _SC_V6_LP64_OFF64___39 = 178,
    _SC_V6_LPBIG_OFFBIG___39 = 179,
    _SC_HOST_NAME_MAX___39 = 180,
    _SC_TRACE___39 = 181,
    _SC_TRACE_EVENT_FILTER___39 = 182,
    _SC_TRACE_INHERIT___39 = 183,
    _SC_TRACE_LOG___39 = 184,
    _SC_LEVEL1_ICACHE_SIZE___39 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___39 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___39 = 187,
    _SC_LEVEL1_DCACHE_SIZE___39 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___39 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___39 = 190,
    _SC_LEVEL2_CACHE_SIZE___39 = 191,
    _SC_LEVEL2_CACHE_ASSOC___39 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___39 = 193,
    _SC_LEVEL3_CACHE_SIZE___39 = 194,
    _SC_LEVEL3_CACHE_ASSOC___39 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___39 = 196,
    _SC_LEVEL4_CACHE_SIZE___39 = 197,
    _SC_LEVEL4_CACHE_ASSOC___39 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___39 = 199,
    _SC_IPV6___39 = 235,
    _SC_RAW_SOCKETS___39 = 236,
    _SC_V7_ILP32_OFF32___39 = 237,
    _SC_V7_ILP32_OFFBIG___39 = 238,
    _SC_V7_LP64_OFF64___39 = 239,
    _SC_V7_LPBIG_OFFBIG___39 = 240,
    _SC_SS_REPL_MAX___39 = 241,
    _SC_TRACE_EVENT_NAME_MAX___39 = 242,
    _SC_TRACE_NAME_MAX___39 = 243,
    _SC_TRACE_SYS_MAX___39 = 244,
    _SC_TRACE_USER_EVENT_MAX___39 = 245,
    _SC_XOPEN_STREAMS___39 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___39 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___39 = 248,
    _SC_MINSIGSTKSZ___39 = 249,
    _SC_SIGSTKSZ___39 = 250
} ;
enum __anonenum_875524036___39 {
    _CS_PATH___39 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___39 = 1,
    _CS_GNU_LIBC_VERSION___39 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___39 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___39 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___39 = 5,
    _CS_LFS_CFLAGS___39 = 1000,
    _CS_LFS_LDFLAGS___39 = 1001,
    _CS_LFS_LIBS___39 = 1002,
    _CS_LFS_LINTFLAGS___39 = 1003,
    _CS_LFS64_CFLAGS___39 = 1004,
    _CS_LFS64_LDFLAGS___39 = 1005,
    _CS_LFS64_LIBS___39 = 1006,
    _CS_LFS64_LINTFLAGS___39 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___39 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___39 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___39 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___39 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___39 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___39 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___39 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___39 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___39 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___39 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___39 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___39 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___39 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___39 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___39 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___39 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___39 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___39 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___39 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___39 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___39 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___39 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___39 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___39 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___39 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___39 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___39 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___39 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___39 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___39 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___39 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___39 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___39 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___39 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___39 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___39 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___39 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___39 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___39 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___39 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___39 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___39 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___39 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___39 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___39 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___39 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___39 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___39 = 1147,
    _CS_V6_ENV___39 = 1148,
    _CS_V7_ENV___39 = 1149
} ;
enum __anonenum_57186863___39 {
    SS_ONSTACK___39 = 1,
    SS_DISABLE___39 = 2
} ;
struct shmTime {
   int mode ;
   int volatile count ;
   time_t clockTimeStampSec ;
   int clockTimeStampUSec ;
   time_t receiveTimeStampSec ;
   int receiveTimeStampUSec ;
   int leap ;
   int precision ;
   int nsamples ;
   int volatile valid ;
   int clockTimeStampNSec ;
   int receiveTimeStampNSec ;
   int dummy[8] ;
};
enum __anonenum_83571709___40 {
    MSG_OOB___40 = 1,
    MSG_PEEK___40 = 2,
    MSG_DONTROUTE___40 = 4,
    MSG_TRYHARD___40 = 4,
    MSG_CTRUNC___40 = 8,
    MSG_PROXY___40 = 16,
    MSG_TRUNC___40 = 32,
    MSG_DONTWAIT___40 = 64,
    MSG_EOR___40 = 128,
    MSG_WAITALL___40 = 256,
    MSG_FIN___40 = 512,
    MSG_SYN___40 = 1024,
    MSG_CONFIRM___40 = 2048,
    MSG_RST___40 = 4096,
    MSG_ERRQUEUE___40 = 8192,
    MSG_NOSIGNAL___40 = 16384,
    MSG_MORE___40 = 32768,
    MSG_WAITFORONE___40 = 65536,
    MSG_BATCH___40 = 262144,
    MSG_ZEROCOPY___40 = 67108864,
    MSG_FASTOPEN___40 = 536870912,
    MSG_CMSG_CLOEXEC___40 = 1073741824
} ;
enum __anonenum_617082774___40 {
    SCM_RIGHTS___40 = 1,
    SCM_CREDENTIALS___40 = 2
} ;
enum __anonenum_606441560___40 {
    SHUT_RD___40 = 0,
    SHUT_WR___40 = 1,
    SHUT_RDWR___40 = 2
} ;
enum __anonenum_264779956___40 {
    IPPROTO_IP___40 = 0,
    IPPROTO_ICMP___40 = 1,
    IPPROTO_IGMP___40 = 2,
    IPPROTO_IPIP___40 = 4,
    IPPROTO_TCP___40 = 6,
    IPPROTO_EGP___40 = 8,
    IPPROTO_PUP___40 = 12,
    IPPROTO_UDP___40 = 17,
    IPPROTO_IDP___40 = 22,
    IPPROTO_TP___40 = 29,
    IPPROTO_DCCP___40 = 33,
    IPPROTO_IPV6___40 = 41,
    IPPROTO_RSVP___40 = 46,
    IPPROTO_GRE___40 = 47,
    IPPROTO_ESP___40 = 50,
    IPPROTO_AH___40 = 51,
    IPPROTO_MTP___40 = 92,
    IPPROTO_BEETPH___40 = 94,
    IPPROTO_ENCAP___40 = 98,
    IPPROTO_PIM___40 = 103,
    IPPROTO_COMP___40 = 108,
    IPPROTO_SCTP___40 = 132,
    IPPROTO_UDPLITE___40 = 136,
    IPPROTO_MPLS___40 = 137,
    IPPROTO_ETHERNET___40 = 143,
    IPPROTO_RAW___40 = 255,
    IPPROTO_MPTCP___40 = 262,
    IPPROTO_MAX___40 = 263
} ;
enum __anonenum_218739988___40 {
    IPPROTO_HOPOPTS___40 = 0,
    IPPROTO_ROUTING___40 = 43,
    IPPROTO_FRAGMENT___40 = 44,
    IPPROTO_ICMPV6___40 = 58,
    IPPROTO_NONE___40 = 59,
    IPPROTO_DSTOPTS___40 = 60,
    IPPROTO_MH___40 = 135
} ;
enum __anonenum_662268580___40 {
    IPPORT_ECHO___40 = 7,
    IPPORT_DISCARD___40 = 9,
    IPPORT_SYSTAT___40 = 11,
    IPPORT_DAYTIME___40 = 13,
    IPPORT_NETSTAT___40 = 15,
    IPPORT_FTP___40 = 21,
    IPPORT_TELNET___40 = 23,
    IPPORT_SMTP___40 = 25,
    IPPORT_TIMESERVER___40 = 37,
    IPPORT_NAMESERVER___40 = 42,
    IPPORT_WHOIS___40 = 43,
    IPPORT_MTP___40 = 57,
    IPPORT_TFTP___40 = 69,
    IPPORT_RJE___40 = 77,
    IPPORT_FINGER___40 = 79,
    IPPORT_TTYLINK___40 = 87,
    IPPORT_SUPDUP___40 = 95,
    IPPORT_EXECSERVER___40 = 512,
    IPPORT_LOGINSERVER___40 = 513,
    IPPORT_CMDSERVER___40 = 514,
    IPPORT_EFSSERVER___40 = 520,
    IPPORT_BIFFUDP___40 = 512,
    IPPORT_WHOSERVER___40 = 513,
    IPPORT_ROUTESERVER___40 = 520,
    IPPORT_RESERVED___40 = 1024,
    IPPORT_USERRESERVED___40 = 5000
} ;
enum __anonenum_18926444___40 {
    _ISupper___40 = 256,
    _ISlower___40 = 512,
    _ISalpha___40 = 1024,
    _ISdigit___40 = 2048,
    _ISxdigit___40 = 4096,
    _ISspace___40 = 8192,
    _ISprint___40 = 16384,
    _ISgraph___40 = 32768,
    _ISblank___40 = 1,
    _IScntrl___40 = 2,
    _ISpunct___40 = 4,
    _ISalnum___40 = 8
} ;
enum __anonenum_913965969___40 {
    FP_INT_UPWARD___40 = 0,
    FP_INT_DOWNWARD___40 = 1,
    FP_INT_TOWARDZERO___40 = 2,
    FP_INT_TONEARESTFROMZERO___40 = 3,
    FP_INT_TONEAREST___40 = 4
} ;
enum __anonenum_1037408945___40 {
    FP_NAN___40 = 0,
    FP_INFINITE___40 = 1,
    FP_ZERO___40 = 2,
    FP_SUBNORMAL___40 = 3,
    FP_NORMAL___40 = 4
} ;
enum __anonenum_556971655___40 {
    SI_ASYNCNL___40 = -60,
    SI_DETHREAD___40 = -7,
    SI_TKILL___40 = -6,
    SI_SIGIO___40 = -5,
    SI_ASYNCIO___40 = -4,
    SI_MESGQ___40 = -3,
    SI_TIMER___40 = -2,
    SI_QUEUE___40 = -1,
    SI_USER___40 = 0,
    SI_KERNEL___40 = 128
} ;
enum __anonenum_640648963___40 {
    ILL_ILLOPC___40 = 1,
    ILL_ILLOPN___40 = 2,
    ILL_ILLADR___40 = 3,
    ILL_ILLTRP___40 = 4,
    ILL_PRVOPC___40 = 5,
    ILL_PRVREG___40 = 6,
    ILL_COPROC___40 = 7,
    ILL_BADSTK___40 = 8,
    ILL_BADIADDR___40 = 9
} ;
enum __anonenum_457704180___40 {
    FPE_INTDIV___40 = 1,
    FPE_INTOVF___40 = 2,
    FPE_FLTDIV___40 = 3,
    FPE_FLTOVF___40 = 4,
    FPE_FLTUND___40 = 5,
    FPE_FLTRES___40 = 6,
    FPE_FLTINV___40 = 7,
    FPE_FLTSUB___40 = 8,
    FPE_FLTUNK___40 = 14,
    FPE_CONDTRAP___40 = 15
} ;
enum __anonenum_180375148___40 {
    SEGV_MAPERR___40 = 1,
    SEGV_ACCERR___40 = 2,
    SEGV_BNDERR___40 = 3,
    SEGV_PKUERR___40 = 4,
    SEGV_ACCADI___40 = 5,
    SEGV_ADIDERR___40 = 6,
    SEGV_ADIPERR___40 = 7,
    SEGV_MTEAERR___40 = 8,
    SEGV_MTESERR___40 = 9
} ;
enum __anonenum_1036286214___40 {
    BUS_ADRALN___40 = 1,
    BUS_ADRERR___40 = 2,
    BUS_OBJERR___40 = 3,
    BUS_MCEERR_AR___40 = 4,
    BUS_MCEERR_AO___40 = 5
} ;
enum __anonenum_91015150___40 {
    TRAP_BRKPT___40 = 1,
    TRAP_TRACE___40 = 2,
    TRAP_BRANCH___40 = 3,
    TRAP_HWBKPT___40 = 4,
    TRAP_UNK___40 = 5
} ;
enum __anonenum_23175539___40 {
    CLD_EXITED___40 = 1,
    CLD_KILLED___40 = 2,
    CLD_DUMPED___40 = 3,
    CLD_TRAPPED___40 = 4,
    CLD_STOPPED___40 = 5,
    CLD_CONTINUED___40 = 6
} ;
enum __anonenum_111643124___40 {
    POLL_IN___40 = 1,
    POLL_OUT___40 = 2,
    POLL_MSG___40 = 3,
    POLL_ERR___40 = 4,
    POLL_PRI___40 = 5,
    POLL_HUP___40 = 6
} ;
enum __anonenum_852341087___40 {
    SIGEV_SIGNAL___40 = 0,
    SIGEV_NONE___40 = 1,
    SIGEV_THREAD___40 = 2,
    SIGEV_THREAD_ID___40 = 4
} ;
enum __anonenum_451154152___40 {
    REG_R8___40 = 0,
    REG_R9___40 = 1,
    REG_R10___40 = 2,
    REG_R11___40 = 3,
    REG_R12___40 = 4,
    REG_R13___40 = 5,
    REG_R14___40 = 6,
    REG_R15___40 = 7,
    REG_RDI___40 = 8,
    REG_RSI___40 = 9,
    REG_RBP___40 = 10,
    REG_RBX___40 = 11,
    REG_RDX___40 = 12,
    REG_RAX___40 = 13,
    REG_RCX___40 = 14,
    REG_RSP___40 = 15,
    REG_RIP___40 = 16,
    REG_EFL___40 = 17,
    REG_CSGSFS___40 = 18,
    REG_ERR___40 = 19,
    REG_TRAPNO___40 = 20,
    REG_OLDMASK___40 = 21,
    REG_CR2___40 = 22
} ;
enum __anonenum_437032235___40 {
    _PC_LINK_MAX___40 = 0,
    _PC_MAX_CANON___40 = 1,
    _PC_MAX_INPUT___40 = 2,
    _PC_NAME_MAX___40 = 3,
    _PC_PATH_MAX___40 = 4,
    _PC_PIPE_BUF___40 = 5,
    _PC_CHOWN_RESTRICTED___40 = 6,
    _PC_NO_TRUNC___40 = 7,
    _PC_VDISABLE___40 = 8,
    _PC_SYNC_IO___40 = 9,
    _PC_ASYNC_IO___40 = 10,
    _PC_PRIO_IO___40 = 11,
    _PC_SOCK_MAXBUF___40 = 12,
    _PC_FILESIZEBITS___40 = 13,
    _PC_REC_INCR_XFER_SIZE___40 = 14,
    _PC_REC_MAX_XFER_SIZE___40 = 15,
    _PC_REC_MIN_XFER_SIZE___40 = 16,
    _PC_REC_XFER_ALIGN___40 = 17,
    _PC_ALLOC_SIZE_MIN___40 = 18,
    _PC_SYMLINK_MAX___40 = 19,
    _PC_2_SYMLINKS___40 = 20
} ;
enum __anonenum_315186338___40 {
    _SC_ARG_MAX___40 = 0,
    _SC_CHILD_MAX___40 = 1,
    _SC_CLK_TCK___40 = 2,
    _SC_NGROUPS_MAX___40 = 3,
    _SC_OPEN_MAX___40 = 4,
    _SC_STREAM_MAX___40 = 5,
    _SC_TZNAME_MAX___40 = 6,
    _SC_JOB_CONTROL___40 = 7,
    _SC_SAVED_IDS___40 = 8,
    _SC_REALTIME_SIGNALS___40 = 9,
    _SC_PRIORITY_SCHEDULING___40 = 10,
    _SC_TIMERS___40 = 11,
    _SC_ASYNCHRONOUS_IO___40 = 12,
    _SC_PRIORITIZED_IO___40 = 13,
    _SC_SYNCHRONIZED_IO___40 = 14,
    _SC_FSYNC___40 = 15,
    _SC_MAPPED_FILES___40 = 16,
    _SC_MEMLOCK___40 = 17,
    _SC_MEMLOCK_RANGE___40 = 18,
    _SC_MEMORY_PROTECTION___40 = 19,
    _SC_MESSAGE_PASSING___40 = 20,
    _SC_SEMAPHORES___40 = 21,
    _SC_SHARED_MEMORY_OBJECTS___40 = 22,
    _SC_AIO_LISTIO_MAX___40 = 23,
    _SC_AIO_MAX___40 = 24,
    _SC_AIO_PRIO_DELTA_MAX___40 = 25,
    _SC_DELAYTIMER_MAX___40 = 26,
    _SC_MQ_OPEN_MAX___40 = 27,
    _SC_MQ_PRIO_MAX___40 = 28,
    _SC_VERSION___40 = 29,
    _SC_PAGESIZE___40 = 30,
    _SC_RTSIG_MAX___40 = 31,
    _SC_SEM_NSEMS_MAX___40 = 32,
    _SC_SEM_VALUE_MAX___40 = 33,
    _SC_SIGQUEUE_MAX___40 = 34,
    _SC_TIMER_MAX___40 = 35,
    _SC_BC_BASE_MAX___40 = 36,
    _SC_BC_DIM_MAX___40 = 37,
    _SC_BC_SCALE_MAX___40 = 38,
    _SC_BC_STRING_MAX___40 = 39,
    _SC_COLL_WEIGHTS_MAX___40 = 40,
    _SC_EQUIV_CLASS_MAX___40 = 41,
    _SC_EXPR_NEST_MAX___40 = 42,
    _SC_LINE_MAX___40 = 43,
    _SC_RE_DUP_MAX___40 = 44,
    _SC_CHARCLASS_NAME_MAX___40 = 45,
    _SC_2_VERSION___40 = 46,
    _SC_2_C_BIND___40 = 47,
    _SC_2_C_DEV___40 = 48,
    _SC_2_FORT_DEV___40 = 49,
    _SC_2_FORT_RUN___40 = 50,
    _SC_2_SW_DEV___40 = 51,
    _SC_2_LOCALEDEF___40 = 52,
    _SC_PII___40 = 53,
    _SC_PII_XTI___40 = 54,
    _SC_PII_SOCKET___40 = 55,
    _SC_PII_INTERNET___40 = 56,
    _SC_PII_OSI___40 = 57,
    _SC_POLL___40 = 58,
    _SC_SELECT___40 = 59,
    _SC_UIO_MAXIOV___40 = 60,
    _SC_IOV_MAX___40 = 60,
    _SC_PII_INTERNET_STREAM___40 = 61,
    _SC_PII_INTERNET_DGRAM___40 = 62,
    _SC_PII_OSI_COTS___40 = 63,
    _SC_PII_OSI_CLTS___40 = 64,
    _SC_PII_OSI_M___40 = 65,
    _SC_T_IOV_MAX___40 = 66,
    _SC_THREADS___40 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___40 = 68,
    _SC_GETGR_R_SIZE_MAX___40 = 69,
    _SC_GETPW_R_SIZE_MAX___40 = 70,
    _SC_LOGIN_NAME_MAX___40 = 71,
    _SC_TTY_NAME_MAX___40 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___40 = 73,
    _SC_THREAD_KEYS_MAX___40 = 74,
    _SC_THREAD_STACK_MIN___40 = 75,
    _SC_THREAD_THREADS_MAX___40 = 76,
    _SC_THREAD_ATTR_STACKADDR___40 = 77,
    _SC_THREAD_ATTR_STACKSIZE___40 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___40 = 79,
    _SC_THREAD_PRIO_INHERIT___40 = 80,
    _SC_THREAD_PRIO_PROTECT___40 = 81,
    _SC_THREAD_PROCESS_SHARED___40 = 82,
    _SC_NPROCESSORS_CONF___40 = 83,
    _SC_NPROCESSORS_ONLN___40 = 84,
    _SC_PHYS_PAGES___40 = 85,
    _SC_AVPHYS_PAGES___40 = 86,
    _SC_ATEXIT_MAX___40 = 87,
    _SC_PASS_MAX___40 = 88,
    _SC_XOPEN_VERSION___40 = 89,
    _SC_XOPEN_XCU_VERSION___40 = 90,
    _SC_XOPEN_UNIX___40 = 91,
    _SC_XOPEN_CRYPT___40 = 92,
    _SC_XOPEN_ENH_I18N___40 = 93,
    _SC_XOPEN_SHM___40 = 94,
    _SC_2_CHAR_TERM___40 = 95,
    _SC_2_C_VERSION___40 = 96,
    _SC_2_UPE___40 = 97,
    _SC_XOPEN_XPG2___40 = 98,
    _SC_XOPEN_XPG3___40 = 99,
    _SC_XOPEN_XPG4___40 = 100,
    _SC_CHAR_BIT___40 = 101,
    _SC_CHAR_MAX___40 = 102,
    _SC_CHAR_MIN___40 = 103,
    _SC_INT_MAX___40 = 104,
    _SC_INT_MIN___40 = 105,
    _SC_LONG_BIT___40 = 106,
    _SC_WORD_BIT___40 = 107,
    _SC_MB_LEN_MAX___40 = 108,
    _SC_NZERO___40 = 109,
    _SC_SSIZE_MAX___40 = 110,
    _SC_SCHAR_MAX___40 = 111,
    _SC_SCHAR_MIN___40 = 112,
    _SC_SHRT_MAX___40 = 113,
    _SC_SHRT_MIN___40 = 114,
    _SC_UCHAR_MAX___40 = 115,
    _SC_UINT_MAX___40 = 116,
    _SC_ULONG_MAX___40 = 117,
    _SC_USHRT_MAX___40 = 118,
    _SC_NL_ARGMAX___40 = 119,
    _SC_NL_LANGMAX___40 = 120,
    _SC_NL_MSGMAX___40 = 121,
    _SC_NL_NMAX___40 = 122,
    _SC_NL_SETMAX___40 = 123,
    _SC_NL_TEXTMAX___40 = 124,
    _SC_XBS5_ILP32_OFF32___40 = 125,
    _SC_XBS5_ILP32_OFFBIG___40 = 126,
    _SC_XBS5_LP64_OFF64___40 = 127,
    _SC_XBS5_LPBIG_OFFBIG___40 = 128,
    _SC_XOPEN_LEGACY___40 = 129,
    _SC_XOPEN_REALTIME___40 = 130,
    _SC_XOPEN_REALTIME_THREADS___40 = 131,
    _SC_ADVISORY_INFO___40 = 132,
    _SC_BARRIERS___40 = 133,
    _SC_BASE___40 = 134,
    _SC_C_LANG_SUPPORT___40 = 135,
    _SC_C_LANG_SUPPORT_R___40 = 136,
    _SC_CLOCK_SELECTION___40 = 137,
    _SC_CPUTIME___40 = 138,
    _SC_THREAD_CPUTIME___40 = 139,
    _SC_DEVICE_IO___40 = 140,
    _SC_DEVICE_SPECIFIC___40 = 141,
    _SC_DEVICE_SPECIFIC_R___40 = 142,
    _SC_FD_MGMT___40 = 143,
    _SC_FIFO___40 = 144,
    _SC_PIPE___40 = 145,
    _SC_FILE_ATTRIBUTES___40 = 146,
    _SC_FILE_LOCKING___40 = 147,
    _SC_FILE_SYSTEM___40 = 148,
    _SC_MONOTONIC_CLOCK___40 = 149,
    _SC_MULTI_PROCESS___40 = 150,
    _SC_SINGLE_PROCESS___40 = 151,
    _SC_NETWORKING___40 = 152,
    _SC_READER_WRITER_LOCKS___40 = 153,
    _SC_SPIN_LOCKS___40 = 154,
    _SC_REGEXP___40 = 155,
    _SC_REGEX_VERSION___40 = 156,
    _SC_SHELL___40 = 157,
    _SC_SIGNALS___40 = 158,
    _SC_SPAWN___40 = 159,
    _SC_SPORADIC_SERVER___40 = 160,
    _SC_THREAD_SPORADIC_SERVER___40 = 161,
    _SC_SYSTEM_DATABASE___40 = 162,
    _SC_SYSTEM_DATABASE_R___40 = 163,
    _SC_TIMEOUTS___40 = 164,
    _SC_TYPED_MEMORY_OBJECTS___40 = 165,
    _SC_USER_GROUPS___40 = 166,
    _SC_USER_GROUPS_R___40 = 167,
    _SC_2_PBS___40 = 168,
    _SC_2_PBS_ACCOUNTING___40 = 169,
    _SC_2_PBS_LOCATE___40 = 170,
    _SC_2_PBS_MESSAGE___40 = 171,
    _SC_2_PBS_TRACK___40 = 172,
    _SC_SYMLOOP_MAX___40 = 173,
    _SC_STREAMS___40 = 174,
    _SC_2_PBS_CHECKPOINT___40 = 175,
    _SC_V6_ILP32_OFF32___40 = 176,
    _SC_V6_ILP32_OFFBIG___40 = 177,
    _SC_V6_LP64_OFF64___40 = 178,
    _SC_V6_LPBIG_OFFBIG___40 = 179,
    _SC_HOST_NAME_MAX___40 = 180,
    _SC_TRACE___40 = 181,
    _SC_TRACE_EVENT_FILTER___40 = 182,
    _SC_TRACE_INHERIT___40 = 183,
    _SC_TRACE_LOG___40 = 184,
    _SC_LEVEL1_ICACHE_SIZE___40 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___40 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___40 = 187,
    _SC_LEVEL1_DCACHE_SIZE___40 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___40 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___40 = 190,
    _SC_LEVEL2_CACHE_SIZE___40 = 191,
    _SC_LEVEL2_CACHE_ASSOC___40 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___40 = 193,
    _SC_LEVEL3_CACHE_SIZE___40 = 194,
    _SC_LEVEL3_CACHE_ASSOC___40 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___40 = 196,
    _SC_LEVEL4_CACHE_SIZE___40 = 197,
    _SC_LEVEL4_CACHE_ASSOC___40 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___40 = 199,
    _SC_IPV6___40 = 235,
    _SC_RAW_SOCKETS___40 = 236,
    _SC_V7_ILP32_OFF32___40 = 237,
    _SC_V7_ILP32_OFFBIG___40 = 238,
    _SC_V7_LP64_OFF64___40 = 239,
    _SC_V7_LPBIG_OFFBIG___40 = 240,
    _SC_SS_REPL_MAX___40 = 241,
    _SC_TRACE_EVENT_NAME_MAX___40 = 242,
    _SC_TRACE_NAME_MAX___40 = 243,
    _SC_TRACE_SYS_MAX___40 = 244,
    _SC_TRACE_USER_EVENT_MAX___40 = 245,
    _SC_XOPEN_STREAMS___40 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___40 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___40 = 248,
    _SC_MINSIGSTKSZ___40 = 249,
    _SC_SIGSTKSZ___40 = 250
} ;
enum __anonenum_875524036___40 {
    _CS_PATH___40 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___40 = 1,
    _CS_GNU_LIBC_VERSION___40 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___40 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___40 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___40 = 5,
    _CS_LFS_CFLAGS___40 = 1000,
    _CS_LFS_LDFLAGS___40 = 1001,
    _CS_LFS_LIBS___40 = 1002,
    _CS_LFS_LINTFLAGS___40 = 1003,
    _CS_LFS64_CFLAGS___40 = 1004,
    _CS_LFS64_LDFLAGS___40 = 1005,
    _CS_LFS64_LIBS___40 = 1006,
    _CS_LFS64_LINTFLAGS___40 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___40 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___40 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___40 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___40 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___40 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___40 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___40 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___40 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___40 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___40 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___40 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___40 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___40 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___40 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___40 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___40 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___40 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___40 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___40 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___40 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___40 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___40 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___40 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___40 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___40 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___40 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___40 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___40 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___40 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___40 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___40 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___40 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___40 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___40 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___40 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___40 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___40 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___40 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___40 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___40 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___40 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___40 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___40 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___40 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___40 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___40 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___40 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___40 = 1147,
    _CS_V6_ENV___40 = 1148,
    _CS_V7_ENV___40 = 1149
} ;
enum __anonenum_57186863___40 {
    SS_ONSTACK___40 = 1,
    SS_DISABLE___40 = 2
} ;
struct sock_sample {
   struct timeval tv ;
   double offset ;
   int pulse ;
   int leap ;
   int _pad ;
   int magic ;
};
enum __anonenum_83571709___41 {
    MSG_OOB___41 = 1,
    MSG_PEEK___41 = 2,
    MSG_DONTROUTE___41 = 4,
    MSG_TRYHARD___41 = 4,
    MSG_CTRUNC___41 = 8,
    MSG_PROXY___41 = 16,
    MSG_TRUNC___41 = 32,
    MSG_DONTWAIT___41 = 64,
    MSG_EOR___41 = 128,
    MSG_WAITALL___41 = 256,
    MSG_FIN___41 = 512,
    MSG_SYN___41 = 1024,
    MSG_CONFIRM___41 = 2048,
    MSG_RST___41 = 4096,
    MSG_ERRQUEUE___41 = 8192,
    MSG_NOSIGNAL___41 = 16384,
    MSG_MORE___41 = 32768,
    MSG_WAITFORONE___41 = 65536,
    MSG_BATCH___41 = 262144,
    MSG_ZEROCOPY___41 = 67108864,
    MSG_FASTOPEN___41 = 536870912,
    MSG_CMSG_CLOEXEC___41 = 1073741824
} ;
enum __anonenum_617082774___41 {
    SCM_RIGHTS___41 = 1,
    SCM_CREDENTIALS___41 = 2
} ;
enum __anonenum_606441560___41 {
    SHUT_RD___41 = 0,
    SHUT_WR___41 = 1,
    SHUT_RDWR___41 = 2
} ;
enum __anonenum_264779956___41 {
    IPPROTO_IP___41 = 0,
    IPPROTO_ICMP___41 = 1,
    IPPROTO_IGMP___41 = 2,
    IPPROTO_IPIP___41 = 4,
    IPPROTO_TCP___41 = 6,
    IPPROTO_EGP___41 = 8,
    IPPROTO_PUP___41 = 12,
    IPPROTO_UDP___41 = 17,
    IPPROTO_IDP___41 = 22,
    IPPROTO_TP___41 = 29,
    IPPROTO_DCCP___41 = 33,
    IPPROTO_IPV6___41 = 41,
    IPPROTO_RSVP___41 = 46,
    IPPROTO_GRE___41 = 47,
    IPPROTO_ESP___41 = 50,
    IPPROTO_AH___41 = 51,
    IPPROTO_MTP___41 = 92,
    IPPROTO_BEETPH___41 = 94,
    IPPROTO_ENCAP___41 = 98,
    IPPROTO_PIM___41 = 103,
    IPPROTO_COMP___41 = 108,
    IPPROTO_SCTP___41 = 132,
    IPPROTO_UDPLITE___41 = 136,
    IPPROTO_MPLS___41 = 137,
    IPPROTO_ETHERNET___41 = 143,
    IPPROTO_RAW___41 = 255,
    IPPROTO_MPTCP___41 = 262,
    IPPROTO_MAX___41 = 263
} ;
enum __anonenum_218739988___41 {
    IPPROTO_HOPOPTS___41 = 0,
    IPPROTO_ROUTING___41 = 43,
    IPPROTO_FRAGMENT___41 = 44,
    IPPROTO_ICMPV6___41 = 58,
    IPPROTO_NONE___41 = 59,
    IPPROTO_DSTOPTS___41 = 60,
    IPPROTO_MH___41 = 135
} ;
enum __anonenum_662268580___41 {
    IPPORT_ECHO___41 = 7,
    IPPORT_DISCARD___41 = 9,
    IPPORT_SYSTAT___41 = 11,
    IPPORT_DAYTIME___41 = 13,
    IPPORT_NETSTAT___41 = 15,
    IPPORT_FTP___41 = 21,
    IPPORT_TELNET___41 = 23,
    IPPORT_SMTP___41 = 25,
    IPPORT_TIMESERVER___41 = 37,
    IPPORT_NAMESERVER___41 = 42,
    IPPORT_WHOIS___41 = 43,
    IPPORT_MTP___41 = 57,
    IPPORT_TFTP___41 = 69,
    IPPORT_RJE___41 = 77,
    IPPORT_FINGER___41 = 79,
    IPPORT_TTYLINK___41 = 87,
    IPPORT_SUPDUP___41 = 95,
    IPPORT_EXECSERVER___41 = 512,
    IPPORT_LOGINSERVER___41 = 513,
    IPPORT_CMDSERVER___41 = 514,
    IPPORT_EFSSERVER___41 = 520,
    IPPORT_BIFFUDP___41 = 512,
    IPPORT_WHOSERVER___41 = 513,
    IPPORT_ROUTESERVER___41 = 520,
    IPPORT_RESERVED___41 = 1024,
    IPPORT_USERRESERVED___41 = 5000
} ;
enum __anonenum_18926444___41 {
    _ISupper___41 = 256,
    _ISlower___41 = 512,
    _ISalpha___41 = 1024,
    _ISdigit___41 = 2048,
    _ISxdigit___41 = 4096,
    _ISspace___41 = 8192,
    _ISprint___41 = 16384,
    _ISgraph___41 = 32768,
    _ISblank___41 = 1,
    _IScntrl___41 = 2,
    _ISpunct___41 = 4,
    _ISalnum___41 = 8
} ;
enum __anonenum_913965969___41 {
    FP_INT_UPWARD___41 = 0,
    FP_INT_DOWNWARD___41 = 1,
    FP_INT_TOWARDZERO___41 = 2,
    FP_INT_TONEARESTFROMZERO___41 = 3,
    FP_INT_TONEAREST___41 = 4
} ;
enum __anonenum_1037408945___41 {
    FP_NAN___41 = 0,
    FP_INFINITE___41 = 1,
    FP_ZERO___41 = 2,
    FP_SUBNORMAL___41 = 3,
    FP_NORMAL___41 = 4
} ;
enum __anonenum_556971655___41 {
    SI_ASYNCNL___41 = -60,
    SI_DETHREAD___41 = -7,
    SI_TKILL___41 = -6,
    SI_SIGIO___41 = -5,
    SI_ASYNCIO___41 = -4,
    SI_MESGQ___41 = -3,
    SI_TIMER___41 = -2,
    SI_QUEUE___41 = -1,
    SI_USER___41 = 0,
    SI_KERNEL___41 = 128
} ;
enum __anonenum_640648963___41 {
    ILL_ILLOPC___41 = 1,
    ILL_ILLOPN___41 = 2,
    ILL_ILLADR___41 = 3,
    ILL_ILLTRP___41 = 4,
    ILL_PRVOPC___41 = 5,
    ILL_PRVREG___41 = 6,
    ILL_COPROC___41 = 7,
    ILL_BADSTK___41 = 8,
    ILL_BADIADDR___41 = 9
} ;
enum __anonenum_457704180___41 {
    FPE_INTDIV___41 = 1,
    FPE_INTOVF___41 = 2,
    FPE_FLTDIV___41 = 3,
    FPE_FLTOVF___41 = 4,
    FPE_FLTUND___41 = 5,
    FPE_FLTRES___41 = 6,
    FPE_FLTINV___41 = 7,
    FPE_FLTSUB___41 = 8,
    FPE_FLTUNK___41 = 14,
    FPE_CONDTRAP___41 = 15
} ;
enum __anonenum_180375148___41 {
    SEGV_MAPERR___41 = 1,
    SEGV_ACCERR___41 = 2,
    SEGV_BNDERR___41 = 3,
    SEGV_PKUERR___41 = 4,
    SEGV_ACCADI___41 = 5,
    SEGV_ADIDERR___41 = 6,
    SEGV_ADIPERR___41 = 7,
    SEGV_MTEAERR___41 = 8,
    SEGV_MTESERR___41 = 9
} ;
enum __anonenum_1036286214___41 {
    BUS_ADRALN___41 = 1,
    BUS_ADRERR___41 = 2,
    BUS_OBJERR___41 = 3,
    BUS_MCEERR_AR___41 = 4,
    BUS_MCEERR_AO___41 = 5
} ;
enum __anonenum_91015150___41 {
    TRAP_BRKPT___41 = 1,
    TRAP_TRACE___41 = 2,
    TRAP_BRANCH___41 = 3,
    TRAP_HWBKPT___41 = 4,
    TRAP_UNK___41 = 5
} ;
enum __anonenum_23175539___41 {
    CLD_EXITED___41 = 1,
    CLD_KILLED___41 = 2,
    CLD_DUMPED___41 = 3,
    CLD_TRAPPED___41 = 4,
    CLD_STOPPED___41 = 5,
    CLD_CONTINUED___41 = 6
} ;
enum __anonenum_111643124___41 {
    POLL_IN___41 = 1,
    POLL_OUT___41 = 2,
    POLL_MSG___41 = 3,
    POLL_ERR___41 = 4,
    POLL_PRI___41 = 5,
    POLL_HUP___41 = 6
} ;
enum __anonenum_852341087___41 {
    SIGEV_SIGNAL___41 = 0,
    SIGEV_NONE___41 = 1,
    SIGEV_THREAD___41 = 2,
    SIGEV_THREAD_ID___41 = 4
} ;
enum __anonenum_451154152___41 {
    REG_R8___41 = 0,
    REG_R9___41 = 1,
    REG_R10___41 = 2,
    REG_R11___41 = 3,
    REG_R12___41 = 4,
    REG_R13___41 = 5,
    REG_R14___41 = 6,
    REG_R15___41 = 7,
    REG_RDI___41 = 8,
    REG_RSI___41 = 9,
    REG_RBP___41 = 10,
    REG_RBX___41 = 11,
    REG_RDX___41 = 12,
    REG_RAX___41 = 13,
    REG_RCX___41 = 14,
    REG_RSP___41 = 15,
    REG_RIP___41 = 16,
    REG_EFL___41 = 17,
    REG_CSGSFS___41 = 18,
    REG_ERR___41 = 19,
    REG_TRAPNO___41 = 20,
    REG_OLDMASK___41 = 21,
    REG_CR2___41 = 22
} ;
enum __anonenum_437032235___41 {
    _PC_LINK_MAX___41 = 0,
    _PC_MAX_CANON___41 = 1,
    _PC_MAX_INPUT___41 = 2,
    _PC_NAME_MAX___41 = 3,
    _PC_PATH_MAX___41 = 4,
    _PC_PIPE_BUF___41 = 5,
    _PC_CHOWN_RESTRICTED___41 = 6,
    _PC_NO_TRUNC___41 = 7,
    _PC_VDISABLE___41 = 8,
    _PC_SYNC_IO___41 = 9,
    _PC_ASYNC_IO___41 = 10,
    _PC_PRIO_IO___41 = 11,
    _PC_SOCK_MAXBUF___41 = 12,
    _PC_FILESIZEBITS___41 = 13,
    _PC_REC_INCR_XFER_SIZE___41 = 14,
    _PC_REC_MAX_XFER_SIZE___41 = 15,
    _PC_REC_MIN_XFER_SIZE___41 = 16,
    _PC_REC_XFER_ALIGN___41 = 17,
    _PC_ALLOC_SIZE_MIN___41 = 18,
    _PC_SYMLINK_MAX___41 = 19,
    _PC_2_SYMLINKS___41 = 20
} ;
enum __anonenum_315186338___41 {
    _SC_ARG_MAX___41 = 0,
    _SC_CHILD_MAX___41 = 1,
    _SC_CLK_TCK___41 = 2,
    _SC_NGROUPS_MAX___41 = 3,
    _SC_OPEN_MAX___41 = 4,
    _SC_STREAM_MAX___41 = 5,
    _SC_TZNAME_MAX___41 = 6,
    _SC_JOB_CONTROL___41 = 7,
    _SC_SAVED_IDS___41 = 8,
    _SC_REALTIME_SIGNALS___41 = 9,
    _SC_PRIORITY_SCHEDULING___41 = 10,
    _SC_TIMERS___41 = 11,
    _SC_ASYNCHRONOUS_IO___41 = 12,
    _SC_PRIORITIZED_IO___41 = 13,
    _SC_SYNCHRONIZED_IO___41 = 14,
    _SC_FSYNC___41 = 15,
    _SC_MAPPED_FILES___41 = 16,
    _SC_MEMLOCK___41 = 17,
    _SC_MEMLOCK_RANGE___41 = 18,
    _SC_MEMORY_PROTECTION___41 = 19,
    _SC_MESSAGE_PASSING___41 = 20,
    _SC_SEMAPHORES___41 = 21,
    _SC_SHARED_MEMORY_OBJECTS___41 = 22,
    _SC_AIO_LISTIO_MAX___41 = 23,
    _SC_AIO_MAX___41 = 24,
    _SC_AIO_PRIO_DELTA_MAX___41 = 25,
    _SC_DELAYTIMER_MAX___41 = 26,
    _SC_MQ_OPEN_MAX___41 = 27,
    _SC_MQ_PRIO_MAX___41 = 28,
    _SC_VERSION___41 = 29,
    _SC_PAGESIZE___41 = 30,
    _SC_RTSIG_MAX___41 = 31,
    _SC_SEM_NSEMS_MAX___41 = 32,
    _SC_SEM_VALUE_MAX___41 = 33,
    _SC_SIGQUEUE_MAX___41 = 34,
    _SC_TIMER_MAX___41 = 35,
    _SC_BC_BASE_MAX___41 = 36,
    _SC_BC_DIM_MAX___41 = 37,
    _SC_BC_SCALE_MAX___41 = 38,
    _SC_BC_STRING_MAX___41 = 39,
    _SC_COLL_WEIGHTS_MAX___41 = 40,
    _SC_EQUIV_CLASS_MAX___41 = 41,
    _SC_EXPR_NEST_MAX___41 = 42,
    _SC_LINE_MAX___41 = 43,
    _SC_RE_DUP_MAX___41 = 44,
    _SC_CHARCLASS_NAME_MAX___41 = 45,
    _SC_2_VERSION___41 = 46,
    _SC_2_C_BIND___41 = 47,
    _SC_2_C_DEV___41 = 48,
    _SC_2_FORT_DEV___41 = 49,
    _SC_2_FORT_RUN___41 = 50,
    _SC_2_SW_DEV___41 = 51,
    _SC_2_LOCALEDEF___41 = 52,
    _SC_PII___41 = 53,
    _SC_PII_XTI___41 = 54,
    _SC_PII_SOCKET___41 = 55,
    _SC_PII_INTERNET___41 = 56,
    _SC_PII_OSI___41 = 57,
    _SC_POLL___41 = 58,
    _SC_SELECT___41 = 59,
    _SC_UIO_MAXIOV___41 = 60,
    _SC_IOV_MAX___41 = 60,
    _SC_PII_INTERNET_STREAM___41 = 61,
    _SC_PII_INTERNET_DGRAM___41 = 62,
    _SC_PII_OSI_COTS___41 = 63,
    _SC_PII_OSI_CLTS___41 = 64,
    _SC_PII_OSI_M___41 = 65,
    _SC_T_IOV_MAX___41 = 66,
    _SC_THREADS___41 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___41 = 68,
    _SC_GETGR_R_SIZE_MAX___41 = 69,
    _SC_GETPW_R_SIZE_MAX___41 = 70,
    _SC_LOGIN_NAME_MAX___41 = 71,
    _SC_TTY_NAME_MAX___41 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___41 = 73,
    _SC_THREAD_KEYS_MAX___41 = 74,
    _SC_THREAD_STACK_MIN___41 = 75,
    _SC_THREAD_THREADS_MAX___41 = 76,
    _SC_THREAD_ATTR_STACKADDR___41 = 77,
    _SC_THREAD_ATTR_STACKSIZE___41 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___41 = 79,
    _SC_THREAD_PRIO_INHERIT___41 = 80,
    _SC_THREAD_PRIO_PROTECT___41 = 81,
    _SC_THREAD_PROCESS_SHARED___41 = 82,
    _SC_NPROCESSORS_CONF___41 = 83,
    _SC_NPROCESSORS_ONLN___41 = 84,
    _SC_PHYS_PAGES___41 = 85,
    _SC_AVPHYS_PAGES___41 = 86,
    _SC_ATEXIT_MAX___41 = 87,
    _SC_PASS_MAX___41 = 88,
    _SC_XOPEN_VERSION___41 = 89,
    _SC_XOPEN_XCU_VERSION___41 = 90,
    _SC_XOPEN_UNIX___41 = 91,
    _SC_XOPEN_CRYPT___41 = 92,
    _SC_XOPEN_ENH_I18N___41 = 93,
    _SC_XOPEN_SHM___41 = 94,
    _SC_2_CHAR_TERM___41 = 95,
    _SC_2_C_VERSION___41 = 96,
    _SC_2_UPE___41 = 97,
    _SC_XOPEN_XPG2___41 = 98,
    _SC_XOPEN_XPG3___41 = 99,
    _SC_XOPEN_XPG4___41 = 100,
    _SC_CHAR_BIT___41 = 101,
    _SC_CHAR_MAX___41 = 102,
    _SC_CHAR_MIN___41 = 103,
    _SC_INT_MAX___41 = 104,
    _SC_INT_MIN___41 = 105,
    _SC_LONG_BIT___41 = 106,
    _SC_WORD_BIT___41 = 107,
    _SC_MB_LEN_MAX___41 = 108,
    _SC_NZERO___41 = 109,
    _SC_SSIZE_MAX___41 = 110,
    _SC_SCHAR_MAX___41 = 111,
    _SC_SCHAR_MIN___41 = 112,
    _SC_SHRT_MAX___41 = 113,
    _SC_SHRT_MIN___41 = 114,
    _SC_UCHAR_MAX___41 = 115,
    _SC_UINT_MAX___41 = 116,
    _SC_ULONG_MAX___41 = 117,
    _SC_USHRT_MAX___41 = 118,
    _SC_NL_ARGMAX___41 = 119,
    _SC_NL_LANGMAX___41 = 120,
    _SC_NL_MSGMAX___41 = 121,
    _SC_NL_NMAX___41 = 122,
    _SC_NL_SETMAX___41 = 123,
    _SC_NL_TEXTMAX___41 = 124,
    _SC_XBS5_ILP32_OFF32___41 = 125,
    _SC_XBS5_ILP32_OFFBIG___41 = 126,
    _SC_XBS5_LP64_OFF64___41 = 127,
    _SC_XBS5_LPBIG_OFFBIG___41 = 128,
    _SC_XOPEN_LEGACY___41 = 129,
    _SC_XOPEN_REALTIME___41 = 130,
    _SC_XOPEN_REALTIME_THREADS___41 = 131,
    _SC_ADVISORY_INFO___41 = 132,
    _SC_BARRIERS___41 = 133,
    _SC_BASE___41 = 134,
    _SC_C_LANG_SUPPORT___41 = 135,
    _SC_C_LANG_SUPPORT_R___41 = 136,
    _SC_CLOCK_SELECTION___41 = 137,
    _SC_CPUTIME___41 = 138,
    _SC_THREAD_CPUTIME___41 = 139,
    _SC_DEVICE_IO___41 = 140,
    _SC_DEVICE_SPECIFIC___41 = 141,
    _SC_DEVICE_SPECIFIC_R___41 = 142,
    _SC_FD_MGMT___41 = 143,
    _SC_FIFO___41 = 144,
    _SC_PIPE___41 = 145,
    _SC_FILE_ATTRIBUTES___41 = 146,
    _SC_FILE_LOCKING___41 = 147,
    _SC_FILE_SYSTEM___41 = 148,
    _SC_MONOTONIC_CLOCK___41 = 149,
    _SC_MULTI_PROCESS___41 = 150,
    _SC_SINGLE_PROCESS___41 = 151,
    _SC_NETWORKING___41 = 152,
    _SC_READER_WRITER_LOCKS___41 = 153,
    _SC_SPIN_LOCKS___41 = 154,
    _SC_REGEXP___41 = 155,
    _SC_REGEX_VERSION___41 = 156,
    _SC_SHELL___41 = 157,
    _SC_SIGNALS___41 = 158,
    _SC_SPAWN___41 = 159,
    _SC_SPORADIC_SERVER___41 = 160,
    _SC_THREAD_SPORADIC_SERVER___41 = 161,
    _SC_SYSTEM_DATABASE___41 = 162,
    _SC_SYSTEM_DATABASE_R___41 = 163,
    _SC_TIMEOUTS___41 = 164,
    _SC_TYPED_MEMORY_OBJECTS___41 = 165,
    _SC_USER_GROUPS___41 = 166,
    _SC_USER_GROUPS_R___41 = 167,
    _SC_2_PBS___41 = 168,
    _SC_2_PBS_ACCOUNTING___41 = 169,
    _SC_2_PBS_LOCATE___41 = 170,
    _SC_2_PBS_MESSAGE___41 = 171,
    _SC_2_PBS_TRACK___41 = 172,
    _SC_SYMLOOP_MAX___41 = 173,
    _SC_STREAMS___41 = 174,
    _SC_2_PBS_CHECKPOINT___41 = 175,
    _SC_V6_ILP32_OFF32___41 = 176,
    _SC_V6_ILP32_OFFBIG___41 = 177,
    _SC_V6_LP64_OFF64___41 = 178,
    _SC_V6_LPBIG_OFFBIG___41 = 179,
    _SC_HOST_NAME_MAX___41 = 180,
    _SC_TRACE___41 = 181,
    _SC_TRACE_EVENT_FILTER___41 = 182,
    _SC_TRACE_INHERIT___41 = 183,
    _SC_TRACE_LOG___41 = 184,
    _SC_LEVEL1_ICACHE_SIZE___41 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___41 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___41 = 187,
    _SC_LEVEL1_DCACHE_SIZE___41 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___41 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___41 = 190,
    _SC_LEVEL2_CACHE_SIZE___41 = 191,
    _SC_LEVEL2_CACHE_ASSOC___41 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___41 = 193,
    _SC_LEVEL3_CACHE_SIZE___41 = 194,
    _SC_LEVEL3_CACHE_ASSOC___41 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___41 = 196,
    _SC_LEVEL4_CACHE_SIZE___41 = 197,
    _SC_LEVEL4_CACHE_ASSOC___41 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___41 = 199,
    _SC_IPV6___41 = 235,
    _SC_RAW_SOCKETS___41 = 236,
    _SC_V7_ILP32_OFF32___41 = 237,
    _SC_V7_ILP32_OFFBIG___41 = 238,
    _SC_V7_LP64_OFF64___41 = 239,
    _SC_V7_LPBIG_OFFBIG___41 = 240,
    _SC_SS_REPL_MAX___41 = 241,
    _SC_TRACE_EVENT_NAME_MAX___41 = 242,
    _SC_TRACE_NAME_MAX___41 = 243,
    _SC_TRACE_SYS_MAX___41 = 244,
    _SC_TRACE_USER_EVENT_MAX___41 = 245,
    _SC_XOPEN_STREAMS___41 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___41 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___41 = 248,
    _SC_MINSIGSTKSZ___41 = 249,
    _SC_SIGSTKSZ___41 = 250
} ;
enum __anonenum_875524036___41 {
    _CS_PATH___41 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___41 = 1,
    _CS_GNU_LIBC_VERSION___41 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___41 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___41 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___41 = 5,
    _CS_LFS_CFLAGS___41 = 1000,
    _CS_LFS_LDFLAGS___41 = 1001,
    _CS_LFS_LIBS___41 = 1002,
    _CS_LFS_LINTFLAGS___41 = 1003,
    _CS_LFS64_CFLAGS___41 = 1004,
    _CS_LFS64_LDFLAGS___41 = 1005,
    _CS_LFS64_LIBS___41 = 1006,
    _CS_LFS64_LINTFLAGS___41 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___41 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___41 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___41 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___41 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___41 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___41 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___41 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___41 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___41 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___41 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___41 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___41 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___41 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___41 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___41 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___41 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___41 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___41 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___41 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___41 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___41 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___41 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___41 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___41 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___41 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___41 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___41 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___41 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___41 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___41 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___41 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___41 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___41 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___41 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___41 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___41 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___41 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___41 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___41 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___41 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___41 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___41 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___41 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___41 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___41 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___41 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___41 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___41 = 1147,
    _CS_V6_ENV___41 = 1148,
    _CS_V7_ENV___41 = 1149
} ;
enum __anonenum_57186863___41 {
    SS_ONSTACK___41 = 1,
    SS_DISABLE___41 = 2
} ;
enum __anonenum_34415463___1 {
    PTHREAD_CREATE_JOINABLE___1 = 0,
    PTHREAD_CREATE_DETACHED___1 = 1
} ;
enum __anonenum_303612439___0 {
    PTHREAD_MUTEX_TIMED_NP___1 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___1 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___1 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___1 = 3,
    PTHREAD_MUTEX_NORMAL___1 = 0,
    PTHREAD_MUTEX_RECURSIVE___1 = 1,
    PTHREAD_MUTEX_ERRORCHECK___1 = 2,
    PTHREAD_MUTEX_DEFAULT___1 = 0,
    PTHREAD_MUTEX_FAST_NP___0 = 0
} ;
enum __anonenum_931900394___1 {
    PTHREAD_MUTEX_STALLED___1 = 0,
    PTHREAD_MUTEX_STALLED_NP___1 = 0,
    PTHREAD_MUTEX_ROBUST___1 = 1,
    PTHREAD_MUTEX_ROBUST_NP___1 = 1
} ;
enum __anonenum_205214487___1 {
    PTHREAD_PRIO_NONE___1 = 0,
    PTHREAD_PRIO_INHERIT___1 = 1,
    PTHREAD_PRIO_PROTECT___1 = 2
} ;
enum __anonenum_25043950___1 {
    PTHREAD_RWLOCK_PREFER_READER_NP___1 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___1 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___1 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___1 = 0
} ;
enum __anonenum_436439511___1 {
    PTHREAD_INHERIT_SCHED___1 = 0,
    PTHREAD_EXPLICIT_SCHED___1 = 1
} ;
enum __anonenum_998661166___1 {
    PTHREAD_SCOPE_SYSTEM___1 = 0,
    PTHREAD_SCOPE_PROCESS___1 = 1
} ;
enum __anonenum_146137331___1 {
    PTHREAD_PROCESS_PRIVATE___1 = 0,
    PTHREAD_PROCESS_SHARED___1 = 1
} ;
enum __anonenum_53396917___1 {
    PTHREAD_CANCEL_ENABLE___1 = 0,
    PTHREAD_CANCEL_DISABLE___1 = 1
} ;
enum __anonenum_904563783___1 {
    PTHREAD_CANCEL_DEFERRED___1 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___1 = 1
} ;
struct DNS_Async_Instance {
   char const *name ;
   DNS_Status status ;
   IPAddr addresses[16] ;
   void (*handler)(DNS_Status status , int n_addrs , IPAddr *ip_addrs , void *anything ) ;
   void *arg ;
   pthread_t thread ;
   int pipe[2] ;
};
enum __anonenum_83571709___42 {
    MSG_OOB___42 = 1,
    MSG_PEEK___42 = 2,
    MSG_DONTROUTE___42 = 4,
    MSG_TRYHARD___42 = 4,
    MSG_CTRUNC___42 = 8,
    MSG_PROXY___42 = 16,
    MSG_TRUNC___42 = 32,
    MSG_DONTWAIT___42 = 64,
    MSG_EOR___42 = 128,
    MSG_WAITALL___42 = 256,
    MSG_FIN___42 = 512,
    MSG_SYN___42 = 1024,
    MSG_CONFIRM___42 = 2048,
    MSG_RST___42 = 4096,
    MSG_ERRQUEUE___42 = 8192,
    MSG_NOSIGNAL___42 = 16384,
    MSG_MORE___42 = 32768,
    MSG_WAITFORONE___42 = 65536,
    MSG_BATCH___42 = 262144,
    MSG_ZEROCOPY___42 = 67108864,
    MSG_FASTOPEN___42 = 536870912,
    MSG_CMSG_CLOEXEC___42 = 1073741824
} ;
enum __anonenum_617082774___42 {
    SCM_RIGHTS___42 = 1,
    SCM_CREDENTIALS___42 = 2
} ;
enum __anonenum_606441560___42 {
    SHUT_RD___42 = 0,
    SHUT_WR___42 = 1,
    SHUT_RDWR___42 = 2
} ;
enum __anonenum_264779956___42 {
    IPPROTO_IP___42 = 0,
    IPPROTO_ICMP___42 = 1,
    IPPROTO_IGMP___42 = 2,
    IPPROTO_IPIP___42 = 4,
    IPPROTO_TCP___42 = 6,
    IPPROTO_EGP___42 = 8,
    IPPROTO_PUP___42 = 12,
    IPPROTO_UDP___42 = 17,
    IPPROTO_IDP___42 = 22,
    IPPROTO_TP___42 = 29,
    IPPROTO_DCCP___42 = 33,
    IPPROTO_IPV6___42 = 41,
    IPPROTO_RSVP___42 = 46,
    IPPROTO_GRE___42 = 47,
    IPPROTO_ESP___42 = 50,
    IPPROTO_AH___42 = 51,
    IPPROTO_MTP___42 = 92,
    IPPROTO_BEETPH___42 = 94,
    IPPROTO_ENCAP___42 = 98,
    IPPROTO_PIM___42 = 103,
    IPPROTO_COMP___42 = 108,
    IPPROTO_SCTP___42 = 132,
    IPPROTO_UDPLITE___42 = 136,
    IPPROTO_MPLS___42 = 137,
    IPPROTO_ETHERNET___42 = 143,
    IPPROTO_RAW___42 = 255,
    IPPROTO_MPTCP___42 = 262,
    IPPROTO_MAX___42 = 263
} ;
enum __anonenum_218739988___42 {
    IPPROTO_HOPOPTS___42 = 0,
    IPPROTO_ROUTING___42 = 43,
    IPPROTO_FRAGMENT___42 = 44,
    IPPROTO_ICMPV6___42 = 58,
    IPPROTO_NONE___42 = 59,
    IPPROTO_DSTOPTS___42 = 60,
    IPPROTO_MH___42 = 135
} ;
enum __anonenum_662268580___42 {
    IPPORT_ECHO___42 = 7,
    IPPORT_DISCARD___42 = 9,
    IPPORT_SYSTAT___42 = 11,
    IPPORT_DAYTIME___42 = 13,
    IPPORT_NETSTAT___42 = 15,
    IPPORT_FTP___42 = 21,
    IPPORT_TELNET___42 = 23,
    IPPORT_SMTP___42 = 25,
    IPPORT_TIMESERVER___42 = 37,
    IPPORT_NAMESERVER___42 = 42,
    IPPORT_WHOIS___42 = 43,
    IPPORT_MTP___42 = 57,
    IPPORT_TFTP___42 = 69,
    IPPORT_RJE___42 = 77,
    IPPORT_FINGER___42 = 79,
    IPPORT_TTYLINK___42 = 87,
    IPPORT_SUPDUP___42 = 95,
    IPPORT_EXECSERVER___42 = 512,
    IPPORT_LOGINSERVER___42 = 513,
    IPPORT_CMDSERVER___42 = 514,
    IPPORT_EFSSERVER___42 = 520,
    IPPORT_BIFFUDP___42 = 512,
    IPPORT_WHOSERVER___42 = 513,
    IPPORT_ROUTESERVER___42 = 520,
    IPPORT_RESERVED___42 = 1024,
    IPPORT_USERRESERVED___42 = 5000
} ;
enum __anonenum_18926444___42 {
    _ISupper___42 = 256,
    _ISlower___42 = 512,
    _ISalpha___42 = 1024,
    _ISdigit___42 = 2048,
    _ISxdigit___42 = 4096,
    _ISspace___42 = 8192,
    _ISprint___42 = 16384,
    _ISgraph___42 = 32768,
    _ISblank___42 = 1,
    _IScntrl___42 = 2,
    _ISpunct___42 = 4,
    _ISalnum___42 = 8
} ;
enum __anonenum_913965969___42 {
    FP_INT_UPWARD___42 = 0,
    FP_INT_DOWNWARD___42 = 1,
    FP_INT_TOWARDZERO___42 = 2,
    FP_INT_TONEARESTFROMZERO___42 = 3,
    FP_INT_TONEAREST___42 = 4
} ;
enum __anonenum_1037408945___42 {
    FP_NAN___42 = 0,
    FP_INFINITE___42 = 1,
    FP_ZERO___42 = 2,
    FP_SUBNORMAL___42 = 3,
    FP_NORMAL___42 = 4
} ;
enum __anonenum_556971655___42 {
    SI_ASYNCNL___42 = -60,
    SI_DETHREAD___42 = -7,
    SI_TKILL___42 = -6,
    SI_SIGIO___42 = -5,
    SI_ASYNCIO___42 = -4,
    SI_MESGQ___42 = -3,
    SI_TIMER___42 = -2,
    SI_QUEUE___42 = -1,
    SI_USER___42 = 0,
    SI_KERNEL___42 = 128
} ;
enum __anonenum_640648963___42 {
    ILL_ILLOPC___42 = 1,
    ILL_ILLOPN___42 = 2,
    ILL_ILLADR___42 = 3,
    ILL_ILLTRP___42 = 4,
    ILL_PRVOPC___42 = 5,
    ILL_PRVREG___42 = 6,
    ILL_COPROC___42 = 7,
    ILL_BADSTK___42 = 8,
    ILL_BADIADDR___42 = 9
} ;
enum __anonenum_457704180___42 {
    FPE_INTDIV___42 = 1,
    FPE_INTOVF___42 = 2,
    FPE_FLTDIV___42 = 3,
    FPE_FLTOVF___42 = 4,
    FPE_FLTUND___42 = 5,
    FPE_FLTRES___42 = 6,
    FPE_FLTINV___42 = 7,
    FPE_FLTSUB___42 = 8,
    FPE_FLTUNK___42 = 14,
    FPE_CONDTRAP___42 = 15
} ;
enum __anonenum_180375148___42 {
    SEGV_MAPERR___42 = 1,
    SEGV_ACCERR___42 = 2,
    SEGV_BNDERR___42 = 3,
    SEGV_PKUERR___42 = 4,
    SEGV_ACCADI___42 = 5,
    SEGV_ADIDERR___42 = 6,
    SEGV_ADIPERR___42 = 7,
    SEGV_MTEAERR___42 = 8,
    SEGV_MTESERR___42 = 9
} ;
enum __anonenum_1036286214___42 {
    BUS_ADRALN___42 = 1,
    BUS_ADRERR___42 = 2,
    BUS_OBJERR___42 = 3,
    BUS_MCEERR_AR___42 = 4,
    BUS_MCEERR_AO___42 = 5
} ;
enum __anonenum_91015150___42 {
    TRAP_BRKPT___42 = 1,
    TRAP_TRACE___42 = 2,
    TRAP_BRANCH___42 = 3,
    TRAP_HWBKPT___42 = 4,
    TRAP_UNK___42 = 5
} ;
enum __anonenum_23175539___42 {
    CLD_EXITED___42 = 1,
    CLD_KILLED___42 = 2,
    CLD_DUMPED___42 = 3,
    CLD_TRAPPED___42 = 4,
    CLD_STOPPED___42 = 5,
    CLD_CONTINUED___42 = 6
} ;
enum __anonenum_111643124___42 {
    POLL_IN___42 = 1,
    POLL_OUT___42 = 2,
    POLL_MSG___42 = 3,
    POLL_ERR___42 = 4,
    POLL_PRI___42 = 5,
    POLL_HUP___42 = 6
} ;
enum __anonenum_852341087___42 {
    SIGEV_SIGNAL___42 = 0,
    SIGEV_NONE___42 = 1,
    SIGEV_THREAD___42 = 2,
    SIGEV_THREAD_ID___42 = 4
} ;
enum __anonenum_451154152___42 {
    REG_R8___42 = 0,
    REG_R9___42 = 1,
    REG_R10___42 = 2,
    REG_R11___42 = 3,
    REG_R12___42 = 4,
    REG_R13___42 = 5,
    REG_R14___42 = 6,
    REG_R15___42 = 7,
    REG_RDI___42 = 8,
    REG_RSI___42 = 9,
    REG_RBP___42 = 10,
    REG_RBX___42 = 11,
    REG_RDX___42 = 12,
    REG_RAX___42 = 13,
    REG_RCX___42 = 14,
    REG_RSP___42 = 15,
    REG_RIP___42 = 16,
    REG_EFL___42 = 17,
    REG_CSGSFS___42 = 18,
    REG_ERR___42 = 19,
    REG_TRAPNO___42 = 20,
    REG_OLDMASK___42 = 21,
    REG_CR2___42 = 22
} ;
enum __anonenum_437032235___42 {
    _PC_LINK_MAX___42 = 0,
    _PC_MAX_CANON___42 = 1,
    _PC_MAX_INPUT___42 = 2,
    _PC_NAME_MAX___42 = 3,
    _PC_PATH_MAX___42 = 4,
    _PC_PIPE_BUF___42 = 5,
    _PC_CHOWN_RESTRICTED___42 = 6,
    _PC_NO_TRUNC___42 = 7,
    _PC_VDISABLE___42 = 8,
    _PC_SYNC_IO___42 = 9,
    _PC_ASYNC_IO___42 = 10,
    _PC_PRIO_IO___42 = 11,
    _PC_SOCK_MAXBUF___42 = 12,
    _PC_FILESIZEBITS___42 = 13,
    _PC_REC_INCR_XFER_SIZE___42 = 14,
    _PC_REC_MAX_XFER_SIZE___42 = 15,
    _PC_REC_MIN_XFER_SIZE___42 = 16,
    _PC_REC_XFER_ALIGN___42 = 17,
    _PC_ALLOC_SIZE_MIN___42 = 18,
    _PC_SYMLINK_MAX___42 = 19,
    _PC_2_SYMLINKS___42 = 20
} ;
enum __anonenum_315186338___42 {
    _SC_ARG_MAX___42 = 0,
    _SC_CHILD_MAX___42 = 1,
    _SC_CLK_TCK___42 = 2,
    _SC_NGROUPS_MAX___42 = 3,
    _SC_OPEN_MAX___42 = 4,
    _SC_STREAM_MAX___42 = 5,
    _SC_TZNAME_MAX___42 = 6,
    _SC_JOB_CONTROL___42 = 7,
    _SC_SAVED_IDS___42 = 8,
    _SC_REALTIME_SIGNALS___42 = 9,
    _SC_PRIORITY_SCHEDULING___42 = 10,
    _SC_TIMERS___42 = 11,
    _SC_ASYNCHRONOUS_IO___42 = 12,
    _SC_PRIORITIZED_IO___42 = 13,
    _SC_SYNCHRONIZED_IO___42 = 14,
    _SC_FSYNC___42 = 15,
    _SC_MAPPED_FILES___42 = 16,
    _SC_MEMLOCK___42 = 17,
    _SC_MEMLOCK_RANGE___42 = 18,
    _SC_MEMORY_PROTECTION___42 = 19,
    _SC_MESSAGE_PASSING___42 = 20,
    _SC_SEMAPHORES___42 = 21,
    _SC_SHARED_MEMORY_OBJECTS___42 = 22,
    _SC_AIO_LISTIO_MAX___42 = 23,
    _SC_AIO_MAX___42 = 24,
    _SC_AIO_PRIO_DELTA_MAX___42 = 25,
    _SC_DELAYTIMER_MAX___42 = 26,
    _SC_MQ_OPEN_MAX___42 = 27,
    _SC_MQ_PRIO_MAX___42 = 28,
    _SC_VERSION___42 = 29,
    _SC_PAGESIZE___42 = 30,
    _SC_RTSIG_MAX___42 = 31,
    _SC_SEM_NSEMS_MAX___42 = 32,
    _SC_SEM_VALUE_MAX___42 = 33,
    _SC_SIGQUEUE_MAX___42 = 34,
    _SC_TIMER_MAX___42 = 35,
    _SC_BC_BASE_MAX___42 = 36,
    _SC_BC_DIM_MAX___42 = 37,
    _SC_BC_SCALE_MAX___42 = 38,
    _SC_BC_STRING_MAX___42 = 39,
    _SC_COLL_WEIGHTS_MAX___42 = 40,
    _SC_EQUIV_CLASS_MAX___42 = 41,
    _SC_EXPR_NEST_MAX___42 = 42,
    _SC_LINE_MAX___42 = 43,
    _SC_RE_DUP_MAX___42 = 44,
    _SC_CHARCLASS_NAME_MAX___42 = 45,
    _SC_2_VERSION___42 = 46,
    _SC_2_C_BIND___42 = 47,
    _SC_2_C_DEV___42 = 48,
    _SC_2_FORT_DEV___42 = 49,
    _SC_2_FORT_RUN___42 = 50,
    _SC_2_SW_DEV___42 = 51,
    _SC_2_LOCALEDEF___42 = 52,
    _SC_PII___42 = 53,
    _SC_PII_XTI___42 = 54,
    _SC_PII_SOCKET___42 = 55,
    _SC_PII_INTERNET___42 = 56,
    _SC_PII_OSI___42 = 57,
    _SC_POLL___42 = 58,
    _SC_SELECT___42 = 59,
    _SC_UIO_MAXIOV___42 = 60,
    _SC_IOV_MAX___42 = 60,
    _SC_PII_INTERNET_STREAM___42 = 61,
    _SC_PII_INTERNET_DGRAM___42 = 62,
    _SC_PII_OSI_COTS___42 = 63,
    _SC_PII_OSI_CLTS___42 = 64,
    _SC_PII_OSI_M___42 = 65,
    _SC_T_IOV_MAX___42 = 66,
    _SC_THREADS___42 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___42 = 68,
    _SC_GETGR_R_SIZE_MAX___42 = 69,
    _SC_GETPW_R_SIZE_MAX___42 = 70,
    _SC_LOGIN_NAME_MAX___42 = 71,
    _SC_TTY_NAME_MAX___42 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___42 = 73,
    _SC_THREAD_KEYS_MAX___42 = 74,
    _SC_THREAD_STACK_MIN___42 = 75,
    _SC_THREAD_THREADS_MAX___42 = 76,
    _SC_THREAD_ATTR_STACKADDR___42 = 77,
    _SC_THREAD_ATTR_STACKSIZE___42 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___42 = 79,
    _SC_THREAD_PRIO_INHERIT___42 = 80,
    _SC_THREAD_PRIO_PROTECT___42 = 81,
    _SC_THREAD_PROCESS_SHARED___42 = 82,
    _SC_NPROCESSORS_CONF___42 = 83,
    _SC_NPROCESSORS_ONLN___42 = 84,
    _SC_PHYS_PAGES___42 = 85,
    _SC_AVPHYS_PAGES___42 = 86,
    _SC_ATEXIT_MAX___42 = 87,
    _SC_PASS_MAX___42 = 88,
    _SC_XOPEN_VERSION___42 = 89,
    _SC_XOPEN_XCU_VERSION___42 = 90,
    _SC_XOPEN_UNIX___42 = 91,
    _SC_XOPEN_CRYPT___42 = 92,
    _SC_XOPEN_ENH_I18N___42 = 93,
    _SC_XOPEN_SHM___42 = 94,
    _SC_2_CHAR_TERM___42 = 95,
    _SC_2_C_VERSION___42 = 96,
    _SC_2_UPE___42 = 97,
    _SC_XOPEN_XPG2___42 = 98,
    _SC_XOPEN_XPG3___42 = 99,
    _SC_XOPEN_XPG4___42 = 100,
    _SC_CHAR_BIT___42 = 101,
    _SC_CHAR_MAX___42 = 102,
    _SC_CHAR_MIN___42 = 103,
    _SC_INT_MAX___42 = 104,
    _SC_INT_MIN___42 = 105,
    _SC_LONG_BIT___42 = 106,
    _SC_WORD_BIT___42 = 107,
    _SC_MB_LEN_MAX___42 = 108,
    _SC_NZERO___42 = 109,
    _SC_SSIZE_MAX___42 = 110,
    _SC_SCHAR_MAX___42 = 111,
    _SC_SCHAR_MIN___42 = 112,
    _SC_SHRT_MAX___42 = 113,
    _SC_SHRT_MIN___42 = 114,
    _SC_UCHAR_MAX___42 = 115,
    _SC_UINT_MAX___42 = 116,
    _SC_ULONG_MAX___42 = 117,
    _SC_USHRT_MAX___42 = 118,
    _SC_NL_ARGMAX___42 = 119,
    _SC_NL_LANGMAX___42 = 120,
    _SC_NL_MSGMAX___42 = 121,
    _SC_NL_NMAX___42 = 122,
    _SC_NL_SETMAX___42 = 123,
    _SC_NL_TEXTMAX___42 = 124,
    _SC_XBS5_ILP32_OFF32___42 = 125,
    _SC_XBS5_ILP32_OFFBIG___42 = 126,
    _SC_XBS5_LP64_OFF64___42 = 127,
    _SC_XBS5_LPBIG_OFFBIG___42 = 128,
    _SC_XOPEN_LEGACY___42 = 129,
    _SC_XOPEN_REALTIME___42 = 130,
    _SC_XOPEN_REALTIME_THREADS___42 = 131,
    _SC_ADVISORY_INFO___42 = 132,
    _SC_BARRIERS___42 = 133,
    _SC_BASE___42 = 134,
    _SC_C_LANG_SUPPORT___42 = 135,
    _SC_C_LANG_SUPPORT_R___42 = 136,
    _SC_CLOCK_SELECTION___42 = 137,
    _SC_CPUTIME___42 = 138,
    _SC_THREAD_CPUTIME___42 = 139,
    _SC_DEVICE_IO___42 = 140,
    _SC_DEVICE_SPECIFIC___42 = 141,
    _SC_DEVICE_SPECIFIC_R___42 = 142,
    _SC_FD_MGMT___42 = 143,
    _SC_FIFO___42 = 144,
    _SC_PIPE___42 = 145,
    _SC_FILE_ATTRIBUTES___42 = 146,
    _SC_FILE_LOCKING___42 = 147,
    _SC_FILE_SYSTEM___42 = 148,
    _SC_MONOTONIC_CLOCK___42 = 149,
    _SC_MULTI_PROCESS___42 = 150,
    _SC_SINGLE_PROCESS___42 = 151,
    _SC_NETWORKING___42 = 152,
    _SC_READER_WRITER_LOCKS___42 = 153,
    _SC_SPIN_LOCKS___42 = 154,
    _SC_REGEXP___42 = 155,
    _SC_REGEX_VERSION___42 = 156,
    _SC_SHELL___42 = 157,
    _SC_SIGNALS___42 = 158,
    _SC_SPAWN___42 = 159,
    _SC_SPORADIC_SERVER___42 = 160,
    _SC_THREAD_SPORADIC_SERVER___42 = 161,
    _SC_SYSTEM_DATABASE___42 = 162,
    _SC_SYSTEM_DATABASE_R___42 = 163,
    _SC_TIMEOUTS___42 = 164,
    _SC_TYPED_MEMORY_OBJECTS___42 = 165,
    _SC_USER_GROUPS___42 = 166,
    _SC_USER_GROUPS_R___42 = 167,
    _SC_2_PBS___42 = 168,
    _SC_2_PBS_ACCOUNTING___42 = 169,
    _SC_2_PBS_LOCATE___42 = 170,
    _SC_2_PBS_MESSAGE___42 = 171,
    _SC_2_PBS_TRACK___42 = 172,
    _SC_SYMLOOP_MAX___42 = 173,
    _SC_STREAMS___42 = 174,
    _SC_2_PBS_CHECKPOINT___42 = 175,
    _SC_V6_ILP32_OFF32___42 = 176,
    _SC_V6_ILP32_OFFBIG___42 = 177,
    _SC_V6_LP64_OFF64___42 = 178,
    _SC_V6_LPBIG_OFFBIG___42 = 179,
    _SC_HOST_NAME_MAX___42 = 180,
    _SC_TRACE___42 = 181,
    _SC_TRACE_EVENT_FILTER___42 = 182,
    _SC_TRACE_INHERIT___42 = 183,
    _SC_TRACE_LOG___42 = 184,
    _SC_LEVEL1_ICACHE_SIZE___42 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___42 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___42 = 187,
    _SC_LEVEL1_DCACHE_SIZE___42 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___42 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___42 = 190,
    _SC_LEVEL2_CACHE_SIZE___42 = 191,
    _SC_LEVEL2_CACHE_ASSOC___42 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___42 = 193,
    _SC_LEVEL3_CACHE_SIZE___42 = 194,
    _SC_LEVEL3_CACHE_ASSOC___42 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___42 = 196,
    _SC_LEVEL4_CACHE_SIZE___42 = 197,
    _SC_LEVEL4_CACHE_ASSOC___42 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___42 = 199,
    _SC_IPV6___42 = 235,
    _SC_RAW_SOCKETS___42 = 236,
    _SC_V7_ILP32_OFF32___42 = 237,
    _SC_V7_ILP32_OFFBIG___42 = 238,
    _SC_V7_LP64_OFF64___42 = 239,
    _SC_V7_LPBIG_OFFBIG___42 = 240,
    _SC_SS_REPL_MAX___42 = 241,
    _SC_TRACE_EVENT_NAME_MAX___42 = 242,
    _SC_TRACE_NAME_MAX___42 = 243,
    _SC_TRACE_SYS_MAX___42 = 244,
    _SC_TRACE_USER_EVENT_MAX___42 = 245,
    _SC_XOPEN_STREAMS___42 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___42 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___42 = 248,
    _SC_MINSIGSTKSZ___42 = 249,
    _SC_SIGSTKSZ___42 = 250
} ;
enum __anonenum_875524036___42 {
    _CS_PATH___42 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___42 = 1,
    _CS_GNU_LIBC_VERSION___42 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___42 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___42 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___42 = 5,
    _CS_LFS_CFLAGS___42 = 1000,
    _CS_LFS_LDFLAGS___42 = 1001,
    _CS_LFS_LIBS___42 = 1002,
    _CS_LFS_LINTFLAGS___42 = 1003,
    _CS_LFS64_CFLAGS___42 = 1004,
    _CS_LFS64_LDFLAGS___42 = 1005,
    _CS_LFS64_LIBS___42 = 1006,
    _CS_LFS64_LINTFLAGS___42 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___42 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___42 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___42 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___42 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___42 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___42 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___42 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___42 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___42 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___42 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___42 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___42 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___42 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___42 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___42 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___42 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___42 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___42 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___42 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___42 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___42 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___42 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___42 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___42 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___42 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___42 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___42 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___42 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___42 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___42 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___42 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___42 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___42 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___42 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___42 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___42 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___42 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___42 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___42 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___42 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___42 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___42 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___42 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___42 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___42 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___42 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___42 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___42 = 1147,
    _CS_V6_ENV___42 = 1148,
    _CS_V7_ENV___42 = 1149
} ;
enum __anonenum_57186863___42 {
    SS_ONSTACK___42 = 1,
    SS_DISABLE___42 = 2
} ;
struct HCL_Instance_Record {
   struct timespec hw_ref ;
   struct timespec local_ref ;
   double *x_data ;
   double *y_data ;
   int min_samples ;
   int max_samples ;
   int n_samples ;
   double last_err ;
   double min_separation ;
   int valid_coefs ;
   double offset ;
   double frequency ;
};
enum __anonenum_83571709___43 {
    MSG_OOB___43 = 1,
    MSG_PEEK___43 = 2,
    MSG_DONTROUTE___43 = 4,
    MSG_TRYHARD___43 = 4,
    MSG_CTRUNC___43 = 8,
    MSG_PROXY___43 = 16,
    MSG_TRUNC___43 = 32,
    MSG_DONTWAIT___43 = 64,
    MSG_EOR___43 = 128,
    MSG_WAITALL___43 = 256,
    MSG_FIN___43 = 512,
    MSG_SYN___43 = 1024,
    MSG_CONFIRM___43 = 2048,
    MSG_RST___43 = 4096,
    MSG_ERRQUEUE___43 = 8192,
    MSG_NOSIGNAL___43 = 16384,
    MSG_MORE___43 = 32768,
    MSG_WAITFORONE___43 = 65536,
    MSG_BATCH___43 = 262144,
    MSG_ZEROCOPY___43 = 67108864,
    MSG_FASTOPEN___43 = 536870912,
    MSG_CMSG_CLOEXEC___43 = 1073741824
} ;
enum __anonenum_617082774___43 {
    SCM_RIGHTS___43 = 1,
    SCM_CREDENTIALS___43 = 2
} ;
enum __anonenum_606441560___43 {
    SHUT_RD___43 = 0,
    SHUT_WR___43 = 1,
    SHUT_RDWR___43 = 2
} ;
enum __anonenum_264779956___43 {
    IPPROTO_IP___43 = 0,
    IPPROTO_ICMP___43 = 1,
    IPPROTO_IGMP___43 = 2,
    IPPROTO_IPIP___43 = 4,
    IPPROTO_TCP___43 = 6,
    IPPROTO_EGP___43 = 8,
    IPPROTO_PUP___43 = 12,
    IPPROTO_UDP___43 = 17,
    IPPROTO_IDP___43 = 22,
    IPPROTO_TP___43 = 29,
    IPPROTO_DCCP___43 = 33,
    IPPROTO_IPV6___43 = 41,
    IPPROTO_RSVP___43 = 46,
    IPPROTO_GRE___43 = 47,
    IPPROTO_ESP___43 = 50,
    IPPROTO_AH___43 = 51,
    IPPROTO_MTP___43 = 92,
    IPPROTO_BEETPH___43 = 94,
    IPPROTO_ENCAP___43 = 98,
    IPPROTO_PIM___43 = 103,
    IPPROTO_COMP___43 = 108,
    IPPROTO_SCTP___43 = 132,
    IPPROTO_UDPLITE___43 = 136,
    IPPROTO_MPLS___43 = 137,
    IPPROTO_ETHERNET___43 = 143,
    IPPROTO_RAW___43 = 255,
    IPPROTO_MPTCP___43 = 262,
    IPPROTO_MAX___43 = 263
} ;
enum __anonenum_218739988___43 {
    IPPROTO_HOPOPTS___43 = 0,
    IPPROTO_ROUTING___43 = 43,
    IPPROTO_FRAGMENT___43 = 44,
    IPPROTO_ICMPV6___43 = 58,
    IPPROTO_NONE___43 = 59,
    IPPROTO_DSTOPTS___43 = 60,
    IPPROTO_MH___43 = 135
} ;
enum __anonenum_662268580___43 {
    IPPORT_ECHO___43 = 7,
    IPPORT_DISCARD___43 = 9,
    IPPORT_SYSTAT___43 = 11,
    IPPORT_DAYTIME___43 = 13,
    IPPORT_NETSTAT___43 = 15,
    IPPORT_FTP___43 = 21,
    IPPORT_TELNET___43 = 23,
    IPPORT_SMTP___43 = 25,
    IPPORT_TIMESERVER___43 = 37,
    IPPORT_NAMESERVER___43 = 42,
    IPPORT_WHOIS___43 = 43,
    IPPORT_MTP___43 = 57,
    IPPORT_TFTP___43 = 69,
    IPPORT_RJE___43 = 77,
    IPPORT_FINGER___43 = 79,
    IPPORT_TTYLINK___43 = 87,
    IPPORT_SUPDUP___43 = 95,
    IPPORT_EXECSERVER___43 = 512,
    IPPORT_LOGINSERVER___43 = 513,
    IPPORT_CMDSERVER___43 = 514,
    IPPORT_EFSSERVER___43 = 520,
    IPPORT_BIFFUDP___43 = 512,
    IPPORT_WHOSERVER___43 = 513,
    IPPORT_ROUTESERVER___43 = 520,
    IPPORT_RESERVED___43 = 1024,
    IPPORT_USERRESERVED___43 = 5000
} ;
enum __anonenum_18926444___43 {
    _ISupper___43 = 256,
    _ISlower___43 = 512,
    _ISalpha___43 = 1024,
    _ISdigit___43 = 2048,
    _ISxdigit___43 = 4096,
    _ISspace___43 = 8192,
    _ISprint___43 = 16384,
    _ISgraph___43 = 32768,
    _ISblank___43 = 1,
    _IScntrl___43 = 2,
    _ISpunct___43 = 4,
    _ISalnum___43 = 8
} ;
enum __anonenum_913965969___43 {
    FP_INT_UPWARD___43 = 0,
    FP_INT_DOWNWARD___43 = 1,
    FP_INT_TOWARDZERO___43 = 2,
    FP_INT_TONEARESTFROMZERO___43 = 3,
    FP_INT_TONEAREST___43 = 4
} ;
enum __anonenum_1037408945___43 {
    FP_NAN___43 = 0,
    FP_INFINITE___43 = 1,
    FP_ZERO___43 = 2,
    FP_SUBNORMAL___43 = 3,
    FP_NORMAL___43 = 4
} ;
enum __anonenum_556971655___43 {
    SI_ASYNCNL___43 = -60,
    SI_DETHREAD___43 = -7,
    SI_TKILL___43 = -6,
    SI_SIGIO___43 = -5,
    SI_ASYNCIO___43 = -4,
    SI_MESGQ___43 = -3,
    SI_TIMER___43 = -2,
    SI_QUEUE___43 = -1,
    SI_USER___43 = 0,
    SI_KERNEL___43 = 128
} ;
enum __anonenum_640648963___43 {
    ILL_ILLOPC___43 = 1,
    ILL_ILLOPN___43 = 2,
    ILL_ILLADR___43 = 3,
    ILL_ILLTRP___43 = 4,
    ILL_PRVOPC___43 = 5,
    ILL_PRVREG___43 = 6,
    ILL_COPROC___43 = 7,
    ILL_BADSTK___43 = 8,
    ILL_BADIADDR___43 = 9
} ;
enum __anonenum_457704180___43 {
    FPE_INTDIV___43 = 1,
    FPE_INTOVF___43 = 2,
    FPE_FLTDIV___43 = 3,
    FPE_FLTOVF___43 = 4,
    FPE_FLTUND___43 = 5,
    FPE_FLTRES___43 = 6,
    FPE_FLTINV___43 = 7,
    FPE_FLTSUB___43 = 8,
    FPE_FLTUNK___43 = 14,
    FPE_CONDTRAP___43 = 15
} ;
enum __anonenum_180375148___43 {
    SEGV_MAPERR___43 = 1,
    SEGV_ACCERR___43 = 2,
    SEGV_BNDERR___43 = 3,
    SEGV_PKUERR___43 = 4,
    SEGV_ACCADI___43 = 5,
    SEGV_ADIDERR___43 = 6,
    SEGV_ADIPERR___43 = 7,
    SEGV_MTEAERR___43 = 8,
    SEGV_MTESERR___43 = 9
} ;
enum __anonenum_1036286214___43 {
    BUS_ADRALN___43 = 1,
    BUS_ADRERR___43 = 2,
    BUS_OBJERR___43 = 3,
    BUS_MCEERR_AR___43 = 4,
    BUS_MCEERR_AO___43 = 5
} ;
enum __anonenum_91015150___43 {
    TRAP_BRKPT___43 = 1,
    TRAP_TRACE___43 = 2,
    TRAP_BRANCH___43 = 3,
    TRAP_HWBKPT___43 = 4,
    TRAP_UNK___43 = 5
} ;
enum __anonenum_23175539___43 {
    CLD_EXITED___43 = 1,
    CLD_KILLED___43 = 2,
    CLD_DUMPED___43 = 3,
    CLD_TRAPPED___43 = 4,
    CLD_STOPPED___43 = 5,
    CLD_CONTINUED___43 = 6
} ;
enum __anonenum_111643124___43 {
    POLL_IN___43 = 1,
    POLL_OUT___43 = 2,
    POLL_MSG___43 = 3,
    POLL_ERR___43 = 4,
    POLL_PRI___43 = 5,
    POLL_HUP___43 = 6
} ;
enum __anonenum_852341087___43 {
    SIGEV_SIGNAL___43 = 0,
    SIGEV_NONE___43 = 1,
    SIGEV_THREAD___43 = 2,
    SIGEV_THREAD_ID___43 = 4
} ;
enum __anonenum_451154152___43 {
    REG_R8___43 = 0,
    REG_R9___43 = 1,
    REG_R10___43 = 2,
    REG_R11___43 = 3,
    REG_R12___43 = 4,
    REG_R13___43 = 5,
    REG_R14___43 = 6,
    REG_R15___43 = 7,
    REG_RDI___43 = 8,
    REG_RSI___43 = 9,
    REG_RBP___43 = 10,
    REG_RBX___43 = 11,
    REG_RDX___43 = 12,
    REG_RAX___43 = 13,
    REG_RCX___43 = 14,
    REG_RSP___43 = 15,
    REG_RIP___43 = 16,
    REG_EFL___43 = 17,
    REG_CSGSFS___43 = 18,
    REG_ERR___43 = 19,
    REG_TRAPNO___43 = 20,
    REG_OLDMASK___43 = 21,
    REG_CR2___43 = 22
} ;
enum __anonenum_437032235___43 {
    _PC_LINK_MAX___43 = 0,
    _PC_MAX_CANON___43 = 1,
    _PC_MAX_INPUT___43 = 2,
    _PC_NAME_MAX___43 = 3,
    _PC_PATH_MAX___43 = 4,
    _PC_PIPE_BUF___43 = 5,
    _PC_CHOWN_RESTRICTED___43 = 6,
    _PC_NO_TRUNC___43 = 7,
    _PC_VDISABLE___43 = 8,
    _PC_SYNC_IO___43 = 9,
    _PC_ASYNC_IO___43 = 10,
    _PC_PRIO_IO___43 = 11,
    _PC_SOCK_MAXBUF___43 = 12,
    _PC_FILESIZEBITS___43 = 13,
    _PC_REC_INCR_XFER_SIZE___43 = 14,
    _PC_REC_MAX_XFER_SIZE___43 = 15,
    _PC_REC_MIN_XFER_SIZE___43 = 16,
    _PC_REC_XFER_ALIGN___43 = 17,
    _PC_ALLOC_SIZE_MIN___43 = 18,
    _PC_SYMLINK_MAX___43 = 19,
    _PC_2_SYMLINKS___43 = 20
} ;
enum __anonenum_315186338___43 {
    _SC_ARG_MAX___43 = 0,
    _SC_CHILD_MAX___43 = 1,
    _SC_CLK_TCK___43 = 2,
    _SC_NGROUPS_MAX___43 = 3,
    _SC_OPEN_MAX___43 = 4,
    _SC_STREAM_MAX___43 = 5,
    _SC_TZNAME_MAX___43 = 6,
    _SC_JOB_CONTROL___43 = 7,
    _SC_SAVED_IDS___43 = 8,
    _SC_REALTIME_SIGNALS___43 = 9,
    _SC_PRIORITY_SCHEDULING___43 = 10,
    _SC_TIMERS___43 = 11,
    _SC_ASYNCHRONOUS_IO___43 = 12,
    _SC_PRIORITIZED_IO___43 = 13,
    _SC_SYNCHRONIZED_IO___43 = 14,
    _SC_FSYNC___43 = 15,
    _SC_MAPPED_FILES___43 = 16,
    _SC_MEMLOCK___43 = 17,
    _SC_MEMLOCK_RANGE___43 = 18,
    _SC_MEMORY_PROTECTION___43 = 19,
    _SC_MESSAGE_PASSING___43 = 20,
    _SC_SEMAPHORES___43 = 21,
    _SC_SHARED_MEMORY_OBJECTS___43 = 22,
    _SC_AIO_LISTIO_MAX___43 = 23,
    _SC_AIO_MAX___43 = 24,
    _SC_AIO_PRIO_DELTA_MAX___43 = 25,
    _SC_DELAYTIMER_MAX___43 = 26,
    _SC_MQ_OPEN_MAX___43 = 27,
    _SC_MQ_PRIO_MAX___43 = 28,
    _SC_VERSION___43 = 29,
    _SC_PAGESIZE___43 = 30,
    _SC_RTSIG_MAX___43 = 31,
    _SC_SEM_NSEMS_MAX___43 = 32,
    _SC_SEM_VALUE_MAX___43 = 33,
    _SC_SIGQUEUE_MAX___43 = 34,
    _SC_TIMER_MAX___43 = 35,
    _SC_BC_BASE_MAX___43 = 36,
    _SC_BC_DIM_MAX___43 = 37,
    _SC_BC_SCALE_MAX___43 = 38,
    _SC_BC_STRING_MAX___43 = 39,
    _SC_COLL_WEIGHTS_MAX___43 = 40,
    _SC_EQUIV_CLASS_MAX___43 = 41,
    _SC_EXPR_NEST_MAX___43 = 42,
    _SC_LINE_MAX___43 = 43,
    _SC_RE_DUP_MAX___43 = 44,
    _SC_CHARCLASS_NAME_MAX___43 = 45,
    _SC_2_VERSION___43 = 46,
    _SC_2_C_BIND___43 = 47,
    _SC_2_C_DEV___43 = 48,
    _SC_2_FORT_DEV___43 = 49,
    _SC_2_FORT_RUN___43 = 50,
    _SC_2_SW_DEV___43 = 51,
    _SC_2_LOCALEDEF___43 = 52,
    _SC_PII___43 = 53,
    _SC_PII_XTI___43 = 54,
    _SC_PII_SOCKET___43 = 55,
    _SC_PII_INTERNET___43 = 56,
    _SC_PII_OSI___43 = 57,
    _SC_POLL___43 = 58,
    _SC_SELECT___43 = 59,
    _SC_UIO_MAXIOV___43 = 60,
    _SC_IOV_MAX___43 = 60,
    _SC_PII_INTERNET_STREAM___43 = 61,
    _SC_PII_INTERNET_DGRAM___43 = 62,
    _SC_PII_OSI_COTS___43 = 63,
    _SC_PII_OSI_CLTS___43 = 64,
    _SC_PII_OSI_M___43 = 65,
    _SC_T_IOV_MAX___43 = 66,
    _SC_THREADS___43 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___43 = 68,
    _SC_GETGR_R_SIZE_MAX___43 = 69,
    _SC_GETPW_R_SIZE_MAX___43 = 70,
    _SC_LOGIN_NAME_MAX___43 = 71,
    _SC_TTY_NAME_MAX___43 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___43 = 73,
    _SC_THREAD_KEYS_MAX___43 = 74,
    _SC_THREAD_STACK_MIN___43 = 75,
    _SC_THREAD_THREADS_MAX___43 = 76,
    _SC_THREAD_ATTR_STACKADDR___43 = 77,
    _SC_THREAD_ATTR_STACKSIZE___43 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___43 = 79,
    _SC_THREAD_PRIO_INHERIT___43 = 80,
    _SC_THREAD_PRIO_PROTECT___43 = 81,
    _SC_THREAD_PROCESS_SHARED___43 = 82,
    _SC_NPROCESSORS_CONF___43 = 83,
    _SC_NPROCESSORS_ONLN___43 = 84,
    _SC_PHYS_PAGES___43 = 85,
    _SC_AVPHYS_PAGES___43 = 86,
    _SC_ATEXIT_MAX___43 = 87,
    _SC_PASS_MAX___43 = 88,
    _SC_XOPEN_VERSION___43 = 89,
    _SC_XOPEN_XCU_VERSION___43 = 90,
    _SC_XOPEN_UNIX___43 = 91,
    _SC_XOPEN_CRYPT___43 = 92,
    _SC_XOPEN_ENH_I18N___43 = 93,
    _SC_XOPEN_SHM___43 = 94,
    _SC_2_CHAR_TERM___43 = 95,
    _SC_2_C_VERSION___43 = 96,
    _SC_2_UPE___43 = 97,
    _SC_XOPEN_XPG2___43 = 98,
    _SC_XOPEN_XPG3___43 = 99,
    _SC_XOPEN_XPG4___43 = 100,
    _SC_CHAR_BIT___43 = 101,
    _SC_CHAR_MAX___43 = 102,
    _SC_CHAR_MIN___43 = 103,
    _SC_INT_MAX___43 = 104,
    _SC_INT_MIN___43 = 105,
    _SC_LONG_BIT___43 = 106,
    _SC_WORD_BIT___43 = 107,
    _SC_MB_LEN_MAX___43 = 108,
    _SC_NZERO___43 = 109,
    _SC_SSIZE_MAX___43 = 110,
    _SC_SCHAR_MAX___43 = 111,
    _SC_SCHAR_MIN___43 = 112,
    _SC_SHRT_MAX___43 = 113,
    _SC_SHRT_MIN___43 = 114,
    _SC_UCHAR_MAX___43 = 115,
    _SC_UINT_MAX___43 = 116,
    _SC_ULONG_MAX___43 = 117,
    _SC_USHRT_MAX___43 = 118,
    _SC_NL_ARGMAX___43 = 119,
    _SC_NL_LANGMAX___43 = 120,
    _SC_NL_MSGMAX___43 = 121,
    _SC_NL_NMAX___43 = 122,
    _SC_NL_SETMAX___43 = 123,
    _SC_NL_TEXTMAX___43 = 124,
    _SC_XBS5_ILP32_OFF32___43 = 125,
    _SC_XBS5_ILP32_OFFBIG___43 = 126,
    _SC_XBS5_LP64_OFF64___43 = 127,
    _SC_XBS5_LPBIG_OFFBIG___43 = 128,
    _SC_XOPEN_LEGACY___43 = 129,
    _SC_XOPEN_REALTIME___43 = 130,
    _SC_XOPEN_REALTIME_THREADS___43 = 131,
    _SC_ADVISORY_INFO___43 = 132,
    _SC_BARRIERS___43 = 133,
    _SC_BASE___43 = 134,
    _SC_C_LANG_SUPPORT___43 = 135,
    _SC_C_LANG_SUPPORT_R___43 = 136,
    _SC_CLOCK_SELECTION___43 = 137,
    _SC_CPUTIME___43 = 138,
    _SC_THREAD_CPUTIME___43 = 139,
    _SC_DEVICE_IO___43 = 140,
    _SC_DEVICE_SPECIFIC___43 = 141,
    _SC_DEVICE_SPECIFIC_R___43 = 142,
    _SC_FD_MGMT___43 = 143,
    _SC_FIFO___43 = 144,
    _SC_PIPE___43 = 145,
    _SC_FILE_ATTRIBUTES___43 = 146,
    _SC_FILE_LOCKING___43 = 147,
    _SC_FILE_SYSTEM___43 = 148,
    _SC_MONOTONIC_CLOCK___43 = 149,
    _SC_MULTI_PROCESS___43 = 150,
    _SC_SINGLE_PROCESS___43 = 151,
    _SC_NETWORKING___43 = 152,
    _SC_READER_WRITER_LOCKS___43 = 153,
    _SC_SPIN_LOCKS___43 = 154,
    _SC_REGEXP___43 = 155,
    _SC_REGEX_VERSION___43 = 156,
    _SC_SHELL___43 = 157,
    _SC_SIGNALS___43 = 158,
    _SC_SPAWN___43 = 159,
    _SC_SPORADIC_SERVER___43 = 160,
    _SC_THREAD_SPORADIC_SERVER___43 = 161,
    _SC_SYSTEM_DATABASE___43 = 162,
    _SC_SYSTEM_DATABASE_R___43 = 163,
    _SC_TIMEOUTS___43 = 164,
    _SC_TYPED_MEMORY_OBJECTS___43 = 165,
    _SC_USER_GROUPS___43 = 166,
    _SC_USER_GROUPS_R___43 = 167,
    _SC_2_PBS___43 = 168,
    _SC_2_PBS_ACCOUNTING___43 = 169,
    _SC_2_PBS_LOCATE___43 = 170,
    _SC_2_PBS_MESSAGE___43 = 171,
    _SC_2_PBS_TRACK___43 = 172,
    _SC_SYMLOOP_MAX___43 = 173,
    _SC_STREAMS___43 = 174,
    _SC_2_PBS_CHECKPOINT___43 = 175,
    _SC_V6_ILP32_OFF32___43 = 176,
    _SC_V6_ILP32_OFFBIG___43 = 177,
    _SC_V6_LP64_OFF64___43 = 178,
    _SC_V6_LPBIG_OFFBIG___43 = 179,
    _SC_HOST_NAME_MAX___43 = 180,
    _SC_TRACE___43 = 181,
    _SC_TRACE_EVENT_FILTER___43 = 182,
    _SC_TRACE_INHERIT___43 = 183,
    _SC_TRACE_LOG___43 = 184,
    _SC_LEVEL1_ICACHE_SIZE___43 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___43 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___43 = 187,
    _SC_LEVEL1_DCACHE_SIZE___43 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___43 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___43 = 190,
    _SC_LEVEL2_CACHE_SIZE___43 = 191,
    _SC_LEVEL2_CACHE_ASSOC___43 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___43 = 193,
    _SC_LEVEL3_CACHE_SIZE___43 = 194,
    _SC_LEVEL3_CACHE_ASSOC___43 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___43 = 196,
    _SC_LEVEL4_CACHE_SIZE___43 = 197,
    _SC_LEVEL4_CACHE_ASSOC___43 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___43 = 199,
    _SC_IPV6___43 = 235,
    _SC_RAW_SOCKETS___43 = 236,
    _SC_V7_ILP32_OFF32___43 = 237,
    _SC_V7_ILP32_OFFBIG___43 = 238,
    _SC_V7_LP64_OFF64___43 = 239,
    _SC_V7_LPBIG_OFFBIG___43 = 240,
    _SC_SS_REPL_MAX___43 = 241,
    _SC_TRACE_EVENT_NAME_MAX___43 = 242,
    _SC_TRACE_NAME_MAX___43 = 243,
    _SC_TRACE_SYS_MAX___43 = 244,
    _SC_TRACE_USER_EVENT_MAX___43 = 245,
    _SC_XOPEN_STREAMS___43 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___43 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___43 = 248,
    _SC_MINSIGSTKSZ___43 = 249,
    _SC_SIGSTKSZ___43 = 250
} ;
enum __anonenum_875524036___43 {
    _CS_PATH___43 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___43 = 1,
    _CS_GNU_LIBC_VERSION___43 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___43 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___43 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___43 = 5,
    _CS_LFS_CFLAGS___43 = 1000,
    _CS_LFS_LDFLAGS___43 = 1001,
    _CS_LFS_LIBS___43 = 1002,
    _CS_LFS_LINTFLAGS___43 = 1003,
    _CS_LFS64_CFLAGS___43 = 1004,
    _CS_LFS64_LDFLAGS___43 = 1005,
    _CS_LFS64_LIBS___43 = 1006,
    _CS_LFS64_LINTFLAGS___43 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___43 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___43 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___43 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___43 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___43 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___43 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___43 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___43 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___43 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___43 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___43 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___43 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___43 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___43 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___43 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___43 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___43 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___43 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___43 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___43 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___43 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___43 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___43 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___43 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___43 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___43 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___43 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___43 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___43 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___43 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___43 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___43 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___43 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___43 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___43 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___43 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___43 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___43 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___43 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___43 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___43 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___43 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___43 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___43 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___43 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___43 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___43 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___43 = 1147,
    _CS_V6_ENV___43 = 1148,
    _CS_V7_ENV___43 = 1149
} ;
enum __anonenum_57186863___43 {
    SS_ONSTACK___43 = 1,
    SS_DISABLE___43 = 2
} ;
union __anonunion_ifa_ifu_671959538 {
   struct sockaddr *ifu_broadaddr ;
   struct sockaddr *ifu_dstaddr ;
};
struct ifaddrs {
   struct ifaddrs *ifa_next ;
   char *ifa_name ;
   unsigned int ifa_flags ;
   struct sockaddr *ifa_addr ;
   struct sockaddr *ifa_netmask ;
   union __anonunion_ifa_ifu_671959538 ifa_ifu ;
   void *ifa_data ;
};
struct ethhdr {
   unsigned char h_dest[6] ;
   unsigned char h_source[6] ;
   __be16 h_proto ;
} __attribute__((__packed__)) ;
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2] ;
};
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32] ;
   char version[32] ;
   char fw_version[32] ;
   char bus_info[32] ;
   char erom_version[32] ;
   char reserved2[12] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6] ;
};
struct ethtool_value {
   __u32 cmd ;
   __u32 data ;
};
enum tunable_id {
    ETHTOOL_ID_UNSPEC = 0,
    ETHTOOL_RX_COPYBREAK = 1,
    ETHTOOL_TX_COPYBREAK = 2,
    ETHTOOL_PFC_PREVENTION_TOUT = 3,
    __ETHTOOL_TUNABLE_COUNT = 4
} ;
enum tunable_type_id {
    ETHTOOL_TUNABLE_UNSPEC = 0,
    ETHTOOL_TUNABLE_U8 = 1,
    ETHTOOL_TUNABLE_U16 = 2,
    ETHTOOL_TUNABLE_U32 = 3,
    ETHTOOL_TUNABLE_U64 = 4,
    ETHTOOL_TUNABLE_STRING = 5,
    ETHTOOL_TUNABLE_S8 = 6,
    ETHTOOL_TUNABLE_S16 = 7,
    ETHTOOL_TUNABLE_S32 = 8,
    ETHTOOL_TUNABLE_S64 = 9
} ;
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0] ;
};
enum phy_tunable_id {
    ETHTOOL_PHY_ID_UNSPEC = 0,
    ETHTOOL_PHY_DOWNSHIFT = 1,
    ETHTOOL_PHY_FAST_LINK_DOWN = 2,
    ETHTOOL_PHY_EDPD = 3,
    __ETHTOOL_PHY_TUNABLE_COUNT = 4
} ;
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0] ;
};
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0] ;
};
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2] ;
};
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8] ;
};
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
enum ethtool_link_ext_state {
    ETHTOOL_LINK_EXT_STATE_AUTONEG = 0,
    ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE = 1,
    ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH = 2,
    ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY = 3,
    ETHTOOL_LINK_EXT_STATE_NO_CABLE = 4,
    ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE = 5,
    ETHTOOL_LINK_EXT_STATE_EEPROM_ISSUE = 6,
    ETHTOOL_LINK_EXT_STATE_CALIBRATION_FAILURE = 7,
    ETHTOOL_LINK_EXT_STATE_POWER_BUDGET_EXCEEDED = 8,
    ETHTOOL_LINK_EXT_STATE_OVERHEAT = 9
} ;
enum ethtool_link_ext_substate_autoneg {
    ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED = 1,
    ETHTOOL_LINK_EXT_SUBSTATE_AN_ACK_NOT_RECEIVED = 2,
    ETHTOOL_LINK_EXT_SUBSTATE_AN_NEXT_PAGE_EXCHANGE_FAILED = 3,
    ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED_FORCE_MODE = 4,
    ETHTOOL_LINK_EXT_SUBSTATE_AN_FEC_MISMATCH_DURING_OVERRIDE = 5,
    ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_HCD = 6
} ;
enum ethtool_link_ext_substate_link_training {
    ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_FRAME_LOCK_NOT_ACQUIRED = 1,
    ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_INHIBIT_TIMEOUT = 2,
    ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_PARTNER_DID_NOT_SET_RECEIVER_READY = 3,
    ETHTOOL_LINK_EXT_SUBSTATE_LT_REMOTE_FAULT = 4
} ;
enum ethtool_link_ext_substate_link_logical_mismatch {
    ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_BLOCK_LOCK = 1,
    ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_AM_LOCK = 2,
    ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_GET_ALIGN_STATUS = 3,
    ETHTOOL_LINK_EXT_SUBSTATE_LLM_FC_FEC_IS_NOT_LOCKED = 4,
    ETHTOOL_LINK_EXT_SUBSTATE_LLM_RS_FEC_IS_NOT_LOCKED = 5
} ;
enum ethtool_link_ext_substate_bad_signal_integrity {
    ETHTOOL_LINK_EXT_SUBSTATE_BSI_LARGE_NUMBER_OF_PHYSICAL_ERRORS = 1,
    ETHTOOL_LINK_EXT_SUBSTATE_BSI_UNSUPPORTED_RATE = 2,
    ETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_REFERENCE_CLOCK_LOST = 3,
    ETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_ALOS = 4
} ;
enum ethtool_link_ext_substate_cable_issue {
    ETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE = 1,
    ETHTOOL_LINK_EXT_SUBSTATE_CI_CABLE_TEST_FAILURE = 2
} ;
enum ethtool_stringset {
    ETH_SS_TEST = 0,
    ETH_SS_STATS = 1,
    ETH_SS_PRIV_FLAGS = 2,
    ETH_SS_NTUPLE_FILTERS = 3,
    ETH_SS_FEATURES = 4,
    ETH_SS_RSS_HASH_FUNCS = 5,
    ETH_SS_TUNABLES = 6,
    ETH_SS_PHY_STATS = 7,
    ETH_SS_PHY_TUNABLES = 8,
    ETH_SS_LINK_MODES = 9,
    ETH_SS_MSG_CLASSES = 10,
    ETH_SS_WOL_MODES = 11,
    ETH_SS_SOF_TIMESTAMPING = 12,
    ETH_SS_TS_TX_TYPES = 13,
    ETH_SS_TS_RX_FILTERS = 14,
    ETH_SS_UDP_TUNNEL_TYPES = 15,
    ETH_SS_STATS_STD = 16,
    ETH_SS_STATS_ETH_PHY = 17,
    ETH_SS_STATS_ETH_MAC = 18,
    ETH_SS_STATS_ETH_CTRL = 19,
    ETH_SS_STATS_RMON = 20,
    ETH_SS_COUNT = 21
} ;
struct ethtool_gstrings {
   __u32 cmd ;
   __u32 string_set ;
   __u32 len ;
   __u8 data[0] ;
};
struct ethtool_sset_info {
   __u32 cmd ;
   __u32 reserved ;
   __u64 sset_mask ;
   __u32 data[0] ;
};
enum ethtool_test_flags {
    ETH_TEST_FL_OFFLINE = 1,
    ETH_TEST_FL_FAILED = 2,
    ETH_TEST_FL_EXTERNAL_LB = 4,
    ETH_TEST_FL_EXTERNAL_LB_DONE = 8
} ;
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0] ;
};
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0] ;
};
struct ethtool_perm_addr {
   __u32 cmd ;
   __u32 size ;
   __u8 data[0] ;
};
enum ethtool_flags {
    ETH_FLAG_TXVLAN = 128,
    ETH_FLAG_RXVLAN = 256,
    ETH_FLAG_LRO = 32768,
    ETH_FLAG_NTUPLE = 134217728,
    ETH_FLAG_RXHASH = 268435456
} ;
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
struct ethtool_tcpip6_spec {
   __be32 ip6src[4] ;
   __be32 ip6dst[4] ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tclass ;
};
struct ethtool_ah_espip6_spec {
   __be32 ip6src[4] ;
   __be32 ip6dst[4] ;
   __be32 spi ;
   __u8 tclass ;
};
struct ethtool_usrip6_spec {
   __be32 ip6src[4] ;
   __be32 ip6dst[4] ;
   __be32 l4_4_bytes ;
   __u8 tclass ;
   __u8 l4_proto ;
};
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethtool_tcpip6_spec tcp_ip6_spec ;
   struct ethtool_tcpip6_spec udp_ip6_spec ;
   struct ethtool_tcpip6_spec sctp_ip6_spec ;
   struct ethtool_ah_espip6_spec ah_ip6_spec ;
   struct ethtool_ah_espip6_spec esp_ip6_spec ;
   struct ethtool_usrip6_spec usr_ip6_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52] ;
};
struct ethtool_flow_ext {
   __u8 padding[2] ;
   unsigned char h_dest[6] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2] ;
};
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
union __anonunion____missing_field_name_529336938 {
   __u32 rule_cnt ;
   __u32 rss_context ;
};
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   union __anonunion____missing_field_name_529336938 __annonCompField2 ;
   __u32 rule_locs[0] ;
};
struct ethtool_rxfh_indir {
   __u32 cmd ;
   __u32 size ;
   __u32 ring_index[0] ;
};
struct ethtool_rxfh {
   __u32 cmd ;
   __u32 rss_context ;
   __u32 indir_size ;
   __u32 key_size ;
   __u8 hfunc ;
   __u8 rsvd8[3] ;
   __u32 rsvd32 ;
   __u32 rss_config[0] ;
};
union __anonunion_h_u_504103738 {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[72] ;
};
struct ethtool_rx_ntuple_flow_spec {
   __u32 flow_type ;
   union __anonunion_h_u_504103738 h_u ;
   union __anonunion_h_u_504103738 m_u ;
   __u16 vlan_tag ;
   __u16 vlan_tag_mask ;
   __u64 data ;
   __u64 data_mask ;
   __s32 action ;
};
struct ethtool_rx_ntuple {
   __u32 cmd ;
   struct ethtool_rx_ntuple_flow_spec fs ;
};
enum ethtool_flash_op_type {
    ETHTOOL_FLASH_ALL_REGIONS = 0
} ;
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128] ;
};
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0] ;
};
struct ethtool_get_features_block {
   __u32 available ;
   __u32 requested ;
   __u32 active ;
   __u32 never_changed ;
};
struct ethtool_gfeatures {
   __u32 cmd ;
   __u32 size ;
   struct ethtool_get_features_block features[0] ;
};
struct ethtool_set_features_block {
   __u32 valid ;
   __u32 requested ;
};
struct ethtool_sfeatures {
   __u32 cmd ;
   __u32 size ;
   struct ethtool_set_features_block features[0] ;
};
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3] ;
};
enum ethtool_sfeatures_retval_bits {
    ETHTOOL_F_UNSUPPORTED__BIT = 0,
    ETHTOOL_F_WISH__BIT = 1,
    ETHTOOL_F_COMPAT__BIT = 2
} ;
struct ethtool_per_queue_op {
   __u32 cmd ;
   __u32 sub_command ;
   __u32 queue_mask[128] ;
   char data[] ;
};
struct ethtool_fecparam {
   __u32 cmd ;
   __u32 active_fec ;
   __u32 fec ;
   __u32 reserved ;
};
enum ethtool_fec_config_bits {
    ETHTOOL_FEC_NONE_BIT = 0,
    ETHTOOL_FEC_AUTO_BIT = 1,
    ETHTOOL_FEC_OFF_BIT = 2,
    ETHTOOL_FEC_RS_BIT = 3,
    ETHTOOL_FEC_BASER_BIT = 4,
    ETHTOOL_FEC_LLRS_BIT = 5
} ;
enum ethtool_link_mode_bit_indices {
    ETHTOOL_LINK_MODE_10baseT_Half_BIT = 0,
    ETHTOOL_LINK_MODE_10baseT_Full_BIT = 1,
    ETHTOOL_LINK_MODE_100baseT_Half_BIT = 2,
    ETHTOOL_LINK_MODE_100baseT_Full_BIT = 3,
    ETHTOOL_LINK_MODE_1000baseT_Half_BIT = 4,
    ETHTOOL_LINK_MODE_1000baseT_Full_BIT = 5,
    ETHTOOL_LINK_MODE_Autoneg_BIT = 6,
    ETHTOOL_LINK_MODE_TP_BIT = 7,
    ETHTOOL_LINK_MODE_AUI_BIT = 8,
    ETHTOOL_LINK_MODE_MII_BIT = 9,
    ETHTOOL_LINK_MODE_FIBRE_BIT = 10,
    ETHTOOL_LINK_MODE_BNC_BIT = 11,
    ETHTOOL_LINK_MODE_10000baseT_Full_BIT = 12,
    ETHTOOL_LINK_MODE_Pause_BIT = 13,
    ETHTOOL_LINK_MODE_Asym_Pause_BIT = 14,
    ETHTOOL_LINK_MODE_2500baseX_Full_BIT = 15,
    ETHTOOL_LINK_MODE_Backplane_BIT = 16,
    ETHTOOL_LINK_MODE_1000baseKX_Full_BIT = 17,
    ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT = 18,
    ETHTOOL_LINK_MODE_10000baseKR_Full_BIT = 19,
    ETHTOOL_LINK_MODE_10000baseR_FEC_BIT = 20,
    ETHTOOL_LINK_MODE_20000baseMLD2_Full_BIT = 21,
    ETHTOOL_LINK_MODE_20000baseKR2_Full_BIT = 22,
    ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT = 23,
    ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT = 24,
    ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT = 25,
    ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT = 26,
    ETHTOOL_LINK_MODE_56000baseKR4_Full_BIT = 27,
    ETHTOOL_LINK_MODE_56000baseCR4_Full_BIT = 28,
    ETHTOOL_LINK_MODE_56000baseSR4_Full_BIT = 29,
    ETHTOOL_LINK_MODE_56000baseLR4_Full_BIT = 30,
    ETHTOOL_LINK_MODE_25000baseCR_Full_BIT = 31,
    ETHTOOL_LINK_MODE_25000baseKR_Full_BIT = 32,
    ETHTOOL_LINK_MODE_25000baseSR_Full_BIT = 33,
    ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT = 34,
    ETHTOOL_LINK_MODE_50000baseKR2_Full_BIT = 35,
    ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT = 36,
    ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT = 37,
    ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT = 38,
    ETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT = 39,
    ETHTOOL_LINK_MODE_50000baseSR2_Full_BIT = 40,
    ETHTOOL_LINK_MODE_1000baseX_Full_BIT = 41,
    ETHTOOL_LINK_MODE_10000baseCR_Full_BIT = 42,
    ETHTOOL_LINK_MODE_10000baseSR_Full_BIT = 43,
    ETHTOOL_LINK_MODE_10000baseLR_Full_BIT = 44,
    ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT = 45,
    ETHTOOL_LINK_MODE_10000baseER_Full_BIT = 46,
    ETHTOOL_LINK_MODE_2500baseT_Full_BIT = 47,
    ETHTOOL_LINK_MODE_5000baseT_Full_BIT = 48,
    ETHTOOL_LINK_MODE_FEC_NONE_BIT = 49,
    ETHTOOL_LINK_MODE_FEC_RS_BIT = 50,
    ETHTOOL_LINK_MODE_FEC_BASER_BIT = 51,
    ETHTOOL_LINK_MODE_50000baseKR_Full_BIT = 52,
    ETHTOOL_LINK_MODE_50000baseSR_Full_BIT = 53,
    ETHTOOL_LINK_MODE_50000baseCR_Full_BIT = 54,
    ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT = 55,
    ETHTOOL_LINK_MODE_50000baseDR_Full_BIT = 56,
    ETHTOOL_LINK_MODE_100000baseKR2_Full_BIT = 57,
    ETHTOOL_LINK_MODE_100000baseSR2_Full_BIT = 58,
    ETHTOOL_LINK_MODE_100000baseCR2_Full_BIT = 59,
    ETHTOOL_LINK_MODE_100000baseLR2_ER2_FR2_Full_BIT = 60,
    ETHTOOL_LINK_MODE_100000baseDR2_Full_BIT = 61,
    ETHTOOL_LINK_MODE_200000baseKR4_Full_BIT = 62,
    ETHTOOL_LINK_MODE_200000baseSR4_Full_BIT = 63,
    ETHTOOL_LINK_MODE_200000baseLR4_ER4_FR4_Full_BIT = 64,
    ETHTOOL_LINK_MODE_200000baseDR4_Full_BIT = 65,
    ETHTOOL_LINK_MODE_200000baseCR4_Full_BIT = 66,
    ETHTOOL_LINK_MODE_100baseT1_Full_BIT = 67,
    ETHTOOL_LINK_MODE_1000baseT1_Full_BIT = 68,
    ETHTOOL_LINK_MODE_400000baseKR8_Full_BIT = 69,
    ETHTOOL_LINK_MODE_400000baseSR8_Full_BIT = 70,
    ETHTOOL_LINK_MODE_400000baseLR8_ER8_FR8_Full_BIT = 71,
    ETHTOOL_LINK_MODE_400000baseDR8_Full_BIT = 72,
    ETHTOOL_LINK_MODE_400000baseCR8_Full_BIT = 73,
    ETHTOOL_LINK_MODE_FEC_LLRS_BIT = 74,
    ETHTOOL_LINK_MODE_100000baseKR_Full_BIT = 75,
    ETHTOOL_LINK_MODE_100000baseSR_Full_BIT = 76,
    ETHTOOL_LINK_MODE_100000baseLR_ER_FR_Full_BIT = 77,
    ETHTOOL_LINK_MODE_100000baseCR_Full_BIT = 78,
    ETHTOOL_LINK_MODE_100000baseDR_Full_BIT = 79,
    ETHTOOL_LINK_MODE_200000baseKR2_Full_BIT = 80,
    ETHTOOL_LINK_MODE_200000baseSR2_Full_BIT = 81,
    ETHTOOL_LINK_MODE_200000baseLR2_ER2_FR2_Full_BIT = 82,
    ETHTOOL_LINK_MODE_200000baseDR2_Full_BIT = 83,
    ETHTOOL_LINK_MODE_200000baseCR2_Full_BIT = 84,
    ETHTOOL_LINK_MODE_400000baseKR4_Full_BIT = 85,
    ETHTOOL_LINK_MODE_400000baseSR4_Full_BIT = 86,
    ETHTOOL_LINK_MODE_400000baseLR4_ER4_FR4_Full_BIT = 87,
    ETHTOOL_LINK_MODE_400000baseDR4_Full_BIT = 88,
    ETHTOOL_LINK_MODE_400000baseCR4_Full_BIT = 89,
    ETHTOOL_LINK_MODE_100baseFX_Half_BIT = 90,
    ETHTOOL_LINK_MODE_100baseFX_Full_BIT = 91,
    __ETHTOOL_LINK_MODE_MASK_NBITS = 92
} ;
enum ethtool_reset_flags {
    ETH_RESET_MGMT = 1,
    ETH_RESET_IRQ = 2,
    ETH_RESET_DMA = 4,
    ETH_RESET_FILTER = 8,
    ETH_RESET_OFFLOAD = 16,
    ETH_RESET_MAC = 32,
    ETH_RESET_PHY = 64,
    ETH_RESET_RAM = 128,
    ETH_RESET_AP = 256,
    ETH_RESET_DEDICATED = 65535,
    ETH_RESET_ALL = 4294967295U
} ;
struct ethtool_link_settings {
   __u32 cmd ;
   __u32 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __s8 link_mode_masks_nwords ;
   __u8 transceiver ;
   __u8 master_slave_cfg ;
   __u8 master_slave_state ;
   __u8 reserved1[1] ;
   __u32 reserved[7] ;
   __u32 link_mode_masks[0] ;
};
enum __anonenum_363867873___0 {
    SOF_TIMESTAMPING_TX_HARDWARE___0 = 1,
    SOF_TIMESTAMPING_TX_SOFTWARE___0 = 2,
    SOF_TIMESTAMPING_RX_HARDWARE___0 = 4,
    SOF_TIMESTAMPING_RX_SOFTWARE___0 = 8,
    SOF_TIMESTAMPING_SOFTWARE___0 = 16,
    SOF_TIMESTAMPING_SYS_HARDWARE___0 = 32,
    SOF_TIMESTAMPING_RAW_HARDWARE___0 = 64,
    SOF_TIMESTAMPING_OPT_ID___0 = 128,
    SOF_TIMESTAMPING_TX_SCHED___0 = 256,
    SOF_TIMESTAMPING_TX_ACK___0 = 512,
    SOF_TIMESTAMPING_OPT_CMSG___0 = 1024,
    SOF_TIMESTAMPING_OPT_TSONLY___0 = 2048,
    SOF_TIMESTAMPING_OPT_STATS___0 = 4096,
    SOF_TIMESTAMPING_OPT_PKTINFO___0 = 8192,
    SOF_TIMESTAMPING_OPT_TX_SWHW___0 = 16384,
    SOF_TIMESTAMPING_BIND_PHC___0 = 32768,
    SOF_TIMESTAMPING_LAST___0 = 32768,
    SOF_TIMESTAMPING_MASK___0 = 65535
} ;
struct if_nameindex {
   unsigned int if_index ;
   char *if_name ;
};
enum __anonenum_673048160 {
    IFF_UP = 1,
    IFF_BROADCAST = 2,
    IFF_DEBUG = 4,
    IFF_LOOPBACK = 8,
    IFF_POINTOPOINT = 16,
    IFF_NOTRAILERS = 32,
    IFF_RUNNING = 64,
    IFF_NOARP = 128,
    IFF_PROMISC = 256,
    IFF_ALLMULTI = 512,
    IFF_MASTER = 1024,
    IFF_SLAVE = 2048,
    IFF_MULTICAST = 4096,
    IFF_PORTSEL = 8192,
    IFF_AUTOMEDIA = 16384,
    IFF_DYNAMIC = 32768
} ;
union __anonunion_ifa_ifu_673048161 {
   struct sockaddr ifu_broadaddr ;
   struct sockaddr ifu_dstaddr ;
};
struct iface ;
struct ifaddr {
   struct sockaddr ifa_addr ;
   union __anonunion_ifa_ifu_673048161 ifa_ifu ;
   struct iface *ifa_ifp ;
   struct ifaddr *ifa_next ;
};
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
union __anonunion_ifr_ifrn_352126815 {
   char ifrn_name[16] ;
};
union __anonunion_ifr_ifru_537349870 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
struct ifreq {
   union __anonunion_ifr_ifrn_352126815 ifr_ifrn ;
   union __anonunion_ifr_ifru_537349870 ifr_ifru ;
};
union __anonunion_ifc_ifcu_753034691 {
   __caddr_t ifcu_buf ;
   struct ifreq *ifcu_req ;
};
struct ifconf {
   int ifc_len ;
   union __anonunion_ifc_ifcu_753034691 ifc_ifcu ;
};
struct Interface {
   char name[16] ;
   int if_index ;
   int phc_fd ;
   int phc_mode ;
   int phc_nocrossts ;
   int link_speed ;
   int l2_udp4_ntp_start ;
   int l2_udp6_ntp_start ;
   double precision ;
   double tx_comp ;
   double rx_comp ;
   HCL_Instance clock ;
};
enum __anonenum_83571709___44 {
    MSG_OOB___44 = 1,
    MSG_PEEK___44 = 2,
    MSG_DONTROUTE___44 = 4,
    MSG_TRYHARD___44 = 4,
    MSG_CTRUNC___44 = 8,
    MSG_PROXY___44 = 16,
    MSG_TRUNC___44 = 32,
    MSG_DONTWAIT___44 = 64,
    MSG_EOR___44 = 128,
    MSG_WAITALL___44 = 256,
    MSG_FIN___44 = 512,
    MSG_SYN___44 = 1024,
    MSG_CONFIRM___44 = 2048,
    MSG_RST___44 = 4096,
    MSG_ERRQUEUE___44 = 8192,
    MSG_NOSIGNAL___44 = 16384,
    MSG_MORE___44 = 32768,
    MSG_WAITFORONE___44 = 65536,
    MSG_BATCH___44 = 262144,
    MSG_ZEROCOPY___44 = 67108864,
    MSG_FASTOPEN___44 = 536870912,
    MSG_CMSG_CLOEXEC___44 = 1073741824
} ;
enum __anonenum_617082774___44 {
    SCM_RIGHTS___44 = 1,
    SCM_CREDENTIALS___44 = 2
} ;
enum __anonenum_606441560___44 {
    SHUT_RD___44 = 0,
    SHUT_WR___44 = 1,
    SHUT_RDWR___44 = 2
} ;
enum __anonenum_264779956___44 {
    IPPROTO_IP___44 = 0,
    IPPROTO_ICMP___44 = 1,
    IPPROTO_IGMP___44 = 2,
    IPPROTO_IPIP___44 = 4,
    IPPROTO_TCP___44 = 6,
    IPPROTO_EGP___44 = 8,
    IPPROTO_PUP___44 = 12,
    IPPROTO_UDP___44 = 17,
    IPPROTO_IDP___44 = 22,
    IPPROTO_TP___44 = 29,
    IPPROTO_DCCP___44 = 33,
    IPPROTO_IPV6___44 = 41,
    IPPROTO_RSVP___44 = 46,
    IPPROTO_GRE___44 = 47,
    IPPROTO_ESP___44 = 50,
    IPPROTO_AH___44 = 51,
    IPPROTO_MTP___44 = 92,
    IPPROTO_BEETPH___44 = 94,
    IPPROTO_ENCAP___44 = 98,
    IPPROTO_PIM___44 = 103,
    IPPROTO_COMP___44 = 108,
    IPPROTO_SCTP___44 = 132,
    IPPROTO_UDPLITE___44 = 136,
    IPPROTO_MPLS___44 = 137,
    IPPROTO_ETHERNET___44 = 143,
    IPPROTO_RAW___44 = 255,
    IPPROTO_MPTCP___44 = 262,
    IPPROTO_MAX___44 = 263
} ;
enum __anonenum_218739988___44 {
    IPPROTO_HOPOPTS___44 = 0,
    IPPROTO_ROUTING___44 = 43,
    IPPROTO_FRAGMENT___44 = 44,
    IPPROTO_ICMPV6___44 = 58,
    IPPROTO_NONE___44 = 59,
    IPPROTO_DSTOPTS___44 = 60,
    IPPROTO_MH___44 = 135
} ;
enum __anonenum_662268580___44 {
    IPPORT_ECHO___44 = 7,
    IPPORT_DISCARD___44 = 9,
    IPPORT_SYSTAT___44 = 11,
    IPPORT_DAYTIME___44 = 13,
    IPPORT_NETSTAT___44 = 15,
    IPPORT_FTP___44 = 21,
    IPPORT_TELNET___44 = 23,
    IPPORT_SMTP___44 = 25,
    IPPORT_TIMESERVER___44 = 37,
    IPPORT_NAMESERVER___44 = 42,
    IPPORT_WHOIS___44 = 43,
    IPPORT_MTP___44 = 57,
    IPPORT_TFTP___44 = 69,
    IPPORT_RJE___44 = 77,
    IPPORT_FINGER___44 = 79,
    IPPORT_TTYLINK___44 = 87,
    IPPORT_SUPDUP___44 = 95,
    IPPORT_EXECSERVER___44 = 512,
    IPPORT_LOGINSERVER___44 = 513,
    IPPORT_CMDSERVER___44 = 514,
    IPPORT_EFSSERVER___44 = 520,
    IPPORT_BIFFUDP___44 = 512,
    IPPORT_WHOSERVER___44 = 513,
    IPPORT_ROUTESERVER___44 = 520,
    IPPORT_RESERVED___44 = 1024,
    IPPORT_USERRESERVED___44 = 5000
} ;
enum __anonenum_18926444___44 {
    _ISupper___44 = 256,
    _ISlower___44 = 512,
    _ISalpha___44 = 1024,
    _ISdigit___44 = 2048,
    _ISxdigit___44 = 4096,
    _ISspace___44 = 8192,
    _ISprint___44 = 16384,
    _ISgraph___44 = 32768,
    _ISblank___44 = 1,
    _IScntrl___44 = 2,
    _ISpunct___44 = 4,
    _ISalnum___44 = 8
} ;
enum __anonenum_913965969___44 {
    FP_INT_UPWARD___44 = 0,
    FP_INT_DOWNWARD___44 = 1,
    FP_INT_TOWARDZERO___44 = 2,
    FP_INT_TONEARESTFROMZERO___44 = 3,
    FP_INT_TONEAREST___44 = 4
} ;
enum __anonenum_1037408945___44 {
    FP_NAN___44 = 0,
    FP_INFINITE___44 = 1,
    FP_ZERO___44 = 2,
    FP_SUBNORMAL___44 = 3,
    FP_NORMAL___44 = 4
} ;
enum __anonenum_556971655___44 {
    SI_ASYNCNL___44 = -60,
    SI_DETHREAD___44 = -7,
    SI_TKILL___44 = -6,
    SI_SIGIO___44 = -5,
    SI_ASYNCIO___44 = -4,
    SI_MESGQ___44 = -3,
    SI_TIMER___44 = -2,
    SI_QUEUE___44 = -1,
    SI_USER___44 = 0,
    SI_KERNEL___44 = 128
} ;
enum __anonenum_640648963___44 {
    ILL_ILLOPC___44 = 1,
    ILL_ILLOPN___44 = 2,
    ILL_ILLADR___44 = 3,
    ILL_ILLTRP___44 = 4,
    ILL_PRVOPC___44 = 5,
    ILL_PRVREG___44 = 6,
    ILL_COPROC___44 = 7,
    ILL_BADSTK___44 = 8,
    ILL_BADIADDR___44 = 9
} ;
enum __anonenum_457704180___44 {
    FPE_INTDIV___44 = 1,
    FPE_INTOVF___44 = 2,
    FPE_FLTDIV___44 = 3,
    FPE_FLTOVF___44 = 4,
    FPE_FLTUND___44 = 5,
    FPE_FLTRES___44 = 6,
    FPE_FLTINV___44 = 7,
    FPE_FLTSUB___44 = 8,
    FPE_FLTUNK___44 = 14,
    FPE_CONDTRAP___44 = 15
} ;
enum __anonenum_180375148___44 {
    SEGV_MAPERR___44 = 1,
    SEGV_ACCERR___44 = 2,
    SEGV_BNDERR___44 = 3,
    SEGV_PKUERR___44 = 4,
    SEGV_ACCADI___44 = 5,
    SEGV_ADIDERR___44 = 6,
    SEGV_ADIPERR___44 = 7,
    SEGV_MTEAERR___44 = 8,
    SEGV_MTESERR___44 = 9
} ;
enum __anonenum_1036286214___44 {
    BUS_ADRALN___44 = 1,
    BUS_ADRERR___44 = 2,
    BUS_OBJERR___44 = 3,
    BUS_MCEERR_AR___44 = 4,
    BUS_MCEERR_AO___44 = 5
} ;
enum __anonenum_91015150___44 {
    TRAP_BRKPT___44 = 1,
    TRAP_TRACE___44 = 2,
    TRAP_BRANCH___44 = 3,
    TRAP_HWBKPT___44 = 4,
    TRAP_UNK___44 = 5
} ;
enum __anonenum_23175539___44 {
    CLD_EXITED___44 = 1,
    CLD_KILLED___44 = 2,
    CLD_DUMPED___44 = 3,
    CLD_TRAPPED___44 = 4,
    CLD_STOPPED___44 = 5,
    CLD_CONTINUED___44 = 6
} ;
enum __anonenum_111643124___44 {
    POLL_IN___44 = 1,
    POLL_OUT___44 = 2,
    POLL_MSG___44 = 3,
    POLL_ERR___44 = 4,
    POLL_PRI___44 = 5,
    POLL_HUP___44 = 6
} ;
enum __anonenum_852341087___44 {
    SIGEV_SIGNAL___44 = 0,
    SIGEV_NONE___44 = 1,
    SIGEV_THREAD___44 = 2,
    SIGEV_THREAD_ID___44 = 4
} ;
enum __anonenum_451154152___44 {
    REG_R8___44 = 0,
    REG_R9___44 = 1,
    REG_R10___44 = 2,
    REG_R11___44 = 3,
    REG_R12___44 = 4,
    REG_R13___44 = 5,
    REG_R14___44 = 6,
    REG_R15___44 = 7,
    REG_RDI___44 = 8,
    REG_RSI___44 = 9,
    REG_RBP___44 = 10,
    REG_RBX___44 = 11,
    REG_RDX___44 = 12,
    REG_RAX___44 = 13,
    REG_RCX___44 = 14,
    REG_RSP___44 = 15,
    REG_RIP___44 = 16,
    REG_EFL___44 = 17,
    REG_CSGSFS___44 = 18,
    REG_ERR___44 = 19,
    REG_TRAPNO___44 = 20,
    REG_OLDMASK___44 = 21,
    REG_CR2___44 = 22
} ;
enum __anonenum_437032235___44 {
    _PC_LINK_MAX___44 = 0,
    _PC_MAX_CANON___44 = 1,
    _PC_MAX_INPUT___44 = 2,
    _PC_NAME_MAX___44 = 3,
    _PC_PATH_MAX___44 = 4,
    _PC_PIPE_BUF___44 = 5,
    _PC_CHOWN_RESTRICTED___44 = 6,
    _PC_NO_TRUNC___44 = 7,
    _PC_VDISABLE___44 = 8,
    _PC_SYNC_IO___44 = 9,
    _PC_ASYNC_IO___44 = 10,
    _PC_PRIO_IO___44 = 11,
    _PC_SOCK_MAXBUF___44 = 12,
    _PC_FILESIZEBITS___44 = 13,
    _PC_REC_INCR_XFER_SIZE___44 = 14,
    _PC_REC_MAX_XFER_SIZE___44 = 15,
    _PC_REC_MIN_XFER_SIZE___44 = 16,
    _PC_REC_XFER_ALIGN___44 = 17,
    _PC_ALLOC_SIZE_MIN___44 = 18,
    _PC_SYMLINK_MAX___44 = 19,
    _PC_2_SYMLINKS___44 = 20
} ;
enum __anonenum_315186338___44 {
    _SC_ARG_MAX___44 = 0,
    _SC_CHILD_MAX___44 = 1,
    _SC_CLK_TCK___44 = 2,
    _SC_NGROUPS_MAX___44 = 3,
    _SC_OPEN_MAX___44 = 4,
    _SC_STREAM_MAX___44 = 5,
    _SC_TZNAME_MAX___44 = 6,
    _SC_JOB_CONTROL___44 = 7,
    _SC_SAVED_IDS___44 = 8,
    _SC_REALTIME_SIGNALS___44 = 9,
    _SC_PRIORITY_SCHEDULING___44 = 10,
    _SC_TIMERS___44 = 11,
    _SC_ASYNCHRONOUS_IO___44 = 12,
    _SC_PRIORITIZED_IO___44 = 13,
    _SC_SYNCHRONIZED_IO___44 = 14,
    _SC_FSYNC___44 = 15,
    _SC_MAPPED_FILES___44 = 16,
    _SC_MEMLOCK___44 = 17,
    _SC_MEMLOCK_RANGE___44 = 18,
    _SC_MEMORY_PROTECTION___44 = 19,
    _SC_MESSAGE_PASSING___44 = 20,
    _SC_SEMAPHORES___44 = 21,
    _SC_SHARED_MEMORY_OBJECTS___44 = 22,
    _SC_AIO_LISTIO_MAX___44 = 23,
    _SC_AIO_MAX___44 = 24,
    _SC_AIO_PRIO_DELTA_MAX___44 = 25,
    _SC_DELAYTIMER_MAX___44 = 26,
    _SC_MQ_OPEN_MAX___44 = 27,
    _SC_MQ_PRIO_MAX___44 = 28,
    _SC_VERSION___44 = 29,
    _SC_PAGESIZE___44 = 30,
    _SC_RTSIG_MAX___44 = 31,
    _SC_SEM_NSEMS_MAX___44 = 32,
    _SC_SEM_VALUE_MAX___44 = 33,
    _SC_SIGQUEUE_MAX___44 = 34,
    _SC_TIMER_MAX___44 = 35,
    _SC_BC_BASE_MAX___44 = 36,
    _SC_BC_DIM_MAX___44 = 37,
    _SC_BC_SCALE_MAX___44 = 38,
    _SC_BC_STRING_MAX___44 = 39,
    _SC_COLL_WEIGHTS_MAX___44 = 40,
    _SC_EQUIV_CLASS_MAX___44 = 41,
    _SC_EXPR_NEST_MAX___44 = 42,
    _SC_LINE_MAX___44 = 43,
    _SC_RE_DUP_MAX___44 = 44,
    _SC_CHARCLASS_NAME_MAX___44 = 45,
    _SC_2_VERSION___44 = 46,
    _SC_2_C_BIND___44 = 47,
    _SC_2_C_DEV___44 = 48,
    _SC_2_FORT_DEV___44 = 49,
    _SC_2_FORT_RUN___44 = 50,
    _SC_2_SW_DEV___44 = 51,
    _SC_2_LOCALEDEF___44 = 52,
    _SC_PII___44 = 53,
    _SC_PII_XTI___44 = 54,
    _SC_PII_SOCKET___44 = 55,
    _SC_PII_INTERNET___44 = 56,
    _SC_PII_OSI___44 = 57,
    _SC_POLL___44 = 58,
    _SC_SELECT___44 = 59,
    _SC_UIO_MAXIOV___44 = 60,
    _SC_IOV_MAX___44 = 60,
    _SC_PII_INTERNET_STREAM___44 = 61,
    _SC_PII_INTERNET_DGRAM___44 = 62,
    _SC_PII_OSI_COTS___44 = 63,
    _SC_PII_OSI_CLTS___44 = 64,
    _SC_PII_OSI_M___44 = 65,
    _SC_T_IOV_MAX___44 = 66,
    _SC_THREADS___44 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___44 = 68,
    _SC_GETGR_R_SIZE_MAX___44 = 69,
    _SC_GETPW_R_SIZE_MAX___44 = 70,
    _SC_LOGIN_NAME_MAX___44 = 71,
    _SC_TTY_NAME_MAX___44 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___44 = 73,
    _SC_THREAD_KEYS_MAX___44 = 74,
    _SC_THREAD_STACK_MIN___44 = 75,
    _SC_THREAD_THREADS_MAX___44 = 76,
    _SC_THREAD_ATTR_STACKADDR___44 = 77,
    _SC_THREAD_ATTR_STACKSIZE___44 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___44 = 79,
    _SC_THREAD_PRIO_INHERIT___44 = 80,
    _SC_THREAD_PRIO_PROTECT___44 = 81,
    _SC_THREAD_PROCESS_SHARED___44 = 82,
    _SC_NPROCESSORS_CONF___44 = 83,
    _SC_NPROCESSORS_ONLN___44 = 84,
    _SC_PHYS_PAGES___44 = 85,
    _SC_AVPHYS_PAGES___44 = 86,
    _SC_ATEXIT_MAX___44 = 87,
    _SC_PASS_MAX___44 = 88,
    _SC_XOPEN_VERSION___44 = 89,
    _SC_XOPEN_XCU_VERSION___44 = 90,
    _SC_XOPEN_UNIX___44 = 91,
    _SC_XOPEN_CRYPT___44 = 92,
    _SC_XOPEN_ENH_I18N___44 = 93,
    _SC_XOPEN_SHM___44 = 94,
    _SC_2_CHAR_TERM___44 = 95,
    _SC_2_C_VERSION___44 = 96,
    _SC_2_UPE___44 = 97,
    _SC_XOPEN_XPG2___44 = 98,
    _SC_XOPEN_XPG3___44 = 99,
    _SC_XOPEN_XPG4___44 = 100,
    _SC_CHAR_BIT___44 = 101,
    _SC_CHAR_MAX___44 = 102,
    _SC_CHAR_MIN___44 = 103,
    _SC_INT_MAX___44 = 104,
    _SC_INT_MIN___44 = 105,
    _SC_LONG_BIT___44 = 106,
    _SC_WORD_BIT___44 = 107,
    _SC_MB_LEN_MAX___44 = 108,
    _SC_NZERO___44 = 109,
    _SC_SSIZE_MAX___44 = 110,
    _SC_SCHAR_MAX___44 = 111,
    _SC_SCHAR_MIN___44 = 112,
    _SC_SHRT_MAX___44 = 113,
    _SC_SHRT_MIN___44 = 114,
    _SC_UCHAR_MAX___44 = 115,
    _SC_UINT_MAX___44 = 116,
    _SC_ULONG_MAX___44 = 117,
    _SC_USHRT_MAX___44 = 118,
    _SC_NL_ARGMAX___44 = 119,
    _SC_NL_LANGMAX___44 = 120,
    _SC_NL_MSGMAX___44 = 121,
    _SC_NL_NMAX___44 = 122,
    _SC_NL_SETMAX___44 = 123,
    _SC_NL_TEXTMAX___44 = 124,
    _SC_XBS5_ILP32_OFF32___44 = 125,
    _SC_XBS5_ILP32_OFFBIG___44 = 126,
    _SC_XBS5_LP64_OFF64___44 = 127,
    _SC_XBS5_LPBIG_OFFBIG___44 = 128,
    _SC_XOPEN_LEGACY___44 = 129,
    _SC_XOPEN_REALTIME___44 = 130,
    _SC_XOPEN_REALTIME_THREADS___44 = 131,
    _SC_ADVISORY_INFO___44 = 132,
    _SC_BARRIERS___44 = 133,
    _SC_BASE___44 = 134,
    _SC_C_LANG_SUPPORT___44 = 135,
    _SC_C_LANG_SUPPORT_R___44 = 136,
    _SC_CLOCK_SELECTION___44 = 137,
    _SC_CPUTIME___44 = 138,
    _SC_THREAD_CPUTIME___44 = 139,
    _SC_DEVICE_IO___44 = 140,
    _SC_DEVICE_SPECIFIC___44 = 141,
    _SC_DEVICE_SPECIFIC_R___44 = 142,
    _SC_FD_MGMT___44 = 143,
    _SC_FIFO___44 = 144,
    _SC_PIPE___44 = 145,
    _SC_FILE_ATTRIBUTES___44 = 146,
    _SC_FILE_LOCKING___44 = 147,
    _SC_FILE_SYSTEM___44 = 148,
    _SC_MONOTONIC_CLOCK___44 = 149,
    _SC_MULTI_PROCESS___44 = 150,
    _SC_SINGLE_PROCESS___44 = 151,
    _SC_NETWORKING___44 = 152,
    _SC_READER_WRITER_LOCKS___44 = 153,
    _SC_SPIN_LOCKS___44 = 154,
    _SC_REGEXP___44 = 155,
    _SC_REGEX_VERSION___44 = 156,
    _SC_SHELL___44 = 157,
    _SC_SIGNALS___44 = 158,
    _SC_SPAWN___44 = 159,
    _SC_SPORADIC_SERVER___44 = 160,
    _SC_THREAD_SPORADIC_SERVER___44 = 161,
    _SC_SYSTEM_DATABASE___44 = 162,
    _SC_SYSTEM_DATABASE_R___44 = 163,
    _SC_TIMEOUTS___44 = 164,
    _SC_TYPED_MEMORY_OBJECTS___44 = 165,
    _SC_USER_GROUPS___44 = 166,
    _SC_USER_GROUPS_R___44 = 167,
    _SC_2_PBS___44 = 168,
    _SC_2_PBS_ACCOUNTING___44 = 169,
    _SC_2_PBS_LOCATE___44 = 170,
    _SC_2_PBS_MESSAGE___44 = 171,
    _SC_2_PBS_TRACK___44 = 172,
    _SC_SYMLOOP_MAX___44 = 173,
    _SC_STREAMS___44 = 174,
    _SC_2_PBS_CHECKPOINT___44 = 175,
    _SC_V6_ILP32_OFF32___44 = 176,
    _SC_V6_ILP32_OFFBIG___44 = 177,
    _SC_V6_LP64_OFF64___44 = 178,
    _SC_V6_LPBIG_OFFBIG___44 = 179,
    _SC_HOST_NAME_MAX___44 = 180,
    _SC_TRACE___44 = 181,
    _SC_TRACE_EVENT_FILTER___44 = 182,
    _SC_TRACE_INHERIT___44 = 183,
    _SC_TRACE_LOG___44 = 184,
    _SC_LEVEL1_ICACHE_SIZE___44 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___44 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___44 = 187,
    _SC_LEVEL1_DCACHE_SIZE___44 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___44 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___44 = 190,
    _SC_LEVEL2_CACHE_SIZE___44 = 191,
    _SC_LEVEL2_CACHE_ASSOC___44 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___44 = 193,
    _SC_LEVEL3_CACHE_SIZE___44 = 194,
    _SC_LEVEL3_CACHE_ASSOC___44 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___44 = 196,
    _SC_LEVEL4_CACHE_SIZE___44 = 197,
    _SC_LEVEL4_CACHE_ASSOC___44 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___44 = 199,
    _SC_IPV6___44 = 235,
    _SC_RAW_SOCKETS___44 = 236,
    _SC_V7_ILP32_OFF32___44 = 237,
    _SC_V7_ILP32_OFFBIG___44 = 238,
    _SC_V7_LP64_OFF64___44 = 239,
    _SC_V7_LPBIG_OFFBIG___44 = 240,
    _SC_SS_REPL_MAX___44 = 241,
    _SC_TRACE_EVENT_NAME_MAX___44 = 242,
    _SC_TRACE_NAME_MAX___44 = 243,
    _SC_TRACE_SYS_MAX___44 = 244,
    _SC_TRACE_USER_EVENT_MAX___44 = 245,
    _SC_XOPEN_STREAMS___44 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___44 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___44 = 248,
    _SC_MINSIGSTKSZ___44 = 249,
    _SC_SIGSTKSZ___44 = 250
} ;
enum __anonenum_875524036___44 {
    _CS_PATH___44 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___44 = 1,
    _CS_GNU_LIBC_VERSION___44 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___44 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___44 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___44 = 5,
    _CS_LFS_CFLAGS___44 = 1000,
    _CS_LFS_LDFLAGS___44 = 1001,
    _CS_LFS_LIBS___44 = 1002,
    _CS_LFS_LINTFLAGS___44 = 1003,
    _CS_LFS64_CFLAGS___44 = 1004,
    _CS_LFS64_LDFLAGS___44 = 1005,
    _CS_LFS64_LIBS___44 = 1006,
    _CS_LFS64_LINTFLAGS___44 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___44 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___44 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___44 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___44 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___44 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___44 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___44 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___44 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___44 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___44 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___44 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___44 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___44 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___44 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___44 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___44 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___44 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___44 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___44 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___44 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___44 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___44 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___44 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___44 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___44 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___44 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___44 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___44 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___44 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___44 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___44 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___44 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___44 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___44 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___44 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___44 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___44 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___44 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___44 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___44 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___44 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___44 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___44 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___44 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___44 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___44 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___44 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___44 = 1147,
    _CS_V6_ENV___44 = 1148,
    _CS_V7_ENV___44 = 1149
} ;
enum __anonenum_57186863___44 {
    SS_ONSTACK___44 = 1,
    SS_DISABLE___44 = 2
} ;
struct rtc_time {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
};
struct rtc_wkalrm {
   unsigned char enabled ;
   unsigned char pending ;
   struct rtc_time time ;
};
struct rtc_pll_info {
   int pll_ctrl ;
   int pll_value ;
   int pll_max ;
   int pll_min ;
   int pll_posmult ;
   int pll_negmult ;
   long pll_clock ;
};
enum __anonenum_83571709___45 {
    MSG_OOB___45 = 1,
    MSG_PEEK___45 = 2,
    MSG_DONTROUTE___45 = 4,
    MSG_TRYHARD___45 = 4,
    MSG_CTRUNC___45 = 8,
    MSG_PROXY___45 = 16,
    MSG_TRUNC___45 = 32,
    MSG_DONTWAIT___45 = 64,
    MSG_EOR___45 = 128,
    MSG_WAITALL___45 = 256,
    MSG_FIN___45 = 512,
    MSG_SYN___45 = 1024,
    MSG_CONFIRM___45 = 2048,
    MSG_RST___45 = 4096,
    MSG_ERRQUEUE___45 = 8192,
    MSG_NOSIGNAL___45 = 16384,
    MSG_MORE___45 = 32768,
    MSG_WAITFORONE___45 = 65536,
    MSG_BATCH___45 = 262144,
    MSG_ZEROCOPY___45 = 67108864,
    MSG_FASTOPEN___45 = 536870912,
    MSG_CMSG_CLOEXEC___45 = 1073741824
} ;
enum __anonenum_617082774___45 {
    SCM_RIGHTS___45 = 1,
    SCM_CREDENTIALS___45 = 2
} ;
enum __anonenum_606441560___45 {
    SHUT_RD___45 = 0,
    SHUT_WR___45 = 1,
    SHUT_RDWR___45 = 2
} ;
enum __anonenum_264779956___45 {
    IPPROTO_IP___45 = 0,
    IPPROTO_ICMP___45 = 1,
    IPPROTO_IGMP___45 = 2,
    IPPROTO_IPIP___45 = 4,
    IPPROTO_TCP___45 = 6,
    IPPROTO_EGP___45 = 8,
    IPPROTO_PUP___45 = 12,
    IPPROTO_UDP___45 = 17,
    IPPROTO_IDP___45 = 22,
    IPPROTO_TP___45 = 29,
    IPPROTO_DCCP___45 = 33,
    IPPROTO_IPV6___45 = 41,
    IPPROTO_RSVP___45 = 46,
    IPPROTO_GRE___45 = 47,
    IPPROTO_ESP___45 = 50,
    IPPROTO_AH___45 = 51,
    IPPROTO_MTP___45 = 92,
    IPPROTO_BEETPH___45 = 94,
    IPPROTO_ENCAP___45 = 98,
    IPPROTO_PIM___45 = 103,
    IPPROTO_COMP___45 = 108,
    IPPROTO_SCTP___45 = 132,
    IPPROTO_UDPLITE___45 = 136,
    IPPROTO_MPLS___45 = 137,
    IPPROTO_ETHERNET___45 = 143,
    IPPROTO_RAW___45 = 255,
    IPPROTO_MPTCP___45 = 262,
    IPPROTO_MAX___45 = 263
} ;
enum __anonenum_218739988___45 {
    IPPROTO_HOPOPTS___45 = 0,
    IPPROTO_ROUTING___45 = 43,
    IPPROTO_FRAGMENT___45 = 44,
    IPPROTO_ICMPV6___45 = 58,
    IPPROTO_NONE___45 = 59,
    IPPROTO_DSTOPTS___45 = 60,
    IPPROTO_MH___45 = 135
} ;
enum __anonenum_662268580___45 {
    IPPORT_ECHO___45 = 7,
    IPPORT_DISCARD___45 = 9,
    IPPORT_SYSTAT___45 = 11,
    IPPORT_DAYTIME___45 = 13,
    IPPORT_NETSTAT___45 = 15,
    IPPORT_FTP___45 = 21,
    IPPORT_TELNET___45 = 23,
    IPPORT_SMTP___45 = 25,
    IPPORT_TIMESERVER___45 = 37,
    IPPORT_NAMESERVER___45 = 42,
    IPPORT_WHOIS___45 = 43,
    IPPORT_MTP___45 = 57,
    IPPORT_TFTP___45 = 69,
    IPPORT_RJE___45 = 77,
    IPPORT_FINGER___45 = 79,
    IPPORT_TTYLINK___45 = 87,
    IPPORT_SUPDUP___45 = 95,
    IPPORT_EXECSERVER___45 = 512,
    IPPORT_LOGINSERVER___45 = 513,
    IPPORT_CMDSERVER___45 = 514,
    IPPORT_EFSSERVER___45 = 520,
    IPPORT_BIFFUDP___45 = 512,
    IPPORT_WHOSERVER___45 = 513,
    IPPORT_ROUTESERVER___45 = 520,
    IPPORT_RESERVED___45 = 1024,
    IPPORT_USERRESERVED___45 = 5000
} ;
enum __anonenum_18926444___45 {
    _ISupper___45 = 256,
    _ISlower___45 = 512,
    _ISalpha___45 = 1024,
    _ISdigit___45 = 2048,
    _ISxdigit___45 = 4096,
    _ISspace___45 = 8192,
    _ISprint___45 = 16384,
    _ISgraph___45 = 32768,
    _ISblank___45 = 1,
    _IScntrl___45 = 2,
    _ISpunct___45 = 4,
    _ISalnum___45 = 8
} ;
enum __anonenum_913965969___45 {
    FP_INT_UPWARD___45 = 0,
    FP_INT_DOWNWARD___45 = 1,
    FP_INT_TOWARDZERO___45 = 2,
    FP_INT_TONEARESTFROMZERO___45 = 3,
    FP_INT_TONEAREST___45 = 4
} ;
enum __anonenum_1037408945___45 {
    FP_NAN___45 = 0,
    FP_INFINITE___45 = 1,
    FP_ZERO___45 = 2,
    FP_SUBNORMAL___45 = 3,
    FP_NORMAL___45 = 4
} ;
enum __anonenum_556971655___45 {
    SI_ASYNCNL___45 = -60,
    SI_DETHREAD___45 = -7,
    SI_TKILL___45 = -6,
    SI_SIGIO___45 = -5,
    SI_ASYNCIO___45 = -4,
    SI_MESGQ___45 = -3,
    SI_TIMER___45 = -2,
    SI_QUEUE___45 = -1,
    SI_USER___45 = 0,
    SI_KERNEL___45 = 128
} ;
enum __anonenum_640648963___45 {
    ILL_ILLOPC___45 = 1,
    ILL_ILLOPN___45 = 2,
    ILL_ILLADR___45 = 3,
    ILL_ILLTRP___45 = 4,
    ILL_PRVOPC___45 = 5,
    ILL_PRVREG___45 = 6,
    ILL_COPROC___45 = 7,
    ILL_BADSTK___45 = 8,
    ILL_BADIADDR___45 = 9
} ;
enum __anonenum_457704180___45 {
    FPE_INTDIV___45 = 1,
    FPE_INTOVF___45 = 2,
    FPE_FLTDIV___45 = 3,
    FPE_FLTOVF___45 = 4,
    FPE_FLTUND___45 = 5,
    FPE_FLTRES___45 = 6,
    FPE_FLTINV___45 = 7,
    FPE_FLTSUB___45 = 8,
    FPE_FLTUNK___45 = 14,
    FPE_CONDTRAP___45 = 15
} ;
enum __anonenum_180375148___45 {
    SEGV_MAPERR___45 = 1,
    SEGV_ACCERR___45 = 2,
    SEGV_BNDERR___45 = 3,
    SEGV_PKUERR___45 = 4,
    SEGV_ACCADI___45 = 5,
    SEGV_ADIDERR___45 = 6,
    SEGV_ADIPERR___45 = 7,
    SEGV_MTEAERR___45 = 8,
    SEGV_MTESERR___45 = 9
} ;
enum __anonenum_1036286214___45 {
    BUS_ADRALN___45 = 1,
    BUS_ADRERR___45 = 2,
    BUS_OBJERR___45 = 3,
    BUS_MCEERR_AR___45 = 4,
    BUS_MCEERR_AO___45 = 5
} ;
enum __anonenum_91015150___45 {
    TRAP_BRKPT___45 = 1,
    TRAP_TRACE___45 = 2,
    TRAP_BRANCH___45 = 3,
    TRAP_HWBKPT___45 = 4,
    TRAP_UNK___45 = 5
} ;
enum __anonenum_23175539___45 {
    CLD_EXITED___45 = 1,
    CLD_KILLED___45 = 2,
    CLD_DUMPED___45 = 3,
    CLD_TRAPPED___45 = 4,
    CLD_STOPPED___45 = 5,
    CLD_CONTINUED___45 = 6
} ;
enum __anonenum_111643124___45 {
    POLL_IN___45 = 1,
    POLL_OUT___45 = 2,
    POLL_MSG___45 = 3,
    POLL_ERR___45 = 4,
    POLL_PRI___45 = 5,
    POLL_HUP___45 = 6
} ;
enum __anonenum_852341087___45 {
    SIGEV_SIGNAL___45 = 0,
    SIGEV_NONE___45 = 1,
    SIGEV_THREAD___45 = 2,
    SIGEV_THREAD_ID___45 = 4
} ;
enum __anonenum_451154152___45 {
    REG_R8___45 = 0,
    REG_R9___45 = 1,
    REG_R10___45 = 2,
    REG_R11___45 = 3,
    REG_R12___45 = 4,
    REG_R13___45 = 5,
    REG_R14___45 = 6,
    REG_R15___45 = 7,
    REG_RDI___45 = 8,
    REG_RSI___45 = 9,
    REG_RBP___45 = 10,
    REG_RBX___45 = 11,
    REG_RDX___45 = 12,
    REG_RAX___45 = 13,
    REG_RCX___45 = 14,
    REG_RSP___45 = 15,
    REG_RIP___45 = 16,
    REG_EFL___45 = 17,
    REG_CSGSFS___45 = 18,
    REG_ERR___45 = 19,
    REG_TRAPNO___45 = 20,
    REG_OLDMASK___45 = 21,
    REG_CR2___45 = 22
} ;
enum __anonenum_437032235___45 {
    _PC_LINK_MAX___45 = 0,
    _PC_MAX_CANON___45 = 1,
    _PC_MAX_INPUT___45 = 2,
    _PC_NAME_MAX___45 = 3,
    _PC_PATH_MAX___45 = 4,
    _PC_PIPE_BUF___45 = 5,
    _PC_CHOWN_RESTRICTED___45 = 6,
    _PC_NO_TRUNC___45 = 7,
    _PC_VDISABLE___45 = 8,
    _PC_SYNC_IO___45 = 9,
    _PC_ASYNC_IO___45 = 10,
    _PC_PRIO_IO___45 = 11,
    _PC_SOCK_MAXBUF___45 = 12,
    _PC_FILESIZEBITS___45 = 13,
    _PC_REC_INCR_XFER_SIZE___45 = 14,
    _PC_REC_MAX_XFER_SIZE___45 = 15,
    _PC_REC_MIN_XFER_SIZE___45 = 16,
    _PC_REC_XFER_ALIGN___45 = 17,
    _PC_ALLOC_SIZE_MIN___45 = 18,
    _PC_SYMLINK_MAX___45 = 19,
    _PC_2_SYMLINKS___45 = 20
} ;
enum __anonenum_315186338___45 {
    _SC_ARG_MAX___45 = 0,
    _SC_CHILD_MAX___45 = 1,
    _SC_CLK_TCK___45 = 2,
    _SC_NGROUPS_MAX___45 = 3,
    _SC_OPEN_MAX___45 = 4,
    _SC_STREAM_MAX___45 = 5,
    _SC_TZNAME_MAX___45 = 6,
    _SC_JOB_CONTROL___45 = 7,
    _SC_SAVED_IDS___45 = 8,
    _SC_REALTIME_SIGNALS___45 = 9,
    _SC_PRIORITY_SCHEDULING___45 = 10,
    _SC_TIMERS___45 = 11,
    _SC_ASYNCHRONOUS_IO___45 = 12,
    _SC_PRIORITIZED_IO___45 = 13,
    _SC_SYNCHRONIZED_IO___45 = 14,
    _SC_FSYNC___45 = 15,
    _SC_MAPPED_FILES___45 = 16,
    _SC_MEMLOCK___45 = 17,
    _SC_MEMLOCK_RANGE___45 = 18,
    _SC_MEMORY_PROTECTION___45 = 19,
    _SC_MESSAGE_PASSING___45 = 20,
    _SC_SEMAPHORES___45 = 21,
    _SC_SHARED_MEMORY_OBJECTS___45 = 22,
    _SC_AIO_LISTIO_MAX___45 = 23,
    _SC_AIO_MAX___45 = 24,
    _SC_AIO_PRIO_DELTA_MAX___45 = 25,
    _SC_DELAYTIMER_MAX___45 = 26,
    _SC_MQ_OPEN_MAX___45 = 27,
    _SC_MQ_PRIO_MAX___45 = 28,
    _SC_VERSION___45 = 29,
    _SC_PAGESIZE___45 = 30,
    _SC_RTSIG_MAX___45 = 31,
    _SC_SEM_NSEMS_MAX___45 = 32,
    _SC_SEM_VALUE_MAX___45 = 33,
    _SC_SIGQUEUE_MAX___45 = 34,
    _SC_TIMER_MAX___45 = 35,
    _SC_BC_BASE_MAX___45 = 36,
    _SC_BC_DIM_MAX___45 = 37,
    _SC_BC_SCALE_MAX___45 = 38,
    _SC_BC_STRING_MAX___45 = 39,
    _SC_COLL_WEIGHTS_MAX___45 = 40,
    _SC_EQUIV_CLASS_MAX___45 = 41,
    _SC_EXPR_NEST_MAX___45 = 42,
    _SC_LINE_MAX___45 = 43,
    _SC_RE_DUP_MAX___45 = 44,
    _SC_CHARCLASS_NAME_MAX___45 = 45,
    _SC_2_VERSION___45 = 46,
    _SC_2_C_BIND___45 = 47,
    _SC_2_C_DEV___45 = 48,
    _SC_2_FORT_DEV___45 = 49,
    _SC_2_FORT_RUN___45 = 50,
    _SC_2_SW_DEV___45 = 51,
    _SC_2_LOCALEDEF___45 = 52,
    _SC_PII___45 = 53,
    _SC_PII_XTI___45 = 54,
    _SC_PII_SOCKET___45 = 55,
    _SC_PII_INTERNET___45 = 56,
    _SC_PII_OSI___45 = 57,
    _SC_POLL___45 = 58,
    _SC_SELECT___45 = 59,
    _SC_UIO_MAXIOV___45 = 60,
    _SC_IOV_MAX___45 = 60,
    _SC_PII_INTERNET_STREAM___45 = 61,
    _SC_PII_INTERNET_DGRAM___45 = 62,
    _SC_PII_OSI_COTS___45 = 63,
    _SC_PII_OSI_CLTS___45 = 64,
    _SC_PII_OSI_M___45 = 65,
    _SC_T_IOV_MAX___45 = 66,
    _SC_THREADS___45 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___45 = 68,
    _SC_GETGR_R_SIZE_MAX___45 = 69,
    _SC_GETPW_R_SIZE_MAX___45 = 70,
    _SC_LOGIN_NAME_MAX___45 = 71,
    _SC_TTY_NAME_MAX___45 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___45 = 73,
    _SC_THREAD_KEYS_MAX___45 = 74,
    _SC_THREAD_STACK_MIN___45 = 75,
    _SC_THREAD_THREADS_MAX___45 = 76,
    _SC_THREAD_ATTR_STACKADDR___45 = 77,
    _SC_THREAD_ATTR_STACKSIZE___45 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___45 = 79,
    _SC_THREAD_PRIO_INHERIT___45 = 80,
    _SC_THREAD_PRIO_PROTECT___45 = 81,
    _SC_THREAD_PROCESS_SHARED___45 = 82,
    _SC_NPROCESSORS_CONF___45 = 83,
    _SC_NPROCESSORS_ONLN___45 = 84,
    _SC_PHYS_PAGES___45 = 85,
    _SC_AVPHYS_PAGES___45 = 86,
    _SC_ATEXIT_MAX___45 = 87,
    _SC_PASS_MAX___45 = 88,
    _SC_XOPEN_VERSION___45 = 89,
    _SC_XOPEN_XCU_VERSION___45 = 90,
    _SC_XOPEN_UNIX___45 = 91,
    _SC_XOPEN_CRYPT___45 = 92,
    _SC_XOPEN_ENH_I18N___45 = 93,
    _SC_XOPEN_SHM___45 = 94,
    _SC_2_CHAR_TERM___45 = 95,
    _SC_2_C_VERSION___45 = 96,
    _SC_2_UPE___45 = 97,
    _SC_XOPEN_XPG2___45 = 98,
    _SC_XOPEN_XPG3___45 = 99,
    _SC_XOPEN_XPG4___45 = 100,
    _SC_CHAR_BIT___45 = 101,
    _SC_CHAR_MAX___45 = 102,
    _SC_CHAR_MIN___45 = 103,
    _SC_INT_MAX___45 = 104,
    _SC_INT_MIN___45 = 105,
    _SC_LONG_BIT___45 = 106,
    _SC_WORD_BIT___45 = 107,
    _SC_MB_LEN_MAX___45 = 108,
    _SC_NZERO___45 = 109,
    _SC_SSIZE_MAX___45 = 110,
    _SC_SCHAR_MAX___45 = 111,
    _SC_SCHAR_MIN___45 = 112,
    _SC_SHRT_MAX___45 = 113,
    _SC_SHRT_MIN___45 = 114,
    _SC_UCHAR_MAX___45 = 115,
    _SC_UINT_MAX___45 = 116,
    _SC_ULONG_MAX___45 = 117,
    _SC_USHRT_MAX___45 = 118,
    _SC_NL_ARGMAX___45 = 119,
    _SC_NL_LANGMAX___45 = 120,
    _SC_NL_MSGMAX___45 = 121,
    _SC_NL_NMAX___45 = 122,
    _SC_NL_SETMAX___45 = 123,
    _SC_NL_TEXTMAX___45 = 124,
    _SC_XBS5_ILP32_OFF32___45 = 125,
    _SC_XBS5_ILP32_OFFBIG___45 = 126,
    _SC_XBS5_LP64_OFF64___45 = 127,
    _SC_XBS5_LPBIG_OFFBIG___45 = 128,
    _SC_XOPEN_LEGACY___45 = 129,
    _SC_XOPEN_REALTIME___45 = 130,
    _SC_XOPEN_REALTIME_THREADS___45 = 131,
    _SC_ADVISORY_INFO___45 = 132,
    _SC_BARRIERS___45 = 133,
    _SC_BASE___45 = 134,
    _SC_C_LANG_SUPPORT___45 = 135,
    _SC_C_LANG_SUPPORT_R___45 = 136,
    _SC_CLOCK_SELECTION___45 = 137,
    _SC_CPUTIME___45 = 138,
    _SC_THREAD_CPUTIME___45 = 139,
    _SC_DEVICE_IO___45 = 140,
    _SC_DEVICE_SPECIFIC___45 = 141,
    _SC_DEVICE_SPECIFIC_R___45 = 142,
    _SC_FD_MGMT___45 = 143,
    _SC_FIFO___45 = 144,
    _SC_PIPE___45 = 145,
    _SC_FILE_ATTRIBUTES___45 = 146,
    _SC_FILE_LOCKING___45 = 147,
    _SC_FILE_SYSTEM___45 = 148,
    _SC_MONOTONIC_CLOCK___45 = 149,
    _SC_MULTI_PROCESS___45 = 150,
    _SC_SINGLE_PROCESS___45 = 151,
    _SC_NETWORKING___45 = 152,
    _SC_READER_WRITER_LOCKS___45 = 153,
    _SC_SPIN_LOCKS___45 = 154,
    _SC_REGEXP___45 = 155,
    _SC_REGEX_VERSION___45 = 156,
    _SC_SHELL___45 = 157,
    _SC_SIGNALS___45 = 158,
    _SC_SPAWN___45 = 159,
    _SC_SPORADIC_SERVER___45 = 160,
    _SC_THREAD_SPORADIC_SERVER___45 = 161,
    _SC_SYSTEM_DATABASE___45 = 162,
    _SC_SYSTEM_DATABASE_R___45 = 163,
    _SC_TIMEOUTS___45 = 164,
    _SC_TYPED_MEMORY_OBJECTS___45 = 165,
    _SC_USER_GROUPS___45 = 166,
    _SC_USER_GROUPS_R___45 = 167,
    _SC_2_PBS___45 = 168,
    _SC_2_PBS_ACCOUNTING___45 = 169,
    _SC_2_PBS_LOCATE___45 = 170,
    _SC_2_PBS_MESSAGE___45 = 171,
    _SC_2_PBS_TRACK___45 = 172,
    _SC_SYMLOOP_MAX___45 = 173,
    _SC_STREAMS___45 = 174,
    _SC_2_PBS_CHECKPOINT___45 = 175,
    _SC_V6_ILP32_OFF32___45 = 176,
    _SC_V6_ILP32_OFFBIG___45 = 177,
    _SC_V6_LP64_OFF64___45 = 178,
    _SC_V6_LPBIG_OFFBIG___45 = 179,
    _SC_HOST_NAME_MAX___45 = 180,
    _SC_TRACE___45 = 181,
    _SC_TRACE_EVENT_FILTER___45 = 182,
    _SC_TRACE_INHERIT___45 = 183,
    _SC_TRACE_LOG___45 = 184,
    _SC_LEVEL1_ICACHE_SIZE___45 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___45 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___45 = 187,
    _SC_LEVEL1_DCACHE_SIZE___45 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___45 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___45 = 190,
    _SC_LEVEL2_CACHE_SIZE___45 = 191,
    _SC_LEVEL2_CACHE_ASSOC___45 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___45 = 193,
    _SC_LEVEL3_CACHE_SIZE___45 = 194,
    _SC_LEVEL3_CACHE_ASSOC___45 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___45 = 196,
    _SC_LEVEL4_CACHE_SIZE___45 = 197,
    _SC_LEVEL4_CACHE_ASSOC___45 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___45 = 199,
    _SC_IPV6___45 = 235,
    _SC_RAW_SOCKETS___45 = 236,
    _SC_V7_ILP32_OFF32___45 = 237,
    _SC_V7_ILP32_OFFBIG___45 = 238,
    _SC_V7_LP64_OFF64___45 = 239,
    _SC_V7_LPBIG_OFFBIG___45 = 240,
    _SC_SS_REPL_MAX___45 = 241,
    _SC_TRACE_EVENT_NAME_MAX___45 = 242,
    _SC_TRACE_NAME_MAX___45 = 243,
    _SC_TRACE_SYS_MAX___45 = 244,
    _SC_TRACE_USER_EVENT_MAX___45 = 245,
    _SC_XOPEN_STREAMS___45 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___45 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___45 = 248,
    _SC_MINSIGSTKSZ___45 = 249,
    _SC_SIGSTKSZ___45 = 250
} ;
enum __anonenum_875524036___45 {
    _CS_PATH___45 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___45 = 1,
    _CS_GNU_LIBC_VERSION___45 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___45 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___45 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___45 = 5,
    _CS_LFS_CFLAGS___45 = 1000,
    _CS_LFS_LDFLAGS___45 = 1001,
    _CS_LFS_LIBS___45 = 1002,
    _CS_LFS_LINTFLAGS___45 = 1003,
    _CS_LFS64_CFLAGS___45 = 1004,
    _CS_LFS64_LDFLAGS___45 = 1005,
    _CS_LFS64_LIBS___45 = 1006,
    _CS_LFS64_LINTFLAGS___45 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___45 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___45 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___45 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___45 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___45 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___45 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___45 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___45 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___45 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___45 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___45 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___45 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___45 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___45 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___45 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___45 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___45 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___45 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___45 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___45 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___45 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___45 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___45 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___45 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___45 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___45 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___45 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___45 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___45 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___45 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___45 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___45 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___45 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___45 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___45 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___45 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___45 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___45 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___45 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___45 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___45 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___45 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___45 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___45 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___45 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___45 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___45 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___45 = 1147,
    _CS_V6_ENV___45 = 1148,
    _CS_V7_ENV___45 = 1149
} ;
enum __anonenum_57186863___45 {
    SS_ONSTACK___45 = 1,
    SS_DISABLE___45 = 2
} ;
typedef uint32_t UINT4;
struct __anonstruct_MD5_CTX_1039593844 {
   UINT4 i[2] ;
   UINT4 buf[4] ;
   unsigned char in[64] ;
   unsigned char digest[16] ;
};
typedef struct __anonstruct_MD5_CTX_1039593844 MD5_CTX;
void ( __attribute__((__nonnull__(1,4))) qsort)(void *ptr , size_t count , size_t size ,
                                                int (*comp)(void const * , void const * ) ) __attribute__((__goblint_stub__)) ;
void ( __attribute__((__nonnull__(1,4))) qsort)(void *ptr , size_t count , size_t size ,
                                                int (*comp)(void const * , void const * ) ) __attribute__((__goblint_stub__)) ;
void ( __attribute__((__nonnull__(1,4))) qsort)(void *ptr , size_t count , size_t size ,
                                                int (*comp)(void const * , void const * ) )
{
  size_t i ;
  size_t j ;
  size_t i___0 ;
  size_t j___0 ;
  int r ;
  size_t k ;
  char *a ;
  char *b ;
  char c ;
  {
  i = (size_t )0;
  {
  while (1) {
    while_continue: ;
    if (! (i < count)) {
      goto while_break;
    }
    j = (size_t )0;
    {
    while (1) {
      while_continue___0: ;
      if (! (j < count)) {
        goto while_break___0;
      }
      (*comp)((void const *)(ptr + i * size), (void const *)(ptr + j * size));
      j ++;
    }
    while_break___0: ;
    }
    i ++;
  }
  while_break: ;
  }
  i___0 = (size_t )0;
  {
  while (1) {
    while_continue___1: ;
    if (! (i___0 < count)) {
      goto while_break___1;
    }
    j___0 = (size_t )0;
    {
    while (1) {
      while_continue___2: ;
      if (! (j___0 < count)) {
        goto while_break___2;
      }
      if (r) {
        k = (size_t )0;
        {
        while (1) {
          while_continue___3: ;
          if (! (k < size)) {
            goto while_break___3;
          }
          a = (char *)((ptr + i___0 * size) + k);
          b = (char *)((ptr + j___0 * size) + k);
          c = *a;
          *a = *b;
          *b = c;
          k ++;
        }
        while_break___3: ;
        }
      }
      j___0 ++;
    }
    while_break___2: ;
    }
    i___0 ++;
  }
  while_break___1: ;
  }
  return;
}
}
void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const *key ,
                                                                                             void const *ptr ,
                                                                                             size_t count ,
                                                                                             size_t size ,
                                                                                             int (*comp)(void const * ,
                                                                                                         void const * ) ) __attribute__((__goblint_stub__)) ;
void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const *key ,
                                                                                             void const *ptr ,
                                                                                             size_t count ,
                                                                                             size_t size ,
                                                                                             int (*comp)(void const * ,
                                                                                                         void const * ) ) __attribute__((__goblint_stub__)) ;
void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const *key ,
                                                                                             void const *ptr ,
                                                                                             size_t count ,
                                                                                             size_t size ,
                                                                                             int (*comp)(void const * ,
                                                                                                         void const * ) )
{
  size_t i ;
  void const *a ;
  int tmp ;
  {
  i = (size_t )0;
  {
  while (1) {
    while_continue: ;
    if (! (i < count)) {
      goto while_break;
    }
    a = ptr + i * size;
    tmp = (*comp)(key, a);
    if (tmp == 0) {
      return ((void *)a);
    }
    i ++;
  }
  while_break: ;
  }
  return ((void *)0);
}
}
extern int ( __attribute__((__leaf__)) __sched_cpucount)(size_t __setsize , cpu_set_t const *__setp ) __attribute__((__nothrow__)) ;
extern cpu_set_t *( __attribute__((__warn_unused_result__, __leaf__)) __sched_cpualloc)(size_t __count ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) __sched_cpufree)(cpu_set_t *__set ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) sched_setparam)(__pid_t __pid , struct sched_param const *__param ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) sched_getparam)(__pid_t __pid , struct sched_param *__param ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) sched_setscheduler)(__pid_t __pid , int __policy ,
                                                           struct sched_param const *__param ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) sched_getscheduler)(__pid_t __pid ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) sched_yield)(void) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) sched_get_priority_max)(int __algorithm ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) sched_get_priority_min)(int __algorithm ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) sched_rr_get_interval)(__pid_t __pid , struct timespec *__t ) __attribute__((__nothrow__)) ;
extern clock_t ( __attribute__((__leaf__)) clock)(void) __attribute__((__nothrow__)) ;
extern time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) difftime)(time_t __time1 , time_t __time0 ) __attribute__((__nothrow__,
__const__)) ;
extern time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp ) __attribute__((__nothrow__)) ;
extern size_t ( __attribute__((__leaf__)) strftime)(char *__s , size_t __maxsize ,
                                                    char const *__format , struct tm const *__tp ) __attribute__((__nothrow__)) ;
extern size_t ( __attribute__((__leaf__)) strftime_l)(char *__s , size_t __maxsize ,
                                                      char const *__format , struct tm const *__tp ,
                                                      locale_t __loc ) __attribute__((__nothrow__)) ;
extern struct tm *( __attribute__((__leaf__)) gmtime)(time_t const *__timer ) __attribute__((__nothrow__)) ;
extern struct tm *( __attribute__((__leaf__)) localtime)(time_t const *__timer ) __attribute__((__nothrow__)) ;
extern struct tm *( __attribute__((__leaf__)) gmtime_r)(time_t const *__timer ,
                                                        struct tm *__tp ) __attribute__((__nothrow__)) ;
extern struct tm *( __attribute__((__leaf__)) localtime_r)(time_t const *__timer ,
                                                           struct tm *__tp ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__leaf__)) asctime)(struct tm const *__tp ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__leaf__)) ctime)(time_t const *__timer ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__leaf__)) asctime_r)(struct tm const *__tp , char *__buf ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__leaf__)) ctime_r)(time_t const *__timer , char *__buf ) __attribute__((__nothrow__)) ;
extern char *__tzname[2] ;
extern int __daylight ;
extern long __timezone ;
extern char *tzname[2] ;
extern void ( __attribute__((__leaf__)) tzset)(void) __attribute__((__nothrow__)) ;
extern int daylight ;
extern long timezone ;
extern time_t ( __attribute__((__leaf__)) timegm)(struct tm *__tp ) __attribute__((__nothrow__)) ;
extern time_t ( __attribute__((__leaf__)) timelocal)(struct tm *__tp ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) dysize)(int __year ) __attribute__((__nothrow__,
__const__)) ;
extern int nanosleep(struct timespec const *__requested_time , struct timespec *__remaining ) ;
extern int ( __attribute__((__leaf__)) clock_getres)(clockid_t __clock_id , struct timespec *__res ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id , struct timespec *__tp ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) clock_settime)(clockid_t __clock_id , struct timespec const *__tp ) __attribute__((__nothrow__)) ;
extern int clock_nanosleep(clockid_t __clock_id , int __flags , struct timespec const *__req ,
                           struct timespec *__rem ) ;
extern int ( __attribute__((__leaf__)) clock_getcpuclockid)(pid_t __pid , clockid_t *__clock_id ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) timer_create)(clockid_t __clock_id , struct sigevent *__evp ,
                                                     timer_t *__timerid ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) timer_delete)(timer_t __timerid ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) timer_settime)(timer_t __timerid , int __flags ,
                                                      struct itimerspec const *__value ,
                                                      struct itimerspec *__ovalue ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) timer_gettime)(timer_t __timerid , struct itimerspec *__value ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) timer_getoverrun)(timer_t __timerid ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) timespec_get)(struct timespec *__ts ,
                                                                     int __base ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t *__newthread ,
                                                               pthread_attr_t const *__attr ,
                                                               void *(*__start_routine)(void * ) ,
                                                               void *__arg ) __attribute__((__nothrow__)) ;
extern void pthread_exit(void *__retval ) __attribute__((__noreturn__)) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern int ( __attribute__((__leaf__)) pthread_detach)(pthread_t __th ) __attribute__((__nothrow__)) ;
extern pthread_t ( __attribute__((__leaf__)) pthread_self)(void) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__, __gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                      pthread_t __thread2 ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_init)(pthread_attr_t *__attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_destroy)(pthread_attr_t *__attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getdetachstate)(pthread_attr_t const *__attr ,
                                                                                      int *__detachstate ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setdetachstate)(pthread_attr_t *__attr ,
                                                                                    int __detachstate ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getguardsize)(pthread_attr_t const *__attr ,
                                                                                    size_t *__guardsize ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setguardsize)(pthread_attr_t *__attr ,
                                                                                  size_t __guardsize ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getschedparam)(pthread_attr_t const *__attr ,
                                                                                     struct sched_param *__param ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_setschedparam)(pthread_attr_t *__attr ,
                                                                                     struct sched_param const *__param ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getschedpolicy)(pthread_attr_t const *__attr ,
                                                                                      int *__policy ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setschedpolicy)(pthread_attr_t *__attr ,
                                                                                    int __policy ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getinheritsched)(pthread_attr_t const *__attr ,
                                                                                       int *__inherit ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setinheritsched)(pthread_attr_t *__attr ,
                                                                                     int __inherit ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getscope)(pthread_attr_t const *__attr ,
                                                                                int *__scope ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setscope)(pthread_attr_t *__attr ,
                                                                              int __scope ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getstackaddr)(pthread_attr_t const *__attr ,
                                                                                    void **__stackaddr ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setstackaddr)(pthread_attr_t *__attr ,
                                                                                  void *__stackaddr ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getstacksize)(pthread_attr_t const *__attr ,
                                                                                    size_t *__stacksize ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setstacksize)(pthread_attr_t *__attr ,
                                                                                  size_t __stacksize ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2,3), __leaf__)) pthread_attr_getstack)(pthread_attr_t const *__attr ,
                                                                                  void **__stackaddr ,
                                                                                  size_t *__stacksize ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setstack)(pthread_attr_t *__attr ,
                                                                              void *__stackaddr ,
                                                                              size_t __stacksize ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(3), __leaf__)) pthread_setschedparam)(pthread_t __target_thread ,
                                                                              int __policy ,
                                                                              struct sched_param const *__param ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2,3), __leaf__)) pthread_getschedparam)(pthread_t __target_thread ,
                                                                                int *__policy ,
                                                                                struct sched_param *__param ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) pthread_setschedprio)(pthread_t __target_thread ,
                                                             int __prio ) __attribute__((__nothrow__)) ;
int ( __attribute__((__nonnull__(1,2))) pthread_once)(pthread_once_t *once_control ,
                                                      void (*init_routine)(void) ) __attribute__((__goblint_stub__)) ;
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
extern int pthread_setcanceltype(int __type , int *__oldtype ) ;
extern int pthread_cancel(pthread_t __th ) ;
extern void pthread_testcancel(void) ;
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
extern void __pthread_unwind_next(__pthread_unwind_buf_t *__buf ) __attribute__((__weak__,
__noreturn__)) ;
extern int __sigsetjmp_cancel(struct __cancel_jmp_buf_tag *__env , int __savemask ) __asm__("__sigsetjmp") __attribute__((__returns_twice__,
__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                           pthread_mutexattr_t const *__mutexattr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_trylock)(pthread_mutex_t *__mutex ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_mutex_timedlock)(pthread_mutex_t *__mutex ,
                                                                        struct timespec const *__abstime ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutex_getprioceiling)(pthread_mutex_t const *__mutex ,
                                                                                       int *__prioceiling ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,3), __leaf__)) pthread_mutex_setprioceiling)(pthread_mutex_t *__mutex ,
                                                                                       int __prioceiling ,
                                                                                       int *__old_ceiling ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_consistent)(pthread_mutex_t *__mutex ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_init)(pthread_mutexattr_t *__attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_destroy)(pthread_mutexattr_t *__attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_getpshared)(pthread_mutexattr_t const *__attr ,
                                                                                       int *__pshared ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_setpshared)(pthread_mutexattr_t *__attr ,
                                                                                     int __pshared ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_gettype)(pthread_mutexattr_t const *__attr ,
                                                                                    int *__kind ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_settype)(pthread_mutexattr_t *__attr ,
                                                                                  int __kind ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_getprotocol)(pthread_mutexattr_t const *__attr ,
                                                                                        int *__protocol ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_setprotocol)(pthread_mutexattr_t *__attr ,
                                                                                      int __protocol ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_getprioceiling)(pthread_mutexattr_t const *__attr ,
                                                                                           int *__prioceiling ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_setprioceiling)(pthread_mutexattr_t *__attr ,
                                                                                         int __prioceiling ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_getrobust)(pthread_mutexattr_t const *__attr ,
                                                                                      int *__robustness ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_setrobust)(pthread_mutexattr_t *__attr ,
                                                                                    int __robustness ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlock_init)(pthread_rwlock_t *__rwlock ,
                                                                            pthread_rwlockattr_t const *__attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlock_destroy)(pthread_rwlock_t *__rwlock ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_rdlock)(pthread_rwlock_t *__rwlock ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_tryrdlock)(pthread_rwlock_t *__rwlock ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_rwlock_timedrdlock)(pthread_rwlock_t *__rwlock ,
                                                                           struct timespec const *__abstime ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_wrlock)(pthread_rwlock_t *__rwlock ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_trywrlock)(pthread_rwlock_t *__rwlock ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_rwlock_timedwrlock)(pthread_rwlock_t *__rwlock ,
                                                                           struct timespec const *__abstime ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_unlock)(pthread_rwlock_t *__rwlock ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_init)(pthread_rwlockattr_t *__attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_destroy)(pthread_rwlockattr_t *__attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_rwlockattr_getpshared)(pthread_rwlockattr_t const *__attr ,
                                                                                        int *__pshared ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_setpshared)(pthread_rwlockattr_t *__attr ,
                                                                                      int __pshared ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_rwlockattr_getkind_np)(pthread_rwlockattr_t const *__attr ,
                                                                                        int *__pref ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_setkind_np)(pthread_rwlockattr_t *__attr ,
                                                                                      int __pref ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_init)(pthread_cond_t *__cond ,
                                                                          pthread_condattr_t const *__cond_attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_destroy)(pthread_cond_t *__cond ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t *__cond ,
                                                                  pthread_mutex_t *__mutex ) ;
extern int ( __attribute__((__nonnull__(1,2,3))) pthread_cond_timedwait)(pthread_cond_t *__cond ,
                                                                         pthread_mutex_t *__mutex ,
                                                                         struct timespec const *__abstime ) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_condattr_init)(pthread_condattr_t *__attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_condattr_destroy)(pthread_condattr_t *__attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_condattr_getpshared)(pthread_condattr_t const *__attr ,
                                                                                      int *__pshared ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_condattr_setpshared)(pthread_condattr_t *__attr ,
                                                                                    int __pshared ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_condattr_getclock)(pthread_condattr_t const *__attr ,
                                                                                    __clockid_t *__clock_id ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_condattr_setclock)(pthread_condattr_t *__attr ,
                                                                                  __clockid_t __clock_id ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_spin_init)(pthread_spinlock_t *__lock ,
                                                                          int __pshared ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_spin_destroy)(pthread_spinlock_t *__lock ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_spin_lock)(pthread_spinlock_t *__lock ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_spin_trylock)(pthread_spinlock_t *__lock ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_spin_unlock)(pthread_spinlock_t *__lock ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrier_init)(pthread_barrier_t *__barrier ,
                                                                             pthread_barrierattr_t const *__attr ,
                                                                             unsigned int __count ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrier_destroy)(pthread_barrier_t *__barrier ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) pthread_barrier_wait)(pthread_barrier_t *__barrier ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrierattr_init)(pthread_barrierattr_t *__attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrierattr_destroy)(pthread_barrierattr_t *__attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_barrierattr_getpshared)(pthread_barrierattr_t const *__attr ,
                                                                                         int *__pshared ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrierattr_setpshared)(pthread_barrierattr_t *__attr ,
                                                                                       int __pshared ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_key_create)(pthread_key_t *__key ,
                                                                           void (*__destr_function)(void * ) ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) pthread_key_delete)(pthread_key_t __key ) __attribute__((__nothrow__)) ;
extern void *( __attribute__((__leaf__)) pthread_getspecific)(pthread_key_t __key ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) pthread_setspecific)(pthread_key_t __key ,
                                                            void const *__pointer ) __attribute__((__nothrow__,
__access__(__none__,2))) ;
extern int ( __attribute__((__nonnull__(2), __leaf__)) pthread_getcpuclockid)(pthread_t __thread_id ,
                                                                              __clockid_t *__clock_id ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) pthread_atfork)(void (*__prepare)(void) , void (*__parent)(void) ,
                                                       void (*__child)(void) ) __attribute__((__nothrow__)) ;
int ( __attribute__((__nonnull__(1,2))) pthread_once)(pthread_once_t *once_control ,
                                                      void (*init_routine)(void) ) __attribute__((__goblint_stub__)) ;
int ( __attribute__((__nonnull__(1,2))) pthread_once)(pthread_once_t *once_control ,
                                                      void (*init_routine)(void) )
{
  int top ;
  {
  (*init_routine)();
  return (top);
}
}
__inline static __uint16_t __bswap_16(__uint16_t __bsx )
{
  short tmp ;
  {
  tmp = __builtin_bswap16((short )__bsx);
  return ((__uint16_t )tmp);
}
}
__inline static __uint32_t __bswap_32(__uint32_t __bsx )
{
  int tmp ;
  {
  tmp = __builtin_bswap32((int )__bsx);
  return ((__uint32_t )tmp);
}
}
__inline static __uint64_t __bswap_64(__uint64_t __bsx )
{
  long tmp ;
  {
  tmp = __builtin_bswap64((long )__bsx);
  return ((__uint64_t )tmp);
}
}
__inline static __uint16_t __uint16_identity(__uint16_t __x )
{
  {
  return (__x);
}
}
__inline static __uint32_t __uint32_identity(__uint32_t __x )
{
  {
  return (__x);
}
}
__inline static __uint64_t __uint64_identity(__uint64_t __x )
{
  {
  return (__x);
}
}
extern int select(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                  struct timeval *__timeout ) ;
extern int pselect(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                   struct timespec const *__timeout , __sigset_t const *__sigmask ) ;
extern long __fdelt_chk(long __d ) ;
extern long __fdelt_warn(long __d ) __attribute__((__warning__("bit outside of fd_set selected"))) ;
__inline extern struct cmsghdr *( __attribute__((__leaf__, __gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                           struct cmsghdr *__cmsg ) __attribute__((__nothrow__)) ;
__inline extern struct cmsghdr *( __attribute__((__leaf__, __gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                           struct cmsghdr *__cmsg ) __attribute__((__nothrow__)) ;
__inline extern struct cmsghdr *( __attribute__((__leaf__, __gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                           struct cmsghdr *__cmsg )
{
  {
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
    return ((struct cmsghdr *)0);
  }
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
  if ((unsigned long )((unsigned char *)(__cmsg + 1)) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  } else
  if ((unsigned long )((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  }
  return (__cmsg);
}
}
extern int ( __attribute__((__leaf__)) socket)(int __domain , int __type , int __protocol ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) socketpair)(int __domain , int __type , int __protocol ,
                                                   int *__fds ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) bind)(int __fd , struct sockaddr const *__addr ,
                                             socklen_t __len ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) getsockname)(int __fd , struct sockaddr *__addr ,
                                                    socklen_t *__len ) __attribute__((__nothrow__)) ;
extern int connect(int __fd , struct sockaddr const *__addr , socklen_t __len ) ;
extern int ( __attribute__((__leaf__)) getpeername)(int __fd , struct sockaddr *__addr ,
                                                    socklen_t *__len ) __attribute__((__nothrow__)) ;
extern ssize_t send(int __fd , void const *__buf , size_t __n , int __flags ) ;
__inline extern ssize_t ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) recv)(int __fd ,
                                                                                                   void *__buf ,
                                                                                                   size_t __n ,
                                                                                                   int __flags ) ;
extern ssize_t sendto(int __fd , void const *__buf , size_t __n , int __flags ,
                      struct sockaddr const *__addr , socklen_t __addr_len ) ;
__inline extern ssize_t ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) recvfrom)(int __fd ,
                                                                                                       void *__buf ,
                                                                                                       size_t __n ,
                                                                                                       int __flags ,
                                                                                                       struct sockaddr * __restrict __cil_tmp12 ,
                                                                                                       socklen_t *__addr_len ) ;
extern ssize_t sendmsg(int __fd , struct msghdr const *__message , int __flags ) ;
extern int sendmmsg(int __fd , struct mmsghdr *__vmessages , unsigned int __vlen ,
                    int __flags ) ;
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
extern int recvmmsg(int __fd , struct mmsghdr *__vmessages , unsigned int __vlen ,
                    int __flags , struct timespec *__tmo ) ;
extern int ( __attribute__((__leaf__)) getsockopt)(int __fd , int __level , int __optname ,
                                                   void *__optval , socklen_t *__optlen ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setsockopt)(int __fd , int __level , int __optname ,
                                                   void const *__optval , socklen_t __optlen ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) listen)(int __fd , int __n ) __attribute__((__nothrow__)) ;
extern int accept(int __fd , struct sockaddr *__addr , socklen_t *__addr_len ) ;
extern int accept4(int __fd , struct sockaddr *__addr , socklen_t *__addr_len , int __flags ) ;
extern int ( __attribute__((__leaf__)) shutdown)(int __fd , int __how ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) sockatmark)(int __fd ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isfdtype)(int __fd , int __fdtype ) __attribute__((__nothrow__)) ;
extern ssize_t __recv_chk(int __fd , void *__buf , size_t __n , size_t __buflen ,
                          int __flags ) ;
extern ssize_t __recv_alias(int __fd , void *__buf , size_t __n , int __flags ) __asm__("recv") ;
extern ssize_t __recv_chk_warn(int __fd , void *__buf , size_t __n , size_t __buflen ,
                               int __flags ) __asm__("__recv_chk") __attribute__((__warning__("recv called with bigger length than size of destination buffer"))) ;
__inline extern ssize_t ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) recv)(int __fd ,
                                                                                                   void *__buf ,
                                                                                                   size_t __n ,
                                                                                                   int __flags )
{
  size_t sz ;
  unsigned long tmp ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  {
  tmp = __builtin_object_size(__buf, 0);
  sz = tmp;
  tmp___2 = __recv_chk(__fd, __buf, __n, sz, __flags);
  return (tmp___2);
}
}
extern ssize_t __recvfrom_chk(int __fd , void *__buf , size_t __n , size_t __buflen ,
                              int __flags , struct sockaddr *__addr , socklen_t *__addr_len ) ;
extern ssize_t __recvfrom_alias(int __fd , void *__buf , size_t __n , int __flags ,
                                struct sockaddr *__addr , socklen_t *__addr_len ) __asm__("recvfrom") ;
extern ssize_t __recvfrom_chk_warn(int __fd , void *__buf , size_t __n , size_t __buflen ,
                                   int __flags , struct sockaddr *__addr , socklen_t *__addr_len ) __asm__("__recvfrom_chk") __attribute__((__warning__("recvfrom called with bigger length than size of destination buffer"))) ;
__inline extern ssize_t ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) recvfrom)(int __fd ,
                                                                                                       void *__buf ,
                                                                                                       size_t __n ,
                                                                                                       int __flags ,
                                                                                                       struct sockaddr * __restrict __cil_tmp12 ,
                                                                                                       socklen_t *__addr_len )
{
  __SOCKADDR_ARG __addr ;
  size_t sz ;
  unsigned long tmp ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  {
  __addr.__sockaddr__ = __cil_tmp12;
  tmp = __builtin_object_size(__buf, 0);
  sz = tmp;
  tmp___2 = __recvfrom_chk(__fd, (void * __restrict )__buf, __n, sz, __flags, __addr.__sockaddr__,
                           (socklen_t * __restrict )__addr_len);
  return (tmp___2);
}
}
extern struct in6_addr const in6addr_any ;
extern struct in6_addr const in6addr_loopback ;
extern uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong ) __attribute__((__nothrow__,
__const__)) ;
extern uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort ) __attribute__((__nothrow__,
__const__)) ;
extern uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong ) __attribute__((__nothrow__,
__const__)) ;
extern uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) bindresvport)(int __sockfd , struct sockaddr_in *__sock_in ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) bindresvport6)(int __sockfd , struct sockaddr_in6 *__sock_in ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) inet6_option_space)(int __nbytes ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__leaf__)) inet6_option_init)(void *__bp , struct cmsghdr **__cmsgp ,
                                                          int __type ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__leaf__)) inet6_option_append)(struct cmsghdr *__cmsg ,
                                                            uint8_t const *__typep ,
                                                            int __multx , int __plusy ) __attribute__((__nothrow__,
__deprecated__)) ;
extern uint8_t *( __attribute__((__leaf__)) inet6_option_alloc)(struct cmsghdr *__cmsg ,
                                                                int __datalen , int __multx ,
                                                                int __plusy ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__leaf__)) inet6_option_next)(struct cmsghdr const *__cmsg ,
                                                          uint8_t **__tptrp ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__leaf__)) inet6_option_find)(struct cmsghdr const *__cmsg ,
                                                          uint8_t **__tptrp , int __type ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__leaf__)) inet6_opt_init)(void *__extbuf , socklen_t __extlen ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) inet6_opt_append)(void *__extbuf , socklen_t __extlen ,
                                                         int __offset , uint8_t __type ,
                                                         socklen_t __len , uint8_t __align ,
                                                         void **__databufp ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) inet6_opt_finish)(void *__extbuf , socklen_t __extlen ,
                                                         int __offset ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) inet6_opt_set_val)(void *__databuf , int __offset ,
                                                          void *__val , socklen_t __vallen ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) inet6_opt_next)(void *__extbuf , socklen_t __extlen ,
                                                       int __offset , uint8_t *__typep ,
                                                       socklen_t *__lenp , void **__databufp ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) inet6_opt_find)(void *__extbuf , socklen_t __extlen ,
                                                       int __offset , uint8_t __type ,
                                                       socklen_t *__lenp , void **__databufp ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) inet6_opt_get_val)(void *__databuf , int __offset ,
                                                          void *__val , socklen_t __vallen ) __attribute__((__nothrow__)) ;
extern socklen_t ( __attribute__((__leaf__)) inet6_rth_space)(int __type , int __segments ) __attribute__((__nothrow__)) ;
extern void *( __attribute__((__leaf__)) inet6_rth_init)(void *__bp , socklen_t __bp_len ,
                                                         int __type , int __segments ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) inet6_rth_add)(void *__bp , struct in6_addr const *__addr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) inet6_rth_reverse)(void const *__in , void *__out ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) inet6_rth_segments)(void const *__bp ) __attribute__((__nothrow__)) ;
extern struct in6_addr *( __attribute__((__leaf__)) inet6_rth_getaddr)(void const *__bp ,
                                                                       int __index ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) getipv4sourcefilter)(int __s , struct in_addr __interface_addr ,
                                                            struct in_addr __group ,
                                                            uint32_t *__fmode , uint32_t *__numsrc ,
                                                            struct in_addr *__slist ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setipv4sourcefilter)(int __s , struct in_addr __interface_addr ,
                                                            struct in_addr __group ,
                                                            uint32_t __fmode , uint32_t __numsrc ,
                                                            struct in_addr const *__slist ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) getsourcefilter)(int __s , uint32_t __interface_addr ,
                                                        struct sockaddr const *__group ,
                                                        socklen_t __grouplen , uint32_t *__fmode ,
                                                        uint32_t *__numsrc , struct sockaddr_storage *__slist ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setsourcefilter)(int __s , uint32_t __interface_addr ,
                                                        struct sockaddr const *__group ,
                                                        socklen_t __grouplen , uint32_t __fmode ,
                                                        uint32_t __numsrc , struct sockaddr_storage const *__slist ) __attribute__((__nothrow__)) ;
extern in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const *__cp ) __attribute__((__nothrow__)) ;
extern in_addr_t ( __attribute__((__leaf__)) inet_lnaof)(struct in_addr __in ) __attribute__((__nothrow__)) ;
extern struct in_addr ( __attribute__((__leaf__)) inet_makeaddr)(in_addr_t __net ,
                                                                 in_addr_t __host ) __attribute__((__nothrow__)) ;
extern in_addr_t ( __attribute__((__leaf__)) inet_netof)(struct in_addr __in ) __attribute__((__nothrow__)) ;
extern in_addr_t ( __attribute__((__leaf__)) inet_network)(char const *__cp ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) inet_pton)(int __af , char const *__cp ,
                                                  void *__buf ) __attribute__((__nothrow__)) ;
extern char const *( __attribute__((__leaf__)) inet_ntop)(int __af , void const *__cp ,
                                                            char *__buf , socklen_t __len ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) inet_aton)(char const *__cp , struct in_addr *__inp ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__leaf__)) inet_neta)(in_addr_t __net , char *__buf ,
                                                    size_t __len ) __attribute__((__nothrow__,
__deprecated__("Use inet_ntop instead"))) ;
extern char *( __attribute__((__leaf__)) inet_net_ntop)(int __af , void const *__cp ,
                                                        int __bits , char *__buf ,
                                                        size_t __len ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) inet_net_pton)(int __af , char const *__cp ,
                                                      void *__buf , size_t __len ) __attribute__((__nothrow__)) ;
extern unsigned int ( __attribute__((__leaf__)) inet_nsap_addr)(char const *__cp ,
                                                                unsigned char *__buf ,
                                                                int __len ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__leaf__)) inet_nsap_ntoa)(int __len , unsigned char const *__cp ,
                                                         char *__buf ) __attribute__((__nothrow__)) ;
extern void assert(int expression ) ;
extern unsigned short const **( __attribute__((__leaf__)) __ctype_b_loc)(void) __attribute__((__nothrow__,
__const__)) ;
extern __int32_t const **( __attribute__((__leaf__)) __ctype_tolower_loc)(void) __attribute__((__nothrow__,
__const__)) ;
extern __int32_t const **( __attribute__((__leaf__)) __ctype_toupper_loc)(void) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) isalnum)(int ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isalpha)(int ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) iscntrl)(int ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isdigit)(int ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) islower)(int ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isgraph)(int ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isprint)(int ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ispunct)(int ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isspace)(int ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isupper)(int ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isxdigit)(int ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) tolower)(int __c ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) toupper)(int __c ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isblank)(int ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isctype)(int __c , int __mask ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isascii)(int __c ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) toascii)(int __c ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) _toupper)(int ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) _tolower)(int ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) tolower)(int __c ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) tolower)(int __c )
{
  __int32_t const **tmp ;
  __int32_t tmp___0 ;
  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_tolower_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const )__c;
    }
  } else {
    tmp___0 = (__int32_t const )__c;
  }
  return ((int )tmp___0);
}
}
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) toupper)(int __c ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) toupper)(int __c )
{
  __int32_t const **tmp ;
  __int32_t tmp___0 ;
  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_toupper_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const )__c;
    }
  } else {
    tmp___0 = (__int32_t const )__c;
  }
  return ((int )tmp___0);
}
}
extern int ( __attribute__((__leaf__)) isalnum_l)(int , locale_t ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isalpha_l)(int , locale_t ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) iscntrl_l)(int , locale_t ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isdigit_l)(int , locale_t ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) islower_l)(int , locale_t ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isgraph_l)(int , locale_t ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isprint_l)(int , locale_t ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ispunct_l)(int , locale_t ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isspace_l)(int , locale_t ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isupper_l)(int , locale_t ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isxdigit_l)(int , locale_t ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isblank_l)(int , locale_t ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __tolower_l)(int __c , locale_t __l ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) tolower_l)(int __c , locale_t __l ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __toupper_l)(int __c , locale_t __l ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) toupper_l)(int __c , locale_t __l ) __attribute__((__nothrow__)) ;
extern int *( __attribute__((__leaf__)) __errno_location)(void) __attribute__((__nothrow__,
__const__)) ;
extern char *program_invocation_name ;
extern char *program_invocation_short_name ;
extern __ssize_t ( __attribute__((__leaf__)) readahead)(int __fd , __off64_t __offset ,
                                                        size_t __count ) __attribute__((__nothrow__)) ;
extern int sync_file_range(int __fd , __off64_t __offset , __off64_t __count , unsigned int __flags ) ;
extern __ssize_t vmsplice(int __fdout , struct iovec const *__iov , size_t __count ,
                          unsigned int __flags ) ;
extern __ssize_t splice(int __fdin , __off64_t *__offin , int __fdout , __off64_t *__offout ,
                        size_t __len , unsigned int __flags ) ;
extern __ssize_t tee(int __fdin , int __fdout , size_t __len , unsigned int __flags ) ;
extern int fallocate(int __fd , int __mode , __off_t __offset , __off_t __len ) ;
extern int fallocate64(int __fd , int __mode , __off64_t __offset , __off64_t __len ) ;
extern int ( __attribute__((__leaf__)) name_to_handle_at)(int __dfd , char const *__name ,
                                                          struct file_handle *__handle ,
                                                          int *__mnt_id , int __flags ) __attribute__((__nothrow__)) ;
extern int open_by_handle_at(int __mountdirfd , struct file_handle *__handle , int __flags ) ;
extern int fcntl(int __fd , int __cmd , ...) ;
extern int fcntl64(int __fd , int __cmd , ...) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __artificial__,
__always_inline__)) open)(char const *__path , int __oflag , ...) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __artificial__,
__always_inline__)) open64)(char const *__path , int __oflag , ...) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__, __artificial__,
__always_inline__)) openat)(int __fd , char const *__path , int __oflag , ...) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__, __artificial__,
__always_inline__)) openat64)(int __fd , char const *__path , int __oflag , ...) ;
extern int ( __attribute__((__nonnull__(1))) creat)(char const *__file , mode_t __mode ) ;
extern int ( __attribute__((__nonnull__(1))) creat64)(char const *__file , mode_t __mode ) ;
extern int lockf(int __fd , int __cmd , off_t __len ) ;
extern int lockf64(int __fd , int __cmd , off64_t __len ) ;
extern int ( __attribute__((__leaf__)) posix_fadvise)(int __fd , off_t __offset ,
                                                      off_t __len , int __advise ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) posix_fadvise64)(int __fd , off64_t __offset ,
                                                        off64_t __len , int __advise ) __attribute__((__nothrow__)) ;
extern int posix_fallocate(int __fd , off_t __offset , off_t __len ) ;
extern int posix_fallocate64(int __fd , off64_t __offset , off64_t __len ) ;
extern int ( __attribute__((__nonnull__(1))) __open_2)(char const *__path , int __oflag ) ;
extern int ( __attribute__((__nonnull__(1))) __open_alias)(char const *__path ,
                                                           int __oflag , ...) __asm__("open") ;
extern void __open_too_many_args(void) __attribute__((__error__("open can be called either with 2 or 3 arguments, not more"))) ;
extern void __open_missing_mode(void) __attribute__((__error__("open with O_CREAT or O_TMPFILE in second argument needs 3 arguments"))) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __artificial__,
__always_inline__)) open)(char const *__path , int __oflag , ...)
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  {
  tmp = __builtin_va_arg_pack_len();
  if (tmp > 1) {
    __open_too_many_args();
  }
  if (0) {
    if ((__oflag & 0100) != 0) {
      goto _L;
    } else
    if ((__oflag & 4259840) == 4259840) {
      _L:
      tmp___1 = __builtin_va_arg_pack_len();
      if (tmp___1 < 1) {
        __open_missing_mode();
        tmp___0 = __open_2(__path, __oflag);
        return (tmp___0);
      }
    }
    tmp___2 = __open_alias(__path, __oflag, __builtin_va_arg_pack());
    return (tmp___2);
  }
  tmp___4 = __builtin_va_arg_pack_len();
  if (tmp___4 < 1) {
    tmp___3 = __open_2(__path, __oflag);
    return (tmp___3);
  }
  tmp___5 = __open_alias(__path, __oflag, __builtin_va_arg_pack());
  return (tmp___5);
}
}
extern int ( __attribute__((__nonnull__(1))) __open64_2)(char const *__path , int __oflag ) ;
extern int ( __attribute__((__nonnull__(1))) __open64_alias)(char const *__path ,
                                                             int __oflag , ...) __asm__("open64") ;
extern void __open64_too_many_args(void) __attribute__((__error__("open64 can be called either with 2 or 3 arguments, not more"))) ;
extern void __open64_missing_mode(void) __attribute__((__error__("open64 with O_CREAT or O_TMPFILE in second argument needs 3 arguments"))) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __artificial__,
__always_inline__)) open64)(char const *__path , int __oflag , ...)
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  {
  tmp = __builtin_va_arg_pack_len();
  if (tmp > 1) {
    __open64_too_many_args();
  }
  if (0) {
    if ((__oflag & 0100) != 0) {
      goto _L;
    } else
    if ((__oflag & 4259840) == 4259840) {
      _L:
      tmp___1 = __builtin_va_arg_pack_len();
      if (tmp___1 < 1) {
        __open64_missing_mode();
        tmp___0 = __open64_2(__path, __oflag);
        return (tmp___0);
      }
    }
    tmp___2 = __open64_alias(__path, __oflag, __builtin_va_arg_pack());
    return (tmp___2);
  }
  tmp___4 = __builtin_va_arg_pack_len();
  if (tmp___4 < 1) {
    tmp___3 = __open64_2(__path, __oflag);
    return (tmp___3);
  }
  tmp___5 = __open64_alias(__path, __oflag, __builtin_va_arg_pack());
  return (tmp___5);
}
}
extern int ( __attribute__((__nonnull__(2))) __openat_2)(int __fd , char const *__path ,
                                                         int __oflag ) ;
extern int ( __attribute__((__nonnull__(2))) __openat_alias)(int __fd , char const *__path ,
                                                             int __oflag , ...) __asm__("openat") ;
extern void __openat_too_many_args(void) __attribute__((__error__("openat can be called either with 3 or 4 arguments, not more"))) ;
extern void __openat_missing_mode(void) __attribute__((__error__("openat with O_CREAT or O_TMPFILE in third argument needs 4 arguments"))) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__, __artificial__,
__always_inline__)) openat)(int __fd , char const *__path , int __oflag , ...)
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  {
  tmp = __builtin_va_arg_pack_len();
  if (tmp > 1) {
    __openat_too_many_args();
  }
  if (0) {
    if ((__oflag & 0100) != 0) {
      goto _L;
    } else
    if ((__oflag & 4259840) == 4259840) {
      _L:
      tmp___1 = __builtin_va_arg_pack_len();
      if (tmp___1 < 1) {
        __openat_missing_mode();
        tmp___0 = __openat_2(__fd, __path, __oflag);
        return (tmp___0);
      }
    }
    tmp___2 = __openat_alias(__fd, __path, __oflag, __builtin_va_arg_pack());
    return (tmp___2);
  }
  tmp___4 = __builtin_va_arg_pack_len();
  if (tmp___4 < 1) {
    tmp___3 = __openat_2(__fd, __path, __oflag);
    return (tmp___3);
  }
  tmp___5 = __openat_alias(__fd, __path, __oflag, __builtin_va_arg_pack());
  return (tmp___5);
}
}
extern int ( __attribute__((__nonnull__(2))) __openat64_2)(int __fd , char const *__path ,
                                                           int __oflag ) ;
extern int ( __attribute__((__nonnull__(2))) __openat64_alias)(int __fd , char const *__path ,
                                                               int __oflag , ...) __asm__("openat64") ;
extern void __openat64_too_many_args(void) __attribute__((__error__("openat64 can be called either with 3 or 4 arguments, not more"))) ;
extern void __openat64_missing_mode(void) __attribute__((__error__("openat64 with O_CREAT or O_TMPFILE in third argument needs 4 arguments"))) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__, __artificial__,
__always_inline__)) openat64)(int __fd , char const *__path , int __oflag , ...)
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  {
  tmp = __builtin_va_arg_pack_len();
  if (tmp > 1) {
    __openat64_too_many_args();
  }
  if (0) {
    if ((__oflag & 0100) != 0) {
      goto _L;
    } else
    if ((__oflag & 4259840) == 4259840) {
      _L:
      tmp___1 = __builtin_va_arg_pack_len();
      if (tmp___1 < 1) {
        __openat64_missing_mode();
        tmp___0 = __openat64_2(__fd, __path, __oflag);
        return (tmp___0);
      }
    }
    tmp___2 = __openat64_alias(__fd, __path, __oflag, __builtin_va_arg_pack());
    return (tmp___2);
  }
  tmp___4 = __builtin_va_arg_pack_len();
  if (tmp___4 < 1) {
    tmp___3 = __openat64_2(__fd, __path, __oflag);
    return (tmp___3);
  }
  tmp___5 = __openat64_alias(__fd, __path, __oflag, __builtin_va_arg_pack());
  return (tmp___5);
}
}
extern int glob(char const *__pattern , int __flags , int (*__errfunc)(char const * ,
                                                                         int ) ,
                glob_t *__pglob ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) globfree)(glob_t *__pglob ) __attribute__((__nothrow__)) ;
extern int glob64(char const *__pattern , int __flags , int (*__errfunc)(char const * ,
                                                                           int ) ,
                  glob64_t *__pglob ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) globfree64)(glob64_t *__pglob ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) glob_pattern_p)(char const *__pattern , int __quote ) __attribute__((__nothrow__)) ;
extern void setgrent(void) ;
extern void endgrent(void) ;
extern struct group *getgrent(void) ;
extern struct group *fgetgrent(FILE *__stream ) ;
extern int putgrent(struct group const *__p , FILE *__f ) ;
extern struct group *getgrgid(__gid_t __gid ) ;
extern struct group *getgrnam(char const *__name ) ;
extern int getgrent_r(struct group *__resultbuf , char *__buffer , size_t __buflen ,
                      struct group **__result ) ;
extern int getgrgid_r(__gid_t __gid , struct group *__resultbuf , char *__buffer ,
                      size_t __buflen , struct group **__result ) ;
extern int getgrnam_r(char const *__name , struct group *__resultbuf , char *__buffer ,
                      size_t __buflen , struct group **__result ) ;
extern int fgetgrent_r(FILE *__stream , struct group *__resultbuf , char *__buffer ,
                       size_t __buflen , struct group **__result ) ;
extern int ( __attribute__((__leaf__)) setgroups)(size_t __n , __gid_t const *__groups ) __attribute__((__nothrow__)) ;
extern int getgrouplist(char const *__user , __gid_t __group , __gid_t *__groups ,
                        int *__ngroups ) ;
extern int initgroups(char const *__user , __gid_t __group ) ;
extern intmax_t ( __attribute__((__leaf__)) imaxabs)(intmax_t __n ) __attribute__((__nothrow__,
__const__)) ;
extern imaxdiv_t ( __attribute__((__leaf__)) imaxdiv)(intmax_t __numer , intmax_t __denom ) __attribute__((__nothrow__,
__const__)) ;
extern intmax_t ( __attribute__((__leaf__)) strtoimax)(char const *__nptr , char **__endptr ,
                                                       int __base ) __attribute__((__nothrow__)) ;
extern uintmax_t ( __attribute__((__leaf__)) strtoumax)(char const *__nptr , char **__endptr ,
                                                        int __base ) __attribute__((__nothrow__)) ;
extern intmax_t ( __attribute__((__leaf__)) wcstoimax)(__gwchar_t const *__nptr ,
                                                       __gwchar_t **__endptr , int __base ) __attribute__((__nothrow__)) ;
extern uintmax_t ( __attribute__((__leaf__)) wcstoumax)(__gwchar_t const *__nptr ,
                                                        __gwchar_t **__endptr , int __base ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __sysconf)(int __name ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __fpclassify)(double __value ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) __signbit)(double __value ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) __isinf)(double __value ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) __finite)(double __value ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) __isnan)(double __value ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) __iseqsig)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __issignaling)(double __value ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) acos)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __acos)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) asin)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __asin)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) atan)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __atan)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) atan2)(double __y , double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __atan2)(double __y , double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) cos)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __cos)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) sin)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __sin)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) tan)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __tan)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) cosh)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __cosh)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) sinh)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __sinh)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) tanh)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __tanh)(double __x ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) sincos)(double __x , double *__sinx , double *__cosx ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) __sincos)(double __x , double *__sinx , double *__cosx ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) acosh)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __acosh)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) asinh)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __asinh)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) atanh)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __atanh)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) exp)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __exp)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) frexp)(double __x , int *__exponent ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __frexp)(double __x , int *__exponent ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) ldexp)(double __x , int __exponent ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __ldexp)(double __x , int __exponent ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) log)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __log)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) log10)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __log10)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) modf)(double __x , double *__iptr ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__nonnull__(2), __leaf__)) __modf)(double __x , double *__iptr ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) exp10)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __exp10)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) expm1)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __expm1)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) log1p)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __log1p)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) logb)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __logb)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) exp2)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __exp2)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) log2)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __log2)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) pow)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __pow)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) sqrt)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __sqrt)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) hypot)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __hypot)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) cbrt)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __cbrt)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) ceil)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __ceil)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fabs)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fabs)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) floor)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __floor)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fmod)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __fmod)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isinf)(double __value ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) finite)(double __value ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) drem)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __drem)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) significand)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __significand)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) copysign)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __copysign)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) nan)(char const *__tagb ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __nan)(char const *__tagb ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isnan)(double __value ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) j0)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __j0)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) j1)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __j1)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) jn)(int , double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __jn)(int , double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) y0)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __y0)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) y1)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __y1)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) yn)(int , double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __yn)(int , double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) erf)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __erf)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) erfc)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __erfc)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) lgamma)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __lgamma)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) tgamma)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __tgamma)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) gamma)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __gamma)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) lgamma_r)(double , int *__signgamp ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __lgamma_r)(double , int *__signgamp ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) rint)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __rint)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) nextafter)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __nextafter)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) nexttoward)(double __x , long double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __nexttoward)(double __x , long double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) nextdown)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __nextdown)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) nextup)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __nextup)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) remainder)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __remainder)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) scalbn)(double __x , int __n ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __scalbn)(double __x , int __n ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ilogb)(double __x ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __ilogb)(double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) llogb)(double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __llogb)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) scalbln)(double __x , long __n ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __scalbln)(double __x , long __n ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) nearbyint)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __nearbyint)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) round)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __round)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) trunc)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __trunc)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) remquo)(double __x , double __y , int *__quo ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __remquo)(double __x , double __y , int *__quo ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) lrint)(double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __lrint)(double __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) llrint)(double __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) __llrint)(double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) lround)(double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __lround)(double __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) llround)(double __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) __llround)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) fdim)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __fdim)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) fmax)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fmax)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fmin)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fmin)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fma)(double __x , double __y , double __z ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __fma)(double __x , double __y , double __z ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) roundeven)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __roundeven)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern __intmax_t ( __attribute__((__leaf__)) fromfp)(double __x , int __round , unsigned int __width ) __attribute__((__nothrow__)) ;
extern __intmax_t ( __attribute__((__leaf__)) __fromfp)(double __x , int __round ,
                                                        unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) ufromfp)(double __x , int __round ,
                                                        unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfp)(double __x , int __round ,
                                                          unsigned int __width ) __attribute__((__nothrow__)) ;
extern __intmax_t ( __attribute__((__leaf__)) fromfpx)(double __x , int __round ,
                                                       unsigned int __width ) __attribute__((__nothrow__)) ;
extern __intmax_t ( __attribute__((__leaf__)) __fromfpx)(double __x , int __round ,
                                                         unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpx)(double __x , int __round ,
                                                         unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpx)(double __x , int __round ,
                                                           unsigned int __width ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) canonicalize)(double *__cx , double const *__x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) fmaxmag)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fmaxmag)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fminmag)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fminmag)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fmaximum)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fmaximum)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fminimum)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fminimum)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fmaximum_num)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fmaximum_num)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fminimum_num)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fminimum_num)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fmaximum_mag)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fmaximum_mag)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fminimum_mag)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fminimum_mag)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fmaximum_mag_num)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fmaximum_mag_num)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fminimum_mag_num)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fminimum_mag_num)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) totalorder)(double const *__x , double const *__y ) __attribute__((__pure__,
__nothrow__)) ;
extern int ( __attribute__((__leaf__)) totalordermag)(double const *__x , double const *__y ) __attribute__((__pure__,
__nothrow__)) ;
extern double ( __attribute__((__leaf__)) getpayload)(double const *__x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __getpayload)(double const *__x ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setpayload)(double *__x , double __payload ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setpayloadsig)(double *__x , double __payload ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) scalb)(double __x , double __n ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __scalb)(double __x , double __n ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __fpclassifyf)(float __value ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) __signbitf)(float __value ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) __isinff)(float __value ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) __finitef)(float __value ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) __isnanf)(float __value ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) __iseqsigf)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __issignalingf)(float __value ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) acosf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __acosf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) asinf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __asinf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) atanf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __atanf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) atan2f)(float __y , float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __atan2f)(float __y , float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) cosf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __cosf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) sinf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __sinf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) tanf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __tanf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) coshf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __coshf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) sinhf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __sinhf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) tanhf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __tanhf)(float __x ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) sincosf)(float __x , float *__sinx , float *__cosx ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) __sincosf)(float __x , float *__sinx , float *__cosx ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) acoshf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __acoshf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) asinhf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __asinhf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) atanhf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __atanhf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) expf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __expf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) frexpf)(float __x , int *__exponent ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __frexpf)(float __x , int *__exponent ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) ldexpf)(float __x , int __exponent ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __ldexpf)(float __x , int __exponent ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) logf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __logf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) log10f)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __log10f)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) modff)(float __x , float *__iptr ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__nonnull__(2), __leaf__)) __modff)(float __x , float *__iptr ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) exp10f)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __exp10f)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) expm1f)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __expm1f)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) log1pf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __log1pf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) logbf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __logbf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) exp2f)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __exp2f)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) log2f)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __log2f)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) powf)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __powf)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) sqrtf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __sqrtf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) hypotf)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __hypotf)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) cbrtf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __cbrtf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) ceilf)(float __x ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __ceilf)(float __x ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fabsf)(float __x ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fabsf)(float __x ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) floorf)(float __x ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __floorf)(float __x ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fmodf)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __fmodf)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isinff)(float __value ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) finitef)(float __value ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) dremf)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __dremf)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) significandf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __significandf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) copysignf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __copysignf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) nanf)(char const *__tagb ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __nanf)(char const *__tagb ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isnanf)(float __value ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) j0f)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __j0f)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) j1f)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __j1f)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) jnf)(int , float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __jnf)(int , float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) y0f)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __y0f)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) y1f)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __y1f)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) ynf)(int , float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __ynf)(int , float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) erff)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __erff)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) erfcf)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __erfcf)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) lgammaf)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __lgammaf)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) tgammaf)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __tgammaf)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) gammaf)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __gammaf)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) lgammaf_r)(float , int *__signgamp ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __lgammaf_r)(float , int *__signgamp ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) rintf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __rintf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) nextafterf)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __nextafterf)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) nexttowardf)(float __x , long double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __nexttowardf)(float __x , long double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) nextdownf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __nextdownf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) nextupf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __nextupf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) remainderf)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __remainderf)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) scalbnf)(float __x , int __n ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __scalbnf)(float __x , int __n ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ilogbf)(float __x ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __ilogbf)(float __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) llogbf)(float __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __llogbf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) scalblnf)(float __x , long __n ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __scalblnf)(float __x , long __n ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) nearbyintf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __nearbyintf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) roundf)(float __x ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __roundf)(float __x ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) truncf)(float __x ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __truncf)(float __x ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) remquof)(float __x , float __y , int *__quo ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __remquof)(float __x , float __y , int *__quo ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) lrintf)(float __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __lrintf)(float __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) llrintf)(float __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) __llrintf)(float __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) lroundf)(float __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __lroundf)(float __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) llroundf)(float __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) __llroundf)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) fdimf)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __fdimf)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) fmaxf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fmaxf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fminf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fminf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fmaf)(float __x , float __y , float __z ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __fmaf)(float __x , float __y , float __z ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) roundevenf)(float __x ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __roundevenf)(float __x ) __attribute__((__nothrow__,
__const__)) ;
extern __intmax_t ( __attribute__((__leaf__)) fromfpf)(float __x , int __round , unsigned int __width ) __attribute__((__nothrow__)) ;
extern __intmax_t ( __attribute__((__leaf__)) __fromfpf)(float __x , int __round ,
                                                         unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpf)(float __x , int __round ,
                                                         unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpf)(float __x , int __round ,
                                                           unsigned int __width ) __attribute__((__nothrow__)) ;
extern __intmax_t ( __attribute__((__leaf__)) fromfpxf)(float __x , int __round ,
                                                        unsigned int __width ) __attribute__((__nothrow__)) ;
extern __intmax_t ( __attribute__((__leaf__)) __fromfpxf)(float __x , int __round ,
                                                          unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpxf)(float __x , int __round ,
                                                          unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpxf)(float __x , int __round ,
                                                            unsigned int __width ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) canonicalizef)(float *__cx , float const *__x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) fmaxmagf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fmaxmagf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fminmagf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fminmagf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fmaximumf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fmaximumf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fminimumf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fminimumf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fmaximum_numf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fmaximum_numf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fminimum_numf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fminimum_numf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fmaximum_magf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fmaximum_magf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fminimum_magf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fminimum_magf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fmaximum_mag_numf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fmaximum_mag_numf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fminimum_mag_numf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fminimum_mag_numf)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) totalorderf)(float const *__x , float const *__y ) __attribute__((__pure__,
__nothrow__)) ;
extern int ( __attribute__((__leaf__)) totalordermagf)(float const *__x , float const *__y ) __attribute__((__pure__,
__nothrow__)) ;
extern float ( __attribute__((__leaf__)) getpayloadf)(float const *__x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __getpayloadf)(float const *__x ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setpayloadf)(float *__x , float __payload ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setpayloadsigf)(float *__x , float __payload ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) scalbf)(float __x , float __n ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __scalbf)(float __x , float __n ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __fpclassifyl)(long double __value ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) __signbitl)(long double __value ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) __isinfl)(long double __value ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) __finitel)(long double __value ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) __isnanl)(long double __value ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) __iseqsigl)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __issignalingl)(long double __value ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) acosl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __acosl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) asinl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __asinl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) atanl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __atanl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) atan2l)(long double __y , long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __atan2l)(long double __y , long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) cosl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __cosl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) sinl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __sinl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) tanl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __tanl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) coshl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __coshl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) sinhl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __sinhl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) tanhl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __tanhl)(long double __x ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) sincosl)(long double __x , long double *__sinx ,
                                                 long double *__cosx ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) __sincosl)(long double __x , long double *__sinx ,
                                                   long double *__cosx ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) acoshl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __acoshl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) asinhl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __asinhl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) atanhl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __atanhl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) expl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __expl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) frexpl)(long double __x , int *__exponent ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __frexpl)(long double __x , int *__exponent ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) ldexpl)(long double __x , int __exponent ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __ldexpl)(long double __x , int __exponent ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) logl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __logl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) log10l)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __log10l)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) modfl)(long double __x , long double *__iptr ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__nonnull__(2), __leaf__)) __modfl)(long double __x ,
                                                                        long double *__iptr ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) exp10l)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __exp10l)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) expm1l)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __expm1l)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) log1pl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __log1pl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) logbl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __logbl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) exp2l)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __exp2l)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) log2l)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __log2l)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) powl)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __powl)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) sqrtl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __sqrtl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) hypotl)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __hypotl)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) cbrtl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __cbrtl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) ceill)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __ceill)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fabsl)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fabsl)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) floorl)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __floorl)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fmodl)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __fmodl)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isinfl)(long double __value ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) finitel)(long double __value ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) dreml)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __dreml)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) significandl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __significandl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) copysignl)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __copysignl)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) nanl)(char const *__tagb ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __nanl)(char const *__tagb ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) isnanl)(long double __value ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) j0l)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __j0l)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) j1l)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __j1l)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) jnl)(int , long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __jnl)(int , long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) y0l)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __y0l)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) y1l)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __y1l)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) ynl)(int , long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __ynl)(int , long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) erfl)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __erfl)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) erfcl)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __erfcl)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) lgammal)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __lgammal)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) tgammal)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __tgammal)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) gammal)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __gammal)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) lgammal_r)(long double , int *__signgamp ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __lgammal_r)(long double , int *__signgamp ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) rintl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __rintl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) nextafterl)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __nextafterl)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) nexttowardl)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __nexttowardl)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) nextdownl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __nextdownl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) nextupl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __nextupl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) remainderl)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __remainderl)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) scalbnl)(long double __x , int __n ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __scalbnl)(long double __x , int __n ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ilogbl)(long double __x ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __ilogbl)(long double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) llogbl)(long double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __llogbl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) scalblnl)(long double __x , long __n ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __scalblnl)(long double __x , long __n ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) nearbyintl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __nearbyintl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) roundl)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __roundl)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) truncl)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __truncl)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) remquol)(long double __x , long double __y ,
                                                        int *__quo ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __remquol)(long double __x , long double __y ,
                                                          int *__quo ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) lrintl)(long double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __lrintl)(long double __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) llrintl)(long double __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) __llrintl)(long double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) lroundl)(long double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __lroundl)(long double __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) llroundl)(long double __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) __llroundl)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) fdiml)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __fdiml)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) fmaxl)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fmaxl)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fminl)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fminl)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fmal)(long double __x , long double __y ,
                                                     long double __z ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __fmal)(long double __x , long double __y ,
                                                       long double __z ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) roundevenl)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __roundevenl)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern __intmax_t ( __attribute__((__leaf__)) fromfpl)(long double __x , int __round ,
                                                       unsigned int __width ) __attribute__((__nothrow__)) ;
extern __intmax_t ( __attribute__((__leaf__)) __fromfpl)(long double __x , int __round ,
                                                         unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpl)(long double __x , int __round ,
                                                         unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpl)(long double __x , int __round ,
                                                           unsigned int __width ) __attribute__((__nothrow__)) ;
extern __intmax_t ( __attribute__((__leaf__)) fromfpxl)(long double __x , int __round ,
                                                        unsigned int __width ) __attribute__((__nothrow__)) ;
extern __intmax_t ( __attribute__((__leaf__)) __fromfpxl)(long double __x , int __round ,
                                                          unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpxl)(long double __x , int __round ,
                                                          unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpxl)(long double __x , int __round ,
                                                            unsigned int __width ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) canonicalizel)(long double *__cx , long double const *__x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) fmaxmagl)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fmaxmagl)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fminmagl)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fminmagl)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fmaximuml)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fmaximuml)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fminimuml)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fminimuml)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fmaximum_numl)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fmaximum_numl)(long double __x ,
                                                                long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fminimum_numl)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fminimum_numl)(long double __x ,
                                                                long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fmaximum_magl)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fmaximum_magl)(long double __x ,
                                                                long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fminimum_magl)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fminimum_magl)(long double __x ,
                                                                long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fmaximum_mag_numl)(long double __x ,
                                                                  long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fmaximum_mag_numl)(long double __x ,
                                                                    long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fminimum_mag_numl)(long double __x ,
                                                                  long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fminimum_mag_numl)(long double __x ,
                                                                    long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) totalorderl)(long double const *__x , long double const *__y ) __attribute__((__pure__,
__nothrow__)) ;
extern int ( __attribute__((__leaf__)) totalordermagl)(long double const *__x ,
                                                       long double const *__y ) __attribute__((__pure__,
__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) getpayloadl)(long double const *__x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __getpayloadl)(long double const *__x ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setpayloadl)(long double *__x , long double __payload ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setpayloadsigl)(long double *__x , long double __payload ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) scalbl)(long double __x , long double __n ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __scalbl)(long double __x , long double __n ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) acosf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __acosf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) asinf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __asinf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) atanf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __atanf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) atan2f32)(float __y , float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __atan2f32)(float __y , float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) cosf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __cosf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) sinf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __sinf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) tanf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __tanf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) coshf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __coshf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) sinhf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __sinhf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) tanhf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __tanhf32)(float __x ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) sincosf32)(float __x , float *__sinx , float *__cosx ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) __sincosf32)(float __x , float *__sinx , float *__cosx ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) acoshf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __acoshf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) asinhf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __asinhf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) atanhf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __atanhf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) expf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __expf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) frexpf32)(float __x , int *__exponent ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __frexpf32)(float __x , int *__exponent ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) ldexpf32)(float __x , int __exponent ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __ldexpf32)(float __x , int __exponent ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) logf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __logf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) log10f32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __log10f32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) modff32)(float __x , float *__iptr ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__nonnull__(2), __leaf__)) __modff32)(float __x , float *__iptr ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) exp10f32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __exp10f32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) expm1f32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __expm1f32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) log1pf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __log1pf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) logbf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __logbf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) exp2f32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __exp2f32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) log2f32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __log2f32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) powf32)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __powf32)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) sqrtf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __sqrtf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) hypotf32)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __hypotf32)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) cbrtf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __cbrtf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) ceilf32)(float __x ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __ceilf32)(float __x ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fabsf32)(float __x ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fabsf32)(float __x ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) floorf32)(float __x ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __floorf32)(float __x ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fmodf32)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __fmodf32)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) copysignf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __copysignf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) nanf32)(char const *__tagb ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __nanf32)(char const *__tagb ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) j0f32)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __j0f32)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) j1f32)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __j1f32)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) jnf32)(int , float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __jnf32)(int , float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) y0f32)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __y0f32)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) y1f32)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __y1f32)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) ynf32)(int , float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __ynf32)(int , float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) erff32)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __erff32)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) erfcf32)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __erfcf32)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) lgammaf32)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __lgammaf32)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) tgammaf32)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __tgammaf32)(float ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) lgammaf32_r)(float , int *__signgamp ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __lgammaf32_r)(float , int *__signgamp ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) rintf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __rintf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) nextafterf32)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __nextafterf32)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) nextdownf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __nextdownf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) nextupf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __nextupf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) remainderf32)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __remainderf32)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) scalbnf32)(float __x , int __n ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __scalbnf32)(float __x , int __n ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ilogbf32)(float __x ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __ilogbf32)(float __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) llogbf32)(float __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __llogbf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) scalblnf32)(float __x , long __n ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __scalblnf32)(float __x , long __n ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) nearbyintf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __nearbyintf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) roundf32)(float __x ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __roundf32)(float __x ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) truncf32)(float __x ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __truncf32)(float __x ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) remquof32)(float __x , float __y , int *__quo ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __remquof32)(float __x , float __y , int *__quo ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) lrintf32)(float __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __lrintf32)(float __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) llrintf32)(float __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) __llrintf32)(float __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) lroundf32)(float __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __lroundf32)(float __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) llroundf32)(float __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) __llroundf32)(float __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) fdimf32)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __fdimf32)(float __x , float __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) fmaxf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fmaxf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fminf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fminf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fmaf32)(float __x , float __y , float __z ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __fmaf32)(float __x , float __y , float __z ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) roundevenf32)(float __x ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __roundevenf32)(float __x ) __attribute__((__nothrow__,
__const__)) ;
extern __intmax_t ( __attribute__((__leaf__)) fromfpf32)(float __x , int __round ,
                                                         unsigned int __width ) __attribute__((__nothrow__)) ;
extern __intmax_t ( __attribute__((__leaf__)) __fromfpf32)(float __x , int __round ,
                                                           unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpf32)(float __x , int __round ,
                                                           unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpf32)(float __x , int __round ,
                                                             unsigned int __width ) __attribute__((__nothrow__)) ;
extern __intmax_t ( __attribute__((__leaf__)) fromfpxf32)(float __x , int __round ,
                                                          unsigned int __width ) __attribute__((__nothrow__)) ;
extern __intmax_t ( __attribute__((__leaf__)) __fromfpxf32)(float __x , int __round ,
                                                            unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpxf32)(float __x , int __round ,
                                                            unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpxf32)(float __x , int __round ,
                                                              unsigned int __width ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) canonicalizef32)(float *__cx , float const *__x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) fmaxmagf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fmaxmagf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fminmagf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fminmagf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fmaximumf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fmaximumf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fminimumf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fminimumf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fmaximum_numf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fmaximum_numf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fminimum_numf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fminimum_numf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fmaximum_magf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fmaximum_magf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fminimum_magf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fminimum_magf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fmaximum_mag_numf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fmaximum_mag_numf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) fminimum_mag_numf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern float ( __attribute__((__leaf__)) __fminimum_mag_numf32)(float __x , float __y ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) totalorderf32)(float const *__x , float const *__y ) __attribute__((__pure__,
__nothrow__)) ;
extern int ( __attribute__((__leaf__)) totalordermagf32)(float const *__x , float const *__y ) __attribute__((__pure__,
__nothrow__)) ;
extern float ( __attribute__((__leaf__)) getpayloadf32)(float const *__x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) __getpayloadf32)(float const *__x ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setpayloadf32)(float *__x , float __payload ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setpayloadsigf32)(float *__x , float __payload ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) acosf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __acosf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) asinf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __asinf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) atanf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __atanf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) atan2f64)(double __y , double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __atan2f64)(double __y , double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) cosf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __cosf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) sinf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __sinf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) tanf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __tanf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) coshf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __coshf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) sinhf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __sinhf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) tanhf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __tanhf64)(double __x ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) sincosf64)(double __x , double *__sinx , double *__cosx ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) __sincosf64)(double __x , double *__sinx ,
                                                     double *__cosx ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) acoshf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __acoshf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) asinhf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __asinhf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) atanhf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __atanhf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) expf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __expf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) frexpf64)(double __x , int *__exponent ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __frexpf64)(double __x , int *__exponent ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) ldexpf64)(double __x , int __exponent ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __ldexpf64)(double __x , int __exponent ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) logf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __logf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) log10f64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __log10f64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) modff64)(double __x , double *__iptr ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__nonnull__(2), __leaf__)) __modff64)(double __x ,
                                                                     double *__iptr ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) exp10f64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __exp10f64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) expm1f64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __expm1f64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) log1pf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __log1pf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) logbf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __logbf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) exp2f64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __exp2f64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) log2f64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __log2f64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) powf64)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __powf64)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) sqrtf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __sqrtf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) hypotf64)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __hypotf64)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) cbrtf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __cbrtf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) ceilf64)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __ceilf64)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fabsf64)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fabsf64)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) floorf64)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __floorf64)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fmodf64)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __fmodf64)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) copysignf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __copysignf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) nanf64)(char const *__tagb ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __nanf64)(char const *__tagb ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) j0f64)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __j0f64)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) j1f64)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __j1f64)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) jnf64)(int , double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __jnf64)(int , double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) y0f64)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __y0f64)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) y1f64)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __y1f64)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) ynf64)(int , double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __ynf64)(int , double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) erff64)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __erff64)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) erfcf64)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __erfcf64)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) lgammaf64)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __lgammaf64)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) tgammaf64)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __tgammaf64)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) lgammaf64_r)(double , int *__signgamp ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __lgammaf64_r)(double , int *__signgamp ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) rintf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __rintf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) nextafterf64)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __nextafterf64)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) nextdownf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __nextdownf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) nextupf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __nextupf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) remainderf64)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __remainderf64)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) scalbnf64)(double __x , int __n ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __scalbnf64)(double __x , int __n ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ilogbf64)(double __x ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __ilogbf64)(double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) llogbf64)(double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __llogbf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) scalblnf64)(double __x , long __n ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __scalblnf64)(double __x , long __n ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) nearbyintf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __nearbyintf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) roundf64)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __roundf64)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) truncf64)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __truncf64)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) remquof64)(double __x , double __y , int *__quo ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __remquof64)(double __x , double __y , int *__quo ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) lrintf64)(double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __lrintf64)(double __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) llrintf64)(double __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) __llrintf64)(double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) lroundf64)(double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __lroundf64)(double __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) llroundf64)(double __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) __llroundf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) fdimf64)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __fdimf64)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) fmaxf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fmaxf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fminf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fminf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fmaf64)(double __x , double __y , double __z ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __fmaf64)(double __x , double __y , double __z ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) roundevenf64)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __roundevenf64)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern __intmax_t ( __attribute__((__leaf__)) fromfpf64)(double __x , int __round ,
                                                         unsigned int __width ) __attribute__((__nothrow__)) ;
extern __intmax_t ( __attribute__((__leaf__)) __fromfpf64)(double __x , int __round ,
                                                           unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpf64)(double __x , int __round ,
                                                           unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpf64)(double __x , int __round ,
                                                             unsigned int __width ) __attribute__((__nothrow__)) ;
extern __intmax_t ( __attribute__((__leaf__)) fromfpxf64)(double __x , int __round ,
                                                          unsigned int __width ) __attribute__((__nothrow__)) ;
extern __intmax_t ( __attribute__((__leaf__)) __fromfpxf64)(double __x , int __round ,
                                                            unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpxf64)(double __x , int __round ,
                                                            unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpxf64)(double __x , int __round ,
                                                              unsigned int __width ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) canonicalizef64)(double *__cx , double const *__x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) fmaxmagf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fmaxmagf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fminmagf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fminmagf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fmaximumf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fmaximumf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fminimumf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fminimumf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fmaximum_numf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fmaximum_numf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fminimum_numf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fminimum_numf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fmaximum_magf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fmaximum_magf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fminimum_magf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fminimum_magf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fmaximum_mag_numf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fmaximum_mag_numf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fminimum_mag_numf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fminimum_mag_numf64)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) totalorderf64)(double const *__x , double const *__y ) __attribute__((__pure__,
__nothrow__)) ;
extern int ( __attribute__((__leaf__)) totalordermagf64)(double const *__x , double const *__y ) __attribute__((__pure__,
__nothrow__)) ;
extern double ( __attribute__((__leaf__)) getpayloadf64)(double const *__x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __getpayloadf64)(double const *__x ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setpayloadf64)(double *__x , double __payload ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setpayloadsigf64)(double *__x , double __payload ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __fpclassifyf128)(long double __value ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) __signbitf128)(long double __value ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) __isinff128)(long double __value ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) __finitef128)(long double __value ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) __isnanf128)(long double __value ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) __iseqsigf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __issignalingf128)(long double __value ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) acosf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __acosf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) asinf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __asinf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) atanf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __atanf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) atan2f128)(long double __y , long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __atan2f128)(long double __y , long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) cosf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __cosf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) sinf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __sinf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) tanf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __tanf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) coshf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __coshf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) sinhf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __sinhf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) tanhf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __tanhf128)(long double __x ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) sincosf128)(long double __x , long double *__sinx ,
                                                    long double *__cosx ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) __sincosf128)(long double __x , long double *__sinx ,
                                                      long double *__cosx ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) acoshf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __acoshf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) asinhf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __asinhf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) atanhf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __atanhf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) expf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __expf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) frexpf128)(long double __x , int *__exponent ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __frexpf128)(long double __x , int *__exponent ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) ldexpf128)(long double __x , int __exponent ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __ldexpf128)(long double __x , int __exponent ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) logf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __logf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) log10f128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __log10f128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) modff128)(long double __x , long double *__iptr ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__nonnull__(2), __leaf__)) __modff128)(long double __x ,
                                                                           long double *__iptr ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) exp10f128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __exp10f128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) expm1f128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __expm1f128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) log1pf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __log1pf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) logbf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __logbf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) exp2f128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __exp2f128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) log2f128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __log2f128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) powf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __powf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) sqrtf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __sqrtf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) hypotf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __hypotf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) cbrtf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __cbrtf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) ceilf128)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __ceilf128)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fabsf128)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fabsf128)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) floorf128)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __floorf128)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fmodf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __fmodf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) copysignf128)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __copysignf128)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) nanf128)(char const *__tagb ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __nanf128)(char const *__tagb ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) j0f128)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __j0f128)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) j1f128)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __j1f128)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) jnf128)(int , long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __jnf128)(int , long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) y0f128)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __y0f128)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) y1f128)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __y1f128)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) ynf128)(int , long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __ynf128)(int , long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) erff128)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __erff128)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) erfcf128)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __erfcf128)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) lgammaf128)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __lgammaf128)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) tgammaf128)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __tgammaf128)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) lgammaf128_r)(long double , int *__signgamp ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __lgammaf128_r)(long double , int *__signgamp ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) rintf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __rintf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) nextafterf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __nextafterf128)(long double __x ,
                                                                long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) nextdownf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __nextdownf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) nextupf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __nextupf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) remainderf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __remainderf128)(long double __x ,
                                                                long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) scalbnf128)(long double __x , int __n ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __scalbnf128)(long double __x , int __n ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ilogbf128)(long double __x ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __ilogbf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) llogbf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __llogbf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) scalblnf128)(long double __x , long __n ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __scalblnf128)(long double __x , long __n ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) nearbyintf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __nearbyintf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) roundf128)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __roundf128)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) truncf128)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __truncf128)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) remquof128)(long double __x , long double __y ,
                                                           int *__quo ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __remquof128)(long double __x , long double __y ,
                                                             int *__quo ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) lrintf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __lrintf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) llrintf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) __llrintf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) lroundf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __lroundf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) llroundf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) __llroundf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) fdimf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __fdimf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) fmaxf128)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fmaxf128)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fminf128)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fminf128)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fmaf128)(long double __x , long double __y ,
                                                        long double __z ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __fmaf128)(long double __x , long double __y ,
                                                          long double __z ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) roundevenf128)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __roundevenf128)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern __intmax_t ( __attribute__((__leaf__)) fromfpf128)(long double __x , int __round ,
                                                          unsigned int __width ) __attribute__((__nothrow__)) ;
extern __intmax_t ( __attribute__((__leaf__)) __fromfpf128)(long double __x , int __round ,
                                                            unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpf128)(long double __x , int __round ,
                                                            unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpf128)(long double __x , int __round ,
                                                              unsigned int __width ) __attribute__((__nothrow__)) ;
extern __intmax_t ( __attribute__((__leaf__)) fromfpxf128)(long double __x , int __round ,
                                                           unsigned int __width ) __attribute__((__nothrow__)) ;
extern __intmax_t ( __attribute__((__leaf__)) __fromfpxf128)(long double __x , int __round ,
                                                             unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpxf128)(long double __x , int __round ,
                                                             unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpxf128)(long double __x , int __round ,
                                                               unsigned int __width ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) canonicalizef128)(long double *__cx , long double const *__x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) fmaxmagf128)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fmaxmagf128)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fminmagf128)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fminmagf128)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fmaximumf128)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fmaximumf128)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fminimumf128)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fminimumf128)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fmaximum_numf128)(long double __x ,
                                                                 long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fmaximum_numf128)(long double __x ,
                                                                   long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fminimum_numf128)(long double __x ,
                                                                 long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fminimum_numf128)(long double __x ,
                                                                   long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fmaximum_magf128)(long double __x ,
                                                                 long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fmaximum_magf128)(long double __x ,
                                                                   long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fminimum_magf128)(long double __x ,
                                                                 long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fminimum_magf128)(long double __x ,
                                                                   long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fmaximum_mag_numf128)(long double __x ,
                                                                     long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fmaximum_mag_numf128)(long double __x ,
                                                                       long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fminimum_mag_numf128)(long double __x ,
                                                                     long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fminimum_mag_numf128)(long double __x ,
                                                                       long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) totalorderf128)(long double const *__x ,
                                                       long double const *__y ) __attribute__((__pure__,
__nothrow__)) ;
extern int ( __attribute__((__leaf__)) totalordermagf128)(long double const *__x ,
                                                          long double const *__y ) __attribute__((__pure__,
__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) getpayloadf128)(long double const *__x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __getpayloadf128)(long double const *__x ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setpayloadf128)(long double *__x , long double __payload ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setpayloadsigf128)(long double *__x , long double __payload ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) acosf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __acosf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) asinf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __asinf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) atanf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __atanf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) atan2f32x)(double __y , double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __atan2f32x)(double __y , double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) cosf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __cosf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) sinf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __sinf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) tanf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __tanf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) coshf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __coshf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) sinhf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __sinhf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) tanhf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __tanhf32x)(double __x ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) sincosf32x)(double __x , double *__sinx ,
                                                    double *__cosx ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) __sincosf32x)(double __x , double *__sinx ,
                                                      double *__cosx ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) acoshf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __acoshf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) asinhf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __asinhf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) atanhf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __atanhf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) expf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __expf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) frexpf32x)(double __x , int *__exponent ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __frexpf32x)(double __x , int *__exponent ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) ldexpf32x)(double __x , int __exponent ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __ldexpf32x)(double __x , int __exponent ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) logf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __logf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) log10f32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __log10f32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) modff32x)(double __x , double *__iptr ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__nonnull__(2), __leaf__)) __modff32x)(double __x ,
                                                                      double *__iptr ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) exp10f32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __exp10f32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) expm1f32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __expm1f32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) log1pf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __log1pf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) logbf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __logbf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) exp2f32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __exp2f32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) log2f32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __log2f32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) powf32x)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __powf32x)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) sqrtf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __sqrtf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) hypotf32x)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __hypotf32x)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) cbrtf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __cbrtf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) ceilf32x)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __ceilf32x)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fabsf32x)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fabsf32x)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) floorf32x)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __floorf32x)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fmodf32x)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __fmodf32x)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) copysignf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __copysignf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) nanf32x)(char const *__tagb ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __nanf32x)(char const *__tagb ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) j0f32x)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __j0f32x)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) j1f32x)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __j1f32x)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) jnf32x)(int , double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __jnf32x)(int , double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) y0f32x)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __y0f32x)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) y1f32x)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __y1f32x)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) ynf32x)(int , double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __ynf32x)(int , double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) erff32x)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __erff32x)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) erfcf32x)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __erfcf32x)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) lgammaf32x)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __lgammaf32x)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) tgammaf32x)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __tgammaf32x)(double ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) lgammaf32x_r)(double , int *__signgamp ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __lgammaf32x_r)(double , int *__signgamp ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) rintf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __rintf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) nextafterf32x)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __nextafterf32x)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) nextdownf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __nextdownf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) nextupf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __nextupf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) remainderf32x)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __remainderf32x)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) scalbnf32x)(double __x , int __n ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __scalbnf32x)(double __x , int __n ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ilogbf32x)(double __x ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __ilogbf32x)(double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) llogbf32x)(double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __llogbf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) scalblnf32x)(double __x , long __n ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __scalblnf32x)(double __x , long __n ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) nearbyintf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __nearbyintf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) roundf32x)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __roundf32x)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) truncf32x)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __truncf32x)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) remquof32x)(double __x , double __y , int *__quo ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __remquof32x)(double __x , double __y ,
                                                        int *__quo ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) lrintf32x)(double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __lrintf32x)(double __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) llrintf32x)(double __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) __llrintf32x)(double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) lroundf32x)(double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __lroundf32x)(double __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) llroundf32x)(double __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) __llroundf32x)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) fdimf32x)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __fdimf32x)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) fmaxf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fmaxf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fminf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fminf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fmaf32x)(double __x , double __y , double __z ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __fmaf32x)(double __x , double __y , double __z ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) roundevenf32x)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __roundevenf32x)(double __x ) __attribute__((__nothrow__,
__const__)) ;
extern __intmax_t ( __attribute__((__leaf__)) fromfpf32x)(double __x , int __round ,
                                                          unsigned int __width ) __attribute__((__nothrow__)) ;
extern __intmax_t ( __attribute__((__leaf__)) __fromfpf32x)(double __x , int __round ,
                                                            unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpf32x)(double __x , int __round ,
                                                            unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpf32x)(double __x , int __round ,
                                                              unsigned int __width ) __attribute__((__nothrow__)) ;
extern __intmax_t ( __attribute__((__leaf__)) fromfpxf32x)(double __x , int __round ,
                                                           unsigned int __width ) __attribute__((__nothrow__)) ;
extern __intmax_t ( __attribute__((__leaf__)) __fromfpxf32x)(double __x , int __round ,
                                                             unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpxf32x)(double __x , int __round ,
                                                             unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpxf32x)(double __x , int __round ,
                                                               unsigned int __width ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) canonicalizef32x)(double *__cx , double const *__x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) fmaxmagf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fmaxmagf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fminmagf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fminmagf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fmaximumf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fmaximumf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fminimumf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fminimumf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fmaximum_numf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fmaximum_numf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fminimum_numf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fminimum_numf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fmaximum_magf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fmaximum_magf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fminimum_magf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fminimum_magf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fmaximum_mag_numf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fmaximum_mag_numf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) fminimum_mag_numf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern double ( __attribute__((__leaf__)) __fminimum_mag_numf32x)(double __x , double __y ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) totalorderf32x)(double const *__x , double const *__y ) __attribute__((__pure__,
__nothrow__)) ;
extern int ( __attribute__((__leaf__)) totalordermagf32x)(double const *__x , double const *__y ) __attribute__((__pure__,
__nothrow__)) ;
extern double ( __attribute__((__leaf__)) getpayloadf32x)(double const *__x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) __getpayloadf32x)(double const *__x ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setpayloadf32x)(double *__x , double __payload ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setpayloadsigf32x)(double *__x , double __payload ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) acosf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __acosf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) asinf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __asinf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) atanf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __atanf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) atan2f64x)(long double __y , long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __atan2f64x)(long double __y , long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) cosf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __cosf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) sinf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __sinf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) tanf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __tanf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) coshf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __coshf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) sinhf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __sinhf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) tanhf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __tanhf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) sincosf64x)(long double __x , long double *__sinx ,
                                                    long double *__cosx ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) __sincosf64x)(long double __x , long double *__sinx ,
                                                      long double *__cosx ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) acoshf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __acoshf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) asinhf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __asinhf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) atanhf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __atanhf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) expf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __expf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) frexpf64x)(long double __x , int *__exponent ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __frexpf64x)(long double __x , int *__exponent ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) ldexpf64x)(long double __x , int __exponent ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __ldexpf64x)(long double __x , int __exponent ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) logf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __logf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) log10f64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __log10f64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) modff64x)(long double __x , long double *__iptr ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__nonnull__(2), __leaf__)) __modff64x)(long double __x ,
                                                                           long double *__iptr ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) exp10f64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __exp10f64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) expm1f64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __expm1f64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) log1pf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __log1pf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) logbf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __logbf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) exp2f64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __exp2f64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) log2f64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __log2f64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) powf64x)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __powf64x)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) sqrtf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __sqrtf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) hypotf64x)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __hypotf64x)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) cbrtf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __cbrtf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) ceilf64x)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __ceilf64x)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fabsf64x)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fabsf64x)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) floorf64x)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __floorf64x)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fmodf64x)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __fmodf64x)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) copysignf64x)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __copysignf64x)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) nanf64x)(char const *__tagb ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __nanf64x)(char const *__tagb ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) j0f64x)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __j0f64x)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) j1f64x)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __j1f64x)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) jnf64x)(int , long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __jnf64x)(int , long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) y0f64x)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __y0f64x)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) y1f64x)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __y1f64x)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) ynf64x)(int , long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __ynf64x)(int , long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) erff64x)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __erff64x)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) erfcf64x)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __erfcf64x)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) lgammaf64x)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __lgammaf64x)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) tgammaf64x)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __tgammaf64x)(long double ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) lgammaf64x_r)(long double , int *__signgamp ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __lgammaf64x_r)(long double , int *__signgamp ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) rintf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __rintf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) nextafterf64x)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __nextafterf64x)(long double __x ,
                                                                long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) nextdownf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __nextdownf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) nextupf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __nextupf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) remainderf64x)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __remainderf64x)(long double __x ,
                                                                long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) scalbnf64x)(long double __x , int __n ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __scalbnf64x)(long double __x , int __n ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ilogbf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __ilogbf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) llogbf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __llogbf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) scalblnf64x)(long double __x , long __n ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __scalblnf64x)(long double __x , long __n ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) nearbyintf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __nearbyintf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) roundf64x)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __roundf64x)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) truncf64x)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __truncf64x)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) remquof64x)(long double __x , long double __y ,
                                                           int *__quo ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __remquof64x)(long double __x , long double __y ,
                                                             int *__quo ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) lrintf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __lrintf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) llrintf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) __llrintf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) lroundf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) __lroundf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) llroundf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__leaf__)) __llroundf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) fdimf64x)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __fdimf64x)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) fmaxf64x)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fmaxf64x)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fminf64x)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fminf64x)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fmaf64x)(long double __x , long double __y ,
                                                        long double __z ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __fmaf64x)(long double __x , long double __y ,
                                                          long double __z ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) roundevenf64x)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __roundevenf64x)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern __intmax_t ( __attribute__((__leaf__)) fromfpf64x)(long double __x , int __round ,
                                                          unsigned int __width ) __attribute__((__nothrow__)) ;
extern __intmax_t ( __attribute__((__leaf__)) __fromfpf64x)(long double __x , int __round ,
                                                            unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpf64x)(long double __x , int __round ,
                                                            unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpf64x)(long double __x , int __round ,
                                                              unsigned int __width ) __attribute__((__nothrow__)) ;
extern __intmax_t ( __attribute__((__leaf__)) fromfpxf64x)(long double __x , int __round ,
                                                           unsigned int __width ) __attribute__((__nothrow__)) ;
extern __intmax_t ( __attribute__((__leaf__)) __fromfpxf64x)(long double __x , int __round ,
                                                             unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpxf64x)(long double __x , int __round ,
                                                             unsigned int __width ) __attribute__((__nothrow__)) ;
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpxf64x)(long double __x , int __round ,
                                                               unsigned int __width ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) canonicalizef64x)(long double *__cx , long double const *__x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) fmaxmagf64x)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fmaxmagf64x)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fminmagf64x)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fminmagf64x)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fmaximumf64x)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fmaximumf64x)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fminimumf64x)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fminimumf64x)(long double __x , long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fmaximum_numf64x)(long double __x ,
                                                                 long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fmaximum_numf64x)(long double __x ,
                                                                   long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fminimum_numf64x)(long double __x ,
                                                                 long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fminimum_numf64x)(long double __x ,
                                                                   long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fmaximum_magf64x)(long double __x ,
                                                                 long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fmaximum_magf64x)(long double __x ,
                                                                   long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fminimum_magf64x)(long double __x ,
                                                                 long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fminimum_magf64x)(long double __x ,
                                                                   long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fmaximum_mag_numf64x)(long double __x ,
                                                                     long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fmaximum_mag_numf64x)(long double __x ,
                                                                       long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) fminimum_mag_numf64x)(long double __x ,
                                                                     long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern long double ( __attribute__((__leaf__)) __fminimum_mag_numf64x)(long double __x ,
                                                                       long double __y ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) totalorderf64x)(long double const *__x ,
                                                       long double const *__y ) __attribute__((__pure__,
__nothrow__)) ;
extern int ( __attribute__((__leaf__)) totalordermagf64x)(long double const *__x ,
                                                          long double const *__y ) __attribute__((__pure__,
__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) getpayloadf64x)(long double const *__x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) __getpayloadf64x)(long double const *__x ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setpayloadf64x)(long double *__x , long double __payload ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setpayloadsigf64x)(long double *__x , long double __payload ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) fadd)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) fdiv)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) ffma)(double __x , double __y , double __z ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) fmul)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) fsqrt)(double __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) fsub)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) faddl)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) fdivl)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) ffmal)(long double __x , long double __y ,
                                                long double __z ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) fmull)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) fsqrtl)(long double __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) fsubl)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) daddl)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) ddivl)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) dfmal)(long double __x , long double __y ,
                                                 long double __z ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) dmull)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) dsqrtl)(long double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) dsubl)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) f32addf32x)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) f32divf32x)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) f32fmaf32x)(double __x , double __y , double __z ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) f32mulf32x)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) f32sqrtf32x)(double __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) f32subf32x)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) f32addf64)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) f32divf64)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) f32fmaf64)(double __x , double __y , double __z ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) f32mulf64)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) f32sqrtf64)(double __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) f32subf64)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) f32addf64x)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) f32divf64x)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) f32fmaf64x)(long double __x , long double __y ,
                                                     long double __z ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) f32mulf64x)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) f32sqrtf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) f32subf64x)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) f32addf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) f32divf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) f32fmaf128)(long double __x , long double __y ,
                                                     long double __z ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) f32mulf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) f32sqrtf128)(long double __x ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__leaf__)) f32subf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f32xaddf64)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f32xdivf64)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f32xfmaf64)(double __x , double __y , double __z ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f32xmulf64)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f32xsqrtf64)(double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f32xsubf64)(double __x , double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f32xaddf64x)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f32xdivf64x)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f32xfmaf64x)(long double __x , long double __y ,
                                                       long double __z ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f32xmulf64x)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f32xsqrtf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f32xsubf64x)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f32xaddf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f32xdivf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f32xfmaf128)(long double __x , long double __y ,
                                                       long double __z ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f32xmulf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f32xsqrtf128)(long double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f32xsubf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f64addf64x)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f64divf64x)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f64fmaf64x)(long double __x , long double __y ,
                                                      long double __z ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f64mulf64x)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f64sqrtf64x)(long double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f64subf64x)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f64addf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f64divf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f64fmaf128)(long double __x , long double __y ,
                                                      long double __z ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f64mulf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f64sqrtf128)(long double __x ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) f64subf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) f64xaddf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) f64xdivf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) f64xfmaf128)(long double __x , long double __y ,
                                                            long double __z ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) f64xmulf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) f64xsqrtf128)(long double __x ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__leaf__)) f64xsubf128)(long double __x , long double __y ) __attribute__((__nothrow__)) ;
extern int signgam ;
extern int ( __attribute__((__leaf__)) __iscanonicall)(long double __x ) __attribute__((__nothrow__,
__const__)) ;
extern void setpwent(void) ;
extern void endpwent(void) ;
extern struct passwd *getpwent(void) ;
extern struct passwd *( __attribute__((__nonnull__(1))) fgetpwent)(FILE *__stream ) ;
extern int putpwent(struct passwd const *__p , FILE *__f ) ;
extern struct passwd *getpwuid(__uid_t __uid ) ;
extern struct passwd *( __attribute__((__nonnull__(1))) getpwnam)(char const *__name ) ;
extern int ( __attribute__((__nonnull__(1,2,4))) getpwent_r)(struct passwd *__resultbuf ,
                                                             char *__buffer , size_t __buflen ,
                                                             struct passwd **__result ) __attribute__((__access__(__write_only__,2,3))) ;
extern int ( __attribute__((__nonnull__(2,3,5))) getpwuid_r)(__uid_t __uid , struct passwd *__resultbuf ,
                                                             char *__buffer , size_t __buflen ,
                                                             struct passwd **__result ) __attribute__((__access__(__write_only__,3,4))) ;
extern int ( __attribute__((__nonnull__(1,2,3,5))) getpwnam_r)(char const *__name ,
                                                               struct passwd *__resultbuf ,
                                                               char *__buffer , size_t __buflen ,
                                                               struct passwd **__result ) __attribute__((__access__(__write_only__,3,4))) ;
extern int ( __attribute__((__nonnull__(1,2,3,5))) fgetpwent_r)(FILE *__stream , struct passwd *__resultbuf ,
                                                                char *__buffer , size_t __buflen ,
                                                                struct passwd **__result ) __attribute__((__access__(__write_only__,3,4))) ;
extern int getpw(__uid_t __uid , char *__buffer ) ;
extern __sighandler_t ( __attribute__((__leaf__)) __sysv_signal)(int __sig , void (*__handler)(int ) ) __attribute__((__nothrow__)) ;
extern __sighandler_t ( __attribute__((__leaf__)) sysv_signal)(int __sig , void (*__handler)(int ) ) __attribute__((__nothrow__)) ;
extern __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig , void (*__handler)(int ) ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) kill)(__pid_t __pid , int __sig ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) killpg)(__pid_t __pgrp , int __sig ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) raise)(int __sig ) __attribute__((__nothrow__)) ;
extern __sighandler_t ( __attribute__((__leaf__)) ssignal)(int __sig , void (*__handler)(int ) ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) gsignal)(int __sig ) __attribute__((__nothrow__)) ;
extern void psignal(int __sig , char const *__s ) ;
extern void psiginfo(siginfo_t const *__pinfo , char const *__s ) ;
extern int sigpause(int __sig ) __asm__("__xpg_sigpause") __attribute__((__deprecated__("Use the sigsuspend function instead"))) ;
extern int ( __attribute__((__leaf__)) sigblock)(int __mask ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__leaf__)) sigsetmask)(int __mask ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__leaf__)) siggetmask)(void) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigfillset)(sigset_t *__set ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                  int __signo ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigdelset)(sigset_t *__set ,
                                                                  int __signo ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigismember)(sigset_t const *__set ,
                                                                    int __signo ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigisemptyset)(sigset_t const *__set ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2,3), __leaf__)) sigandset)(sigset_t *__set ,
                                                                      sigset_t const *__left ,
                                                                      sigset_t const *__right ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2,3), __leaf__)) sigorset)(sigset_t *__set ,
                                                                     sigset_t const *__left ,
                                                                     sigset_t const *__right ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) sigprocmask)(int __how , sigset_t const *__set ,
                                                    sigset_t *__oset ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1))) sigsuspend)(sigset_t const *__set ) ;
extern int ( __attribute__((__leaf__)) sigaction)(int __sig , struct sigaction const *__act ,
                                                  struct sigaction *__oact ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigpending)(sigset_t *__set ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2))) sigwait)(sigset_t const *__set ,
                                                        int *__sig ) ;
extern int ( __attribute__((__nonnull__(1))) sigwaitinfo)(sigset_t const *__set ,
                                                          siginfo_t *__info ) ;
extern int ( __attribute__((__nonnull__(1))) sigtimedwait)(sigset_t const *__set ,
                                                           siginfo_t *__info , struct timespec const *__timeout ) ;
extern int ( __attribute__((__leaf__)) sigqueue)(__pid_t __pid , int __sig , union sigval const __val ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) sigreturn)(struct sigcontext *__scp ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) siginterrupt)(int __sig , int __interrupt ) __attribute__((__nothrow__,
__deprecated__("Use sigaction with SA_RESTART instead"))) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const *__name ,
                                                               int __type ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) euidaccess)(char const *__name ,
                                                                   int __type ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) eaccess)(char const *__name ,
                                                                int __type ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2,3), __leaf__)) execveat)(int __fd , char const *__path ,
                                                                   char **__argv ,
                                                                   char **__envp ,
                                                                   int __flags ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__)) faccessat)(int __fd ,
                                                                                          char const *__file ,
                                                                                          int __type ,
                                                                                          int __flag ) __attribute__((__nothrow__)) ;
extern __off_t ( __attribute__((__leaf__)) lseek)(int __fd , __off_t __offset , int __whence ) __attribute__((__nothrow__)) ;
extern __off64_t ( __attribute__((__leaf__)) lseek64)(int __fd , __off64_t __offset ,
                                                      int __whence ) __attribute__((__nothrow__)) ;
extern int close(int __fd ) ;
extern void ( __attribute__((__leaf__)) closefrom)(int __lowfd ) __attribute__((__nothrow__)) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) __attribute__((__access__(__write_only__,2,3))) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) write)(int __fd , void const *__buf ,
                                                                size_t __n ) __attribute__((__access__(__read_only__,2,3))) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) pread)(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) __attribute__((__access__(__write_only__,2,3))) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) pwrite)(int __fd , void const *__buf ,
                                                                 size_t __n , __off_t __offset ) __attribute__((__access__(__read_only__,2,3))) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) pread64)(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ) __attribute__((__access__(__write_only__,2,3))) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) pwrite64)(int __fd , void const *__buf ,
                                                                   size_t __n , __off64_t __offset ) __attribute__((__access__(__read_only__,2,3))) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) pipe)(int *__pipedes ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) pipe2)(int *__pipedes ,
                                                                      int __flags ) __attribute__((__nothrow__)) ;
extern unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) __attribute__((__nothrow__)) ;
extern unsigned int sleep(unsigned int __seconds ) ;
extern __useconds_t ( __attribute__((__leaf__)) ualarm)(__useconds_t __value , __useconds_t __interval ) __attribute__((__nothrow__)) ;
extern int usleep(__useconds_t __useconds ) ;
extern int pause(void) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) chown)(char const *__file ,
                                                                                      __uid_t __owner ,
                                                                                      __gid_t __group ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) fchown)(int __fd ,
                                                                       __uid_t __owner ,
                                                                       __gid_t __group ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) lchown)(char const *__file ,
                                                                                       __uid_t __owner ,
                                                                                       __gid_t __group ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__)) fchownat)(int __fd ,
                                                                                         char const *__file ,
                                                                                         __uid_t __owner ,
                                                                                         __gid_t __group ,
                                                                                         int __flag ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) chdir)(char const *__path ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) fchdir)(int __fd ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__leaf__)) get_current_dir_name)(void) __attribute__((__nothrow__)) ;
__inline extern char __attribute__((__deprecated__)) *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) getwd)(char *__buf ) __attribute__((__nothrow__,
__deprecated__, __access__(__write_only__,1))) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) dup)(int __fd ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) dup2)(int __fd , int __fd2 ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) dup3)(int __fd , int __fd2 , int __flags ) __attribute__((__nothrow__)) ;
extern char **__environ ;
extern char **environ ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const *__path ,
                                                                 char **__argv , char **__envp ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2), __leaf__)) fexecve)(int __fd , char **__argv ,
                                                                char **__envp ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const *__path ,
                                                                char **__argv ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execle)(char const *__path ,
                                                                 char const *__arg
                                                                 , ...) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const *__path ,
                                                                char const *__arg
                                                                , ...) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const *__file ,
                                                                 char **__argv ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const *__file ,
                                                                 char const *__arg
                                                                 , ...) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execvpe)(char const *__file ,
                                                                  char **__argv ,
                                                                  char **__envp ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) nice)(int __inc ) __attribute__((__nothrow__)) ;
extern void _exit(int __status ) __attribute__((__noreturn__)) ;
extern long ( __attribute__((__nonnull__(1), __leaf__)) pathconf)(char const *__path ,
                                                                  int __name ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) fpathconf)(int __fd , int __name ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) sysconf)(int __name ) __attribute__((__nothrow__)) ;
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len ) __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
extern __pid_t ( __attribute__((__leaf__)) getpid)(void) __attribute__((__nothrow__)) ;
extern __pid_t ( __attribute__((__leaf__)) getppid)(void) __attribute__((__nothrow__)) ;
extern __pid_t ( __attribute__((__leaf__)) getpgrp)(void) __attribute__((__nothrow__)) ;
extern __pid_t ( __attribute__((__leaf__)) __getpgid)(__pid_t __pid ) __attribute__((__nothrow__)) ;
extern __pid_t ( __attribute__((__leaf__)) getpgid)(__pid_t __pid ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setpgid)(__pid_t __pid , __pid_t __pgid ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setpgrp)(void) __attribute__((__nothrow__)) ;
extern __pid_t ( __attribute__((__leaf__)) setsid)(void) __attribute__((__nothrow__)) ;
extern __pid_t ( __attribute__((__leaf__)) getsid)(__pid_t __pid ) __attribute__((__nothrow__)) ;
extern __uid_t ( __attribute__((__leaf__)) getuid)(void) __attribute__((__nothrow__)) ;
extern __uid_t ( __attribute__((__leaf__)) geteuid)(void) __attribute__((__nothrow__)) ;
extern __gid_t ( __attribute__((__leaf__)) getgid)(void) __attribute__((__nothrow__)) ;
extern __gid_t ( __attribute__((__leaf__)) getegid)(void) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list ) __attribute__((__nothrow__,
__access__(__write_only__,2,1))) ;
extern int ( __attribute__((__leaf__)) group_member)(__gid_t __gid ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) setuid)(__uid_t __uid ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) setreuid)(__uid_t __ruid ,
                                                                         __uid_t __euid ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) seteuid)(__uid_t __uid ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) setgid)(__gid_t __gid ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) setregid)(__gid_t __rgid ,
                                                                         __gid_t __egid ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) setegid)(__gid_t __gid ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) getresuid)(__uid_t *__ruid , __uid_t *__euid ,
                                                  __uid_t *__suid ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) getresgid)(__gid_t *__rgid , __gid_t *__egid ,
                                                  __gid_t *__sgid ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) setresuid)(__uid_t __ruid ,
                                                                          __uid_t __euid ,
                                                                          __uid_t __suid ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) setresgid)(__gid_t __rgid ,
                                                                          __gid_t __egid ,
                                                                          __gid_t __sgid ) __attribute__((__nothrow__)) ;
extern __pid_t fork(void) __attribute__((__nothrow__)) ;
extern __pid_t ( __attribute__((__leaf__)) vfork)(void) __attribute__((__nothrow__)) ;
extern __pid_t ( __attribute__((__leaf__)) _Fork)(void) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__leaf__)) ttyname)(int __fd ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen ) __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
extern int ( __attribute__((__leaf__)) isatty)(int __fd ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ttyslot)(void) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1,2), __leaf__)) link)(char const *__from ,
                                                                                       char const *__to ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(2,4), __leaf__)) linkat)(int __fromfd ,
                                                                                         char const *__from ,
                                                                                         int __tofd ,
                                                                                         char const *__to ,
                                                                                         int __flags ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1,2), __leaf__)) symlink)(char const *__from ,
                                                                                          char const *__to ) __attribute__((__nothrow__)) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlink)(char const *__path ,
                                                                        char *__buf ,
                                                                        size_t __len ) __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1,3), __leaf__)) symlinkat)(char const *__from ,
                                                                                            int __tofd ,
                                                                                            char const *__to ) __attribute__((__nothrow__)) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                          char const *__path ,
                                                                          char *__buf ,
                                                                          size_t __len ) __attribute__((__nothrow__,
__access__(__write_only__,3,4))) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const *__name ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2), __leaf__)) unlinkat)(int __fd , char const *__name ,
                                                                 int __flag ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const *__path ) __attribute__((__nothrow__)) ;
extern __pid_t ( __attribute__((__leaf__)) tcgetpgrp)(int __fd ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) tcsetpgrp)(int __fd , __pid_t __pgrp_id ) __attribute__((__nothrow__)) ;
extern char *getlogin(void) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __artificial__,
__always_inline__)) getlogin_r)(char *__buf , size_t __buflen ) __attribute__((__access__(__write_only__,1,2))) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) setlogin)(char const *__name ) __attribute__((__nothrow__)) ;
extern char *optarg ;
extern int optind ;
extern int opterr ;
extern int optopt ;
extern int ( __attribute__((__nonnull__(2,3), __leaf__)) getopt)(int ___argc , char **___argv ,
                                                                 char const *__shortopts ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) gethostname)(char *__buf , size_t __buflen ) __attribute__((__nothrow__,
__access__(__write_only__,1,2))) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) sethostname)(char const *__name ,
                                                                                            size_t __len ) __attribute__((__nothrow__,
__access__(__read_only__,1,2))) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) sethostid)(long __id ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) getdomainname)(char *__buf , size_t __buflen ) __attribute__((__nothrow__,
__access__(__write_only__,1,2))) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) setdomainname)(char const *__name ,
                                                                                              size_t __len ) __attribute__((__nothrow__,
__access__(__read_only__,1,2))) ;
extern int ( __attribute__((__leaf__)) vhangup)(void) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) revoke)(char const *__file ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) profil)(unsigned short *__sample_buffer ,
                                                               size_t __size , size_t __offset ,
                                                               unsigned int __scale ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) acct)(char const *__name ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__leaf__)) getusershell)(void) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) endusershell)(void) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) setusershell)(void) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) daemon)(int __nochdir ,
                                                                       int __noclose ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) chroot)(char const *__path ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__nonnull__(1))) getpass)(char const *__prompt ) ;
extern int fsync(int __fd ) ;
extern int ( __attribute__((__leaf__)) syncfs)(int __fd ) __attribute__((__nothrow__)) ;
extern long gethostid(void) ;
extern void ( __attribute__((__leaf__)) sync)(void) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) getpagesize)(void) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) getdtablesize)(void) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) truncate)(char const *__file ,
                                                                                         __off_t __length ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) truncate64)(char const *__file ,
                                                                                           __off64_t __length ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) ftruncate)(int __fd ,
                                                                          __off_t __length ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) ftruncate64)(int __fd ,
                                                                            __off64_t __length ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) brk)(void *__addr ) __attribute__((__nothrow__)) ;
extern void *( __attribute__((__leaf__)) sbrk)(intptr_t __delta ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) syscall)(long __sysno , ...) __attribute__((__nothrow__)) ;
extern ssize_t copy_file_range(int __infd , __off64_t *__pinoff , int __outfd , __off64_t *__poutoff ,
                               size_t __length , unsigned int __flags ) ;
extern int fdatasync(int __fildes ) ;
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) crypt)(char const *__key ,
                                                                  char const *__salt ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__nonnull__(1,2), __leaf__)) swab)(void const *__from ,
                                                                void *__to , ssize_t __n ) __attribute__((__nothrow__,
__access__(__write_only__,2,3), __access__(__read_only__,1,3))) ;
extern int ( __attribute__((__warn_unused_result__)) getentropy)(void *__buffer ,
                                                                 size_t __length ) __attribute__((__access__(__write_only__,1,2))) ;
extern int ( __attribute__((__leaf__)) close_range)(unsigned int __fd , unsigned int __max_fd ,
                                                    int __flags ) __attribute__((__nothrow__)) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk)(int __fd , void *__buf ,
                                                                     size_t __nbytes ,
                                                                     size_t __buflen ) __attribute__((__access__(__write_only__,2,3))) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_alias)(int __fd ,
                                                                       void *__buf ,
                                                                       size_t __nbytes ) __asm__("read") __attribute__((__access__(__write_only__,2,3))) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk_warn)(int __fd ,
                                                                          void *__buf ,
                                                                          size_t __nbytes ,
                                                                          size_t __buflen ) __asm__("__read_chk") __attribute__((__warning__("read called with bigger length than size of the destination buffer"))) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) __attribute__((__access__(__write_only__,2,3))) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes )
{
  unsigned long tmp ;
  unsigned long tmp___0 ;
  ssize_t tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;
  unsigned long tmp___6 ;
  ssize_t tmp___7 ;
  {
  tmp___6 = __builtin_object_size(__buf, 0);
  tmp___7 = __read_chk(__fd, __buf, __nbytes, tmp___6);
  return (tmp___7);
}
}
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread_chk)(int __fd , void *__buf ,
                                                                      size_t __nbytes ,
                                                                      __off_t __offset ,
                                                                      size_t __bufsize ) __attribute__((__access__(__write_only__,2,3))) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread64_chk)(int __fd ,
                                                                        void *__buf ,
                                                                        size_t __nbytes ,
                                                                        __off64_t __offset ,
                                                                        size_t __bufsize ) __attribute__((__access__(__write_only__,2,3))) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread_alias)(int __fd ,
                                                                        void *__buf ,
                                                                        size_t __nbytes ,
                                                                        __off_t __offset ) __asm__("pread") __attribute__((__access__(__write_only__,2,3))) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread64_alias)(int __fd ,
                                                                          void *__buf ,
                                                                          size_t __nbytes ,
                                                                          __off64_t __offset ) __asm__("pread64") __attribute__((__access__(__write_only__,2,3))) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread_chk_warn)(int __fd ,
                                                                           void *__buf ,
                                                                           size_t __nbytes ,
                                                                           __off_t __offset ,
                                                                           size_t __bufsize ) __asm__("__pread_chk") __attribute__((__warning__("pread called with bigger length than size of the destination buffer"))) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread64_chk_warn)(int __fd ,
                                                                             void *__buf ,
                                                                             size_t __nbytes ,
                                                                             __off64_t __offset ,
                                                                             size_t __bufsize ) __asm__("__pread64_chk") __attribute__((__warning__("pread64 called with bigger length than size of the destination buffer"))) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) pread)(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) __attribute__((__access__(__write_only__,2,3))) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) pread)(int __fd , void *__buf , size_t __nbytes , __off_t __offset )
{
  unsigned long tmp ;
  unsigned long tmp___0 ;
  ssize_t tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;
  unsigned long tmp___6 ;
  ssize_t tmp___7 ;
  {
  tmp___6 = __builtin_object_size(__buf, 0);
  tmp___7 = __pread_chk(__fd, __buf, __nbytes, __offset, tmp___6);
  return (tmp___7);
}
}
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) pread64)(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ) __attribute__((__access__(__write_only__,2,3))) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) pread64)(int __fd , void *__buf , size_t __nbytes , __off64_t __offset )
{
  unsigned long tmp ;
  unsigned long tmp___0 ;
  ssize_t tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;
  unsigned long tmp___6 ;
  ssize_t tmp___7 ;
  {
  tmp___6 = __builtin_object_size(__buf, 0);
  tmp___7 = __pread64_chk(__fd, __buf, __nbytes, __offset, tmp___6);
  return (tmp___7);
}
}
extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2), __leaf__)) __readlink_chk)(char const *__path ,
                                                                                                     char *__buf ,
                                                                                                     size_t __len ,
                                                                                                     size_t __buflen ) __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2), __leaf__)) __readlink_alias)(char const *__path ,
                                                                                                       char *__buf ,
                                                                                                       size_t __len ) __asm__("readlink") __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2), __leaf__)) __readlink_chk_warn)(char const *__path ,
                                                                                                          char *__buf ,
                                                                                                          size_t __len ,
                                                                                                          size_t __buflen ) __asm__("__readlink_chk") __attribute__((__warning__("readlink called with bigger length than size of destination buffer"),
__nothrow__)) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlink)(char const *__path ,
                                                                        char *__buf ,
                                                                        size_t __len ) __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlink)(char const *__path ,
                                                                        char *__buf ,
                                                                        size_t __len )
{
  unsigned long tmp ;
  unsigned long tmp___0 ;
  ssize_t tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;
  unsigned long tmp___6 ;
  ssize_t tmp___7 ;
  {
  tmp___6 = __builtin_object_size((void *)__buf, 1);
  tmp___7 = __readlink_chk((char const * __restrict )__path, (char * __restrict )__buf,
                           __len, tmp___6);
  return (tmp___7);
}
}
extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3), __leaf__)) __readlinkat_chk)(int __fd ,
                                                                                                       char const *__path ,
                                                                                                       char *__buf ,
                                                                                                       size_t __len ,
                                                                                                       size_t __buflen ) __attribute__((__nothrow__,
__access__(__write_only__,3,4))) ;
extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3), __leaf__)) __readlinkat_alias)(int __fd ,
                                                                                                         char const *__path ,
                                                                                                         char *__buf ,
                                                                                                         size_t __len ) __asm__("readlinkat") __attribute__((__nothrow__,
__access__(__write_only__,3,4))) ;
extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3), __leaf__)) __readlinkat_chk_warn)(int __fd ,
                                                                                                            char const *__path ,
                                                                                                            char *__buf ,
                                                                                                            size_t __len ,
                                                                                                            size_t __buflen ) __asm__("__readlinkat_chk") __attribute__((__warning__("readlinkat called with bigger length than size of destination buffer"),
__nothrow__)) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                          char const *__path ,
                                                                          char *__buf ,
                                                                          size_t __len ) __attribute__((__nothrow__,
__access__(__write_only__,3,4))) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                          char const *__path ,
                                                                          char *__buf ,
                                                                          size_t __len )
{
  unsigned long tmp ;
  unsigned long tmp___0 ;
  ssize_t tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;
  unsigned long tmp___6 ;
  ssize_t tmp___7 ;
  {
  tmp___6 = __builtin_object_size((void *)__buf, 1);
  tmp___7 = __readlinkat_chk(__fd, (char const * __restrict )__path, (char * __restrict )__buf,
                             __len, tmp___6);
  return (tmp___7);
}
}
extern char *( __attribute__((__warn_unused_result__, __leaf__)) __getcwd_chk)(char *__buf ,
                                                                               size_t __size ,
                                                                               size_t __buflen ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__warn_unused_result__, __leaf__)) __getcwd_alias)(char *__buf ,
                                                                                 size_t __size ) __asm__("getcwd") __attribute__((__nothrow__)) ;
extern char *( __attribute__((__warn_unused_result__, __leaf__)) __getcwd_chk_warn)(char *__buf ,
                                                                                    size_t __size ,
                                                                                    size_t __buflen ) __asm__("__getcwd_chk") __attribute__((__warning__("getcwd caller with bigger length than size of destination buffer"),
__nothrow__)) ;
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size )
{
  unsigned long tmp ;
  unsigned long tmp___0 ;
  char *tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;
  unsigned long tmp___6 ;
  char *tmp___7 ;
  {
  tmp___6 = __builtin_object_size((void *)__buf, 1);
  tmp___7 = __getcwd_chk(__buf, __size, tmp___6);
  return (tmp___7);
}
}
extern char *( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) __getwd_chk)(char *__buf ,
                                                                                              size_t buflen ) __attribute__((__nothrow__,
__access__(__write_only__,1,2))) ;
extern char *( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) __getwd_warn)(char *__buf ) __asm__("getwd") __attribute__((__warning__("please use getcwd instead, as getwd doesn\'t specify buffer size"),
__nothrow__)) ;
__inline extern char __attribute__((__deprecated__)) *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) getwd)(char *__buf ) __attribute__((__nothrow__,
__deprecated__, __access__(__write_only__,1))) ;
__inline extern char __attribute__((__deprecated__)) *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) getwd)(char *__buf )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  {
  tmp___1 = __builtin_object_size((void *)__buf, 1);
  if (tmp___1 != 18446744073709551615UL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __getwd_chk(__buf, tmp);
    return ((char __attribute__((__deprecated__)) *)tmp___0);
  }
  tmp___2 = __getwd_warn(__buf);
  return ((char __attribute__((__deprecated__)) *)tmp___2);
}
}
extern size_t ( __attribute__((__leaf__)) __confstr_chk)(int __name , char *__buf ,
                                                         size_t __len , size_t __buflen ) __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
extern size_t ( __attribute__((__leaf__)) __confstr_alias)(int __name , char *__buf ,
                                                           size_t __len ) __asm__("confstr") __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
extern size_t ( __attribute__((__leaf__)) __confstr_chk_warn)(int __name , char *__buf ,
                                                              size_t __len , size_t __buflen ) __asm__("__confstr_chk") __attribute__((__warning__("confstr called with bigger length than size of destination buffer"),
__nothrow__)) ;
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len ) __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len )
{
  unsigned long tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;
  unsigned long tmp___6 ;
  size_t tmp___7 ;
  {
  tmp___6 = __builtin_object_size((void *)__buf, 1);
  tmp___7 = __confstr_chk(__name, __buf, __len, tmp___6);
  return (tmp___7);
}
}
extern int ( __attribute__((__warn_unused_result__, __leaf__)) __getgroups_chk)(int __size ,
                                                                                __gid_t *__list ,
                                                                                size_t __listlen ) __attribute__((__nothrow__,
__access__(__write_only__,2,1))) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) __getgroups_alias)(int __size ,
                                                                                  __gid_t *__list ) __asm__("getgroups") __attribute__((__nothrow__,
__access__(__write_only__,2,1))) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) __getgroups_chk_warn)(int __size ,
                                                                                     __gid_t *__list ,
                                                                                     size_t __listlen ) __asm__("__getgroups_chk") __attribute__((__warning__("getgroups called with bigger group count than what can fit into destination buffer"),
__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list ) __attribute__((__nothrow__,
__access__(__write_only__,2,1))) ;
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list )
{
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  unsigned long tmp___6 ;
  int tmp___7 ;
  {
  tmp___6 = __builtin_object_size((void *)__list, 1);
  tmp___7 = __getgroups_chk(__size, __list, tmp___6);
  return (tmp___7);
}
}
extern int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_chk)(int __fd ,
                                                                        char *__buf ,
                                                                        size_t __buflen ,
                                                                        size_t __nreal ) __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
extern int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_alias)(int __fd ,
                                                                          char *__buf ,
                                                                          size_t __buflen ) __asm__("ttyname_r") __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_chk_warn)(int __fd ,
                                                                             char *__buf ,
                                                                             size_t __buflen ,
                                                                             size_t __nreal ) __asm__("__ttyname_r_chk") __attribute__((__warning__("ttyname_r called with bigger buflen than size of destination buffer"),
__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen ) __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen )
{
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  unsigned long tmp___6 ;
  int tmp___7 ;
  {
  tmp___6 = __builtin_object_size((void *)__buf, 1);
  tmp___7 = __ttyname_r_chk(__fd, __buf, __buflen, tmp___6);
  return (tmp___7);
}
}
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk)(char *__buf , size_t __buflen ,
                                                               size_t __nreal ) __attribute__((__access__(__write_only__,1,2))) ;
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_alias)(char *__buf , size_t __buflen ) __asm__("getlogin_r") ;
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk_warn)(char *__buf ,
                                                                    size_t __buflen ,
                                                                    size_t __nreal ) __asm__("__getlogin_r_chk") __attribute__((__warning__("getlogin_r called with bigger buflen than size of destination buffer"))) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __artificial__,
__always_inline__)) getlogin_r)(char *__buf , size_t __buflen ) __attribute__((__access__(__write_only__,1,2))) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __artificial__,
__always_inline__)) getlogin_r)(char *__buf , size_t __buflen )
{
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  unsigned long tmp___6 ;
  int tmp___7 ;
  {
  tmp___6 = __builtin_object_size((void *)__buf, 1);
  tmp___7 = __getlogin_r_chk(__buf, __buflen, tmp___6);
  return (tmp___7);
}
}
extern int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_chk)(char *__buf ,
                                                                          size_t __buflen ,
                                                                          size_t __nreal ) __attribute__((__nothrow__,
__access__(__write_only__,1,2))) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_alias)(char *__buf ,
                                                                            size_t __buflen ) __asm__("gethostname") __attribute__((__nothrow__,
__access__(__write_only__,1,2))) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_chk_warn)(char *__buf ,
                                                                               size_t __buflen ,
                                                                               size_t __nreal ) __asm__("__gethostname_chk") __attribute__((__warning__("gethostname called with bigger buflen than size of destination buffer"),
__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) gethostname)(char *__buf , size_t __buflen ) __attribute__((__nothrow__,
__access__(__write_only__,1,2))) ;
__inline extern int ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) gethostname)(char *__buf , size_t __buflen )
{
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  unsigned long tmp___6 ;
  int tmp___7 ;
  {
  tmp___6 = __builtin_object_size((void *)__buf, 1);
  tmp___7 = __gethostname_chk(__buf, __buflen, tmp___6);
  return (tmp___7);
}
}
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) __getdomainname_chk)(char *__buf ,
                                                                                                    size_t __buflen ,
                                                                                                    size_t __nreal ) __attribute__((__nothrow__,
__access__(__write_only__,1,2))) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) __getdomainname_alias)(char *__buf ,
                                                                                                      size_t __buflen ) __asm__("getdomainname") __attribute__((__nothrow__,
__access__(__write_only__,1,2))) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) __getdomainname_chk_warn)(char *__buf ,
                                                                                                         size_t __buflen ,
                                                                                                         size_t __nreal ) __asm__("__getdomainname_chk") __attribute__((__warning__("getdomainname called with bigger buflen than size of destination buffer"),
__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) getdomainname)(char *__buf , size_t __buflen ) __attribute__((__nothrow__,
__access__(__write_only__,1,2))) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) getdomainname)(char *__buf , size_t __buflen )
{
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  unsigned long tmp___6 ;
  int tmp___7 ;
  {
  tmp___6 = __builtin_object_size((void *)__buf, 1);
  tmp___7 = __getdomainname_chk(__buf, __buflen, tmp___6);
  return (tmp___7);
}
}
extern __pid_t ( __attribute__((__leaf__)) gettid)(void) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) sigaltstack)(stack_t const *__ss , stack_t *__oss ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) sigstack)(struct sigstack *__ss , struct sigstack *__oss ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__leaf__)) sighold)(int __sig ) __attribute__((__nothrow__,
__deprecated__("Use the sigprocmask function instead"))) ;
extern int ( __attribute__((__leaf__)) sigrelse)(int __sig ) __attribute__((__nothrow__,
__deprecated__("Use the sigprocmask function instead"))) ;
extern int ( __attribute__((__leaf__)) sigignore)(int __sig ) __attribute__((__nothrow__,
__deprecated__("Use the signal function instead"))) ;
extern __sighandler_t ( __attribute__((__leaf__)) sigset)(int __sig , void (*__disp)(int ) ) __attribute__((__nothrow__,
__deprecated__("Use the signal and sigprocmask functions instead"))) ;
extern int ( __attribute__((__leaf__)) pthread_sigmask)(int __how , __sigset_t const *__newmask ,
                                                        __sigset_t *__oldmask ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) pthread_kill)(pthread_t __threadid , int __signo ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) pthread_sigqueue)(pthread_t __threadid , int __signo ,
                                                         union sigval const __value ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __libc_current_sigrtmin)(void) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __libc_current_sigrtmax)(void) __attribute__((__nothrow__)) ;
extern int tgkill(__pid_t __tgid , __pid_t __tid , int __signal ) ;
extern FILE *stdin ;
extern FILE *stdout ;
extern FILE *stderr ;
extern int ( __attribute__((__leaf__)) remove)(char const *__filename ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) rename)(char const *__old , char const *__new ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) renameat)(int __oldfd , char const *__old ,
                                                 int __newfd , char const *__new ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) renameat2)(int __oldfd , char const *__old ,
                                                  int __newfd , char const *__new ,
                                                  unsigned int __flags ) __attribute__((__nothrow__)) ;
extern int fclose(FILE *__stream ) ;
extern FILE *( __attribute__((__warn_unused_result__)) tmpfile)(void) __attribute__((__malloc__(fclose,1),
__malloc__)) ;
extern FILE *( __attribute__((__warn_unused_result__)) tmpfile64)(void) __attribute__((__malloc__(fclose,1),
__malloc__)) ;
extern char *( __attribute__((__warn_unused_result__, __leaf__)) tmpnam)(char * ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__warn_unused_result__, __leaf__)) tmpnam_r)(char *__s ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__warn_unused_result__, __leaf__)) tempnam)(char const *__dir ,
                                                                          char const *__pfx ) __attribute__((__nothrow__,
__malloc__(__builtin_free,1), __malloc__)) ;
extern int fflush(FILE *__stream ) ;
extern int fflush_unlocked(FILE *__stream ) ;
extern int fcloseall(void) ;
extern FILE *( __attribute__((__warn_unused_result__)) fopen)(char const *__filename ,
                                                              char const *__modes ) __attribute__((__malloc__(fclose,1),
__malloc__)) ;
extern FILE *( __attribute__((__warn_unused_result__)) freopen)(char const *__filename ,
                                                                char const *__modes ,
                                                                FILE *__stream ) ;
extern FILE *( __attribute__((__warn_unused_result__)) fopen64)(char const *__filename ,
                                                                char const *__modes ) __attribute__((__malloc__(fclose,1),
__malloc__)) ;
extern FILE *( __attribute__((__warn_unused_result__)) freopen64)(char const *__filename ,
                                                                  char const *__modes ,
                                                                  FILE *__stream ) ;
extern FILE *( __attribute__((__warn_unused_result__, __leaf__)) fdopen)(int __fd ,
                                                                         char const *__modes ) __attribute__((__nothrow__,
__malloc__(fclose,1), __malloc__)) ;
extern FILE *( __attribute__((__warn_unused_result__, __leaf__)) fopencookie)(void *__magic_cookie ,
                                                                              char const *__modes ,
                                                                              cookie_io_functions_t __io_funcs ) __attribute__((__nothrow__,
__malloc__(fclose,1), __malloc__)) ;
extern FILE *( __attribute__((__warn_unused_result__, __leaf__)) fmemopen)(void *__s ,
                                                                           size_t __len ,
                                                                           char const *__modes ) __attribute__((__nothrow__,
__malloc__(fclose,1), __malloc__)) ;
extern FILE *( __attribute__((__warn_unused_result__, __leaf__)) open_memstream)(char **__bufloc ,
                                                                                 size_t *__sizeloc ) __attribute__((__nothrow__,
__malloc__(fclose,1), __malloc__)) ;
extern void ( __attribute__((__leaf__)) setbuf)(FILE *__stream , char *__buf ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setvbuf)(FILE *__stream , char *__buf , int __modes ,
                                                size_t __n ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) setbuffer)(FILE *__stream , char *__buf ,
                                                   size_t __size ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) setlinebuf)(FILE *__stream ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const *__fmt
                                                                                                  , ...) ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const *__fmt
                                                                                                 , ...) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const *__fmt
                                                                                                            , ...) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const *__fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const *__fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const *__fmt ,
                                                                                                             __gnuc_va_list __ap ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const *__fmt
                                              , ...) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const *__fmt ,
                                               __gnuc_va_list __ap ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vasprintf)(char **__ptr ,
                                                                         char const *__fmt ,
                                                                         __gnuc_va_list __ap ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) __asprintf)(char **__ptr ,
                                                                          char const *__fmt
                                                                          , ...) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) asprintf)(char **__ptr ,
                                                                        char const *__fmt
                                                                        , ...) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) vdprintf)(int __fd , char const *__fmt , __gnuc_va_list __ap ) ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) dprintf)(int __fd , char const *__fmt , ...) ;
extern int ( __attribute__((__warn_unused_result__)) fscanf)(FILE *__stream , char const *__format
                                                             , ...) __asm__("__isoc99_fscanf") ;
extern int ( __attribute__((__warn_unused_result__)) scanf)(char const *__format
                                                            , ...) __asm__("__isoc99_scanf") ;
extern int ( __attribute__((__leaf__)) sscanf)(char const *__s , char const *__format
                                               , ...) __asm__("__isoc99_sscanf") __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__)) vfscanf)(FILE *__s ,
                                                                                     char const *__format ,
                                                                                     __gnuc_va_list __arg ) __asm__("__isoc99_vfscanf") ;
extern int ( __attribute__((__warn_unused_result__)) vscanf)(char const *__format ,
                                                                                    __gnuc_va_list __arg ) __asm__("__isoc99_vscanf") ;
extern int ( __attribute__((__leaf__)) vsscanf)(char const *__s ,
                                                                       char const *__format ,
                                                                       __gnuc_va_list __arg ) __asm__("__isoc99_vsscanf") __attribute__((__nothrow__)) ;
extern int fgetc(FILE *__stream ) ;
extern int getc(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
extern int fputc(int __c , FILE *__stream ) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
extern int getw(FILE *__stream ) ;
extern int putw(int __w , FILE *__stream ) ;
__inline extern char __attribute__((__access__(__write_only__,1,2))) *( __attribute__((__warn_unused_result__,
__gnu_inline__, __artificial__, __always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) __attribute__((__access__(__write_only__,1,2))) ;
__inline extern char __attribute__((__access__(__write_only__,1,2))) *( __attribute__((__warn_unused_result__,
__gnu_inline__, __artificial__, __always_inline__)) fgets_unlocked)(char *__s , int __n ,
                                                                    FILE *__stream ) __attribute__((__access__(__write_only__,1,2))) ;
extern __ssize_t ( __attribute__((__warn_unused_result__)) __getdelim)(char **__lineptr ,
                                                                       size_t *__n ,
                                                                       int __delimiter ,
                                                                       FILE *__stream ) ;
extern __ssize_t ( __attribute__((__warn_unused_result__)) getdelim)(char **__lineptr ,
                                                                     size_t *__n ,
                                                                     int __delimiter ,
                                                                     FILE *__stream ) ;
__inline extern __ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__)) getline)(char **__lineptr ,
                                                                                             size_t *__n ,
                                                                                             FILE *__stream ) ;
extern int fputs(char const *__s , FILE *__stream ) ;
extern int puts(char const *__s ) ;
extern int ungetc(int __c , FILE *__stream ) ;
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
extern size_t fwrite(void const *__ptr , size_t __size , size_t __n , FILE *__s ) ;
extern int fputs_unlocked(char const *__s , FILE *__stream ) ;
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread_unlocked)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
extern size_t fwrite_unlocked(void const *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
extern int fseek(FILE *__stream , long __off , int __whence ) ;
extern long ( __attribute__((__warn_unused_result__)) ftell)(FILE *__stream ) ;
extern void rewind(FILE *__stream ) ;
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
extern __off_t ( __attribute__((__warn_unused_result__)) ftello)(FILE *__stream ) ;
extern int fgetpos(FILE *__stream , fpos_t *__pos ) ;
extern int fsetpos(FILE *__stream , fpos_t const *__pos ) ;
extern int fseeko64(FILE *__stream , __off64_t __off , int __whence ) ;
extern __off64_t ( __attribute__((__warn_unused_result__)) ftello64)(FILE *__stream ) ;
extern int fgetpos64(FILE *__stream , fpos64_t *__pos ) ;
extern int fsetpos64(FILE *__stream , fpos64_t const *__pos ) ;
extern void ( __attribute__((__leaf__)) clearerr)(FILE *__stream ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) feof)(FILE *__stream ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) ferror)(FILE *__stream ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) clearerr_unlocked)(FILE *__stream ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__)) feof_unlocked)(FILE *__stream ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__)) ferror_unlocked)(FILE *__stream ) __attribute__((__nothrow__)) ;
extern void perror(char const *__s ) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) fileno)(FILE *__stream ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) fileno_unlocked)(FILE *__stream ) __attribute__((__nothrow__)) ;
extern int pclose(FILE *__stream ) ;
extern FILE *( __attribute__((__warn_unused_result__)) popen)(char const *__command ,
                                                              char const *__modes ) __attribute__((__malloc__(pclose,1),
__malloc__)) ;
extern char *( __attribute__((__leaf__)) ctermid)(char *__s ) __attribute__((__nothrow__,
__access__(__write_only__,1))) ;
extern char *cuserid(char *__s ) __attribute__((__access__(__write_only__,1))) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) obstack_printf)(struct obstack *__obstack , char const *__fmt
                                                    , ...) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) obstack_vprintf)(struct obstack *__obstack , char const *__fmt ,
                                                     __gnuc_va_list __ap ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) flockfile)(FILE *__stream ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) ftrylockfile)(FILE *__stream ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) funlockfile)(FILE *__stream ) __attribute__((__nothrow__)) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void)
{
  int tmp ;
  {
  tmp = getc(stdin);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp )
{
  long tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void)
{
  long tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c )
{
  int tmp ;
  {
  tmp = putc(__c, stdout);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream )
{
  long tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c )
{
  long tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern __ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__)) getline)(char **__lineptr ,
                                                                                             size_t *__n ,
                                                                                             FILE *__stream )
{
  __ssize_t tmp ;
  {
  tmp = __getdelim((char ** __restrict )__lineptr, (size_t * __restrict )__n, '\n',
                   (FILE * __restrict )__stream);
  return (tmp);
}
}
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__)) feof_unlocked)(FILE *__stream ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__)) feof_unlocked)(FILE *__stream )
{
  {
  return ((__stream->_flags & 0x0010) != 0);
}
}
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__)) ferror_unlocked)(FILE *__stream ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__)) ferror_unlocked)(FILE *__stream )
{
  {
  return ((__stream->_flags & 0x0020) != 0);
}
}
extern int ( __attribute__((__leaf__)) __sprintf_chk)(char *__s , int __flag , size_t __slen ,
                                                      char const *__format , ...) __attribute__((__nothrow__,
__access__(__write_only__,1,3))) ;
extern int ( __attribute__((__leaf__)) __vsprintf_chk)(char *__s , int __flag , size_t __slen ,
                                                       char const *__format , __gnuc_va_list __ap ) __attribute__((__nothrow__,
__access__(__write_only__,1,3))) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const *__fmt
                                                                                                            , ...) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const *__fmt
                                                                                                            , ...)
{
  unsigned long tmp ;
  int tmp___0 ;
  {
  tmp = __builtin_object_size((void *)__s, 1);
  tmp___0 = __builtin___sprintf_chk(__s, 1, tmp, __fmt, __builtin_va_arg_pack());
  return (tmp___0);
}
}
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const *__fmt ,
                                                                                                             __gnuc_va_list __ap ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const *__fmt ,
                                                                                                             __gnuc_va_list __ap )
{
  unsigned long tmp ;
  int tmp___0 ;
  {
  tmp = __builtin_object_size((void *)__s, 1);
  tmp___0 = __builtin___vsprintf_chk(__s, 1, tmp, __fmt, __ap);
  return (tmp___0);
}
}
extern int ( __attribute__((__leaf__)) __snprintf_chk)(char *__s , size_t __n , int __flag ,
                                                       size_t __slen , char const *__format
                                                       , ...) __attribute__((__nothrow__,
__access__(__write_only__,1,2))) ;
extern int ( __attribute__((__leaf__)) __vsnprintf_chk)(char *__s , size_t __n , int __flag ,
                                                        size_t __slen , char const *__format ,
                                                        __gnuc_va_list __ap ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const *__fmt
                                              , ...) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const *__fmt
                                              , ...)
{
  unsigned long tmp ;
  int tmp___0 ;
  {
  tmp = __builtin_object_size((void *)__s, 1);
  tmp___0 = __builtin___snprintf_chk(__s, __n, 1, tmp, __fmt, __builtin_va_arg_pack());
  return (tmp___0);
}
}
__inline extern int ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const *__fmt ,
                                               __gnuc_va_list __ap ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const *__fmt ,
                                               __gnuc_va_list __ap )
{
  unsigned long tmp ;
  int tmp___0 ;
  {
  tmp = __builtin_object_size((void *)__s, 1);
  tmp___0 = __builtin___vsnprintf_chk(__s, __n, 1, tmp, __fmt, __ap);
  return (tmp___0);
}
}
extern int __fprintf_chk(FILE *__stream , int __flag , char const *__format , ...) ;
extern int __printf_chk(int __flag , char const *__format , ...) ;
extern int __vfprintf_chk(FILE *__stream , int __flag , char const *__format , __gnuc_va_list __ap ) ;
extern int __vprintf_chk(int __flag , char const *__format , __gnuc_va_list __ap ) ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const *__fmt
                                                                                                  , ...)
{
  int tmp ;
  {
  tmp = __fprintf_chk((FILE * __restrict )__stream, 1, (char const * __restrict )__fmt,
                      __builtin_va_arg_pack());
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const *__fmt
                                                                                                 , ...)
{
  int tmp ;
  {
  tmp = __printf_chk(1, (char const * __restrict )__fmt, __builtin_va_arg_pack());
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const *__fmt ,
                                                                                                  __gnuc_va_list __ap )
{
  int tmp ;
  {
  tmp = __vfprintf_chk((FILE * __restrict )stdout, 1, (char const * __restrict )__fmt,
                       __ap);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const *__fmt ,
                                                                                                   __gnuc_va_list __ap )
{
  int tmp ;
  {
  tmp = __vfprintf_chk((FILE * __restrict )__stream, 1, (char const * __restrict )__fmt,
                       __ap);
  return (tmp);
}
}
extern int ( __dprintf_chk)(int __fd , int __flag , char const *__fmt
                                                    , ...) ;
extern int ( __vdprintf_chk)(int __fd , int __flag , char const *__fmt ,
                                                     __gnuc_va_list __arg ) ;
__inline extern int ( __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) dprintf)(int __fd , char const *__fmt , ...)
{
  int tmp ;
  {
  tmp = __dprintf_chk(__fd, 1, (char const * __restrict )__fmt, __builtin_va_arg_pack());
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) vdprintf)(int __fd , char const *__fmt , __gnuc_va_list __ap )
{
  int tmp ;
  {
  tmp = __vdprintf_chk(__fd, 1, (char const * __restrict )__fmt, __ap);
  return (tmp);
}
}
extern int ( __attribute__((__warn_unused_result__, __leaf__)) __asprintf_chk)(char **__ptr ,
                                                                                                      int __flag ,
                                                                                                      char const *__fmt
                                                                                                      , ...) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) __vasprintf_chk)(char **__ptr ,
                                                                                                       int __flag ,
                                                                                                       char const *__fmt ,
                                                                                                       __gnuc_va_list __arg ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __obstack_printf_chk)(struct obstack *__obstack ,
                                                                                    int __flag ,
                                                                                    char const *__format
                                                                                    , ...) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __obstack_vprintf_chk)(struct obstack *__obstack ,
                                                                                     int __flag ,
                                                                                     char const *__format ,
                                                                                     __gnuc_va_list __args ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) asprintf)(char **__ptr ,
                                                                        char const *__fmt
                                                                        , ...) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) asprintf)(char **__ptr ,
                                                                        char const *__fmt
                                                                        , ...)
{
  int tmp ;
  {
  tmp = __asprintf_chk((char ** __restrict )__ptr, 1, (char const * __restrict )__fmt,
                       __builtin_va_arg_pack());
  return (tmp);
}
}
__inline extern int ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) obstack_printf)(struct obstack *__obstack , char const *__fmt
                                                    , ...) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) obstack_printf)(struct obstack *__obstack , char const *__fmt
                                                    , ...)
{
  int tmp ;
  {
  tmp = __obstack_printf_chk((struct obstack * __restrict )__obstack, 1, (char const * __restrict )__fmt,
                             __builtin_va_arg_pack());
  return (tmp);
}
}
__inline extern int ( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vasprintf)(char **__ptr ,
                                                                         char const *__fmt ,
                                                                         __gnuc_va_list __ap ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vasprintf)(char **__ptr ,
                                                                         char const *__fmt ,
                                                                         __gnuc_va_list __ap )
{
  int tmp ;
  {
  tmp = __vasprintf_chk((char ** __restrict )__ptr, 1, (char const * __restrict )__fmt,
                        __ap);
  return (tmp);
}
}
__inline extern int ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) obstack_vprintf)(struct obstack *__obstack , char const *__fmt ,
                                                     __gnuc_va_list __ap ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) obstack_vprintf)(struct obstack *__obstack , char const *__fmt ,
                                                     __gnuc_va_list __ap )
{
  int tmp ;
  {
  tmp = __obstack_vprintf_chk((struct obstack * __restrict )__obstack, 1, (char const * __restrict )__fmt,
                              __ap);
  return (tmp);
}
}
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk)(char *__s , size_t __size ,
                                                                    int __n , FILE *__stream ) __attribute__((__access__(__write_only__,1,3))) ;
extern char *( __attribute__((__warn_unused_result__)) __fgets_alias)(char *__s ,
                                                                      int __n , FILE *__stream ) __asm__("fgets") __attribute__((__access__(__write_only__,1,2))) ;
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk_warn)(char *__s ,
                                                                         size_t __size ,
                                                                         int __n ,
                                                                         FILE *__stream ) __asm__("__fgets_chk") __attribute__((__warning__("fgets called with bigger size than length of destination buffer"))) ;
__inline extern char __attribute__((__access__(__write_only__,1,2))) *( __attribute__((__warn_unused_result__,
__gnu_inline__, __artificial__, __always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) __attribute__((__access__(__write_only__,1,2))) ;
__inline extern char __attribute__((__access__(__write_only__,1,2))) *( __attribute__((__warn_unused_result__,
__gnu_inline__, __artificial__, __always_inline__)) fgets)(char *__s , int __n , FILE *__stream )
{
  size_t sz ;
  unsigned long tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  {
  tmp = __builtin_object_size((void *)__s, 1);
  sz = tmp;
  tmp___2 = __fgets_chk((char * __restrict )__s, sz, __n, (FILE * __restrict )__stream);
  return ((char __attribute__((__access__(__write_only__,1,2))) *)tmp___2);
}
}
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk)(void *__ptr ,
                                                                     size_t __ptrlen ,
                                                                     size_t __size ,
                                                                     size_t __n ,
                                                                     FILE *__stream ) ;
extern size_t ( __attribute__((__warn_unused_result__)) __fread_alias)(void *__ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE *__stream ) __asm__("fread") ;
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk_warn)(void *__ptr ,
                                                                          size_t __ptrlen ,
                                                                          size_t __size ,
                                                                          size_t __n ,
                                                                          FILE *__stream ) __asm__("__fread_chk") __attribute__((__warning__("fread called with bigger size * nmemb than length of destination buffer"))) ;
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream )
{
  size_t sz ;
  unsigned long tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  {
  tmp = __builtin_object_size(__ptr, 0);
  sz = tmp;
  tmp___2 = __fread_chk((void * __restrict )__ptr, sz, __size, __n, (FILE * __restrict )__stream);
  return (tmp___2);
}
}
extern char *( __attribute__((__warn_unused_result__)) __fgets_unlocked_chk)(char *__s ,
                                                                             size_t __size ,
                                                                             int __n ,
                                                                             FILE *__stream ) __attribute__((__access__(__write_only__,1,3))) ;
extern char *( __attribute__((__warn_unused_result__)) __fgets_unlocked_alias)(char *__s ,
                                                                               int __n ,
                                                                               FILE *__stream ) __asm__("fgets_unlocked") __attribute__((__access__(__write_only__,1,2))) ;
extern char *( __attribute__((__warn_unused_result__)) __fgets_unlocked_chk_warn)(char *__s ,
                                                                                  size_t __size ,
                                                                                  int __n ,
                                                                                  FILE *__stream ) __asm__("__fgets_unlocked_chk") __attribute__((__warning__("fgets_unlocked called with bigger size than length of destination buffer"))) ;
__inline extern char __attribute__((__access__(__write_only__,1,2))) *( __attribute__((__warn_unused_result__,
__gnu_inline__, __artificial__, __always_inline__)) fgets_unlocked)(char *__s , int __n ,
                                                                    FILE *__stream ) __attribute__((__access__(__write_only__,1,2))) ;
__inline extern char __attribute__((__access__(__write_only__,1,2))) *( __attribute__((__warn_unused_result__,
__gnu_inline__, __artificial__, __always_inline__)) fgets_unlocked)(char *__s , int __n ,
                                                                    FILE *__stream )
{
  size_t sz ;
  unsigned long tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  {
  tmp = __builtin_object_size((void *)__s, 1);
  sz = tmp;
  tmp___2 = __fgets_unlocked_chk((char * __restrict )__s, sz, __n, (FILE * __restrict )__stream);
  return ((char __attribute__((__access__(__write_only__,1,2))) *)tmp___2);
}
}
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk)(void *__ptr ,
                                                                              size_t __ptrlen ,
                                                                              size_t __size ,
                                                                              size_t __n ,
                                                                              FILE *__stream ) ;
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_alias)(void *__ptr ,
                                                                                size_t __size ,
                                                                                size_t __n ,
                                                                                FILE *__stream ) __asm__("fread_unlocked") ;
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk_warn)(void *__ptr ,
                                                                                   size_t __ptrlen ,
                                                                                   size_t __size ,
                                                                                   size_t __n ,
                                                                                   FILE *__stream ) __asm__("__fread_unlocked_chk") __attribute__((__warning__("fread_unlocked called with bigger size * nmemb than length of destination buffer"))) ;
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread_unlocked)(void *__ptr , size_t __size , size_t __n , FILE *__stream )
{
  size_t sz ;
  unsigned long tmp ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  int tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  {
  tmp = __builtin_object_size(__ptr, 0);
  sz = tmp;
  tmp___4 = __fread_unlocked_chk((void * __restrict )__ptr, sz, __size, __n, (FILE * __restrict )__stream);
  return (tmp___4);
}
}
extern size_t ( __attribute__((__warn_unused_result__, __leaf__)) __ctype_get_mb_cur_max)(void) __attribute__((__nothrow__)) ;
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const *__nptr ) __attribute__((__pure__, __nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const *__nptr ) __attribute__((__pure__, __nothrow__)) ;
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const *__nptr ) __attribute__((__pure__, __nothrow__)) ;
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const *__nptr ) __attribute__((__pure__,
__nothrow__)) ;
extern double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const *__nptr ,
                                                                  char **__endptr ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__nonnull__(1), __leaf__)) strtof)(char const *__nptr ,
                                                                 char **__endptr ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__nonnull__(1), __leaf__)) strtold)(char const *__nptr ,
                                                                        char **__endptr ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__nonnull__(1), __leaf__)) strtof32)(char const *__nptr ,
                                                                   char **__endptr ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__nonnull__(1), __leaf__)) strtof64)(char const *__nptr ,
                                                                    char **__endptr ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__nonnull__(1), __leaf__)) strtof128)(char const *__nptr ,
                                                                          char **__endptr ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__nonnull__(1), __leaf__)) strtof32x)(char const *__nptr ,
                                                                     char **__endptr ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__nonnull__(1), __leaf__)) strtof64x)(char const *__nptr ,
                                                                          char **__endptr ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const *__nptr ,
                                                                char **__endptr ,
                                                                int __base ) __attribute__((__nothrow__)) ;
extern unsigned long ( __attribute__((__nonnull__(1), __leaf__)) strtoul)(char const *__nptr ,
                                                                          char **__endptr ,
                                                                          int __base ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__nonnull__(1), __leaf__)) strtoq)(char const *__nptr ,
                                                                     char **__endptr ,
                                                                     int __base ) __attribute__((__nothrow__)) ;
extern unsigned long long ( __attribute__((__nonnull__(1), __leaf__)) strtouq)(char const *__nptr ,
                                                                               char **__endptr ,
                                                                               int __base ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__nonnull__(1), __leaf__)) strtoll)(char const *__nptr ,
                                                                      char **__endptr ,
                                                                      int __base ) __attribute__((__nothrow__)) ;
extern unsigned long long ( __attribute__((__nonnull__(1), __leaf__)) strtoull)(char const *__nptr ,
                                                                                char **__endptr ,
                                                                                int __base ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(3), __leaf__)) strfromd)(char *__dest , size_t __size ,
                                                                 char const *__format ,
                                                                 double __f ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(3), __leaf__)) strfromf)(char *__dest , size_t __size ,
                                                                 char const *__format ,
                                                                 float __f ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(3), __leaf__)) strfroml)(char *__dest , size_t __size ,
                                                                 char const *__format ,
                                                                 long double __f ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(3), __leaf__)) strfromf32)(char *__dest ,
                                                                   size_t __size ,
                                                                   char const *__format ,
                                                                   float __f ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(3), __leaf__)) strfromf64)(char *__dest ,
                                                                   size_t __size ,
                                                                   char const *__format ,
                                                                   double __f ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(3), __leaf__)) strfromf128)(char *__dest ,
                                                                    size_t __size ,
                                                                    char const *__format ,
                                                                    long double __f ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(3), __leaf__)) strfromf32x)(char *__dest ,
                                                                    size_t __size ,
                                                                    char const *__format ,
                                                                    double __f ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(3), __leaf__)) strfromf64x)(char *__dest ,
                                                                    size_t __size ,
                                                                    char const *__format ,
                                                                    long double __f ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__nonnull__(1,4), __leaf__)) strtol_l)(char const *__nptr ,
                                                                    char **__endptr ,
                                                                    int __base , locale_t __loc ) __attribute__((__nothrow__)) ;
extern unsigned long ( __attribute__((__nonnull__(1,4), __leaf__)) strtoul_l)(char const *__nptr ,
                                                                              char **__endptr ,
                                                                              int __base ,
                                                                              locale_t __loc ) __attribute__((__nothrow__)) ;
extern long long ( __attribute__((__nonnull__(1,4), __leaf__)) strtoll_l)(char const *__nptr ,
                                                                          char **__endptr ,
                                                                          int __base ,
                                                                          locale_t __loc ) __attribute__((__nothrow__)) ;
extern unsigned long long ( __attribute__((__nonnull__(1,4), __leaf__)) strtoull_l)(char const *__nptr ,
                                                                                    char **__endptr ,
                                                                                    int __base ,
                                                                                    locale_t __loc ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__nonnull__(1,3), __leaf__)) strtod_l)(char const *__nptr ,
                                                                      char **__endptr ,
                                                                      locale_t __loc ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__nonnull__(1,3), __leaf__)) strtof_l)(char const *__nptr ,
                                                                     char **__endptr ,
                                                                     locale_t __loc ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__nonnull__(1,3), __leaf__)) strtold_l)(char const *__nptr ,
                                                                            char **__endptr ,
                                                                            locale_t __loc ) __attribute__((__nothrow__)) ;
extern float ( __attribute__((__nonnull__(1,3), __leaf__)) strtof32_l)(char const *__nptr ,
                                                                       char **__endptr ,
                                                                       locale_t __loc ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__nonnull__(1,3), __leaf__)) strtof64_l)(char const *__nptr ,
                                                                        char **__endptr ,
                                                                        locale_t __loc ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__nonnull__(1,3), __leaf__)) strtof128_l)(char const *__nptr ,
                                                                              char **__endptr ,
                                                                              locale_t __loc ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__nonnull__(1,3), __leaf__)) strtof32x_l)(char const *__nptr ,
                                                                         char **__endptr ,
                                                                         locale_t __loc ) __attribute__((__nothrow__)) ;
extern long double ( __attribute__((__nonnull__(1,3), __leaf__)) strtof64x_l)(char const *__nptr ,
                                                                              char **__endptr ,
                                                                              locale_t __loc ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const *__nptr ) __attribute__((__pure__, __nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const *__nptr )
{
  long tmp ;
  {
  tmp = strtol((char const * __restrict )__nptr, (char ** __restrict )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const *__nptr ) __attribute__((__pure__, __nothrow__)) ;
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const *__nptr )
{
  long tmp ;
  {
  tmp = strtol((char const * __restrict )__nptr, (char ** __restrict )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const *__nptr ) __attribute__((__pure__,
__nothrow__)) ;
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const *__nptr )
{
  long long tmp ;
  {
  tmp = strtoll((char const * __restrict )__nptr, (char ** __restrict )((char **)((void *)0)),
                10);
  return (tmp);
}
}
extern char *( __attribute__((__warn_unused_result__, __leaf__)) l64a)(long __n ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) a64l)(char const *__s ) __attribute__((__pure__,
__nothrow__)) ;
extern long ( __attribute__((__leaf__)) random)(void) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__nonnull__(2), __leaf__)) initstate)(unsigned int __seed ,
                                                                    char *__statebuf ,
                                                                    size_t __statelen ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__nonnull__(1), __leaf__)) setstate)(char *__statebuf ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) random_r)(struct random_data *__buf ,
                                                                   int32_t *__result ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2), __leaf__)) srandom_r)(unsigned int __seed ,
                                                                  struct random_data *__buf ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2,4), __leaf__)) initstate_r)(unsigned int __seed ,
                                                                      char *__statebuf ,
                                                                      size_t __statelen ,
                                                                      struct random_data *__buf ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) setstate_r)(char *__statebuf ,
                                                                     struct random_data *__buf ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) rand)(void) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) rand_r)(unsigned int *__seed ) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__leaf__)) drand48)(void) __attribute__((__nothrow__)) ;
extern double ( __attribute__((__nonnull__(1), __leaf__)) erand48)(unsigned short *__xsubi ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) lrand48)(void) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__nonnull__(1), __leaf__)) nrand48)(unsigned short *__xsubi ) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__leaf__)) mrand48)(void) __attribute__((__nothrow__)) ;
extern long ( __attribute__((__nonnull__(1), __leaf__)) jrand48)(unsigned short *__xsubi ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) srand48)(long __seedval ) __attribute__((__nothrow__)) ;
extern unsigned short *( __attribute__((__nonnull__(1), __leaf__)) seed48)(unsigned short *__seed16v ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__nonnull__(1), __leaf__)) lcong48)(unsigned short *__param ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) drand48_r)(struct drand48_data *__buffer ,
                                                                    double *__result ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) erand48_r)(unsigned short *__xsubi ,
                                                                    struct drand48_data *__buffer ,
                                                                    double *__result ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) lrand48_r)(struct drand48_data *__buffer ,
                                                                    long *__result ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) nrand48_r)(unsigned short *__xsubi ,
                                                                    struct drand48_data *__buffer ,
                                                                    long *__result ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) mrand48_r)(struct drand48_data *__buffer ,
                                                                    long *__result ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) jrand48_r)(unsigned short *__xsubi ,
                                                                    struct drand48_data *__buffer ,
                                                                    long *__result ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2), __leaf__)) srand48_r)(long __seedval ,
                                                                  struct drand48_data *__buffer ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) seed48_r)(unsigned short *__seed16v ,
                                                                   struct drand48_data *__buffer ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) lcong48_r)(unsigned short *__param ,
                                                                    struct drand48_data *__buffer ) __attribute__((__nothrow__)) ;
extern void *( __attribute__((__warn_unused_result__, __leaf__)) malloc)(size_t __size ) __attribute__((__nothrow__,
__malloc__, __alloc_size__(1))) ;
extern void *( __attribute__((__warn_unused_result__, __leaf__)) calloc)(size_t __nmemb ,
                                                                         size_t __size ) __attribute__((__nothrow__,
__malloc__, __alloc_size__(1,2))) ;
extern void *( __attribute__((__warn_unused_result__, __leaf__)) realloc)(void *__ptr ,
                                                                          size_t __size ) __attribute__((__nothrow__,
__alloc_size__(2))) ;
extern void ( __attribute__((__leaf__)) free)(void *__ptr ) __attribute__((__nothrow__)) ;
extern void *( __attribute__((__warn_unused_result__, __leaf__)) reallocarray)(void *__ptr ,
                                                                               size_t __nmemb ,
                                                                               size_t __size ) __attribute__((__nothrow__,
__malloc__(__builtin_free,1), __malloc__(reallocarray,1), __alloc_size__(2,3))) ;
extern void *( __attribute__((__leaf__)) alloca)(size_t __size ) __attribute__((__nothrow__)) ;
extern void *( __attribute__((__warn_unused_result__, __leaf__)) valloc)(size_t __size ) __attribute__((__nothrow__,
__malloc__, __alloc_size__(1))) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) posix_memalign)(void **__memptr ,
                                                                                               size_t __alignment ,
                                                                                               size_t __size ) __attribute__((__nothrow__)) ;
extern void *( __attribute__((__warn_unused_result__, __leaf__)) aligned_alloc)(size_t __alignment ,
                                                                                size_t __size ) __attribute__((__nothrow__,
__malloc__, __alloc_size__(2), __alloc_align__(1))) ;
extern void ( __attribute__((__leaf__)) abort)(void) __attribute__((__nothrow__,
__noreturn__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) at_quick_exit)(void (*__func)(void) ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) on_exit)(void (*__func)(int __status ,
                                                                               void *__arg ) ,
                                                                void *__arg ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) exit)(int __status ) __attribute__((__nothrow__,
__noreturn__)) ;
extern void ( __attribute__((__leaf__)) quick_exit)(int __status ) __attribute__((__nothrow__,
__noreturn__)) ;
extern void ( __attribute__((__leaf__)) _Exit)(int __status ) __attribute__((__nothrow__,
__noreturn__)) ;
extern char *( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) getenv)(char const *__name ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) secure_getenv)(char const *__name ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const *__name ,
                                                               char const *__value ,
                                                               int __replace ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) unsetenv)(char const *__name ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) clearenv)(void) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__nonnull__(1), __leaf__)) mktemp)(char *__template ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkstemp)(char *__template ) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkstemp64)(char *__template ) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkstemps)(char *__template ,
                                                                               int __suffixlen ) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkstemps64)(char *__template ,
                                                                                 int __suffixlen ) ;
extern char *( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) mkdtemp)(char *__template ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkostemp)(char *__template ,
                                                                               int __flags ) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkostemp64)(char *__template ,
                                                                                 int __flags ) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkostemps)(char *__template ,
                                                                                int __suffixlen ,
                                                                                int __flags ) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkostemps64)(char *__template ,
                                                                                  int __suffixlen ,
                                                                                  int __flags ) ;
extern int ( __attribute__((__warn_unused_result__)) system)(char const *__command ) ;
extern char *( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) canonicalize_file_name)(char const *__name ) __attribute__((__nothrow__,
__malloc__(__builtin_free,1), __malloc__)) ;
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) realpath)(char const *__name , char *__resolved ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__nonnull__(1,4))) qsort_r)(void *__base , size_t __nmemb ,
                                                         size_t __size , int (*__compar)(void const * ,
                                                                                         void const * ,
                                                                                         void * ) ,
                                                         void *__arg ) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) abs)(int __x ) __attribute__((__nothrow__,
__const__)) ;
extern long ( __attribute__((__warn_unused_result__, __leaf__)) labs)(long __x ) __attribute__((__nothrow__,
__const__)) ;
extern long long ( __attribute__((__warn_unused_result__, __leaf__)) llabs)(long long __x ) __attribute__((__nothrow__,
__const__)) ;
extern div_t ( __attribute__((__warn_unused_result__, __leaf__)) div)(int __numer ,
                                                                      int __denom ) __attribute__((__nothrow__,
__const__)) ;
extern ldiv_t ( __attribute__((__warn_unused_result__, __leaf__)) ldiv)(long __numer ,
                                                                        long __denom ) __attribute__((__nothrow__,
__const__)) ;
extern lldiv_t ( __attribute__((__warn_unused_result__, __leaf__)) lldiv)(long long __numer ,
                                                                          long long __denom ) __attribute__((__nothrow__,
__const__)) ;
extern char *( __attribute__((__warn_unused_result__, __nonnull__(3,4), __leaf__)) ecvt)(double __value ,
                                                                                         int __ndigit ,
                                                                                         int *__decpt ,
                                                                                         int *__sign ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__warn_unused_result__, __nonnull__(3,4), __leaf__)) fcvt)(double __value ,
                                                                                         int __ndigit ,
                                                                                         int *__decpt ,
                                                                                         int *__sign ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__warn_unused_result__, __nonnull__(3), __leaf__)) gcvt)(double __value ,
                                                                                       int __ndigit ,
                                                                                       char *__buf ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__warn_unused_result__, __nonnull__(3,4), __leaf__)) qecvt)(long double __value ,
                                                                                          int __ndigit ,
                                                                                          int *__decpt ,
                                                                                          int *__sign ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__warn_unused_result__, __nonnull__(3,4), __leaf__)) qfcvt)(long double __value ,
                                                                                          int __ndigit ,
                                                                                          int *__decpt ,
                                                                                          int *__sign ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__warn_unused_result__, __nonnull__(3), __leaf__)) qgcvt)(long double __value ,
                                                                                        int __ndigit ,
                                                                                        char *__buf ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(3,4,5), __leaf__)) ecvt_r)(double __value ,
                                                                   int __ndigit ,
                                                                   int *__decpt ,
                                                                   int *__sign , char *__buf ,
                                                                   size_t __len ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(3,4,5), __leaf__)) fcvt_r)(double __value ,
                                                                   int __ndigit ,
                                                                   int *__decpt ,
                                                                   int *__sign , char *__buf ,
                                                                   size_t __len ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(3,4,5), __leaf__)) qecvt_r)(long double __value ,
                                                                    int __ndigit ,
                                                                    int *__decpt ,
                                                                    int *__sign ,
                                                                    char *__buf ,
                                                                    size_t __len ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(3,4,5), __leaf__)) qfcvt_r)(long double __value ,
                                                                    int __ndigit ,
                                                                    int *__decpt ,
                                                                    int *__sign ,
                                                                    char *__buf ,
                                                                    size_t __len ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) mblen)(char const *__s , size_t __n ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) mbtowc)(wchar_t *__pwc , char const *__s ,
                                               size_t __n ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar ) __attribute__((__nothrow__)) ;
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const *__src , size_t __len ) __attribute__((__nothrow__,
__access__(__read_only__,2))) ;
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const *__src , size_t __len ) __attribute__((__nothrow__,
__access__(__read_only__,2), __access__(__write_only__,1,3))) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) rpmatch)(char const *__response ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1,2,3), __leaf__)) getsubopt)(char **__optionp ,
                                                                                              char **__tokens ,
                                                                                              char **__valuep ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__)) posix_openpt)(int __oflag ) ;
extern int ( __attribute__((__leaf__)) grantpt)(int __fd ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) unlockpt)(int __fd ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__warn_unused_result__, __leaf__)) ptsname)(int __fd ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(2), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) ptsname_r)(int __fd , char *__buf , size_t __buflen ) __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
extern int getpt(void) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) getloadavg)(double *__loadavg ,
                                                                   int __nelem ) __attribute__((__nothrow__)) ;
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const *__nptr ) __attribute__((__pure__, __nothrow__)) ;
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const *__nptr )
{
  double tmp ;
  {
  tmp = strtod((char const * __restrict )__nptr, (char ** __restrict )((char **)((void *)0)));
  return (tmp);
}
}
extern char *( __attribute__((__warn_unused_result__, __leaf__)) __realpath_chk)(char const *__name ,
                                                                                 char *__resolved ,
                                                                                 size_t __resolvedlen ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__warn_unused_result__, __leaf__)) __realpath_alias)(char const *__name ,
                                                                                   char *__resolved ) __asm__("realpath") __attribute__((__nothrow__)) ;
extern char *( __attribute__((__warn_unused_result__, __leaf__)) __realpath_chk_warn)(char const *__name ,
                                                                                      char *__resolved ,
                                                                                      size_t __resolvedlen ) __asm__("__realpath_chk") __attribute__((__warning__("second argument of realpath must be either NULL or at least PATH_MAX bytes long buffer"),
__nothrow__)) ;
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) realpath)(char const *__name , char *__resolved ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) realpath)(char const *__name , char *__resolved )
{
  size_t sz ;
  unsigned long tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  {
  tmp = __builtin_object_size((void *)__resolved, 1);
  sz = tmp;
  if (sz == 18446744073709551615UL) {
    tmp___0 = __realpath_alias((char const * __restrict )__name, (char * __restrict )__resolved);
    return (tmp___0);
  }
  tmp___2 = __realpath_chk((char const * __restrict )__name, (char * __restrict )__resolved,
                           sz);
  return (tmp___2);
}
}
extern int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_chk)(int __fd ,
                                                                        char *__buf ,
                                                                        size_t __buflen ,
                                                                        size_t __nreal ) __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
extern int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_alias)(int __fd ,
                                                                          char *__buf ,
                                                                          size_t __buflen ) __asm__("ptsname_r") __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
extern int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_chk_warn)(int __fd ,
                                                                             char *__buf ,
                                                                             size_t __buflen ,
                                                                             size_t __nreal ) __asm__("__ptsname_r_chk") __attribute__((__warning__("ptsname_r called with buflen bigger than size of buf"),
__nothrow__)) ;
__inline extern int ( __attribute__((__nonnull__(2), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) ptsname_r)(int __fd , char *__buf , size_t __buflen ) __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
__inline extern int ( __attribute__((__nonnull__(2), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) ptsname_r)(int __fd , char *__buf , size_t __buflen )
{
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  unsigned long tmp___6 ;
  int tmp___7 ;
  {
  tmp___6 = __builtin_object_size((void *)__buf, 1);
  tmp___7 = __ptsname_r_chk(__fd, __buf, __buflen, tmp___6);
  return (tmp___7);
}
}
extern int ( __attribute__((__warn_unused_result__, __leaf__)) __wctomb_chk)(char *__s ,
                                                                             wchar_t __wchar ,
                                                                             size_t __buflen ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __leaf__)) __wctomb_alias)(char *__s ,
                                                                               wchar_t __wchar ) __asm__("wctomb") __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar ) __attribute__((__nothrow__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  {
  tmp___1 = __builtin_object_size((void *)__s, 1);
  if (tmp___1 != 18446744073709551615UL) {
    tmp___2 = __builtin_object_size((void *)__s, 1);
    if (16UL > tmp___2) {
      tmp = __builtin_object_size((void *)__s, 1);
      tmp___0 = __wctomb_chk(__s, __wchar, tmp);
      return (tmp___0);
    }
  }
  tmp___3 = __wctomb_alias(__s, __wchar);
  return (tmp___3);
}
}
extern size_t ( __attribute__((__leaf__)) __mbstowcs_chk)(wchar_t *__dst , char const *__src ,
                                                          size_t __len , size_t __dstlen ) __attribute__((__nothrow__,
__access__(__read_only__,2), __access__(__write_only__,1,3))) ;
extern size_t ( __attribute__((__leaf__)) __mbstowcs_alias)(wchar_t *__dst , char const *__src ,
                                                            size_t __len ) __asm__("mbstowcs") __attribute__((__nothrow__,
__access__(__read_only__,2), __access__(__write_only__,1,3))) ;
extern size_t ( __attribute__((__leaf__)) __mbstowcs_chk_warn)(wchar_t *__dst , char const *__src ,
                                                               size_t __len , size_t __dstlen ) __asm__("__mbstowcs_chk") __attribute__((__warning__("mbstowcs called with dst buffer smaller than len * sizeof (wchar_t)"),
__nothrow__)) ;
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const *__src , size_t __len ) __attribute__((__nothrow__,
__access__(__read_only__,2))) ;
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const *__src , size_t __len )
{
  unsigned long tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;
  unsigned long tmp___6 ;
  size_t tmp___7 ;
  {
  tmp___6 = __builtin_object_size((void *)__dst, 1);
  tmp___7 = __mbstowcs_chk((wchar_t * __restrict )__dst, (char const * __restrict )__src,
                           __len, tmp___6 / sizeof(wchar_t ));
  return (tmp___7);
}
}
extern size_t ( __attribute__((__leaf__)) __wcstombs_chk)(char *__dst , wchar_t const *__src ,
                                                          size_t __len , size_t __dstlen ) __attribute__((__nothrow__,
__access__(__read_only__,2), __access__(__write_only__,1,3))) ;
extern size_t ( __attribute__((__leaf__)) __wcstombs_alias)(char *__dst , wchar_t const *__src ,
                                                            size_t __len ) __asm__("wcstombs") __attribute__((__nothrow__,
__access__(__read_only__,2), __access__(__write_only__,1,3))) ;
extern size_t ( __attribute__((__leaf__)) __wcstombs_chk_warn)(char *__dst , wchar_t const *__src ,
                                                               size_t __len , size_t __dstlen ) __asm__("__wcstombs_chk") __attribute__((__warning__("wcstombs called with dst buffer smaller than len"),
__nothrow__)) ;
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const *__src , size_t __len ) __attribute__((__nothrow__,
__access__(__read_only__,2), __access__(__write_only__,1,3))) ;
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const *__src , size_t __len )
{
  unsigned long tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;
  unsigned long tmp___6 ;
  size_t tmp___7 ;
  {
  tmp___6 = __builtin_object_size((void *)__dst, 1);
  tmp___7 = __wcstombs_chk((char * __restrict )__dst, (wchar_t const * __restrict )__src,
                           __len, tmp___6);
  return (tmp___7);
}
}
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const *__src , size_t __len ) __attribute__((__nothrow__)) ;
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const *__src ,
                                             size_t __len ) __attribute__((__nothrow__)) ;
extern void *( __attribute__((__nonnull__(1,2), __leaf__)) memccpy)(void *__dest ,
                                                                    void const *__src ,
                                                                    int __c , size_t __n ) __attribute__((__nothrow__,
__access__(__write_only__,1,4))) ;
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const *__s1 ,
                                                                 void const *__s2 ,
                                                                 size_t __n ) __attribute__((__pure__,
__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) __memcmpeq)(void const *__s1 ,
                                                                     void const *__s2 ,
                                                                     size_t __n ) __attribute__((__pure__,
__nothrow__)) ;
extern void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const *__s ,
                                                                 int __c , size_t __n ) __attribute__((__pure__,
__nothrow__)) ;
extern void *( __attribute__((__nonnull__(1), __leaf__)) rawmemchr)(void const *__s ,
                                                                    int __c ) __attribute__((__pure__,
__nothrow__)) ;
extern void *( __attribute__((__nonnull__(1), __leaf__)) memrchr)(void const *__s ,
                                                                  int __c , size_t __n ) __attribute__((__pure__,
__nothrow__, __access__(__read_only__,1,3))) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const *__src ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const *__src ,
                                             size_t __len ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const *__src ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const *__src ,
                                             size_t __len ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const *__s1 ,
                                                                 char const *__s2 ) __attribute__((__pure__,
__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const *__s1 ,
                                                                  char const *__s2 ,
                                                                  size_t __n ) __attribute__((__pure__,
__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) strcoll)(char const *__s1 ,
                                                                  char const *__s2 ) __attribute__((__pure__,
__nothrow__)) ;
extern size_t ( __attribute__((__nonnull__(2), __leaf__)) strxfrm)(char *__dest ,
                                                                   char const *__src ,
                                                                   size_t __n ) __attribute__((__nothrow__,
__access__(__write_only__,1,3))) ;
extern int ( __attribute__((__nonnull__(1,2,3), __leaf__)) strcoll_l)(char const *__s1 ,
                                                                      char const *__s2 ,
                                                                      locale_t __l ) __attribute__((__pure__,
__nothrow__)) ;
extern size_t ( __attribute__((__nonnull__(2,4), __leaf__)) strxfrm_l)(char *__dest ,
                                                                       char const *__src ,
                                                                       size_t __n ,
                                                                       locale_t __l ) __attribute__((__nothrow__,
__access__(__write_only__,1,3))) ;
extern char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const *__s ) __attribute__((__nothrow__,
__malloc__)) ;
extern char *( __attribute__((__nonnull__(1), __leaf__)) strndup)(char const *__string ,
                                                                  size_t __n ) __attribute__((__nothrow__,
__malloc__)) ;
extern char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const *__s ,
                                                                 int __c ) __attribute__((__pure__,
__nothrow__)) ;
extern char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const *__s ,
                                                                  int __c ) __attribute__((__pure__,
__nothrow__)) ;
extern char *( __attribute__((__nonnull__(1), __leaf__)) strchrnul)(char const *__s ,
                                                                    int __c ) __attribute__((__pure__,
__nothrow__)) ;
extern size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const *__s ,
                                                                     char const *__reject ) __attribute__((__pure__,
__nothrow__)) ;
extern size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const *__s ,
                                                                    char const *__accept ) __attribute__((__pure__,
__nothrow__)) ;
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const *__s ,
                                                                    char const *__accept ) __attribute__((__pure__,
__nothrow__)) ;
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const *__haystack ,
                                                                   char const *__needle ) __attribute__((__pure__,
__nothrow__)) ;
extern char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char *__s , char const *__delim ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__nonnull__(2,3), __leaf__)) __strtok_r)(char *__s ,
                                                                       char const *__delim ,
                                                                       char **__save_ptr ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__nonnull__(2,3), __leaf__)) strtok_r)(char *__s , char const *__delim ,
                                                                     char **__save_ptr ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) strcasestr)(char const *__haystack ,
                                                                       char const *__needle ) __attribute__((__pure__,
__nothrow__)) ;
extern void *( __attribute__((__nonnull__(1,3), __leaf__)) memmem)(void const *__haystack ,
                                                                   size_t __haystacklen ,
                                                                   void const *__needle ,
                                                                   size_t __needlelen ) __attribute__((__pure__,
__nothrow__, __access__(__read_only__,3,4), __access__(__read_only__,1,2))) ;
extern void *( __attribute__((__nonnull__(1,2), __leaf__)) __mempcpy)(void *__dest ,
                                                                      void const *__src ,
                                                                      size_t __n ) __attribute__((__nothrow__)) ;
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) mempcpy)(void *__dest , void const *__src ,
                                             size_t __len ) __attribute__((__nothrow__)) ;
extern size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const *__s ) __attribute__((__pure__,
__nothrow__)) ;
extern size_t ( __attribute__((__nonnull__(1), __leaf__)) strnlen)(char const *__string ,
                                                                   size_t __maxlen ) __attribute__((__pure__,
__nothrow__)) ;
extern char *( __attribute__((__leaf__)) strerror)(int __errnum ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__)) strerror_r)(int __errnum ,
                                                                                             char *__buf ,
                                                                                             size_t __buflen ) __attribute__((__nothrow__,
__access__(__write_only__,2,3))) ;
extern char const *( __attribute__((__leaf__)) strerrordesc_np)(int __err ) __attribute__((__nothrow__)) ;
extern char const *( __attribute__((__leaf__)) strerrorname_np)(int __err ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__leaf__)) strerror_l)(int __errnum , locale_t __l ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) bcmp)(void const *__s1 ,
                                                               void const *__s2 ,
                                                               size_t __n ) __attribute__((__pure__,
__nothrow__)) ;
__inline extern void ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) bcopy)(void const *__src , void *__dest , size_t __len ) __attribute__((__nothrow__)) ;
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) bzero)(void *__dest , size_t __len ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__nonnull__(1), __leaf__)) index)(char const *__s ,
                                                                int __c ) __attribute__((__pure__,
__nothrow__)) ;
extern char *( __attribute__((__nonnull__(1), __leaf__)) rindex)(char const *__s ,
                                                                 int __c ) __attribute__((__pure__,
__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ffs)(int __i ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) ffsl)(long __l ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) ffsll)(long long __ll ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const *__s1 ,
                                                                     char const *__s2 ) __attribute__((__pure__,
__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const *__s1 ,
                                                                      char const *__s2 ,
                                                                      size_t __n ) __attribute__((__pure__,
__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2,3), __leaf__)) strcasecmp_l)(char const *__s1 ,
                                                                         char const *__s2 ,
                                                                         locale_t __loc ) __attribute__((__pure__,
__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2,4), __leaf__)) strncasecmp_l)(char const *__s1 ,
                                                                          char const *__s2 ,
                                                                          size_t __n ,
                                                                          locale_t __loc ) __attribute__((__pure__,
__nothrow__)) ;
__inline extern void ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) bcopy)(void const *__src , void *__dest , size_t __len ) __attribute__((__nothrow__)) ;
__inline extern void ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) bcopy)(void const *__src , void *__dest , size_t __len )
{
  unsigned long tmp ;
  {
  tmp = __builtin_object_size(__dest, 0);
  __builtin___memmove_chk(__dest, __src, __len, tmp);
  return;
}
}
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) bzero)(void *__dest , size_t __len ) __attribute__((__nothrow__)) ;
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) bzero)(void *__dest , size_t __len )
{
  unsigned long tmp ;
  {
  tmp = __builtin_object_size(__dest, 0);
  __builtin___memset_chk(__dest, '\000', __len, tmp);
  return;
}
}
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) explicit_bzero)(void *__dest , size_t __len ) __attribute__((__nothrow__,
__access__(__write_only__,1,2))) ;
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) strsep)(char **__stringp ,
                                                                   char const *__delim ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__leaf__)) strsignal)(int __sig ) __attribute__((__nothrow__)) ;
extern char const *( __attribute__((__leaf__)) sigabbrev_np)(int __sig ) __attribute__((__nothrow__)) ;
extern char const *( __attribute__((__leaf__)) sigdescr_np)(int __sig ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) __stpcpy)(char *__dest ,
                                                                     char const *__src ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) stpcpy)(char *__dest , char const *__src ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) __stpncpy)(char *__dest ,
                                                                      char const *__src ,
                                                                      size_t __n ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) stpncpy)(char *__dest , char const *__src ,
                                             size_t __n ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) strverscmp)(char const *__s1 ,
                                                                     char const *__s2 ) __attribute__((__pure__,
__nothrow__)) ;
extern char *( __attribute__((__nonnull__(1), __leaf__)) strfry)(char *__string ) __attribute__((__nothrow__)) ;
extern void *( __attribute__((__nonnull__(1), __leaf__)) memfrob)(void *__s , size_t __n ) __attribute__((__nothrow__,
__access__(__read_write__,1,2))) ;
extern char *( __attribute__((__nonnull__(1), __leaf__)) basename)(char const *__filename ) __attribute__((__nothrow__)) ;
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const *__src , size_t __len ) __attribute__((__nothrow__)) ;
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const *__src , size_t __len )
{
  unsigned long tmp ;
  void *tmp___0 ;
  {
  tmp = __builtin_object_size(__dest, 0);
  tmp___0 = __builtin___memcpy_chk(__dest, __src, __len, tmp);
  return (tmp___0);
}
}
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const *__src ,
                                             size_t __len ) __attribute__((__nothrow__)) ;
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const *__src ,
                                             size_t __len )
{
  unsigned long tmp ;
  void *tmp___0 ;
  {
  tmp = __builtin_object_size(__dest, 0);
  tmp___0 = __builtin___memmove_chk(__dest, __src, __len, tmp);
  return (tmp___0);
}
}
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) mempcpy)(void *__dest , void const *__src ,
                                             size_t __len ) __attribute__((__nothrow__)) ;
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) mempcpy)(void *__dest , void const *__src ,
                                             size_t __len )
{
  unsigned long tmp ;
  void *tmp___0 ;
  {
  tmp = __builtin_object_size(__dest, 0);
  tmp___0 = __builtin___mempcpy_chk(__dest, __src, __len, tmp);
  return (tmp___0);
}
}
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len ) __attribute__((__nothrow__)) ;
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )
{
  unsigned long tmp ;
  void *tmp___0 ;
  {
  tmp = __builtin_object_size(__dest, 0);
  tmp___0 = __builtin___memset_chk(__dest, __ch, __len, tmp);
  return (tmp___0);
}
}
extern void ( __attribute__((__nonnull__(1), __leaf__)) __explicit_bzero_chk)(void *__dest ,
                                                                              size_t __len ,
                                                                              size_t __destlen ) __attribute__((__nothrow__,
__access__(__write_only__,1,2))) ;
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) explicit_bzero)(void *__dest , size_t __len ) __attribute__((__nothrow__,
__access__(__write_only__,1,2))) ;
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) explicit_bzero)(void *__dest , size_t __len )
{
  unsigned long tmp ;
  {
  tmp = __builtin_object_size(__dest, 0);
  __explicit_bzero_chk(__dest, __len, tmp);
  return;
}
}
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const *__src ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const *__src )
{
  unsigned long tmp ;
  char *tmp___0 ;
  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strcpy_chk(__dest, __src, tmp);
  return (tmp___0);
}
}
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) stpcpy)(char *__dest , char const *__src ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) stpcpy)(char *__dest , char const *__src )
{
  unsigned long tmp ;
  char *tmp___0 ;
  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___stpcpy_chk(__dest, __src, tmp);
  return (tmp___0);
}
}
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const *__src ,
                                             size_t __len ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const *__src ,
                                             size_t __len )
{
  unsigned long tmp ;
  char *tmp___0 ;
  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strncpy_chk(__dest, __src, __len, tmp);
  return (tmp___0);
}
}
extern int ( __builtin___stpncpy_chk)() ;
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) stpncpy)(char *__dest , char const *__src ,
                                             size_t __n ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) stpncpy)(char *__dest , char const *__src ,
                                             size_t __n )
{
  unsigned long tmp ;
  int tmp___0 ;
  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___stpncpy_chk(__dest, __src, __n, tmp);
  return ((char *)tmp___0);
}
}
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const *__src ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const *__src )
{
  unsigned long tmp ;
  char *tmp___0 ;
  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strcat_chk(__dest, __src, tmp);
  return (tmp___0);
}
}
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const *__src ,
                                             size_t __len ) __attribute__((__nothrow__)) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const *__src ,
                                             size_t __len )
{
  unsigned long tmp ;
  char *tmp___0 ;
  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strncat_chk(__dest, __src, __len, tmp);
  return (tmp___0);
}
}
extern int ( __attribute__((__leaf__)) ioctl)(int __fd , unsigned long __request
                                              , ...) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const *__file ,
                                                               struct stat *__buf ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd , struct stat *__buf ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) stat64)(char const *__file ,
                                                                 struct stat64 *__buf ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2), __leaf__)) fstat64)(int __fd , struct stat64 *__buf ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2,3), __leaf__)) fstatat)(int __fd , char const *__file ,
                                                                  struct stat *__buf ,
                                                                  int __flag ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2,3), __leaf__)) fstatat64)(int __fd , char const *__file ,
                                                                    struct stat64 *__buf ,
                                                                    int __flag ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const *__file ,
                                                                struct stat *__buf ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat64)(char const *__file ,
                                                                  struct stat64 *__buf ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const *__file ,
                                                              __mode_t __mode ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) lchmod)(char const *__file ,
                                                               __mode_t __mode ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) fchmod)(int __fd , __mode_t __mode ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__)) fchmodat)(int __fd ,
                                                                                         char const *__file ,
                                                                                         __mode_t __mode ,
                                                                                         int __flag ) __attribute__((__nothrow__)) ;
extern __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) __attribute__((__nothrow__)) ;
extern __mode_t ( __attribute__((__leaf__)) getumask)(void) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const *__path ,
                                                              __mode_t __mode ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2), __leaf__)) mkdirat)(int __fd , char const *__path ,
                                                                __mode_t __mode ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) mknod)(char const *__path ,
                                                              __mode_t __mode , __dev_t __dev ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2), __leaf__)) mknodat)(int __fd , char const *__path ,
                                                                __mode_t __mode ,
                                                                __dev_t __dev ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) mkfifo)(char const *__path ,
                                                               __mode_t __mode ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2), __leaf__)) mkfifoat)(int __fd , char const *__path ,
                                                                 __mode_t __mode ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2), __leaf__)) utimensat)(int __fd , char const *__path ,
                                                                  struct timespec const *__times ,
                                                                  int __flags ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) futimens)(int __fd , struct timespec const *__times ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2,5), __leaf__)) statx)(int __dirfd , char const *__path ,
                                                                int __flags , unsigned int __mask ,
                                                                struct statx *__buf ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval *__tv ,
                                                                     void *__tz ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) settimeofday)(struct timeval const *__tv ,
                                                     struct timezone const *__tz ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) adjtime)(struct timeval const *__delta ,
                                                struct timeval *__olddelta ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) getitimer)(__itimer_which_t __which , struct itimerval *__value ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setitimer)(__itimer_which_t __which , struct itimerval const *__new ,
                                                  struct itimerval *__old ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) utimes)(char const *__file ,
                                                               struct timeval const *__tvp ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) lutimes)(char const *__file ,
                                                                struct timeval const *__tvp ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) futimes)(int __fd , struct timeval const *__tvp ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) futimesat)(int __fd , char const *__file ,
                                                  struct timeval const *__tvp ) __attribute__((__nothrow__)) ;
extern key_t ( __attribute__((__leaf__)) ftok)(char const *__pathname , int __proj_id ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __getpagesize)(void) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__)) shmctl)(int __shmid , int __cmd , struct shmid_ds *__buf ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) shmget)(key_t __key , size_t __size , int __shmflg ) __attribute__((__nothrow__)) ;
extern void *( __attribute__((__leaf__)) shmat)(int __shmid , void const *__shmaddr ,
                                                int __shmflg ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) shmdt)(void const *__shmaddr ) __attribute__((__nothrow__)) ;
extern __pid_t wait(int *__stat_loc ) ;
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
extern int waitid(idtype_t __idtype , __id_t __id , siginfo_t *__infop , int __options ) ;
extern __pid_t wait3(int *__stat_loc , int __options , struct rusage *__usage ) __attribute__((__nothrow__)) ;
extern __pid_t wait4(__pid_t __pid , int *__stat_loc , int __options , struct rusage *__usage ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) clock_adjtime)(__clockid_t __clock_id , struct timex *__utx ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__leaf__)) strptime)(char const *__s , char const *__fmt ,
                                                   struct tm *__tp ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__leaf__)) strptime_l)(char const *__s , char const *__fmt ,
                                                     struct tm *__tp , locale_t __loc ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) timespec_getres)(struct timespec *__ts , int __base ) __attribute__((__nothrow__)) ;
extern int getdate_err ;
extern struct tm *getdate(char const *__string ) ;
extern int getdate_r(char const *__string , struct tm *__resbufp ) ;
extern int ( __attribute__((__leaf__)) adjtimex)(struct timex *__ntx ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ntp_gettimex)(struct ntptimeval *__ntv ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ntp_gettime)(struct ntptimeval *__ntv ) __asm__("ntp_gettimex") __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ntp_adjtime)(struct timex *__tntx ) __attribute__((__nothrow__)) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) getrandom)(void *__buffer ,
                                                                    size_t __length ,
                                                                    unsigned int __flags ) ;
ARR_Instance ARR_CreateInstance(unsigned int elem_size ) ;
void ARR_DestroyInstance(ARR_Instance array ) ;
void *ARR_GetNewElement(ARR_Instance array ) ;
void *ARR_GetElement(ARR_Instance array , unsigned int index___0 ) ;
void *ARR_GetElements(ARR_Instance array ) ;
void ARR_AppendElement(ARR_Instance array , void *element ) ;
void ARR_SetSize(ARR_Instance array , unsigned int size ) ;
unsigned int ARR_GetSize(ARR_Instance array ) ;
void *Malloc(size_t size ) ;
void *Realloc(void *ptr , size_t size ) ;
void *Malloc2(size_t nmemb , size_t size ) ;
void *Realloc2(void *ptr , size_t nmemb , size_t size ) ;
char *Strdup(char const *s ) ;
ARR_Instance ARR_CreateInstance(unsigned int elem_size )
{
  ARR_Instance array ;
  void *tmp ;
  {
  assert(elem_size > 0U);
  tmp = Malloc(sizeof(struct ARR_Instance_Record ));
  array = (struct ARR_Instance_Record *)tmp;
  array->data = (void *)0;
  array->elem_size = elem_size;
  array->used = 0U;
  array->allocated = 0U;
  return (array);
}
}
void ARR_DestroyInstance(ARR_Instance array )
{
  {
  free(array->data);
  free((void *)array);
  return;
}
}
static void realloc_array(ARR_Instance array , unsigned int min_size )
{
  {
  assert(min_size <= 2U * min_size);
  if (array->allocated >= min_size) {
    if (array->allocated <= 2U * min_size) {
      return;
    }
  }
  if (array->allocated < min_size) {
    {
    while (1) {
      while_continue: ;
      if (! (array->allocated < min_size)) {
        goto while_break;
      }
      if (array->allocated) {
        array->allocated = 2U * array->allocated;
      } else {
        array->allocated = 1U;
      }
    }
    while_break: ;
    }
  } else {
    array->allocated = min_size;
  }
  array->data = Realloc2(array->data, (size_t )array->allocated, (size_t )array->elem_size);
  return;
}
}
void *ARR_GetNewElement(ARR_Instance array )
{
  void *tmp ;
  {
  (array->used) ++;
  realloc_array(array, array->used);
  tmp = ARR_GetElement(array, array->used - 1U);
  return (tmp);
}
}
void *ARR_GetElement(ARR_Instance array , unsigned int index___0 )
{
  {
  assert(index___0 < array->used);
  return ((void *)((char *)array->data + (size_t )index___0 * (size_t )array->elem_size));
}
}
void *ARR_GetElements(ARR_Instance array )
{
  {
  if (! array->data) {
    assert(! array->used);
    return ((void *)array);
  }
  return (array->data);
}
}
void ARR_AppendElement(ARR_Instance array , void *element )
{
  void *e ;
  {
  e = ARR_GetNewElement(array);
  memcpy(e, (void const *)element, (size_t )array->elem_size);
  return;
}
}
void ARR_SetSize(ARR_Instance array , unsigned int size )
{
  {
  realloc_array(array, size);
  array->used = size;
  return;
}
}
unsigned int ARR_GetSize(ARR_Instance array )
{
  {
  return (array->used);
}
}
int HSH_GetHashId(HSH_Algorithm algorithm ) ;
int HSH_Hash(int id , void const *in1 , int in1_len , void const *in2 , int in2_len ,
             unsigned char *out , int out_len ) ;
void HSH_Finalise(void) ;
void SST_Initialise(void) ;
void SST_Finalise(void) ;
SST_Stats SST_CreateInstance(uint32_t refid , IPAddr *addr , int min_samples___0 ,
                             int max_samples___0 , double min_delay , double asymmetry ) ;
void SST_DeleteInstance(SST_Stats inst ) ;
void SST_ResetInstance(SST_Stats inst ) ;
void SST_SetRefid(SST_Stats inst , uint32_t refid , IPAddr *addr ) ;
void SST_AccumulateSample(SST_Stats inst , NTP_Sample *sample ) ;
void SST_DoNewRegression(SST_Stats inst ) ;
void SST_GetFrequencyRange(SST_Stats inst , double *lo , double *hi ) ;
void SST_GetSelectionData(SST_Stats inst , struct timespec *now , double *offset_lo_limit ,
                          double *offset_hi_limit , double *root_distance , double *std_dev ,
                          double *first_sample_ago , double *last_sample_ago , int *select_ok ) ;
void SST_GetTrackingData(SST_Stats inst , struct timespec *ref_time , double *average_offset ,
                         double *offset_sd , double *frequency , double *frequency_sd ,
                         double *skew , double *root_delay , double *root_dispersion ) ;
void SST_SlewSamples(SST_Stats inst , struct timespec *when , double dfreq , double doffset ) ;
void SST_CorrectOffset(SST_Stats inst , double doffset ) ;
void SST_AddDispersion(SST_Stats inst , double dispersion ) ;
double SST_PredictOffset(SST_Stats inst , struct timespec *when ) ;
double SST_MinRoundTripDelay(SST_Stats inst ) ;
int SST_GetDelayTestData(SST_Stats inst , struct timespec *sample_time , double *last_sample_ago ,
                         double *predicted_offset , double *min_delay , double *skew ,
                         double *std_dev ) ;
int SST_SaveToFile(SST_Stats inst , FILE *out ) ;
int SST_LoadFromFile(SST_Stats inst , FILE *in ) ;
void SST_DoSourceReport(SST_Stats inst , RPT_SourceReport *report , struct timespec *now ) ;
void SST_DoSourcestatsReport(SST_Stats inst , RPT_SourcestatsReport *report , struct timespec *now ) ;
int SST_Samples(SST_Stats inst ) ;
double SST_GetJitterAsymmetry(SST_Stats inst ) ;
void SRC_Initialise(void) ;
void SRC_Finalise(void) ;
SRC_Instance SRC_CreateNewInstance(uint32_t ref_id , SRC_Type type , int authenticated ,
                                   int sel_options , IPAddr *addr , int min_samples___0 ,
                                   int max_samples___0 , double min_delay , double asymmetry ) ;
void SRC_DestroyInstance(SRC_Instance instance ) ;
void SRC_ResetInstance(SRC_Instance instance ) ;
void SRC_SetRefid(SRC_Instance instance , uint32_t ref_id , IPAddr *addr ) ;
SST_Stats SRC_GetSourcestats(SRC_Instance instance ) ;
void SRC_UpdateStatus(SRC_Instance inst , int stratum , NTP_Leap leap ) ;
void SRC_AccumulateSample(SRC_Instance inst , NTP_Sample *sample ) ;
void SRC_SetActive(SRC_Instance inst ) ;
void SRC_UnsetActive(SRC_Instance inst ) ;
void SRC_UpdateReachability(SRC_Instance inst , int reachable ) ;
void SRC_ResetReachability(SRC_Instance inst ) ;
void SRC_SelectSource(SRC_Instance updated_inst ) ;
void SRC_ReselectSource(void) ;
void SRC_SetReselectDistance(double distance ) ;
void SRC_DumpSources(void) ;
void SRC_ReloadSources(void) ;
void SRC_RemoveDumpFiles(void) ;
void SRC_ResetSources(void) ;
int SRC_IsSyncPeer(SRC_Instance inst ) ;
int SRC_IsReachable(SRC_Instance inst ) ;
int SRC_ReadNumberOfSources(void) ;
int SRC_ActiveSources(void) ;
int SRC_ReportSource(int index___0 , RPT_SourceReport *report , struct timespec *now ) ;
int SRC_ReportSourcestats(int index___0 , RPT_SourcestatsReport *report , struct timespec *now ) ;
int SRC_GetSelectReport(int index___0 , RPT_SelectReport *report ) ;
SRC_Type SRC_GetType(int index___0 ) ;
int CPS_ParseNTPSourceAdd(char *line , CPS_NTP_Source *src ) ;
int CPS_ParseAllowDeny(char *line , int *all , IPAddr *ip , int *subnet_bits ) ;
int CPS_ParseLocal(char *line , int *stratum , int *orphan , double *distance ) ;
void CPS_NormalizeLine(char *line ) ;
char *CPS_SplitWord(char *line ) ;
int CPS_ParseKey(char *line , uint32_t *id , char const **type , char **key ) ;
void DNS_SetAddressFamily(int family ) ;
DNS_Status DNS_Name2IPAddress(char const *name , IPAddr *ip_addrs , int max_addrs ) ;
int DNS_IPAddress2Name(IPAddr *ip_addr , char *name , int len ) ;
void DNS_Reload(void) ;
int CMC_GetKeyLength(CMC_Algorithm algorithm ) ;
CMC_Instance CMC_CreateInstance(CMC_Algorithm algorithm , unsigned char const *key ,
                                int length ) ;
int CMC_Hash(CMC_Instance inst , void const *in , int in_len , unsigned char *out ,
             int out_len ) ;
void CMC_DestroyInstance(CMC_Instance inst ) ;
void UTI_ZeroTimespec(struct timespec *ts ) ;
int UTI_IsZeroTimespec(struct timespec *ts ) ;
void UTI_TimevalToTimespec(struct timeval const *tv , struct timespec *ts ) ;
void UTI_TimespecToTimeval(struct timespec const *ts , struct timeval *tv ) ;
double UTI_TimespecToDouble(struct timespec const *ts ) ;
void UTI_DoubleToTimespec(double d , struct timespec *ts ) ;
void UTI_NormaliseTimespec(struct timespec *ts ) ;
double UTI_TimevalToDouble(struct timeval const *tv ) ;
void UTI_DoubleToTimeval(double a , struct timeval *b ) ;
void UTI_NormaliseTimeval(struct timeval *x ) ;
int UTI_CompareTimespecs(struct timespec const *a , struct timespec const *b ) ;
void UTI_DiffTimespecs(struct timespec *result , struct timespec const *a , struct timespec const *b ) ;
double UTI_DiffTimespecsToDouble(struct timespec const *a , struct timespec const *b ) ;
void UTI_AddDoubleToTimespec(struct timespec const *start , double increment , struct timespec *end ) ;
void UTI_AverageDiffTimespecs(struct timespec const *earlier , struct timespec const *later ,
                              struct timespec *average , double *diff ) ;
void UTI_AddDiffToTimespec(struct timespec const *a , struct timespec const *b ,
                           struct timespec const *c , struct timespec *result ) ;
char *UTI_TimespecToString(struct timespec const *ts ) ;
char *UTI_Ntp64ToString(NTP_int64 const *ntp_ts ) ;
char *UTI_RefidToString(uint32_t ref_id ) ;
char *UTI_IPToString(IPAddr const *addr ) ;
int UTI_StringToIP(char const *addr , IPAddr *ip ) ;
int UTI_IsStringIP(char const *string ) ;
int UTI_StringToIdIP(char const *addr , IPAddr *ip ) ;
int UTI_IsIPReal(IPAddr const *ip ) ;
uint32_t UTI_IPToRefid(IPAddr const *ip ) ;
uint32_t UTI_IPToHash(IPAddr const *ip ) ;
void UTI_IPHostToNetwork(IPAddr const *src , IPAddr *dest ) ;
void UTI_IPNetworkToHost(IPAddr const *src , IPAddr *dest ) ;
int UTI_CompareIPs(IPAddr const *a , IPAddr const *b , IPAddr const *mask ) ;
char *UTI_IPSockAddrToString(IPSockAddr const *sa ) ;
char *UTI_TimeToLogForm(time_t t ) ;
void UTI_AdjustTimespec(struct timespec const *old_ts , struct timespec const *when ,
                        struct timespec *new_ts , double *delta_time , double dfreq ,
                        double doffset ) ;
void UTI_GetNtp64Fuzz(NTP_int64 *ts , int precision ) ;
double UTI_Ntp32ToDouble(NTP_int32 x ) ;
NTP_int32 UTI_DoubleToNtp32(double x ) ;
double UTI_Ntp32f28ToDouble(NTP_int32 x ) ;
NTP_int32 UTI_DoubleToNtp32f28(double x ) ;
void UTI_ZeroNtp64(NTP_int64 *ts ) ;
int UTI_IsZeroNtp64(NTP_int64 const *ts ) ;
int UTI_CompareNtp64(NTP_int64 const *a , NTP_int64 const *b ) ;
int UTI_IsEqualAnyNtp64(NTP_int64 const *a , NTP_int64 const *b1 , NTP_int64 const *b2 ,
                        NTP_int64 const *b3 ) ;
void UTI_TimespecToNtp64(struct timespec const *src , NTP_int64 *dest , NTP_int64 const *fuzz ) ;
void UTI_Ntp64ToTimespec(NTP_int64 const *src , struct timespec *dest ) ;
double UTI_DiffNtp64ToDouble(NTP_int64 const *a , NTP_int64 const *b ) ;
int UTI_IsTimeOffsetSane(struct timespec const *ts , double offset ) ;
double UTI_Log2ToDouble(int l ) ;
void UTI_TimespecNetworkToHost(Timespec const *src , struct timespec *dest ) ;
void UTI_TimespecHostToNetwork(struct timespec const *src , Timespec *dest ) ;
double UTI_FloatNetworkToHost(Float f ) ;
Float UTI_FloatHostToNetwork(double x ) ;
CMC_Algorithm UTI_CmacNameToAlgorithm(char const *name ) ;
HSH_Algorithm UTI_HashNameToAlgorithm(char const *name ) ;
int UTI_FdSetCloexec(int fd___0 ) ;
void UTI_SetQuitSignalsHandler(void (*handler)(int ) , int ignore_sigpipe ) ;
char *UTI_PathToDir(char const *path ) ;
int UTI_CreateDirAndParents(char const *path , mode_t mode___0 , uid_t uid , gid_t gid ) ;
int UTI_CheckDirPermissions(char const *path , mode_t perm , uid_t uid , gid_t gid ) ;
FILE *UTI_OpenFile(char const *basedir , char const *name , char const *suffix ,
                   char mode___0 , mode_t perm ) ;
int UTI_RenameTempFile(char const *basedir , char const *name , char const *old_suffix ,
                       char const *new_suffix ) ;
int UTI_RemoveFile(char const *basedir , char const *name , char const *suffix ) ;
void UTI_DropRoot(uid_t uid , gid_t gid ) ;
void UTI_GetRandomBytesUrandom(void *buf , unsigned int len ) ;
void UTI_GetRandomBytes(void *buf , unsigned int len ) ;
void UTI_ResetGetRandomFunctions(void) ;
int UTI_BytesToHex(void const *buf , unsigned int buf_len , char *hex , unsigned int hex_len ) ;
unsigned int UTI_HexToBytes(char const *hex , void *buf , unsigned int len ) ;
int UTI_SplitString(char *string , char **words , int max_saved_words ) ;
int CPS_ParseNTPSourceAdd(char *line , CPS_NTP_Source *src )
{
  char *hostname ;
  char *cmd ;
  uint32_t ef_type ;
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  {
  src->port = 123;
  src->params.minpoll = 6;
  src->params.maxpoll = 10;
  src->params.connectivity = (SRC_Connectivity )1;
  src->params.auto_offline = 0;
  src->params.presend_minpoll = 100;
  src->params.burst = 0;
  src->params.iburst = 0;
  src->params.min_stratum = 0;
  src->params.poll_target = 8;
  src->params.version = 0;
  src->params.max_sources = 4;
  src->params.min_samples = -1;
  src->params.max_samples = -1;
  src->params.filter_length = 0;
  src->params.interleaved = 0;
  src->params.sel_options = 0;
  src->params.nts = 0;
  src->params.nts_port = 4460;
  src->params.copy = 0;
  src->params.ext_fields = 0;
  src->params.authkey = (uint32_t )0;
  src->params.cert_set = (uint32_t )0;
  src->params.max_delay = 3.0;
  src->params.max_delay_ratio = 0.0;
  src->params.max_delay_dev_ratio = 10.0;
  src->params.min_delay = 0.0;
  src->params.asymmetry = 1.0;
  src->params.offset = 0.0;
  hostname = line;
  line = CPS_SplitWord(line);
  if (! *hostname) {
    return (0);
  }
  src->name = hostname;
  {
  while (1) {
    while_continue: ;
    if (! *line) {
      goto while_break;
    }
    cmd = line;
    line = CPS_SplitWord(line);
    n = 0;
    tmp___51 = strcasecmp((char const *)cmd, (char const *)"auto_offline");
    if (tmp___51) {
      tmp___50 = strcasecmp((char const *)cmd, (char const *)"burst");
      if (tmp___50) {
        tmp___49 = strcasecmp((char const *)cmd, (char const *)"copy");
        if (tmp___49) {
          tmp___48 = strcasecmp((char const *)cmd, (char const *)"iburst");
          if (tmp___48) {
            tmp___47 = strcasecmp((char const *)cmd, (char const *)"offline");
            if (tmp___47) {
              tmp___46 = strcasecmp((char const *)cmd, (char const *)"noselect");
              if (tmp___46) {
                tmp___45 = strcasecmp((char const *)cmd, (char const *)"prefer");
                if (tmp___45) {
                  tmp___44 = strcasecmp((char const *)cmd, (char const *)"require");
                  if (tmp___44) {
                    tmp___43 = strcasecmp((char const *)cmd, (char const *)"trust");
                    if (tmp___43) {
                      tmp___42 = strcasecmp((char const *)cmd, (char const *)"certset");
                      if (tmp___42) {
                        tmp___41 = strcasecmp((char const *)cmd, (char const *)"key");
                        if (tmp___41) {
                          tmp___40 = strcasecmp((char const *)cmd, (char const *)"asymmetry");
                          if (tmp___40) {
                            tmp___39 = strcasecmp((char const *)cmd, (char const *)"extfield");
                            if (tmp___39) {
                              tmp___38 = strcasecmp((char const *)cmd, (char const *)"filter");
                              if (tmp___38) {
                                tmp___37 = strcasecmp((char const *)cmd, (char const *)"maxdelay");
                                if (tmp___37) {
                                  tmp___36 = strcasecmp((char const *)cmd, (char const *)"maxdelayratio");
                                  if (tmp___36) {
                                    tmp___35 = strcasecmp((char const *)cmd, (char const *)"maxdelaydevratio");
                                    if (tmp___35) {
                                      tmp___34 = strcasecmp((char const *)cmd, (char const *)"maxpoll");
                                      if (tmp___34) {
                                        tmp___33 = strcasecmp((char const *)cmd,
                                                              (char const *)"maxsamples");
                                        if (tmp___33) {
                                          tmp___32 = strcasecmp((char const *)cmd,
                                                                (char const *)"maxsources");
                                          if (tmp___32) {
                                            tmp___31 = strcasecmp((char const *)cmd,
                                                                  (char const *)"mindelay");
                                            if (tmp___31) {
                                              tmp___30 = strcasecmp((char const *)cmd,
                                                                    (char const *)"minpoll");
                                              if (tmp___30) {
                                                tmp___29 = strcasecmp((char const *)cmd,
                                                                      (char const *)"minsamples");
                                                if (tmp___29) {
                                                  tmp___28 = strcasecmp((char const *)cmd,
                                                                        (char const *)"minstratum");
                                                  if (tmp___28) {
                                                    tmp___27 = strcasecmp((char const *)cmd,
                                                                          (char const *)"nts");
                                                    if (tmp___27) {
                                                      tmp___26 = strcasecmp((char const *)cmd,
                                                                            (char const *)"ntsport");
                                                      if (tmp___26) {
                                                        tmp___25 = strcasecmp((char const *)cmd,
                                                                              (char const *)"offset");
                                                        if (tmp___25) {
                                                          tmp___24 = strcasecmp((char const *)cmd,
                                                                                (char const *)"port");
                                                          if (tmp___24) {
                                                            tmp___23 = strcasecmp((char const *)cmd,
                                                                                  (char const *)"polltarget");
                                                            if (tmp___23) {
                                                              tmp___22 = strcasecmp((char const *)cmd,
                                                                                    (char const *)"presend");
                                                              if (tmp___22) {
                                                                tmp___21 = strcasecmp((char const *)cmd,
                                                                                      (char const *)"version");
                                                                if (tmp___21) {
                                                                  tmp___20 = strcasecmp((char const *)cmd,
                                                                                        (char const *)"xleave");
                                                                  if (tmp___20) {
                                                                    return (0);
                                                                  } else {
                                                                    src->params.interleaved = 1;
                                                                  }
                                                                } else {
                                                                  tmp___19 = sscanf((char const *)line,
                                                                                    (char const *)"%d%n",
                                                                                    & src->params.version,
                                                                                    & n);
                                                                  if (tmp___19 != 1) {
                                                                    return (0);
                                                                  }
                                                                }
                                                              } else {
                                                                tmp___18 = sscanf((char const *)line,
                                                                                  (char const *)"%d%n",
                                                                                  & src->params.presend_minpoll,
                                                                                  & n);
                                                                if (tmp___18 != 1) {
                                                                  return (0);
                                                                }
                                                              }
                                                            } else {
                                                              tmp___17 = sscanf((char const *)line,
                                                                                (char const *)"%d%n",
                                                                                & src->params.poll_target,
                                                                                & n);
                                                              if (tmp___17 != 1) {
                                                                return (0);
                                                              }
                                                            }
                                                          } else {
                                                            tmp___16 = sscanf((char const *)line,
                                                                              (char const *)"%d%n",
                                                                              & src->port,
                                                                              & n);
                                                            if (tmp___16 != 1) {
                                                              return (0);
                                                            }
                                                          }
                                                        } else {
                                                          tmp___15 = sscanf((char const *)line,
                                                                            (char const *)"%lf%n",
                                                                            & src->params.offset,
                                                                            & n);
                                                          if (tmp___15 != 1) {
                                                            return (0);
                                                          }
                                                        }
                                                      } else {
                                                        tmp___14 = sscanf((char const *)line,
                                                                          (char const *)"%d%n",
                                                                          & src->params.nts_port,
                                                                          & n);
                                                        if (tmp___14 != 1) {
                                                          return (0);
                                                        }
                                                      }
                                                    } else {
                                                      src->params.nts = 1;
                                                    }
                                                  } else {
                                                    tmp___13 = sscanf((char const *)line,
                                                                      (char const *)"%d%n",
                                                                      & src->params.min_stratum,
                                                                      & n);
                                                    if (tmp___13 != 1) {
                                                      return (0);
                                                    }
                                                  }
                                                } else {
                                                  tmp___12 = sscanf((char const *)line,
                                                                    (char const *)"%d%n",
                                                                    & src->params.min_samples,
                                                                    & n);
                                                  if (tmp___12 != 1) {
                                                    return (0);
                                                  }
                                                }
                                              } else {
                                                tmp___11 = sscanf((char const *)line,
                                                                  (char const *)"%d%n",
                                                                  & src->params.minpoll,
                                                                  & n);
                                                if (tmp___11 != 1) {
                                                  return (0);
                                                }
                                              }
                                            } else {
                                              tmp___10 = sscanf((char const *)line,
                                                                (char const *)"%lf%n",
                                                                & src->params.min_delay,
                                                                & n);
                                              if (tmp___10 != 1) {
                                                return (0);
                                              }
                                            }
                                          } else {
                                            tmp___9 = sscanf((char const *)line,
                                                             (char const *)"%d%n",
                                                             & src->params.max_sources,
                                                             & n);
                                            if (tmp___9 != 1) {
                                              return (0);
                                            }
                                          }
                                        } else {
                                          tmp___8 = sscanf((char const *)line, (char const *)"%d%n",
                                                           & src->params.max_samples,
                                                           & n);
                                          if (tmp___8 != 1) {
                                            return (0);
                                          }
                                        }
                                      } else {
                                        tmp___7 = sscanf((char const *)line, (char const *)"%d%n",
                                                         & src->params.maxpoll, & n);
                                        if (tmp___7 != 1) {
                                          return (0);
                                        }
                                      }
                                    } else {
                                      tmp___6 = sscanf((char const *)line, (char const *)"%lf%n",
                                                       & src->params.max_delay_dev_ratio,
                                                       & n);
                                      if (tmp___6 != 1) {
                                        return (0);
                                      }
                                    }
                                  } else {
                                    tmp___5 = sscanf((char const *)line, (char const *)"%lf%n",
                                                     & src->params.max_delay_ratio,
                                                     & n);
                                    if (tmp___5 != 1) {
                                      return (0);
                                    }
                                  }
                                } else {
                                  tmp___4 = sscanf((char const *)line, (char const *)"%lf%n",
                                                   & src->params.max_delay, & n);
                                  if (tmp___4 != 1) {
                                    return (0);
                                  }
                                }
                              } else {
                                tmp___3 = sscanf((char const *)line, (char const *)"%d%n",
                                                 & src->params.filter_length, & n);
                                if (tmp___3 != 1) {
                                  return (0);
                                }
                              }
                            } else {
                              tmp___2 = sscanf((char const *)line, (char const *)"%x%n",
                                               & ef_type, & n);
                              if (tmp___2 != 1) {
                                return (0);
                              }
                              {
                              if (ef_type == 62243U) {
                                goto case_62243;
                              }
                              goto switch_default;
                              case_62243:
                              src->params.ext_fields |= 0x1;
                              goto switch_break;
                              switch_default:
                              return (0);
                              switch_break: ;
                              }
                            }
                          } else {
                            tmp___1 = sscanf((char const *)line, (char const *)"%lf%n",
                                             & src->params.asymmetry, & n);
                            if (tmp___1 != 1) {
                              return (0);
                            }
                          }
                        } else {
                          tmp___0 = sscanf((char const *)line, (char const *)"%u%n",
                                           & src->params.authkey, & n);
                          if (tmp___0 != 1) {
                            return (0);
                          } else
                          if (src->params.authkey == 0U) {
                            return (0);
                          }
                        }
                      } else {
                        tmp = sscanf((char const *)line, (char const *)"%u%n",
                                     & src->params.cert_set, & n);
                        if (tmp != 1) {
                          return (0);
                        }
                      }
                    } else {
                      src->params.sel_options |= 0x4;
                    }
                  } else {
                    src->params.sel_options |= 0x8;
                  }
                } else {
                  src->params.sel_options |= 0x2;
                }
              } else {
                src->params.sel_options |= 0x1;
              }
            } else {
              src->params.connectivity = (SRC_Connectivity )0;
            }
          } else {
            src->params.iburst = 1;
          }
        } else {
          src->params.copy = 1;
        }
      } else {
        src->params.burst = 1;
      }
    } else {
      src->params.auto_offline = 1;
    }
    line += n;
  }
  while_break: ;
  }
  return (1);
}
}
int CPS_ParseAllowDeny(char *line , int *all , IPAddr *ip , int *subnet_bits )
{
  char *p ;
  char *net ;
  char *slash ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  int bits ;
  int len ;
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  DNS_Status tmp___2 ;
  {
  p = CPS_SplitWord(line);
  tmp = strcmp((char const *)line, (char const *)"all");
  if (tmp == 0) {
    *all = 1;
    net = p;
    p = CPS_SplitWord(p);
  } else {
    *all = 0;
    net = line;
  }
  if (*p) {
    return (0);
  }
  if (! *net) {
    ip->family = (uint16_t )0;
    *subnet_bits = 0;
    return (1);
  }
  slash = strchr((char const *)net, '/');
  if (slash) {
    tmp___0 = sscanf((char const *)(slash + 1), (char const *)"%d%n", & bits,
                     & len);
    if (tmp___0 != 1) {
      return (0);
    } else
    if (*(slash + (len + 1))) {
      return (0);
    } else
    if (bits < 0) {
      return (0);
    }
    *slash = (char )'\000';
  } else {
    bits = -1;
  }
  tmp___1 = UTI_StringToIP((char const *)net, ip);
  if (tmp___1) {
    if (bits >= 0) {
      *subnet_bits = bits;
    } else
    if ((int )ip->family == 2) {
      *subnet_bits = 128;
    } else {
      *subnet_bits = 32;
    }
    return (1);
  }
  c = (uint32_t )0;
  b = c;
  a = b;
  n = sscanf((char const *)net, (char const *)"%u%n.%u%n.%u%n", & a, & len, & b,
             & len, & c, & len);
  if (n > 0) {
    if (! *(net + len)) {
      if (a > 255U) {
        return (0);
      } else
      if (b > 255U) {
        return (0);
      } else
      if (c > 255U) {
        return (0);
      }
      ip->family = (uint16_t )1;
      ip->addr.in4 = ((a << 24) | (b << 16)) | (c << 8);
      if (bits >= 0) {
        *subnet_bits = bits;
      } else {
        *subnet_bits = n * 8;
      }
      return (1);
    }
  }
  if (bits < 0) {
    tmp___2 = DNS_Name2IPAddress((char const *)net, ip, 1);
    if ((unsigned int )tmp___2 == 0U) {
      if ((int )ip->family == 2) {
        *subnet_bits = 128;
      } else {
        *subnet_bits = 32;
      }
      return (1);
    }
  }
  return (0);
}
}
int CPS_ParseLocal(char *line , int *stratum , int *orphan , double *distance )
{
  int n ;
  char *cmd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  {
  *stratum = 10;
  *distance = 1.0;
  *orphan = 0;
  {
  while (1) {
    while_continue: ;
    if (! *line) {
      goto while_break;
    }
    cmd = line;
    line = CPS_SplitWord(line);
    tmp___3 = strcasecmp((char const *)cmd, (char const *)"stratum");
    if (tmp___3) {
      tmp___2 = strcasecmp((char const *)cmd, (char const *)"orphan");
      if (tmp___2) {
        tmp___1 = strcasecmp((char const *)cmd, (char const *)"distance");
        if (tmp___1) {
          return (0);
        } else {
          tmp___0 = sscanf((char const *)line, (char const *)"%lf%n", distance,
                           & n);
          if (tmp___0 != 1) {
            return (0);
          }
        }
      } else {
        *orphan = 1;
        n = 0;
      }
    } else {
      tmp = sscanf((char const *)line, (char const *)"%d%n", stratum, & n);
      if (tmp != 1) {
        return (0);
      } else
      if (*stratum >= 16) {
        return (0);
      } else
      if (*stratum <= 0) {
        return (0);
      }
    }
    line += n;
  }
  while_break: ;
  }
  return (1);
}
}
void CPS_NormalizeLine(char *line )
{
  char *p ;
  char *q ;
  int space ;
  int first ;
  char *tmp ;
  unsigned short const **tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  {
  space = 1;
  first = 1;
  q = line;
  p = q;
  {
  while (1) {
    while_continue: ;
    if (! *p) {
      goto while_break;
    }
    tmp___0 = __ctype_b_loc();
    if ((int const )*(*tmp___0 + (int )((unsigned char )*p)) & 8192) {
      if (! space) {
        tmp = q;
        q ++;
        *tmp = (char )' ';
      }
      space = 1;
      goto __Cont;
    }
    if (first) {
      tmp___1 = strchr((char const *)"!;#%", (int )*p);
      if (tmp___1) {
        goto while_break;
      }
    }
    tmp___2 = q;
    q ++;
    *tmp___2 = *p;
    first = 0;
    space = first;
    __Cont:
    p ++;
  }
  while_break: ;
  }
  if ((unsigned long )q > (unsigned long )line) {
    if ((int )*(q + -1) == 32) {
      q --;
    }
  }
  *q = (char )'\000';
  return;
}
}
char *CPS_SplitWord(char *line )
{
  char *p ;
  char *q ;
  unsigned short const **tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short const **tmp___2 ;
  unsigned short const **tmp___3 ;
  {
  p = line;
  q = line;
  {
  while (1) {
    while_continue: ;
    if (*q) {
      tmp = __ctype_b_loc();
      if (! ((int const )*(*tmp + (int )((unsigned char )*q)) & 8192)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    q ++;
  }
  while_break: ;
  }
  {
  while (1) {
    while_continue___0: ;
    if (*q) {
      tmp___2 = __ctype_b_loc();
      if ((int const )*(*tmp___2 + (int )((unsigned char )*q)) & 8192) {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
    tmp___0 = p;
    p ++;
    tmp___1 = q;
    q ++;
    *tmp___0 = *tmp___1;
  }
  while_break___0: ;
  }
  {
  while (1) {
    while_continue___1: ;
    if (*q) {
      tmp___3 = __ctype_b_loc();
      if (! ((int const )*(*tmp___3 + (int )((unsigned char )*q)) & 8192)) {
        goto while_break___1;
      }
    } else {
      goto while_break___1;
    }
    q ++;
  }
  while_break___1: ;
  }
  *p = (char )'\000';
  return (q);
}
}
int CPS_ParseKey(char *line , uint32_t *id , char const **type , char **key )
{
  char *s1 ;
  char *s2 ;
  char *s3 ;
  char *s4 ;
  int tmp ;
  {
  s1 = line;
  s2 = CPS_SplitWord(s1);
  s3 = CPS_SplitWord(s2);
  s4 = CPS_SplitWord(s3);
  if (! *s2) {
    return (0);
  } else
  if (*s4) {
    return (0);
  }
  tmp = sscanf((char const *)s1, (char const *)"%u", id);
  if (tmp != 1) {
    return (0);
  }
  if (*s3) {
    *type = (char const *)s2;
    *key = s3;
  } else {
    *type = (char const *)"MD5";
    *key = s2;
  }
  return (1);
}
}
void REF_Initialise(void) ;
void REF_Finalise(void) ;
void REF_SetMode(REF_Mode new_mode ) ;
REF_Mode REF_GetMode(void) ;
void REF_SetModeEndHandler(void (*handler)(int result ) ) ;
REF_LeapMode REF_GetLeapMode(void) ;
void REF_GetReferenceParams(struct timespec *local_time , int *is_synchronised , NTP_Leap *leap_status ,
                            int *stratum , uint32_t *ref_id , struct timespec *ref_time ,
                            double *root_delay , double *root_dispersion ) ;
void REF_SetReference(int stratum , NTP_Leap leap , int combined_sources , uint32_t ref_id ,
                      IPAddr *ref_ip , struct timespec *ref_time , double offset ,
                      double offset_sd , double frequency , double frequency_sd ,
                      double skew , double root_delay , double root_dispersion ) ;
void REF_SetManualReference(struct timespec *ref_time , double offset , double frequency ,
                            double skew ) ;
void REF_SetUnsynchronised(void) ;
void REF_UpdateLeapStatus(NTP_Leap leap ) ;
int REF_GetOurStratum(void) ;
int REF_GetOrphanStratum(void) ;
double REF_GetSkew(void) ;
void REF_ModifyMaxupdateskew(double new_max_update_skew ) ;
void REF_ModifyMakestep(int limit , double threshold ) ;
void REF_EnableLocal(int stratum , double distance , int orphan ) ;
void REF_DisableLocal(void) ;
int REF_IsLeapSecondClose(struct timespec *ts , double offset ) ;
int REF_GetTaiOffset(struct timespec *ts ) ;
void REF_GetTrackingReport(RPT_TrackingReport *rep ) ;
void CNF_Initialise(int r , int client_only ) ;
void CNF_Finalise(void) ;
void CNF_EnablePrint(void) ;
char *CNF_GetRtcDevice(void) ;
void CNF_ReadFile(char const *filename___0 ) ;
void CNF_ParseLine(char const *filename___0 , int number , char *line ) ;
void CNF_CreateDirs(uid_t uid , gid_t gid ) ;
void CNF_AddInitSources(void) ;
void CNF_AddSources(void) ;
void CNF_AddBroadcasts(void) ;
void CNF_AddRefclocks(void) ;
void CNF_ReloadSources(void) ;
int CNF_GetAcquisitionPort(void) ;
int CNF_GetNTPPort(void) ;
char *CNF_GetDriftFile(void) ;
char *CNF_GetLogDir(void) ;
char *CNF_GetDumpDir(void) ;
int CNF_GetLogBanner(void) ;
int CNF_GetLogMeasurements(int *raw ) ;
int CNF_GetLogStatistics(void) ;
int CNF_GetLogTracking(void) ;
int CNF_GetLogRtc(void) ;
int CNF_GetLogRefclocks(void) ;
int CNF_GetLogTempComp(void) ;
char *CNF_GetKeysFile(void) ;
char *CNF_GetRtcFile(void) ;
int CNF_GetManualEnabled(void) ;
int CNF_GetCommandPort(void) ;
int CNF_GetRtcOnUtc(void) ;
int CNF_GetRtcSync(void) ;
void CNF_GetMakeStep(int *limit , double *threshold ) ;
void CNF_GetMaxChange(int *delay , int *ignore , double *offset ) ;
double CNF_GetLogChange(void) ;
void CNF_GetMailOnChange(int *enabled___1 , double *threshold , char **user___0 ) ;
int CNF_GetNoClientLog(void) ;
unsigned long CNF_GetClientLogLimit(void) ;
void CNF_GetFallbackDrifts(int *min , int *max ) ;
void CNF_GetBindAddress(int family , IPAddr *addr ) ;
void CNF_GetBindAcquisitionAddress(int family , IPAddr *addr ) ;
void CNF_GetBindCommandAddress(int family , IPAddr *addr ) ;
char *CNF_GetBindNtpInterface(void) ;
char *CNF_GetBindAcquisitionInterface(void) ;
char *CNF_GetBindCommandInterface(void) ;
char *CNF_GetBindCommandPath(void) ;
int CNF_GetNtpDscp(void) ;
char *CNF_GetNtpSigndSocket(void) ;
char *CNF_GetPidFile(void) ;
REF_LeapMode CNF_GetLeapSecMode(void) ;
char *CNF_GetLeapSecTimezone(void) ;
double CNF_GetMaxUpdateSkew(void) ;
double CNF_GetMaxClockError(void) ;
double CNF_GetMaxDrift(void) ;
double CNF_GetCorrectionTimeRatio(void) ;
double CNF_GetMaxSlewRate(void) ;
double CNF_GetClockPrecision(void) ;
SRC_AuthSelectMode CNF_GetAuthSelectMode(void) ;
double CNF_GetMaxDistance(void) ;
double CNF_GetMaxJitter(void) ;
double CNF_GetReselectDistance(void) ;
double CNF_GetStratumWeight(void) ;
double CNF_GetCombineLimit(void) ;
int CNF_AllowLocalReference(int *stratum , int *orphan , double *distance ) ;
void CNF_SetupAccessRestrictions(void) ;
int CNF_GetSchedPriority(void) ;
int CNF_GetLockMemory(void) ;
int CNF_GetNTPRateLimit(int *interval , int *burst , int *leak ) ;
int CNF_GetNtsRateLimit(int *interval , int *burst , int *leak ) ;
int CNF_GetCommandRateLimit(int *interval , int *burst , int *leak ) ;
void CNF_GetSmooth(double *max_freq___1 , double *max_wander___0 , int *leap_only ) ;
void CNF_GetTempComp(char **file , double *interval , char **point_file , double *T0___0 ,
                     double *k0___0 , double *k1___0 , double *k2___0 ) ;
char *CNF_GetUser(void) ;
int CNF_GetMaxSamples(void) ;
int CNF_GetMinSamples(void) ;
int CNF_GetMinSources(void) ;
double CNF_GetRtcAutotrim(void) ;
char *CNF_GetHwclockFile(void) ;
int CNF_GetInitSources(void) ;
double CNF_GetInitStepThreshold(void) ;
int CNF_GetHwTsInterface(unsigned int index___0 , CNF_HwTsInterface **iface ) ;
int CNF_GetPtpPort(void) ;
char *CNF_GetNtsDumpDir(void) ;
char *CNF_GetNtsNtpServer(void) ;
int CNF_GetNtsServerCertAndKeyFiles(char const ***certs , char const ***keys___0 ) ;
int CNF_GetNtsServerPort(void) ;
int CNF_GetNtsServerProcesses(void) ;
int CNF_GetNtsServerConnections(void) ;
int CNF_GetNtsRefresh(void) ;
int CNF_GetNtsRotate(void) ;
int CNF_GetNtsTrustedCertsPaths(char const ***paths , uint32_t **ids ) ;
int CNF_GetNoSystemCert(void) ;
int CNF_GetNoCertTimeCheck(void) ;
void NCR_Initialise(void) ;
void NCR_Finalise(void) ;
NCR_Instance NCR_CreateInstance(NTP_Remote_Address *remote_addr , NTP_Source_Type type ,
                                SourceParameters *params , char const *name ) ;
void NCR_DestroyInstance(NCR_Instance instance ) ;
void NCR_StartInstance(NCR_Instance instance ) ;
void NCR_ResetInstance(NCR_Instance instance ) ;
void NCR_ResetPoll(NCR_Instance instance ) ;
void NCR_ChangeRemoteAddress(NCR_Instance inst , NTP_Remote_Address *remote_addr ,
                             int ntp_only ) ;
int NCR_ProcessRxKnown(NCR_Instance inst , NTP_Local_Address *local_addr , NTP_Local_Timestamp *rx_ts ,
                       NTP_Packet *message , int length ) ;
void NCR_ProcessRxUnknown(NTP_Remote_Address *remote_addr , NTP_Local_Address *local_addr ,
                          NTP_Local_Timestamp *rx_ts , NTP_Packet *message , int length ) ;
void NCR_ProcessTxKnown(NCR_Instance inst , NTP_Local_Address *local_addr , NTP_Local_Timestamp *tx_ts ,
                        NTP_Packet *message , int length ) ;
void NCR_ProcessTxUnknown(NTP_Remote_Address *remote_addr , NTP_Local_Address *local_addr ,
                          NTP_Local_Timestamp *tx_ts , NTP_Packet *message , int length ) ;
void NCR_SlewTimes(NCR_Instance inst , struct timespec *when , double dfreq , double doffset ) ;
void NCR_SetConnectivity(NCR_Instance inst , SRC_Connectivity connectivity ) ;
void NCR_ModifyMinpoll(NCR_Instance inst , int new_minpoll ) ;
void NCR_ModifyMaxpoll(NCR_Instance inst , int new_maxpoll ) ;
void NCR_ModifyMaxdelay(NCR_Instance inst , double new_max_delay ) ;
void NCR_ModifyMaxdelayratio(NCR_Instance inst , double new_max_delay_ratio ) ;
void NCR_ModifyMaxdelaydevratio(NCR_Instance inst , double new_max_delay_dev_ratio ) ;
void NCR_ModifyMinstratum(NCR_Instance inst , int new_min_stratum ) ;
void NCR_ModifyPolltarget(NCR_Instance inst , int new_poll_target ) ;
void NCR_InitiateSampleBurst(NCR_Instance inst , int n_good_samples , int n_total_samples ) ;
void NCR_ReportSource(NCR_Instance inst , RPT_SourceReport *report , struct timespec *now ) ;
void NCR_GetAuthReport(NCR_Instance inst , RPT_AuthReport *report ) ;
void NCR_GetNTPReport(NCR_Instance inst , RPT_NTPReport *report ) ;
int NCR_AddAccessRestriction(IPAddr *ip_addr , int subnet_bits , int allow , int all ) ;
int NCR_CheckAccessRestriction(IPAddr *ip_addr ) ;
void NCR_IncrementActivityCounters(NCR_Instance inst , int *online , int *offline ,
                                   int *burst_online , int *burst_offline ) ;
NTP_Remote_Address *NCR_GetRemoteAddress(NCR_Instance inst ) ;
uint32_t NCR_GetLocalRefid(NCR_Instance inst ) ;
int NCR_IsSyncPeer(NCR_Instance inst ) ;
void NCR_DumpAuthData(NCR_Instance inst ) ;
void NCR_AddBroadcastDestination(NTP_Remote_Address *addr , int interval ) ;
NSR_Status NSR_AddSource(NTP_Remote_Address *remote_addr , NTP_Source_Type type ,
                         SourceParameters *params , uint32_t *conf_id ) ;
NSR_Status NSR_AddSourceByName(char *name , int port , int pool , NTP_Source_Type type ,
                               SourceParameters *params , uint32_t *conf_id ) ;
void NSR_SetSourceResolvingEndHandler(void (*handler)(void) ) ;
void NSR_ResolveSources(void) ;
void NSR_StartSources(void) ;
void NSR_AutoStartSources(void) ;
NSR_Status NSR_RemoveSource(IPAddr *address ) ;
void NSR_RemoveSourcesById(uint32_t conf_id ) ;
void NSR_RemoveAllSources(void) ;
void NSR_HandleBadSource(IPAddr *address ) ;
void NSR_RefreshAddresses(void) ;
NSR_Status NSR_UpdateSourceNtpAddress(NTP_Remote_Address *old_addr , NTP_Remote_Address *new_addr ) ;
uint32_t NSR_GetLocalRefid(IPAddr *address ) ;
char *NSR_GetName(IPAddr *address ) ;
void NSR_ProcessRx(NTP_Remote_Address *remote_addr , NTP_Local_Address *local_addr ,
                   NTP_Local_Timestamp *rx_ts , NTP_Packet *message , int length ) ;
void NSR_ProcessTx(NTP_Remote_Address *remote_addr , NTP_Local_Address *local_addr ,
                   NTP_Local_Timestamp *tx_ts , NTP_Packet *message , int length ) ;
void NSR_Initialise(void) ;
void NSR_Finalise(void) ;
int NSR_SetConnectivity(IPAddr *mask , IPAddr *address , SRC_Connectivity connectivity ) ;
int NSR_ModifyMinpoll(IPAddr *address , int new_minpoll ) ;
int NSR_ModifyMaxpoll(IPAddr *address , int new_maxpoll ) ;
int NSR_ModifyMaxdelay(IPAddr *address , double new_max_delay ) ;
int NSR_ModifyMaxdelayratio(IPAddr *address , double new_max_delay_ratio ) ;
int NSR_ModifyMaxdelaydevratio(IPAddr *address , double new_max_delay_dev_ratio ) ;
int NSR_ModifyMinstratum(IPAddr *address , int new_min_stratum ) ;
int NSR_ModifyPolltarget(IPAddr *address , int new_poll_target ) ;
int NSR_InitiateSampleBurst(int n_good_samples , int n_total_samples , IPAddr *mask ,
                            IPAddr *address ) ;
void NSR_ReportSource(RPT_SourceReport *report , struct timespec *now ) ;
int NSR_GetAuthReport(IPAddr *address , RPT_AuthReport *report ) ;
int NSR_GetNTPReport(RPT_NTPReport *report ) ;
void NSR_GetActivityReport(RPT_ActivityReport *report ) ;
void NSR_DumpAuthData(void) ;
extern SIV_Instance SIV_CreateInstance(SIV_Algorithm algorithm ) ;
extern void SIV_DestroyInstance(SIV_Instance instance ) ;
extern int SIV_GetKeyLength(SIV_Algorithm algorithm ) ;
extern int SIV_SetKey(SIV_Instance instance , unsigned char const *key , int length ) ;
extern int SIV_GetTagLength(SIV_Instance instance ) ;
extern int SIV_Encrypt(SIV_Instance instance , unsigned char const *nonce , int nonce_length ,
                       void const *assoc , int assoc_length , void const *plaintext ,
                       int plaintext_length , unsigned char *ciphertext , int ciphertext_length ) ;
extern int SIV_Decrypt(SIV_Instance instance , unsigned char const *nonce , int nonce_length ,
                       void const *assoc , int assoc_length , unsigned char const *ciphertext ,
                       int ciphertext_length , void *plaintext , int plaintext_length ) ;
void RCL_Initialise(void) ;
void RCL_Finalise(void) ;
int RCL_AddRefclock(RefclockParameters *params ) ;
void RCL_StartRefclocks(void) ;
void RCL_ReportSource(RPT_SourceReport *report , struct timespec *now ) ;
void RCL_SetDriverData(RCL_Instance instance , void *data ) ;
void *RCL_GetDriverData(RCL_Instance instance ) ;
char *RCL_GetDriverParameter(RCL_Instance instance ) ;
void RCL_CheckDriverOptions(RCL_Instance instance , char const **options ) ;
char *RCL_GetDriverOption(RCL_Instance instance , char *name ) ;
int RCL_AddSample(RCL_Instance instance , struct timespec *sample_time , double offset ,
                  int leap ) ;
int RCL_AddPulse(RCL_Instance instance , struct timespec *pulse_time , double second ) ;
int RCL_AddCookedPulse(RCL_Instance instance , struct timespec *cooked_time , double second ,
                       double dispersion , double raw_correction ) ;
double RCL_GetPrecision(RCL_Instance instance ) ;
int RCL_GetDriverPoll(RCL_Instance instance ) ;
void CAM_Initialise(void) ;
void CAM_Finalise(void) ;
void CAM_OpenUnixSocket(void) ;
int CAM_AddAccessRestriction(IPAddr *ip_addr , int subnet_bits , int allow , int all ) ;
int CAM_CheckAccessRestriction(IPAddr *ip_addr ) ;
void SCK_Initialise(int family ) ;
void SCK_Finalise(void) ;
int SCK_IsIpFamilyEnabled(int family ) ;
void SCK_GetAnyLocalIPAddress(int family , IPAddr *local_addr ) ;
void SCK_GetLoopbackIPAddress(int family , IPAddr *local_addr ) ;
int SCK_IsLinkLocalIPAddress(IPAddr *addr ) ;
void SCK_SetPrivBind(int (*function)(int sock_fd , struct sockaddr *address , socklen_t address_len ) ) ;
int SCK_OpenUdpSocket(IPSockAddr *remote_addr , IPSockAddr *local_addr , char const *iface ,
                      int flags ) ;
int SCK_OpenTcpSocket(IPSockAddr *remote_addr , IPSockAddr *local_addr , char const *iface ,
                      int flags ) ;
int SCK_OpenUnixDatagramSocket(char const *remote_addr , char const *local_addr ,
                               int flags ) ;
int SCK_OpenUnixStreamSocket(char const *remote_addr , char const *local_addr ,
                             int flags ) ;
int SCK_OpenUnixSocketPair(int flags , int *other_fd ) ;
int SCK_SetIntOption(int sock_fd , int level , int name , int value ) ;
int SCK_GetIntOption(int sock_fd , int level , int name , int *value ) ;
int SCK_EnableKernelRxTimestamping(int sock_fd ) ;
int SCK_ListenOnSocket(int sock_fd , int backlog ) ;
int SCK_AcceptConnection(int sock_fd , IPSockAddr *remote_addr ) ;
int SCK_ShutdownConnection(int sock_fd ) ;
int SCK_Receive(int sock_fd , void *buffer , int length , int flags ) ;
int SCK_Send(int sock_fd , void const *buffer , int length , int flags ) ;
SCK_Message *SCK_ReceiveMessage(int sock_fd , int flags ) ;
SCK_Message *SCK_ReceiveMessages(int sock_fd , int flags , int *num_messages ) ;
void SCK_InitMessage(SCK_Message *message , SCK_AddressType addr_type ) ;
int SCK_SendMessage(int sock_fd , SCK_Message *message , int flags ) ;
int SCK_RemoveSocket(int sock_fd ) ;
void SCK_CloseSocket(int sock_fd ) ;
void SCK_SockaddrToIPSockAddr(struct sockaddr *sa , int sa_length , IPSockAddr *ip_sa ) ;
int SCK_IPSockAddrToSockaddr(IPSockAddr *ip_sa , struct sockaddr *sa , int sa_length ) ;
LOG_Severity log_min_severity ;
void LOG_Initialise(void) ;
void LOG_Finalise(void) ;
void ( LOG_Message)(LOG_Severity severity , char const *format
                                            , ...) ;
void LOG_SetMinSeverity(LOG_Severity severity ) ;
LOG_Severity LOG_GetMinSeverity(void) ;
void LOG_SetDebugPrefix(char const *prefix ) ;
void LOG_OpenFileLog(char const *log_file ) ;
void LOG_OpenSystemLog(void) ;
void LOG_SetParentFd(int fd___0 ) ;
void LOG_CloseParentFd(void) ;
LOG_FileID LOG_FileOpen(char const *name , char const *banner ) ;
void ( LOG_FileWrite)(LOG_FileID id , char const *format
                                              , ...) ;
void LOG_CycleLogFiles(void) ;
static int parse_string(char *line , char **result ) ;
static int parse_int(char *line , int *result ) ;
static int parse_double(char *line , double *result ) ;
static int parse_null(char *line ) ;
static void parse_allow_deny(char *line , ARR_Instance restrictions , int allow ) ;
static void parse_authselectmode(char *line ) ;
static void parse_bindacqaddress(char *line ) ;
static void parse_bindaddress(char *line ) ;
static void parse_bindcmdaddress(char *line ) ;
static void parse_broadcast(char *line ) ;
static void parse_clientloglimit(char *line ) ;
static void parse_confdir(char *line ) ;
static void parse_fallbackdrift(char *line ) ;
static void parse_hwtimestamp(char *line ) ;
static void parse_include(char *line ) ;
static void parse_initstepslew(char *line ) ;
static void parse_leapsecmode(char *line ) ;
static void parse_local(char *line ) ;
static void parse_log(char *line ) ;
static void parse_mailonchange(char *line ) ;
static void parse_makestep(char *line ) ;
static void parse_maxchange(char *line ) ;
static void parse_ntsserver(char *line , ARR_Instance files ) ;
static void parse_ntstrustedcerts(char *line ) ;
static void parse_ratelimit(char *line , int *enabled___1 , int *interval , int *burst ,
                            int *leak ) ;
static void parse_refclock(char *line ) ;
static void parse_smoothtime(char *line ) ;
static void parse_source(char *line , char *type , int fatal ) ;
static void parse_sourcedir(char *line ) ;
static void parse_tempcomp(char *line ) ;
static int print_config = 0;
static int restarted = 0;
static char *rtc_device ;
static int acquisition_port = -1;
static int ntp_port = 123;
static char *keys_file = (char *)((void *)0);
static char *drift_file = (char *)((void *)0);
static char *rtc_file = (char *)((void *)0);
static double max_update_skew = 1000.0;
static double correction_time_ratio = 3.0;
static double max_clock_error = 1.0;
static double max_drift = 500000.0;
static double max_slew_rate = 1e6 / 12.0;
static double clock_precision = 0.0;
static SRC_AuthSelectMode authselect_mode = (SRC_AuthSelectMode )1;
static double max_distance = 3.0;
static double max_jitter = 1.0;
static double reselect_distance = 1e-4;
static double stratum_weight = 1e-3;
static double combine_limit = 3.0;
static int cmd_port = 323;
static int raw_measurements = 0;
static int do_log_measurements = 0;
static int do_log_statistics = 0;
static int do_log_tracking = 0;
static int do_log_rtc = 0;
static int do_log_refclocks = 0;
static int do_log_tempcomp = 0;
static int log_banner = 32;
static char *logdir = (char *)((void *)0);
static char *dumpdir = (char *)((void *)0);
static int enable_local = 0;
static int local_stratum ;
static int local_orphan ;
static double local_distance ;
static double init_slew_threshold ;
static ARR_Instance init_sources ;
static int enable_manual = 0;
static int rtc_on_utc = 0;
static char *hwclock_file ;
static int rtc_sync = 0;
static int make_step_limit = 0;
static double make_step_threshold = 0.0;
static double rtc_autotrim_threshold = 0.0;
static int min_sources = 1;
static int max_offset_delay = -1;
static int max_offset_ignore ;
static double max_offset ;
static int max_samples = 0;
static int min_samples = 6;
static double log_change_threshold = 1.0;
static char *mail_user_on_change = (char *)((void *)0);
static double mail_change_threshold = 0.0;
static int no_client_log = 0;
static unsigned long client_log_limit = 524288UL;
static int fb_drift_min = 0;
static int fb_drift_max = 0;
static IPAddr bind_address4 ;
static IPAddr bind_address6 ;
static IPAddr bind_acq_address4 ;
static IPAddr bind_acq_address6 ;
static IPAddr bind_cmd_address4 ;
static IPAddr bind_cmd_address6 ;
static char *bind_ntp_iface = (char *)((void *)0);
static char *bind_acq_iface = (char *)((void *)0);
static char *bind_cmd_iface = (char *)((void *)0);
static char *bind_cmd_path = (char *)((void *)0);
static int ntp_dscp = 0;
static char *ntp_signd_socket = (char *)((void *)0);
static char *pidfile = (char *)((void *)0);
static int ntp_ratelimit_enabled = 0;
static int ntp_ratelimit_interval = 3;
static int ntp_ratelimit_burst = 8;
static int ntp_ratelimit_leak = 2;
static int nts_ratelimit_enabled = 0;
static int nts_ratelimit_interval = 6;
static int nts_ratelimit_burst = 8;
static int nts_ratelimit_leak = 2;
static int cmd_ratelimit_enabled = 0;
static int cmd_ratelimit_interval = -4;
static int cmd_ratelimit_burst = 8;
static int cmd_ratelimit_leak = 2;
static double smooth_max_freq = 0.0;
static double smooth_max_wander = 0.0;
static int smooth_leap_only = 0;
static char *tempcomp_sensor_file = (char *)((void *)0);
static char *tempcomp_point_file = (char *)((void *)0);
static double tempcomp_interval ;
static double tempcomp_T0 ;
static double tempcomp_k0 ;
static double tempcomp_k1 ;
static double tempcomp_k2 ;
static int sched_priority = 0;
static int lock_memory = 0;
static REF_LeapMode leapsec_mode = (REF_LeapMode )0;
static char *leapsec_tz = (char *)((void *)0);
static char *user ;
static char *nts_dump_dir = (char *)((void *)0);
static char *nts_ntp_server = (char *)((void *)0);
static ARR_Instance nts_server_cert_files ;
static ARR_Instance nts_server_key_files ;
static int nts_server_port = 4460;
static int nts_server_processes = 1;
static int nts_server_connections = 100;
static int nts_refresh = 2419200;
static int nts_rotate = 604800;
static ARR_Instance nts_trusted_certs_paths ;
static ARR_Instance nts_trusted_certs_ids ;
static int no_cert_time_check = 0;
static int no_system_cert = 0;
static ARR_Instance hwts_interfaces ;
static int ptp_port = 0;
static ARR_Instance ntp_sources ;
static ARR_Instance ntp_source_dirs ;
static ARR_Instance ntp_source_ids ;
static ARR_Instance refclock_sources ;
static ARR_Instance ntp_restrictions ;
static ARR_Instance cmd_restrictions ;
static ARR_Instance broadcasts ;
static int line_number ;
static char const *processed_file ;
static char const *processed_command ;
static int include_level = 0;
static void command_parse_error(void)
{
  char const *tmp ;
  char *tmp___0 ;
  {
  {
  while (1) {
    while_continue: ;
    if (processed_file) {
      tmp = processed_file;
    } else {
      tmp = (char const *)"";
    }
    if (processed_file) {
      tmp___0 = " in file ";
    } else {
      tmp___0 = "";
    }
    LOG_Message((LOG_Severity )3, (char const *)"Could not parse %s directive at line %d%s%s",
                processed_command, line_number, tmp___0, tmp);
    exit(1);
    goto while_break;
  }
  while_break: ;
  }
  return;
}
}
static void other_parse_error(char const *message )
{
  char const *tmp ;
  char *tmp___0 ;
  {
  {
  while (1) {
    while_continue: ;
    if (processed_file) {
      tmp = processed_file;
    } else {
      tmp = (char const *)"";
    }
    if (processed_file) {
      tmp___0 = " in file ";
    } else {
      tmp___0 = "";
    }
    LOG_Message((LOG_Severity )3, (char const *)"%s at line %d%s%s", message, line_number,
                tmp___0, tmp);
    exit(1);
    goto while_break;
  }
  while_break: ;
  }
  return;
}
}
static int get_number_of_args(char *line )
{
  int num ;
  {
  num = 0;
  if ((int )*line == 32) {
    line ++;
  }
  if (*line) {
    num ++;
  }
  {
  while (1) {
    while_continue: ;
    if (! *line) {
      goto while_break;
    }
    if ((int )*line == 32) {
      num ++;
    }
    line ++;
  }
  while_break: ;
  }
  return (num);
}
}
static void check_number_of_args(char *line , int num )
{
  int tmp ;
  char const *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  {
  tmp = get_number_of_args(line);
  num -= tmp;
  if (num) {
    {
    while (1) {
      while_continue: ;
      if (processed_file) {
        tmp___0 = processed_file;
      } else {
        tmp___0 = (char const *)"";
      }
      if (processed_file) {
        tmp___1 = " in file ";
      } else {
        tmp___1 = "";
      }
      if (num > 0) {
        tmp___2 = "Missing";
      } else {
        tmp___2 = "Too many";
      }
      LOG_Message((LOG_Severity )3, (char const *)"%s arguments for %s directive at line %d%s%s",
                  tmp___2, processed_command, line_number, tmp___1, tmp___0);
      exit(1);
      goto while_break;
    }
    while_break: ;
    }
  }
  return;
}
}
void CNF_Initialise(int r , int client_only )
{
  {
  restarted = r;
  hwts_interfaces = ARR_CreateInstance((unsigned int )sizeof(CNF_HwTsInterface ));
  init_sources = ARR_CreateInstance((unsigned int )sizeof(IPAddr ));
  ntp_sources = ARR_CreateInstance((unsigned int )sizeof(NTP_Source ));
  ntp_source_dirs = ARR_CreateInstance((unsigned int )sizeof(char *));
  ntp_source_ids = ARR_CreateInstance((unsigned int )sizeof(uint32_t ));
  refclock_sources = ARR_CreateInstance((unsigned int )sizeof(RefclockParameters ));
  broadcasts = ARR_CreateInstance((unsigned int )sizeof(NTP_Broadcast_Destination ));
  ntp_restrictions = ARR_CreateInstance((unsigned int )sizeof(AllowDeny ));
  cmd_restrictions = ARR_CreateInstance((unsigned int )sizeof(AllowDeny ));
  nts_server_cert_files = ARR_CreateInstance((unsigned int )sizeof(char *));
  nts_server_key_files = ARR_CreateInstance((unsigned int )sizeof(char *));
  nts_trusted_certs_paths = ARR_CreateInstance((unsigned int )sizeof(char *));
  nts_trusted_certs_ids = ARR_CreateInstance((unsigned int )sizeof(uint32_t ));
  rtc_device = Strdup((char const *)"/dev/rtc");
  hwclock_file = Strdup((char const *)"");
  user = Strdup((char const *)"root");
  if (client_only) {
    ntp_port = 0;
    cmd_port = ntp_port;
  } else {
    bind_cmd_path = Strdup((char const *)"/var/run/chrony/chronyd.sock");
    pidfile = Strdup((char const *)"/var/run/chrony/chronyd.pid");
  }
  SCK_GetAnyLocalIPAddress(1, & bind_address4);
  SCK_GetAnyLocalIPAddress(2, & bind_address6);
  SCK_GetAnyLocalIPAddress(1, & bind_acq_address4);
  SCK_GetAnyLocalIPAddress(2, & bind_acq_address6);
  SCK_GetLoopbackIPAddress(1, & bind_cmd_address4);
  SCK_GetLoopbackIPAddress(2, & bind_cmd_address6);
  return;
}
}
void CNF_Finalise(void)
{
  unsigned int i ;
  void *tmp ;
  unsigned int tmp___0 ;
  void *tmp___1 ;
  unsigned int tmp___2 ;
  void *tmp___3 ;
  unsigned int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  unsigned int tmp___7 ;
  void *tmp___8 ;
  unsigned int tmp___9 ;
  void *tmp___10 ;
  unsigned int tmp___11 ;
  void *tmp___12 ;
  unsigned int tmp___13 ;
  {
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp___0 = ARR_GetSize(hwts_interfaces);
    if (! (i < tmp___0)) {
      goto while_break;
    }
    tmp = ARR_GetElement(hwts_interfaces, i);
    free((void *)((CNF_HwTsInterface *)tmp)->name);
    i ++;
  }
  while_break: ;
  }
  ARR_DestroyInstance(hwts_interfaces);
  i = 0U;
  {
  while (1) {
    while_continue___0: ;
    tmp___2 = ARR_GetSize(ntp_sources);
    if (! (i < tmp___2)) {
      goto while_break___0;
    }
    tmp___1 = ARR_GetElement(ntp_sources, i);
    free((void *)((NTP_Source *)tmp___1)->params.name);
    i ++;
  }
  while_break___0: ;
  }
  i = 0U;
  {
  while (1) {
    while_continue___1: ;
    tmp___4 = ARR_GetSize(ntp_source_dirs);
    if (! (i < tmp___4)) {
      goto while_break___1;
    }
    tmp___3 = ARR_GetElement(ntp_source_dirs, i);
    free((void *)*((char **)tmp___3));
    i ++;
  }
  while_break___1: ;
  }
  i = 0U;
  {
  while (1) {
    while_continue___2: ;
    tmp___7 = ARR_GetSize(refclock_sources);
    if (! (i < tmp___7)) {
      goto while_break___2;
    }
    tmp___5 = ARR_GetElement(refclock_sources, i);
    free((void *)((RefclockParameters *)tmp___5)->driver_name);
    tmp___6 = ARR_GetElement(refclock_sources, i);
    free((void *)((RefclockParameters *)tmp___6)->driver_parameter);
    i ++;
  }
  while_break___2: ;
  }
  i = 0U;
  {
  while (1) {
    while_continue___3: ;
    tmp___9 = ARR_GetSize(nts_server_cert_files);
    if (! (i < tmp___9)) {
      goto while_break___3;
    }
    tmp___8 = ARR_GetElement(nts_server_cert_files, i);
    free((void *)*((char **)tmp___8));
    i ++;
  }
  while_break___3: ;
  }
  i = 0U;
  {
  while (1) {
    while_continue___4: ;
    tmp___11 = ARR_GetSize(nts_server_key_files);
    if (! (i < tmp___11)) {
      goto while_break___4;
    }
    tmp___10 = ARR_GetElement(nts_server_key_files, i);
    free((void *)*((char **)tmp___10));
    i ++;
  }
  while_break___4: ;
  }
  i = 0U;
  {
  while (1) {
    while_continue___5: ;
    tmp___13 = ARR_GetSize(nts_trusted_certs_paths);
    if (! (i < tmp___13)) {
      goto while_break___5;
    }
    tmp___12 = ARR_GetElement(nts_trusted_certs_paths, i);
    free((void *)*((char **)tmp___12));
    i ++;
  }
  while_break___5: ;
  }
  ARR_DestroyInstance(init_sources);
  ARR_DestroyInstance(ntp_sources);
  ARR_DestroyInstance(ntp_source_dirs);
  ARR_DestroyInstance(ntp_source_ids);
  ARR_DestroyInstance(refclock_sources);
  ARR_DestroyInstance(broadcasts);
  ARR_DestroyInstance(ntp_restrictions);
  ARR_DestroyInstance(cmd_restrictions);
  ARR_DestroyInstance(nts_server_cert_files);
  ARR_DestroyInstance(nts_server_key_files);
  ARR_DestroyInstance(nts_trusted_certs_paths);
  ARR_DestroyInstance(nts_trusted_certs_ids);
  free((void *)drift_file);
  free((void *)dumpdir);
  free((void *)hwclock_file);
  free((void *)keys_file);
  free((void *)leapsec_tz);
  free((void *)logdir);
  free((void *)bind_ntp_iface);
  free((void *)bind_acq_iface);
  free((void *)bind_cmd_iface);
  free((void *)bind_cmd_path);
  free((void *)ntp_signd_socket);
  free((void *)pidfile);
  free((void *)rtc_device);
  free((void *)rtc_file);
  free((void *)user);
  free((void *)mail_user_on_change);
  free((void *)tempcomp_sensor_file);
  free((void *)tempcomp_point_file);
  free((void *)nts_dump_dir);
  free((void *)nts_ntp_server);
  return;
}
}
void CNF_EnablePrint(void)
{
  {
  print_config = 1;
  return;
}
}
void CNF_ReadFile(char const *filename___0 )
{
  FILE *in ;
  char line[2049] ;
  int i ;
  char __attribute__((__access__(__write_only__,1,2))) *tmp ;
  {
  include_level ++;
  if (include_level > 10) {
    {
    while (1) {
      while_continue: ;
      LOG_Message((LOG_Severity )3, (char const *)"Maximum include level reached");
      exit(1);
      goto while_break;
    }
    while_break: ;
    }
  }
  in = UTI_OpenFile((char const *)((void *)0), filename___0, (char const *)((void *)0),
                    (char )'R', (mode_t )0);
  i = 1;
  {
  while (1) {
    while_continue___0: ;
    tmp = fgets(line, (int )sizeof(line), in);
    if (! tmp) {
      goto while_break___0;
    }
    CNF_ParseLine(filename___0, i, line);
    i ++;
  }
  while_break___0: ;
  }
  fclose(in);
  include_level --;
  return;
}
}
void CNF_ParseLine(char const *filename___0 , int number , char *line )
{
  char *p ;
  char *command ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  {
  processed_file = filename___0;
  line_number = number;
  tmp = strlen((char const *)line);
  if (tmp >= 2048UL) {
    other_parse_error((char const *)"String too long");
  }
  CPS_NormalizeLine(line);
  if (! *line) {
    processed_file = (char const *)((void *)0);
    return;
  }
  command = line;
  processed_command = (char const *)command;
  p = CPS_SplitWord(line);
  if (print_config) {
    tmp___1 = strcasecmp((char const *)command, (char const *)"include");
    if (tmp___1) {
      tmp___2 = strcasecmp((char const *)command, (char const *)"confdir");
      if (tmp___2) {
        if ((int )*(p + 0) != 0) {
          tmp___0 = " ";
        } else {
          tmp___0 = "";
        }
        printf((char const *)"%s%s%s\n", command, tmp___0, p);
      }
    }
  }
  tmp___93 = strcasecmp((char const *)command, (char const *)"acquisitionport");
  if (tmp___93) {
    tmp___92 = strcasecmp((char const *)command, (char const *)"allow");
    if (tmp___92) {
      tmp___91 = strcasecmp((char const *)command, (char const *)"authselectmode");
      if (tmp___91) {
        tmp___90 = strcasecmp((char const *)command, (char const *)"bindacqaddress");
        if (tmp___90) {
          tmp___89 = strcasecmp((char const *)command, (char const *)"bindacqdevice");
          if (tmp___89) {
            tmp___88 = strcasecmp((char const *)command, (char const *)"bindaddress");
            if (tmp___88) {
              tmp___87 = strcasecmp((char const *)command, (char const *)"bindcmdaddress");
              if (tmp___87) {
                tmp___86 = strcasecmp((char const *)command, (char const *)"bindcmddevice");
                if (tmp___86) {
                  tmp___85 = strcasecmp((char const *)command, (char const *)"binddevice");
                  if (tmp___85) {
                    tmp___84 = strcasecmp((char const *)command, (char const *)"broadcast");
                    if (tmp___84) {
                      tmp___83 = strcasecmp((char const *)command, (char const *)"clientloglimit");
                      if (tmp___83) {
                        tmp___82 = strcasecmp((char const *)command, (char const *)"clockprecision");
                        if (tmp___82) {
                          tmp___81 = strcasecmp((char const *)command, (char const *)"cmdallow");
                          if (tmp___81) {
                            tmp___80 = strcasecmp((char const *)command, (char const *)"cmddeny");
                            if (tmp___80) {
                              tmp___79 = strcasecmp((char const *)command, (char const *)"cmdport");
                              if (tmp___79) {
                                tmp___78 = strcasecmp((char const *)command, (char const *)"cmdratelimit");
                                if (tmp___78) {
                                  tmp___77 = strcasecmp((char const *)command, (char const *)"combinelimit");
                                  if (tmp___77) {
                                    tmp___76 = strcasecmp((char const *)command,
                                                          (char const *)"confdir");
                                    if (tmp___76) {
                                      tmp___75 = strcasecmp((char const *)command,
                                                            (char const *)"corrtimeratio");
                                      if (tmp___75) {
                                        tmp___74 = strcasecmp((char const *)command,
                                                              (char const *)"deny");
                                        if (tmp___74) {
                                          tmp___73 = strcasecmp((char const *)command,
                                                                (char const *)"driftfile");
                                          if (tmp___73) {
                                            tmp___72 = strcasecmp((char const *)command,
                                                                  (char const *)"dscp");
                                            if (tmp___72) {
                                              tmp___71 = strcasecmp((char const *)command,
                                                                    (char const *)"dumpdir");
                                              if (tmp___71) {
                                                tmp___70 = strcasecmp((char const *)command,
                                                                      (char const *)"dumponexit");
                                                if (tmp___70) {
                                                  tmp___69 = strcasecmp((char const *)command,
                                                                        (char const *)"fallbackdrift");
                                                  if (tmp___69) {
                                                    tmp___68 = strcasecmp((char const *)command,
                                                                          (char const *)"hwclockfile");
                                                    if (tmp___68) {
                                                      tmp___67 = strcasecmp((char const *)command,
                                                                            (char const *)"hwtimestamp");
                                                      if (tmp___67) {
                                                        tmp___66 = strcasecmp((char const *)command,
                                                                              (char const *)"include");
                                                        if (tmp___66) {
                                                          tmp___65 = strcasecmp((char const *)command,
                                                                                (char const *)"initstepslew");
                                                          if (tmp___65) {
                                                            tmp___64 = strcasecmp((char const *)command,
                                                                                  (char const *)"keyfile");
                                                            if (tmp___64) {
                                                              tmp___63 = strcasecmp((char const *)command,
                                                                                    (char const *)"leapsecmode");
                                                              if (tmp___63) {
                                                                tmp___62 = strcasecmp((char const *)command,
                                                                                      (char const *)"leapsectz");
                                                                if (tmp___62) {
                                                                  tmp___61 = strcasecmp((char const *)command,
                                                                                        (char const *)"local");
                                                                  if (tmp___61) {
                                                                    tmp___60 = strcasecmp((char const *)command,
                                                                                          (char const *)"lock_all");
                                                                    if (tmp___60) {
                                                                      tmp___59 = strcasecmp((char const *)command,
                                                                                            (char const *)"log");
                                                                      if (tmp___59) {
                                                                        tmp___58 = strcasecmp((char const *)command,
                                                                                              (char const *)"logbanner");
                                                                        if (tmp___58) {
                                                                          tmp___57 = strcasecmp((char const *)command,
                                                                                                (char const *)"logchange");
                                                                          if (tmp___57) {
                                                                            tmp___56 = strcasecmp((char const *)command,
                                                                                                  (char const *)"logdir");
                                                                            if (tmp___56) {
                                                                              tmp___55 = strcasecmp((char const *)command,
                                                                                                    (char const *)"mailonchange");
                                                                              if (tmp___55) {
                                                                                tmp___54 = strcasecmp((char const *)command,
                                                                                                      (char const *)"makestep");
                                                                                if (tmp___54) {
                                                                                  tmp___53 = strcasecmp((char const *)command,
                                                                                                        (char const *)"manual");
                                                                                  if (tmp___53) {
                                                                                    tmp___52 = strcasecmp((char const *)command,
                                                                                                          (char const *)"maxchange");
                                                                                    if (tmp___52) {
                                                                                      tmp___51 = strcasecmp((char const *)command,
                                                                                                            (char const *)"maxclockerror");
                                                                                      if (tmp___51) {
                                                                                        tmp___50 = strcasecmp((char const *)command,
                                                                                                              (char const *)"maxdistance");
                                                                                        if (tmp___50) {
                                                                                          tmp___49 = strcasecmp((char const *)command,
                                                                                                                (char const *)"maxdrift");
                                                                                          if (tmp___49) {
                                                                                            tmp___48 = strcasecmp((char const *)command,
                                                                                                                  (char const *)"maxjitter");
                                                                                            if (tmp___48) {
                                                                                              tmp___47 = strcasecmp((char const *)command,
                                                                                                                    (char const *)"maxntsconnections");
                                                                                              if (tmp___47) {
                                                                                                tmp___46 = strcasecmp((char const *)command,
                                                                                                                      (char const *)"maxsamples");
                                                                                                if (tmp___46) {
                                                                                                  tmp___45 = strcasecmp((char const *)command,
                                                                                                                        (char const *)"maxslewrate");
                                                                                                  if (tmp___45) {
                                                                                                    tmp___44 = strcasecmp((char const *)command,
                                                                                                                          (char const *)"maxupdateskew");
                                                                                                    if (tmp___44) {
                                                                                                      tmp___43 = strcasecmp((char const *)command,
                                                                                                                            (char const *)"minsamples");
                                                                                                      if (tmp___43) {
                                                                                                        tmp___42 = strcasecmp((char const *)command,
                                                                                                                              (char const *)"minsources");
                                                                                                        if (tmp___42) {
                                                                                                          tmp___41 = strcasecmp((char const *)command,
                                                                                                                                (char const *)"nocerttimecheck");
                                                                                                          if (tmp___41) {
                                                                                                            tmp___40 = strcasecmp((char const *)command,
                                                                                                                                  (char const *)"noclientlog");
                                                                                                            if (tmp___40) {
                                                                                                              tmp___39 = strcasecmp((char const *)command,
                                                                                                                                    (char const *)"nosystemcert");
                                                                                                              if (tmp___39) {
                                                                                                                tmp___38 = strcasecmp((char const *)command,
                                                                                                                                      (char const *)"ntpsigndsocket");
                                                                                                                if (tmp___38) {
                                                                                                                  tmp___37 = strcasecmp((char const *)command,
                                                                                                                                        (char const *)"ntsratelimit");
                                                                                                                  if (tmp___37) {
                                                                                                                    tmp___35 = strcasecmp((char const *)command,
                                                                                                                                          (char const *)"ntscachedir");
                                                                                                                    if (tmp___35) {
                                                                                                                      tmp___36 = strcasecmp((char const *)command,
                                                                                                                                            (char const *)"ntsdumpdir");
                                                                                                                      if (tmp___36) {
                                                                                                                        tmp___34 = strcasecmp((char const *)command,
                                                                                                                                              (char const *)"ntsntpserver");
                                                                                                                        if (tmp___34) {
                                                                                                                          tmp___33 = strcasecmp((char const *)command,
                                                                                                                                                (char const *)"ntsport");
                                                                                                                          if (tmp___33) {
                                                                                                                            tmp___32 = strcasecmp((char const *)command,
                                                                                                                                                  (char const *)"ntsprocesses");
                                                                                                                            if (tmp___32) {
                                                                                                                              tmp___31 = strcasecmp((char const *)command,
                                                                                                                                                    (char const *)"ntsrefresh");
                                                                                                                              if (tmp___31) {
                                                                                                                                tmp___30 = strcasecmp((char const *)command,
                                                                                                                                                      (char const *)"ntsrotate");
                                                                                                                                if (tmp___30) {
                                                                                                                                  tmp___29 = strcasecmp((char const *)command,
                                                                                                                                                        (char const *)"ntsservercert");
                                                                                                                                  if (tmp___29) {
                                                                                                                                    tmp___28 = strcasecmp((char const *)command,
                                                                                                                                                          (char const *)"ntsserverkey");
                                                                                                                                    if (tmp___28) {
                                                                                                                                      tmp___27 = strcasecmp((char const *)command,
                                                                                                                                                            (char const *)"ntstrustedcerts");
                                                                                                                                      if (tmp___27) {
                                                                                                                                        tmp___26 = strcasecmp((char const *)command,
                                                                                                                                                              (char const *)"peer");
                                                                                                                                        if (tmp___26) {
                                                                                                                                          tmp___25 = strcasecmp((char const *)command,
                                                                                                                                                                (char const *)"pidfile");
                                                                                                                                          if (tmp___25) {
                                                                                                                                            tmp___24 = strcasecmp((char const *)command,
                                                                                                                                                                  (char const *)"pool");
                                                                                                                                            if (tmp___24) {
                                                                                                                                              tmp___23 = strcasecmp((char const *)command,
                                                                                                                                                                    (char const *)"port");
                                                                                                                                              if (tmp___23) {
                                                                                                                                                tmp___22 = strcasecmp((char const *)command,
                                                                                                                                                                      (char const *)"ptpport");
                                                                                                                                                if (tmp___22) {
                                                                                                                                                  tmp___21 = strcasecmp((char const *)command,
                                                                                                                                                                        (char const *)"ratelimit");
                                                                                                                                                  if (tmp___21) {
                                                                                                                                                    tmp___20 = strcasecmp((char const *)command,
                                                                                                                                                                          (char const *)"refclock");
                                                                                                                                                    if (tmp___20) {
                                                                                                                                                      tmp___19 = strcasecmp((char const *)command,
                                                                                                                                                                            (char const *)"reselectdist");
                                                                                                                                                      if (tmp___19) {
                                                                                                                                                        tmp___18 = strcasecmp((char const *)command,
                                                                                                                                                                              (char const *)"rtcautotrim");
                                                                                                                                                        if (tmp___18) {
                                                                                                                                                          tmp___17 = strcasecmp((char const *)command,
                                                                                                                                                                                (char const *)"rtcdevice");
                                                                                                                                                          if (tmp___17) {
                                                                                                                                                            tmp___16 = strcasecmp((char const *)command,
                                                                                                                                                                                  (char const *)"rtcfile");
                                                                                                                                                            if (tmp___16) {
                                                                                                                                                              tmp___15 = strcasecmp((char const *)command,
                                                                                                                                                                                    (char const *)"rtconutc");
                                                                                                                                                              if (tmp___15) {
                                                                                                                                                                tmp___14 = strcasecmp((char const *)command,
                                                                                                                                                                                      (char const *)"rtcsync");
                                                                                                                                                                if (tmp___14) {
                                                                                                                                                                  tmp___13 = strcasecmp((char const *)command,
                                                                                                                                                                                        (char const *)"sched_priority");
                                                                                                                                                                  if (tmp___13) {
                                                                                                                                                                    tmp___12 = strcasecmp((char const *)command,
                                                                                                                                                                                          (char const *)"server");
                                                                                                                                                                    if (tmp___12) {
                                                                                                                                                                      tmp___11 = strcasecmp((char const *)command,
                                                                                                                                                                                            (char const *)"smoothtime");
                                                                                                                                                                      if (tmp___11) {
                                                                                                                                                                        tmp___10 = strcasecmp((char const *)command,
                                                                                                                                                                                              (char const *)"sourcedir");
                                                                                                                                                                        if (tmp___10) {
                                                                                                                                                                          tmp___9 = strcasecmp((char const *)command,
                                                                                                                                                                                               (char const *)"stratumweight");
                                                                                                                                                                          if (tmp___9) {
                                                                                                                                                                            tmp___8 = strcasecmp((char const *)command,
                                                                                                                                                                                                 (char const *)"tempcomp");
                                                                                                                                                                            if (tmp___8) {
                                                                                                                                                                              tmp___7 = strcasecmp((char const *)command,
                                                                                                                                                                                                   (char const *)"user");
                                                                                                                                                                              if (tmp___7) {
                                                                                                                                                                                tmp___3 = strcasecmp((char const *)command,
                                                                                                                                                                                                     (char const *)"commandkey");
                                                                                                                                                                                if (tmp___3) {
                                                                                                                                                                                  tmp___4 = strcasecmp((char const *)command,
                                                                                                                                                                                                       (char const *)"generatecommandkey");
                                                                                                                                                                                  if (tmp___4) {
                                                                                                                                                                                    tmp___5 = strcasecmp((char const *)command,
                                                                                                                                                                                                         (char const *)"linux_freq_scale");
                                                                                                                                                                                    if (tmp___5) {
                                                                                                                                                                                      tmp___6 = strcasecmp((char const *)command,
                                                                                                                                                                                                           (char const *)"linux_hz");
                                                                                                                                                                                      if (tmp___6) {
                                                                                                                                                                                        other_parse_error((char const *)"Invalid directive");
                                                                                                                                                                                      } else {
                                                                                                                                                                                        LOG_Message((LOG_Severity )1,
                                                                                                                                                                                                    (char const *)"%s directive is no longer supported",
                                                                                                                                                                                                    command);
                                                                                                                                                                                      }
                                                                                                                                                                                    } else {
                                                                                                                                                                                      LOG_Message((LOG_Severity )1,
                                                                                                                                                                                                  (char const *)"%s directive is no longer supported",
                                                                                                                                                                                                  command);
                                                                                                                                                                                    }
                                                                                                                                                                                  } else {
                                                                                                                                                                                    LOG_Message((LOG_Severity )1,
                                                                                                                                                                                                (char const *)"%s directive is no longer supported",
                                                                                                                                                                                                command);
                                                                                                                                                                                  }
                                                                                                                                                                                } else {
                                                                                                                                                                                  LOG_Message((LOG_Severity )1,
                                                                                                                                                                                              (char const *)"%s directive is no longer supported",
                                                                                                                                                                                              command);
                                                                                                                                                                                }
                                                                                                                                                                              } else {
                                                                                                                                                                                parse_string(p,
                                                                                                                                                                                             & user);
                                                                                                                                                                              }
                                                                                                                                                                            } else {
                                                                                                                                                                              parse_tempcomp(p);
                                                                                                                                                                            }
                                                                                                                                                                          } else {
                                                                                                                                                                            parse_double(p,
                                                                                                                                                                                         & stratum_weight);
                                                                                                                                                                          }
                                                                                                                                                                        } else {
                                                                                                                                                                          parse_sourcedir(p);
                                                                                                                                                                        }
                                                                                                                                                                      } else {
                                                                                                                                                                        parse_smoothtime(p);
                                                                                                                                                                      }
                                                                                                                                                                    } else {
                                                                                                                                                                      parse_source(p,
                                                                                                                                                                                   command,
                                                                                                                                                                                   1);
                                                                                                                                                                    }
                                                                                                                                                                  } else {
                                                                                                                                                                    parse_int(p,
                                                                                                                                                                              & sched_priority);
                                                                                                                                                                  }
                                                                                                                                                                } else {
                                                                                                                                                                  rtc_sync = parse_null(p);
                                                                                                                                                                }
                                                                                                                                                              } else {
                                                                                                                                                                rtc_on_utc = parse_null(p);
                                                                                                                                                              }
                                                                                                                                                            } else {
                                                                                                                                                              parse_string(p,
                                                                                                                                                                           & rtc_file);
                                                                                                                                                            }
                                                                                                                                                          } else {
                                                                                                                                                            parse_string(p,
                                                                                                                                                                         & rtc_device);
                                                                                                                                                          }
                                                                                                                                                        } else {
                                                                                                                                                          parse_double(p,
                                                                                                                                                                       & rtc_autotrim_threshold);
                                                                                                                                                        }
                                                                                                                                                      } else {
                                                                                                                                                        parse_double(p,
                                                                                                                                                                     & reselect_distance);
                                                                                                                                                      }
                                                                                                                                                    } else {
                                                                                                                                                      parse_refclock(p);
                                                                                                                                                    }
                                                                                                                                                  } else {
                                                                                                                                                    parse_ratelimit(p,
                                                                                                                                                                    & ntp_ratelimit_enabled,
                                                                                                                                                                    & ntp_ratelimit_interval,
                                                                                                                                                                    & ntp_ratelimit_burst,
                                                                                                                                                                    & ntp_ratelimit_leak);
                                                                                                                                                  }
                                                                                                                                                } else {
                                                                                                                                                  parse_int(p,
                                                                                                                                                            & ptp_port);
                                                                                                                                                }
                                                                                                                                              } else {
                                                                                                                                                parse_int(p,
                                                                                                                                                          & ntp_port);
                                                                                                                                              }
                                                                                                                                            } else {
                                                                                                                                              parse_source(p,
                                                                                                                                                           command,
                                                                                                                                                           1);
                                                                                                                                            }
                                                                                                                                          } else {
                                                                                                                                            parse_string(p,
                                                                                                                                                         & pidfile);
                                                                                                                                          }
                                                                                                                                        } else {
                                                                                                                                          parse_source(p,
                                                                                                                                                       command,
                                                                                                                                                       1);
                                                                                                                                        }
                                                                                                                                      } else {
                                                                                                                                        parse_ntstrustedcerts(p);
                                                                                                                                      }
                                                                                                                                    } else {
                                                                                                                                      parse_ntsserver(p,
                                                                                                                                                      nts_server_key_files);
                                                                                                                                    }
                                                                                                                                  } else {
                                                                                                                                    parse_ntsserver(p,
                                                                                                                                                    nts_server_cert_files);
                                                                                                                                  }
                                                                                                                                } else {
                                                                                                                                  parse_int(p,
                                                                                                                                            & nts_rotate);
                                                                                                                                }
                                                                                                                              } else {
                                                                                                                                parse_int(p,
                                                                                                                                          & nts_refresh);
                                                                                                                              }
                                                                                                                            } else {
                                                                                                                              parse_int(p,
                                                                                                                                        & nts_server_processes);
                                                                                                                            }
                                                                                                                          } else {
                                                                                                                            parse_int(p,
                                                                                                                                      & nts_server_port);
                                                                                                                          }
                                                                                                                        } else {
                                                                                                                          parse_string(p,
                                                                                                                                       & nts_ntp_server);
                                                                                                                        }
                                                                                                                      } else {
                                                                                                                        parse_string(p,
                                                                                                                                     & nts_dump_dir);
                                                                                                                      }
                                                                                                                    } else {
                                                                                                                      parse_string(p,
                                                                                                                                   & nts_dump_dir);
                                                                                                                    }
                                                                                                                  } else {
                                                                                                                    parse_ratelimit(p,
                                                                                                                                    & nts_ratelimit_enabled,
                                                                                                                                    & nts_ratelimit_interval,
                                                                                                                                    & nts_ratelimit_burst,
                                                                                                                                    & nts_ratelimit_leak);
                                                                                                                  }
                                                                                                                } else {
                                                                                                                  parse_string(p,
                                                                                                                               & ntp_signd_socket);
                                                                                                                }
                                                                                                              } else {
                                                                                                                no_system_cert = parse_null(p);
                                                                                                              }
                                                                                                            } else {
                                                                                                              no_client_log = parse_null(p);
                                                                                                            }
                                                                                                          } else {
                                                                                                            parse_int(p,
                                                                                                                      & no_cert_time_check);
                                                                                                          }
                                                                                                        } else {
                                                                                                          parse_int(p,
                                                                                                                    & min_sources);
                                                                                                        }
                                                                                                      } else {
                                                                                                        parse_int(p,
                                                                                                                  & min_samples);
                                                                                                      }
                                                                                                    } else {
                                                                                                      parse_double(p,
                                                                                                                   & max_update_skew);
                                                                                                    }
                                                                                                  } else {
                                                                                                    parse_double(p,
                                                                                                                 & max_slew_rate);
                                                                                                  }
                                                                                                } else {
                                                                                                  parse_int(p,
                                                                                                            & max_samples);
                                                                                                }
                                                                                              } else {
                                                                                                parse_int(p,
                                                                                                          & nts_server_connections);
                                                                                              }
                                                                                            } else {
                                                                                              parse_double(p,
                                                                                                           & max_jitter);
                                                                                            }
                                                                                          } else {
                                                                                            parse_double(p,
                                                                                                         & max_drift);
                                                                                          }
                                                                                        } else {
                                                                                          parse_double(p,
                                                                                                       & max_distance);
                                                                                        }
                                                                                      } else {
                                                                                        parse_double(p,
                                                                                                     & max_clock_error);
                                                                                      }
                                                                                    } else {
                                                                                      parse_maxchange(p);
                                                                                    }
                                                                                  } else {
                                                                                    enable_manual = parse_null(p);
                                                                                  }
                                                                                } else {
                                                                                  parse_makestep(p);
                                                                                }
                                                                              } else {
                                                                                parse_mailonchange(p);
                                                                              }
                                                                            } else {
                                                                              parse_string(p,
                                                                                           & logdir);
                                                                            }
                                                                          } else {
                                                                            parse_double(p,
                                                                                         & log_change_threshold);
                                                                          }
                                                                        } else {
                                                                          parse_int(p,
                                                                                    & log_banner);
                                                                        }
                                                                      } else {
                                                                        parse_log(p);
                                                                      }
                                                                    } else {
                                                                      lock_memory = parse_null(p);
                                                                    }
                                                                  } else {
                                                                    parse_local(p);
                                                                  }
                                                                } else {
                                                                  parse_string(p,
                                                                               & leapsec_tz);
                                                                }
                                                              } else {
                                                                parse_leapsecmode(p);
                                                              }
                                                            } else {
                                                              parse_string(p, & keys_file);
                                                            }
                                                          } else {
                                                            parse_initstepslew(p);
                                                          }
                                                        } else {
                                                          parse_include(p);
                                                        }
                                                      } else {
                                                        parse_hwtimestamp(p);
                                                      }
                                                    } else {
                                                      parse_string(p, & hwclock_file);
                                                    }
                                                  } else {
                                                    parse_fallbackdrift(p);
                                                  }
                                                }
                                              } else {
                                                parse_string(p, & dumpdir);
                                              }
                                            } else {
                                              parse_int(p, & ntp_dscp);
                                            }
                                          } else {
                                            parse_string(p, & drift_file);
                                          }
                                        } else {
                                          parse_allow_deny(p, ntp_restrictions, 0);
                                        }
                                      } else {
                                        parse_double(p, & correction_time_ratio);
                                      }
                                    } else {
                                      parse_confdir(p);
                                    }
                                  } else {
                                    parse_double(p, & combine_limit);
                                  }
                                } else {
                                  parse_ratelimit(p, & cmd_ratelimit_enabled, & cmd_ratelimit_interval,
                                                  & cmd_ratelimit_burst, & cmd_ratelimit_leak);
                                }
                              } else {
                                parse_int(p, & cmd_port);
                              }
                            } else {
                              parse_allow_deny(p, cmd_restrictions, 0);
                            }
                          } else {
                            parse_allow_deny(p, cmd_restrictions, 1);
                          }
                        } else {
                          parse_double(p, & clock_precision);
                        }
                      } else {
                        parse_clientloglimit(p);
                      }
                    } else {
                      parse_broadcast(p);
                    }
                  } else {
                    parse_string(p, & bind_ntp_iface);
                  }
                } else {
                  parse_string(p, & bind_cmd_iface);
                }
              } else {
                parse_bindcmdaddress(p);
              }
            } else {
              parse_bindaddress(p);
            }
          } else {
            parse_string(p, & bind_acq_iface);
          }
        } else {
          parse_bindacqaddress(p);
        }
      } else {
        parse_authselectmode(p);
      }
    } else {
      parse_allow_deny(p, ntp_restrictions, 1);
    }
  } else {
    parse_int(p, & acquisition_port);
  }
  processed_command = (char const *)((void *)0);
  processed_file = processed_command;
  return;
}
}
static int parse_string(char *line , char **result )
{
  {
  check_number_of_args(line, 1);
  free((void *)*result);
  *result = Strdup((char const *)line);
  return (1);
}
}
static int parse_int(char *line , int *result )
{
  int tmp ;
  {
  check_number_of_args(line, 1);
  tmp = sscanf((char const *)line, (char const *)"%d", result);
  if (tmp != 1) {
    command_parse_error();
    return (0);
  }
  return (1);
}
}
static int parse_double(char *line , double *result )
{
  int tmp ;
  {
  check_number_of_args(line, 1);
  tmp = sscanf((char const *)line, (char const *)"%lf", result);
  if (tmp != 1) {
    command_parse_error();
    return (0);
  }
  return (1);
}
}
static int parse_null(char *line )
{
  {
  check_number_of_args(line, 0);
  return (1);
}
}
static void parse_source(char *line , char *type , int fatal )
{
  NTP_Source source ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  tmp___1 = strcasecmp((char const *)type, (char const *)"peer");
  if (tmp___1 == 0) {
    source.type = (NTP_Source_Type )1;
    source.pool = 0;
  } else {
    tmp___0 = strcasecmp((char const *)type, (char const *)"pool");
    if (tmp___0 == 0) {
      source.type = (NTP_Source_Type )0;
      source.pool = 1;
    } else {
      tmp = strcasecmp((char const *)type, (char const *)"server");
      if (tmp == 0) {
        source.type = (NTP_Source_Type )0;
        source.pool = 0;
      } else {
        if (fatal) {
          command_parse_error();
        }
        return;
      }
    }
  }
  memset((void *)(& source.params), 0, sizeof(source.params));
  tmp___2 = CPS_ParseNTPSourceAdd(line, & source.params);
  if (! tmp___2) {
    if (fatal) {
      command_parse_error();
    }
    return;
  }
  source.params.name = Strdup((char const *)source.params.name);
  ARR_AppendElement(ntp_sources, (void *)(& source));
  return;
}
}
static void parse_sourcedir(char *line )
{
  char *s ;
  {
  s = Strdup((char const *)line);
  ARR_AppendElement(ntp_source_dirs, (void *)(& s));
  return;
}
}
static void parse_ratelimit(char *line , int *enabled___1 , int *interval , int *burst ,
                            int *leak )
{
  int n ;
  int val ;
  char *opt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  *enabled___1 = 1;
  {
  while (1) {
    while_continue: ;
    if (! *line) {
      goto while_break;
    }
    opt = line;
    line = CPS_SplitWord(line);
    tmp = sscanf((char const *)line, (char const *)"%d%n", & val, & n);
    if (tmp != 1) {
      command_parse_error();
      return;
    }
    line += n;
    tmp___2 = strcasecmp((char const *)opt, (char const *)"interval");
    if (tmp___2) {
      tmp___1 = strcasecmp((char const *)opt, (char const *)"burst");
      if (tmp___1) {
        tmp___0 = strcasecmp((char const *)opt, (char const *)"leak");
        if (tmp___0) {
          command_parse_error();
        } else {
          *leak = val;
        }
      } else {
        *burst = val;
      }
    } else {
      *interval = val;
    }
  }
  while_break: ;
  }
  return;
}
}
static void parse_refclock(char *line )
{
  int n ;
  int poll ;
  int dpoll ;
  int filter_length ;
  int pps_rate ;
  int min_samples___0 ;
  int max_samples___0 ;
  int sel_options ;
  int max_lock_age ;
  int pps_forced ;
  int stratum ;
  int tai ;
  uint32_t ref_id ;
  uint32_t lock_ref_id ;
  double offset ;
  double delay ;
  double precision ;
  double max_dispersion ;
  double pulse_width ;
  char *p ;
  char *cmd ;
  char *name ;
  char *param ;
  unsigned char ref[5] ;
  RefclockParameters *refclock ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  void *tmp___35 ;
  {
  poll = 4;
  dpoll = 0;
  filter_length = 64;
  pps_forced = 0;
  pps_rate = 0;
  min_samples___0 = -1;
  max_samples___0 = -1;
  sel_options = 0;
  offset = 0.0;
  delay = 1e-9;
  precision = 0.0;
  max_dispersion = 0.0;
  pulse_width = 0.0;
  ref_id = (uint32_t )0;
  max_lock_age = 2;
  lock_ref_id = (uint32_t )0;
  stratum = 0;
  tai = 0;
  if (! *line) {
    command_parse_error();
    return;
  }
  p = line;
  line = CPS_SplitWord(line);
  if (! *line) {
    command_parse_error();
    return;
  }
  name = Strdup((char const *)p);
  p = line;
  line = CPS_SplitWord(line);
  param = Strdup((char const *)p);
  cmd = line;
  {
  while (1) {
    while_continue: ;
    if (! *cmd) {
      goto while_break;
    }
    line = CPS_SplitWord(line);
    tmp___34 = strcasecmp((char const *)cmd, (char const *)"refid");
    if (tmp___34) {
      tmp___33 = strcasecmp((char const *)cmd, (char const *)"lock");
      if (tmp___33) {
        tmp___32 = strcasecmp((char const *)cmd, (char const *)"poll");
        if (tmp___32) {
          tmp___31 = strcasecmp((char const *)cmd, (char const *)"dpoll");
          if (tmp___31) {
            tmp___30 = strcasecmp((char const *)cmd, (char const *)"filter");
            if (tmp___30) {
              tmp___29 = strcasecmp((char const *)cmd, (char const *)"rate");
              if (tmp___29) {
                tmp___28 = strcasecmp((char const *)cmd, (char const *)"minsamples");
                if (tmp___28) {
                  tmp___27 = strcasecmp((char const *)cmd, (char const *)"maxlockage");
                  if (tmp___27) {
                    tmp___26 = strcasecmp((char const *)cmd, (char const *)"maxsamples");
                    if (tmp___26) {
                      tmp___25 = strcasecmp((char const *)cmd, (char const *)"offset");
                      if (tmp___25) {
                        tmp___24 = strcasecmp((char const *)cmd, (char const *)"delay");
                        if (tmp___24) {
                          tmp___23 = strcasecmp((char const *)cmd, (char const *)"pps");
                          if (tmp___23) {
                            tmp___22 = strcasecmp((char const *)cmd, (char const *)"precision");
                            if (tmp___22) {
                              tmp___21 = strcasecmp((char const *)cmd, (char const *)"maxdispersion");
                              if (tmp___21) {
                                tmp___20 = strcasecmp((char const *)cmd, (char const *)"stratum");
                                if (tmp___20) {
                                  tmp___19 = strcasecmp((char const *)cmd, (char const *)"tai");
                                  if (tmp___19) {
                                    tmp___18 = strcasecmp((char const *)cmd, (char const *)"width");
                                    if (tmp___18) {
                                      tmp___17 = strcasecmp((char const *)cmd, (char const *)"noselect");
                                      if (tmp___17) {
                                        tmp___16 = strcasecmp((char const *)cmd,
                                                              (char const *)"prefer");
                                        if (tmp___16) {
                                          tmp___15 = strcasecmp((char const *)cmd,
                                                                (char const *)"trust");
                                          if (tmp___15) {
                                            tmp___14 = strcasecmp((char const *)cmd,
                                                                  (char const *)"require");
                                            if (tmp___14) {
                                              other_parse_error((char const *)"Invalid refclock option");
                                              return;
                                            } else {
                                              n = 0;
                                              sel_options |= 0x8;
                                            }
                                          } else {
                                            n = 0;
                                            sel_options |= 0x4;
                                          }
                                        } else {
                                          n = 0;
                                          sel_options |= 0x2;
                                        }
                                      } else {
                                        n = 0;
                                        sel_options |= 0x1;
                                      }
                                    } else {
                                      tmp___13 = sscanf((char const *)line, (char const *)"%lf%n",
                                                        & pulse_width, & n);
                                      if (tmp___13 != 1) {
                                        goto while_break;
                                      }
                                    }
                                  } else {
                                    n = 0;
                                    tai = 1;
                                  }
                                } else {
                                  tmp___12 = sscanf((char const *)line, (char const *)"%d%n",
                                                    & stratum, & n);
                                  if (tmp___12 != 1) {
                                    goto while_break;
                                  } else
                                  if (stratum >= 16) {
                                    goto while_break;
                                  } else
                                  if (stratum < 0) {
                                    goto while_break;
                                  }
                                }
                              } else {
                                tmp___11 = sscanf((char const *)line, (char const *)"%lf%n",
                                                  & max_dispersion, & n);
                                if (tmp___11 != 1) {
                                  goto while_break;
                                }
                              }
                            } else {
                              tmp___10 = sscanf((char const *)line, (char const *)"%lf%n",
                                                & precision, & n);
                              if (tmp___10 != 1) {
                                goto while_break;
                              }
                            }
                          } else {
                            n = 0;
                            pps_forced = 1;
                          }
                        } else {
                          tmp___9 = sscanf((char const *)line, (char const *)"%lf%n",
                                           & delay, & n);
                          if (tmp___9 != 1) {
                            goto while_break;
                          }
                        }
                      } else {
                        tmp___8 = sscanf((char const *)line, (char const *)"%lf%n",
                                         & offset, & n);
                        if (tmp___8 != 1) {
                          goto while_break;
                        }
                      }
                    } else {
                      tmp___7 = sscanf((char const *)line, (char const *)"%d%n",
                                       & max_samples___0, & n);
                      if (tmp___7 != 1) {
                        goto while_break;
                      }
                    }
                  } else {
                    tmp___6 = sscanf((char const *)line, (char const *)"%d%n",
                                     & max_lock_age, & n);
                    if (tmp___6 != 1) {
                      goto while_break;
                    }
                  }
                } else {
                  tmp___5 = sscanf((char const *)line, (char const *)"%d%n", & min_samples___0,
                                   & n);
                  if (tmp___5 != 1) {
                    goto while_break;
                  }
                }
              } else {
                tmp___4 = sscanf((char const *)line, (char const *)"%d%n", & pps_rate,
                                 & n);
                if (tmp___4 != 1) {
                  goto while_break;
                }
              }
            } else {
              tmp___3 = sscanf((char const *)line, (char const *)"%d%n", & filter_length,
                               & n);
              if (tmp___3 != 1) {
                goto while_break;
              }
            }
          } else {
            tmp___2 = sscanf((char const *)line, (char const *)"%d%n", & dpoll,
                             & n);
            if (tmp___2 != 1) {
              goto while_break;
            }
          }
        } else {
          tmp___1 = sscanf((char const *)line, (char const *)"%d%n", & poll, & n);
          if (tmp___1 != 1) {
            goto while_break;
          }
        }
      } else {
        tmp___0 = sscanf((char const *)line, (char const *)"%4s%n", (char *)(ref),
                         & n);
        if (tmp___0 != 1) {
          goto while_break;
        }
        lock_ref_id = ((((uint32_t )ref[0] << 24) | (unsigned int )((int )ref[1] << 16)) | (unsigned int )((int )ref[2] << 8)) | (unsigned int )ref[3];
      }
    } else {
      tmp = sscanf((char const *)line, (char const *)"%4s%n", (char *)(ref), & n);
      if (tmp != 1) {
        goto while_break;
      }
      ref_id = ((((uint32_t )ref[0] << 24) | (unsigned int )((int )ref[1] << 16)) | (unsigned int )((int )ref[2] << 8)) | (unsigned int )ref[3];
    }
    line += n;
    cmd = line;
  }
  while_break: ;
  }
  if (*cmd) {
    command_parse_error();
    return;
  }
  tmp___35 = ARR_GetNewElement(refclock_sources);
  refclock = (RefclockParameters *)tmp___35;
  refclock->driver_name = name;
  refclock->driver_parameter = param;
  refclock->driver_poll = dpoll;
  refclock->poll = poll;
  refclock->filter_length = filter_length;
  refclock->pps_forced = pps_forced;
  refclock->pps_rate = pps_rate;
  refclock->min_samples = min_samples___0;
  refclock->max_samples = max_samples___0;
  refclock->sel_options = sel_options;
  refclock->stratum = stratum;
  refclock->tai = tai;
  refclock->offset = offset;
  refclock->delay = delay;
  refclock->precision = precision;
  refclock->max_dispersion = max_dispersion;
  refclock->pulse_width = pulse_width;
  refclock->ref_id = ref_id;
  refclock->max_lock_age = max_lock_age;
  refclock->lock_ref_id = lock_ref_id;
  return;
}
}
static void parse_log(char *line )
{
  char *log_name ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  {
  {
  while (1) {
    while_continue: ;
    log_name = line;
    line = CPS_SplitWord(line);
    if (*log_name) {
      tmp___5 = strcmp((char const *)log_name, (char const *)"rawmeasurements");
      if (tmp___5) {
        tmp___4 = strcmp((char const *)log_name, (char const *)"measurements");
        if (tmp___4) {
          tmp___3 = strcmp((char const *)log_name, (char const *)"statistics");
          if (tmp___3) {
            tmp___2 = strcmp((char const *)log_name, (char const *)"tracking");
            if (tmp___2) {
              tmp___1 = strcmp((char const *)log_name, (char const *)"rtc");
              if (tmp___1) {
                tmp___0 = strcmp((char const *)log_name, (char const *)"refclocks");
                if (tmp___0) {
                  tmp = strcmp((char const *)log_name, (char const *)"tempcomp");
                  if (tmp) {
                    other_parse_error((char const *)"Invalid log parameter");
                    goto while_break;
                  } else {
                    do_log_tempcomp = 1;
                  }
                } else {
                  do_log_refclocks = 1;
                }
              } else {
                do_log_rtc = 1;
              }
            } else {
              do_log_tracking = 1;
            }
          } else {
            do_log_statistics = 1;
          }
        } else {
          do_log_measurements = 1;
        }
      } else {
        do_log_measurements = 1;
        raw_measurements = 1;
      }
    } else {
      goto while_break;
    }
  }
  while_break: ;
  }
  return;
}
}
static void parse_local(char *line )
{
  int tmp ;
  {
  tmp = CPS_ParseLocal(line, & local_stratum, & local_orphan, & local_distance);
  if (! tmp) {
    command_parse_error();
  }
  enable_local = 1;
  return;
}
}
static void parse_initstepslew(char *line )
{
  char *p ;
  char *hostname ;
  IPAddr ip_addr ;
  int tmp ;
  DNS_Status tmp___0 ;
  {
  if (restarted) {
    return;
  }
  ARR_SetSize(init_sources, 0U);
  p = CPS_SplitWord(line);
  tmp = sscanf((char const *)line, (char const *)"%lf", & init_slew_threshold);
  if (tmp != 1) {
    command_parse_error();
    return;
  }
  {
  while (1) {
    while_continue: ;
    if (! *p) {
      goto while_break;
    }
    hostname = p;
    p = CPS_SplitWord(p);
    if (*hostname) {
      tmp___0 = DNS_Name2IPAddress((char const *)hostname, & ip_addr, 1);
      if ((unsigned int )tmp___0 == 0U) {
        ARR_AppendElement(init_sources, (void *)(& ip_addr));
      } else {
        LOG_Message((LOG_Severity )1, (char const *)"Could not resolve address of initstepslew server %s",
                    hostname);
      }
    }
  }
  while_break: ;
  }
  return;
}
}
static void parse_leapsecmode(char *line )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  tmp___2 = strcasecmp((char const *)line, (char const *)"system");
  if (tmp___2) {
    tmp___1 = strcasecmp((char const *)line, (char const *)"slew");
    if (tmp___1) {
      tmp___0 = strcasecmp((char const *)line, (char const *)"step");
      if (tmp___0) {
        tmp = strcasecmp((char const *)line, (char const *)"ignore");
        if (tmp) {
          command_parse_error();
        } else {
          leapsec_mode = (REF_LeapMode )3;
        }
      } else {
        leapsec_mode = (REF_LeapMode )2;
      }
    } else {
      leapsec_mode = (REF_LeapMode )1;
    }
  } else {
    leapsec_mode = (REF_LeapMode )0;
  }
  return;
}
}
static void parse_clientloglimit(char *line )
{
  int tmp ;
  {
  check_number_of_args(line, 1);
  tmp = sscanf((char const *)line, (char const *)"%lu", & client_log_limit);
  if (tmp != 1) {
    command_parse_error();
  }
  return;
}
}
static void parse_fallbackdrift(char *line )
{
  int tmp ;
  {
  check_number_of_args(line, 2);
  tmp = sscanf((char const *)line, (char const *)"%d %d", & fb_drift_min, & fb_drift_max);
  if (tmp != 2) {
    command_parse_error();
  }
  return;
}
}
static void parse_makestep(char *line )
{
  int tmp ;
  {
  check_number_of_args(line, 2);
  tmp = sscanf((char const *)line, (char const *)"%lf %d", & make_step_threshold,
               & make_step_limit);
  if (tmp != 2) {
    make_step_limit = 0;
    command_parse_error();
  }
  if (restarted) {
    if (make_step_limit > 0) {
      make_step_limit = 0;
    }
  }
  return;
}
}
static void parse_maxchange(char *line )
{
  int tmp ;
  {
  check_number_of_args(line, 3);
  tmp = sscanf((char const *)line, (char const *)"%lf %d %d", & max_offset, & max_offset_delay,
               & max_offset_ignore);
  if (tmp != 3) {
    max_offset_delay = -1;
    command_parse_error();
  }
  return;
}
}
static void parse_mailonchange(char *line )
{
  char *address ;
  int tmp ;
  {
  check_number_of_args(line, 2);
  address = line;
  line = CPS_SplitWord(line);
  free((void *)mail_user_on_change);
  tmp = sscanf((char const *)line, (char const *)"%lf", & mail_change_threshold);
  if (tmp == 1) {
    mail_user_on_change = Strdup((char const *)address);
  } else {
    mail_user_on_change = (char *)((void *)0);
    command_parse_error();
  }
  return;
}
}
static void parse_ntsserver(char *line , ARR_Instance files )
{
  char *file ;
  {
  file = (char *)((void *)0);
  parse_string(line, & file);
  ARR_AppendElement(files, (void *)(& file));
  return;
}
}
static void parse_ntstrustedcerts(char *line )
{
  uint32_t id ;
  char *path ;
  int tmp ;
  int tmp___0 ;
  {
  tmp___0 = get_number_of_args(line);
  if (tmp___0 == 2) {
    path = CPS_SplitWord(line);
    tmp = sscanf((char const *)line, (char const *)"%u", & id);
    if (tmp != 1) {
      command_parse_error();
    }
  } else {
    check_number_of_args(line, 1);
    path = line;
    id = (uint32_t )0;
  }
  path = Strdup((char const *)path);
  ARR_AppendElement(nts_trusted_certs_paths, (void *)(& path));
  ARR_AppendElement(nts_trusted_certs_ids, (void *)(& id));
  return;
}
}
static void parse_allow_deny(char *line , ARR_Instance restrictions , int allow )
{
  int all ;
  int subnet_bits ;
  AllowDeny *node ;
  IPAddr ip ;
  int tmp ;
  void *tmp___0 ;
  {
  tmp = CPS_ParseAllowDeny(line, & all, & ip, & subnet_bits);
  if (! tmp) {
    command_parse_error();
  }
  tmp___0 = ARR_GetNewElement(restrictions);
  node = (AllowDeny *)tmp___0;
  node->allow = allow;
  node->all = all;
  node->ip = ip;
  node->subnet_bits = subnet_bits;
  return;
}
}
static void parse_authselectmode(char *line )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  tmp___2 = strcasecmp((char const *)line, (char const *)"require");
  if (tmp___2) {
    tmp___1 = strcasecmp((char const *)line, (char const *)"prefer");
    if (tmp___1) {
      tmp___0 = strcasecmp((char const *)line, (char const *)"mix");
      if (tmp___0) {
        tmp = strcasecmp((char const *)line, (char const *)"ignore");
        if (tmp) {
          command_parse_error();
        } else {
          authselect_mode = (SRC_AuthSelectMode )0;
        }
      } else {
        authselect_mode = (SRC_AuthSelectMode )1;
      }
    } else {
      authselect_mode = (SRC_AuthSelectMode )2;
    }
  } else {
    authselect_mode = (SRC_AuthSelectMode )3;
  }
  return;
}
}
static void parse_bindacqaddress(char *line )
{
  IPAddr ip ;
  int tmp ;
  {
  check_number_of_args(line, 1);
  tmp = UTI_StringToIP((char const *)line, & ip);
  if (tmp) {
    if ((int )ip.family == 1) {
      bind_acq_address4 = ip;
    } else
    if ((int )ip.family == 2) {
      bind_acq_address6 = ip;
    }
  } else {
    command_parse_error();
  }
  return;
}
}
static void parse_bindaddress(char *line )
{
  IPAddr ip ;
  int tmp ;
  {
  check_number_of_args(line, 1);
  tmp = UTI_StringToIP((char const *)line, & ip);
  if (tmp) {
    if ((int )ip.family == 1) {
      bind_address4 = ip;
    } else
    if ((int )ip.family == 2) {
      bind_address6 = ip;
    }
  } else {
    command_parse_error();
  }
  return;
}
}
static void parse_bindcmdaddress(char *line )
{
  IPAddr ip ;
  int tmp ;
  int tmp___0 ;
  {
  check_number_of_args(line, 1);
  if ((int )*(line + 0) == 47) {
    parse_string(line, & bind_cmd_path);
    tmp = strcmp((char const *)bind_cmd_path, (char const *)"/");
    if (tmp == 0) {
      free((void *)bind_cmd_path);
      bind_cmd_path = (char *)((void *)0);
    }
  } else {
    tmp___0 = UTI_StringToIP((char const *)line, & ip);
    if (tmp___0) {
      if ((int )ip.family == 1) {
        bind_cmd_address4 = ip;
      } else
      if ((int )ip.family == 2) {
        bind_cmd_address6 = ip;
      }
    } else {
      command_parse_error();
    }
  }
  return;
}
}
static void parse_broadcast(char *line )
{
  NTP_Broadcast_Destination *destination ;
  int port ;
  int interval ;
  char *p ;
  IPAddr ip ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  {
  p = line;
  line = CPS_SplitWord(line);
  tmp = sscanf((char const *)p, (char const *)"%d", & interval);
  if (tmp != 1) {
    command_parse_error();
    return;
  }
  p = line;
  line = CPS_SplitWord(line);
  tmp___0 = UTI_StringToIP((char const *)p, & ip);
  if (! tmp___0) {
    command_parse_error();
    return;
  }
  p = line;
  line = CPS_SplitWord(line);
  if (*p) {
    tmp___1 = sscanf((char const *)p, (char const *)"%d", & port);
    if (tmp___1 != 1) {
      command_parse_error();
      return;
    } else
    if (*line) {
      command_parse_error();
      return;
    }
  } else {
    port = 123;
  }
  tmp___2 = ARR_GetNewElement(broadcasts);
  destination = (NTP_Broadcast_Destination *)tmp___2;
  destination->addr.ip_addr = ip;
  destination->addr.port = (uint16_t )port;
  destination->interval = interval;
  return;
}
}
static void parse_smoothtime(char *line )
{
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  {
  tmp = get_number_of_args(line);
  if (tmp != 3) {
    check_number_of_args(line, 2);
  }
  tmp___0 = sscanf((char const *)line, (char const *)"%lf %lf", & smooth_max_freq,
                   & smooth_max_wander);
  if (tmp___0 != 2) {
    smooth_max_freq = 0.0;
    command_parse_error();
  }
  tmp___1 = CPS_SplitWord(line);
  line = CPS_SplitWord(tmp___1);
  smooth_leap_only = 0;
  if (*line) {
    tmp___2 = strcasecmp((char const *)line, (char const *)"leaponly");
    if (tmp___2) {
      command_parse_error();
    } else {
      smooth_leap_only = 1;
    }
  }
  return;
}
}
static void parse_tempcomp(char *line )
{
  char *p ;
  int point_form ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  {
  tmp = get_number_of_args(line);
  point_form = tmp == 3;
  if (! point_form) {
    check_number_of_args(line, 6);
  }
  p = line;
  line = CPS_SplitWord(line);
  if (! *p) {
    command_parse_error();
    return;
  }
  free((void *)tempcomp_point_file);
  if (point_form) {
    tmp___0 = sscanf((char const *)line, (char const *)"%lf", & tempcomp_interval);
    if (tmp___0 != 1) {
      command_parse_error();
      return;
    }
    tmp___1 = CPS_SplitWord(line);
    tempcomp_point_file = Strdup((char const *)tmp___1);
  } else {
    tmp___2 = sscanf((char const *)line, (char const *)"%lf %lf %lf %lf %lf",
                     & tempcomp_interval, & tempcomp_T0, & tempcomp_k0, & tempcomp_k1,
                     & tempcomp_k2);
    if (tmp___2 != 5) {
      command_parse_error();
      return;
    }
    tempcomp_point_file = (char *)((void *)0);
  }
  free((void *)tempcomp_sensor_file);
  tempcomp_sensor_file = Strdup((char const *)p);
  return;
}
}
static void parse_hwtimestamp(char *line )
{
  CNF_HwTsInterface *iface ;
  char *p ;
  char filter[5] ;
  int n ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  {
  if (! *line) {
    command_parse_error();
    return;
  }
  p = line;
  line = CPS_SplitWord(line);
  tmp = ARR_GetNewElement(hwts_interfaces);
  iface = (CNF_HwTsInterface *)tmp;
  iface->name = Strdup((char const *)p);
  iface->minpoll = 0;
  iface->min_samples = 2;
  iface->max_samples = 16;
  iface->nocrossts = 0;
  iface->rxfilter = (CNF_HwTs_RxFilter )0;
  iface->precision = 100.0e-9;
  iface->tx_comp = 0.0;
  iface->rx_comp = 0.0;
  p = line;
  {
  while (1) {
    while_continue: ;
    if (! *p) {
      goto while_break;
    }
    line = CPS_SplitWord(line);
    tmp___18 = strcasecmp((char const *)p, (char const *)"maxsamples");
    if (tmp___18) {
      tmp___17 = strcasecmp((char const *)p, (char const *)"minpoll");
      if (tmp___17) {
        tmp___16 = strcasecmp((char const *)p, (char const *)"minsamples");
        if (tmp___16) {
          tmp___15 = strcasecmp((char const *)p, (char const *)"precision");
          if (tmp___15) {
            tmp___14 = strcasecmp((char const *)p, (char const *)"rxcomp");
            if (tmp___14) {
              tmp___13 = strcasecmp((char const *)p, (char const *)"txcomp");
              if (tmp___13) {
                tmp___12 = strcasecmp((char const *)p, (char const *)"rxfilter");
                if (tmp___12) {
                  tmp___11 = strcasecmp((char const *)p, (char const *)"nocrossts");
                  if (tmp___11) {
                    goto while_break;
                  } else {
                    n = 0;
                    iface->nocrossts = 1;
                  }
                } else {
                  tmp___6 = sscanf((char const *)line, (char const *)"%4s%n",
                                   filter, & n);
                  if (tmp___6 != 1) {
                    goto while_break;
                  }
                  tmp___10 = strcasecmp((char const *)(filter), (char const *)"none");
                  if (tmp___10) {
                    tmp___9 = strcasecmp((char const *)(filter), (char const *)"ntp");
                    if (tmp___9) {
                      tmp___8 = strcasecmp((char const *)(filter), (char const *)"ptp");
                      if (tmp___8) {
                        tmp___7 = strcasecmp((char const *)(filter), (char const *)"all");
                        if (tmp___7) {
                          goto while_break;
                        } else {
                          iface->rxfilter = (CNF_HwTs_RxFilter )4;
                        }
                      } else {
                        iface->rxfilter = (CNF_HwTs_RxFilter )3;
                      }
                    } else {
                      iface->rxfilter = (CNF_HwTs_RxFilter )2;
                    }
                  } else {
                    iface->rxfilter = (CNF_HwTs_RxFilter )1;
                  }
                }
              } else {
                tmp___5 = sscanf((char const *)line, (char const *)"%lf%n", & iface->tx_comp,
                                 & n);
                if (tmp___5 != 1) {
                  goto while_break;
                }
              }
            } else {
              tmp___4 = sscanf((char const *)line, (char const *)"%lf%n", & iface->rx_comp,
                               & n);
              if (tmp___4 != 1) {
                goto while_break;
              }
            }
          } else {
            tmp___3 = sscanf((char const *)line, (char const *)"%lf%n", & iface->precision,
                             & n);
            if (tmp___3 != 1) {
              goto while_break;
            }
          }
        } else {
          tmp___2 = sscanf((char const *)line, (char const *)"%d%n", & iface->min_samples,
                           & n);
          if (tmp___2 != 1) {
            goto while_break;
          }
        }
      } else {
        tmp___1 = sscanf((char const *)line, (char const *)"%d%n", & iface->minpoll,
                         & n);
        if (tmp___1 != 1) {
          goto while_break;
        }
      }
    } else {
      tmp___0 = sscanf((char const *)line, (char const *)"%d%n", & iface->max_samples,
                       & n);
      if (tmp___0 != 1) {
        goto while_break;
      }
    }
    line += n;
    p = line;
  }
  while_break: ;
  }
  if (*p) {
    command_parse_error();
  }
  return;
}
}
static char const *get_basename(char const *path )
{
  char const *b ;
  char *tmp ;
  char const *tmp___0 ;
  {
  tmp = strrchr(path, '/');
  b = (char const *)tmp;
  if (b) {
    tmp___0 = b + 1;
  } else {
    tmp___0 = path;
  }
  return (tmp___0);
}
}
static int compare_basenames(void const *a , void const *b )
{
  char const *tmp ;
  char const *tmp___0 ;
  int tmp___1 ;
  {
  tmp = get_basename((char const *)*((char const **)b));
  tmp___0 = get_basename((char const *)*((char const **)a));
  tmp___1 = strcmp(tmp___0, tmp);
  return (tmp___1);
}
}
static int search_dirs(char *line , char const *suffix , void (*file_handler)(char const *path ) )
{
  char *dirs[10] ;
  char buf[2048] ;
  char *path ;
  size_t i ;
  size_t j ;
  size_t k ;
  size_t locations ;
  size_t n_dirs ;
  glob_t gl ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  char const *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  {
  tmp = UTI_SplitString(line, dirs, 10);
  n_dirs = (size_t )tmp;
  if (n_dirs < 1UL) {
    return (0);
  } else
  if (n_dirs > 10UL) {
    return (0);
  }
  i = (size_t )0;
  {
  while (1) {
    while_continue: ;
    if (! (i < n_dirs)) {
      goto while_break;
    }
    tmp___0 = snprintf(buf, sizeof(buf), (char const *)"%s/*%s", dirs[i], suffix);
    if ((unsigned long )tmp___0 >= sizeof(buf)) {
      assert(0);
    }
    if (i > 0UL) {
      tmp___1 = 1 << 5;
    } else {
      tmp___1 = 0;
    }
    tmp___2 = glob((char const * __restrict )(buf), (1 << 2) | tmp___1, (int (*)(char const * ,
                                                                                    int ))((void *)0),
                   (glob_t * __restrict )(& gl));
    i ++;
  }
  while_break: ;
  }
  if (gl.gl_pathc > 0UL) {
    qsort((void *)gl.gl_pathv, gl.gl_pathc, sizeof(*(gl.gl_pathv + 0)), & compare_basenames);
    i = (size_t )0;
    {
    while (1) {
      while_continue___0: ;
      if (! (i < gl.gl_pathc)) {
        goto while_break___0;
      }
      j = i + 1UL;
      locations = (size_t )1;
      {
      while (1) {
        while_continue___1: ;
        if (! (j < gl.gl_pathc)) {
          goto while_break___1;
        }
        tmp___3 = compare_basenames((void const *)(gl.gl_pathv + i), (void const *)(gl.gl_pathv + j));
        if (tmp___3 != 0) {
          goto while_break___1;
        }
        j ++;
        locations ++;
      }
      while_break___1: ;
      }
      j = (size_t )0;
      {
      while (1) {
        while_continue___2: ;
        if (! (j < n_dirs)) {
          goto while_break___2;
        }
        k = (size_t )0;
        {
        while (1) {
          while_continue___3: ;
          if (! (k < locations)) {
            goto while_break___3;
          }
          path = *(gl.gl_pathv + (i + k));
          tmp___4 = strlen((char const *)dirs[j]);
          tmp___5 = strncmp((char const *)path, (char const *)dirs[j], tmp___4);
          if (tmp___5 == 0) {
            tmp___6 = strlen((char const *)dirs[j]);
            tmp___7 = get_basename((char const *)path);
            tmp___8 = strlen(tmp___7);
            tmp___9 = strlen((char const *)path);
            if ((tmp___6 + 1UL) + tmp___8 == tmp___9) {
              (*file_handler)((char const *)path);
              goto while_break___3;
            }
          }
          k ++;
        }
        while_break___3: ;
        }
        if (k < locations) {
          goto while_break___2;
        }
        j ++;
      }
      while_break___2: ;
      }
      i += locations;
    }
    while_break___0: ;
    }
  }
  globfree(& gl);
  return (1);
}
}
static void parse_confdir(char *line )
{
  int tmp ;
  {
  tmp = search_dirs(line, (char const *)".conf", & CNF_ReadFile);
  if (! tmp) {
    command_parse_error();
  }
  return;
}
}
static void parse_include(char *line )
{
  glob_t gl ;
  size_t i ;
  int r ;
  {
  check_number_of_args(line, 1);
  r = glob((char const * __restrict )line, (1 << 11) | 1, (int (*)(char const * ,
                                                                      int ))((void *)0),
           (glob_t * __restrict )(& gl));
  if (r != 0) {
    if (r != 3) {
      {
      while (1) {
        while_continue: ;
        LOG_Message((LOG_Severity )3, (char const *)"Could not search for files matching %s",
                    line);
        exit(1);
        goto while_break;
      }
      while_break: ;
      }
    }
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
    return;
  }
  i = (size_t )0;
  {
  while (1) {
    while_continue___1: ;
    if (! (i < gl.gl_pathc)) {
      goto while_break___1;
    }
    CNF_ReadFile((char const *)*(gl.gl_pathv + i));
    i ++;
  }
  while_break___1: ;
  }
  globfree(& gl);
  return;
}
}
static void load_source_file(char const *filename___0 )
{
  char line[2049] ;
  FILE *f ;
  size_t tmp ;
  char *tmp___0 ;
  char __attribute__((__access__(__write_only__,1,2))) *tmp___1 ;
  {
  f = UTI_OpenFile((char const *)((void *)0), filename___0, (char const *)((void *)0),
                   (char )'r', (mode_t )0);
  if (! f) {
    return;
  }
  {
  while (1) {
    while_continue: ;
    tmp___1 = fgets(line, (int )sizeof(line), f);
    if (! tmp___1) {
      goto while_break;
    }
    if ((int )line[0] == 0) {
      goto while_break;
    } else {
      tmp = strlen((char const *)(line));
      if ((int )line[tmp - 1UL] != 10) {
        goto while_break;
      }
    }
    CPS_NormalizeLine(line);
    if ((int )line[0] == 0) {
      goto while_continue;
    }
    tmp___0 = CPS_SplitWord(line);
    parse_source(tmp___0, line, 0);
  }
  while_break: ;
  }
  fclose(f);
  return;
}
}
static int compare_sources(void const *a , void const *b )
{
  NTP_Source const *sa ;
  NTP_Source const *sb ;
  int d ;
  int tmp ;
  {
  sa = (NTP_Source const *)a;
  sb = (NTP_Source const *)b;
  if (! sa->params.name) {
    return (-1);
  }
  if (! sb->params.name) {
    return (1);
  }
  d = strcmp((char const *)sa->params.name, (char const *)sb->params.name);
  if (d != 0) {
    return (d);
  }
  d = (int )sa->type - (int )sb->type;
  if (d != 0) {
    return (d);
  }
  d = (int )(sa->pool - sb->pool);
  if (d != 0) {
    return (d);
  }
  d = (int )(sa->params.port - sb->params.port);
  if (d != 0) {
    return (d);
  }
  tmp = memcmp((void const *)(& sa->params.params), (void const *)(& sb->params.params),
               sizeof(sa->params.params));
  return (tmp);
}
}
static void reload_source_dirs(void)
{
  NTP_Source *prev_sources ;
  NTP_Source *new_sources ;
  NTP_Source *source ;
  unsigned int i ;
  unsigned int j ;
  unsigned int prev_size ;
  unsigned int new_size ;
  unsigned int unresolved ;
  uint32_t *prev_ids ;
  uint32_t *new_ids ;
  char buf[2048] ;
  NSR_Status s ;
  int d ;
  unsigned int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  {
  prev_size = ARR_GetSize(ntp_source_ids);
  if (prev_size > 0U) {
    tmp = ARR_GetSize(ntp_sources);
    if (tmp != prev_size) {
      assert(0);
    }
  }
  tmp___0 = Malloc2((size_t )prev_size, sizeof(uint32_t ));
  prev_ids = (uint32_t *)tmp___0;
  tmp___1 = ARR_GetElements(ntp_source_ids);
  memcpy((void *)prev_ids, (void const *)tmp___1, (unsigned long )prev_size * sizeof(*(prev_ids + 0)));
  tmp___2 = Malloc2((size_t )prev_size, sizeof(NTP_Source ));
  prev_sources = (NTP_Source *)tmp___2;
  tmp___3 = ARR_GetElements(ntp_sources);
  memcpy((void *)prev_sources, (void const *)tmp___3, (unsigned long )prev_size * sizeof(*(prev_sources + 0)));
  ARR_SetSize(ntp_sources, 0U);
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp___6 = ARR_GetSize(ntp_source_dirs);
    if (! (i < tmp___6)) {
      goto while_break;
    }
    tmp___4 = ARR_GetElement(ntp_source_dirs, i);
    tmp___5 = snprintf(buf, sizeof(buf), (char const *)"%s", *((char **)tmp___4));
    if ((unsigned long )tmp___5 >= sizeof(buf)) {
      assert(0);
    }
    search_dirs(buf, (char const *)".sources", & load_source_file);
    i ++;
  }
  while_break: ;
  }
  new_size = ARR_GetSize(ntp_sources);
  tmp___7 = ARR_GetElements(ntp_sources);
  new_sources = (NTP_Source *)tmp___7;
  ARR_SetSize(ntp_source_ids, new_size);
  tmp___8 = ARR_GetElements(ntp_source_ids);
  new_ids = (uint32_t *)tmp___8;
  unresolved = 0U;
  qsort((void *)new_sources, (size_t )new_size, sizeof(*(new_sources + 0)), & compare_sources);
  j = 0U;
  i = j;
  {
  while (1) {
    while_continue___0: ;
    if (! (i < prev_size)) {
      if (! (j < new_size)) {
        goto while_break___0;
      }
    }
    if (i < prev_size) {
      if (j < new_size) {
        d = compare_sources((void const *)(prev_sources + i), (void const *)(new_sources + j));
      } else {
        goto _L;
      }
    } else
    _L:
    if (i < prev_size) {
      d = -1;
    } else {
      d = 1;
    }
    if (d < 0) {
      if ((int )*((prev_sources + i)->params.name + 0) != 0) {
        NSR_RemoveSourcesById(*(prev_ids + i));
      }
      i ++;
    } else
    if (d > 0) {
      source = new_sources + j;
      s = NSR_AddSourceByName(source->params.name, source->params.port, source->pool,
                              source->type, & source->params.params, new_ids + j);
      if ((unsigned int )s == 6U) {
        unresolved ++;
      } else
      if ((unsigned int )s != 0U) {
        LOG_Message((LOG_Severity )2, (char const *)"Could not add source %s", source->params.name);
        *(source->params.name + 0) = (char )'\000';
      }
      j ++;
    } else {
      *(new_ids + j) = *(prev_ids + i);
      i ++;
      j ++;
    }
  }
  while_break___0: ;
  }
  i = 0U;
  {
  while (1) {
    while_continue___1: ;
    if (! (i < prev_size)) {
      goto while_break___1;
    }
    free((void *)(prev_sources + i)->params.name);
    i ++;
  }
  while_break___1: ;
  }
  free((void *)prev_sources);
  free((void *)prev_ids);
  if (unresolved > 0U) {
    NSR_ResolveSources();
  }
  return;
}
}
void CNF_CreateDirs(uid_t uid , gid_t gid )
{
  char *dir ;
  int tmp ;
  {
  if (bind_cmd_path) {
    dir = UTI_PathToDir((char const *)bind_cmd_path);
    UTI_CreateDirAndParents((char const *)dir, (mode_t )0770, uid, gid);
    tmp = UTI_CheckDirPermissions((char const *)dir, (mode_t )0770, uid, gid);
    if (! tmp) {
      LOG_Message((LOG_Severity )1, (char const *)"Disabled command socket %s",
                  bind_cmd_path);
      free((void *)bind_cmd_path);
      bind_cmd_path = (char *)((void *)0);
    }
    free((void *)dir);
  }
  if (logdir) {
    UTI_CreateDirAndParents((char const *)logdir, (mode_t )0750, uid, gid);
  }
  if (dumpdir) {
    UTI_CreateDirAndParents((char const *)dumpdir, (mode_t )0750, uid, gid);
  }
  if (nts_dump_dir) {
    UTI_CreateDirAndParents((char const *)nts_dump_dir, (mode_t )0750, uid, gid);
  }
  return;
}
}
void CNF_AddInitSources(void)
{
  CPS_NTP_Source cps_source ;
  NTP_Remote_Address ntp_addr ;
  char dummy_hostname[2] ;
  unsigned int i ;
  void *tmp ;
  char *tmp___0 ;
  NSR_Status tmp___1 ;
  unsigned int tmp___2 ;
  {
  dummy_hostname[0] = (char )'H';
  dummy_hostname[1] = (char )'\000';
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp___2 = ARR_GetSize(init_sources);
    if (! (i < tmp___2)) {
      goto while_break;
    }
    CPS_ParseNTPSourceAdd(dummy_hostname, & cps_source);
    tmp = ARR_GetElement(init_sources, i);
    ntp_addr.ip_addr = *((IPAddr *)tmp);
    ntp_addr.port = (uint16_t )cps_source.port;
    cps_source.params.iburst = 1;
    tmp___1 = NSR_AddSource(& ntp_addr, (NTP_Source_Type )0, & cps_source.params,
                            (uint32_t *)((void *)0));
    if ((unsigned int )tmp___1 != 0U) {
      tmp___0 = UTI_IPToString((IPAddr const *)(& ntp_addr.ip_addr));
      LOG_Message((LOG_Severity )2, (char const *)"Could not add source %s", tmp___0);
    }
    i ++;
  }
  while_break: ;
  }
  ARR_SetSize(init_sources, 0U);
  return;
}
}
void CNF_AddSources(void)
{
  NTP_Source *source ;
  unsigned int i ;
  NSR_Status s ;
  void *tmp ;
  unsigned int tmp___0 ;
  {
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp___0 = ARR_GetSize(ntp_sources);
    if (! (i < tmp___0)) {
      goto while_break;
    }
    tmp = ARR_GetElement(ntp_sources, i);
    source = (NTP_Source *)tmp;
    s = NSR_AddSourceByName(source->params.name, source->params.port, source->pool,
                            source->type, & source->params.params, (uint32_t *)((void *)0));
    if ((unsigned int )s != 0U) {
      if ((unsigned int )s != 6U) {
        LOG_Message((LOG_Severity )2, (char const *)"Could not add source %s", source->params.name);
      }
    }
    free((void *)source->params.name);
    i ++;
  }
  while_break: ;
  }
  ARR_SetSize(ntp_sources, 0U);
  reload_source_dirs();
  return;
}
}
void CNF_AddRefclocks(void)
{
  RefclockParameters *refclock ;
  unsigned int i ;
  void *tmp ;
  unsigned int tmp___0 ;
  {
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp___0 = ARR_GetSize(refclock_sources);
    if (! (i < tmp___0)) {
      goto while_break;
    }
    tmp = ARR_GetElement(refclock_sources, i);
    refclock = (RefclockParameters *)tmp;
    RCL_AddRefclock(refclock);
    free((void *)refclock->driver_name);
    free((void *)refclock->driver_parameter);
    i ++;
  }
  while_break: ;
  }
  ARR_SetSize(refclock_sources, 0U);
  return;
}
}
void CNF_AddBroadcasts(void)
{
  unsigned int i ;
  NTP_Broadcast_Destination *destination ;
  void *tmp ;
  unsigned int tmp___0 ;
  {
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp___0 = ARR_GetSize(broadcasts);
    if (! (i < tmp___0)) {
      goto while_break;
    }
    tmp = ARR_GetElement(broadcasts, i);
    destination = (NTP_Broadcast_Destination *)tmp;
    NCR_AddBroadcastDestination(& destination->addr, destination->interval);
    i ++;
  }
  while_break: ;
  }
  ARR_SetSize(broadcasts, 0U);
  return;
}
}
void CNF_ReloadSources(void)
{
  {
  reload_source_dirs();
  return;
}
}
int CNF_GetNTPPort(void)
{
  {
  return (ntp_port);
}
}
int CNF_GetAcquisitionPort(void)
{
  {
  return (acquisition_port);
}
}
char *CNF_GetDriftFile(void)
{
  {
  return (drift_file);
}
}
int CNF_GetLogBanner(void)
{
  {
  return (log_banner);
}
}
char *CNF_GetLogDir(void)
{
  {
  return (logdir);
}
}
char *CNF_GetDumpDir(void)
{
  {
  return (dumpdir);
}
}
int CNF_GetLogMeasurements(int *raw )
{
  {
  *raw = raw_measurements;
  return (do_log_measurements);
}
}
int CNF_GetLogStatistics(void)
{
  {
  return (do_log_statistics);
}
}
int CNF_GetLogTracking(void)
{
  {
  return (do_log_tracking);
}
}
int CNF_GetLogRtc(void)
{
  {
  return (do_log_rtc);
}
}
int CNF_GetLogRefclocks(void)
{
  {
  return (do_log_refclocks);
}
}
int CNF_GetLogTempComp(void)
{
  {
  return (do_log_tempcomp);
}
}
char *CNF_GetKeysFile(void)
{
  {
  return (keys_file);
}
}
double CNF_GetRtcAutotrim(void)
{
  {
  return (rtc_autotrim_threshold);
}
}
char *CNF_GetRtcFile(void)
{
  {
  return (rtc_file);
}
}
char *CNF_GetRtcDevice(void)
{
  {
  return (rtc_device);
}
}
double CNF_GetMaxUpdateSkew(void)
{
  {
  return (max_update_skew);
}
}
double CNF_GetMaxDrift(void)
{
  {
  return (max_drift);
}
}
double CNF_GetMaxClockError(void)
{
  {
  return (max_clock_error);
}
}
double CNF_GetCorrectionTimeRatio(void)
{
  {
  return (correction_time_ratio);
}
}
SRC_AuthSelectMode CNF_GetAuthSelectMode(void)
{
  {
  return (authselect_mode);
}
}
double CNF_GetMaxSlewRate(void)
{
  {
  return (max_slew_rate);
}
}
double CNF_GetClockPrecision(void)
{
  {
  return (clock_precision);
}
}
double CNF_GetMaxDistance(void)
{
  {
  return (max_distance);
}
}
double CNF_GetMaxJitter(void)
{
  {
  return (max_jitter);
}
}
double CNF_GetReselectDistance(void)
{
  {
  return (reselect_distance);
}
}
double CNF_GetStratumWeight(void)
{
  {
  return (stratum_weight);
}
}
double CNF_GetCombineLimit(void)
{
  {
  return (combine_limit);
}
}
int CNF_GetManualEnabled(void)
{
  {
  return (enable_manual);
}
}
int CNF_GetCommandPort(void)
{
  {
  return (cmd_port);
}
}
int CNF_AllowLocalReference(int *stratum , int *orphan , double *distance )
{
  {
  if (enable_local) {
    *stratum = local_stratum;
    *orphan = local_orphan;
    *distance = local_distance;
    return (1);
  } else {
    return (0);
  }
}
}
int CNF_GetRtcOnUtc(void)
{
  {
  return (rtc_on_utc);
}
}
int CNF_GetRtcSync(void)
{
  {
  return (rtc_sync);
}
}
void CNF_GetMakeStep(int *limit , double *threshold )
{
  {
  *limit = make_step_limit;
  *threshold = make_step_threshold;
  return;
}
}
void CNF_GetMaxChange(int *delay , int *ignore , double *offset )
{
  {
  *delay = max_offset_delay;
  *ignore = max_offset_ignore;
  *offset = max_offset;
  return;
}
}
double CNF_GetLogChange(void)
{
  {
  return (log_change_threshold);
}
}
void CNF_GetMailOnChange(int *enabled___1 , double *threshold , char **user___0 )
{
  {
  if (mail_user_on_change) {
    *enabled___1 = 1;
    *threshold = mail_change_threshold;
    *user___0 = mail_user_on_change;
  } else {
    *enabled___1 = 0;
    *threshold = 0.0;
    *user___0 = (char *)((void *)0);
  }
  return;
}
}
void CNF_SetupAccessRestrictions(void)
{
  AllowDeny *node ;
  int status ;
  unsigned int i ;
  void *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  {
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp___1 = ARR_GetSize(ntp_restrictions);
    if (! (i < tmp___1)) {
      goto while_break;
    }
    tmp = ARR_GetElement(ntp_restrictions, i);
    node = (AllowDeny *)tmp;
    status = NCR_AddAccessRestriction(& node->ip, node->subnet_bits, node->allow,
                                      node->all);
    if (! status) {
      {
      while (1) {
        while_continue___0: ;
        tmp___0 = UTI_IPToString((IPAddr const *)(& node->ip));
        LOG_Message((LOG_Severity )3, (char const *)"Bad subnet in %s/%d", tmp___0,
                    node->subnet_bits);
        exit(1);
        goto while_break___0;
      }
      while_break___0: ;
      }
    }
    i ++;
  }
  while_break: ;
  }
  i = 0U;
  {
  while (1) {
    while_continue___1: ;
    tmp___4 = ARR_GetSize(cmd_restrictions);
    if (! (i < tmp___4)) {
      goto while_break___1;
    }
    tmp___2 = ARR_GetElement(cmd_restrictions, i);
    node = (AllowDeny *)tmp___2;
    status = CAM_AddAccessRestriction(& node->ip, node->subnet_bits, node->allow,
                                      node->all);
    if (! status) {
      {
      while (1) {
        while_continue___2: ;
        tmp___3 = UTI_IPToString((IPAddr const *)(& node->ip));
        LOG_Message((LOG_Severity )3, (char const *)"Bad subnet in %s/%d", tmp___3,
                    node->subnet_bits);
        exit(1);
        goto while_break___2;
      }
      while_break___2: ;
      }
    }
    i ++;
  }
  while_break___1: ;
  }
  ARR_SetSize(ntp_restrictions, 0U);
  ARR_SetSize(cmd_restrictions, 0U);
  return;
}
}
int CNF_GetNoClientLog(void)
{
  {
  return (no_client_log);
}
}
unsigned long CNF_GetClientLogLimit(void)
{
  {
  return (client_log_limit);
}
}
void CNF_GetFallbackDrifts(int *min , int *max )
{
  {
  *min = fb_drift_min;
  *max = fb_drift_max;
  return;
}
}
void CNF_GetBindAddress(int family , IPAddr *addr )
{
  {
  if (family == 1) {
    *addr = bind_address4;
  } else
  if (family == 2) {
    *addr = bind_address6;
  } else {
    addr->family = (uint16_t )0;
  }
  return;
}
}
void CNF_GetBindAcquisitionAddress(int family , IPAddr *addr )
{
  {
  if (family == 1) {
    *addr = bind_acq_address4;
  } else
  if (family == 2) {
    *addr = bind_acq_address6;
  } else {
    addr->family = (uint16_t )0;
  }
  return;
}
}
char *CNF_GetBindNtpInterface(void)
{
  {
  return (bind_ntp_iface);
}
}
char *CNF_GetBindAcquisitionInterface(void)
{
  {
  return (bind_acq_iface);
}
}
char *CNF_GetBindCommandInterface(void)
{
  {
  return (bind_cmd_iface);
}
}
char *CNF_GetBindCommandPath(void)
{
  {
  return (bind_cmd_path);
}
}
void CNF_GetBindCommandAddress(int family , IPAddr *addr )
{
  {
  if (family == 1) {
    *addr = bind_cmd_address4;
  } else
  if (family == 2) {
    *addr = bind_cmd_address6;
  } else {
    addr->family = (uint16_t )0;
  }
  return;
}
}
int CNF_GetNtpDscp(void)
{
  {
  return (ntp_dscp);
}
}
char *CNF_GetNtpSigndSocket(void)
{
  {
  return (ntp_signd_socket);
}
}
char *CNF_GetPidFile(void)
{
  {
  return (pidfile);
}
}
REF_LeapMode CNF_GetLeapSecMode(void)
{
  {
  return (leapsec_mode);
}
}
char *CNF_GetLeapSecTimezone(void)
{
  {
  return (leapsec_tz);
}
}
int CNF_GetSchedPriority(void)
{
  {
  return (sched_priority);
}
}
int CNF_GetLockMemory(void)
{
  {
  return (lock_memory);
}
}
int CNF_GetNTPRateLimit(int *interval , int *burst , int *leak )
{
  {
  *interval = ntp_ratelimit_interval;
  *burst = ntp_ratelimit_burst;
  *leak = ntp_ratelimit_leak;
  return (ntp_ratelimit_enabled);
}
}
int CNF_GetNtsRateLimit(int *interval , int *burst , int *leak )
{
  {
  *interval = nts_ratelimit_interval;
  *burst = nts_ratelimit_burst;
  *leak = nts_ratelimit_leak;
  return (nts_ratelimit_enabled);
}
}
int CNF_GetCommandRateLimit(int *interval , int *burst , int *leak )
{
  {
  *interval = cmd_ratelimit_interval;
  *burst = cmd_ratelimit_burst;
  *leak = cmd_ratelimit_leak;
  return (cmd_ratelimit_enabled);
}
}
void CNF_GetSmooth(double *max_freq___1 , double *max_wander___0 , int *leap_only )
{
  {
  *max_freq___1 = smooth_max_freq;
  *max_wander___0 = smooth_max_wander;
  *leap_only = smooth_leap_only;
  return;
}
}
void CNF_GetTempComp(char **file , double *interval , char **point_file , double *T0___0 ,
                     double *k0___0 , double *k1___0 , double *k2___0 )
{
  {
  *file = tempcomp_sensor_file;
  *point_file = tempcomp_point_file;
  *interval = tempcomp_interval;
  *T0___0 = tempcomp_T0;
  *k0___0 = tempcomp_k0;
  *k1___0 = tempcomp_k1;
  *k2___0 = tempcomp_k2;
  return;
}
}
char *CNF_GetUser(void)
{
  {
  return (user);
}
}
int CNF_GetMaxSamples(void)
{
  {
  return (max_samples);
}
}
int CNF_GetMinSamples(void)
{
  {
  return (min_samples);
}
}
int CNF_GetMinSources(void)
{
  {
  return (min_sources);
}
}
char *CNF_GetHwclockFile(void)
{
  {
  return (hwclock_file);
}
}
int CNF_GetInitSources(void)
{
  unsigned int tmp ;
  {
  tmp = ARR_GetSize(init_sources);
  return ((int )tmp);
}
}
double CNF_GetInitStepThreshold(void)
{
  {
  return (init_slew_threshold);
}
}
int CNF_GetHwTsInterface(unsigned int index___0 , CNF_HwTsInterface **iface )
{
  unsigned int tmp ;
  void *tmp___0 ;
  {
  tmp = ARR_GetSize(hwts_interfaces);
  if (index___0 >= tmp) {
    return (0);
  }
  tmp___0 = ARR_GetElement(hwts_interfaces, index___0);
  *iface = (CNF_HwTsInterface *)tmp___0;
  return (1);
}
}
int CNF_GetPtpPort(void)
{
  {
  return (ptp_port);
}
}
char *CNF_GetNtsDumpDir(void)
{
  {
  return (nts_dump_dir);
}
}
char *CNF_GetNtsNtpServer(void)
{
  {
  return (nts_ntp_server);
}
}
int CNF_GetNtsServerCertAndKeyFiles(char const ***certs , char const ***keys___0 )
{
  void *tmp ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  {
  tmp = ARR_GetElements(nts_server_cert_files);
  *certs = (char const **)tmp;
  tmp___0 = ARR_GetElements(nts_server_key_files);
  *keys___0 = (char const **)tmp___0;
  tmp___1 = ARR_GetSize(nts_server_cert_files);
  tmp___2 = ARR_GetSize(nts_server_key_files);
  if (tmp___1 != tmp___2) {
    {
    while (1) {
      while_continue: ;
      LOG_Message((LOG_Severity )3, (char const *)"Uneven number of NTS certs and keys");
      exit(1);
      goto while_break;
    }
    while_break: ;
    }
  }
  tmp___3 = ARR_GetSize(nts_server_cert_files);
  return ((int )tmp___3);
}
}
int CNF_GetNtsServerPort(void)
{
  {
  return (nts_server_port);
}
}
int CNF_GetNtsServerProcesses(void)
{
  {
  return (nts_server_processes);
}
}
int CNF_GetNtsServerConnections(void)
{
  {
  return (nts_server_connections);
}
}
int CNF_GetNtsRefresh(void)
{
  {
  return (nts_refresh);
}
}
int CNF_GetNtsRotate(void)
{
  {
  return (nts_rotate);
}
}
int CNF_GetNtsTrustedCertsPaths(char const ***paths , uint32_t **ids )
{
  void *tmp ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  {
  tmp = ARR_GetElements(nts_trusted_certs_paths);
  *paths = (char const **)tmp;
  tmp___0 = ARR_GetElements(nts_trusted_certs_ids);
  *ids = (uint32_t *)tmp___0;
  tmp___1 = ARR_GetSize(nts_trusted_certs_paths);
  tmp___2 = ARR_GetSize(nts_trusted_certs_ids);
  if (tmp___1 != tmp___2) {
    assert(0);
  }
  tmp___3 = ARR_GetSize(nts_trusted_certs_paths);
  return ((int )tmp___3);
}
}
int CNF_GetNoSystemCert(void)
{
  {
  return (no_system_cert);
}
}
int CNF_GetNoCertTimeCheck(void)
{
  {
  return (no_cert_time_check);
}
}
void LCL_ReadRawTime(struct timespec *ts ) ;
void LCL_ReadCookedTime(struct timespec *result , double *err ) ;
void LCL_CookTime(struct timespec *raw , struct timespec *cooked , double *err ) ;
void LCL_GetOffsetCorrection(struct timespec *raw , double *correction , double *err ) ;
void LCL_AddParameterChangeHandler(void (*handler)(struct timespec *raw , struct timespec *cooked ,
                                                   double dfreq , double doffset ,
                                                   LCL_ChangeType change_type , void *anything ) ,
                                   void *anything ) ;
void LCL_RemoveParameterChangeHandler(void (*handler)(struct timespec *raw , struct timespec *cooked ,
                                                      double dfreq , double doffset ,
                                                      LCL_ChangeType change_type ,
                                                      void *anything ) , void *anything ) ;
int LCL_IsFirstParameterChangeHandler(void (*handler)(struct timespec *raw , struct timespec *cooked ,
                                                      double dfreq , double doffset ,
                                                      LCL_ChangeType change_type ,
                                                      void *anything ) ) ;
void LCL_AddDispersionNotifyHandler(void (*handler)(double dispersion , void *anything ) ,
                                    void *anything ) ;
extern void LCL_RemoveDispersionNotifyHandler(void (*handler)(double dispersion ,
                                                              void *anything ) , void *anything ) ;
double LCL_ReadAbsoluteFrequency(void) ;
void LCL_SetAbsoluteFrequency(double afreq_ppm ) ;
void LCL_AccumulateDeltaFrequency(double dfreq ) ;
int LCL_AccumulateOffset(double offset , double corr_rate ) ;
int LCL_ApplyStepOffset(double offset ) ;
void LCL_NotifyExternalTimeStep(struct timespec *raw , struct timespec *cooked , double offset ,
                                double dispersion ) ;
void LCL_NotifyLeap(int leap ) ;
int LCL_AccumulateFrequencyAndOffset(double dfreq , double doffset , double corr_rate ) ;
int LCL_GetSysPrecisionAsLog(void) ;
double LCL_GetSysPrecisionAsQuantum(void) ;
double LCL_GetMaxClockError(void) ;
void LCL_Initialise(void) ;
void LCL_Finalise(void) ;
int LCL_MakeStep(void) ;
void LCL_CancelOffsetCorrection(void) ;
int LCL_CanSystemLeap(void) ;
void LCL_SetSystemLeap(int leap , int tai_offset ) ;
double LCL_SetTempComp(double comp ) ;
void LCL_SetSyncStatus(int synchronised , double est_error , double max_error ) ;
void lcl_InvokeDispersionNotifyHandlers(double dispersion ) ;
void lcl_RegisterSystemDrivers(double (*read_freq)(void) , double (*set_freq)(double freq_ppm ) ,
                               void (*accrue_offset___1)(double offset , double corr_rate ) ,
                               int (*apply_step_offset___2)(double offset ) , void (*offset_convert___1)(struct timespec *raw ,
                                                                                                         double *corr ,
                                                                                                         double *err ) ,
                               void (*set_leap___0)(int leap , int tai_offset ) ,
                               void (*set_sync_status___1)(int synchronised , double est_error ,
                                                           double max_error ) ) ;
void SMT_Initialise(void) ;
void SMT_Finalise(void) ;
int SMT_IsEnabled(void) ;
double SMT_GetOffset(struct timespec *now ) ;
void SMT_Activate(struct timespec *now ) ;
void SMT_Reset(struct timespec *now ) ;
void SMT_Leap(struct timespec *now , int leap ) ;
int SMT_GetSmoothingReport(RPT_SmoothingReport *report , struct timespec *now ) ;
static double current_freq_ppm ;
static double max_freq_ppm ;
static double temp_comp_ppm ;
static double (*drv_read_freq)(void) ;
static double (*drv_set_freq)(double freq_ppm ) ;
static void (*drv_accrue_offset)(double offset , double corr_rate ) ;
static int (*drv_apply_step_offset)(double offset ) ;
static void (*drv_offset_convert)(struct timespec *raw , double *corr , double *err ) ;
static void (*drv_set_leap)(int leap , int tai_offset ) ;
static void (*drv_set_sync_status)(int synchronised , double est_error , double max_error ) ;
static ChangeListEntry change_list ;
static DispersionNotifyListEntry dispersion_notify_list ;
static int precision_log ;
static double precision_quantum ;
static double max_clock_error___0 ;
static double measure_clock_precision(void)
{
  struct timespec ts ;
  struct timespec old_ts ;
  int iters ;
  int diff ;
  int best ;
  {
  LCL_ReadRawTime(& old_ts);
  best = 1000000000;
  iters = 0;
  {
  while (1) {
    while_continue: ;
    LCL_ReadRawTime(& ts);
    diff = (int )(1000000000L * (ts.tv_sec - old_ts.tv_sec) + (ts.tv_nsec - old_ts.tv_nsec));
    old_ts = ts;
    if (diff > 0) {
      if (diff < best) {
        best = diff;
      }
      iters ++;
    }
    if (! (iters < 100)) {
      goto while_break;
    }
  }
  while_break: ;
  }
  assert(best > 0);
  return (1.0e-9 * (double )best);
}
}
void LCL_Initialise(void)
{
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  {
  change_list.prev = & change_list;
  change_list.next = change_list.prev;
  dispersion_notify_list.prev = & dispersion_notify_list;
  dispersion_notify_list.next = dispersion_notify_list.prev;
  drv_read_freq = (double (*)(void))((void *)0);
  drv_set_freq = (double (*)(double freq_ppm ))((void *)0);
  drv_accrue_offset = (void (*)(double offset , double corr_rate ))((void *)0);
  drv_offset_convert = (void (*)(struct timespec *raw , double *corr , double *err ))((void *)0);
  current_freq_ppm = 0.0;
  temp_comp_ppm = 0.0;
  precision_quantum = CNF_GetClockPrecision();
  if (precision_quantum <= 0.0) {
    precision_quantum = measure_clock_precision();
  }
  if (precision_quantum < 1.0) {
    tmp___1 = precision_quantum;
  } else {
    tmp___1 = 1.0;
  }
  if (1.0e-9 > tmp___1) {
    precision_quantum = 1.0e-9;
  } else {
    if (precision_quantum < 1.0) {
      tmp___0 = precision_quantum;
    } else {
      tmp___0 = 1.0;
    }
    precision_quantum = tmp___0;
  }
  tmp___2 = log(precision_quantum);
  tmp___3 = log(2.0);
  tmp___4 = round(tmp___2 / tmp___3);
  precision_log = (int )tmp___4;
  assert(precision_log >= -30);
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  max_freq_ppm = CNF_GetMaxDrift();
  if (max_freq_ppm < 500000.0) {
    tmp___7 = max_freq_ppm;
  } else {
    tmp___7 = 500000.0;
  }
  if (0.0 > tmp___7) {
    max_freq_ppm = 0.0;
  } else {
    if (max_freq_ppm < 500000.0) {
      tmp___6 = max_freq_ppm;
    } else {
      tmp___6 = 500000.0;
    }
    max_freq_ppm = tmp___6;
  }
  tmp___8 = CNF_GetMaxClockError();
  max_clock_error___0 = tmp___8 * 1e-6;
  return;
}
}
void LCL_Finalise(void)
{
  {
  if ((unsigned long )change_list.next != (unsigned long )(& change_list)) {
    assert(0);
  }
  if ((unsigned long )dispersion_notify_list.next != (unsigned long )(& dispersion_notify_list)) {
    assert(0);
  }
  return;
}
}
int LCL_GetSysPrecisionAsLog(void)
{
  {
  return (precision_log);
}
}
double LCL_GetSysPrecisionAsQuantum(void)
{
  {
  return (precision_quantum);
}
}
double LCL_GetMaxClockError(void)
{
  {
  return (max_clock_error___0);
}
}
void LCL_AddParameterChangeHandler(void (*handler)(struct timespec *raw , struct timespec *cooked ,
                                                   double dfreq , double doffset ,
                                                   LCL_ChangeType change_type , void *anything ) ,
                                   void *anything )
{
  ChangeListEntry *ptr ;
  ChangeListEntry *new_entry ;
  void *tmp ;
  {
  ptr = change_list.next;
  {
  while (1) {
    while_continue: ;
    if (! ((unsigned long )ptr != (unsigned long )(& change_list))) {
      goto while_break;
    }
    if (! ((unsigned long )ptr->handler != (unsigned long )handler)) {
      if (! ((unsigned long )ptr->anything != (unsigned long )anything)) {
        assert(0);
      }
    }
    ptr = ptr->next;
  }
  while_break: ;
  }
  tmp = Malloc(sizeof(ChangeListEntry ));
  new_entry = (ChangeListEntry *)tmp;
  new_entry->handler = handler;
  new_entry->anything = anything;
  new_entry->next = & change_list;
  new_entry->prev = change_list.prev;
  (change_list.prev)->next = new_entry;
  change_list.prev = new_entry;
  return;
}
}
void LCL_RemoveParameterChangeHandler(void (*handler)(struct timespec *raw , struct timespec *cooked ,
                                                      double dfreq , double doffset ,
                                                      LCL_ChangeType change_type ,
                                                      void *anything ) , void *anything )
{
  ChangeListEntry *ptr ;
  int ok ;
  {
  ptr = (ChangeListEntry *)((void *)0);
  ok = 0;
  ptr = change_list.next;
  {
  while (1) {
    while_continue: ;
    if (! ((unsigned long )ptr != (unsigned long )(& change_list))) {
      goto while_break;
    }
    if ((unsigned long )ptr->handler == (unsigned long )handler) {
      if ((unsigned long )ptr->anything == (unsigned long )anything) {
        ok = 1;
        goto while_break;
      }
    }
    ptr = ptr->next;
  }
  while_break: ;
  }
  assert(ok);
  (ptr->next)->prev = ptr->prev;
  (ptr->prev)->next = ptr->next;
  free((void *)ptr);
  return;
}
}
int LCL_IsFirstParameterChangeHandler(void (*handler)(struct timespec *raw , struct timespec *cooked ,
                                                      double dfreq , double doffset ,
                                                      LCL_ChangeType change_type ,
                                                      void *anything ) )
{
  {
  return ((unsigned long )(change_list.next)->handler == (unsigned long )handler);
}
}
static void invoke_parameter_change_handlers(struct timespec *raw , struct timespec *cooked ,
                                             double dfreq , double doffset , LCL_ChangeType change_type )
{
  ChangeListEntry *ptr ;
  {
  ptr = change_list.next;
  {
  while (1) {
    while_continue: ;
    if (! ((unsigned long )ptr != (unsigned long )(& change_list))) {
      goto while_break;
    }
    (*(ptr->handler))(raw, cooked, dfreq, doffset, change_type, ptr->anything);
    ptr = ptr->next;
  }
  while_break: ;
  }
  return;
}
}
void LCL_AddDispersionNotifyHandler(void (*handler)(double dispersion , void *anything ) ,
                                    void *anything )
{
  DispersionNotifyListEntry *ptr ;
  DispersionNotifyListEntry *new_entry ;
  void *tmp ;
  {
  ptr = dispersion_notify_list.next;
  {
  while (1) {
    while_continue: ;
    if (! ((unsigned long )ptr != (unsigned long )(& dispersion_notify_list))) {
      goto while_break;
    }
    if (! ((unsigned long )ptr->handler != (unsigned long )handler)) {
      if (! ((unsigned long )ptr->anything != (unsigned long )anything)) {
        assert(0);
      }
    }
    ptr = ptr->next;
  }
  while_break: ;
  }
  tmp = Malloc(sizeof(DispersionNotifyListEntry ));
  new_entry = (DispersionNotifyListEntry *)tmp;
  new_entry->handler = handler;
  new_entry->anything = anything;
  new_entry->next = & dispersion_notify_list;
  new_entry->prev = dispersion_notify_list.prev;
  (dispersion_notify_list.prev)->next = new_entry;
  dispersion_notify_list.prev = new_entry;
  return;
}
}
extern void LCL_RemoveDispersionNotifyHandler(void (*handler)(double dispersion ,
                                                              void *anything ) , void *anything )
{
  DispersionNotifyListEntry *ptr ;
  int ok ;
  {
  ptr = (DispersionNotifyListEntry *)((void *)0);
  ok = 0;
  ptr = dispersion_notify_list.next;
  {
  while (1) {
    while_continue: ;
    if (! ((unsigned long )ptr != (unsigned long )(& dispersion_notify_list))) {
      goto while_break;
    }
    if ((unsigned long )ptr->handler == (unsigned long )handler) {
      if ((unsigned long )ptr->anything == (unsigned long )anything) {
        ok = 1;
        goto while_break;
      }
    }
    ptr = ptr->next;
  }
  while_break: ;
  }
  assert(ok);
  (ptr->next)->prev = ptr->prev;
  (ptr->prev)->next = ptr->next;
  free((void *)ptr);
  return;
}
}
void LCL_ReadRawTime(struct timespec *ts )
{
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  {
  tmp___1 = clock_gettime(0, ts);
  if (tmp___1 < 0) {
    {
    while (1) {
      while_continue: ;
      tmp = __errno_location();
      tmp___0 = strerror(*tmp);
      LOG_Message((LOG_Severity )3, (char const *)"clock_gettime() failed : %s",
                  tmp___0);
      exit(1);
      goto while_break;
    }
    while_break: ;
    }
  }
  return;
}
}
void LCL_ReadCookedTime(struct timespec *result , double *err )
{
  struct timespec raw ;
  {
  LCL_ReadRawTime(& raw);
  LCL_CookTime(& raw, result, err);
  return;
}
}
void LCL_CookTime(struct timespec *raw , struct timespec *cooked , double *err )
{
  double correction ;
  {
  LCL_GetOffsetCorrection(raw, & correction, err);
  UTI_AddDoubleToTimespec((struct timespec const *)raw, correction, cooked);
  return;
}
}
void LCL_GetOffsetCorrection(struct timespec *raw , double *correction , double *err )
{
  {
  (*drv_offset_convert)(raw, correction, err);
  return;
}
}
double LCL_ReadAbsoluteFrequency(void)
{
  double freq___0 ;
  {
  freq___0 = current_freq_ppm;
  if (temp_comp_ppm != 0.0) {
    freq___0 = (freq___0 + temp_comp_ppm) / (1.0 - 1.0e-6 * temp_comp_ppm);
  }
  return (freq___0);
}
}
static double clamp_freq(double freq___0 )
{
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  {
  if (freq___0 <= max_freq_ppm) {
    if (freq___0 >= - max_freq_ppm) {
      return (freq___0);
    }
  }
  LOG_Message((LOG_Severity )1, (char const *)"Frequency %.1f ppm exceeds allowed maximum",
              freq___0);
  if (freq___0 < max_freq_ppm) {
    tmp___2 = freq___0;
  } else {
    tmp___2 = max_freq_ppm;
  }
  if (- max_freq_ppm > tmp___2) {
    tmp___1 = - max_freq_ppm;
  } else {
    if (freq___0 < max_freq_ppm) {
      tmp___0 = freq___0;
    } else {
      tmp___0 = max_freq_ppm;
    }
    tmp___1 = tmp___0;
  }
  return (tmp___1);
}
}
static int check_offset(struct timespec *now , double offset )
{
  int tmp ;
  {
  tmp = UTI_IsTimeOffsetSane((struct timespec const *)now, - offset);
  if (tmp) {
    return (1);
  }
  LOG_Message((LOG_Severity )1, (char const *)"Adjustment of %.1f seconds is invalid",
              - offset);
  return (0);
}
}
void LCL_SetAbsoluteFrequency(double afreq_ppm )
{
  struct timespec raw ;
  struct timespec cooked ;
  double dfreq ;
  {
  afreq_ppm = clamp_freq(afreq_ppm);
  if (temp_comp_ppm != 0.0) {
    afreq_ppm = afreq_ppm * (1.0 - 1.0e-6 * temp_comp_ppm) - temp_comp_ppm;
  }
  afreq_ppm = (*drv_set_freq)(afreq_ppm);
  dfreq = (afreq_ppm - current_freq_ppm) / (1.0e6 - current_freq_ppm);
  LCL_ReadRawTime(& raw);
  LCL_CookTime(& raw, & cooked, (double *)((void *)0));
  invoke_parameter_change_handlers(& raw, & cooked, dfreq, 0.0, (LCL_ChangeType )0);
  current_freq_ppm = afreq_ppm;
  return;
}
}
void LCL_AccumulateDeltaFrequency(double dfreq )
{
  struct timespec raw ;
  struct timespec cooked ;
  double old_freq_ppm ;
  {
  old_freq_ppm = current_freq_ppm;
  current_freq_ppm += dfreq * (1.0e6 - current_freq_ppm);
  current_freq_ppm = clamp_freq(current_freq_ppm);
  current_freq_ppm = (*drv_set_freq)(current_freq_ppm);
  dfreq = (current_freq_ppm - old_freq_ppm) / (1.0e6 - old_freq_ppm);
  LCL_ReadRawTime(& raw);
  LCL_CookTime(& raw, & cooked, (double *)((void *)0));
  invoke_parameter_change_handlers(& raw, & cooked, dfreq, 0.0, (LCL_ChangeType )0);
  return;
}
}
int LCL_AccumulateOffset(double offset , double corr_rate )
{
  struct timespec raw ;
  struct timespec cooked ;
  int tmp ;
  {
  LCL_ReadRawTime(& raw);
  LCL_CookTime(& raw, & cooked, (double *)((void *)0));
  tmp = check_offset(& cooked, offset);
  if (! tmp) {
    return (0);
  }
  (*drv_accrue_offset)(offset, corr_rate);
  invoke_parameter_change_handlers(& raw, & cooked, 0.0, offset, (LCL_ChangeType )0);
  return (1);
}
}
int LCL_ApplyStepOffset(double offset )
{
  struct timespec raw ;
  struct timespec cooked ;
  int tmp ;
  int tmp___0 ;
  {
  LCL_ReadRawTime(& raw);
  LCL_CookTime(& raw, & cooked, (double *)((void *)0));
  tmp = check_offset(& raw, offset);
  if (! tmp) {
    return (0);
  }
  tmp___0 = (*drv_apply_step_offset)(offset);
  if (! tmp___0) {
    LOG_Message((LOG_Severity )2, (char const *)"Could not step system clock");
    return (0);
  }
  SMT_Reset(& cooked);
  invoke_parameter_change_handlers(& raw, & cooked, 0.0, offset, (LCL_ChangeType )1);
  return (1);
}
}
void LCL_NotifyExternalTimeStep(struct timespec *raw , struct timespec *cooked , double offset ,
                                double dispersion )
{
  {
  invoke_parameter_change_handlers(raw, cooked, 0.0, offset, (LCL_ChangeType )2);
  lcl_InvokeDispersionNotifyHandlers(dispersion);
  return;
}
}
void LCL_NotifyLeap(int leap )
{
  struct timespec raw ;
  struct timespec cooked ;
  {
  LCL_ReadRawTime(& raw);
  LCL_CookTime(& raw, & cooked, (double *)((void *)0));
  SMT_Leap(& cooked, leap);
  invoke_parameter_change_handlers(& raw, & cooked, 0.0, (double )(- leap), (LCL_ChangeType )1);
  return;
}
}
int LCL_AccumulateFrequencyAndOffset(double dfreq , double doffset , double corr_rate )
{
  struct timespec raw ;
  struct timespec cooked ;
  double old_freq_ppm ;
  int tmp ;
  {
  LCL_ReadRawTime(& raw);
  LCL_CookTime(& raw, & cooked, (double *)((void *)0));
  tmp = check_offset(& cooked, doffset);
  if (! tmp) {
    return (0);
  }
  old_freq_ppm = current_freq_ppm;
  current_freq_ppm += dfreq * (1.0e6 - current_freq_ppm);
  current_freq_ppm = clamp_freq(current_freq_ppm);
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  current_freq_ppm = (*drv_set_freq)(current_freq_ppm);
  dfreq = (current_freq_ppm - old_freq_ppm) / (1.0e6 - old_freq_ppm);
  (*drv_accrue_offset)(doffset, corr_rate);
  invoke_parameter_change_handlers(& raw, & cooked, dfreq, doffset, (LCL_ChangeType )0);
  return (1);
}
}
void lcl_InvokeDispersionNotifyHandlers(double dispersion )
{
  DispersionNotifyListEntry *ptr ;
  {
  ptr = dispersion_notify_list.next;
  {
  while (1) {
    while_continue: ;
    if (! ((unsigned long )ptr != (unsigned long )(& dispersion_notify_list))) {
      goto while_break;
    }
    (*(ptr->handler))(dispersion, ptr->anything);
    ptr = ptr->next;
  }
  while_break: ;
  }
  return;
}
}
void lcl_RegisterSystemDrivers(double (*read_freq)(void) , double (*set_freq)(double freq_ppm ) ,
                               void (*accrue_offset___1)(double offset , double corr_rate ) ,
                               int (*apply_step_offset___2)(double offset ) , void (*offset_convert___1)(struct timespec *raw ,
                                                                                                         double *corr ,
                                                                                                         double *err ) ,
                               void (*set_leap___0)(int leap , int tai_offset ) ,
                               void (*set_sync_status___1)(int synchronised , double est_error ,
                                                           double max_error ) )
{
  {
  drv_read_freq = read_freq;
  drv_set_freq = set_freq;
  drv_accrue_offset = accrue_offset___1;
  drv_apply_step_offset = apply_step_offset___2;
  drv_offset_convert = offset_convert___1;
  drv_set_leap = set_leap___0;
  drv_set_sync_status = set_sync_status___1;
  current_freq_ppm = (*drv_read_freq)();
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  return;
}
}
int LCL_MakeStep(void)
{
  struct timespec raw ;
  double correction ;
  int tmp ;
  int tmp___0 ;
  {
  LCL_ReadRawTime(& raw);
  LCL_GetOffsetCorrection(& raw, & correction, (double *)((void *)0));
  tmp = check_offset(& raw, - correction);
  if (! tmp) {
    return (0);
  }
  LCL_AccumulateOffset(correction, 0.0);
  tmp___0 = LCL_ApplyStepOffset(- correction);
  if (! tmp___0) {
    return (0);
  }
  LOG_Message((LOG_Severity )1, (char const *)"System clock was stepped by %.6f seconds",
              correction);
  return (1);
}
}
void LCL_CancelOffsetCorrection(void)
{
  struct timespec raw ;
  double correction ;
  {
  LCL_ReadRawTime(& raw);
  LCL_GetOffsetCorrection(& raw, & correction, (double *)((void *)0));
  LCL_AccumulateOffset(correction, 0.0);
  return;
}
}
int LCL_CanSystemLeap(void)
{
  int tmp ;
  {
  if (drv_set_leap) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
void LCL_SetSystemLeap(int leap , int tai_offset )
{
  {
  if (drv_set_leap) {
    (*drv_set_leap)(leap, tai_offset);
  }
  return;
}
}
double LCL_SetTempComp(double comp )
{
  double uncomp_freq_ppm ;
  {
  if (temp_comp_ppm == comp) {
    return (comp);
  }
  current_freq_ppm = (current_freq_ppm + temp_comp_ppm) / (1.0 - 1.0e-6 * temp_comp_ppm);
  uncomp_freq_ppm = current_freq_ppm;
  current_freq_ppm = current_freq_ppm * (1.0 - 1.0e-6 * comp) - comp;
  current_freq_ppm = (*drv_set_freq)(current_freq_ppm);
  temp_comp_ppm = (uncomp_freq_ppm - current_freq_ppm) / (1.0e-6 * uncomp_freq_ppm + 1.0);
  return (temp_comp_ppm);
}
}
void LCL_SetSyncStatus(int synchronised , double est_error , double max_error )
{
  {
  if (drv_set_sync_status) {
    (*drv_set_sync_status)(synchronised, est_error, max_error);
  }
  return;
}
}
extern void closelog(void) ;
extern void openlog(char const *__ident , int __option , int __facility ) ;
extern int ( __attribute__((__leaf__)) setlogmask)(int __mask ) __attribute__((__nothrow__)) ;
__inline extern void ( __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) syslog)(int __pri , char const *__fmt , ...) ;
__inline extern void ( __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) vsyslog)(int __pri , char const *__fmt , __gnuc_va_list __ap ) ;
extern void ( __syslog_chk)(int __pri , int __flag , char const *__fmt
                                                    , ...) ;
__inline extern void ( __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) syslog)(int __pri , char const *__fmt , ...)
{
  {
  __syslog_chk(__pri, 1, __fmt, __builtin_va_arg_pack());
  return;
}
}
extern void ( __vsyslog_chk)(int __pri , int __flag , char const *__fmt ,
                                                     __gnuc_va_list __ap ) ;
__inline extern void ( __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) vsyslog)(int __pri , char const *__fmt , __gnuc_va_list __ap )
{
  {
  __vsyslog_chk(__pri, 1, __fmt, __ap);
  return;
}
}
LOG_Severity log_min_severity = (LOG_Severity )0;
static int initialised = 0;
static FILE *file_log = (FILE *)((void *)0);
static int system_log = 0;
static int parent_fd = 0;
static int n_filelogs = 0;
static struct LogFile logfiles[6] ;
static char *debug_prefix ;
void LOG_Initialise(void)
{
  {
  debug_prefix = Strdup((char const *)"");
  initialised = 1;
  LOG_OpenFileLog((char const *)((void *)0));
  return;
}
}
void LOG_Finalise(void)
{
  {
  if (system_log) {
    closelog();
  }
  if (file_log) {
    fclose(file_log);
  }
  LOG_CycleLogFiles();
  free((void *)debug_prefix);
  initialised = 0;
  return;
}
}
static void log_message(int fatal , LOG_Severity severity , char const *message )
{
  int priority ;
  char *tmp ;
  char *tmp___0 ;
  {
  if (system_log) {
    {
    if ((int )severity == -1) {
      goto case_neg_1;
    }
    if ((int )severity == 0) {
      goto case_0;
    }
    if ((int )severity == 1) {
      goto case_1;
    }
    if ((int )severity == 2) {
      goto case_2;
    }
    if ((int )severity == 3) {
      goto case_3;
    }
    goto switch_default;
    case_neg_1:
    priority = 7;
    goto switch_break;
    case_0:
    priority = 6;
    goto switch_break;
    case_1:
    priority = 4;
    goto switch_break;
    case_2:
    priority = 3;
    goto switch_break;
    case_3:
    priority = 2;
    goto switch_break;
    switch_default:
    assert(0);
    switch_break: ;
    }
    if (fatal) {
      tmp = "Fatal error : %s";
    } else {
      tmp = "%s";
    }
    syslog(priority, (char const *)tmp, message);
  } else
  if (file_log) {
    if (fatal) {
      tmp___0 = "Fatal error : %s\n";
    } else {
      tmp___0 = "%s\n";
    }
    fprintf(file_log, (char const *)tmp___0, message);
  }
  return;
}
}
void ( LOG_Message)(LOG_Severity severity , char const *format
                                            , ...)
{
  char buf[2048] ;
  va_list other_args ;
  time_t t ;
  struct tm *tm ;
  size_t tmp ;
  ssize_t tmp___0 ;
  {
  assert(initialised);
  if (! system_log) {
    if (file_log) {
      if ((int )severity >= (int )log_min_severity) {
        time(& t);
        tm = gmtime((time_t const *)(& t));
        if (tm) {
          strftime((char * __restrict )(buf), sizeof(buf), (char const * __restrict )"%Y-%m-%dT%H:%M:%SZ",
                   (struct tm const * __restrict )tm);
          fprintf(file_log, (char const *)"%s ", buf);
        }
      }
    }
  }
  __builtin_va_start(other_args, format);
  vsnprintf(buf, sizeof(buf), format, other_args);
  __builtin_va_end(other_args);
  {
  if ((int )severity == 2) {
    goto case_2;
  }
  if ((int )severity == 1) {
    goto case_2;
  }
  if ((int )severity == 0) {
    goto case_2;
  }
  if ((int )severity == -1) {
    goto case_2;
  }
  if ((int )severity == 3) {
    goto case_3;
  }
  goto switch_default;
  case_2:
  case_1:
  case_0:
  case_neg_1:
  if ((int )severity >= (int )log_min_severity) {
    log_message(0, severity, (char const *)(buf));
  }
  goto switch_break;
  case_3:
  if ((int )severity >= (int )log_min_severity) {
    log_message(1, severity, (char const *)(buf));
  }
  if (parent_fd > 0) {
    tmp = strlen((char const *)(buf));
    tmp___0 = write(parent_fd, (void const *)(buf), tmp + 1UL);
  } else
  if (system_log) {
    if (parent_fd == 0) {
      system_log = 0;
      log_message(1, severity, (char const *)(buf));
    }
  }
  exit(1);
  goto switch_break;
  switch_default:
  assert(0);
  switch_break: ;
  }
  return;
}
}
void LOG_OpenFileLog(char const *log_file )
{
  FILE *f ;
  {
  if (log_file) {
    f = UTI_OpenFile((char const *)((void *)0), log_file, (char const *)((void *)0),
                     (char )'A', (mode_t )0640);
  } else {
    f = stderr;
  }
  setvbuf((FILE * __restrict )f, (char * __restrict )((void *)0), 1, (size_t )8192);
  if (file_log) {
    if ((unsigned long )file_log != (unsigned long )stderr) {
      fclose(file_log);
    }
  }
  file_log = f;
  return;
}
}
void LOG_OpenSystemLog(void)
{
  {
  system_log = 1;
  openlog((char const *)"chronyd", 0x01, 3 << 3);
  return;
}
}
void LOG_SetMinSeverity(LOG_Severity severity )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  if ((int )severity < 3) {
    tmp___1 = (int )severity;
  } else {
    tmp___1 = 3;
  }
  if (0 > tmp___1) {
    log_min_severity = (LOG_Severity )0;
  } else {
    if ((int )severity < 3) {
      tmp___0 = (int )severity;
    } else {
      tmp___0 = 3;
    }
    log_min_severity = (LOG_Severity )tmp___0;
  }
  return;
}
}
LOG_Severity LOG_GetMinSeverity(void)
{
  {
  return (log_min_severity);
}
}
void LOG_SetDebugPrefix(char const *prefix )
{
  {
  free((void *)debug_prefix);
  debug_prefix = Strdup(prefix);
  return;
}
}
void LOG_SetParentFd(int fd___0 )
{
  {
  parent_fd = fd___0;
  if ((unsigned long )file_log == (unsigned long )stderr) {
    file_log = (FILE *)((void *)0);
  }
  return;
}
}
void LOG_CloseParentFd(void)
{
  {
  if (parent_fd > 0) {
    close(parent_fd);
  }
  parent_fd = -1;
  return;
}
}
LOG_FileID LOG_FileOpen(char const *name , char const *banner )
{
  int tmp ;
  {
  if (n_filelogs >= 6) {
    assert(0);
    return (-1);
  }
  logfiles[n_filelogs].name = name;
  logfiles[n_filelogs].banner = banner;
  logfiles[n_filelogs].file = (FILE *)((void *)0);
  logfiles[n_filelogs].writes = 0UL;
  tmp = n_filelogs;
  n_filelogs ++;
  return (tmp);
}
}
void ( LOG_FileWrite)(LOG_FileID id , char const *format
                                              , ...)
{
  va_list other_args ;
  int banner ;
  char *logdir___0 ;
  char *tmp ;
  char bannerline[256] ;
  int i ;
  int bannerlen ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  {
  if (id < 0) {
    return;
  } else
  if (id >= n_filelogs) {
    return;
  } else
  if (! logfiles[id].name) {
    return;
  }
  if (! logfiles[id].file) {
    tmp = CNF_GetLogDir();
    logdir___0 = tmp;
    if (! logdir___0) {
      LOG_Message((LOG_Severity )1, (char const *)"logdir not specified");
      logfiles[id].name = (char const *)((void *)0);
      return;
    }
    logfiles[id].file = UTI_OpenFile((char const *)logdir___0, logfiles[id].name,
                                     (char const *)".log", (char )'a', (mode_t )0644);
    if (! logfiles[id].file) {
      logfiles[id].name = (char const *)((void *)0);
      return;
    }
  }
  banner = CNF_GetLogBanner();
  if (banner) {
    tmp___3 = logfiles[id].writes;
    (logfiles[id].writes) ++;
    if (tmp___3 % (unsigned long )banner == 0UL) {
      tmp___2 = strlen(logfiles[id].banner);
      if (tmp___2 < sizeof(bannerline) - 1UL) {
        tmp___1 = strlen(logfiles[id].banner);
        bannerlen = (int )tmp___1;
      } else {
        bannerlen = (int )(sizeof(bannerline) - 1UL);
      }
      i = 0;
      {
      while (1) {
        while_continue: ;
        if (! (i < bannerlen)) {
          goto while_break;
        }
        bannerline[i] = (char )'=';
        i ++;
      }
      while_break: ;
      }
      bannerline[i] = (char )'\000';
      fprintf(logfiles[id].file, (char const *)"%s\n", bannerline);
      fprintf(logfiles[id].file, (char const *)"%s\n", logfiles[id].banner);
      fprintf(logfiles[id].file, (char const *)"%s\n", bannerline);
    }
  }
  __builtin_va_start(other_args, format);
  vfprintf(logfiles[id].file, format, other_args);
  __builtin_va_end(other_args);
  fprintf(logfiles[id].file, (char const *)"\n");
  fflush(logfiles[id].file);
  return;
}
}
void LOG_CycleLogFiles(void)
{
  LOG_FileID i ;
  {
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < n_filelogs)) {
      goto while_break;
    }
    if (logfiles[i].file) {
      fclose(logfiles[i].file);
    }
    logfiles[i].file = (FILE *)((void *)0);
    logfiles[i].writes = 0UL;
    i ++;
  }
  while_break: ;
  }
  return;
}
}
void MAI_CleanupAndExit(void) ;
void SCH_Initialise(void) ;
void SCH_Finalise(void) ;
void SCH_AddFileHandler(int fd___0 , int events , void (*handler)(int fd , int event ,
                                                                  SCH_ArbitraryArgument ) ,
                        SCH_ArbitraryArgument arg ) ;
void SCH_RemoveFileHandler(int fd___0 ) ;
void SCH_SetFileHandlerEvent(int fd___0 , int event , int enable ) ;
void SCH_GetLastEventTime(struct timespec *cooked , double *err , struct timespec *raw ) ;
double SCH_GetLastEventMonoTime(void) ;
SCH_TimeoutID SCH_AddTimeout(struct timespec *ts , void (*handler)(SCH_ArbitraryArgument ) ,
                             SCH_ArbitraryArgument arg ) ;
SCH_TimeoutID SCH_AddTimeoutByDelay(double delay , void (*handler)(SCH_ArbitraryArgument ) ,
                                    SCH_ArbitraryArgument arg ) ;
SCH_TimeoutID SCH_AddTimeoutInClass(double min_delay , double separation , double randomness ,
                                    SCH_TimeoutClass class , void (*handler)(SCH_ArbitraryArgument ) ,
                                    SCH_ArbitraryArgument arg ) ;
void SCH_RemoveTimeout(SCH_TimeoutID id ) ;
void SCH_MainLoop(void) ;
void SCH_QuitProgram(void) ;
void SYS_Initialise(int clock_control ) ;
void SYS_Finalise(void) ;
void SYS_DropRoot(uid_t uid , gid_t gid , SYS_ProcessContext context ) ;
void SYS_EnableSystemCallFilter(int level , SYS_ProcessContext context ) ;
void SYS_SetScheduler(int SchedPriority ) ;
void SYS_LockMemory(void) ;
void NIO_Initialise(void) ;
void NIO_Finalise(void) ;
int NIO_OpenClientSocket(NTP_Remote_Address *remote_addr ) ;
int NIO_OpenServerSocket(NTP_Remote_Address *remote_addr ) ;
void NIO_CloseClientSocket(int sock_fd ) ;
void NIO_CloseServerSocket(int sock_fd ) ;
int NIO_IsServerSocket(int sock_fd ) ;
int NIO_IsServerSocketOpen(void) ;
int NIO_IsServerConnectable(NTP_Remote_Address *remote_addr ) ;
int NIO_UnwrapMessage(SCK_Message *message , int sock_fd ) ;
int NIO_SendPacket(NTP_Packet *packet , NTP_Remote_Address *remote_addr , NTP_Local_Address *local_addr ,
                   int length , int process_tx ) ;
void NSD_Initialise(void) ;
void NSD_Finalise(void) ;
int NSD_SignAndSendPacket(uint32_t key_id , NTP_Packet *packet , NTP_PacketInfo *info ,
                          NTP_Remote_Address *remote_addr , NTP_Local_Address *local_addr ) ;
void NKS_PreInitialise(uid_t uid , gid_t gid , int scfilter_level ) ;
void NKS_Initialise(void) ;
void NKS_Finalise(void) ;
void NKS_DumpKeys(void) ;
void NKS_ReloadKeys(void) ;
extern int NKS_GenerateCookie(NKE_Context *context , NKE_Cookie *cookie ) ;
extern int NKS_DecodeCookie(NKE_Cookie *cookie , NKE_Context *context ) ;
void NNS_Initialise(void) ;
void NNS_Finalise(void) ;
int NNS_CheckRequestAuth(NTP_Packet *packet , NTP_PacketInfo *info , uint32_t *kod ) ;
int NNS_GenerateResponseAuth(NTP_Packet *request , NTP_PacketInfo *req_info , NTP_Packet *response ,
                             NTP_PacketInfo *res_info , uint32_t kod ) ;
void KEY_Initialise(void) ;
void KEY_Finalise(void) ;
void KEY_Reload(void) ;
int KEY_KeyKnown(uint32_t key_id ) ;
int KEY_GetAuthLength(uint32_t key_id ) ;
int KEY_CheckKeyLength(uint32_t key_id ) ;
int KEY_GetKeyInfo(uint32_t key_id , int *type , int *bits ) ;
int KEY_GenerateAuth(uint32_t key_id , void const *data , int data_len , unsigned char *auth ,
                     int auth_len ) ;
int KEY_CheckAuth(uint32_t key_id , void const *data , int data_len , unsigned char const *auth ,
                  int auth_len , int trunc_len ) ;
void MNL_Initialise(void) ;
void MNL_Finalise(void) ;
int MNL_AcceptTimestamp(struct timespec *ts , double *reg_offset , double *dfreq_ppm ,
                        double *new_afreq_ppm ) ;
void MNL_Enable(void) ;
void MNL_Disable(void) ;
void MNL_Reset(void) ;
int MNL_IsEnabled(void) ;
void MNL_ReportSamples(RPT_ManualSamplesReport *report , int max , int *n ) ;
int MNL_DeleteSample(int index___0 ) ;
void RTC_Initialise(int initial_set ) ;
void RTC_Finalise(void) ;
void RTC_TimeInit(void (*after_hook)(void * ) , void *anything ) ;
void RTC_StartMeasurements(void) ;
int RTC_GetReport(RPT_RTC_Report *report ) ;
int RTC_WriteParameters(void) ;
int RTC_Trim(void) ;
void CLG_Initialise(void) ;
void CLG_Finalise(void) ;
int CLG_GetClientIndex(IPAddr *client ) ;
int CLG_LogServiceAccess(CLG_Service service , IPAddr *client , struct timespec *now ) ;
int CLG_LimitServiceRate(CLG_Service service , int index___0 ) ;
void CLG_LogAuthNtpRequest(void) ;
int CLG_GetNtpMinPoll(void) ;
void CLG_SaveNtpTimestamps(NTP_int64 *rx_ts , struct timespec *tx_ts ) ;
void CLG_UndoNtpTxTimestampSlew(NTP_int64 *rx_ts , struct timespec *tx_ts ) ;
void CLG_UpdateNtpTxTimestamp(NTP_int64 *rx_ts , struct timespec *tx_ts ) ;
int CLG_GetNtpTxTimestamp(NTP_int64 *rx_ts , struct timespec *tx_ts ) ;
void CLG_DisableNtpTimestamps(NTP_int64 *rx_ts ) ;
int CLG_GetNumberOfIndices(void) ;
int CLG_GetClientAccessReportByIndex(int index___0 , int reset , uint32_t min_hits ,
                                     RPT_ClientAccessByIndex_Report *report , struct timespec *now ) ;
void CLG_GetServerStatsReport(RPT_ServerStatsReport *report ) ;
void TMC_Initialise(void) ;
void TMC_Finalise(void) ;
static int initialised___0 = 0;
static int exit_status = 0;
static int reload = 0;
static REF_Mode ref_mode = (REF_Mode )0;
static void do_platform_checks(void)
{
  struct timespec ts ;
  int tmp ;
  {
  assert(sizeof(int ) >= 4UL);
  assert(1);
  assert(1);
  ts.tv_sec = (__time_t )-1;
  ts.tv_nsec = (__syscall_slong_t )-1;
  if (ts.tv_sec < 0L) {
    if (ts.tv_nsec < 0L) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  assert(tmp);
  return;
}
}
static void delete_pidfile(void)
{
  char const *pidfile___0 ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  tmp = CNF_GetPidFile();
  pidfile___0 = (char const *)tmp;
  if (! pidfile___0) {
    return;
  }
  tmp___0 = UTI_RemoveFile((char const *)((void *)0), pidfile___0, (char const *)((void *)0));
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  return;
}
}
void MAI_CleanupAndExit(void)
{
  {
  if (! initialised___0) {
    exit(exit_status);
  }
  LCL_CancelOffsetCorrection();
  SRC_DumpSources();
  REF_SetMode((REF_Mode )4);
  SMT_Finalise();
  TMC_Finalise();
  MNL_Finalise();
  CLG_Finalise();
  NKS_Finalise();
  NNS_Finalise();
  NSD_Finalise();
  NSR_Finalise();
  SST_Finalise();
  NCR_Finalise();
  NIO_Finalise();
  CAM_Finalise();
  KEY_Finalise();
  RCL_Finalise();
  SRC_Finalise();
  REF_Finalise();
  RTC_Finalise();
  SYS_Finalise();
  SCK_Finalise();
  SCH_Finalise();
  LCL_Finalise();
  delete_pidfile();
  CNF_Finalise();
  HSH_Finalise();
  LOG_Finalise();
  UTI_ResetGetRandomFunctions();
  exit(exit_status);
}
}
static void signal_cleanup(int x )
{
  {
  SCH_QuitProgram();
  return;
}
}
static void quit_timeout(void *arg )
{
  int tmp ;
  {
  tmp = REF_GetOurStratum();
  exit_status = tmp >= 16;
  SCH_QuitProgram();
  return;
}
}
static void ntp_source_resolving_end(void)
{
  int tmp ;
  {
  NSR_SetSourceResolvingEndHandler((void (*)(void))((void *)0));
  if (reload) {
    SRC_ReloadSources();
  }
  SRC_RemoveDumpFiles();
  RTC_StartMeasurements();
  RCL_StartRefclocks();
  NSR_StartSources();
  NSR_AutoStartSources();
  if ((unsigned int )ref_mode != 0U) {
    tmp = SRC_ActiveSources();
    if (! tmp) {
      REF_SetUnsynchronised();
    }
  }
  return;
}
}
static void post_init_ntp_hook(void *anything )
{
  {
  if ((unsigned int )ref_mode == 1U) {
    NSR_RemoveAllSources();
    ref_mode = (REF_Mode )0;
    REF_SetMode(ref_mode);
  }
  LOG_CloseParentFd();
  CNF_AddSources();
  CNF_AddBroadcasts();
  NSR_SetSourceResolvingEndHandler(& ntp_source_resolving_end);
  NSR_ResolveSources();
  return;
}
}
static void reference_mode_end(int result )
{
  {
  {
  if ((unsigned int )ref_mode == 3U) {
    goto case_3;
  }
  if ((unsigned int )ref_mode == 2U) {
    goto case_3;
  }
  if ((unsigned int )ref_mode == 0U) {
    goto case_3;
  }
  if ((unsigned int )ref_mode == 1U) {
    goto case_1;
  }
  goto switch_default;
  case_3:
  case_2:
  case_0:
  exit_status = ! result;
  SCH_QuitProgram();
  goto switch_break;
  case_1:
  SCH_AddTimeoutByDelay(2.0, & post_init_ntp_hook, (void *)0);
  goto switch_break;
  switch_default:
  assert(0);
  switch_break: ;
  }
  return;
}
}
static void post_init_rtc_hook(void *anything )
{
  REF_Mode tmp ;
  int tmp___0 ;
  {
  tmp___0 = CNF_GetInitSources();
  if (tmp___0 > 0) {
    CNF_AddInitSources();
    NSR_StartSources();
    tmp = REF_GetMode();
    assert((unsigned int )tmp != 0U);
  } else {
    post_init_ntp_hook((void *)0);
  }
  return;
}
}
static void check_pidfile(void)
{
  char const *pidfile___0 ;
  char *tmp ;
  FILE *in ;
  int pid ;
  int count ;
  __pid_t tmp___0 ;
  {
  tmp = CNF_GetPidFile();
  pidfile___0 = (char const *)tmp;
  if (! pidfile___0) {
    return;
  }
  in = UTI_OpenFile((char const *)((void *)0), pidfile___0, (char const *)((void *)0),
                    (char )'r', (mode_t )0);
  if (! in) {
    return;
  }
  count = fscanf(in, (char const *)"%d", & pid);
  fclose(in);
  if (count != 1) {
    return;
  }
  tmp___0 = getsid(pid);
  if (tmp___0 < 0) {
    return;
  }
  {
  while (1) {
    while_continue: ;
    LOG_Message((LOG_Severity )3, (char const *)"Another chronyd may already be running (pid=%d), check %s",
                pid, pidfile___0);
    exit(1);
    goto while_break;
  }
  while_break: ;
  }
  return;
}
}
static void write_pidfile(void)
{
  char const *pidfile___0 ;
  char *tmp ;
  FILE *out ;
  __pid_t tmp___0 ;
  {
  tmp = CNF_GetPidFile();
  pidfile___0 = (char const *)tmp;
  if (! pidfile___0) {
    return;
  }
  out = UTI_OpenFile((char const *)((void *)0), pidfile___0, (char const *)((void *)0),
                     (char )'W', (mode_t )0644);
  tmp___0 = getpid();
  fprintf(out, (char const *)"%d\n", tmp___0);
  fclose(out);
  return;
}
}
static void go_daemon(void)
{
  int pid ;
  int fd___0 ;
  int pipefd[2] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char message[1024] ;
  int r ;
  ssize_t tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  {
  tmp___1 = pipe((int *)(pipefd));
  if (tmp___1) {
    {
    while (1) {
      while_continue: ;
      tmp = __errno_location();
      tmp___0 = strerror(*tmp);
      LOG_Message((LOG_Severity )3, (char const *)"pipe() failed : %s", tmp___0);
      exit(1);
      goto while_break;
    }
    while_break: ;
    }
  }
  pid = fork();
  if (pid < 0) {
    {
    while (1) {
      while_continue___0: ;
      tmp___2 = __errno_location();
      tmp___3 = strerror(*tmp___2);
      LOG_Message((LOG_Severity )3, (char const *)"fork() failed : %s", tmp___3);
      exit(1);
      goto while_break___0;
    }
    while_break___0: ;
    }
  } else
  if (pid > 0) {
    close(pipefd[1]);
    tmp___4 = read(pipefd[0], (void *)(message), sizeof(message));
    r = (int )tmp___4;
    if (r) {
      if (r > 0) {
        message[sizeof(message) - 1UL] = (char )'\000';
        fprintf(stderr, (char const *)"%s\n", message);
      }
      exit(1);
    } else {
      exit(0);
    }
  } else {
    close(pipefd[0]);
    setsid();
    pid = fork();
    if (pid < 0) {
      {
      while (1) {
        while_continue___1: ;
        tmp___5 = __errno_location();
        tmp___6 = strerror(*tmp___5);
        LOG_Message((LOG_Severity )3, (char const *)"fork() failed : %s", tmp___6);
        exit(1);
        goto while_break___1;
      }
      while_break___1: ;
      }
    } else
    if (pid > 0) {
      exit(0);
    } else {
      tmp___9 = chdir((char const *)"/");
      if (tmp___9 < 0) {
        {
        while (1) {
          while_continue___2: ;
          tmp___7 = __errno_location();
          tmp___8 = strerror(*tmp___7);
          LOG_Message((LOG_Severity )3, (char const *)"chdir() failed : %s", tmp___8);
          exit(1);
          goto while_break___2;
        }
        while_break___2: ;
        }
      }
      fd___0 = 0;
      {
      while (1) {
        while_continue___3: ;
        if (! (fd___0 < 1024)) {
          goto while_break___3;
        }
        if (fd___0 != pipefd[1]) {
          close(fd___0);
        }
        fd___0 ++;
      }
      while_break___3: ;
      }
      LOG_SetParentFd(pipefd[1]);
      tmp___10 = __errno_location();
      *tmp___10 = 0;
      tmp___13 = open((char const *)"/dev/null", 00);
      if (tmp___13 != 0) {
        goto _L;
      } else {
        tmp___14 = open((char const *)"/dev/null", 01);
        if (tmp___14 != 1) {
          goto _L;
        } else {
          tmp___15 = open((char const *)"/dev/null", 02);
          if (tmp___15 != 2) {
            _L:
            {
            while (1) {
              while_continue___4: ;
              tmp___11 = __errno_location();
              tmp___12 = strerror(*tmp___11);
              LOG_Message((LOG_Severity )3, (char const *)"Could not open %s : %s",
                          "/dev/null", tmp___12);
              exit(1);
              goto while_break___4;
            }
            while_break___4: ;
            }
          }
        }
      }
    }
  }
  return;
}
}
static void print_help(char const *progname )
{
  {
  printf((char const *)"Usage: %s [OPTION]... [DIRECTIVE]...\n\nOptions:\n  -4\t\tUse IPv4 addresses only\n  -6\t\tUse IPv6 addresses only\n  -f FILE\tSpecify configuration file (%s)\n  -n\t\tDon\'t run as daemon\n  -d\t\tDon\'t run as daemon and log to stderr\n  -l FILE\tLog to file\n  -L LEVEL\tSet logging threshold (0)\n  -p\t\tPrint configuration and exit\n  -q\t\tSet clock and exit\n  -Q\t\tLog offset and exit\n  -r\t\tReload dump files\n  -R\t\tAdapt configuration for restart\n  -s\t\tSet clock from RTC\n  -t SECONDS\tExit after elapsed time\n  -u USER\tSpecify user (%s)\n  -U\t\tDon\'t check for root\n  -F LEVEL\tSet system call filter level (0)\n  -P PRIORITY\tSet process priority (0)\n  -m\t\tLock memory\n  -x\t\tDon\'t control clock\n  -v, --version\tPrint version and exit\n  -h, --help\tPrint usage and exit\n",
         progname, "/etc/chrony.conf", "root");
  return;
}
}
static void print_version(void)
{
  {
  printf((char const *)"chronyd (chrony) version %s (%s)\n", "4.2", "+CMDMON +NTP +REFCLOCK +RTC -PRIVDROP -SCFILTER -SIGND +ASYNCDNS -NTS -SECHASH +IPV6 -DEBUG");
  return;
}
}
static int parse_int_arg(char const *arg )
{
  int i ;
  int tmp ;
  {
  tmp = sscanf(arg, (char const *)"%d", & i);
  if (tmp != 1) {
    {
    while (1) {
      while_continue: ;
      LOG_Message((LOG_Severity )3, (char const *)"Invalid argument %s", arg);
      exit(1);
      goto while_break;
    }
    while_break: ;
    }
  }
  return (i);
}
}
int main(int argc , char **argv )
{
  char const *conf_file ;
  char const *progname ;
  char *user___0 ;
  char *log_file ;
  struct passwd *pw ;
  int opt ;
  int debug ;
  int nofork ;
  int address_family___0 ;
  int do_init_rtc ;
  int restarted___0 ;
  int client_only ;
  int timeout ;
  int scfilter_level ;
  int lock_memory___0 ;
  int sched_priority___0 ;
  int clock_control ;
  int system_log___0 ;
  int log_severity ;
  int user_check ;
  int config_args ;
  int print_config___0 ;
  int tmp ;
  int tmp___0 ;
  __uid_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  __uid_t tmp___4 ;
  __uid_t tmp___5 ;
  int tmp___6 ;
  {
  conf_file = (char const *)"/etc/chrony.conf";
  progname = (char const *)*(argv + 0);
  user___0 = (char *)((void *)0);
  log_file = (char *)((void *)0);
  debug = 0;
  nofork = 0;
  address_family___0 = 0;
  do_init_rtc = 0;
  restarted___0 = 0;
  client_only = 0;
  timeout = -1;
  scfilter_level = 0;
  lock_memory___0 = 0;
  sched_priority___0 = 0;
  clock_control = 1;
  system_log___0 = 1;
  log_severity = 0;
  user_check = 1;
  config_args = 0;
  print_config___0 = 0;
  do_platform_checks();
  LOG_Initialise();
  optind = 1;
  {
  while (1) {
    while_continue: ;
    if (! (optind < argc)) {
      goto while_break;
    }
    tmp___0 = strcmp((char const *)"--help", (char const *)*(argv + optind));
    if (tmp___0) {
      tmp = strcmp((char const *)"--version", (char const *)*(argv + optind));
      if (! tmp) {
        print_version();
        return (0);
      }
    } else {
      print_help(progname);
      return (0);
    }
    optind ++;
  }
  while_break: ;
  }
  optind = 1;
  {
  while (1) {
    while_continue___0: ;
    opt = getopt(argc, (char **)argv, (char const *)"46df:F:hl:L:mnpP:qQrRst:u:Uvx");
    if (! (opt != -1)) {
      goto while_break___0;
    }
    {
    if (opt == 54) {
      goto case_54;
    }
    if (opt == 52) {
      goto case_54;
    }
    if (opt == 100) {
      goto case_100;
    }
    if (opt == 102) {
      goto case_102;
    }
    if (opt == 70) {
      goto case_70;
    }
    if (opt == 108) {
      goto case_108;
    }
    if (opt == 76) {
      goto case_76;
    }
    if (opt == 109) {
      goto case_109;
    }
    if (opt == 110) {
      goto case_110;
    }
    if (opt == 112) {
      goto case_112;
    }
    if (opt == 80) {
      goto case_80;
    }
    if (opt == 113) {
      goto case_113;
    }
    if (opt == 81) {
      goto case_81;
    }
    if (opt == 114) {
      goto case_114;
    }
    if (opt == 82) {
      goto case_82;
    }
    if (opt == 115) {
      goto case_115;
    }
    if (opt == 116) {
      goto case_116;
    }
    if (opt == 117) {
      goto case_117;
    }
    if (opt == 85) {
      goto case_85;
    }
    if (opt == 118) {
      goto case_118;
    }
    if (opt == 120) {
      goto case_120;
    }
    goto switch_default;
    case_54:
    case_52:
    if (opt == 52) {
      address_family___0 = 1;
    } else {
      address_family___0 = 2;
    }
    goto switch_break;
    case_100:
    debug ++;
    nofork = 1;
    system_log___0 = 0;
    goto switch_break;
    case_102:
    conf_file = (char const *)optarg;
    goto switch_break;
    case_70:
    scfilter_level = parse_int_arg((char const *)optarg);
    goto switch_break;
    case_108:
    log_file = optarg;
    goto switch_break;
    case_76:
    log_severity = parse_int_arg((char const *)optarg);
    goto switch_break;
    case_109:
    lock_memory___0 = 1;
    goto switch_break;
    case_110:
    nofork = 1;
    goto switch_break;
    case_112:
    print_config___0 = 1;
    user_check = 0;
    nofork = 1;
    system_log___0 = 0;
    log_severity = 1;
    goto switch_break;
    case_80:
    sched_priority___0 = parse_int_arg((char const *)optarg);
    goto switch_break;
    case_113:
    ref_mode = (REF_Mode )2;
    nofork = 1;
    client_only = 0;
    system_log___0 = 0;
    goto switch_break;
    case_81:
    ref_mode = (REF_Mode )3;
    nofork = 1;
    client_only = 1;
    user_check = 0;
    clock_control = 0;
    system_log___0 = 0;
    goto switch_break;
    case_114:
    reload = 1;
    goto switch_break;
    case_82:
    restarted___0 = 1;
    goto switch_break;
    case_115:
    do_init_rtc = 1;
    goto switch_break;
    case_116:
    timeout = parse_int_arg((char const *)optarg);
    goto switch_break;
    case_117:
    user___0 = optarg;
    goto switch_break;
    case_85:
    user_check = 0;
    goto switch_break;
    case_118:
    print_version();
    return (0);
    case_120:
    clock_control = 0;
    goto switch_break;
    switch_default:
    print_help(progname);
    return (opt != 104);
    switch_break: ;
    }
  }
  while_break___0: ;
  }
  if (user_check) {
    tmp___1 = getuid();
    if (tmp___1 != 0U) {
      {
      while (1) {
        while_continue___1: ;
        LOG_Message((LOG_Severity )3, (char const *)"Not superuser");
        exit(1);
        goto while_break___1;
      }
      while_break___1: ;
      }
    }
  }
  if (! nofork) {
    go_daemon();
  }
  if (log_file) {
    LOG_OpenFileLog((char const *)log_file);
  } else
  if (system_log___0) {
    LOG_OpenSystemLog();
  }
  if (debug >= 2) {
    tmp___2 = -1;
  } else {
    tmp___2 = log_severity;
  }
  LOG_SetMinSeverity((LOG_Severity )tmp___2);
  LOG_Message((LOG_Severity )0, (char const *)"chronyd version %s starting (%s)",
              "4.2", "+CMDMON +NTP +REFCLOCK +RTC -PRIVDROP -SCFILTER -SIGND +ASYNCDNS -NTS -SECHASH +IPV6 -DEBUG");
  DNS_SetAddressFamily(address_family___0);
  CNF_Initialise(restarted___0, client_only);
  if (print_config___0) {
    CNF_EnablePrint();
  }
  config_args = argc - optind;
  if (! config_args) {
    CNF_ReadFile(conf_file);
  } else {
    {
    while (1) {
      while_continue___2: ;
      if (! (optind < argc)) {
        goto while_break___2;
      }
      CNF_ParseLine((char const *)((void *)0), ((config_args + optind) - argc) + 1,
                    *(argv + optind));
      optind ++;
    }
    while_break___2: ;
    }
  }
  if (print_config___0) {
    return (0);
  }
  check_pidfile();
  if (! user___0) {
    user___0 = CNF_GetUser();
  }
  pw = getpwnam((char const *)user___0);
  if (! pw) {
    {
    while (1) {
      while_continue___3: ;
      LOG_Message((LOG_Severity )3, (char const *)"Could not get user/group ID of %s",
                  user___0);
      exit(1);
      goto while_break___3;
    }
    while_break___3: ;
    }
  }
  CNF_CreateDirs(pw->pw_uid, pw->pw_gid);
  write_pidfile();
  LCL_Initialise();
  SCH_Initialise();
  SCK_Initialise(address_family___0);
  NKS_PreInitialise(pw->pw_uid, pw->pw_gid, scfilter_level);
  SYS_Initialise(clock_control);
  RTC_Initialise(do_init_rtc);
  SRC_Initialise();
  RCL_Initialise();
  KEY_Initialise();
  CAM_Initialise();
  NIO_Initialise();
  NCR_Initialise();
  CNF_SetupAccessRestrictions();
  if (! sched_priority___0) {
    sched_priority___0 = CNF_GetSchedPriority();
  }
  if (sched_priority___0) {
    SYS_SetScheduler(sched_priority___0);
  }
  if (lock_memory___0) {
    SYS_LockMemory();
  } else {
    tmp___3 = CNF_GetLockMemory();
    if (tmp___3) {
      SYS_LockMemory();
    }
  }
  tmp___4 = geteuid();
  if (! tmp___4) {
    if (pw->pw_uid) {
      SYS_DropRoot(pw->pw_uid, pw->pw_gid, (SYS_ProcessContext )0);
    } else
    if (pw->pw_gid) {
      SYS_DropRoot(pw->pw_uid, pw->pw_gid, (SYS_ProcessContext )0);
    }
  }
  tmp___5 = geteuid();
  if (! tmp___5) {
    LOG_Message((LOG_Severity )1, (char const *)"Running with root privileges");
  }
  REF_Initialise();
  SST_Initialise();
  NSR_Initialise();
  NSD_Initialise();
  NNS_Initialise();
  NKS_Initialise();
  CLG_Initialise();
  MNL_Initialise();
  TMC_Initialise();
  SMT_Initialise();
  initialised___0 = 1;
  UTI_SetQuitSignalsHandler(& signal_cleanup, 1);
  CAM_OpenUnixSocket();
  if (scfilter_level) {
    SYS_EnableSystemCallFilter(scfilter_level, (SYS_ProcessContext )0);
  }
  if ((unsigned int )ref_mode == 0U) {
    tmp___6 = CNF_GetInitSources();
    if (tmp___6 > 0) {
      ref_mode = (REF_Mode )1;
    }
  }
  REF_SetModeEndHandler(& reference_mode_end);
  REF_SetMode(ref_mode);
  if (timeout >= 0) {
    SCH_AddTimeoutByDelay((double )timeout, & quit_timeout, (void *)0);
  }
  if (do_init_rtc) {
    RTC_TimeInit(& post_init_rtc_hook, (void *)0);
  } else {
    post_init_rtc_hook((void *)0);
  }
  SCH_MainLoop();
  LOG_Message((LOG_Severity )0, (char const *)"chronyd exiting");
  MAI_CleanupAndExit();
  return (0);
}
}
void *Malloc(size_t size )
{
  void *r ;
  {
  r = malloc(size);
  if (! r) {
    if (size) {
      {
      while (1) {
        while_continue: ;
        LOG_Message((LOG_Severity )3, (char const *)"Could not allocate memory");
        exit(1);
        goto while_break;
      }
      while_break: ;
      }
    }
  }
  return (r);
}
}
void *Realloc(void *ptr , size_t size )
{
  void *r ;
  {
  r = realloc(ptr, size);
  if (! r) {
    if (size) {
      {
      while (1) {
        while_continue: ;
        LOG_Message((LOG_Severity )3, (char const *)"Could not allocate memory");
        exit(1);
        goto while_break;
      }
      while_break: ;
      }
    }
  }
  return (r);
}
}
static size_t get_array_size(size_t nmemb , size_t size )
{
  size_t array_size ;
  {
  array_size = nmemb * size;
  if (nmemb > 0UL) {
    if (array_size / nmemb != size) {
      {
      while (1) {
        while_continue: ;
        LOG_Message((LOG_Severity )3, (char const *)"Could not allocate memory");
        exit(1);
        goto while_break;
      }
      while_break: ;
      }
    }
  }
  return (array_size);
}
}
void *Malloc2(size_t nmemb , size_t size )
{
  size_t tmp ;
  void *tmp___0 ;
  {
  tmp = get_array_size(nmemb, size);
  tmp___0 = Malloc(tmp);
  return (tmp___0);
}
}
void *Realloc2(void *ptr , size_t nmemb , size_t size )
{
  size_t tmp ;
  void *tmp___0 ;
  {
  tmp = get_array_size(nmemb, size);
  tmp___0 = Realloc(ptr, tmp);
  return (tmp___0);
}
}
char *Strdup(char const *s )
{
  void *r ;
  char *tmp ;
  {
  tmp = strdup(s);
  r = (void *)tmp;
  if (! r) {
    {
    while (1) {
      while_continue: ;
      LOG_Message((LOG_Severity )3, (char const *)"Could not allocate memory");
      exit(1);
      goto while_break;
    }
    while_break: ;
    }
  }
  return ((char *)r);
}
}
static int are_we_synchronised ;
static int enable_local_stratum ;
static int local_stratum___0 ;
static int local_orphan___0 ;
static double local_distance___0 ;
static struct timespec local_ref_time ;
static NTP_Leap our_leap_status ;
static int our_leap_sec ;
static int our_tai_offset ;
static int our_stratum ;
static uint32_t our_ref_id ;
static IPAddr our_ref_ip ;
static struct timespec our_ref_time ;
static double our_skew ;
static double our_residual_freq ;
static double our_root_delay ;
static double our_root_dispersion ;
static double our_offset_sd ;
static double our_frequency_sd ;
static double max_update_skew___0 ;
static double last_offset ;
static double avg2_offset ;
static int avg2_moving ;
static double correction_time_ratio___0 ;
static int initialised___1 = 0;
static REF_Mode mode ;
static int make_step_limit___0 ;
static double make_step_threshold___0 ;
static int max_offset_delay___0 ;
static int max_offset_ignore___0 ;
static double max_offset___0 ;
static double log_change_threshold___0 ;
static int do_mail_change ;
static double mail_change_threshold___0 ;
static char *mail_change_user ;
static void (*mode_end_handler)(int result ) = (void (*)(int result ))((void *)0);
static char *drift_file___0 = (char *)((void *)0);
static double drift_file_age ;
static void update_drift_file(double freq_ppm , double skew ) ;
static REF_LeapMode leap_mode ;
static time_t leap_when ;
static int leap_in_progress ;
static SCH_TimeoutID leap_timeout_id ;
static char *leap_tzname ;
static LOG_FileID logfileid ;
static int fb_drift_min___0 ;
static int fb_drift_max___0 ;
static struct fb_drift *fb_drifts = (struct fb_drift *)((void *)0);
static int next_fb_drift ;
static SCH_TimeoutID fb_drift_timeout_id ;
static double last_ref_update ;
static double last_ref_update_interval ;
static NTP_Leap get_tz_leap(time_t when , int *tai_offset ) ;
static void update_leap_status(NTP_Leap leap , time_t now , int reset ) ;
static void handle_slew(struct timespec *raw , struct timespec *cooked , double dfreq ,
                        double doffset , LCL_ChangeType change_type , void *anything )
{
  double delta ;
  struct timespec now ;
  int tmp ;
  {
  tmp = UTI_IsZeroTimespec(& our_ref_time);
  if (! tmp) {
    UTI_AdjustTimespec((struct timespec const *)(& our_ref_time), (struct timespec const *)cooked,
                       & our_ref_time, & delta, dfreq, doffset);
  }
  if ((unsigned int )change_type == 2U) {
    last_ref_update = 0.0;
    REF_SetUnsynchronised();
  }
  if ((unsigned int )change_type != 0U) {
    if (our_leap_sec) {
      if (! leap_in_progress) {
        LCL_ReadRawTime(& now);
        update_leap_status(our_leap_status, now.tv_sec, 1);
      }
    }
  }
  return;
}
}
void REF_Initialise(void)
{
  FILE *in ;
  double file_freq_ppm ;
  double file_skew_ppm ;
  double our_frequency_ppm ;
  int tai_offset ;
  int tmp ;
  int tmp___0 ;
  LOG_FileID tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  int tmp___5 ;
  NTP_Leap tmp___6 ;
  NTP_Leap tmp___7 ;
  void *tmp___8 ;
  {
  mode = (REF_Mode )0;
  are_we_synchronised = 0;
  our_leap_status = (NTP_Leap )3;
  our_leap_sec = 0;
  our_tai_offset = 0;
  initialised___1 = 1;
  our_root_dispersion = 1.0;
  our_root_delay = 1.0;
  our_frequency_ppm = 0.0;
  our_skew = 1.0;
  our_residual_freq = 0.0;
  our_frequency_sd = 0.0;
  our_offset_sd = 0.0;
  drift_file_age = 0.0;
  drift_file___0 = CNF_GetDriftFile();
  if (drift_file___0) {
    in = UTI_OpenFile((char const *)((void *)0), (char const *)drift_file___0,
                      (char const *)((void *)0), (char )'r', (mode_t )0);
    if (in) {
      tmp = fscanf(in, (char const *)"%lf%lf", & file_freq_ppm, & file_skew_ppm);
      if (tmp == 2) {
        our_frequency_ppm = file_freq_ppm;
        our_skew = 1.0e-6 * file_skew_ppm;
        if (our_skew < 1.0e-12) {
          our_skew = 1.0e-12;
        }
        LOG_Message((LOG_Severity )0, (char const *)"Frequency %.3f +/- %.3f ppm read from %s",
                    file_freq_ppm, file_skew_ppm, drift_file___0);
        LCL_SetAbsoluteFrequency(our_frequency_ppm);
      } else {
        LOG_Message((LOG_Severity )1, (char const *)"Could not read valid frequency and skew from driftfile %s",
                    drift_file___0);
      }
      fclose(in);
    }
  }
  if (our_frequency_ppm == 0.0) {
    our_frequency_ppm = LCL_ReadAbsoluteFrequency();
    if (our_frequency_ppm != 0.0) {
      LOG_Message((LOG_Severity )0, (char const *)"Initial frequency %.3f ppm",
                  our_frequency_ppm);
    }
  }
  tmp___2 = CNF_GetLogTracking();
  if (tmp___2) {
    tmp___1 = LOG_FileOpen((char const *)"tracking", (char const *)"   Date (UTC) Time     IP Address   St   Freq ppm   Skew ppm     Offset L Co  Offset sd Rem. corr. Root delay Root disp. Max. error");
    logfileid = tmp___1;
  } else {
    logfileid = -1;
  }
  tmp___3 = CNF_GetMaxUpdateSkew();
  tmp___4 = fabs(tmp___3);
  max_update_skew___0 = tmp___4 * 1.0e-6;
  correction_time_ratio___0 = CNF_GetCorrectionTimeRatio();
  enable_local_stratum = CNF_AllowLocalReference(& local_stratum___0, & local_orphan___0,
                                                 & local_distance___0);
  UTI_ZeroTimespec(& local_ref_time);
  leap_when = (time_t )0;
  leap_timeout_id = (SCH_TimeoutID )0;
  leap_in_progress = 0;
  leap_mode = CNF_GetLeapSecMode();
  if ((unsigned int )leap_mode == 0U) {
    tmp___5 = LCL_CanSystemLeap();
    if (! tmp___5) {
      leap_mode = (REF_LeapMode )2;
    }
  }
  leap_tzname = CNF_GetLeapSecTimezone();
  if (leap_tzname) {
    tmp___6 = get_tz_leap((time_t )1341014400, & tai_offset);
    if ((unsigned int )tmp___6 == 1U) {
      if (tai_offset == 34) {
        tmp___7 = get_tz_leap((time_t )1356912000, & tai_offset);
        if ((unsigned int )tmp___7 == 0U) {
          if (tai_offset == 35) {
            LOG_Message((LOG_Severity )0, (char const *)"Using %s timezone to obtain leap second data",
                        leap_tzname);
          } else {
            LOG_Message((LOG_Severity )1, (char const *)"Timezone %s failed leap second check, ignoring",
                        leap_tzname);
            leap_tzname = (char *)((void *)0);
          }
        } else {
          LOG_Message((LOG_Severity )1, (char const *)"Timezone %s failed leap second check, ignoring",
                      leap_tzname);
          leap_tzname = (char *)((void *)0);
        }
      } else {
        LOG_Message((LOG_Severity )1, (char const *)"Timezone %s failed leap second check, ignoring",
                    leap_tzname);
        leap_tzname = (char *)((void *)0);
      }
    } else {
      LOG_Message((LOG_Severity )1, (char const *)"Timezone %s failed leap second check, ignoring",
                  leap_tzname);
      leap_tzname = (char *)((void *)0);
    }
  }
  CNF_GetMakeStep(& make_step_limit___0, & make_step_threshold___0);
  CNF_GetMaxChange(& max_offset_delay___0, & max_offset_ignore___0, & max_offset___0);
  CNF_GetMailOnChange(& do_mail_change, & mail_change_threshold___0, & mail_change_user);
  log_change_threshold___0 = CNF_GetLogChange();
  CNF_GetFallbackDrifts(& fb_drift_min___0, & fb_drift_max___0);
  if (fb_drift_max___0 >= fb_drift_min___0) {
    if (fb_drift_min___0 > 0) {
      tmp___8 = Malloc2((size_t )((fb_drift_max___0 - fb_drift_min___0) + 1), sizeof(struct fb_drift ));
      fb_drifts = (struct fb_drift *)tmp___8;
      memset((void *)fb_drifts, 0, sizeof(struct fb_drift ) * (unsigned long )((fb_drift_max___0 - fb_drift_min___0) + 1));
      next_fb_drift = 0;
      fb_drift_timeout_id = (SCH_TimeoutID )0;
    }
  }
  UTI_ZeroTimespec(& our_ref_time);
  last_ref_update = 0.0;
  last_ref_update_interval = 0.0;
  LCL_AddParameterChangeHandler(& handle_slew, (void *)0);
  REF_SetUnsynchronised();
  return;
}
}
void REF_Finalise(void)
{
  double tmp ;
  {
  update_leap_status((NTP_Leap )3, (time_t )0, 0);
  if (drift_file___0) {
    tmp = LCL_ReadAbsoluteFrequency();
    update_drift_file(tmp, our_skew);
  }
  LCL_RemoveParameterChangeHandler(& handle_slew, (void *)0);
  free((void *)fb_drifts);
  initialised___1 = 0;
  return;
}
}
void REF_SetMode(REF_Mode new_mode )
{
  {
  mode = new_mode;
  return;
}
}
REF_Mode REF_GetMode(void)
{
  {
  return (mode);
}
}
void REF_SetModeEndHandler(void (*handler)(int result ) )
{
  {
  mode_end_handler = handler;
  return;
}
}
REF_LeapMode REF_GetLeapMode(void)
{
  {
  return (leap_mode);
}
}
static void update_drift_file(double freq_ppm , double skew )
{
  FILE *out ;
  int tmp ;
  int tmp___0 ;
  {
  out = UTI_OpenFile((char const *)((void *)0), (char const *)drift_file___0,
                     (char const *)".tmp", (char )'w', (mode_t )0644);
  if (! out) {
    return;
  }
  fprintf(out, (char const *)"%20.6f %20.6f\n", freq_ppm, 1.0e6 * skew);
  fclose(out);
  tmp = UTI_RenameTempFile((char const *)((void *)0), (char const *)drift_file___0,
                           (char const *)".tmp", (char const *)((void *)0));
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  return;
}
}
static void update_fb_drifts(double freq_ppm , double update_interval___0 )
{
  int i ;
  int secs ;
  double tmp ;
  {
  assert(are_we_synchronised);
  if (next_fb_drift > 0) {
    next_fb_drift = 0;
  }
  SCH_RemoveTimeout(fb_drift_timeout_id);
  fb_drift_timeout_id = (SCH_TimeoutID )0;
  if (update_interval___0 < 1.0) {
    return;
  } else
  if (update_interval___0 > last_ref_update_interval * 4.0) {
    return;
  }
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < (fb_drift_max___0 - fb_drift_min___0) + 1)) {
      goto while_break;
    }
    secs = 1 << (i + fb_drift_min___0);
    if ((fb_drifts + i)->secs < (double )secs) {
      (fb_drifts + i)->freq = ((fb_drifts + i)->freq * (fb_drifts + i)->secs + (update_interval___0 * 0.5) * freq_ppm) / (update_interval___0 * 0.5 + (fb_drifts + i)->secs);
      (fb_drifts + i)->secs += update_interval___0 * 0.5;
    } else {
      tmp = exp(update_interval___0 / (double )secs);
      (fb_drifts + i)->freq += ((double )1 - 1.0 / tmp) * (freq_ppm - (fb_drifts + i)->freq);
    }
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
    i ++;
  }
  while_break: ;
  }
  return;
}
}
static void fb_drift_timeout(void *arg )
{
  int tmp ;
  {
  if (next_fb_drift >= fb_drift_min___0) {
    if (next_fb_drift <= fb_drift_max___0) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  assert(tmp);
  fb_drift_timeout_id = (SCH_TimeoutID )0;
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  LCL_SetAbsoluteFrequency((fb_drifts + (next_fb_drift - fb_drift_min___0))->freq);
  REF_SetUnsynchronised();
  return;
}
}
static void schedule_fb_drift(void)
{
  int i ;
  int c ;
  int secs ;
  double unsynchronised ;
  double now ;
  {
  if (fb_drift_timeout_id) {
    return;
  }
  now = SCH_GetLastEventMonoTime();
  unsynchronised = now - last_ref_update;
  secs = 0;
  c = secs;
  i = fb_drift_min___0;
  {
  while (1) {
    while_continue: ;
    if (! (i <= fb_drift_max___0)) {
      goto while_break;
    }
    secs = 1 << i;
    if ((fb_drifts + (i - fb_drift_min___0))->secs < (double )secs) {
      goto __Cont;
    }
    if (unsynchronised < (double )secs) {
      if (i > next_fb_drift) {
        goto while_break;
      }
    }
    c = i;
    __Cont:
    i ++;
  }
  while_break: ;
  }
  if (c > next_fb_drift) {
    LCL_SetAbsoluteFrequency((fb_drifts + (c - fb_drift_min___0))->freq);
    next_fb_drift = c;
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
  }
  if (i <= fb_drift_max___0) {
    next_fb_drift = i;
    fb_drift_timeout_id = SCH_AddTimeoutByDelay((double )secs - unsynchronised, & fb_drift_timeout,
                                                (void *)0);
    {
    while (1) {
      while_continue___1: ;
      goto while_break___1;
    }
    while_break___1: ;
    }
  }
  return;
}
}
static void end_ref_mode(int result )
{
  {
  mode = (REF_Mode )4;
  if (mode_end_handler) {
    (*mode_end_handler)(result);
  }
  return;
}
}
static void maybe_log_offset(double offset , time_t now )
{
  double abs_offset ;
  FILE *p ;
  char buffer[255] ;
  char host[255] ;
  struct tm *tm ;
  int tmp ;
  {
  abs_offset = fabs(offset);
  if (abs_offset > log_change_threshold___0) {
    LOG_Message((LOG_Severity )1, (char const *)"System clock wrong by %.6f seconds",
                - offset);
  }
  if (do_mail_change) {
    if (abs_offset > mail_change_threshold___0) {
      snprintf(buffer, sizeof(buffer), (char const *)"%s -t", "/usr/lib/sendmail");
      p = popen((char const *)(buffer), (char const *)"w");
      if (p) {
        tmp = gethostname(host, sizeof(host));
        if (tmp < 0) {
          strcpy(host, (char const *)"<UNKNOWN>");
        }
        host[sizeof(host) - 1UL] = (char )'\000';
        fprintf(p, (char const *)"To: %s\n", mail_change_user);
        fprintf(p, (char const *)"Subject: chronyd reports change to system clock on node [%s]\n",
                host);
        fputs((char const * __restrict )"\n", (FILE * __restrict )p);
        tm = localtime((time_t const *)(& now));
        if (tm) {
          strftime((char * __restrict )(buffer), sizeof(buffer), (char const * __restrict )"On %A, %d %B %Y\n  with the system clock reading %H:%M:%S (%Z)",
                   (struct tm const * __restrict )tm);
          fputs((char const * __restrict )(buffer), (FILE * __restrict )p);
        }
        fprintf(p, (char const *)"\n\nchronyd started to apply an adjustment of %.3f seconds to it,\n  which exceeded the reporting threshold of %.3f seconds\n\n",
                - offset, mail_change_threshold___0);
        pclose(p);
      } else {
        LOG_Message((LOG_Severity )2, (char const *)"Could not send mail notification to user %s\n",
                    mail_change_user);
      }
    }
  }
  return;
}
}
static int is_step_limit_reached(double offset , double offset_correction )
{
  double tmp ;
  {
  if (make_step_limit___0 == 0) {
    return (0);
  } else
  if (make_step_limit___0 > 0) {
    make_step_limit___0 --;
  }
  tmp = fabs(offset - offset_correction);
  return (tmp > make_step_threshold___0);
}
}
static int is_offset_ok(double offset )
{
  char *tmp ;
  double tmp___0 ;
  {
  if (max_offset_delay___0 < 0) {
    return (1);
  }
  if (max_offset_delay___0 > 0) {
    max_offset_delay___0 --;
    return (1);
  }
  tmp___0 = fabs(offset);
  if (tmp___0 > max_offset___0) {
    if (! max_offset_ignore___0) {
      tmp = "exiting";
    } else {
      tmp = "ignored";
    }
    LOG_Message((LOG_Severity )1, (char const *)"Adjustment of %.3f seconds exceeds the allowed maximum of %.3f seconds (%s) ",
                - offset, max_offset___0, tmp);
    if (! max_offset_ignore___0) {
      end_ref_mode(0);
    } else
    if (max_offset_ignore___0 > 0) {
      max_offset_ignore___0 --;
    }
    return (0);
  }
  return (1);
}
}
static int is_leap_second_day(time_t when )
{
  struct tm *stm ;
  int tmp ;
  {
  stm = gmtime((time_t const *)(& when));
  if (! stm) {
    return (0);
  }
  if (stm->tm_mon == 5) {
    if (stm->tm_mday == 30) {
      tmp = 1;
    } else {
      goto _L;
    }
  } else
  _L:
  if (stm->tm_mon == 11) {
    if (stm->tm_mday == 31) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
static time_t last_tz_leap_check ;
static NTP_Leap tz_leap ;
static int tz_tai_offset ;
static NTP_Leap get_tz_leap(time_t when , int *tai_offset )
{
  struct tm stm ;
  struct tm *tm ;
  time_t t ;
  char *tz_env ;
  char tz_orig[128] ;
  size_t tmp ;
  {
  *tai_offset = tz_tai_offset;
  when = (when / 43200L) * 43200L;
  if (last_tz_leap_check == when) {
    return (tz_leap);
  }
  last_tz_leap_check = when;
  tz_leap = (NTP_Leap )0;
  tz_tai_offset = 0;
  tm = gmtime((time_t const *)(& when));
  if (! tm) {
    return (tz_leap);
  }
  stm = *tm;
  tz_env = getenv((char const *)"TZ");
  if (tz_env) {
    tmp = strlen((char const *)tz_env);
    if (tmp >= sizeof(tz_orig)) {
      return (tz_leap);
    }
    strcpy(tz_orig, (char const *)tz_env);
  }
  setenv((char const *)"TZ", (char const *)leap_tzname, 1);
  tzset();
  t = mktime(& stm);
  if (t != -1L) {
    tz_tai_offset = (int )((t - when) + 10L);
  }
  stm.tm_sec = 60;
  stm.tm_min = 59;
  stm.tm_hour = 23;
  t = mktime(& stm);
  if (tz_env) {
    setenv((char const *)"TZ", (char const *)(tz_orig), 1);
  } else {
    unsetenv((char const *)"TZ");
  }
  tzset();
  if (t == -1L) {
    return (tz_leap);
  }
  if (stm.tm_sec == 60) {
    tz_leap = (NTP_Leap )1;
  } else
  if (stm.tm_sec == 1) {
    tz_leap = (NTP_Leap )2;
  }
  *tai_offset = tz_tai_offset;
  return (tz_leap);
}
}
static void leap_end_timeout(void *arg )
{
  {
  leap_timeout_id = (SCH_TimeoutID )0;
  leap_in_progress = 0;
  if (our_tai_offset) {
    our_tai_offset += our_leap_sec;
  }
  our_leap_sec = 0;
  if ((unsigned int )leap_mode == 0U) {
    LCL_SetSystemLeap(our_leap_sec, our_tai_offset);
  }
  if ((unsigned int )our_leap_status == 1U) {
    our_leap_status = (NTP_Leap )0;
  } else
  if ((unsigned int )our_leap_status == 2U) {
    our_leap_status = (NTP_Leap )0;
  }
  return;
}
}
static void leap_start_timeout(void *arg )
{
  {
  leap_in_progress = 1;
  {
  if ((unsigned int )leap_mode == 0U) {
    goto case_0;
  }
  if ((unsigned int )leap_mode == 1U) {
    goto case_1;
  }
  if ((unsigned int )leap_mode == 2U) {
    goto case_2;
  }
  if ((unsigned int )leap_mode == 3U) {
    goto case_3;
  }
  goto switch_default;
  case_0:
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  goto switch_break;
  case_1:
  LCL_NotifyLeap(our_leap_sec);
  LCL_AccumulateOffset((double )our_leap_sec, 0.0);
  LOG_Message((LOG_Severity )1, (char const *)"Adjusting system clock for leap second");
  goto switch_break;
  case_2:
  LCL_NotifyLeap(our_leap_sec);
  LCL_ApplyStepOffset((double )our_leap_sec);
  LOG_Message((LOG_Severity )1, (char const *)"System clock was stepped for leap second");
  goto switch_break;
  case_3:
  LOG_Message((LOG_Severity )1, (char const *)"Ignoring leap second");
  goto switch_break;
  switch_default:
  goto switch_break;
  switch_break: ;
  }
  leap_timeout_id = SCH_AddTimeoutByDelay(2.0, & leap_end_timeout, (void *)0);
  return;
}
}
static void set_leap_timeout(time_t now )
{
  struct timespec when ;
  {
  SCH_RemoveTimeout(leap_timeout_id);
  leap_timeout_id = (SCH_TimeoutID )0;
  leap_in_progress = 0;
  if (! our_leap_sec) {
    return;
  }
  leap_when = (now / 86400L + 1L) * 86400L;
  when.tv_sec = leap_when;
  when.tv_nsec = (__syscall_slong_t )0;
  if (our_leap_sec < 0) {
    (when.tv_sec) --;
  }
  if ((unsigned int )leap_mode == 0U) {
    (when.tv_sec) --;
    when.tv_nsec = (__syscall_slong_t )500000000;
  }
  leap_timeout_id = SCH_AddTimeout(& when, & leap_start_timeout, (void *)0);
  return;
}
}
static void update_leap_status(NTP_Leap leap , time_t now , int reset )
{
  NTP_Leap tz_leap___0 ;
  int leap_sec ;
  int tai_offset ;
  int tmp ;
  int tmp___0 ;
  {
  leap_sec = 0;
  tai_offset = 0;
  if (leap_tzname) {
    if (now) {
      tz_leap___0 = get_tz_leap(now, & tai_offset);
      if ((unsigned int )leap == 0U) {
        leap = tz_leap___0;
      }
    }
  }
  if ((unsigned int )leap == 1U) {
    goto _L;
  } else
  if ((unsigned int )leap == 2U) {
    _L:
    tmp = is_leap_second_day(now);
    if (tmp) {
      if ((unsigned int )leap == 1U) {
        leap_sec = 1;
      } else {
        leap_sec = -1;
      }
    } else {
      leap = (NTP_Leap )0;
    }
  }
  if (leap_sec != our_leap_sec) {
    goto _L___1;
  } else
  if (tai_offset != our_tai_offset) {
    _L___1:
    tmp___0 = REF_IsLeapSecondClose((struct timespec *)((void *)0), 0.0);
    if (tmp___0) {
      goto _L___0;
    } else {
      our_leap_sec = leap_sec;
      our_tai_offset = tai_offset;
      {
      if ((unsigned int )leap_mode == 0U) {
        goto case_0;
      }
      if ((unsigned int )leap_mode == 3U) {
        goto case_3;
      }
      if ((unsigned int )leap_mode == 2U) {
        goto case_3;
      }
      if ((unsigned int )leap_mode == 1U) {
        goto case_3;
      }
      goto switch_default;
      case_0:
      LCL_SetSystemLeap(our_leap_sec, our_tai_offset);
      case_3:
      case_2:
      case_1:
      set_leap_timeout(now);
      goto switch_break;
      switch_default:
      assert(0);
      goto switch_break;
      switch_break: ;
      }
    }
  } else
  _L___0:
  if (reset) {
    set_leap_timeout(now);
  }
  our_leap_status = leap;
  return;
}
}
static double get_root_dispersion(struct timespec *ts )
{
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  {
  tmp = UTI_IsZeroTimespec(& our_ref_time);
  if (tmp) {
    return (1.0);
  }
  tmp___0 = UTI_DiffTimespecsToDouble((struct timespec const *)ts, (struct timespec const *)(& our_ref_time));
  tmp___1 = fabs(tmp___0);
  tmp___2 = fabs(our_residual_freq);
  tmp___3 = LCL_GetMaxClockError();
  return (our_root_dispersion + tmp___1 * ((our_skew + tmp___2) + tmp___3));
}
}
static void update_sync_status(struct timespec *now )
{
  double elapsed ;
  double tmp ;
  double tmp___0 ;
  {
  tmp = UTI_DiffTimespecsToDouble((struct timespec const *)now, (struct timespec const *)(& our_ref_time));
  elapsed = fabs(tmp);
  tmp___0 = get_root_dispersion(now);
  LCL_SetSyncStatus(are_we_synchronised, our_offset_sd + elapsed * our_frequency_sd,
                    our_root_delay / 2.0 + tmp___0);
  return;
}
}
static void write_log(struct timespec *now , int combined_sources , double freq___0 ,
                      double offset , double offset_sd , double uncorrected_offset ,
                      double orig_root_distance ) ;
static double last_sys_offset = 0.0;
static void write_log(struct timespec *now , int combined_sources , double freq___0 ,
                      double offset , double offset_sd , double uncorrected_offset ,
                      double orig_root_distance )
{
  char leap_codes[4] ;
  double root_dispersion ;
  double max_error ;
  double tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  {
  leap_codes[0] = (char )'N';
  leap_codes[1] = (char )'+';
  leap_codes[2] = (char )'-';
  leap_codes[3] = (char )'?';
  if (logfileid == -1) {
    return;
  }
  tmp = fabs(last_sys_offset);
  max_error = orig_root_distance + tmp;
  root_dispersion = get_root_dispersion(now);
  last_sys_offset = offset - uncorrected_offset;
  if ((int )our_ref_ip.family != 0) {
    tmp___0 = UTI_IPToString((IPAddr const *)(& our_ref_ip));
    tmp___2 = tmp___0;
  } else {
    tmp___1 = UTI_RefidToString(our_ref_id);
    tmp___2 = tmp___1;
  }
  tmp___3 = UTI_TimeToLogForm(now->tv_sec);
  LOG_FileWrite(logfileid, (char const *)"%s %-15s %2d %10.3f %10.3f %10.3e %1c %2d %10.3e %10.3e %10.3e %10.3e %10.3e",
                tmp___3, tmp___2, our_stratum, freq___0, 1.0e6 * our_skew, offset,
                (int )leap_codes[our_leap_status], combined_sources, offset_sd, uncorrected_offset,
                our_root_delay, root_dispersion, max_error);
  return;
}
}
static void special_mode_sync(int valid , double offset )
{
  int step ;
  double tmp ;
  double tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  double tmp___3 ;
  char *tmp___4 ;
  {
  {
  if ((unsigned int )mode == 1U) {
    goto case_1;
  }
  if ((unsigned int )mode == 3U) {
    goto case_3;
  }
  if ((unsigned int )mode == 2U) {
    goto case_3;
  }
  if ((unsigned int )mode == 4U) {
    goto case_4;
  }
  goto switch_default;
  case_1:
  if (! valid) {
    LOG_Message((LOG_Severity )1, (char const *)"No suitable source for initstepslew");
    end_ref_mode(0);
    goto switch_break;
  }
  tmp = fabs(offset);
  tmp___0 = CNF_GetInitStepThreshold();
  step = tmp >= tmp___0;
  if (step) {
    tmp___1 = "step";
  } else {
    tmp___1 = "slew";
  }
  if (offset >= (double )0) {
    tmp___2 = "fast";
  } else {
    tmp___2 = "slow";
  }
  tmp___3 = fabs(offset);
  LOG_Message((LOG_Severity )0, (char const *)"System\'s initial offset : %.6f seconds %s of true (%s)",
              tmp___3, tmp___2, tmp___1);
  if (step) {
    LCL_ApplyStepOffset(offset);
  } else {
    LCL_AccumulateOffset(offset, 0.0);
  }
  end_ref_mode(1);
  goto switch_break;
  case_3:
  case_2:
  if (! valid) {
    LOG_Message((LOG_Severity )1, (char const *)"No suitable source for synchronisation");
    end_ref_mode(0);
    goto switch_break;
  }
  step = (unsigned int )mode == 2U;
  if (step) {
    tmp___4 = "step";
  } else {
    tmp___4 = "ignored";
  }
  LOG_Message((LOG_Severity )0, (char const *)"System clock wrong by %.6f seconds (%s)",
              - offset, tmp___4);
  if (step) {
    LCL_ApplyStepOffset(offset);
  }
  end_ref_mode(1);
  goto switch_break;
  case_4:
  goto switch_break;
  switch_default:
  assert(0);
  switch_break: ;
  }
  return;
}
}
static void get_clock_estimates(int manual , double measured_freq , double measured_skew ,
                                double *estimated_freq , double *estimated_skew ,
                                double *residual_freq )
{
  double gain ;
  double expected_freq ;
  double expected_skew ;
  double extra_skew ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  {
  expected_freq = 0.0;
  expected_skew = our_skew;
  if (manual) {
    gain = 1.0;
  } else {
    tmp = fabs(measured_skew);
    if (tmp > max_update_skew___0) {
      {
      while (1) {
        while_continue: ;
        goto while_break;
      }
      while_break: ;
      }
      gain = 0.0;
    } else {
      gain = (3.0 * (expected_skew * expected_skew)) / (3.0 * (expected_skew * expected_skew) + measured_skew * measured_skew);
    }
  }
  if (gain < 1.0) {
    tmp___2 = gain;
  } else {
    tmp___2 = 1.0;
  }
  if (0.0 > tmp___2) {
    gain = 0.0;
  } else {
    if (gain < 1.0) {
      tmp___1 = gain;
    } else {
      tmp___1 = 1.0;
    }
    gain = tmp___1;
  }
  *estimated_freq = expected_freq + gain * (measured_freq - expected_freq);
  *residual_freq = measured_freq - *estimated_freq;
  extra_skew = sqrt(((expected_freq - *estimated_freq) * (expected_freq - *estimated_freq)) * (1.0 - gain) + ((measured_freq - *estimated_freq) * (measured_freq - *estimated_freq)) * gain);
  *estimated_skew = (expected_skew + gain * (measured_skew - expected_skew)) + extra_skew;
  return;
}
}
static void fuzz_ref_time(struct timespec *ts )
{
  uint32_t rnd___0 ;
  {
  UTI_GetRandomBytes((void *)(& rnd___0), (unsigned int )sizeof(rnd___0));
  UTI_AddDoubleToTimespec((struct timespec const *)ts, - ((double )rnd___0) / (double )4294967295U,
                          ts);
  return;
}
}
void REF_SetReference(int stratum , NTP_Leap leap , int combined_sources , uint32_t ref_id ,
                      IPAddr *ref_ip , struct timespec *ref_time , double offset ,
                      double offset_sd , double frequency , double frequency_sd ,
                      double skew , double root_delay , double root_dispersion )
{
  double uncorrected_offset ;
  double accumulate_offset ;
  double step_offset ;
  double residual_frequency ;
  double local_abs_frequency ;
  double elapsed ;
  double mono_now ;
  double update_interval___0 ;
  double correction_rate___0 ;
  double orig_root_distance ;
  struct timespec now ;
  struct timespec raw_now ;
  int manual ;
  int tmp ;
  double tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  assert(initialised___1);
  if ((unsigned int )mode != 0U) {
    special_mode_sync(1, offset);
    return;
  }
  manual = (unsigned int )leap == 3U;
  mono_now = SCH_GetLastEventMonoTime();
  LCL_ReadRawTime(& raw_now);
  LCL_GetOffsetCorrection(& raw_now, & uncorrected_offset, (double *)((void *)0));
  UTI_AddDoubleToTimespec((struct timespec const *)(& raw_now), uncorrected_offset,
                          & now);
  elapsed = UTI_DiffTimespecsToDouble((struct timespec const *)(& now), (struct timespec const *)ref_time);
  offset += elapsed * frequency;
  if (last_ref_update != 0.0) {
    update_interval___0 = mono_now - last_ref_update;
  } else {
    update_interval___0 = 0.0;
  }
  get_clock_estimates(manual, frequency, skew, & frequency, & skew, & residual_frequency);
  tmp = is_offset_ok(offset);
  if (! tmp) {
    return;
  }
  tmp___0 = get_root_dispersion(& now);
  orig_root_distance = our_root_delay / 2.0 + tmp___0;
  are_we_synchronised = (unsigned int )leap != 3U;
  our_stratum = stratum + 1;
  our_ref_id = ref_id;
  if (ref_ip) {
    our_ref_ip = *ref_ip;
  } else {
    our_ref_ip.family = (uint16_t )0;
  }
  our_ref_time = *ref_time;
  our_skew = skew;
  our_residual_freq = residual_frequency;
  our_root_delay = root_delay;
  our_root_dispersion = root_dispersion;
  our_frequency_sd = frequency_sd;
  our_offset_sd = offset_sd;
  last_ref_update = mono_now;
  last_ref_update_interval = update_interval___0;
  last_offset = offset;
  correction_rate___0 = ((correction_time_ratio___0 * 0.5) * offset_sd) * update_interval___0;
  tmp___1 = is_step_limit_reached(offset, uncorrected_offset);
  if (tmp___1) {
    accumulate_offset = uncorrected_offset;
    step_offset = offset - uncorrected_offset;
  } else {
    accumulate_offset = offset;
    step_offset = 0.0;
  }
  LCL_AccumulateFrequencyAndOffset(frequency, accumulate_offset, correction_rate___0);
  maybe_log_offset(offset, raw_now.tv_sec);
  if (step_offset != 0.0) {
    tmp___2 = LCL_ApplyStepOffset(step_offset);
    if (tmp___2) {
      LOG_Message((LOG_Severity )1, (char const *)"System clock was stepped by %.6f seconds",
                  - step_offset);
    }
  }
  update_leap_status(leap, raw_now.tv_sec, 0);
  update_sync_status(& now);
  fuzz_ref_time(& our_ref_time);
  local_abs_frequency = LCL_ReadAbsoluteFrequency();
  write_log(& now, combined_sources, local_abs_frequency, offset, offset_sd, uncorrected_offset,
            orig_root_distance);
  if (drift_file___0) {
    drift_file_age += update_interval___0;
    if (drift_file_age >= 3600.0) {
      update_drift_file(local_abs_frequency, our_skew);
      drift_file_age = 0.0;
    }
  }
  if (fb_drifts) {
    if (are_we_synchronised) {
      update_fb_drifts(local_abs_frequency, update_interval___0);
      schedule_fb_drift();
    }
  }
  if (avg2_moving) {
    avg2_offset += 0.1 * (offset * offset - avg2_offset);
  } else {
    if (avg2_offset > 0.0) {
      if (avg2_offset < offset * offset) {
        avg2_moving = 1;
      }
    }
    avg2_offset = offset * offset;
  }
  return;
}
}
void REF_SetManualReference(struct timespec *ref_time , double offset , double frequency ,
                            double skew )
{
  {
  REF_SetReference(0, (NTP_Leap )3, 1, (uint32_t )0x4D414E55UL, (IPAddr *)((void *)0),
                   ref_time, offset, 0.0, frequency, skew, skew, 0.0, 0.0);
  return;
}
}
void REF_SetUnsynchronised(void)
{
  struct timespec now ;
  struct timespec now_raw ;
  double uncorrected_offset ;
  double tmp ;
  double tmp___0 ;
  {
  assert(initialised___1);
  if ((unsigned int )mode != 0U) {
    special_mode_sync(0, 0.0);
    return;
  }
  LCL_ReadRawTime(& now_raw);
  LCL_GetOffsetCorrection(& now_raw, & uncorrected_offset, (double *)((void *)0));
  UTI_AddDoubleToTimespec((struct timespec const *)(& now_raw), uncorrected_offset,
                          & now);
  if (fb_drifts) {
    schedule_fb_drift();
  }
  update_leap_status((NTP_Leap )3, (time_t )0, 0);
  our_ref_ip.family = (uint16_t )1;
  our_ref_ip.addr.in4 = (uint32_t )0;
  our_stratum = 0;
  are_we_synchronised = 0;
  LCL_SetSyncStatus(0, 0.0, 0.0);
  tmp = get_root_dispersion(& now);
  tmp___0 = LCL_ReadAbsoluteFrequency();
  write_log(& now, 0, tmp___0, 0.0, 0.0, uncorrected_offset, our_root_delay / 2.0 + tmp);
  return;
}
}
void REF_UpdateLeapStatus(NTP_Leap leap )
{
  struct timespec raw_now ;
  struct timespec now ;
  {
  if (! are_we_synchronised) {
    return;
  }
  SCH_GetLastEventTime(& now, (double *)((void *)0), & raw_now);
  update_leap_status(leap, raw_now.tv_sec, 0);
  update_sync_status(& now);
  return;
}
}
void REF_GetReferenceParams(struct timespec *local_time , int *is_synchronised , NTP_Leap *leap_status ,
                            int *stratum , uint32_t *ref_id , struct timespec *ref_time ,
                            double *root_delay , double *root_dispersion )
{
  double dispersion ;
  double delta ;
  {
  assert(initialised___1);
  if (are_we_synchronised) {
    dispersion = get_root_dispersion(local_time);
  } else {
    dispersion = 0.0;
  }
  if (are_we_synchronised) {
    if (enable_local_stratum) {
      if (our_root_delay / (double )2 + dispersion > local_distance___0) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0:
      *is_synchronised = 1;
      *stratum = our_stratum;
      if (! leap_in_progress) {
        *leap_status = our_leap_status;
      } else {
        *leap_status = (NTP_Leap )3;
      }
      *ref_id = our_ref_id;
      *ref_time = our_ref_time;
      *root_delay = our_root_delay;
      *root_dispersion = dispersion;
    }
  } else
  _L:
  if (enable_local_stratum) {
    *is_synchronised = 0;
    *stratum = local_stratum___0;
    *ref_id = (uint32_t )0x7F7F0101UL;
    delta = UTI_DiffTimespecsToDouble((struct timespec const *)local_time, (struct timespec const *)(& local_ref_time));
    if (delta > 64.0) {
      UTI_AddDoubleToTimespec((struct timespec const *)local_time, - 1.0, & local_ref_time);
      fuzz_ref_time(& local_ref_time);
    } else
    if (delta < 1.0) {
      UTI_AddDoubleToTimespec((struct timespec const *)local_time, - 1.0, & local_ref_time);
      fuzz_ref_time(& local_ref_time);
    }
    *ref_time = local_ref_time;
    *leap_status = (NTP_Leap )0;
    *root_delay = 0.0;
    *root_dispersion = 0.0;
  } else {
    *is_synchronised = 0;
    *leap_status = (NTP_Leap )3;
    *stratum = 16;
    *ref_id = (uint32_t )0x0UL;
    UTI_ZeroTimespec(ref_time);
    *root_dispersion = 1.0;
    *root_delay = 1.0;
  }
  return;
}
}
int REF_GetOurStratum(void)
{
  struct timespec now_cooked ;
  struct timespec ref_time ;
  int synchronised ;
  int stratum ;
  NTP_Leap leap_status ;
  uint32_t ref_id ;
  double root_delay ;
  double root_dispersion ;
  {
  SCH_GetLastEventTime(& now_cooked, (double *)((void *)0), (struct timespec *)((void *)0));
  REF_GetReferenceParams(& now_cooked, & synchronised, & leap_status, & stratum, & ref_id,
                         & ref_time, & root_delay, & root_dispersion);
  return (stratum);
}
}
int REF_GetOrphanStratum(void)
{
  {
  if (! enable_local_stratum) {
    return (16);
  } else
  if (! local_orphan___0) {
    return (16);
  } else
  if ((unsigned int )mode != 0U) {
    return (16);
  }
  return (local_stratum___0);
}
}
double REF_GetSkew(void)
{
  {
  return (our_skew);
}
}
void REF_ModifyMaxupdateskew(double new_max_update_skew )
{
  {
  max_update_skew___0 = new_max_update_skew * 1.0e-6;
  return;
}
}
void REF_ModifyMakestep(int limit , double threshold )
{
  {
  make_step_limit___0 = limit;
  make_step_threshold___0 = threshold;
  return;
}
}
void REF_EnableLocal(int stratum , double distance , int orphan )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  enable_local_stratum = 1;
  if (stratum < 15) {
    tmp___1 = stratum;
  } else {
    tmp___1 = 15;
  }
  if (1 > tmp___1) {
    local_stratum___0 = 1;
  } else {
    if (stratum < 15) {
      tmp___0 = stratum;
    } else {
      tmp___0 = 15;
    }
    local_stratum___0 = tmp___0;
  }
  local_distance___0 = distance;
  local_orphan___0 = ! (! orphan);
  return;
}
}
void REF_DisableLocal(void)
{
  {
  enable_local_stratum = 0;
  return;
}
}
static int is_leap_close(time_t t )
{
  int tmp ;
  {
  if (leap_when != 0L) {
    if (t >= leap_when - 5L) {
      if (t < leap_when + 5L) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
int REF_IsLeapSecondClose(struct timespec *ts , double offset )
{
  struct timespec now ;
  struct timespec now_raw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  SCH_GetLastEventTime(& now, (double *)((void *)0), & now_raw);
  tmp = is_leap_close(now.tv_sec);
  if (tmp) {
    return (1);
  } else {
    tmp___0 = is_leap_close(now_raw.tv_sec);
    if (tmp___0) {
      return (1);
    }
  }
  if (ts) {
    tmp___1 = is_leap_close(ts->tv_sec);
    if (tmp___1) {
      return (1);
    } else {
      tmp___2 = is_leap_close((time_t )((double )ts->tv_sec + offset));
      if (tmp___2) {
        return (1);
      }
    }
  }
  return (0);
}
}
int REF_GetTaiOffset(struct timespec *ts )
{
  int tai_offset ;
  {
  get_tz_leap(ts->tv_sec, & tai_offset);
  return (tai_offset);
}
}
void REF_GetTrackingReport(RPT_TrackingReport *rep )
{
  struct timespec now_raw ;
  struct timespec now_cooked ;
  double correction ;
  int synchronised ;
  {
  LCL_ReadRawTime(& now_raw);
  LCL_GetOffsetCorrection(& now_raw, & correction, (double *)((void *)0));
  UTI_AddDoubleToTimespec((struct timespec const *)(& now_raw), correction, & now_cooked);
  REF_GetReferenceParams(& now_cooked, & synchronised, & rep->leap_status, & rep->stratum,
                         & rep->ref_id, & rep->ref_time, & rep->root_delay, & rep->root_dispersion);
  if (rep->stratum == 16) {
    if (! synchronised) {
      rep->stratum = 0;
    }
  }
  rep->ip_addr.family = (uint16_t )0;
  rep->current_correction = correction;
  rep->freq_ppm = LCL_ReadAbsoluteFrequency();
  rep->resid_freq_ppm = 0.0;
  rep->skew_ppm = 0.0;
  rep->last_update_interval = last_ref_update_interval;
  rep->last_offset = last_offset;
  rep->rms_offset = sqrt(avg2_offset);
  if (synchronised) {
    rep->ip_addr = our_ref_ip;
    rep->resid_freq_ppm = 1.0e6 * our_residual_freq;
    rep->skew_ppm = 1.0e6 * our_skew;
  }
  return;
}
}
void RGR_WeightedRegression(double *x , double *y , double *w , int n , double *b0 ,
                            double *b1 , double *s2 , double *sb0 , double *sb1 ) ;
double RGR_GetTCoef(int dof ) ;
double RGR_GetChi2Coef(int dof ) ;
int RGR_FindBestRegression(double *x , double *y , double *w , int n , int m , int min_samples___0 ,
                           double *b0 , double *b1 , double *s2 , double *sb0 , double *sb1 ,
                           int *new_start , int *n_runs___0 , int *dof ) ;
int RGR_FindBestRobustRegression(double *x , double *y , int n , double tol , double *b0 ,
                                 double *b1 , int *n_runs___0 , int *best_start ) ;
int RGR_MultipleRegress(double *x1 , double *x2 , double *y , int n , double *b2 ) ;
double RGR_FindMedian(double *x , int n ) ;
void RGR_WeightedRegression(double *x , double *y , double *w , int n , double *b0 ,
                            double *b1 , double *s2 , double *sb0 , double *sb1 )
{
  double P ;
  double Q ;
  double U ;
  double V ;
  double W ;
  double diff ;
  double u ;
  double ui ;
  double aa ;
  int i ;
  {
  assert(n >= 3);
  U = (double )0;
  W = U;
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < n)) {
      goto while_break;
    }
    U += *(x + i) / *(w + i);
    W += 1.0 / *(w + i);
    i ++;
  }
  while_break: ;
  }
  u = U / W;
  V = 0.0;
  Q = V;
  P = Q;
  i = 0;
  {
  while (1) {
    while_continue___0: ;
    if (! (i < n)) {
      goto while_break___0;
    }
    ui = *(x + i) - u;
    P += *(y + i) / *(w + i);
    Q += (*(y + i) * ui) / *(w + i);
    V += (ui * ui) / *(w + i);
    i ++;
  }
  while_break___0: ;
  }
  *b1 = Q / V;
  *b0 = P / W - *b1 * u;
  *s2 = 0.0;
  i = 0;
  {
  while (1) {
    while_continue___1: ;
    if (! (i < n)) {
      goto while_break___1;
    }
    diff = (*(y + i) - *b0) - *b1 * *(x + i);
    *s2 += (diff * diff) / *(w + i);
    i ++;
  }
  while_break___1: ;
  }
  *s2 /= (double )(n - 2);
  *sb1 = sqrt(*s2 / V);
  aa = u * *sb1;
  *sb0 = sqrt(*s2 / W + aa * aa);
  *s2 *= (double )n / W;
  return;
}
}
static float const coefs[40] =
  { (float const )636.6, (float const )31.6, (float const )12.92, (float const )8.61,
        (float const )6.869, (float const )5.959, (float const )5.408, (float const )5.041,
        (float const )4.781, (float const )4.587, (float const )4.437, (float const )4.318,
        (float const )4.221, (float const )4.140, (float const )4.073, (float const )4.015,
        (float const )3.965, (float const )3.922, (float const )3.883, (float const )3.850,
        (float const )3.819, (float const )3.792, (float const )3.768, (float const )3.745,
        (float const )3.725, (float const )3.707, (float const )3.690, (float const )3.674,
        (float const )3.659, (float const )3.646, (float const )3.633, (float const )3.622,
        (float const )3.611, (float const )3.601, (float const )3.591, (float const )3.582,
        (float const )3.574, (float const )3.566, (float const )3.558, (float const )3.551};
double RGR_GetTCoef(int dof )
{
  {
  if (dof <= 40) {
    return ((double )coefs[dof - 1]);
  } else {
    return (3.5);
  }
}
}
static float const coefs___0[64] =
  { (float const )2.706, (float const )4.605, (float const )6.251, (float const )7.779,
        (float const )9.236, (float const )10.645, (float const )12.017, (float const )13.362,
        (float const )14.684, (float const )15.987, (float const )17.275, (float const )18.549,
        (float const )19.812, (float const )21.064, (float const )22.307, (float const )23.542,
        (float const )24.769, (float const )25.989, (float const )27.204, (float const )28.412,
        (float const )29.615, (float const )30.813, (float const )32.007, (float const )33.196,
        (float const )34.382, (float const )35.563, (float const )36.741, (float const )37.916,
        (float const )39.087, (float const )40.256, (float const )41.422, (float const )42.585,
        (float const )43.745, (float const )44.903, (float const )46.059, (float const )47.212,
        (float const )48.363, (float const )49.513, (float const )50.660, (float const )51.805,
        (float const )52.949, (float const )54.090, (float const )55.230, (float const )56.369,
        (float const )57.505, (float const )58.641, (float const )59.774, (float const )60.907,
        (float const )62.038, (float const )63.167, (float const )64.295, (float const )65.422,
        (float const )66.548, (float const )67.673, (float const )68.796, (float const )69.919,
        (float const )71.040, (float const )72.160, (float const )73.279, (float const )74.397,
        (float const )75.514, (float const )76.630, (float const )77.745, (float const )78.860};
double RGR_GetChi2Coef(int dof )
{
  {
  if (dof <= 64) {
    return ((double )coefs___0[dof - 1]);
  } else {
    return (1.2 * (double )dof);
  }
}
}
static char critical_runs[130] =
  { (char)0, (char)0, (char)0, (char)0,
        (char)0, (char)0, (char)0, (char)0,
        (char)2, (char)3, (char)3, (char)3,
        (char)4, (char)4, (char)5, (char)5,
        (char)5, (char)6, (char)6, (char)7,
        (char)7, (char)7, (char)8, (char)8,
        (char)9, (char)9, (char)9, (char)10,
        (char)10, (char)11, (char)11, (char)11,
        (char)12, (char)12, (char)13, (char)13,
        (char)14, (char)14, (char)14, (char)15,
        (char)15, (char)16, (char)16, (char)17,
        (char)17, (char)18, (char)18, (char)18,
        (char)19, (char)19, (char)20, (char)20,
        (char)21, (char)21, (char)21, (char)22,
        (char)22, (char)23, (char)23, (char)24,
        (char)24, (char)25, (char)25, (char)26,
        (char)26, (char)26, (char)27, (char)27,
        (char)28, (char)28, (char)29, (char)29,
        (char)30, (char)30, (char)30, (char)31,
        (char)31, (char)32, (char)32, (char)33,
        (char)33, (char)34, (char)34, (char)35,
        (char)35, (char)35, (char)36, (char)36,
        (char)37, (char)37, (char)38, (char)38,
        (char)39, (char)39, (char)40, (char)40,
        (char)40, (char)41, (char)41, (char)42,
        (char)42, (char)43, (char)43, (char)44,
        (char)44, (char)45, (char)45, (char)46,
        (char)46, (char)46, (char)47, (char)47,
        (char)48, (char)48, (char)49, (char)49,
        (char)50, (char)50, (char)51, (char)51,
        (char)52, (char)52, (char)52, (char)53,
        (char)53, (char)54, (char)54, (char)55,
        (char)55, (char)56};
static int n_runs_from_residuals(double *resid , int n )
{
  int nruns ;
  int i ;
  {
  nruns = 1;
  i = 1;
  {
  while (1) {
    while_continue: ;
    if (! (i < n)) {
      goto while_break;
    }
    if (*(resid + (i - 1)) < 0.0) {
      if (! (*(resid + i) < 0.0)) {
        goto _L;
      }
    } else
    _L:
    if (*(resid + (i - 1)) > 0.0) {
      if (! (*(resid + i) > 0.0)) {
        nruns ++;
      }
    } else {
      nruns ++;
    }
    i ++;
  }
  while_break: ;
  }
  return (nruns);
}
}
int RGR_FindBestRegression(double *x , double *y , double *w , int n , int m , int min_samples___0 ,
                           double *b0 , double *b1 , double *s2 , double *sb0 , double *sb1 ,
                           int *new_start , int *n_runs___0 , int *dof )
{
  double P ;
  double Q ;
  double U ;
  double V ;
  double W ;
  double resid[128] ;
  double ss ;
  double a ;
  double b ;
  double u ;
  double ui ;
  double aa ;
  int start ;
  int resid_start ;
  int nruns ;
  int npoints ;
  int i ;
  int tmp ;
  {
  if (n <= 64) {
    if (m >= 0) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  assert(tmp);
  assert((unsigned long )(n * 2) < sizeof(critical_runs) / sizeof(critical_runs[0]));
  if (n < 3) {
    return (0);
  }
  start = 0;
  {
  while (1) {
    while_continue: ;
    U = (double )0;
    W = U;
    i = start;
    {
    while (1) {
      while_continue___0: ;
      if (! (i < n)) {
        goto while_break___0;
      }
      U += *(x + i) / *(w + i);
      W += 1.0 / *(w + i);
      i ++;
    }
    while_break___0: ;
    }
    u = U / W;
    V = 0.0;
    Q = V;
    P = Q;
    i = start;
    {
    while (1) {
      while_continue___1: ;
      if (! (i < n)) {
        goto while_break___1;
      }
      ui = *(x + i) - u;
      P += *(y + i) / *(w + i);
      Q += (*(y + i) * ui) / *(w + i);
      V += (ui * ui) / *(w + i);
      i ++;
    }
    while_break___1: ;
    }
    b = Q / V;
    a = P / W - b * u;
    resid_start = n - (n - start) * 2;
    if (resid_start < - m) {
      resid_start = - m;
    }
    i = resid_start;
    {
    while (1) {
      while_continue___2: ;
      if (! (i < n)) {
        goto while_break___2;
      }
      resid[i - resid_start] = (*(y + i) - a) - b * *(x + i);
      i ++;
    }
    while_break___2: ;
    }
    nruns = n_runs_from_residuals(resid, n - resid_start);
    if (nruns > (int )critical_runs[n - resid_start]) {
      goto _L;
    } else
    if (n - start <= 3) {
      goto _L;
    } else
    if (n - start <= min_samples___0) {
      _L:
      if (start != resid_start) {
        nruns = n_runs_from_residuals(resid + (start - resid_start), n - start);
      }
      goto while_break;
    } else {
      start ++;
    }
  }
  while_break: ;
  }
  *b1 = b;
  *b0 = a;
  ss = 0.0;
  i = start;
  {
  while (1) {
    while_continue___3: ;
    if (! (i < n)) {
      goto while_break___3;
    }
    ss += (resid[i - resid_start] * resid[i - resid_start]) / *(w + i);
    i ++;
  }
  while_break___3: ;
  }
  npoints = n - start;
  ss /= (double )(npoints - 2);
  *sb1 = sqrt(ss / V);
  aa = u * *sb1;
  *sb0 = sqrt(ss / W + aa * aa);
  *s2 = (ss * (double )npoints) / W;
  *new_start = start;
  *dof = npoints - 2;
  *n_runs___0 = nruns;
  return (1);
}
}
static double find_ordered_entry_with_flags(double *x , int n , int index___0 , char *flags )
{
  int u ;
  int v ;
  int l ;
  int r ;
  double temp ;
  double piv ;
  int pivind ;
  char tmp ;
  {
  assert(index___0 >= 0);
  if (*(flags + index___0)) {
    return (*(x + index___0));
  }
  v = index___0;
  u = v;
  {
  while (1) {
    while_continue: ;
    if (u > 0) {
      if (! (! *(flags + u))) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    u --;
  }
  while_break: ;
  }
  if (*(flags + u)) {
    u ++;
  }
  {
  while (1) {
    while_continue___0: ;
    if (v < n - 1) {
      if (! (! *(flags + v))) {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
    v ++;
  }
  while_break___0: ;
  }
  if (*(flags + v)) {
    v --;
  }
  {
  while (1) {
    while_continue___1: ;
    if (v - u < 2) {
      if (*(x + v) < *(x + u)) {
        temp = *(x + v);
        *(x + v) = *(x + u);
        *(x + u) = temp;
      }
      tmp = (char)1;
      *(flags + u) = tmp;
      *(flags + v) = tmp;
      return (*(x + index___0));
    } else {
      pivind = (u + v) >> 1;
      temp = *(x + u);
      *(x + u) = *(x + pivind);
      *(x + pivind) = temp;
      piv = *(x + u);
      l = u + 1;
      r = v;
      {
      while (1) {
        while_continue___2: ;
        {
        while (1) {
          while_continue___3: ;
          if (l < v) {
            if (! (*(x + l) < piv)) {
              goto while_break___3;
            }
          } else {
            goto while_break___3;
          }
          l ++;
        }
        while_break___3: ;
        }
        {
        while (1) {
          while_continue___4: ;
          if (! (*(x + r) > piv)) {
            goto while_break___4;
          }
          r --;
        }
        while_break___4: ;
        }
        if (r <= l) {
          goto while_break___2;
        }
        temp = *(x + l);
        *(x + l) = *(x + r);
        *(x + r) = temp;
        l ++;
        r --;
      }
      while_break___2: ;
      }
      temp = *(x + u);
      *(x + u) = *(x + r);
      *(x + r) = temp;
      *(flags + r) = (char)1;
      if (index___0 == r) {
        return (*(x + r));
      } else
      if (index___0 < r) {
        v = r - 1;
      } else
      if (index___0 > r) {
        u = l;
      }
    }
  }
  while_break___1: ;
  }
}
}
static double find_median(double *x , int n )
{
  int k ;
  char flags[64] ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  {
  memset((void *)(flags), 0, (unsigned long )n * sizeof(flags[0]));
  k = n >> 1;
  if (n & 1) {
    tmp = find_ordered_entry_with_flags(x, n, k, flags);
    return (tmp);
  } else {
    tmp___0 = find_ordered_entry_with_flags(x, n, k, flags);
    tmp___1 = find_ordered_entry_with_flags(x, n, k - 1, flags);
    return (0.5 * (tmp___0 + tmp___1));
  }
}
}
double RGR_FindMedian(double *x , int n )
{
  double tmp[64] ;
  int tmp___0 ;
  double tmp___1 ;
  {
  if (n > 0) {
    if (n <= 64) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  assert(tmp___0);
  memcpy((void *)(tmp), (void const *)x, (unsigned long )n * sizeof(tmp[0]));
  tmp___1 = find_median(tmp, n);
  return (tmp___1);
}
}
static void eval_robust_residual(double *x , double *y , int n , double b , double *aa ,
                                 double *rr )
{
  int i ;
  double a ;
  double res ;
  double del ;
  double d[64] ;
  {
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < n)) {
      goto while_break;
    }
    d[i] = *(y + i) - b * *(x + i);
    i ++;
  }
  while_break: ;
  }
  a = find_median(d, n);
  res = 0.0;
  i = 0;
  {
  while (1) {
    while_continue___0: ;
    if (! (i < n)) {
      goto while_break___0;
    }
    del = (*(y + i) - a) - b * *(x + i);
    if (del > 0.0) {
      res += *(x + i);
    } else
    if (del < 0.0) {
      res -= *(x + i);
    }
    i ++;
  }
  while_break___0: ;
  }
  *aa = a;
  *rr = res;
  return;
}
}
int RGR_FindBestRobustRegression(double *x , double *y , int n , double tol , double *b0 ,
                                 double *b1 , int *n_runs___0 , int *best_start )
{
  int i ;
  int start ;
  int n_points ;
  double a ;
  double b ;
  double P ;
  double U ;
  double V ;
  double W ;
  double X ;
  double resid ;
  double resids[64] ;
  double blo ;
  double bhi ;
  double bmid ;
  double rlo ;
  double rhi ;
  double rmid ;
  double s2 ;
  double sb ;
  double incr ;
  double mx ;
  double dx ;
  double my ;
  double dy ;
  int nruns ;
  {
  nruns = 0;
  assert(n <= 64);
  if (n < 2) {
    return (0);
  } else
  if (n == 2) {
    *b1 = (*(y + 1) - *(y + 0)) / (*(x + 1) - *(x + 0));
    *b0 = *(y + 0) - *b1 * *(x + 0);
    *n_runs___0 = 0;
    *best_start = 0;
    return (1);
  }
  start = 0;
  {
  while (1) {
    while_continue: ;
    n_points = n - start;
    U = 0.0;
    P = U;
    i = start;
    {
    while (1) {
      while_continue___0: ;
      if (! (i < n)) {
        goto while_break___0;
      }
      P += *(y + i);
      U += *(x + i);
      i ++;
    }
    while_break___0: ;
    }
    W = (double )n_points;
    my = P / W;
    mx = U / W;
    V = 0.0;
    X = V;
    i = start;
    {
    while (1) {
      while_continue___1: ;
      if (! (i < n)) {
        goto while_break___1;
      }
      dy = *(y + i) - my;
      dx = *(x + i) - mx;
      X += dy * dx;
      V += dx * dx;
      i ++;
    }
    while_break___1: ;
    }
    b = X / V;
    a = my - b * mx;
    s2 = 0.0;
    i = start;
    {
    while (1) {
      while_continue___2: ;
      if (! (i < n)) {
        goto while_break___2;
      }
      resid = (*(y + i) - a) - b * *(x + i);
      s2 += resid * resid;
      i ++;
    }
    while_break___2: ;
    }
    sb = sqrt((s2 * W) / V);
    if (sb > tol) {
      incr = sb;
    } else {
      incr = tol;
    }
    {
    while (1) {
      while_continue___3: ;
      incr *= 2.0;
      if (incr > 100.0) {
        return (0);
      }
      blo = b - incr;
      bhi = b + incr;
      eval_robust_residual(x + start, y + start, n_points, blo, & a, & rlo);
      eval_robust_residual(x + start, y + start, n_points, bhi, & a, & rhi);
      if (! (rlo * rhi >= 0.0)) {
        goto while_break___3;
      }
    }
    while_break___3: ;
    }
    {
    while (1) {
      while_continue___4: ;
      bmid = 0.5 * (blo + bhi);
      if (blo < bmid) {
        if (! (bmid < bhi)) {
          goto while_break___4;
        }
      } else {
        goto while_break___4;
      }
      eval_robust_residual(x + start, y + start, n_points, bmid, & a, & rmid);
      if (rmid == 0.0) {
        goto while_break___4;
      } else
      if (rmid * rlo > 0.0) {
        blo = bmid;
        rlo = rmid;
      } else
      if (rmid * rhi > 0.0) {
        bhi = bmid;
        rhi = rmid;
      } else {
        assert(0);
      }
      if (! (bhi - blo > tol)) {
        goto while_break___4;
      }
    }
    while_break___4: ;
    }
    *b0 = a;
    *b1 = bmid;
    if (n_points == 3) {
      goto while_break;
    }
    i = start;
    {
    while (1) {
      while_continue___5: ;
      if (! (i < n)) {
        goto while_break___5;
      }
      resids[i] = (*(y + i) - a) - bmid * *(x + i);
      i ++;
    }
    while_break___5: ;
    }
    nruns = n_runs_from_residuals(resids + start, n_points);
    if (nruns > (int )critical_runs[n_points]) {
      goto while_break;
    } else {
      start ++;
    }
  }
  while_break: ;
  }
  *n_runs___0 = nruns;
  *best_start = start;
  return (1);
}
}
int RGR_MultipleRegress(double *x1 , double *x2 , double *y , int n , double *b2 )
{
  double Sx1 ;
  double Sx2 ;
  double Sx1x1 ;
  double Sx1x2 ;
  double Sx2x2 ;
  double Sx1y ;
  double Sx2y ;
  double Sy ;
  double U ;
  double V ;
  double V1 ;
  double V2 ;
  double V3 ;
  int i ;
  double tmp ;
  double tmp___0 ;
  {
  if (n < 4) {
    return (0);
  }
  Sy = 0.0;
  Sx2y = Sy;
  Sx1y = Sx2y;
  Sx2x2 = Sx1y;
  Sx1x2 = Sx2x2;
  Sx1x1 = Sx1x2;
  Sx2 = Sx1x1;
  Sx1 = Sx2;
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < n)) {
      goto while_break;
    }
    Sx1 += *(x1 + i);
    Sx2 += *(x2 + i);
    Sx1x1 += *(x1 + i) * *(x1 + i);
    Sx1x2 += *(x1 + i) * *(x2 + i);
    Sx2x2 += *(x2 + i) * *(x2 + i);
    Sx1y += *(x1 + i) * *(y + i);
    Sx2y += *(x2 + i) * *(y + i);
    Sy += *(y + i);
    i ++;
  }
  while_break: ;
  }
  U = (((double )n * (Sx1x2 * Sx1y - Sx1x1 * Sx2y) + (Sx1 * Sx1) * Sx2y) - (Sx1 * Sx2) * Sx1y) + Sy * (Sx2 * Sx1x1 - Sx1 * Sx1x2);
  V1 = (double )n * (Sx1x2 * Sx1x2 - Sx1x1 * Sx2x2);
  V2 = (Sx1 * Sx1) * Sx2x2 + (Sx2 * Sx2) * Sx1x1;
  V3 = ((- 2.0 * Sx1) * Sx2) * Sx1x2;
  V = (V1 + V2) + V3;
  tmp = fabs(V);
  tmp___0 = fabs(V3);
  if (tmp * 1.0e10 <= (- V1 + V2) + tmp___0) {
    return (0);
  }
  *b2 = U / V;
  return (1);
}
}
int RTC_Linux_Initialise(void) ;
void RTC_Linux_Finalise(void) ;
int RTC_Linux_TimePreInit(time_t driftfile_time ) ;
void RTC_Linux_TimeInit(void (*after_hook)(void * ) , void *anything ) ;
void RTC_Linux_StartMeasurements(void) ;
int RTC_Linux_WriteParameters(void) ;
int RTC_Linux_GetReport(RPT_RTC_Report *report ) ;
int RTC_Linux_Trim(void) ;
extern void RTC_Linux_CycleLogFile(void) ;
static int driver_initialised = 0;
static int driver_preinit_ok = 0;
static struct __anonstruct_driver_285539026 driver =
     {& RTC_Linux_Initialise, & RTC_Linux_Finalise, & RTC_Linux_TimePreInit, & RTC_Linux_TimeInit,
    & RTC_Linux_StartMeasurements, & RTC_Linux_WriteParameters, & RTC_Linux_GetReport,
    & RTC_Linux_Trim};
static time_t get_driftfile_time(void)
{
  struct stat buf ;
  char *drift_file___1 ;
  int tmp ;
  {
  drift_file___1 = CNF_GetDriftFile();
  if (! drift_file___1) {
    return ((time_t )0);
  }
  tmp = stat((char const * __restrict )drift_file___1, (struct stat * __restrict )(& buf));
  if (tmp) {
    return ((time_t )0);
  }
  return (buf.st_mtim.tv_sec);
}
}
static void apply_driftfile_time(time_t t )
{
  struct timespec now ;
  int tmp ;
  {
  LCL_ReadCookedTime(& now, (double *)((void *)0));
  if (now.tv_sec < t) {
    tmp = LCL_ApplyStepOffset((double )(now.tv_sec - t));
    if (tmp) {
      LOG_Message((LOG_Severity )0, (char const *)"System time restored from driftfile");
    }
  }
  return;
}
}
void RTC_Initialise(int initial_set )
{
  time_t driftfile_time ;
  char *file_name ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  if (initial_set) {
    driftfile_time = get_driftfile_time();
    if (driver.time_pre_init) {
      tmp = (*(driver.time_pre_init))(driftfile_time);
      if (tmp) {
        driver_preinit_ok = 1;
      } else {
        goto _L;
      }
    } else {
      _L:
      driver_preinit_ok = 0;
      if (driftfile_time) {
        apply_driftfile_time(driftfile_time);
      }
    }
  }
  driver_initialised = 0;
  file_name = CNF_GetRtcFile();
  if (file_name) {
    tmp___0 = CNF_GetRtcSync();
    if (tmp___0) {
      {
      while (1) {
        while_continue: ;
        LOG_Message((LOG_Severity )3, (char const *)"rtcfile directive cannot be used with rtcsync");
        exit(1);
        goto while_break;
      }
      while_break: ;
      }
    }
    if (driver.init) {
      tmp___1 = (*(driver.init))();
      if (tmp___1) {
        driver_initialised = 1;
      } else {
        LOG_Message((LOG_Severity )2, (char const *)"RTC driver could not be initialised");
      }
    } else {
      LOG_Message((LOG_Severity )2, (char const *)"RTC not supported on this operating system");
    }
  }
  return;
}
}
void RTC_Finalise(void)
{
  {
  if (driver_initialised) {
    (*(driver.fini))();
  }
  return;
}
}
void RTC_TimeInit(void (*after_hook)(void * ) , void *anything )
{
  {
  if (driver_initialised) {
    if (driver_preinit_ok) {
      (*(driver.time_init))(after_hook, anything);
    } else {
      (*after_hook)(anything);
    }
  } else {
    (*after_hook)(anything);
  }
  return;
}
}
void RTC_StartMeasurements(void)
{
  {
  if (driver_initialised) {
    (*(driver.start_measurements))();
  }
  return;
}
}
int RTC_WriteParameters(void)
{
  int tmp ;
  {
  if (driver_initialised) {
    tmp = (*(driver.write_parameters))();
    return (tmp);
  } else {
    return (1);
  }
}
}
int RTC_GetReport(RPT_RTC_Report *report )
{
  int tmp ;
  {
  if (driver_initialised) {
    tmp = (*(driver.get_report))(report);
    return (tmp);
  } else {
    return (0);
  }
}
}
int RTC_Trim(void)
{
  int tmp ;
  {
  if (driver_initialised) {
    tmp = (*(driver.trim))();
    return (tmp);
  } else {
    return (0);
  }
}
}
SPF_Instance SPF_CreateInstance(int min_samples___0 , int max_samples___0 , double max_dispersion ,
                                double combine_ratio ) ;
void SPF_DestroyInstance(SPF_Instance filter ) ;
int SPF_AccumulateSample(SPF_Instance filter , NTP_Sample *sample ) ;
int SPF_GetLastSample(SPF_Instance filter , NTP_Sample *sample ) ;
int SPF_GetNumberOfSamples(SPF_Instance filter ) ;
double SPF_GetAvgSampleDispersion(SPF_Instance filter ) ;
void SPF_DropSamples(SPF_Instance filter ) ;
int SPF_GetFilteredSample(SPF_Instance filter , NTP_Sample *sample ) ;
void SPF_SlewSamples(SPF_Instance filter , struct timespec *when , double dfreq ,
                     double doffset ) ;
void SPF_AddDispersion(SPF_Instance filter , double dispersion ) ;
SPF_Instance SPF_CreateInstance(int min_samples___0 , int max_samples___0 , double max_dispersion ,
                                double combine_ratio )
{
  SPF_Instance filter ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  {
  tmp = Malloc(sizeof(struct SPF_Instance_Record ));
  filter = (struct SPF_Instance_Record *)tmp;
  if (min_samples___0 < 256) {
    tmp___2 = min_samples___0;
  } else {
    tmp___2 = 256;
  }
  if (1 > tmp___2) {
    min_samples___0 = 1;
  } else {
    if (min_samples___0 < 256) {
      tmp___1 = min_samples___0;
    } else {
      tmp___1 = 256;
    }
    min_samples___0 = tmp___1;
  }
  if (max_samples___0 < 256) {
    tmp___5 = max_samples___0;
  } else {
    tmp___5 = 256;
  }
  if (1 > tmp___5) {
    max_samples___0 = 1;
  } else {
    if (max_samples___0 < 256) {
      tmp___4 = max_samples___0;
    } else {
      tmp___4 = 256;
    }
    max_samples___0 = tmp___4;
  }
  if (min_samples___0 > max_samples___0) {
    max_samples___0 = min_samples___0;
  } else {
    max_samples___0 = max_samples___0;
  }
  if (combine_ratio < 1.0) {
    tmp___8 = combine_ratio;
  } else {
    tmp___8 = 1.0;
  }
  if (0.0 > tmp___8) {
    combine_ratio = 0.0;
  } else {
    if (combine_ratio < 1.0) {
      tmp___7 = combine_ratio;
    } else {
      tmp___7 = 1.0;
    }
    combine_ratio = tmp___7;
  }
  filter->min_samples = min_samples___0;
  filter->max_samples = max_samples___0;
  filter->index = -1;
  filter->used = 0;
  filter->last = -1;
  filter->avg_var_n = 0;
  tmp___9 = LCL_GetSysPrecisionAsQuantum();
  tmp___10 = LCL_GetSysPrecisionAsQuantum();
  filter->avg_var = tmp___9 * tmp___10;
  filter->max_var = max_dispersion * max_dispersion;
  filter->combine_ratio = combine_ratio;
  tmp___11 = Malloc2((size_t )filter->max_samples, sizeof(NTP_Sample ));
  filter->samples = (NTP_Sample *)tmp___11;
  tmp___12 = Malloc2((size_t )filter->max_samples, sizeof(int ));
  filter->selected = (int *)tmp___12;
  tmp___13 = Malloc2((size_t )filter->max_samples, sizeof(double ));
  filter->x_data = (double *)tmp___13;
  tmp___14 = Malloc2((size_t )filter->max_samples, sizeof(double ));
  filter->y_data = (double *)tmp___14;
  tmp___15 = Malloc2((size_t )filter->max_samples, sizeof(double ));
  filter->w_data = (double *)tmp___15;
  return (filter);
}
}
void SPF_DestroyInstance(SPF_Instance filter )
{
  {
  free((void *)filter->samples);
  free((void *)filter->selected);
  free((void *)filter->x_data);
  free((void *)filter->y_data);
  free((void *)filter->w_data);
  free((void *)filter);
  return;
}
}
static int check_sample(SPF_Instance filter , NTP_Sample *sample )
{
  char *tmp ;
  int tmp___0 ;
  {
  if (filter->used <= 0) {
    return (1);
  }
  tmp___0 = UTI_CompareTimespecs((struct timespec const *)(& (filter->samples + filter->last)->time),
                                 (struct timespec const *)(& sample->time));
  if (tmp___0 >= 0) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  return (1);
}
}
int SPF_AccumulateSample(SPF_Instance filter , NTP_Sample *sample )
{
  int tmp ;
  char *tmp___0 ;
  {
  tmp = check_sample(filter, sample);
  if (! tmp) {
    return (0);
  }
  (filter->index) ++;
  filter->index %= filter->max_samples;
  filter->last = filter->index;
  if (filter->used < filter->max_samples) {
    (filter->used) ++;
  }
  *(filter->samples + filter->index) = *sample;
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  return (1);
}
}
int SPF_GetLastSample(SPF_Instance filter , NTP_Sample *sample )
{
  {
  if (filter->last < 0) {
    return (0);
  }
  *sample = *(filter->samples + filter->last);
  return (1);
}
}
int SPF_GetNumberOfSamples(SPF_Instance filter )
{
  {
  return (filter->used);
}
}
double SPF_GetAvgSampleDispersion(SPF_Instance filter )
{
  double tmp ;
  {
  tmp = sqrt(filter->avg_var);
  return (tmp);
}
}
void SPF_DropSamples(SPF_Instance filter )
{
  {
  filter->index = -1;
  filter->used = 0;
  return;
}
}
static NTP_Sample const *tmp_sort_samples ;
static int compare_samples(void const *a , void const *b )
{
  NTP_Sample const *s1 ;
  NTP_Sample const *s2 ;
  {
  s1 = tmp_sort_samples + *((int *)a);
  s2 = tmp_sort_samples + *((int *)b);
  if (s1->offset < s2->offset) {
    return (-1);
  } else
  if (s1->offset > s2->offset) {
    return (1);
  }
  return (0);
}
}
static int select_samples(SPF_Instance filter )
{
  int i ;
  int j ;
  int k ;
  int o ;
  int from ;
  int to ;
  int *selected ;
  double min_dispersion ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  {
  if (filter->used < filter->min_samples) {
    return (0);
  }
  selected = filter->selected;
  if (filter->used > 4) {
    i = 1;
    min_dispersion = (filter->samples + 0)->peer_dispersion;
    {
    while (1) {
      while_continue: ;
      if (! (i < filter->used)) {
        goto while_break;
      }
      if (min_dispersion > (filter->samples + i)->peer_dispersion) {
        min_dispersion = (filter->samples + i)->peer_dispersion;
      }
      i ++;
    }
    while_break: ;
    }
    j = 0;
    i = j;
    {
    while (1) {
      while_continue___0: ;
      if (! (i < filter->used)) {
        goto while_break___0;
      }
      if ((filter->samples + i)->peer_dispersion <= 1.5 * min_dispersion) {
        tmp = j;
        j ++;
        *(selected + tmp) = i;
      }
      i ++;
    }
    while_break___0: ;
    }
  } else {
    j = 0;
  }
  if (j < 4) {
    j = 0;
    {
    while (1) {
      while_continue___1: ;
      if (! (j < filter->used)) {
        goto while_break___1;
      }
      *(selected + j) = j;
      j ++;
    }
    while_break___1: ;
    }
  }
  tmp_sort_samples = (NTP_Sample const *)filter->samples;
  qsort((void *)selected, (size_t )j, sizeof(int ), & compare_samples);
  if (j > 2) {
    from = (int )(((double )j * (1.0 - filter->combine_ratio)) / 2.0);
    if (from < (j - 1) / 2) {
      tmp___2 = from;
    } else {
      tmp___2 = (j - 1) / 2;
    }
    if (1 > tmp___2) {
      from = 1;
    } else {
      if (from < (j - 1) / 2) {
        tmp___1 = from;
      } else {
        tmp___1 = (j - 1) / 2;
      }
      from = tmp___1;
    }
  } else {
    from = 0;
  }
  to = j - from;
  o = (filter->used - filter->index) - 1;
  i = 0;
  {
  while (1) {
    while_continue___2: ;
    if (! (i < from)) {
      goto while_break___2;
    }
    *(selected + i) = -1;
    i ++;
  }
  while_break___2: ;
  }
  {
  while (1) {
    while_continue___3: ;
    if (! (i < to)) {
      goto while_break___3;
    }
    *(selected + i) = (*(selected + i) + o) % filter->used;
    i ++;
  }
  while_break___3: ;
  }
  {
  while (1) {
    while_continue___4: ;
    if (! (i < filter->used)) {
      goto while_break___4;
    }
    *(selected + i) = -1;
    i ++;
  }
  while_break___4: ;
  }
  i = from;
  {
  while (1) {
    while_continue___5: ;
    if (! (i < to)) {
      goto while_break___5;
    }
    j = *(selected + i);
    *(selected + i) = -1;
    {
    while (1) {
      while_continue___6: ;
      if (j != -1) {
        if (! (*(selected + j) != j)) {
          goto while_break___6;
        }
      } else {
        goto while_break___6;
      }
      k = *(selected + j);
      *(selected + j) = j;
      j = k;
    }
    while_break___6: ;
    }
    i ++;
  }
  while_break___5: ;
  }
  j = 0;
  i = j;
  {
  while (1) {
    while_continue___7: ;
    if (! (i < filter->used)) {
      goto while_break___7;
    }
    if (*(selected + i) != -1) {
      tmp___3 = j;
      j ++;
      *(selected + tmp___3) = ((*(selected + i) + filter->used) - o) % filter->used;
    }
    i ++;
  }
  while_break___7: ;
  }
  if (j > 0) {
    if (j <= filter->max_samples) {
      tmp___4 = 1;
    } else {
      tmp___4 = 0;
    }
  } else {
    tmp___4 = 0;
  }
  assert(tmp___4);
  return (j);
}
}
static int combine_selected_samples(SPF_Instance filter , int n , NTP_Sample *result )
{
  double mean_peer_dispersion ;
  double mean_root_dispersion ;
  double mean_peer_delay ;
  double mean_root_delay ;
  double mean_x ;
  double mean_y ;
  double disp ;
  double var ;
  double prev_avg_var ;
  NTP_Sample *sample ;
  NTP_Sample *last_sample ;
  int i ;
  int dof ;
  double b0 ;
  double b1 ;
  double s2 ;
  double sb0 ;
  double sb1 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  {
  last_sample = filter->samples + *(filter->selected + (n - 1));
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < n)) {
      goto while_break;
    }
    sample = filter->samples + *(filter->selected + i);
    *(filter->x_data + i) = UTI_DiffTimespecsToDouble((struct timespec const *)(& sample->time),
                                                      (struct timespec const *)(& last_sample->time));
    *(filter->y_data + i) = sample->offset;
    *(filter->w_data + i) = sample->peer_dispersion;
    i ++;
  }
  while_break: ;
  }
  i = 0;
  mean_y = 0.0;
  mean_x = mean_y;
  {
  while (1) {
    while_continue___0: ;
    if (! (i < n)) {
      goto while_break___0;
    }
    mean_x += *(filter->x_data + i);
    mean_y += *(filter->y_data + i);
    i ++;
  }
  while_break___0: ;
  }
  mean_x /= (double )n;
  mean_y /= (double )n;
  if (n >= 4) {
    i = 0;
    {
    while (1) {
      while_continue___1: ;
      if (! (i < n)) {
        goto while_break___1;
      }
      *(filter->x_data + i) -= mean_x;
      i ++;
    }
    while_break___1: ;
    }
    RGR_WeightedRegression(filter->x_data, filter->y_data, filter->w_data, n, & b0,
                           & b1, & s2, & sb0, & sb1);
    var = s2;
    disp = sb0;
    dof = n - 2;
  } else
  if (n >= 2) {
    i = 0;
    disp = 0.0;
    {
    while (1) {
      while_continue___2: ;
      if (! (i < n)) {
        goto while_break___2;
      }
      disp += (*(filter->y_data + i) - mean_y) * (*(filter->y_data + i) - mean_y);
      i ++;
    }
    while_break___2: ;
    }
    var = disp / (double )(n - 1);
    disp = sqrt(var);
    dof = n - 1;
  } else {
    var = filter->avg_var;
    disp = sqrt(var);
    dof = 1;
  }
  if (var < 1e-20) {
    var = 1e-20;
    disp = sqrt(var);
  }
  if (filter->max_var > 0.0) {
    if (var > filter->max_var) {
      {
      while (1) {
        while_continue___3: ;
        goto while_break___3;
      }
      while_break___3: ;
      }
      return (0);
    }
  }
  prev_avg_var = filter->avg_var;
  if (filter->avg_var_n > 50) {
    filter->avg_var += ((double )dof / ((double )dof + 50.0)) * (var - filter->avg_var);
  } else {
    filter->avg_var = (filter->avg_var * (double )filter->avg_var_n + var * (double )dof) / (double )(dof + filter->avg_var_n);
    if (filter->avg_var_n == 0) {
      prev_avg_var = filter->avg_var;
    }
    filter->avg_var_n += dof;
  }
  tmp___3 = RGR_GetChi2Coef(dof);
  if ((var * (double )dof) / tmp___3 < prev_avg_var) {
    tmp___1 = sqrt(filter->avg_var);
    tmp___2 = sqrt(var);
    disp = (tmp___1 * disp) / tmp___2;
  }
  mean_root_delay = 0.0;
  mean_peer_delay = mean_root_delay;
  mean_root_dispersion = mean_peer_delay;
  mean_peer_dispersion = mean_root_dispersion;
  i = 0;
  {
  while (1) {
    while_continue___4: ;
    if (! (i < n)) {
      goto while_break___4;
    }
    sample = filter->samples + *(filter->selected + i);
    mean_peer_dispersion += sample->peer_dispersion;
    mean_root_dispersion += sample->root_dispersion;
    mean_peer_delay += sample->peer_delay;
    mean_root_delay += sample->root_delay;
    i ++;
  }
  while_break___4: ;
  }
  mean_peer_dispersion /= (double )n;
  mean_root_dispersion /= (double )n;
  mean_peer_delay /= (double )n;
  mean_root_delay /= (double )n;
  UTI_AddDoubleToTimespec((struct timespec const *)(& last_sample->time), mean_x,
                          & result->time);
  result->offset = mean_y;
  if (disp > mean_peer_dispersion) {
    result->peer_dispersion = disp;
  } else {
    result->peer_dispersion = mean_peer_dispersion;
  }
  if (disp > mean_root_dispersion) {
    result->root_dispersion = disp;
  } else {
    result->root_dispersion = mean_root_dispersion;
  }
  result->peer_delay = mean_peer_delay;
  result->root_delay = mean_root_delay;
  return (1);
}
}
int SPF_GetFilteredSample(SPF_Instance filter , NTP_Sample *sample )
{
  int n ;
  int tmp ;
  {
  n = select_samples(filter);
  if (n < 1) {
    return (0);
  }
  tmp = combine_selected_samples(filter, n, sample);
  if (! tmp) {
    return (0);
  }
  SPF_DropSamples(filter);
  return (1);
}
}
void SPF_SlewSamples(SPF_Instance filter , struct timespec *when , double dfreq ,
                     double doffset )
{
  int i ;
  int first ;
  int last ;
  double delta_time ;
  {
  if (filter->last < 0) {
    return;
  }
  if (filter->used > 0) {
    first = 0;
    last = filter->used - 1;
  } else {
    last = filter->last;
    first = last;
  }
  i = first;
  {
  while (1) {
    while_continue: ;
    if (! (i <= last)) {
      goto while_break;
    }
    UTI_AdjustTimespec((struct timespec const *)(& (filter->samples + i)->time),
                       (struct timespec const *)when, & (filter->samples + i)->time,
                       & delta_time, dfreq, doffset);
    (filter->samples + i)->offset -= delta_time;
    i ++;
  }
  while_break: ;
  }
  return;
}
}
void SPF_AddDispersion(SPF_Instance filter , double dispersion )
{
  int i ;
  {
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < filter->used)) {
      goto while_break;
    }
    (filter->samples + i)->peer_dispersion += dispersion;
    (filter->samples + i)->root_dispersion += dispersion;
    i ++;
  }
  while_break: ;
  }
  return;
}
}
static int initialised___2 = 0;
static unsigned int one_highest_fd ;
static ARR_Instance file_handlers ;
static struct timespec last_select_ts ;
static struct timespec last_select_ts_raw ;
static double last_select_ts_err ;
static double last_select_ts_mono ;
static uint32_t last_select_ts_mono_ns ;
static TimerQueueEntry timer_queue ;
static unsigned long n_timer_queue_entries ;
static SCH_TimeoutID next_tqe_id ;
static TimerQueueEntry *tqe_free_list = (TimerQueueEntry *)((void *)0);
static struct timespec last_class_dispatch[4] ;
static int volatile need_to_exit ;
static void handle_slew___0(struct timespec *raw , struct timespec *cooked , double dfreq ,
                            double doffset , LCL_ChangeType change_type , void *anything ) ;
void SCH_Initialise(void)
{
  {
  file_handlers = ARR_CreateInstance((unsigned int )sizeof(FileHandlerEntry ));
  n_timer_queue_entries = 0UL;
  next_tqe_id = (SCH_TimeoutID )0;
  timer_queue.next = & timer_queue;
  timer_queue.prev = & timer_queue;
  need_to_exit = (int volatile )0;
  LCL_AddParameterChangeHandler(& handle_slew___0, (void *)0);
  LCL_ReadRawTime(& last_select_ts_raw);
  last_select_ts = last_select_ts_raw;
  last_select_ts_mono = 0.0;
  last_select_ts_mono_ns = (uint32_t )0;
  initialised___2 = 1;
  return;
}
}
void SCH_Finalise(void)
{
  {
  ARR_DestroyInstance(file_handlers);
  LCL_RemoveParameterChangeHandler(& handle_slew___0, (void *)0);
  initialised___2 = 0;
  return;
}
}
void SCH_AddFileHandler(int fd___0 , int events , void (*handler)(int fd , int event ,
                                                                  SCH_ArbitraryArgument ) ,
                        SCH_ArbitraryArgument arg )
{
  FileHandlerEntry *ptr ;
  void *tmp ;
  unsigned int tmp___0 ;
  void *tmp___1 ;
  {
  assert(initialised___2);
  assert(events);
  assert(fd___0 >= 0);
  if (fd___0 >= 1024) {
    {
    while (1) {
      while_continue: ;
      LOG_Message((LOG_Severity )3, (char const *)"Too many file descriptors");
      exit(1);
      goto while_break;
    }
    while_break: ;
    }
  }
  {
  while (1) {
    while_continue___0: ;
    tmp___0 = ARR_GetSize(file_handlers);
    if (! (tmp___0 <= (unsigned int )fd___0)) {
      goto while_break___0;
    }
    tmp = ARR_GetNewElement(file_handlers);
    ptr = (FileHandlerEntry *)tmp;
    ptr->handler = (void (*)(int fd , int event , SCH_ArbitraryArgument ))((void *)0);
    ptr->arg = (void *)0;
    ptr->events = 0;
  }
  while_break___0: ;
  }
  tmp___1 = ARR_GetElement(file_handlers, (unsigned int )fd___0);
  ptr = (FileHandlerEntry *)tmp___1;
  assert(! ptr->handler);
  ptr->handler = handler;
  ptr->arg = arg;
  ptr->events = events;
  if (one_highest_fd < (unsigned int )(fd___0 + 1)) {
    one_highest_fd = (unsigned int )(fd___0 + 1);
  }
  return;
}
}
void SCH_RemoveFileHandler(int fd___0 )
{
  FileHandlerEntry *ptr ;
  void *tmp ;
  void *tmp___0 ;
  {
  assert(initialised___2);
  tmp = ARR_GetElement(file_handlers, (unsigned int )fd___0);
  ptr = (FileHandlerEntry *)tmp;
  assert((int )ptr->handler);
  ptr->handler = (void (*)(int fd , int event , SCH_ArbitraryArgument ))((void *)0);
  ptr->arg = (void *)0;
  ptr->events = 0;
  {
  while (1) {
    while_continue: ;
    if (! (one_highest_fd > 0U)) {
      goto while_break;
    }
    tmp___0 = ARR_GetElement(file_handlers, one_highest_fd - 1U);
    ptr = (FileHandlerEntry *)tmp___0;
    if (ptr->handler) {
      goto while_break;
    }
    one_highest_fd --;
  }
  while_break: ;
  }
  return;
}
}
void SCH_SetFileHandlerEvent(int fd___0 , int event , int enable )
{
  FileHandlerEntry *ptr ;
  void *tmp ;
  {
  tmp = ARR_GetElement(file_handlers, (unsigned int )fd___0);
  ptr = (FileHandlerEntry *)tmp;
  if (enable) {
    ptr->events |= event;
  } else {
    ptr->events &= ~ event;
  }
  return;
}
}
void SCH_GetLastEventTime(struct timespec *cooked , double *err , struct timespec *raw )
{
  {
  if (cooked) {
    *cooked = last_select_ts;
    if (err) {
      *err = last_select_ts_err;
    }
  }
  if (raw) {
    *raw = last_select_ts_raw;
  }
  return;
}
}
double SCH_GetLastEventMonoTime(void)
{
  {
  return (last_select_ts_mono);
}
}
static TimerQueueEntry *allocate_tqe(void)
{
  TimerQueueEntry *new_block ;
  TimerQueueEntry *result ;
  int i ;
  void *tmp ;
  {
  if ((unsigned long )tqe_free_list == (unsigned long )((void *)0)) {
    tmp = Malloc2((size_t )32, sizeof(TimerQueueEntry ));
    new_block = (TimerQueueEntry *)tmp;
    i = 1;
    {
    while (1) {
      while_continue: ;
      if (! (i < 32)) {
        goto while_break;
      }
      (new_block + i)->next = new_block + (i - 1);
      i ++;
    }
    while_break: ;
    }
    (new_block + 0)->next = (struct _TimerQueueEntry *)((void *)0);
    tqe_free_list = new_block + 31;
  }
  result = tqe_free_list;
  tqe_free_list = tqe_free_list->next;
  return (result);
}
}
static void release_tqe(TimerQueueEntry *node )
{
  {
  node->next = tqe_free_list;
  tqe_free_list = node;
  return;
}
}
static SCH_TimeoutID get_new_tqe_id(void)
{
  TimerQueueEntry *ptr ;
  {
  try_again:
  next_tqe_id ++;
  if (! next_tqe_id) {
    goto try_again;
  }
  ptr = timer_queue.next;
  {
  while (1) {
    while_continue: ;
    if (! ((unsigned long )ptr != (unsigned long )(& timer_queue))) {
      goto while_break;
    }
    if (ptr->id == next_tqe_id) {
      goto try_again;
    }
    ptr = ptr->next;
  }
  while_break: ;
  }
  return (next_tqe_id);
}
}
SCH_TimeoutID SCH_AddTimeout(struct timespec *ts , void (*handler)(SCH_ArbitraryArgument ) ,
                             SCH_ArbitraryArgument arg )
{
  TimerQueueEntry *new_tqe ;
  TimerQueueEntry *ptr ;
  int tmp ;
  {
  assert(initialised___2);
  new_tqe = allocate_tqe();
  new_tqe->id = get_new_tqe_id();
  new_tqe->handler = handler;
  new_tqe->arg = arg;
  new_tqe->ts = *ts;
  new_tqe->class = (SCH_TimeoutClass )0;
  ptr = timer_queue.next;
  {
  while (1) {
    while_continue: ;
    if (! ((unsigned long )ptr != (unsigned long )(& timer_queue))) {
      goto while_break;
    }
    tmp = UTI_CompareTimespecs((struct timespec const *)(& new_tqe->ts), (struct timespec const *)(& ptr->ts));
    if (tmp == -1) {
      goto while_break;
    }
    ptr = ptr->next;
  }
  while_break: ;
  }
  new_tqe->next = ptr;
  new_tqe->prev = ptr->prev;
  (ptr->prev)->next = new_tqe;
  ptr->prev = new_tqe;
  n_timer_queue_entries ++;
  return (new_tqe->id);
}
}
SCH_TimeoutID SCH_AddTimeoutByDelay(double delay , void (*handler)(SCH_ArbitraryArgument ) ,
                                    SCH_ArbitraryArgument arg )
{
  struct timespec now ;
  struct timespec then ;
  int tmp ;
  SCH_TimeoutID tmp___0 ;
  {
  assert(initialised___2);
  assert(delay >= 0.0);
  LCL_ReadRawTime(& now);
  UTI_AddDoubleToTimespec((struct timespec const *)(& now), delay, & then);
  tmp = UTI_CompareTimespecs((struct timespec const *)(& now), (struct timespec const *)(& then));
  if (tmp > 0) {
    {
    while (1) {
      while_continue: ;
      LOG_Message((LOG_Severity )3, (char const *)"Timeout overflow");
      exit(1);
      goto while_break;
    }
    while_break: ;
    }
  }
  tmp___0 = SCH_AddTimeout(& then, handler, arg);
  return (tmp___0);
}
}
SCH_TimeoutID SCH_AddTimeoutInClass(double min_delay , double separation , double randomness ,
                                    SCH_TimeoutClass class , void (*handler)(SCH_ArbitraryArgument ) ,
                                    SCH_ArbitraryArgument arg )
{
  TimerQueueEntry *new_tqe ;
  TimerQueueEntry *ptr ;
  struct timespec now ;
  double diff ;
  double r ;
  double new_min_delay ;
  uint32_t rnd___0 ;
  {
  assert(initialised___2);
  assert(min_delay >= 0.0);
  assert((unsigned int )class < 4U);
  if (randomness > 0.0) {
    UTI_GetRandomBytes((void *)(& rnd___0), (unsigned int )sizeof(rnd___0));
    r = (double )rnd___0 * (randomness / (double )4294967295U) + 1.0;
    min_delay *= r;
    separation *= r;
  }
  LCL_ReadRawTime(& now);
  new_min_delay = min_delay;
  diff = UTI_DiffTimespecsToDouble((struct timespec const *)(& now), (struct timespec const *)(& last_class_dispatch[class]));
  if (diff < separation) {
    if (diff >= 0.0) {
      if (diff + new_min_delay < separation) {
        new_min_delay = separation - diff;
      }
    }
  }
  ptr = timer_queue.next;
  {
  while (1) {
    while_continue: ;
    if (! ((unsigned long )ptr != (unsigned long )(& timer_queue))) {
      goto while_break;
    }
    if ((unsigned int )ptr->class == (unsigned int )class) {
      diff = UTI_DiffTimespecsToDouble((struct timespec const *)(& ptr->ts), (struct timespec const *)(& now));
      if (new_min_delay > diff) {
        if (new_min_delay - diff < separation) {
          new_min_delay = diff + separation;
        }
      } else
      if (diff - new_min_delay < separation) {
        new_min_delay = diff + separation;
      }
    }
    ptr = ptr->next;
  }
  while_break: ;
  }
  ptr = timer_queue.next;
  {
  while (1) {
    while_continue___0: ;
    if (! ((unsigned long )ptr != (unsigned long )(& timer_queue))) {
      goto while_break___0;
    }
    diff = UTI_DiffTimespecsToDouble((struct timespec const *)(& ptr->ts), (struct timespec const *)(& now));
    if (diff > new_min_delay) {
      goto while_break___0;
    }
    ptr = ptr->next;
  }
  while_break___0: ;
  }
  new_tqe = allocate_tqe();
  new_tqe->id = get_new_tqe_id();
  new_tqe->handler = handler;
  new_tqe->arg = arg;
  UTI_AddDoubleToTimespec((struct timespec const *)(& now), new_min_delay, & new_tqe->ts);
  new_tqe->class = class;
  new_tqe->next = ptr;
  new_tqe->prev = ptr->prev;
  (ptr->prev)->next = new_tqe;
  ptr->prev = new_tqe;
  n_timer_queue_entries ++;
  return (new_tqe->id);
}
}
void SCH_RemoveTimeout(SCH_TimeoutID id )
{
  TimerQueueEntry *ptr ;
  {
  assert(initialised___2);
  if (! id) {
    return;
  }
  ptr = timer_queue.next;
  {
  while (1) {
    while_continue: ;
    if (! ((unsigned long )ptr != (unsigned long )(& timer_queue))) {
      goto while_break;
    }
    if (ptr->id == id) {
      (ptr->next)->prev = ptr->prev;
      (ptr->prev)->next = ptr->next;
      n_timer_queue_entries --;
      release_tqe(ptr);
      return;
    }
    ptr = ptr->next;
  }
  while_break: ;
  }
  assert(0);
  return;
}
}
static void dispatch_timeouts(struct timespec *now )
{
  unsigned long n_done ;
  unsigned long n_entries_on_start ;
  TimerQueueEntry *ptr ;
  void (*handler)(SCH_ArbitraryArgument ) ;
  SCH_ArbitraryArgument arg ;
  int tmp ;
  unsigned long tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  {
  n_entries_on_start = n_timer_queue_entries;
  n_done = 0UL;
  {
  while (1) {
    while_continue: ;
    LCL_ReadRawTime(now);
    if (n_timer_queue_entries > 0UL) {
      tmp = UTI_CompareTimespecs((struct timespec const *)now, (struct timespec const *)(& (timer_queue.next)->ts));
      if (! (tmp >= 0)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    ptr = timer_queue.next;
    last_class_dispatch[ptr->class] = *now;
    handler = ptr->handler;
    arg = ptr->arg;
    SCH_RemoveTimeout(ptr->id);
    (*handler)(arg);
    n_done ++;
    if (n_done > 20UL) {
      if (n_timer_queue_entries > n_entries_on_start) {
        tmp___0 = n_timer_queue_entries;
      } else {
        tmp___0 = n_entries_on_start;
      }
      if (n_done > 4UL * tmp___0) {
        tmp___1 = UTI_DiffTimespecsToDouble((struct timespec const *)now, (struct timespec const *)(& last_select_ts_raw));
        tmp___2 = fabs(tmp___1);
        if (tmp___2 / (double )n_done < 0.01) {
          {
          while (1) {
            while_continue___0: ;
            LOG_Message((LOG_Severity )3, (char const *)"Possible infinite loop in scheduling");
            exit(1);
            goto while_break___0;
          }
          while_break___0: ;
          }
        }
      }
    }
    if (! (! need_to_exit)) {
      goto while_break;
    }
  }
  while_break: ;
  }
  return;
}
}
static void dispatch_filehandlers(int nfd , fd_set *read_fds , fd_set *write_fds ,
                                  fd_set *except_fds )
{
  FileHandlerEntry *ptr ;
  int fd___0 ;
  void *tmp ;
  long __d ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long __d___0 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long __d___1 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  void *tmp___9 ;
  long __d___2 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  void *tmp___13 ;
  long __d___3 ;
  long tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  {
  fd___0 = 0;
  {
  while (1) {
    while_continue: ;
    if (nfd) {
      if (! ((unsigned int )fd___0 < one_highest_fd)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if (except_fds) {
      __d___1 = (long )fd___0;
      tmp___8 = __fdelt_chk(__d___1);
      if ((except_fds->fds_bits[tmp___8] & (__fd_mask )(1UL << fd___0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        tmp = ARR_GetElement(file_handlers, (unsigned int )fd___0);
        ptr = (FileHandlerEntry *)tmp;
        if (ptr->handler) {
          (*(ptr->handler))(fd___0, 4, ptr->arg);
        }
        nfd --;
        if (read_fds) {
          __d___0 = (long )fd___0;
          tmp___5 = __fdelt_chk(__d___0);
          if ((read_fds->fds_bits[tmp___5] & (__fd_mask )(1UL << fd___0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
            __d = (long )fd___0;
            tmp___2 = __fdelt_chk(__d);
            read_fds->fds_bits[tmp___2] &= ~ ((__fd_mask )(1UL << fd___0 % (8 * (int )sizeof(__fd_mask ))));
            nfd --;
          }
        }
      }
    }
    if (read_fds) {
      __d___2 = (long )fd___0;
      tmp___12 = __fdelt_chk(__d___2);
      if ((read_fds->fds_bits[tmp___12] & (__fd_mask )(1UL << fd___0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        tmp___9 = ARR_GetElement(file_handlers, (unsigned int )fd___0);
        ptr = (FileHandlerEntry *)tmp___9;
        if (ptr->handler) {
          (*(ptr->handler))(fd___0, 1, ptr->arg);
        }
        nfd --;
      }
    }
    if (write_fds) {
      __d___3 = (long )fd___0;
      tmp___16 = __fdelt_chk(__d___3);
      if ((write_fds->fds_bits[tmp___16] & (__fd_mask )(1UL << fd___0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        tmp___13 = ARR_GetElement(file_handlers, (unsigned int )fd___0);
        ptr = (FileHandlerEntry *)tmp___13;
        if (ptr->handler) {
          (*(ptr->handler))(fd___0, 2, ptr->arg);
        }
        nfd --;
      }
    }
    fd___0 ++;
  }
  while_break: ;
  }
  return;
}
}
static void handle_slew___0(struct timespec *raw , struct timespec *cooked , double dfreq ,
                            double doffset , LCL_ChangeType change_type , void *anything )
{
  TimerQueueEntry *ptr ;
  double delta ;
  int i ;
  int tmp ;
  {
  if ((unsigned int )change_type != 0U) {
    tmp = LCL_IsFirstParameterChangeHandler(& handle_slew___0);
    assert(tmp);
    ptr = timer_queue.next;
    {
    while (1) {
      while_continue: ;
      if (! ((unsigned long )ptr != (unsigned long )(& timer_queue))) {
        goto while_break;
      }
      UTI_AddDoubleToTimespec((struct timespec const *)(& ptr->ts), - doffset, & ptr->ts);
      ptr = ptr->next;
    }
    while_break: ;
    }
    i = 0;
    {
    while (1) {
      while_continue___0: ;
      if (! (i < 4)) {
        goto while_break___0;
      }
      UTI_AddDoubleToTimespec((struct timespec const *)(& last_class_dispatch[i]),
                              - doffset, & last_class_dispatch[i]);
      i ++;
    }
    while_break___0: ;
    }
    UTI_AddDoubleToTimespec((struct timespec const *)(& last_select_ts_raw), - doffset,
                            & last_select_ts_raw);
  }
  UTI_AdjustTimespec((struct timespec const *)(& last_select_ts), (struct timespec const *)cooked,
                     & last_select_ts, & delta, dfreq, doffset);
  return;
}
}
static void fill_fd_sets(fd_set **read_fds , fd_set **write_fds , fd_set **except_fds )
{
  FileHandlerEntry *handlers ;
  fd_set *rd ;
  fd_set *wr ;
  fd_set *ex ;
  int i ;
  int n ;
  int events ;
  unsigned int tmp ;
  void *tmp___0 ;
  unsigned int __i ;
  fd_set *__arr ;
  long __d ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  unsigned int __i___0 ;
  fd_set *__arr___0 ;
  long __d___0 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  unsigned int __i___1 ;
  fd_set *__arr___1 ;
  long __d___1 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  {
  tmp = ARR_GetSize(file_handlers);
  n = (int )tmp;
  tmp___0 = ARR_GetElements(file_handlers);
  handlers = (FileHandlerEntry *)tmp___0;
  ex = (fd_set *)((void *)0);
  wr = ex;
  rd = wr;
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < n)) {
      goto while_break;
    }
    events = (handlers + i)->events;
    if (! events) {
      goto __Cont;
    }
    if (events & 1) {
      if (! rd) {
        rd = *read_fds;
        {
        while (1) {
          while_continue___0: ;
          __arr = rd;
          __i = 0U;
          {
          while (1) {
            while_continue___1: ;
            if (! ((unsigned long )__i < sizeof(fd_set ) / sizeof(__fd_mask ))) {
              goto while_break___1;
            }
            __arr->fds_bits[__i] = (__fd_mask )0;
            __i ++;
          }
          while_break___1: ;
          }
          goto while_break___0;
        }
        while_break___0: ;
        }
      }
      __d = (long )i;
      tmp___3 = __fdelt_chk(__d);
      rd->fds_bits[tmp___3] |= (__fd_mask )(1UL << i % (8 * (int )sizeof(__fd_mask )));
    }
    if (events & 2) {
      if (! wr) {
        wr = *write_fds;
        {
        while (1) {
          while_continue___2: ;
          __arr___0 = wr;
          __i___0 = 0U;
          {
          while (1) {
            while_continue___3: ;
            if (! ((unsigned long )__i___0 < sizeof(fd_set ) / sizeof(__fd_mask ))) {
              goto while_break___3;
            }
            __arr___0->fds_bits[__i___0] = (__fd_mask )0;
            __i___0 ++;
          }
          while_break___3: ;
          }
          goto while_break___2;
        }
        while_break___2: ;
        }
      }
      __d___0 = (long )i;
      tmp___6 = __fdelt_chk(__d___0);
      wr->fds_bits[tmp___6] |= (__fd_mask )(1UL << i % (8 * (int )sizeof(__fd_mask )));
    }
    if (events & 4) {
      if (! ex) {
        ex = *except_fds;
        {
        while (1) {
          while_continue___4: ;
          __arr___1 = ex;
          __i___1 = 0U;
          {
          while (1) {
            while_continue___5: ;
            if (! ((unsigned long )__i___1 < sizeof(fd_set ) / sizeof(__fd_mask ))) {
              goto while_break___5;
            }
            __arr___1->fds_bits[__i___1] = (__fd_mask )0;
            __i___1 ++;
          }
          while_break___5: ;
          }
          goto while_break___4;
        }
        while_break___4: ;
        }
      }
      __d___1 = (long )i;
      tmp___9 = __fdelt_chk(__d___1);
      ex->fds_bits[tmp___9] |= (__fd_mask )(1UL << i % (8 * (int )sizeof(__fd_mask )));
    }
    __Cont:
    i ++;
  }
  while_break: ;
  }
  if (! rd) {
    *read_fds = (fd_set *)((void *)0);
  }
  if (! wr) {
    *write_fds = (fd_set *)((void *)0);
  }
  if (! ex) {
    *except_fds = (fd_set *)((void *)0);
  }
  return;
}
}
static int check_current_time(struct timespec *prev_raw , struct timespec *raw , int timeout ,
                              struct timeval *orig_select_tv , struct timeval *rem_select_tv )
{
  struct timespec elapsed_min ;
  struct timespec elapsed_max ;
  struct timespec orig_select_ts ;
  struct timespec rem_select_ts ;
  double step ;
  double elapsed ;
  double tmp ;
  {
  UTI_TimevalToTimespec((struct timeval const *)orig_select_tv, & orig_select_ts);
  if (timeout) {
    elapsed_min = orig_select_ts;
    elapsed_max = elapsed_min;
  } else
  if (rem_select_tv) {
    if (rem_select_tv->tv_sec >= 0L) {
      if (rem_select_tv->tv_sec <= orig_select_tv->tv_sec) {
        if (rem_select_tv->tv_sec != orig_select_tv->tv_sec) {
          UTI_TimevalToTimespec((struct timeval const *)rem_select_tv, & rem_select_ts);
          UTI_DiffTimespecs(& elapsed_min, (struct timespec const *)(& orig_select_ts),
                            (struct timespec const *)(& rem_select_ts));
          elapsed_max = elapsed_min;
        } else
        if (rem_select_tv->tv_usec != orig_select_tv->tv_usec) {
          UTI_TimevalToTimespec((struct timeval const *)rem_select_tv, & rem_select_ts);
          UTI_DiffTimespecs(& elapsed_min, (struct timespec const *)(& orig_select_ts),
                            (struct timespec const *)(& rem_select_ts));
          elapsed_max = elapsed_min;
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1:
    _L___0:
    _L:
    if (rem_select_tv) {
      elapsed_max = orig_select_ts;
    } else {
      UTI_DiffTimespecs(& elapsed_max, (struct timespec const *)raw, (struct timespec const *)prev_raw);
    }
    UTI_ZeroTimespec(& elapsed_min);
  }
  if (last_select_ts_raw.tv_sec + elapsed_min.tv_sec > raw->tv_sec + 10L) {
    LOG_Message((LOG_Severity )1, (char const *)"Backward time jump detected!");
  } else
  if ((prev_raw->tv_sec + elapsed_max.tv_sec) + 10L < raw->tv_sec) {
    LOG_Message((LOG_Severity )1, (char const *)"Forward time jump detected!");
  } else {
    return (1);
  }
  step = UTI_DiffTimespecsToDouble((struct timespec const *)(& last_select_ts_raw),
                                   (struct timespec const *)raw);
  elapsed = UTI_TimespecToDouble((struct timespec const *)(& elapsed_min));
  step += elapsed;
  tmp = fabs(step);
  LCL_NotifyExternalTimeStep(raw, raw, step, tmp);
  return (0);
}
}
static void update_monotonic_time(struct timespec *now , struct timespec *before )
{
  struct timespec diff ;
  double tmp ;
  double tmp___0 ;
  {
  UTI_DiffTimespecs(& diff, (struct timespec const *)now, (struct timespec const *)before);
  if (diff.tv_sec == 0L) {
    last_select_ts_mono_ns = (uint32_t )((__syscall_slong_t )last_select_ts_mono_ns + diff.tv_nsec);
  } else {
    tmp = UTI_TimespecToDouble((struct timespec const *)(& diff));
    tmp___0 = fabs(tmp + (double )last_select_ts_mono_ns / 1.0e9);
    last_select_ts_mono += tmp___0;
    last_select_ts_mono_ns = (uint32_t )0;
  }
  if (last_select_ts_mono_ns > 10000000U) {
    last_select_ts_mono += (double )last_select_ts_mono_ns / 1.0e9;
    last_select_ts_mono_ns = (uint32_t )0;
  }
  return;
}
}
void SCH_MainLoop(void)
{
  fd_set read_fds ;
  fd_set write_fds ;
  fd_set except_fds ;
  fd_set *p_read_fds ;
  fd_set *p_write_fds ;
  fd_set *p_except_fds ;
  int status ;
  int errsv ;
  struct timeval tv ;
  struct timeval saved_tv ;
  struct timeval *ptv ;
  struct timespec ts ;
  struct timespec now ;
  struct timespec saved_now ;
  struct timespec cooked ;
  double err ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  {
  assert(initialised___2);
  {
  while (1) {
    while_continue: ;
    if (! (! need_to_exit)) {
      goto while_break;
    }
    dispatch_timeouts(& now);
    saved_now = now;
    if (need_to_exit) {
      goto while_break;
    }
    if (n_timer_queue_entries > 0UL) {
      UTI_DiffTimespecs(& ts, (struct timespec const *)(& (timer_queue.next)->ts),
                        (struct timespec const *)(& now));
      if (ts.tv_sec > 0L) {
        tmp = 1;
      } else
      if (ts.tv_nsec > 0L) {
        tmp = 1;
      } else {
        tmp = 0;
      }
      assert(tmp);
      UTI_TimespecToTimeval((struct timespec const *)(& ts), & tv);
      ptv = & tv;
      saved_tv = tv;
    } else {
      ptv = (struct timeval *)((void *)0);
      saved_tv.tv_usec = (__suseconds_t )0;
      saved_tv.tv_sec = saved_tv.tv_usec;
    }
    p_read_fds = & read_fds;
    p_write_fds = & write_fds;
    p_except_fds = & except_fds;
    fill_fd_sets(& p_read_fds, & p_write_fds, & p_except_fds);
    if (! ptv) {
      if (! p_read_fds) {
        if (! p_write_fds) {
          {
          while (1) {
            while_continue___0: ;
            LOG_Message((LOG_Severity )3, (char const *)"Nothing to do");
            exit(1);
            goto while_break___0;
          }
          while_break___0: ;
          }
        }
      }
    }
    status = select((int )one_highest_fd, (fd_set * __restrict )p_read_fds, (fd_set * __restrict )p_write_fds,
                    (fd_set * __restrict )p_except_fds, (struct timeval * __restrict )ptv);
    tmp___0 = __errno_location();
    errsv = *tmp___0;
    LCL_ReadRawTime(& now);
    LCL_CookTime(& now, & cooked, & err);
    update_monotonic_time(& now, & last_select_ts_raw);
    tmp___1 = check_current_time(& saved_now, & now, status == 0, & saved_tv, ptv);
    if (! tmp___1) {
      LCL_CookTime(& now, & cooked, & err);
    }
    last_select_ts_raw = now;
    last_select_ts = cooked;
    last_select_ts_err = err;
    if (status < 0) {
      if (! need_to_exit) {
        if (errsv != 4) {
          {
          while (1) {
            while_continue___1: ;
            tmp___2 = strerror(errsv);
            LOG_Message((LOG_Severity )3, (char const *)"select() failed : %s",
                        tmp___2);
            exit(1);
            goto while_break___1;
          }
          while_break___1: ;
          }
        }
      }
    } else
    if (status > 0) {
      dispatch_filehandlers(status, p_read_fds, p_write_fds, p_except_fds);
    } else {
      assert((int )ptv);
    }
  }
  while_break: ;
  }
  return;
}
}
void SCH_QuitProgram(void)
{
  {
  need_to_exit = (int volatile )1;
  return;
}
}
static int initialised___3 ;
static int ip4_enabled ;
static int ip6_enabled ;
static int supported_socket_flags ;
static ARR_Instance recv_messages ;
static ARR_Instance recv_headers ;
static ARR_Instance recv_sck_messages ;
static unsigned int received_messages ;
static int (*priv_bind_function)(int sock_fd , struct sockaddr *address , socklen_t address_len ) ;
static void prepare_buffers(unsigned int n )
{
  struct mmsghdr *hdr ;
  struct Message *msg ;
  unsigned int i ;
  void *tmp ;
  void *tmp___0 ;
  {
  i = 0U;
  {
  while (1) {
    while_continue: ;
    if (! (i < n)) {
      goto while_break;
    }
    tmp = ARR_GetElement(recv_messages, i);
    msg = (struct Message *)tmp;
    tmp___0 = ARR_GetElement(recv_headers, i);
    hdr = (struct mmsghdr *)tmp___0;
    msg->iov.iov_base = (void *)(& msg->msg_buf);
    msg->iov.iov_len = sizeof(msg->msg_buf);
    hdr->msg_hdr.msg_name = (void *)(& msg->name);
    hdr->msg_hdr.msg_namelen = (socklen_t )sizeof(msg->name);
    hdr->msg_hdr.msg_iov = & msg->iov;
    hdr->msg_hdr.msg_iovlen = (size_t )1;
    hdr->msg_hdr.msg_control = (void *)(msg->cmsg_buf);
    hdr->msg_hdr.msg_controllen = sizeof(msg->cmsg_buf);
    hdr->msg_hdr.msg_flags = 0;
    hdr->msg_len = 0U;
    i ++;
  }
  while_break: ;
  }
  return;
}
}
static char const *domain_to_string(int domain )
{
  {
  {
  if (domain == 2) {
    goto case_2;
  }
  if (domain == 10) {
    goto case_10;
  }
  if (domain == 1) {
    goto case_1;
  }
  if (domain == 0) {
    goto case_0;
  }
  goto switch_default;
  case_2:
  return ((char const *)"IPv4");
  case_10:
  return ((char const *)"IPv6");
  case_1:
  return ((char const *)"Unix");
  case_0:
  return ((char const *)"UNSPEC");
  switch_default:
  return ((char const *)"?");
  switch_break: ;
  }
}
}
static int check_socket_flag(int sock_flag , int fd_flag , int fs_flag )
{
  int sock_fd ;
  int fd_flags ;
  int fs_flags ;
  {
  sock_fd = socket(2, 2 | sock_flag, 0);
  if (sock_fd < 0) {
    return (0);
  }
  fd_flags = fcntl(sock_fd, 1);
  fs_flags = fcntl(sock_fd, 3);
  close(sock_fd);
  if (fd_flags == -1) {
    return (0);
  } else
  if ((fd_flags & fd_flag) != fd_flag) {
    return (0);
  } else
  if (fs_flags == -1) {
    return (0);
  } else
  if ((fs_flags & fs_flag) != fs_flag) {
    return (0);
  }
  return (1);
}
}
static int set_socket_nonblock(int sock_fd )
{
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  {
  tmp___1 = fcntl(sock_fd, 4, 04000);
  if (tmp___1 < 0) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  return (1);
}
}
static int get_open_flags(int flags )
{
  int r ;
  {
  r = supported_socket_flags;
  if (flags & 1) {
    r &= -2049;
  }
  return (r);
}
}
static int set_socket_flags(int sock_fd , int flags )
{
  int tmp ;
  int tmp___0 ;
  {
  if ((supported_socket_flags & 524288) == 0) {
    tmp = UTI_FdSetCloexec(sock_fd);
    if (! tmp) {
      return (0);
    }
  }
  if ((flags & 1) == 0) {
    if ((supported_socket_flags & 2048) == 0) {
      tmp___0 = set_socket_nonblock(sock_fd);
      if (! tmp___0) {
        return (0);
      }
    }
  }
  return (1);
}
}
static int open_socket(int domain , int type , int flags )
{
  int sock_fd ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char const *tmp___2 ;
  int tmp___3 ;
  {
  tmp = get_open_flags(flags);
  sock_fd = socket(domain, type | tmp, 0);
  if (sock_fd < 0) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (-4);
  }
  tmp___3 = set_socket_flags(sock_fd, flags);
  if (! tmp___3) {
    close(sock_fd);
    return (-4);
  }
  return (sock_fd);
}
}
static int open_socket_pair(int domain , int type , int flags , int *other_fd )
{
  int sock_fds[2] ;
  int *tmp ;
  char *tmp___0 ;
  char const *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  {
  tmp___2 = get_open_flags(flags);
  tmp___3 = socketpair(domain, type | tmp___2, 0, (int *)(sock_fds));
  if (tmp___3 < 0) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (-4);
  }
  tmp___4 = set_socket_flags(sock_fds[0], flags);
  if (tmp___4) {
    tmp___5 = set_socket_flags(sock_fds[1], flags);
    if (! tmp___5) {
      close(sock_fds[0]);
      close(sock_fds[1]);
      return (-4);
    }
  } else {
    close(sock_fds[0]);
    close(sock_fds[1]);
    return (-4);
  }
  *other_fd = sock_fds[1];
  return (sock_fds[0]);
}
}
static int set_socket_options(int sock_fd , int flags )
{
  int tmp ;
  int tmp___0 ;
  {
  if (flags & 2) {
    tmp = SCK_SetIntOption(sock_fd, 1, 6, 1);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  return (1);
}
}
static int set_ip_options(int sock_fd , int family , int flags )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  {
  if (family == 2) {
    tmp = SCK_SetIntOption(sock_fd, 41, 26, 1);
    if (! tmp) {
      return (0);
    }
  }
  if (flags & 4) {
    if (family == 1) {
      tmp___0 = SCK_SetIntOption(sock_fd, 0, 8, 1);
      if (tmp___0) {
        tmp___1 = 0;
      } else {
        tmp___1 = 1;
      }
    } else
    if (family == 2) {
      tmp___2 = SCK_SetIntOption(sock_fd, 41, 49, 1);
      if (tmp___2) {
        tmp___3 = 0;
      } else {
        tmp___3 = 1;
      }
    }
  }
  return (1);
}
}
static int is_any_address(IPAddr *addr )
{
  IPAddr any_addr ;
  int tmp ;
  {
  SCK_GetAnyLocalIPAddress((int )addr->family, & any_addr);
  tmp = UTI_CompareIPs((IPAddr const *)(& any_addr), (IPAddr const *)addr, (IPAddr const *)((void *)0));
  return (tmp == 0);
}
}
static int bind_device(int sock_fd , char const *iface )
{
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  {
  tmp___1 = strlen(iface);
  tmp___2 = setsockopt(sock_fd, 1, 25, (void const *)iface, (socklen_t )(tmp___1 + 1UL));
  if (tmp___2 < 0) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  return (1);
}
}
static int bind_ip_address(int sock_fd , IPSockAddr *addr , int flags )
{
  union sockaddr_all saddr ;
  socklen_t saddr_len ;
  int s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  {
  if ((int )addr->port > 0) {
    tmp = SCK_SetIntOption(sock_fd, 1, 2, 1);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  if ((int )addr->port > 0) {
    tmp___1 = SCK_SetIntOption(sock_fd, 1, 15, 1);
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
  } else {
    tmp___2 = 0;
  }
  tmp___3 = SCK_SetIntOption(sock_fd, 0, 15, 1);
  if (tmp___3) {
    tmp___4 = 0;
  } else {
    tmp___4 = 1;
  }
  tmp___5 = SCK_IPSockAddrToSockaddr(addr, (struct sockaddr *)(& saddr), (int )sizeof(saddr));
  saddr_len = (socklen_t )tmp___5;
  if (saddr_len == 0U) {
    return (0);
  }
  if (flags & 16) {
    if (priv_bind_function) {
      s = (*priv_bind_function)(sock_fd, & saddr.sa, saddr_len);
    } else {
      s = bind(sock_fd, (struct sockaddr const * __restrict )(& saddr.sa), saddr_len);
    }
  } else {
    s = bind(sock_fd, (struct sockaddr const * __restrict )(& saddr.sa), saddr_len);
  }
  if (s < 0) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  return (1);
}
}
static int connect_ip_address(int sock_fd , IPSockAddr *addr )
{
  union sockaddr_all saddr ;
  socklen_t saddr_len ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  {
  tmp = SCK_IPSockAddrToSockaddr(addr, (struct sockaddr *)(& saddr), (int )sizeof(saddr));
  saddr_len = (socklen_t )tmp;
  if (saddr_len == 0U) {
    return (0);
  }
  tmp___3 = connect(sock_fd, (struct sockaddr const * __restrict )(& saddr.sa),
                    saddr_len);
  if (tmp___3 < 0) {
    tmp___4 = __errno_location();
    if (*tmp___4 != 115) {
      {
      while (1) {
        while_continue: ;
        goto while_break;
      }
      while_break: ;
      }
      return (0);
    }
  }
  return (1);
}
}
static int open_ip_socket(IPSockAddr *remote_addr , IPSockAddr *local_addr , char const *iface ,
                          int type , int flags )
{
  int domain ;
  int family ;
  int sock_fd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  {
  if (local_addr) {
    family = (int )local_addr->ip_addr.family;
  } else
  if (remote_addr) {
    family = (int )remote_addr->ip_addr.family;
  } else {
    family = 1;
  }
  {
  if (family == 1) {
    goto case_1;
  }
  if (family == 2) {
    goto case_2;
  }
  goto switch_default;
  case_1:
  if (! ip4_enabled) {
    return (-4);
  }
  domain = 2;
  goto switch_break;
  case_2:
  if (! ip6_enabled) {
    return (-4);
  }
  domain = 10;
  goto switch_break;
  switch_default:
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  return (-4);
  switch_break: ;
  }
  sock_fd = open_socket(domain, type, flags);
  if (sock_fd < 0) {
    return (-4);
  }
  tmp = set_socket_options(sock_fd, flags);
  if (! tmp) {
    goto error;
  }
  tmp___0 = set_ip_options(sock_fd, family, flags);
  if (! tmp___0) {
    goto error;
  }
  if (iface) {
    tmp___1 = bind_device(sock_fd, iface);
    if (! tmp___1) {
      goto error;
    }
  }
  if (local_addr) {
    if ((int )local_addr->ip_addr.family != 0) {
      if ((int )local_addr->port != 0) {
        goto _L;
      } else {
        tmp___2 = is_any_address(& local_addr->ip_addr);
        if (! tmp___2) {
          _L:
          tmp___3 = bind_ip_address(sock_fd, local_addr, flags);
          if (! tmp___3) {
            goto error;
          }
        }
      }
    }
  }
  if (remote_addr) {
    if ((int )remote_addr->ip_addr.family != 0) {
      tmp___4 = connect_ip_address(sock_fd, remote_addr);
      if (! tmp___4) {
        goto error;
      }
    }
  }
  if (remote_addr) {
    goto _L___0;
  } else
  if (local_addr) {
    _L___0:
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
  }
  return (sock_fd);
  error:
  SCK_CloseSocket(sock_fd);
  return (-4);
}
}
static int bind_unix_address(int sock_fd , char const *addr , int flags )
{
  union sockaddr_all saddr ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  {
  memset((void *)(& saddr), 0, sizeof(saddr));
  tmp = snprintf(saddr.un.sun_path, sizeof(saddr.un.sun_path), (char const *)"%s",
                 addr);
  if ((unsigned long )tmp >= sizeof(saddr.un.sun_path)) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  saddr.un.sun_family = (sa_family_t )1;
  tmp___2 = unlink(addr);
  if (tmp___2 < 0) {
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
  }
  tmp___5 = bind(sock_fd, (struct sockaddr const * __restrict )(& saddr.sa), (socklen_t )sizeof(saddr.un));
  if (tmp___5 < 0) {
    {
    while (1) {
      while_continue___1: ;
      goto while_break___1;
    }
    while_break___1: ;
    }
    return (0);
  }
  if (flags & 8) {
    tmp___8 = chmod(addr, (__mode_t )0666);
    if (tmp___8 < 0) {
      {
      while (1) {
        while_continue___2: ;
        goto while_break___2;
      }
      while_break___2: ;
      }
      return (0);
    }
  }
  return (1);
}
}
static int connect_unix_address(int sock_fd , char const *addr )
{
  union sockaddr_all saddr ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  {
  memset((void *)(& saddr), 0, sizeof(saddr));
  tmp = snprintf(saddr.un.sun_path, sizeof(saddr.un.sun_path), (char const *)"%s",
                 addr);
  if ((unsigned long )tmp >= sizeof(saddr.un.sun_path)) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  saddr.un.sun_family = (sa_family_t )1;
  tmp___2 = connect(sock_fd, (struct sockaddr const * __restrict )(& saddr.sa),
                    (socklen_t )sizeof(saddr.un));
  if (tmp___2 < 0) {
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
    return (0);
  }
  return (1);
}
}
static int open_unix_socket(char const *remote_addr , char const *local_addr ,
                            int type , int flags )
{
  int sock_fd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const *tmp___2 ;
  char *tmp___3 ;
  char const *tmp___4 ;
  char *tmp___5 ;
  {
  sock_fd = open_socket(1, type, flags);
  if (sock_fd < 0) {
    return (-4);
  }
  tmp = set_socket_options(sock_fd, flags);
  if (! tmp) {
    goto error;
  }
  if (local_addr) {
    tmp___0 = bind_unix_address(sock_fd, local_addr, flags);
    if (! tmp___0) {
      goto error;
    }
  }
  if (remote_addr) {
    tmp___1 = connect_unix_address(sock_fd, remote_addr);
    if (! tmp___1) {
      goto error;
    }
  }
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  return (sock_fd);
  error:
  SCK_RemoveSocket(sock_fd);
  SCK_CloseSocket(sock_fd);
  return (-4);
}
}
static int open_unix_socket_pair(int type , int flags , int *other_fd )
{
  int sock_fd ;
  {
  sock_fd = open_socket_pair(1, type, flags, other_fd);
  if (sock_fd < 0) {
    return (-4);
  }
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  return (sock_fd);
}
}
static int get_recv_flags(int flags )
{
  int recv_flags ;
  {
  recv_flags = 0;
  if (flags & 1) {
    recv_flags |= 8192;
  }
  return (recv_flags);
}
}
static void handle_recv_error(int sock_fd , int flags )
{
  int error ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  {
  if (flags & 1) {
    error = 0;
    tmp___0 = SCK_GetIntOption(sock_fd, 1, 4, & error);
    if (tmp___0) {
      tmp = __errno_location();
      *tmp = error;
    }
  }
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  return;
}
}
static void log_message___0(int sock_fd , int direction , SCK_Message *message , char const *prefix ,
                            char const *error )
{
  char const *local_addr ;
  char const *remote_addr ;
  char if_index[20] ;
  char tss[10] ;
  char tsif[20] ;
  char tslen[20] ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const *tmp___9 ;
  char *tmp___10 ;
  char const *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char const *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  {
  return;
  remote_addr = (char const *)((void *)0);
  local_addr = (char const *)((void *)0);
  if_index[0] = (char )'\000';
  tss[0] = (char )'\000';
  tsif[0] = (char )'\000';
  tslen[0] = (char )'\000';
  {
  if ((unsigned int )message->addr_type == 1U) {
    goto case_1;
  }
  if ((unsigned int )message->addr_type == 2U) {
    goto case_2;
  }
  goto switch_default;
  case_1:
  if ((int )message->remote_addr.ip.ip_addr.family != 0) {
    tmp = UTI_IPSockAddrToString((IPSockAddr const *)(& message->remote_addr.ip));
    remote_addr = (char const *)tmp;
  }
  if ((int )message->local_addr.ip.family != 0) {
    tmp___0 = UTI_IPToString((IPAddr const *)(& message->local_addr.ip));
    local_addr = (char const *)tmp___0;
  }
  goto switch_break;
  case_2:
  remote_addr = message->remote_addr.path;
  goto switch_break;
  switch_default:
  goto switch_break;
  switch_break: ;
  }
  if (message->if_index != -1) {
    snprintf(if_index, sizeof(if_index), (char const *)" if=%d", message->if_index);
  }
  if (direction > 0) {
    tmp___7 = UTI_IsZeroTimespec(& message->timestamp.kernel);
    if (tmp___7) {
      tmp___8 = UTI_IsZeroTimespec(& message->timestamp.hw);
      if (! tmp___8) {
        _L:
        tmp___3 = UTI_IsZeroTimespec(& message->timestamp.hw);
        if (tmp___3) {
          tmp___2 = "";
        } else {
          tmp___2 = "H";
        }
        tmp___6 = UTI_IsZeroTimespec(& message->timestamp.kernel);
        if (tmp___6) {
          tmp___5 = "";
        } else {
          tmp___5 = "K";
        }
        snprintf(tss, sizeof(tss), (char const *)" tss=%s%s", tmp___5, tmp___2);
      }
    } else {
      goto _L;
    }
    if (message->timestamp.if_index != -1) {
      snprintf(tsif, sizeof(tsif), (char const *)" tsif=%d", message->timestamp.if_index);
    }
    if (message->timestamp.l2_length != 0) {
      snprintf(tslen, sizeof(tslen), (char const *)" tslen=%d", message->timestamp.l2_length);
    }
  }
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
}
}
static void init_message_addresses(SCK_Message *message , SCK_AddressType addr_type )
{
  {
  message->addr_type = addr_type;
  {
  if ((unsigned int )addr_type == 0U) {
    goto case_0;
  }
  if ((unsigned int )addr_type == 1U) {
    goto case_1;
  }
  if ((unsigned int )addr_type == 2U) {
    goto case_2;
  }
  goto switch_default;
  case_0:
  goto switch_break;
  case_1:
  message->remote_addr.ip.ip_addr.family = (uint16_t )0;
  message->remote_addr.ip.port = (uint16_t )0;
  message->local_addr.ip.family = (uint16_t )0;
  goto switch_break;
  case_2:
  message->remote_addr.path = (char const *)((void *)0);
  goto switch_break;
  switch_default:
  assert(0);
  switch_break: ;
  }
  return;
}
}
static void init_message_nonaddress(SCK_Message *message )
{
  {
  message->data = (void *)0;
  message->length = 0;
  message->if_index = -1;
  UTI_ZeroTimespec(& message->timestamp.kernel);
  UTI_ZeroTimespec(& message->timestamp.hw);
  message->timestamp.if_index = -1;
  message->timestamp.l2_length = 0;
  message->timestamp.tx_flags = 0;
  message->descriptor = -4;
  return;
}
}
static int match_cmsg(struct cmsghdr *cmsg , int level , int type , size_t length )
{
  {
  if (cmsg->cmsg_type == type) {
    if (cmsg->cmsg_level == level) {
      if (length == 0UL) {
        return (1);
      } else
      if (cmsg->cmsg_len == (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + length) {
        return (1);
      }
    }
  }
  return (0);
}
}
static int process_header(struct msghdr *msg , int msg_length , int sock_fd , int flags ,
                          SCK_Message *message )
{
  struct cmsghdr *cmsg ;
  int r ;
  struct in_pktinfo ipi ;
  struct in6_pktinfo ipi___0 ;
  struct timeval tv ;
  struct scm_ts_pktinfo ts_pktinfo ;
  struct scm_timestamping ts3 ;
  struct sock_extended_err err ;
  int i ;
  int fd___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  {
  r = 1;
  if ((unsigned long )msg->msg_namelen <= sizeof(union sockaddr_all )) {
    if ((unsigned long )msg->msg_namelen > sizeof(((struct sockaddr *)msg->msg_name)->sa_family)) {
      {
      if ((int )((struct sockaddr *)msg->msg_name)->sa_family == 10) {
        goto case_10;
      }
      if ((int )((struct sockaddr *)msg->msg_name)->sa_family == 2) {
        goto case_10;
      }
      if ((int )((struct sockaddr *)msg->msg_name)->sa_family == 1) {
        goto case_1;
      }
      goto switch_default;
      case_10:
      case_2:
      init_message_addresses(message, (SCK_AddressType )1);
      SCK_SockaddrToIPSockAddr((struct sockaddr *)msg->msg_name, (int )msg->msg_namelen,
                               & message->remote_addr.ip);
      goto switch_break;
      case_1:
      init_message_addresses(message, (SCK_AddressType )2);
      message->remote_addr.path = (char const *)(((struct sockaddr_un *)msg->msg_name)->sun_path);
      goto switch_break;
      switch_default:
      init_message_addresses(message, (SCK_AddressType )0);
      {
      while (1) {
        while_continue: ;
        goto while_break;
      }
      while_break: ;
      }
      r = 0;
      goto switch_break;
      switch_break: ;
      }
    } else {
      goto _L;
    }
  } else {
    _L:
    init_message_addresses(message, (SCK_AddressType )0);
    if ((unsigned long )msg->msg_namelen > sizeof(union sockaddr_all )) {
      {
      while (1) {
        while_continue___0: ;
        goto while_break___0;
      }
      while_break___0: ;
      }
      r = 0;
    }
  }
  init_message_nonaddress(message);
  if (msg->msg_iovlen == 1UL) {
    message->data = (msg->msg_iov + 0)->iov_base;
    message->length = msg_length;
  } else {
    {
    while (1) {
      while_continue___1: ;
      goto while_break___1;
    }
    while_break___1: ;
    }
    r = 0;
  }
  if (msg->msg_flags & 32) {
    log_message___0(sock_fd, 1, message, (char const *)"Truncated", (char const *)((void *)0));
    r = 0;
  }
  if (msg->msg_flags & 8) {
    log_message___0(sock_fd, 1, message, (char const *)"Truncated cmsg in", (char const *)((void *)0));
    r = 0;
  }
  if (msg->msg_controllen >= sizeof(struct cmsghdr )) {
    cmsg = (struct cmsghdr *)msg->msg_control;
  } else {
    cmsg = (struct cmsghdr *)0;
  }
  {
  while (1) {
    while_continue___2: ;
    if (! cmsg) {
      goto while_break___2;
    }
    tmp___7 = match_cmsg(cmsg, 0, 8, sizeof(struct in_pktinfo ));
    if (tmp___7) {
      if ((unsigned int )message->addr_type != 1U) {
        init_message_addresses(message, (SCK_AddressType )1);
      }
      memcpy((void *)(& ipi), (void const *)(cmsg->__cmsg_data), sizeof(ipi));
      message->local_addr.ip.addr.in4 = __bswap_32(ipi.ipi_addr.s_addr);
      message->local_addr.ip.family = (uint16_t )1;
      message->if_index = ipi.ipi_ifindex;
    } else {
      tmp___6 = match_cmsg(cmsg, 41, 50, sizeof(struct in6_pktinfo ));
      if (tmp___6) {
        if ((unsigned int )message->addr_type != 1U) {
          init_message_addresses(message, (SCK_AddressType )1);
        }
        memcpy((void *)(& ipi___0), (void const *)(cmsg->__cmsg_data), sizeof(ipi___0));
        memcpy((void *)(& message->local_addr.ip.addr.in6), (void const *)(& ipi___0.ipi6_addr.__in6_u.__u6_addr8),
               sizeof(message->local_addr.ip.addr.in6));
        message->local_addr.ip.family = (uint16_t )2;
        message->if_index = (int )ipi___0.ipi6_ifindex;
      } else {
        tmp___5 = match_cmsg(cmsg, 1, 29, sizeof(struct timeval ));
        if (tmp___5) {
          memcpy((void *)(& tv), (void const *)(cmsg->__cmsg_data), sizeof(tv));
          UTI_TimevalToTimespec((struct timeval const *)(& tv), & message->timestamp.kernel);
        } else {
          tmp___4 = match_cmsg(cmsg, 1, 35, sizeof(message->timestamp.kernel));
          if (tmp___4) {
            memcpy((void *)(& message->timestamp.kernel), (void const *)(cmsg->__cmsg_data),
                   sizeof(message->timestamp.kernel));
          } else {
            tmp___3 = match_cmsg(cmsg, 1, 58, sizeof(struct scm_ts_pktinfo ));
            if (tmp___3) {
              memcpy((void *)(& ts_pktinfo), (void const *)(cmsg->__cmsg_data),
                     sizeof(ts_pktinfo));
              message->timestamp.if_index = (int )ts_pktinfo.if_index;
              message->timestamp.l2_length = (int )ts_pktinfo.pkt_length;
            } else {
              tmp___2 = match_cmsg(cmsg, 1, 37, sizeof(struct scm_timestamping ));
              if (tmp___2) {
                memcpy((void *)(& ts3), (void const *)(cmsg->__cmsg_data), sizeof(ts3));
                message->timestamp.kernel = ts3.ts[0];
                message->timestamp.hw = ts3.ts[2];
              } else {
                tmp___0 = match_cmsg(cmsg, 0, 11, (size_t )0);
                if (tmp___0) {
                  goto _L___2;
                } else {
                  tmp___1 = match_cmsg(cmsg, 41, 25, (size_t )0);
                  if (tmp___1) {
                    _L___2:
                    if (cmsg->cmsg_len >= (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + sizeof(struct sock_extended_err )) {
                      memcpy((void *)(& err), (void const *)(cmsg->__cmsg_data),
                             sizeof(err));
                      if (err.ee_errno != 42U) {
                        log_message___0(sock_fd, 1, message, (char const *)"Unexpected extended error in",
                                        (char const *)((void *)0));
                        r = 0;
                      } else
                      if (err.ee_info != 0U) {
                        log_message___0(sock_fd, 1, message, (char const *)"Unexpected extended error in",
                                        (char const *)((void *)0));
                        r = 0;
                      } else
                      if ((int )err.ee_origin != 4) {
                        log_message___0(sock_fd, 1, message, (char const *)"Unexpected extended error in",
                                        (char const *)((void *)0));
                        r = 0;
                      }
                    } else {
                      goto _L___1;
                    }
                  } else {
                    _L___1:
                    tmp = match_cmsg(cmsg, 1, 1, (size_t )0);
                    if (tmp) {
                      if (! (flags & 2)) {
                        goto _L___0;
                      } else
                      if (cmsg->cmsg_len != (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + sizeof(int )) {
                        _L___0:
                        {
                        while (1) {
                          while_continue___3: ;
                          goto while_break___3;
                        }
                        while_break___3: ;
                        }
                        i = 0;
                        {
                        while (1) {
                          while_continue___4: ;
                          if (! ((((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (unsigned long )(i + 1) * sizeof(int ) <= cmsg->cmsg_len)) {
                            goto while_break___4;
                          }
                          memcpy((void *)(& fd___0), (void const *)((char *)(cmsg->__cmsg_data) + (unsigned long )i * sizeof(int )),
                                 sizeof(fd___0));
                          close(fd___0);
                          i ++;
                        }
                        while_break___4: ;
                        }
                        r = 0;
                      } else {
                        memcpy((void *)(& message->descriptor), (void const *)(cmsg->__cmsg_data),
                               sizeof(message->descriptor));
                      }
                    } else {
                      {
                      while (1) {
                        while_continue___5: ;
                        goto while_break___5;
                      }
                      while_break___5: ;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    cmsg = __cmsg_nxthdr(msg, cmsg);
  }
  while_break___2: ;
  }
  if (! r) {
    if (message->descriptor != -4) {
      close(message->descriptor);
    }
  }
  return (r);
}
}
static SCK_Message *receive_messages(int sock_fd , int flags , int max_messages ,
                                     int *num_messages )
{
  struct mmsghdr *hdr ;
  SCK_Message *messages ;
  unsigned int i ;
  unsigned int n ;
  unsigned int n_ok ;
  int ret ;
  int recv_flags ;
  void *tmp ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  SCK_Message *tmp___6 ;
  {
  recv_flags = 0;
  assert(initialised___3);
  *num_messages = 0;
  if (max_messages < 1) {
    return ((SCK_Message *)((void *)0));
  }
  prepare_buffers(received_messages);
  received_messages = 0U;
  tmp = ARR_GetElements(recv_sck_messages);
  messages = (SCK_Message *)tmp;
  tmp___0 = ARR_GetElements(recv_headers);
  hdr = (struct mmsghdr *)tmp___0;
  n = ARR_GetSize(recv_headers);
  if (n < (unsigned int )max_messages) {
    n = n;
  } else {
    n = (unsigned int )max_messages;
  }
  if (n < 1U) {
    assert(0);
  } else
  if (n > 16U) {
    assert(0);
  } else {
    tmp___1 = ARR_GetSize(recv_messages);
    if (n > tmp___1) {
      assert(0);
    } else {
      tmp___2 = ARR_GetSize(recv_sck_messages);
      if (n > tmp___2) {
        assert(0);
      }
    }
  }
  recv_flags = get_recv_flags(flags);
  ret = recvmmsg(sock_fd, hdr, n, recv_flags, (struct timespec *)((void *)0));
  if (ret >= 0) {
    n = (unsigned int )ret;
  }
  if (ret < 0) {
    handle_recv_error(sock_fd, flags);
    return ((SCK_Message *)((void *)0));
  }
  received_messages = n;
  n_ok = 0U;
  i = n_ok;
  {
  while (1) {
    while_continue: ;
    if (! (i < n)) {
      goto while_break;
    }
    tmp___3 = ARR_GetElement(recv_headers, i);
    hdr = (struct mmsghdr *)tmp___3;
    tmp___4 = process_header(& hdr->msg_hdr, (int )hdr->msg_len, sock_fd, flags, messages + n_ok);
    if (! tmp___4) {
      goto __Cont;
    }
    if (flags & 1) {
      tmp___5 = "Received error";
    } else {
      tmp___5 = "Received";
    }
    log_message___0(sock_fd, 1, messages + n_ok, (char const *)tmp___5, (char const *)((void *)0));
    n_ok ++;
    __Cont:
    i ++;
  }
  while_break: ;
  }
  *num_messages = (int )n_ok;
  if (n_ok > 0U) {
    tmp___6 = messages;
  } else {
    tmp___6 = (SCK_Message *)((void *)0);
  }
  return (tmp___6);
}
}
static void *add_control_message(struct msghdr *msg , int level , int type , size_t length ,
                                 size_t buf_length )
{
  struct cmsghdr *cmsg ;
  size_t cmsg_space ;
  {
  cmsg = (struct cmsghdr *)msg->msg_control;
  cmsg_space = (((length + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL));
  if (! cmsg) {
    goto _L;
  } else
  if (length > buf_length) {
    goto _L;
  } else
  if (msg->msg_controllen + cmsg_space > buf_length) {
    _L:
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return ((void *)0);
  }
  cmsg = (struct cmsghdr *)((char *)cmsg + msg->msg_controllen);
  memset((void *)cmsg, 0, cmsg_space);
  cmsg->cmsg_level = level;
  cmsg->cmsg_type = type;
  cmsg->cmsg_len = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + length;
  msg->msg_controllen += cmsg_space;
  return ((void *)(cmsg->__cmsg_data));
}
}
static int send_message(int sock_fd , SCK_Message *message , int flags )
{
  struct cmsghdr cmsg_buf[256UL / sizeof(struct cmsghdr )] ;
  union sockaddr_all saddr ;
  socklen_t saddr_len ;
  struct msghdr msg ;
  struct iovec iov ;
  int tmp ;
  int tmp___0 ;
  struct in_pktinfo *ipi ;
  void *tmp___1 ;
  struct in6_pktinfo *ipi___0 ;
  void *tmp___2 ;
  int *ts_tx_flags___0 ;
  void *tmp___3 ;
  int *fd___0 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  ssize_t tmp___7 ;
  {
  {
  if ((unsigned int )message->addr_type == 0U) {
    goto case_0;
  }
  if ((unsigned int )message->addr_type == 1U) {
    goto case_1;
  }
  if ((unsigned int )message->addr_type == 2U) {
    goto case_2;
  }
  goto switch_default;
  case_0:
  saddr_len = (socklen_t )0;
  goto switch_break;
  case_1:
  tmp = SCK_IPSockAddrToSockaddr(& message->remote_addr.ip, (struct sockaddr *)(& saddr),
                                 (int )sizeof(saddr));
  saddr_len = (socklen_t )tmp;
  goto switch_break;
  case_2:
  memset((void *)(& saddr), 0, sizeof(saddr));
  tmp___0 = snprintf(saddr.un.sun_path, sizeof(saddr.un.sun_path), (char const *)"%s",
                     message->remote_addr.path);
  if ((unsigned long )tmp___0 >= sizeof(saddr.un.sun_path)) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  saddr.un.sun_family = (sa_family_t )1;
  saddr_len = (socklen_t )sizeof(saddr.un);
  goto switch_break;
  switch_default:
  assert(0);
  switch_break: ;
  }
  if (saddr_len) {
    msg.msg_name = (void *)(& saddr.un);
    msg.msg_namelen = saddr_len;
  } else {
    msg.msg_name = (void *)0;
    msg.msg_namelen = (socklen_t )0;
  }
  if (message->length < 0) {
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
    return (0);
  }
  iov.iov_base = message->data;
  iov.iov_len = (size_t )message->length;
  msg.msg_iov = & iov;
  msg.msg_iovlen = (size_t )1;
  msg.msg_control = (void *)(cmsg_buf);
  msg.msg_controllen = (size_t )0;
  msg.msg_flags = 0;
  if ((unsigned int )message->addr_type == 1U) {
    if ((int )message->local_addr.ip.family == 1) {
      tmp___1 = add_control_message(& msg, 0, 8, sizeof(*ipi), sizeof(cmsg_buf));
      ipi = (struct in_pktinfo *)tmp___1;
      if (! ipi) {
        return (0);
      }
      ipi->ipi_spec_dst.s_addr = __bswap_32(message->local_addr.ip.addr.in4);
      if (message->if_index != -1) {
        ipi->ipi_ifindex = message->if_index;
      }
    }
    if ((int )message->local_addr.ip.family == 2) {
      tmp___2 = add_control_message(& msg, 41, 50, sizeof(*ipi___0), sizeof(cmsg_buf));
      ipi___0 = (struct in6_pktinfo *)tmp___2;
      if (! ipi___0) {
        return (0);
      }
      memcpy((void *)(& ipi___0->ipi6_addr.__in6_u.__u6_addr8), (void const *)(& message->local_addr.ip.addr.in6),
             sizeof(ipi___0->ipi6_addr.__in6_u.__u6_addr8));
      if (message->if_index != -1) {
        ipi___0->ipi6_ifindex = (unsigned int )message->if_index;
      }
    }
  }
  if (message->timestamp.tx_flags) {
    tmp___3 = add_control_message(& msg, 1, 37, sizeof(*ts_tx_flags___0), sizeof(cmsg_buf));
    ts_tx_flags___0 = (int *)tmp___3;
    if (! ts_tx_flags___0) {
      return (0);
    }
    *ts_tx_flags___0 = message->timestamp.tx_flags;
  }
  if (flags & 2) {
    tmp___4 = add_control_message(& msg, 1, 1, sizeof(*fd___0), sizeof(cmsg_buf));
    fd___0 = (int *)tmp___4;
    if (! fd___0) {
      return (0);
    }
    *fd___0 = message->descriptor;
  }
  if (msg.msg_controllen == 0UL) {
    msg.msg_control = (void *)0;
  }
  tmp___7 = sendmsg(sock_fd, (struct msghdr const *)(& msg), 0);
  if (tmp___7 < 0L) {
    tmp___5 = __errno_location();
    tmp___6 = strerror(*tmp___5);
    log_message___0(sock_fd, -1, message, (char const *)"Could not send", (char const *)tmp___6);
    return (0);
  }
  log_message___0(sock_fd, -1, message, (char const *)"Sent", (char const *)((void *)0));
  return (1);
}
}
void SCK_Initialise(int family )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  if (family == 1) {
    tmp = 1;
  } else
  if (family == 0) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  ip4_enabled = tmp;
  if (family == 2) {
    tmp___0 = 1;
  } else
  if (family == 0) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  ip6_enabled = tmp___0;
  recv_messages = ARR_CreateInstance((unsigned int )sizeof(struct Message ));
  ARR_SetSize(recv_messages, 16U);
  recv_headers = ARR_CreateInstance((unsigned int )sizeof(struct mmsghdr ));
  ARR_SetSize(recv_headers, 16U);
  recv_sck_messages = ARR_CreateInstance((unsigned int )sizeof(SCK_Message ));
  ARR_SetSize(recv_sck_messages, 16U);
  received_messages = 16U;
  priv_bind_function = (int (*)(int sock_fd , struct sockaddr *address , socklen_t address_len ))((void *)0);
  supported_socket_flags = 0;
  tmp___1 = check_socket_flag(524288, 1, 0);
  if (tmp___1) {
    supported_socket_flags |= 524288;
  }
  tmp___2 = check_socket_flag(2048, 0, 04000);
  if (tmp___2) {
    supported_socket_flags |= 2048;
  }
  initialised___3 = 1;
  return;
}
}
void SCK_Finalise(void)
{
  {
  ARR_DestroyInstance(recv_sck_messages);
  ARR_DestroyInstance(recv_headers);
  ARR_DestroyInstance(recv_messages);
  initialised___3 = 0;
  return;
}
}
int SCK_IsIpFamilyEnabled(int family )
{
  {
  {
  if (family == 1) {
    goto case_1;
  }
  if (family == 2) {
    goto case_2;
  }
  goto switch_default;
  case_1:
  return (ip4_enabled);
  case_2:
  return (ip6_enabled);
  switch_default:
  return (0);
  switch_break: ;
  }
}
}
void SCK_GetAnyLocalIPAddress(int family , IPAddr *local_addr )
{
  {
  local_addr->family = (uint16_t )family;
  {
  if (family == 1) {
    goto case_1;
  }
  if (family == 2) {
    goto case_2;
  }
  goto switch_break;
  case_1:
  local_addr->addr.in4 = (in_addr_t )0x00000000;
  goto switch_break;
  case_2:
  memcpy((void *)(& local_addr->addr.in6), (void const *)(& in6addr_any), sizeof(local_addr->addr.in6));
  goto switch_break;
  switch_break: ;
  }
  return;
}
}
void SCK_GetLoopbackIPAddress(int family , IPAddr *local_addr )
{
  {
  local_addr->family = (uint16_t )family;
  {
  if (family == 1) {
    goto case_1;
  }
  if (family == 2) {
    goto case_2;
  }
  goto switch_break;
  case_1:
  local_addr->addr.in4 = (in_addr_t )0x7f000001;
  goto switch_break;
  case_2:
  memcpy((void *)(& local_addr->addr.in6), (void const *)(& in6addr_loopback), sizeof(local_addr->addr.in6));
  goto switch_break;
  switch_break: ;
  }
  return;
}
}
int SCK_IsLinkLocalIPAddress(IPAddr *addr )
{
  int tmp ;
  {
  {
  if ((int )addr->family == 1) {
    goto case_1;
  }
  if ((int )addr->family == 2) {
    goto case_2;
  }
  goto switch_default;
  case_1:
  return ((addr->addr.in4 & 0xffff0000) == 0xa9fe0000);
  case_2:
  if ((int )addr->addr.in6[0] == 0xfe) {
    if (((int )addr->addr.in6[1] & 0xc0) == 0x80) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
  switch_default:
  return (0);
  switch_break: ;
  }
}
}
void SCK_SetPrivBind(int (*function)(int sock_fd , struct sockaddr *address , socklen_t address_len ) )
{
  {
  priv_bind_function = function;
  return;
}
}
int SCK_OpenUdpSocket(IPSockAddr *remote_addr , IPSockAddr *local_addr , char const *iface ,
                      int flags )
{
  int tmp ;
  {
  tmp = open_ip_socket(remote_addr, local_addr, iface, 2, flags);
  return (tmp);
}
}
int SCK_OpenTcpSocket(IPSockAddr *remote_addr , IPSockAddr *local_addr , char const *iface ,
                      int flags )
{
  int tmp ;
  {
  tmp = open_ip_socket(remote_addr, local_addr, iface, 1, flags);
  return (tmp);
}
}
int SCK_OpenUnixDatagramSocket(char const *remote_addr , char const *local_addr ,
                               int flags )
{
  int tmp ;
  {
  tmp = open_unix_socket(remote_addr, local_addr, 2, flags);
  return (tmp);
}
}
int SCK_OpenUnixStreamSocket(char const *remote_addr , char const *local_addr ,
                             int flags )
{
  int tmp ;
  {
  tmp = open_unix_socket(remote_addr, local_addr, 1, flags);
  return (tmp);
}
}
int SCK_OpenUnixSocketPair(int flags , int *other_fd )
{
  int sock_fd ;
  {
  sock_fd = open_unix_socket_pair(5, flags, other_fd);
  if (sock_fd < 0) {
    sock_fd = open_unix_socket_pair(2, flags, other_fd);
    if (sock_fd < 0) {
      return (-4);
    }
  }
  return (sock_fd);
}
}
int SCK_SetIntOption(int sock_fd , int level , int name , int value )
{
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  {
  tmp___1 = setsockopt(sock_fd, level, name, (void const *)(& value), (socklen_t )sizeof(value));
  if (tmp___1 < 0) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  return (1);
}
}
int SCK_GetIntOption(int sock_fd , int level , int name , int *value )
{
  socklen_t len ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  {
  len = (socklen_t )sizeof(*value);
  tmp___1 = getsockopt(sock_fd, level, name, (void * __restrict )value, (socklen_t * __restrict )(& len));
  if (tmp___1 < 0) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  return (1);
}
}
int SCK_EnableKernelRxTimestamping(int sock_fd )
{
  int tmp ;
  int tmp___0 ;
  {
  tmp = SCK_SetIntOption(sock_fd, 1, 35, 1);
  if (tmp) {
    return (1);
  }
  tmp___0 = SCK_SetIntOption(sock_fd, 1, 29, 1);
  if (tmp___0) {
    return (1);
  }
  return (0);
}
}
int SCK_ListenOnSocket(int sock_fd , int backlog )
{
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  {
  tmp___1 = listen(sock_fd, backlog);
  if (tmp___1 < 0) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  return (1);
}
}
int SCK_AcceptConnection(int sock_fd , IPSockAddr *remote_addr )
{
  union sockaddr_all saddr ;
  socklen_t saddr_len ;
  int conn_fd ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  saddr_len = (socklen_t )sizeof(saddr);
  conn_fd = accept(sock_fd, (struct sockaddr * __restrict )(& saddr.sa), (socklen_t * __restrict )(& saddr_len));
  if (conn_fd < 0) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (-4);
  }
  tmp___1 = UTI_FdSetCloexec(conn_fd);
  if (tmp___1) {
    tmp___2 = set_socket_nonblock(conn_fd);
    if (! tmp___2) {
      close(conn_fd);
      return (-4);
    }
  } else {
    close(conn_fd);
    return (-4);
  }
  SCK_SockaddrToIPSockAddr(& saddr.sa, (int )saddr_len, remote_addr);
  return (conn_fd);
}
}
int SCK_ShutdownConnection(int sock_fd )
{
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  {
  tmp___1 = shutdown(sock_fd, 2);
  if (tmp___1 < 0) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  return (1);
}
}
int SCK_Receive(int sock_fd , void *buffer , int length , int flags )
{
  int r ;
  int tmp ;
  ssize_t tmp___0 ;
  {
  if (length < 0) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (-1);
  }
  tmp = get_recv_flags(flags);
  tmp___0 = recv(sock_fd, buffer, (size_t )length, tmp);
  r = (int )tmp___0;
  if (r < 0) {
    handle_recv_error(sock_fd, flags);
    return (r);
  }
  {
  while (1) {
    while_continue___0: ;
    goto while_break___0;
  }
  while_break___0: ;
  }
  return (r);
}
}
int SCK_Send(int sock_fd , void const *buffer , int length , int flags )
{
  int r ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  {
  assert(flags == 0);
  if (length < 0) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (-1);
  }
  tmp = send(sock_fd, buffer, (size_t )length, 0);
  r = (int )tmp;
  if (r < 0) {
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
    return (r);
  }
  {
  while (1) {
    while_continue___1: ;
    goto while_break___1;
  }
  while_break___1: ;
  }
  return (r);
}
}
SCK_Message *SCK_ReceiveMessage(int sock_fd , int flags )
{
  int num_messages ;
  SCK_Message *tmp ;
  {
  tmp = receive_messages(sock_fd, flags, 1, & num_messages);
  return (tmp);
}
}
SCK_Message *SCK_ReceiveMessages(int sock_fd , int flags , int *num_messages )
{
  SCK_Message *tmp ;
  {
  tmp = receive_messages(sock_fd, flags, 16, num_messages);
  return (tmp);
}
}
void SCK_InitMessage(SCK_Message *message , SCK_AddressType addr_type )
{
  {
  init_message_addresses(message, addr_type);
  init_message_nonaddress(message);
  return;
}
}
int SCK_SendMessage(int sock_fd , SCK_Message *message , int flags )
{
  int tmp ;
  {
  tmp = send_message(sock_fd, message, flags);
  return (tmp);
}
}
int SCK_RemoveSocket(int sock_fd )
{
  union sockaddr_all saddr ;
  socklen_t saddr_len ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  {
  saddr_len = (socklen_t )sizeof(saddr);
  tmp___1 = getsockname(sock_fd, (struct sockaddr * __restrict )(& saddr.sa), (socklen_t * __restrict )(& saddr_len));
  if (tmp___1 < 0) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  if ((unsigned long )saddr_len > sizeof(saddr)) {
    return (0);
  } else
  if ((unsigned long )saddr_len <= sizeof(saddr.sa.sa_family)) {
    return (0);
  } else
  if ((int )saddr.sa.sa_family != 1) {
    return (0);
  }
  tmp___4 = unlink((char const *)(saddr.un.sun_path));
  if (tmp___4 < 0) {
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
    return (0);
  }
  return (1);
}
}
void SCK_CloseSocket(int sock_fd )
{
  {
  close(sock_fd);
  return;
}
}
void SCK_SockaddrToIPSockAddr(struct sockaddr *sa , int sa_length , IPSockAddr *ip_sa )
{
  {
  ip_sa->ip_addr.family = (uint16_t )0;
  ip_sa->port = (uint16_t )0;
  {
  if ((int )sa->sa_family == 2) {
    goto case_2;
  }
  if ((int )sa->sa_family == 10) {
    goto case_10;
  }
  goto switch_default;
  case_2:
  if (sa_length < (int )sizeof(struct sockaddr_in )) {
    return;
  }
  ip_sa->ip_addr.family = (uint16_t )1;
  ip_sa->ip_addr.addr.in4 = __bswap_32(((struct sockaddr_in *)sa)->sin_addr.s_addr);
  ip_sa->port = __bswap_16(((struct sockaddr_in *)sa)->sin_port);
  goto switch_break;
  case_10:
  if (sa_length < (int )sizeof(struct sockaddr_in6 )) {
    return;
  }
  ip_sa->ip_addr.family = (uint16_t )2;
  memcpy((void *)(& ip_sa->ip_addr.addr.in6), (void const *)(((struct sockaddr_in6 *)sa)->sin6_addr.__in6_u.__u6_addr8),
         sizeof(ip_sa->ip_addr.addr.in6));
  ip_sa->port = __bswap_16(((struct sockaddr_in6 *)sa)->sin6_port);
  goto switch_break;
  switch_default:
  goto switch_break;
  switch_break: ;
  }
  return;
}
}
int SCK_IPSockAddrToSockaddr(IPSockAddr *ip_sa , struct sockaddr *sa , int sa_length )
{
  {
  {
  if ((int )ip_sa->ip_addr.family == 1) {
    goto case_1;
  }
  if ((int )ip_sa->ip_addr.family == 2) {
    goto case_2;
  }
  goto switch_default;
  case_1:
  if (sa_length < (int )sizeof(struct sockaddr_in )) {
    return (0);
  }
  memset((void *)sa, 0, sizeof(struct sockaddr_in ));
  sa->sa_family = (sa_family_t )2;
  ((struct sockaddr_in *)sa)->sin_addr.s_addr = __bswap_32(ip_sa->ip_addr.addr.in4);
  ((struct sockaddr_in *)sa)->sin_port = __bswap_16(ip_sa->port);
  return ((int )sizeof(struct sockaddr_in ));
  case_2:
  if (sa_length < (int )sizeof(struct sockaddr_in6 )) {
    return (0);
  }
  memset((void *)sa, 0, sizeof(struct sockaddr_in6 ));
  sa->sa_family = (sa_family_t )10;
  memcpy((void *)(& ((struct sockaddr_in6 *)sa)->sin6_addr.__in6_u.__u6_addr8), (void const *)(ip_sa->ip_addr.addr.in6),
         sizeof(((struct sockaddr_in6 *)sa)->sin6_addr.__in6_u.__u6_addr8));
  ((struct sockaddr_in6 *)sa)->sin6_port = __bswap_16(ip_sa->port);
  return ((int )sizeof(struct sockaddr_in6 ));
  switch_default:
  if (sa_length < (int )sizeof(struct sockaddr )) {
    return (0);
  }
  memset((void *)sa, 0, sizeof(struct sockaddr ));
  sa->sa_family = (sa_family_t )0;
  return (0);
  switch_break: ;
  }
}
}
static int initialised___4 = 0;
static struct SRC_Instance_Record **sources ;
static struct Sort_Element *sort_list ;
static int *sel_sources ;
static int n_sources ;
static int max_n_sources ;
static int selected_source_index ;
static double max_distance___0 ;
static double max_jitter___0 ;
static double reselect_distance___0 ;
static double stratum_weight___0 ;
static double combine_limit___0 ;
static void update_sel_options(void) ;
static void slew_sources(struct timespec *raw , struct timespec *cooked , double dfreq ,
                         double doffset , LCL_ChangeType change_type , void *anything ) ;
static void add_dispersion(double dispersion , void *anything ) ;
static char *source_to_string(SRC_Instance inst ) ;
void SRC_Initialise(void)
{
  {
  sources = (struct SRC_Instance_Record **)((void *)0);
  sort_list = (struct Sort_Element *)((void *)0);
  sel_sources = (int *)((void *)0);
  n_sources = 0;
  max_n_sources = 0;
  selected_source_index = -1;
  max_distance___0 = CNF_GetMaxDistance();
  max_jitter___0 = CNF_GetMaxJitter();
  reselect_distance___0 = CNF_GetReselectDistance();
  stratum_weight___0 = CNF_GetStratumWeight();
  combine_limit___0 = CNF_GetCombineLimit();
  initialised___4 = 1;
  LCL_AddParameterChangeHandler(& slew_sources, (void *)0);
  LCL_AddDispersionNotifyHandler(& add_dispersion, (void *)0);
  return;
}
}
void SRC_Finalise(void)
{
  {
  LCL_RemoveParameterChangeHandler(& slew_sources, (void *)0);
  LCL_RemoveDispersionNotifyHandler(& add_dispersion, (void *)0);
  free((void *)sources);
  free((void *)sort_list);
  free((void *)sel_sources);
  initialised___4 = 0;
  return;
}
}
SRC_Instance SRC_CreateNewInstance(uint32_t ref_id , SRC_Type type , int authenticated ,
                                   int sel_options , IPAddr *addr , int min_samples___0 ,
                                   int max_samples___0 , double min_delay , double asymmetry )
{
  SRC_Instance result ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  {
  assert(initialised___4);
  if (min_samples___0 == -1) {
    min_samples___0 = CNF_GetMinSamples();
  }
  if (max_samples___0 == -1) {
    max_samples___0 = CNF_GetMaxSamples();
  }
  tmp = Malloc(sizeof(struct SRC_Instance_Record ));
  result = (struct SRC_Instance_Record *)tmp;
  result->stats = SST_CreateInstance(ref_id, addr, min_samples___0, max_samples___0,
                                     min_delay, asymmetry);
  if (n_sources == max_n_sources) {
    if (max_n_sources > 0) {
      max_n_sources = 2 * max_n_sources;
    } else {
      max_n_sources = 4;
    }
    if (sources) {
      tmp___0 = Realloc2((void *)sources, (size_t )max_n_sources, sizeof(struct SRC_Instance_Record *));
      sources = (struct SRC_Instance_Record **)tmp___0;
      tmp___1 = Realloc2((void *)sort_list, (size_t )(3 * max_n_sources), sizeof(struct Sort_Element ));
      sort_list = (struct Sort_Element *)tmp___1;
      tmp___2 = Realloc2((void *)sel_sources, (size_t )max_n_sources, sizeof(int ));
      sel_sources = (int *)tmp___2;
    } else {
      tmp___3 = Malloc2((size_t )max_n_sources, sizeof(struct SRC_Instance_Record *));
      sources = (struct SRC_Instance_Record **)tmp___3;
      tmp___4 = Malloc2((size_t )(3 * max_n_sources), sizeof(struct Sort_Element ));
      sort_list = (struct Sort_Element *)tmp___4;
      tmp___5 = Malloc2((size_t )max_n_sources, sizeof(int ));
      sel_sources = (int *)tmp___5;
    }
  }
  *(sources + n_sources) = result;
  result->index = n_sources;
  result->type = type;
  result->authenticated = authenticated;
  result->conf_sel_options = sel_options;
  result->sel_options = sel_options;
  result->active = 0;
  SRC_SetRefid(result, ref_id, addr);
  SRC_ResetInstance(result);
  n_sources ++;
  update_sel_options();
  return (result);
}
}
void SRC_DestroyInstance(SRC_Instance instance )
{
  int dead_index ;
  int i ;
  {
  assert(initialised___4);
  SST_DeleteInstance(instance->stats);
  dead_index = instance->index;
  i = dead_index;
  {
  while (1) {
    while_continue: ;
    if (! (i < n_sources - 1)) {
      goto while_break;
    }
    *(sources + i) = *(sources + (i + 1));
    (*(sources + i))->index = i;
    i ++;
  }
  while_break: ;
  }
  n_sources --;
  free((void *)instance);
  update_sel_options();
  if (selected_source_index == dead_index) {
    SRC_ReselectSource();
  } else
  if (selected_source_index > dead_index) {
    selected_source_index --;
  }
  return;
}
}
void SRC_ResetInstance(SRC_Instance instance )
{
  {
  instance->updates = 0;
  instance->reachability = 0;
  instance->reachability_size = 0;
  instance->distant = 0;
  instance->status = (SRC_Status )2;
  instance->sel_score = 1.0;
  instance->stratum = 0;
  instance->leap = (NTP_Leap )3;
  instance->leap_vote = 0;
  memset((void *)(& instance->sel_info), 0, sizeof(instance->sel_info));
  SST_ResetInstance(instance->stats);
  return;
}
}
void SRC_SetRefid(SRC_Instance instance , uint32_t ref_id , IPAddr *addr )
{
  {
  instance->ref_id = ref_id;
  instance->ip_addr = addr;
  SST_SetRefid(instance->stats, ref_id, addr);
  return;
}
}
SST_Stats SRC_GetSourcestats(SRC_Instance instance )
{
  {
  assert(initialised___4);
  return (instance->stats);
}
}
static NTP_Leap get_leap_status(void)
{
  int i ;
  int leap_votes ;
  int leap_ins ;
  int leap_del ;
  {
  leap_votes = 0;
  leap_del = leap_votes;
  leap_ins = leap_del;
  i = leap_ins;
  {
  while (1) {
    while_continue: ;
    if (! (i < n_sources)) {
      goto while_break;
    }
    if (! (*(sources + i))->leap_vote) {
      goto __Cont;
    }
    leap_votes ++;
    if ((unsigned int )(*(sources + i))->leap == 1U) {
      leap_ins ++;
    } else
    if ((unsigned int )(*(sources + i))->leap == 2U) {
      leap_del ++;
    }
    __Cont:
    i ++;
  }
  while_break: ;
  }
  if (leap_ins > leap_votes / 2) {
    return ((NTP_Leap )1);
  } else
  if (leap_del > leap_votes / 2) {
    return ((NTP_Leap )2);
  } else {
    return ((NTP_Leap )0);
  }
}
}
void SRC_UpdateStatus(SRC_Instance inst , int stratum , NTP_Leap leap )
{
  int tmp ;
  NTP_Leap tmp___0 ;
  {
  inst->stratum = stratum;
  tmp = REF_IsLeapSecondClose((struct timespec *)((void *)0), 0.0);
  if (tmp) {
    return;
  }
  inst->leap = leap;
  if (inst->leap_vote) {
    tmp___0 = get_leap_status();
    REF_UpdateLeapStatus(tmp___0);
  }
  return;
}
}
void SRC_AccumulateSample(SRC_Instance inst , NTP_Sample *sample )
{
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  {
  assert(initialised___4);
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  tmp___1 = REF_IsLeapSecondClose(& sample->time, sample->offset);
  if (tmp___1) {
    LOG_Message((LOG_Severity )0, (char const *)"Dropping sample around leap second");
    return;
  }
  SST_AccumulateSample(inst->stats, sample);
  SST_DoNewRegression(inst->stats);
  return;
}
}
void SRC_SetActive(SRC_Instance inst )
{
  {
  inst->active = 1;
  return;
}
}
void SRC_UnsetActive(SRC_Instance inst )
{
  {
  inst->active = 0;
  return;
}
}
static int special_mode_end(void)
{
  int i ;
  int tmp ;
  {
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < n_sources)) {
      goto while_break;
    }
    if (! (*(sources + i))->active) {
      goto __Cont;
    }
    if ((*(sources + i))->reachability_size >= 7) {
      goto __Cont;
    }
    tmp = SST_Samples((*(sources + i))->stats);
    if ((7 - (*(sources + i))->reachability_size) + tmp >= 3) {
      return (0);
    }
    __Cont:
    i ++;
  }
  while_break: ;
  }
  return (1);
}
}
void SRC_UpdateReachability(SRC_Instance inst , int reachable )
{
  REF_Mode tmp ;
  int tmp___0 ;
  {
  inst->reachability <<= 1;
  inst->reachability |= ! (! reachable);
  inst->reachability = (int )((unsigned int )inst->reachability % (1U << 8));
  if (inst->reachability_size < 8) {
    (inst->reachability_size) ++;
  }
  if (! reachable) {
    if (inst->index == selected_source_index) {
      SRC_SelectSource((SRC_Instance )((void *)0));
    }
  }
  tmp = REF_GetMode();
  if ((unsigned int )tmp != 0U) {
    tmp___0 = special_mode_end();
    if (tmp___0) {
      REF_SetUnsynchronised();
    }
  }
  if ((unsigned int )inst->type == 0U) {
    if (! inst->reachability) {
      if (inst->reachability_size == 8) {
        NSR_HandleBadSource(inst->ip_addr);
      } else {
        goto _L;
      }
    } else
    _L:
    if ((unsigned int )inst->status == 3U) {
      NSR_HandleBadSource(inst->ip_addr);
    } else
    if ((unsigned int )inst->status == 4U) {
      NSR_HandleBadSource(inst->ip_addr);
    } else
    if ((unsigned int )inst->status == 9U) {
      NSR_HandleBadSource(inst->ip_addr);
    }
  }
  return;
}
}
void SRC_ResetReachability(SRC_Instance inst )
{
  {
  inst->reachability = 0;
  inst->reachability_size = 0;
  SRC_UpdateReachability(inst, 0);
  return;
}
}
static void update_sel_options(void)
{
  int options ;
  int auth_ntp_options ;
  int unauth_ntp_options ;
  int refclk_options ;
  int i ;
  int auth_ntp_sources ;
  int unauth_ntp_sources ;
  SRC_AuthSelectMode tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  {
  unauth_ntp_sources = 0;
  auth_ntp_sources = unauth_ntp_sources;
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < n_sources)) {
      goto while_break;
    }
    if ((*(sources + i))->conf_sel_options & 0x1) {
      goto __Cont;
    }
    if ((unsigned int )(*(sources + i))->type != 0U) {
      goto __Cont;
    }
    if ((*(sources + i))->authenticated) {
      auth_ntp_sources ++;
    } else {
      unauth_ntp_sources ++;
    }
    __Cont:
    i ++;
  }
  while_break: ;
  }
  refclk_options = 0;
  unauth_ntp_options = refclk_options;
  auth_ntp_options = unauth_ntp_options;
  tmp = CNF_GetAuthSelectMode();
  {
  if ((unsigned int )tmp == 0U) {
    goto case_0;
  }
  if ((unsigned int )tmp == 1U) {
    goto case_1;
  }
  if ((unsigned int )tmp == 2U) {
    goto case_2;
  }
  if ((unsigned int )tmp == 3U) {
    goto case_3;
  }
  goto switch_default;
  case_0:
  goto switch_break;
  case_1:
  if (auth_ntp_sources > 0) {
    if (unauth_ntp_sources > 0) {
      refclk_options = 12;
      auth_ntp_options = refclk_options;
    }
  }
  goto switch_break;
  case_2:
  if (auth_ntp_sources > 0) {
    unauth_ntp_options = 0x1;
  }
  goto switch_break;
  case_3:
  unauth_ntp_options = 0x1;
  goto switch_break;
  switch_default:
  assert(0);
  switch_break: ;
  }
  i = 0;
  {
  while (1) {
    while_continue___0: ;
    if (! (i < n_sources)) {
      goto while_break___0;
    }
    options = (*(sources + i))->conf_sel_options;
    if (options & 0x1) {
      goto __Cont___0;
    }
    {
    if ((unsigned int )(*(sources + i))->type == 0U) {
      goto case_0___0;
    }
    if ((unsigned int )(*(sources + i))->type == 1U) {
      goto case_1___0;
    }
    goto switch_default___0;
    case_0___0:
    if ((*(sources + i))->authenticated) {
      tmp___0 = auth_ntp_options;
    } else {
      tmp___0 = unauth_ntp_options;
    }
    options |= tmp___0;
    goto switch_break___0;
    case_1___0:
    options |= refclk_options;
    goto switch_break___0;
    switch_default___0:
    assert(0);
    switch_break___0: ;
    }
    if ((*(sources + i))->sel_options != options) {
      {
      while (1) {
        while_continue___1: ;
        goto while_break___1;
      }
      while_break___1: ;
      }
      (*(sources + i))->sel_options = options;
    }
    __Cont___0:
    i ++;
  }
  while_break___0: ;
  }
  return;
}
}
static void log_selection_message(char const *format , char const *arg )
{
  REF_Mode tmp ;
  {
  tmp = REF_GetMode();
  if ((unsigned int )tmp != 0U) {
    return;
  }
  LOG_Message((LOG_Severity )0, format, arg);
  return;
}
}
static void log_selection_source(char const *format , SRC_Instance inst )
{
  char buf[320] ;
  char *name ;
  char *ntp_name ;
  char *tmp ;
  int tmp___0 ;
  {
  name = source_to_string(inst);
  if ((unsigned int )inst->type == 0U) {
    tmp = NSR_GetName(inst->ip_addr);
    ntp_name = tmp;
  } else {
    ntp_name = (char *)((void *)0);
  }
  if (ntp_name) {
    tmp___0 = strcmp((char const *)name, (char const *)ntp_name);
    if (tmp___0 != 0) {
      snprintf(buf, sizeof(buf), (char const *)"%s (%s)", name, ntp_name);
    } else {
      snprintf(buf, sizeof(buf), (char const *)"%s", name);
    }
  } else {
    snprintf(buf, sizeof(buf), (char const *)"%s", name);
  }
  log_selection_message(format, (char const *)(buf));
  return;
}
}
static int compare_sort_elements(void const *a , void const *b )
{
  struct Sort_Element const *u ;
  struct Sort_Element const *v ;
  {
  u = (struct Sort_Element const *)a;
  v = (struct Sort_Element const *)b;
  if (u->offset < v->offset) {
    return (-1);
  } else
  if (u->offset > v->offset) {
    return (1);
  } else
  if ((int )u->tag < (int )v->tag) {
    return (-1);
  } else
  if ((int )u->tag > (int )v->tag) {
    return (1);
  } else {
    return (0);
  }
}
}
static char *source_to_string(SRC_Instance inst )
{
  char *tmp ;
  char *tmp___0 ;
  {
  {
  if ((unsigned int )inst->type == 0U) {
    goto case_0;
  }
  if ((unsigned int )inst->type == 1U) {
    goto case_1;
  }
  goto switch_default;
  case_0:
  tmp = UTI_IPToString((IPAddr const *)inst->ip_addr);
  return (tmp);
  case_1:
  tmp___0 = UTI_RefidToString(inst->ref_id);
  return (tmp___0);
  switch_default:
  assert(0);
  switch_break: ;
  }
  return ((char *)((void *)0));
}
}
static void mark_source(SRC_Instance inst , SRC_Status status )
{
  char *tmp ;
  {
  inst->status = status;
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  return;
}
}
static void mark_ok_sources(SRC_Status status )
{
  int i ;
  {
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < n_sources)) {
      goto while_break;
    }
    if ((unsigned int )(*(sources + i))->status != 0U) {
      goto __Cont;
    }
    mark_source(*(sources + i), status);
    __Cont:
    i ++;
  }
  while_break: ;
  }
  return;
}
}
static int combine_sources(int n_sel_sources , struct timespec *ref_time , double *offset ,
                           double *offset_sd , double *frequency , double *frequency_sd ,
                           double *skew )
{
  struct timespec src_ref_time ;
  double src_offset ;
  double src_offset_sd ;
  double src_frequency ;
  double src_frequency_sd ;
  double src_skew ;
  double src_root_delay ;
  double src_root_dispersion ;
  double sel_src_distance ;
  double elapsed ;
  double offset_weight ;
  double sum_offset_weight ;
  double sum_offset ;
  double sum2_offset_sd ;
  double frequency_weight ;
  double sum_frequency_weight ;
  double sum_frequency ;
  double inv_sum2_frequency_sd ;
  double inv_sum2_skew ;
  int i ;
  int index___0 ;
  int combined ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  {
  if (n_sel_sources == 1) {
    return (1);
  }
  sum2_offset_sd = 0.0;
  sum_offset = sum2_offset_sd;
  sum_offset_weight = sum_offset;
  inv_sum2_skew = 0.0;
  inv_sum2_frequency_sd = inv_sum2_skew;
  sum_frequency = inv_sum2_frequency_sd;
  sum_frequency_weight = sum_frequency;
  sel_src_distance = (*(sources + selected_source_index))->sel_info.root_distance;
  if ((unsigned int )(*(sources + selected_source_index))->type == 0U) {
    sel_src_distance += reselect_distance___0;
  }
  combined = 0;
  i = combined;
  {
  while (1) {
    while_continue: ;
    if (! (i < n_sel_sources)) {
      goto while_break;
    }
    index___0 = *(sel_sources + i);
    SST_GetTrackingData((*(sources + index___0))->stats, & src_ref_time, & src_offset,
                        & src_offset_sd, & src_frequency, & src_frequency_sd, & src_skew,
                        & src_root_delay, & src_root_dispersion);
    if (index___0 != selected_source_index) {
      if ((*(sources + index___0))->sel_info.root_distance > combine_limit___0 * sel_src_distance) {
        goto _L___0;
      } else {
        tmp = fabs(*frequency - src_frequency);
        tmp___0 = LCL_GetMaxClockError();
        if (tmp > combine_limit___0 * ((*skew + src_skew) + tmp___0)) {
          _L___0:
          if ((*(sources + index___0))->reachability_size >= 8) {
            (*(sources + index___0))->distant = 32;
          } else {
            (*(sources + index___0))->distant = 1;
          }
        } else {
          goto _L;
        }
      }
    } else
    _L:
    if ((*(sources + index___0))->distant) {
      ((*(sources + index___0))->distant) --;
    }
    if ((*(sources + index___0))->distant) {
      mark_source(*(sources + index___0), (SRC_Status )13);
      goto __Cont;
    }
    if ((unsigned int )(*(sources + index___0))->status == 0U) {
      mark_source(*(sources + index___0), (SRC_Status )15);
    }
    elapsed = UTI_DiffTimespecsToDouble((struct timespec const *)ref_time, (struct timespec const *)(& src_ref_time));
    src_offset += elapsed * src_frequency;
    src_offset_sd += elapsed * src_frequency_sd;
    offset_weight = 1.0 / (*(sources + index___0))->sel_info.root_distance;
    frequency_weight = 1.0 / (src_frequency_sd * src_frequency_sd);
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
    sum_offset_weight += offset_weight;
    sum_offset += offset_weight * src_offset;
    sum2_offset_sd += offset_weight * (src_offset_sd * src_offset_sd + (src_offset - *offset) * (src_offset - *offset));
    sum_frequency_weight += frequency_weight;
    sum_frequency += frequency_weight * src_frequency;
    inv_sum2_frequency_sd += 1.0 / (src_frequency_sd * src_frequency_sd);
    inv_sum2_skew += 1.0 / (src_skew * src_skew);
    combined ++;
    __Cont:
    i ++;
  }
  while_break: ;
  }
  assert(combined);
  *offset = sum_offset / sum_offset_weight;
  *offset_sd = sqrt(sum2_offset_sd / sum_offset_weight);
  *frequency = sum_frequency / sum_frequency_weight;
  tmp___1 = sqrt(inv_sum2_frequency_sd);
  *frequency_sd = 1.0 / tmp___1;
  tmp___2 = sqrt(inv_sum2_skew);
  *skew = 1.0 / tmp___2;
  {
  while (1) {
    while_continue___1: ;
    goto while_break___1;
  }
  while_break___1: ;
  }
  return (combined);
}
}
void SRC_SelectSource(SRC_Instance updated_inst )
{
  struct SelectInfo *si ;
  struct timespec now ;
  struct timespec ref_time ;
  int i ;
  int j ;
  int j1___0 ;
  int j2 ;
  int index___0 ;
  int sel_prefer ;
  int n_endpoints ;
  int n_sel_sources ;
  int sel_req_source ;
  int n_badstats_sources ;
  int max_sel_reach ;
  int max_sel_reach_size ;
  int max_badstat_reach ;
  int depth ;
  int best_depth ;
  int trust_depth ;
  int best_trust_depth ;
  int n_sel_trust_sources ;
  int combined ;
  int stratum ;
  int min_stratum ;
  int max_score_index ;
  int orphan_stratum ;
  int orphan_source ;
  double src_offset ;
  double src_offset_sd ;
  double src_frequency ;
  double src_frequency_sd ;
  double src_skew ;
  double src_root_delay ;
  double src_root_dispersion ;
  double best_lo ;
  double best_hi ;
  double distance ;
  double sel_src_distance ;
  double max_score ;
  double best_trust_lo ;
  double best_trust_hi ;
  double first_sample_ago ;
  double max_reach_sample_ago ;
  NTP_Leap leap_status ;
  double extra_disp ;
  double tmp ;
  uint32_t local_ref_id ;
  uint32_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  {
  if (updated_inst) {
    (updated_inst->updates) ++;
  }
  if (n_sources == 0) {
    if (selected_source_index != -1) {
      log_selection_message((char const *)"Can\'t synchronise: no sources", (char const *)((void *)0));
      selected_source_index = -1;
    }
    return;
  }
  SCH_GetLastEventTime(& now, (double *)((void *)0), (struct timespec *)((void *)0));
  n_endpoints = 0;
  n_sel_trust_sources = 0;
  n_sel_sources = n_sel_trust_sources;
  n_badstats_sources = 0;
  sel_req_source = 0;
  max_badstat_reach = 0;
  max_sel_reach = max_badstat_reach;
  max_sel_reach_size = 0;
  max_reach_sample_ago = 0.0;
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < n_sources)) {
      goto while_break;
    }
    assert((unsigned int )(*(sources + i))->status != 0U);
    (*(sources + i))->leap_vote = 0;
    if ((*(sources + i))->sel_options & 0x8) {
      sel_req_source = 1;
    }
    if ((*(sources + i))->sel_options & 0x1) {
      mark_source(*(sources + i), (SRC_Status )1);
      goto __Cont;
    }
    si = & (*(sources + i))->sel_info;
    SST_GetSelectionData((*(sources + i))->stats, & now, & si->lo_limit, & si->hi_limit,
                         & si->root_distance, & si->std_dev, & first_sample_ago, & si->last_sample_ago,
                         & si->select_ok);
    if (! si->select_ok) {
      n_badstats_sources ++;
      mark_source(*(sources + i), (SRC_Status )2);
      if (max_badstat_reach < (*(sources + i))->reachability) {
        max_badstat_reach = (*(sources + i))->reachability;
      }
      goto __Cont;
    }
    if (first_sample_ago < 2.0 * si->last_sample_ago) {
      tmp = LCL_GetMaxClockError();
      extra_disp = tmp * (2.0 * si->last_sample_ago - first_sample_ago);
      si->root_distance += extra_disp;
      si->lo_limit -= extra_disp;
      si->hi_limit += extra_disp;
    }
    if (si->root_distance <= max_distance___0) {
      if (! (si->lo_limit <= si->hi_limit)) {
        mark_source(*(sources + i), (SRC_Status )3);
        goto __Cont;
      }
    } else {
      mark_source(*(sources + i), (SRC_Status )3);
      goto __Cont;
    }
    if (si->std_dev > max_jitter___0) {
      mark_source(*(sources + i), (SRC_Status )4);
      goto __Cont;
    }
    (*(sources + i))->status = (SRC_Status )0;
    if ((*(sources + i))->reachability) {
      if (max_reach_sample_ago < first_sample_ago) {
        max_reach_sample_ago = first_sample_ago;
      }
    }
    if (max_sel_reach < (*(sources + i))->reachability) {
      max_sel_reach = (*(sources + i))->reachability;
    }
    if (max_sel_reach_size < (*(sources + i))->reachability_size) {
      max_sel_reach_size = (*(sources + i))->reachability_size;
    }
    __Cont:
    i ++;
  }
  while_break: ;
  }
  orphan_stratum = REF_GetOrphanStratum();
  orphan_source = -1;
  i = 0;
  {
  while (1) {
    while_continue___0: ;
    if (! (i < n_sources)) {
      goto while_break___0;
    }
    if ((unsigned int )(*(sources + i))->status != 0U) {
      goto __Cont___0;
    }
    si = & (*(sources + i))->sel_info;
    if (! (*(sources + i))->reachability) {
      if (max_reach_sample_ago < si->last_sample_ago) {
        mark_source(*(sources + i), (SRC_Status )6);
        goto __Cont___0;
      }
    }
    if ((*(sources + i))->stratum >= orphan_stratum) {
      if ((unsigned int )(*(sources + i))->type == 0U) {
        mark_source(*(sources + i), (SRC_Status )7);
        if ((*(sources + i))->stratum == orphan_stratum) {
          if ((*(sources + i))->reachability) {
            if (orphan_source == -1) {
              orphan_source = i;
            } else
            if ((*(sources + i))->ref_id < (*(sources + orphan_source))->ref_id) {
              orphan_source = i;
            }
          }
        }
        goto __Cont___0;
      }
    }
    n_sel_sources ++;
    __Cont___0:
    i ++;
  }
  while_break___0: ;
  }
  if (! n_sel_sources) {
    if (orphan_source != -1) {
      tmp___0 = NSR_GetLocalRefid((*(sources + orphan_source))->ip_addr);
      local_ref_id = tmp___0;
      if (! local_ref_id) {
        LOG_Message((LOG_Severity )2, (char const *)"Unknown local refid in orphan mode");
      } else
      if ((*(sources + orphan_source))->ref_id < local_ref_id) {
        (*(sources + orphan_source))->status = (SRC_Status )0;
        n_sel_sources = 1;
        {
        while (1) {
          while_continue___1: ;
          goto while_break___1;
        }
        while_break___1: ;
        }
      }
    }
  }
  i = 0;
  {
  while (1) {
    while_continue___2: ;
    if (! (i < n_sources)) {
      goto while_break___2;
    }
    if ((unsigned int )(*(sources + i))->status != 0U) {
      goto __Cont___1;
    }
    if ((*(sources + i))->sel_options & 0x4) {
      n_sel_trust_sources ++;
    }
    si = & (*(sources + i))->sel_info;
    j1___0 = n_endpoints;
    j2 = j1___0 + 1;
    (sort_list + j1___0)->index = i;
    (sort_list + j1___0)->offset = si->lo_limit;
    (sort_list + j1___0)->tag = (enum __anonenum_tag_1057593569 )-1;
    (sort_list + j2)->index = i;
    (sort_list + j2)->offset = si->hi_limit;
    (sort_list + j2)->tag = (enum __anonenum_tag_1057593569 )1;
    n_endpoints += 2;
    __Cont___1:
    i ++;
  }
  while_break___2: ;
  }
  {
  while (1) {
    while_continue___3: ;
    goto while_break___3;
  }
  while_break___3: ;
  }
  if (n_badstats_sources) {
    if (n_sel_sources) {
      if (selected_source_index == -1) {
        if (max_sel_reach_size < 8) {
          if (max_sel_reach >> 1 == max_badstat_reach) {
            mark_ok_sources((SRC_Status )5);
            return;
          }
        }
      }
    }
  }
  if (n_endpoints == 0) {
    if (selected_source_index != -1) {
      log_selection_message((char const *)"Can\'t synchronise: no selectable sources",
                            (char const *)((void *)0));
      selected_source_index = -1;
    }
    return;
  }
  qsort((void *)sort_list, (size_t )n_endpoints, sizeof(struct Sort_Element ), & compare_sort_elements);
  best_trust_depth = 0;
  trust_depth = best_trust_depth;
  best_depth = 0;
  depth = best_depth;
  best_trust_hi = 0.0;
  best_trust_lo = best_trust_hi;
  best_hi = best_trust_lo;
  best_lo = best_hi;
  i = 0;
  {
  while (1) {
    while_continue___4: ;
    if (! (i < n_endpoints)) {
      goto while_break___4;
    }
    {
    if ((int )(sort_list + i)->tag == -1) {
      goto case_neg_1;
    }
    if ((int )(sort_list + i)->tag == 1) {
      goto case_1;
    }
    goto switch_default;
    case_neg_1:
    depth ++;
    if ((*(sources + (sort_list + i)->index))->sel_options & 0x4) {
      trust_depth ++;
    }
    if (trust_depth > best_trust_depth) {
      goto _L;
    } else
    if (trust_depth == best_trust_depth) {
      if (depth > best_depth) {
        _L:
        if (trust_depth > best_trust_depth) {
          best_trust_depth = trust_depth;
          best_trust_lo = (sort_list + i)->offset;
        }
        best_depth = depth;
        best_lo = (sort_list + i)->offset;
      }
    }
    goto switch_break;
    case_1:
    if (trust_depth == best_trust_depth) {
      if (depth == best_depth) {
        best_hi = (sort_list + i)->offset;
      }
      best_trust_hi = (sort_list + i)->offset;
    }
    if ((*(sources + (sort_list + i)->index))->sel_options & 0x4) {
      trust_depth --;
    }
    depth --;
    goto switch_break;
    switch_default:
    assert(0);
    switch_break: ;
    }
    assert(trust_depth <= depth);
    assert(trust_depth >= 0);
    i ++;
  }
  while_break___4: ;
  }
  if (depth == 0) {
    if (trust_depth == 0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  assert(tmp___1);
  assert(2 * n_sel_sources == n_endpoints);
  if (best_trust_depth == 0) {
    if (best_depth <= n_sel_sources / 2) {
      goto _L___0;
    } else {
      goto _L___1;
    }
  } else
  _L___1:
  if (best_trust_depth > 0) {
    if (best_trust_depth <= n_sel_trust_sources / 2) {
      _L___0:
      if (selected_source_index != -1) {
        log_selection_message((char const *)"Can\'t synchronise: no majority", (char const *)((void *)0));
        REF_SetUnsynchronised();
        selected_source_index = -1;
      }
      mark_ok_sources((SRC_Status )9);
      return;
    }
  }
  n_sel_sources = 0;
  i = 0;
  {
  while (1) {
    while_continue___5: ;
    if (! (i < n_sources)) {
      goto while_break___5;
    }
    if ((unsigned int )(*(sources + i))->status != 0U) {
      goto __Cont___2;
    }
    if ((*(sources + i))->sel_info.lo_limit <= best_lo) {
      if ((*(sources + i))->sel_info.hi_limit >= best_hi) {
        goto _L___2;
      } else {
        goto _L___3;
      }
    } else
    _L___3:
    if ((*(sources + i))->sel_info.lo_limit >= best_lo) {
      if ((*(sources + i))->sel_info.hi_limit <= best_hi) {
        _L___2:
        if (! (best_trust_depth == 0)) {
          if (! ((*(sources + i))->sel_options & 0x4)) {
            if ((*(sources + i))->sel_info.lo_limit >= best_trust_lo) {
              if (! ((*(sources + i))->sel_info.hi_limit <= best_trust_hi)) {
                mark_source(*(sources + i), (SRC_Status )8);
                goto __Cont___2;
              }
            } else {
              mark_source(*(sources + i), (SRC_Status )8);
              goto __Cont___2;
            }
          }
        }
        tmp___2 = n_sel_sources;
        n_sel_sources ++;
        *(sel_sources + tmp___2) = i;
        if ((*(sources + i))->sel_options & 0x8) {
          sel_req_source = 0;
        }
      } else {
        mark_source(*(sources + i), (SRC_Status )9);
      }
    } else {
      mark_source(*(sources + i), (SRC_Status )9);
    }
    __Cont___2:
    i ++;
  }
  while_break___5: ;
  }
  if (! n_sel_sources) {
    goto _L___4;
  } else
  if (sel_req_source) {
    goto _L___4;
  } else {
    tmp___5 = CNF_GetMinSources();
    if (n_sel_sources < tmp___5) {
      _L___4:
      if (selected_source_index != -1) {
        if (! n_sel_sources) {
          tmp___4 = "no";
        } else {
          if (sel_req_source) {
            tmp___3 = "no required source in";
          } else {
            tmp___3 = "not enough";
          }
          tmp___4 = tmp___3;
        }
        log_selection_message((char const *)"Can\'t synchronise: %s selectable sources",
                              (char const *)tmp___4);
        selected_source_index = -1;
      }
      mark_ok_sources((SRC_Status )10);
      return;
    }
  }
  i = 0;
  {
  while (1) {
    while_continue___6: ;
    if (! (i < n_sel_sources)) {
      goto while_break___6;
    }
    index___0 = *(sel_sources + i);
    if (best_trust_depth) {
      if (! ((*(sources + index___0))->sel_options & 0x4)) {
        goto __Cont___3;
      }
    }
    (*(sources + index___0))->leap_vote = 1;
    __Cont___3:
    i ++;
  }
  while_break___6: ;
  }
  i = 0;
  {
  while (1) {
    while_continue___7: ;
    if (! (i < n_sel_sources)) {
      goto while_break___7;
    }
    if ((*(sources + *(sel_sources + i)))->sel_options & 0x2) {
      goto while_break___7;
    }
    i ++;
  }
  while_break___7: ;
  }
  if (i < n_sel_sources) {
    j = 0;
    i = j;
    {
    while (1) {
      while_continue___8: ;
      if (! (i < n_sel_sources)) {
        goto while_break___8;
      }
      if (! ((*(sources + *(sel_sources + i)))->sel_options & 0x2)) {
        mark_source(*(sources + *(sel_sources + i)), (SRC_Status )11);
      } else {
        tmp___6 = j;
        j ++;
        *(sel_sources + tmp___6) = *(sel_sources + i);
      }
      i ++;
    }
    while_break___8: ;
    }
    assert(j > 0);
    n_sel_sources = j;
    sel_prefer = 1;
  } else {
    sel_prefer = 0;
  }
  index___0 = *(sel_sources + 0);
  min_stratum = (*(sources + index___0))->stratum;
  i = 1;
  {
  while (1) {
    while_continue___9: ;
    if (! (i < n_sel_sources)) {
      goto while_break___9;
    }
    index___0 = *(sel_sources + i);
    stratum = (*(sources + index___0))->stratum;
    if (stratum < min_stratum) {
      min_stratum = stratum;
    }
    i ++;
  }
  while_break___9: ;
  }
  max_score_index = -1;
  max_score = 0.0;
  sel_src_distance = 0.0;
  if (selected_source_index != -1) {
    sel_src_distance = (*(sources + selected_source_index))->sel_info.root_distance + (double )((*(sources + selected_source_index))->stratum - min_stratum) * stratum_weight___0;
  }
  i = 0;
  {
  while (1) {
    while_continue___10: ;
    if (! (i < n_sources)) {
      goto while_break___10;
    }
    if ((unsigned int )(*(sources + i))->status != 0U) {
      (*(sources + i))->sel_score = 1.0;
      (*(sources + i))->distant = 32;
      goto __Cont___4;
    } else
    if (sel_prefer) {
      if (! ((*(sources + i))->sel_options & 0x2)) {
        (*(sources + i))->sel_score = 1.0;
        (*(sources + i))->distant = 32;
        goto __Cont___4;
      }
    }
    distance = (*(sources + i))->sel_info.root_distance + (double )((*(sources + i))->stratum - min_stratum) * stratum_weight___0;
    if ((unsigned int )(*(sources + i))->type == 0U) {
      distance += reselect_distance___0;
    }
    if (selected_source_index != -1) {
      if ((unsigned long )*(sources + i) == (unsigned long )updated_inst) {
        goto _L___5;
      } else
      if ((unsigned long )*(sources + selected_source_index) == (unsigned long )updated_inst) {
        _L___5:
        (*(sources + i))->sel_score *= sel_src_distance / distance;
        if ((*(sources + i))->sel_score < 1.0) {
          (*(sources + i))->sel_score = 1.0;
        }
      }
    } else {
      (*(sources + i))->sel_score = 1.0 / distance;
    }
    {
    while (1) {
      while_continue___11: ;
      goto while_break___11;
    }
    while_break___11: ;
    }
    if (max_score < (*(sources + i))->sel_score) {
      max_score = (*(sources + i))->sel_score;
      max_score_index = i;
    }
    __Cont___4:
    i ++;
  }
  while_break___10: ;
  }
  assert(max_score_index != -1);
  if (selected_source_index == -1) {
    goto _L___6;
  } else
  if ((unsigned int )(*(sources + selected_source_index))->status != 0U) {
    goto _L___6;
  } else
  if (max_score_index != selected_source_index) {
    if (max_score > 10.0) {
      _L___6:
      if ((*(sources + max_score_index))->updates == 0) {
        selected_source_index = -1;
        mark_ok_sources((SRC_Status )12);
        return;
      }
      selected_source_index = max_score_index;
      log_selection_source((char const *)"Selected source %s", *(sources + selected_source_index));
      i = 0;
      {
      while (1) {
        while_continue___12: ;
        if (! (i < n_sources)) {
          goto while_break___12;
        }
        (*(sources + i))->sel_score = 1.0;
        (*(sources + i))->distant = 0;
        i ++;
      }
      while_break___12: ;
      }
    }
  }
  mark_source(*(sources + selected_source_index), (SRC_Status )16);
  if ((*(sources + selected_source_index))->updates == 0) {
    i = 0;
    {
    while (1) {
      while_continue___13: ;
      if (! (i < n_sel_sources)) {
        goto while_break___13;
      }
      index___0 = *(sel_sources + i);
      if ((unsigned int )(*(sources + index___0))->status == 0U) {
        if ((*(sources + index___0))->distant) {
          tmp___8 = 13;
        } else {
          tmp___8 = 15;
        }
        mark_source(*(sources + index___0), (SRC_Status )tmp___8);
      }
      i ++;
    }
    while_break___13: ;
    }
    return;
  }
  i = 0;
  {
  while (1) {
    while_continue___14: ;
    if (! (i < n_sources)) {
      goto while_break___14;
    }
    (*(sources + i))->updates = 0;
    i ++;
  }
  while_break___14: ;
  }
  leap_status = get_leap_status();
  SST_GetTrackingData((*(sources + selected_source_index))->stats, & ref_time, & src_offset,
                      & src_offset_sd, & src_frequency, & src_frequency_sd, & src_skew,
                      & src_root_delay, & src_root_dispersion);
  combined = combine_sources(n_sel_sources, & ref_time, & src_offset, & src_offset_sd,
                             & src_frequency, & src_frequency_sd, & src_skew);
  REF_SetReference((*(sources + selected_source_index))->stratum, leap_status, combined,
                   (*(sources + selected_source_index))->ref_id, (*(sources + selected_source_index))->ip_addr,
                   & ref_time, src_offset, src_offset_sd, src_frequency, src_frequency_sd,
                   src_skew, src_root_delay, src_root_dispersion);
  return;
}
}
void SRC_ReselectSource(void)
{
  {
  selected_source_index = -1;
  SRC_SelectSource((SRC_Instance )((void *)0));
  return;
}
}
void SRC_SetReselectDistance(double distance )
{
  {
  if (reselect_distance___0 != distance) {
    reselect_distance___0 = distance;
    LOG_Message((LOG_Severity )0, (char const *)"New reselect distance %f", distance);
  }
  return;
}
}
static void slew_sources(struct timespec *raw , struct timespec *cooked , double dfreq ,
                         double doffset , LCL_ChangeType change_type , void *anything )
{
  int i ;
  {
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < n_sources)) {
      goto while_break;
    }
    if ((unsigned int )change_type == 2U) {
      SST_ResetInstance((*(sources + i))->stats);
    } else {
      SST_SlewSamples((*(sources + i))->stats, cooked, dfreq, doffset);
    }
    i ++;
  }
  while_break: ;
  }
  if ((unsigned int )change_type == 2U) {
    SRC_SelectSource((SRC_Instance )((void *)0));
  }
  return;
}
}
static void add_dispersion(double dispersion , void *anything )
{
  int i ;
  {
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < n_sources)) {
      goto while_break;
    }
    SST_AddDispersion((*(sources + i))->stats, dispersion);
    i ++;
  }
  while_break: ;
  }
  return;
}
}
static int get_dumpfile(SRC_Instance inst , char *filename___0 , size_t len )
{
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  {
  if ((unsigned int )inst->type == 0U) {
    goto case_0;
  }
  if ((unsigned int )inst->type == 1U) {
    goto case_1;
  }
  goto switch_default;
  case_0:
  tmp = UTI_IsIPReal((IPAddr const *)inst->ip_addr);
  if (tmp) {
    tmp___0 = source_to_string(inst);
    tmp___1 = snprintf(filename___0, len, (char const *)"%s", tmp___0);
    if ((size_t )tmp___1 >= len) {
      return (0);
    }
  } else {
    return (0);
  }
  goto switch_break;
  case_1:
  tmp___2 = snprintf(filename___0, len, (char const *)"refid:%08x", inst->ref_id);
  if ((size_t )tmp___2 >= len) {
    return (0);
  }
  goto switch_break;
  switch_default:
  assert(0);
  switch_break: ;
  }
  return (1);
}
}
static void save_source(SRC_Instance inst )
{
  char filename___0[64] ;
  char *dumpdir___0 ;
  char *ntp_name ;
  FILE *f ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  {
  dumpdir___0 = CNF_GetDumpDir();
  if (! dumpdir___0) {
    return;
  }
  tmp = get_dumpfile(inst, filename___0, sizeof(filename___0));
  if (! tmp) {
    return;
  }
  f = UTI_OpenFile((char const *)dumpdir___0, (char const *)(filename___0), (char const *)".dat",
                   (char )'w', (mode_t )0644);
  if (! f) {
    return;
  }
  if ((unsigned int )inst->type == 0U) {
    tmp___0 = NSR_GetName(inst->ip_addr);
    ntp_name = tmp___0;
  } else {
    ntp_name = ".";
  }
  tmp___3 = fprintf(f, (char const *)"%s%s\n%d %o %d %d %d\n", "SRC0\n", ntp_name,
                    inst->authenticated, (unsigned int )inst->reachability, inst->reachability_size,
                    inst->stratum, (int )inst->leap);
  if (tmp___3 < 0) {
    goto _L;
  } else {
    tmp___4 = SST_SaveToFile(inst->stats, f);
    if (! tmp___4) {
      _L:
      fclose(f);
      tmp___1 = UTI_RemoveFile((char const *)dumpdir___0, (char const *)(filename___0),
                               (char const *)".dat");
      if (tmp___1) {
        tmp___2 = 0;
      } else {
        tmp___2 = 1;
      }
      return;
    }
  }
  fclose(f);
  return;
}
}
void SRC_DumpSources(void)
{
  int i ;
  {
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < n_sources)) {
      goto while_break;
    }
    save_source(*(sources + i));
    i ++;
  }
  while_break: ;
  }
  return;
}
}
static void load_source(SRC_Instance inst )
{
  char filename___0[64] ;
  char line[256] ;
  char *dumpdir___0 ;
  char *ntp_name ;
  char *words[1] ;
  int auth ;
  int leap ;
  int reach_size ;
  int stratum ;
  unsigned int reach ;
  FILE *f ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char __attribute__((__access__(__write_only__,1,2))) *tmp___2 ;
  int tmp___3 ;
  char __attribute__((__access__(__write_only__,1,2))) *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char __attribute__((__access__(__write_only__,1,2))) *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  {
  dumpdir___0 = CNF_GetDumpDir();
  if (! dumpdir___0) {
    return;
  }
  tmp = get_dumpfile(inst, filename___0, sizeof(filename___0));
  if (! tmp) {
    return;
  }
  f = UTI_OpenFile((char const *)dumpdir___0, (char const *)(filename___0), (char const *)".dat",
                   (char )'r', (mode_t )0);
  if (! f) {
    return;
  }
  if ((unsigned int )inst->type == 0U) {
    tmp___0 = NSR_GetName(inst->ip_addr);
    ntp_name = tmp___0;
  } else {
    ntp_name = (char *)((void *)0);
  }
  tmp___2 = fgets(line, (int )sizeof(line), f);
  if (tmp___2) {
    tmp___3 = strcmp((char const *)(line), (char const *)"SRC0\n");
    if (tmp___3 != 0) {
      tmp___1 = source_to_string(inst);
      LOG_Message((LOG_Severity )1, (char const *)"Could not load dump file for %s",
                  tmp___1);
      fclose(f);
      return;
    } else {
      tmp___4 = fgets(line, (int )sizeof(line), f);
      if (tmp___4) {
        tmp___5 = UTI_SplitString(line, words, 1);
        if (tmp___5 != 1) {
          tmp___1 = source_to_string(inst);
          LOG_Message((LOG_Severity )1, (char const *)"Could not load dump file for %s",
                      tmp___1);
          fclose(f);
          return;
        } else
        if ((unsigned int )inst->type == 0U) {
          if (! ntp_name) {
            tmp___1 = source_to_string(inst);
            LOG_Message((LOG_Severity )1, (char const *)"Could not load dump file for %s",
                        tmp___1);
            fclose(f);
            return;
          } else {
            tmp___6 = strcmp((char const *)words[0], (char const *)ntp_name);
            if (tmp___6 != 0) {
              tmp___1 = source_to_string(inst);
              LOG_Message((LOG_Severity )1, (char const *)"Could not load dump file for %s",
                          tmp___1);
              fclose(f);
              return;
            } else {
              goto _L___0;
            }
          }
        } else {
          _L___0:
          tmp___7 = fgets(line, (int )sizeof(line), f);
          if (tmp___7) {
            tmp___8 = sscanf((char const *)words[0], (char const *)"%d %o %d %d %d",
                             & auth, & reach, & reach_size, & stratum, & leap);
            if (tmp___8 != 5) {
              tmp___1 = source_to_string(inst);
              LOG_Message((LOG_Severity )1, (char const *)"Could not load dump file for %s",
                          tmp___1);
              fclose(f);
              return;
            } else
            if (! auth) {
              if (inst->authenticated) {
                tmp___1 = source_to_string(inst);
                LOG_Message((LOG_Severity )1, (char const *)"Could not load dump file for %s",
                            tmp___1);
                fclose(f);
                return;
              } else {
                goto _L;
              }
            } else
            _L:
            if (stratum < 0) {
              tmp___1 = source_to_string(inst);
              LOG_Message((LOG_Severity )1, (char const *)"Could not load dump file for %s",
                          tmp___1);
              fclose(f);
              return;
            } else
            if (stratum >= 16) {
              tmp___1 = source_to_string(inst);
              LOG_Message((LOG_Severity )1, (char const *)"Could not load dump file for %s",
                          tmp___1);
              fclose(f);
              return;
            } else
            if (leap < 0) {
              tmp___1 = source_to_string(inst);
              LOG_Message((LOG_Severity )1, (char const *)"Could not load dump file for %s",
                          tmp___1);
              fclose(f);
              return;
            } else
            if (leap >= 3) {
              tmp___1 = source_to_string(inst);
              LOG_Message((LOG_Severity )1, (char const *)"Could not load dump file for %s",
                          tmp___1);
              fclose(f);
              return;
            } else {
              tmp___9 = SST_LoadFromFile(inst->stats, f);
              if (! tmp___9) {
                tmp___1 = source_to_string(inst);
                LOG_Message((LOG_Severity )1, (char const *)"Could not load dump file for %s",
                            tmp___1);
                fclose(f);
                return;
              }
            }
          } else {
            tmp___1 = source_to_string(inst);
            LOG_Message((LOG_Severity )1, (char const *)"Could not load dump file for %s",
                        tmp___1);
            fclose(f);
            return;
          }
        }
      } else {
        tmp___1 = source_to_string(inst);
        LOG_Message((LOG_Severity )1, (char const *)"Could not load dump file for %s",
                    tmp___1);
        fclose(f);
        return;
      }
    }
  } else {
    tmp___1 = source_to_string(inst);
    LOG_Message((LOG_Severity )1, (char const *)"Could not load dump file for %s",
                tmp___1);
    fclose(f);
    return;
  }
  inst->reachability = (int )(reach & ((1U << 8) - 1U));
  if (reach_size < 8) {
    tmp___12 = reach_size;
  } else {
    tmp___12 = 8;
  }
  if (0 > tmp___12) {
    inst->reachability_size = 0;
  } else {
    if (reach_size < 8) {
      tmp___11 = reach_size;
    } else {
      tmp___11 = 8;
    }
    inst->reachability_size = tmp___11;
  }
  inst->stratum = stratum;
  inst->leap = (NTP_Leap )leap;
  tmp___13 = source_to_string(inst);
  LOG_Message((LOG_Severity )0, (char const *)"Loaded dump file for %s", tmp___13);
  fclose(f);
  return;
}
}
void SRC_ReloadSources(void)
{
  int i ;
  {
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < n_sources)) {
      goto while_break;
    }
    load_source(*(sources + i));
    ((*(sources + i))->updates) ++;
    i ++;
  }
  while_break: ;
  }
  SRC_SelectSource((SRC_Instance )((void *)0));
  return;
}
}
void SRC_RemoveDumpFiles(void)
{
  char pattern[4096] ;
  char name[64] ;
  char *dumpdir___0 ;
  char *s ;
  IPAddr ip_addr ;
  glob_t gl ;
  size_t i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  {
  dumpdir___0 = CNF_GetDumpDir();
  if (! dumpdir___0) {
    return;
  } else {
    tmp = snprintf(pattern, sizeof(pattern), (char const *)"%s/*.dat", dumpdir___0);
    if ((unsigned long )tmp >= sizeof(pattern)) {
      return;
    }
  }
  tmp___0 = glob((char const * __restrict )(pattern), 0, (int (*)(char const * ,
                                                                     int ))((void *)0),
                 (glob_t * __restrict )(& gl));
  if (tmp___0) {
    return;
  }
  i = (size_t )0;
  {
  while (1) {
    while_continue: ;
    if (! (i < gl.gl_pathc)) {
      goto while_break;
    }
    s = strrchr((char const *)*(gl.gl_pathv + i), '/');
    if (! s) {
      goto __Cont;
    } else {
      tmp___1 = snprintf(name, sizeof(name), (char const *)"%s", s + 1);
      if ((unsigned long )tmp___1 >= sizeof(name)) {
        goto __Cont;
      }
    }
    tmp___2 = strlen((char const *)(name));
    if (tmp___2 < 4UL) {
      goto __Cont;
    }
    tmp___3 = strlen((char const *)(name));
    name[tmp___3 - 4UL] = (char )'\000';
    tmp___4 = strncmp((char const *)(name), (char const *)"refid:", (size_t )6);
    if (tmp___4) {
      tmp___5 = UTI_StringToIP((char const *)(name), & ip_addr);
      if (! tmp___5) {
        goto __Cont;
      }
    }
    tmp___6 = UTI_RemoveFile((char const *)((void *)0), (char const *)*(gl.gl_pathv + i),
                             (char const *)((void *)0));
    if (tmp___6) {
      tmp___7 = 0;
    } else {
      tmp___7 = 1;
    }
    __Cont:
    i ++;
  }
  while_break: ;
  }
  globfree(& gl);
  return;
}
}
void SRC_ResetSources(void)
{
  int i ;
  {
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < n_sources)) {
      goto while_break;
    }
    SRC_ResetInstance(*(sources + i));
    i ++;
  }
  while_break: ;
  }
  return;
}
}
int SRC_IsSyncPeer(SRC_Instance inst )
{
  {
  if (inst->index == selected_source_index) {
    return (1);
  } else {
    return (0);
  }
}
}
int SRC_IsReachable(SRC_Instance inst )
{
  {
  return (inst->reachability != 0);
}
}
int SRC_ReadNumberOfSources(void)
{
  {
  return (n_sources);
}
}
int SRC_ActiveSources(void)
{
  int i ;
  int r ;
  {
  r = 0;
  i = r;
  {
  while (1) {
    while_continue: ;
    if (! (i < n_sources)) {
      goto while_break;
    }
    if ((*(sources + i))->active) {
      r ++;
    }
    i ++;
  }
  while_break: ;
  }
  return (r);
}
}
int SRC_ReportSource(int index___0 , RPT_SourceReport *report , struct timespec *now )
{
  SRC_Instance src ;
  {
  if (index___0 >= n_sources) {
    return (0);
  } else
  if (index___0 < 0) {
    return (0);
  } else {
    src = *(sources + index___0);
    if (src->ip_addr) {
      report->ip_addr = *(src->ip_addr);
    } else {
      report->ip_addr.addr.in4 = src->ref_id;
      report->ip_addr.family = (uint16_t )1;
    }
    report->stratum = src->stratum;
    {
    if ((unsigned int )src->status == 9U) {
      goto case_9;
    }
    if ((unsigned int )src->status == 4U) {
      goto case_4;
    }
    if ((unsigned int )src->status == 14U) {
      goto case_14;
    }
    if ((unsigned int )src->status == 13U) {
      goto case_14;
    }
    if ((unsigned int )src->status == 12U) {
      goto case_14;
    }
    if ((unsigned int )src->status == 11U) {
      goto case_14;
    }
    if ((unsigned int )src->status == 10U) {
      goto case_14;
    }
    if ((unsigned int )src->status == 15U) {
      goto case_15;
    }
    if ((unsigned int )src->status == 16U) {
      goto case_16;
    }
    goto switch_default;
    case_9:
    report->state = (enum __anonenum_state_667680095 )1;
    goto switch_break;
    case_4:
    report->state = (enum __anonenum_state_667680095 )2;
    goto switch_break;
    case_14:
    case_13:
    case_12:
    case_11:
    case_10:
    report->state = (enum __anonenum_state_667680095 )3;
    goto switch_break;
    case_15:
    report->state = (enum __anonenum_state_667680095 )4;
    goto switch_break;
    case_16:
    report->state = (enum __anonenum_state_667680095 )5;
    goto switch_break;
    switch_default:
    report->state = (enum __anonenum_state_667680095 )0;
    goto switch_break;
    switch_break: ;
    }
    report->reachability = src->reachability;
    SST_DoSourceReport(src->stats, report, now);
    return (1);
  }
}
}
int SRC_ReportSourcestats(int index___0 , RPT_SourcestatsReport *report , struct timespec *now )
{
  SRC_Instance src ;
  {
  if (index___0 >= n_sources) {
    return (0);
  } else
  if (index___0 < 0) {
    return (0);
  } else {
    src = *(sources + index___0);
    report->ref_id = src->ref_id;
    if (src->ip_addr) {
      report->ip_addr = *(src->ip_addr);
    } else {
      report->ip_addr.family = (uint16_t )0;
    }
    SST_DoSourcestatsReport(src->stats, report, now);
    return (1);
  }
}
}
static char get_status_char(SRC_Status status )
{
  {
  {
  if ((unsigned int )status == 1U) {
    goto case_1;
  }
  if ((unsigned int )status == 2U) {
    goto case_2;
  }
  if ((unsigned int )status == 3U) {
    goto case_3;
  }
  if ((unsigned int )status == 4U) {
    goto case_4;
  }
  if ((unsigned int )status == 5U) {
    goto case_5;
  }
  if ((unsigned int )status == 6U) {
    goto case_6;
  }
  if ((unsigned int )status == 7U) {
    goto case_7;
  }
  if ((unsigned int )status == 8U) {
    goto case_8;
  }
  if ((unsigned int )status == 9U) {
    goto case_9;
  }
  if ((unsigned int )status == 10U) {
    goto case_10;
  }
  if ((unsigned int )status == 11U) {
    goto case_11;
  }
  if ((unsigned int )status == 12U) {
    goto case_12;
  }
  if ((unsigned int )status == 13U) {
    goto case_13;
  }
  if ((unsigned int )status == 14U) {
    goto case_14;
  }
  if ((unsigned int )status == 15U) {
    goto case_15;
  }
  if ((unsigned int )status == 16U) {
    goto case_16;
  }
  goto switch_default;
  case_1:
  return ((char )'N');
  case_2:
  return ((char )'M');
  case_3:
  return ((char )'d');
  case_4:
  return ((char )'~');
  case_5:
  return ((char )'w');
  case_6:
  return ((char )'S');
  case_7:
  return ((char )'O');
  case_8:
  return ((char )'T');
  case_9:
  return ((char )'x');
  case_10:
  return ((char )'W');
  case_11:
  return ((char )'P');
  case_12:
  return ((char )'U');
  case_13:
  return ((char )'D');
  case_14:
  return ((char )'L');
  case_15:
  return ((char )'+');
  case_16:
  return ((char )'*');
  switch_default:
  return ((char )'?');
  switch_break: ;
  }
}
}
int SRC_GetSelectReport(int index___0 , RPT_SelectReport *report )
{
  SRC_Instance inst ;
  {
  if (index___0 >= n_sources) {
    return (0);
  } else
  if (index___0 < 0) {
    return (0);
  }
  inst = *(sources + index___0);
  report->ref_id = inst->ref_id;
  if (inst->ip_addr) {
    report->ip_addr = *(inst->ip_addr);
  } else {
    report->ip_addr.family = (uint16_t )0;
  }
  report->state_char = get_status_char(inst->status);
  report->authentication = inst->authenticated;
  report->leap = inst->leap;
  report->conf_options = inst->conf_sel_options;
  report->eff_options = inst->sel_options;
  report->last_sample_ago = (uint32_t )inst->sel_info.last_sample_ago;
  report->score = inst->sel_score;
  report->lo_limit = inst->sel_info.lo_limit;
  report->hi_limit = inst->sel_info.hi_limit;
  return (1);
}
}
SRC_Type SRC_GetType(int index___0 )
{
  {
  if (index___0 >= n_sources) {
    return ((SRC_Type )-1);
  } else
  if (index___0 < 0) {
    return ((SRC_Type )-1);
  }
  return ((*(sources + index___0))->type);
}
}
static LOG_FileID logfileid___0 ;
static void find_min_delay_sample(SST_Stats inst ) ;
static int get_buf_index(SST_Stats inst , int i ) ;
void SST_Initialise(void)
{
  int tmp ;
  LOG_FileID tmp___0 ;
  int tmp___1 ;
  {
  tmp___1 = CNF_GetLogStatistics();
  if (tmp___1) {
    tmp___0 = LOG_FileOpen((char const *)"statistics", (char const *)"   Date (UTC) Time     IP Address    Std dev\'n Est offset  Offset sd  Diff freq   Est skew  Stress  Ns  Bs  Nr  Asym");
    logfileid___0 = tmp___0;
  } else {
    logfileid___0 = -1;
  }
  return;
}
}
void SST_Finalise(void)
{
  {
  return;
}
}
SST_Stats SST_CreateInstance(uint32_t refid , IPAddr *addr , int min_samples___0 ,
                             int max_samples___0 , double min_delay , double asymmetry )
{
  SST_Stats inst ;
  void *tmp ;
  {
  tmp = Malloc(sizeof(struct SST_Stats_Record ));
  inst = (struct SST_Stats_Record *)tmp;
  inst->min_samples = min_samples___0;
  inst->max_samples = max_samples___0;
  inst->fixed_min_delay = min_delay;
  inst->fixed_asymmetry = asymmetry;
  SST_SetRefid(inst, refid, addr);
  SST_ResetInstance(inst);
  return (inst);
}
}
void SST_DeleteInstance(SST_Stats inst )
{
  {
  free((void *)inst);
  return;
}
}
void SST_ResetInstance(SST_Stats inst )
{
  {
  inst->n_samples = 0;
  inst->runs_samples = 0;
  inst->last_sample = 0;
  inst->regression_ok = 0;
  inst->best_single_sample = 0;
  inst->min_delay_sample = 0;
  inst->estimated_frequency = (double )0;
  inst->estimated_frequency_sd = 2000.0 / 1.0e6;
  inst->skew = 2000.0 / 1.0e6;
  inst->estimated_offset = 0.0;
  inst->estimated_offset_sd = 4.0;
  UTI_ZeroTimespec(& inst->offset_time);
  inst->std_dev = 4.0;
  inst->nruns = 0;
  inst->asymmetry_run = 0;
  inst->asymmetry = 0.0;
  return;
}
}
void SST_SetRefid(SST_Stats inst , uint32_t refid , IPAddr *addr )
{
  {
  inst->refid = refid;
  inst->ip_addr = addr;
  return;
}
}
static void prune_register(SST_Stats inst , int new_oldest )
{
  {
  if (! new_oldest) {
    return;
  }
  assert(inst->n_samples >= new_oldest);
  inst->n_samples -= new_oldest;
  inst->runs_samples += new_oldest;
  if (inst->runs_samples > inst->n_samples) {
    inst->runs_samples = inst->n_samples;
  }
  assert(inst->n_samples + inst->runs_samples <= 128);
  find_min_delay_sample(inst);
  return;
}
}
void SST_AccumulateSample(SST_Stats inst , NTP_Sample *sample )
{
  int n ;
  int m ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  {
  if (inst->n_samples > 0) {
    if (inst->n_samples == 64) {
      prune_register(inst, 1);
    } else
    if (inst->n_samples == inst->max_samples) {
      prune_register(inst, 1);
    }
  }
  if (inst->n_samples) {
    tmp___2 = UTI_CompareTimespecs((struct timespec const *)(& inst->sample_times[inst->last_sample]),
                                   (struct timespec const *)(& sample->time));
    if (tmp___2 >= 0) {
      if (inst->ip_addr) {
        tmp = UTI_IPToString((IPAddr const *)inst->ip_addr);
        tmp___1 = tmp;
      } else {
        tmp___0 = UTI_RefidToString(inst->refid);
        tmp___1 = tmp___0;
      }
      LOG_Message((LOG_Severity )1, (char const *)"Out of order sample detected, discarding history for %s",
                  tmp___1);
      SST_ResetInstance(inst);
    }
  }
  tmp___3 = (inst->last_sample + 1) % 128;
  inst->last_sample = tmp___3;
  n = tmp___3;
  m = n % 64;
  inst->sample_times[n] = sample->time;
  inst->offsets[n] = - sample->offset;
  inst->orig_offsets[m] = - sample->offset;
  inst->peer_delays[n] = sample->peer_delay;
  inst->peer_dispersions[m] = sample->peer_dispersion;
  inst->root_delays[m] = sample->root_delay;
  inst->root_dispersions[m] = sample->root_dispersion;
  if (inst->peer_delays[n] < inst->fixed_min_delay) {
    inst->peer_delays[n] = 2.0 * inst->fixed_min_delay - inst->peer_delays[n];
  }
  if (! inst->n_samples) {
    inst->min_delay_sample = n;
  } else
  if (inst->peer_delays[n] < inst->peer_delays[inst->min_delay_sample]) {
    inst->min_delay_sample = n;
  }
  (inst->n_samples) ++;
  return;
}
}
static int get_runsbuf_index(SST_Stats inst , int i )
{
  {
  return ((int )((unsigned int )((((inst->last_sample + 256) - inst->n_samples) + i) + 1) % 128U));
}
}
static int get_buf_index(SST_Stats inst , int i )
{
  {
  return ((int )((unsigned int )((((inst->last_sample + 128) - inst->n_samples) + i) + 1) % 64U));
}
}
static void convert_to_intervals(SST_Stats inst , double *times_back )
{
  struct timespec *ts ;
  int i ;
  int tmp ;
  {
  ts = & inst->sample_times[inst->last_sample];
  i = - inst->runs_samples;
  {
  while (1) {
    while_continue: ;
    if (! (i < inst->n_samples)) {
      goto while_break;
    }
    tmp = get_runsbuf_index(inst, i);
    *(times_back + i) = UTI_DiffTimespecsToDouble((struct timespec const *)(& inst->sample_times[tmp]),
                                                  (struct timespec const *)ts);
    i ++;
  }
  while_break: ;
  }
  return;
}
}
static void find_best_sample_index(SST_Stats inst , double *times_back )
{
  double root_distance ;
  double best_root_distance ;
  double elapsed ;
  int i ;
  int j ;
  int best_index ;
  {
  if (! inst->n_samples) {
    return;
  }
  best_index = -1;
  best_root_distance = (double )1.79769313486231570814527423731704357e+308L;
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < inst->n_samples)) {
      goto while_break;
    }
    j = get_buf_index(inst, i);
    elapsed = - *(times_back + i);
    assert(elapsed >= 0.0);
    root_distance = (inst->root_dispersions[j] + elapsed * inst->skew) + 0.5 * inst->root_delays[j];
    if (root_distance < best_root_distance) {
      best_root_distance = root_distance;
      best_index = i;
    }
    i ++;
  }
  while_break: ;
  }
  assert(best_index >= 0);
  inst->best_single_sample = best_index;
  return;
}
}
static void find_min_delay_sample(SST_Stats inst )
{
  int i ;
  int index___0 ;
  {
  inst->min_delay_sample = get_runsbuf_index(inst, - inst->runs_samples);
  i = - inst->runs_samples + 1;
  {
  while (1) {
    while_continue: ;
    if (! (i < inst->n_samples)) {
      goto while_break;
    }
    index___0 = get_runsbuf_index(inst, i);
    if (inst->peer_delays[index___0] < inst->peer_delays[inst->min_delay_sample]) {
      inst->min_delay_sample = index___0;
    }
    i ++;
  }
  while_break: ;
  }
  return;
}
}
static int estimate_asymmetry(double *times_back , double *offsets , double *delays ,
                              int n , double *asymmetry , int *asymmetry_run )
{
  double a ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  {
  tmp = RGR_MultipleRegress(times_back, delays, offsets, n, & a);
  if (tmp) {
    if (a * (double )*asymmetry_run < 0.0) {
      *asymmetry = (double )0;
      *asymmetry_run = (int )0.0;
      return (0);
    }
  } else {
    *asymmetry = (double )0;
    *asymmetry_run = (int )0.0;
    return (0);
  }
  if (a <= - 0.45) {
    if (*asymmetry_run > -1000) {
      (*asymmetry_run) --;
    } else {
      goto _L;
    }
  } else
  _L:
  if (a >= 0.45) {
    if (*asymmetry_run < 1000) {
      (*asymmetry_run) ++;
    }
  }
  tmp___0 = abs(*asymmetry_run);
  if (tmp___0 < 10) {
    return (0);
  }
  if (a < 0.5) {
    tmp___3 = a;
  } else {
    tmp___3 = 0.5;
  }
  if (- 0.5 > tmp___3) {
    *asymmetry = - 0.5;
  } else {
    if (a < 0.5) {
      tmp___2 = a;
    } else {
      tmp___2 = 0.5;
    }
    *asymmetry = tmp___2;
  }
  return (1);
}
}
static void correct_asymmetry(SST_Stats inst , double *times_back , double *offsets )
{
  double min_delay ;
  double delays[128] ;
  int i ;
  int n ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  {
  if (inst->fixed_asymmetry == 0.0) {
    return;
  }
  min_delay = SST_MinRoundTripDelay(inst);
  n = inst->runs_samples + inst->n_samples;
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < n)) {
      goto while_break;
    }
    tmp = get_runsbuf_index(inst, i - inst->runs_samples);
    delays[i] = inst->peer_delays[tmp] - min_delay;
    i ++;
  }
  while_break: ;
  }
  tmp___1 = fabs(inst->fixed_asymmetry);
  if (tmp___1 <= 0.5) {
    inst->asymmetry = inst->fixed_asymmetry;
  } else {
    tmp___0 = estimate_asymmetry(times_back, offsets, delays, n, & inst->asymmetry,
                                 & inst->asymmetry_run);
    if (! tmp___0) {
      return;
    }
  }
  i = 0;
  {
  while (1) {
    while_continue___0: ;
    if (! (i < n)) {
      goto while_break___0;
    }
    *(offsets + i) -= inst->asymmetry * delays[i];
    i ++;
  }
  while_break___0: ;
  }
  return;
}
}
void SST_DoNewRegression(SST_Stats inst )
{
  double times_back[128] ;
  double offsets[128] ;
  double peer_distances[64] ;
  double weights[64] ;
  int degrees_of_freedom ;
  int best_start ;
  int times_back_start ;
  double est_intercept ;
  double est_slope ;
  double est_var ;
  double est_intercept_sd ;
  double est_slope_sd ;
  int i ;
  int j ;
  int nruns ;
  double min_distance ;
  double median_distance ;
  double sd_weight ;
  double sd ;
  double old_skew ;
  double old_freq ;
  double stress ;
  double precision ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  {
  convert_to_intervals(inst, times_back + inst->runs_samples);
  if (inst->n_samples > 0) {
    i = - inst->runs_samples;
    {
    while (1) {
      while_continue: ;
      if (! (i < inst->n_samples)) {
        goto while_break;
      }
      tmp = get_runsbuf_index(inst, i);
      offsets[i + inst->runs_samples] = inst->offsets[tmp];
      i ++;
    }
    while_break: ;
    }
    i = 0;
    min_distance = (double )1.79769313486231570814527423731704357e+308L;
    {
    while (1) {
      while_continue___0: ;
      if (! (i < inst->n_samples)) {
        goto while_break___0;
      }
      j = get_buf_index(inst, i);
      tmp___0 = get_runsbuf_index(inst, i);
      peer_distances[i] = 0.5 * inst->peer_delays[tmp___0] + inst->peer_dispersions[j];
      if (peer_distances[i] < min_distance) {
        min_distance = peer_distances[i];
      }
      i ++;
    }
    while_break___0: ;
    }
    precision = LCL_GetSysPrecisionAsQuantum();
    median_distance = RGR_FindMedian(peer_distances, inst->n_samples);
    sd = (median_distance - min_distance) / 0.7;
    if (sd < min_distance) {
      tmp___3 = sd;
    } else {
      tmp___3 = min_distance;
    }
    if (precision > tmp___3) {
      sd = precision;
    } else {
      if (sd < min_distance) {
        tmp___2 = sd;
      } else {
        tmp___2 = min_distance;
      }
      sd = tmp___2;
    }
    min_distance += precision;
    i = 0;
    {
    while (1) {
      while_continue___1: ;
      if (! (i < inst->n_samples)) {
        goto while_break___1;
      }
      sd_weight = 1.0;
      if (peer_distances[i] > min_distance) {
        sd_weight += (peer_distances[i] - min_distance) / sd;
      }
      weights[i] = sd_weight * sd_weight;
      i ++;
    }
    while_break___1: ;
    }
  }
  correct_asymmetry(inst, times_back, offsets);
  inst->regression_ok = RGR_FindBestRegression(times_back + inst->runs_samples, offsets + inst->runs_samples,
                                               weights, inst->n_samples, inst->runs_samples,
                                               inst->min_samples, & est_intercept,
                                               & est_slope, & est_var, & est_intercept_sd,
                                               & est_slope_sd, & best_start, & nruns,
                                               & degrees_of_freedom);
  if (inst->regression_ok) {
    old_skew = inst->skew;
    old_freq = inst->estimated_frequency;
    inst->estimated_frequency = est_slope;
    if (est_slope_sd < 1.0e+02) {
      tmp___6 = est_slope_sd;
    } else {
      tmp___6 = 1.0e+02;
    }
    if (1.0e-12 > tmp___6) {
      inst->estimated_frequency_sd = 1.0e-12;
    } else {
      if (est_slope_sd < 1.0e+02) {
        tmp___5 = est_slope_sd;
      } else {
        tmp___5 = 1.0e+02;
      }
      inst->estimated_frequency_sd = tmp___5;
    }
    tmp___7 = RGR_GetTCoef(degrees_of_freedom);
    inst->skew = est_slope_sd * tmp___7;
    inst->estimated_offset = est_intercept;
    inst->offset_time = inst->sample_times[inst->last_sample];
    inst->estimated_offset_sd = est_intercept_sd;
    tmp___10 = sqrt(est_var);
    if (1.0e-9 > tmp___10) {
      inst->std_dev = 1.0e-9;
    } else {
      tmp___9 = sqrt(est_var);
      inst->std_dev = tmp___9;
    }
    inst->nruns = nruns;
    if (inst->skew < 1.0e+02) {
      tmp___13 = inst->skew;
    } else {
      tmp___13 = 1.0e+02;
    }
    if (1.0e-12 > tmp___13) {
      inst->skew = 1.0e-12;
    } else {
      if (inst->skew < 1.0e+02) {
        tmp___12 = inst->skew;
      } else {
        tmp___12 = 1.0e+02;
      }
      inst->skew = tmp___12;
    }
    tmp___14 = fabs(old_freq - inst->estimated_frequency);
    stress = tmp___14 / old_skew;
    {
    while (1) {
      while_continue___2: ;
      goto while_break___2;
    }
    while_break___2: ;
    }
    if (logfileid___0 != -1) {
      if (inst->ip_addr) {
        tmp___15 = UTI_IPToString((IPAddr const *)inst->ip_addr);
        tmp___17 = tmp___15;
      } else {
        tmp___16 = UTI_RefidToString(inst->refid);
        tmp___17 = tmp___16;
      }
      tmp___18 = UTI_TimeToLogForm(inst->offset_time.tv_sec);
      LOG_FileWrite(logfileid___0, (char const *)"%s %-15s %10.3e %10.3e %10.3e %10.3e %10.3e %7.1e %3d %3d %3d %5.2f",
                    tmp___18, tmp___17, inst->std_dev, inst->estimated_offset, inst->estimated_offset_sd,
                    inst->estimated_frequency, inst->skew, stress, inst->n_samples,
                    best_start, inst->nruns, inst->asymmetry);
    }
    times_back_start = inst->runs_samples + best_start;
    prune_register(inst, best_start);
  } else {
    inst->estimated_frequency_sd = 2000.0 / 1.0e6;
    inst->skew = 2000.0 / 1.0e6;
    inst->estimated_offset_sd = 4.0;
    inst->std_dev = 4.0;
    inst->nruns = 0;
    if (inst->n_samples > 0) {
      inst->estimated_offset = inst->offsets[inst->last_sample];
      inst->offset_time = inst->sample_times[inst->last_sample];
    } else {
      inst->estimated_offset = 0.0;
      UTI_ZeroTimespec(& inst->offset_time);
    }
    times_back_start = 0;
  }
  find_best_sample_index(inst, times_back + times_back_start);
  return;
}
}
void SST_GetFrequencyRange(SST_Stats inst , double *lo , double *hi )
{
  double freq___0 ;
  double skew ;
  {
  freq___0 = inst->estimated_frequency;
  skew = inst->skew;
  *lo = freq___0 - skew;
  *hi = freq___0 + skew;
  if (skew > 2000.0 / 1.0e6) {
    *lo = - (2000.0 / 1.0e6);
    *hi = 2000.0 / 1.0e6;
  }
  return;
}
}
void SST_GetSelectionData(SST_Stats inst , struct timespec *now , double *offset_lo_limit ,
                          double *offset_hi_limit , double *root_distance , double *std_dev ,
                          double *first_sample_ago , double *last_sample_ago , int *select_ok )
{
  double offset ;
  double sample_elapsed ;
  int i ;
  int j ;
  double tmp ;
  {
  if (! inst->n_samples) {
    *select_ok = 0;
    return;
  }
  i = get_runsbuf_index(inst, inst->best_single_sample);
  j = get_buf_index(inst, inst->best_single_sample);
  *std_dev = inst->std_dev;
  tmp = UTI_DiffTimespecsToDouble((struct timespec const *)now, (struct timespec const *)(& inst->sample_times[i]));
  sample_elapsed = fabs(tmp);
  offset = inst->offsets[i] + sample_elapsed * inst->estimated_frequency;
  *root_distance = (0.5 * inst->root_delays[j] + inst->root_dispersions[j]) + sample_elapsed * inst->skew;
  *offset_lo_limit = offset - *root_distance;
  *offset_hi_limit = offset + *root_distance;
  i = get_runsbuf_index(inst, 0);
  *first_sample_ago = UTI_DiffTimespecsToDouble((struct timespec const *)now, (struct timespec const *)(& inst->sample_times[i]));
  i = get_runsbuf_index(inst, inst->n_samples - 1);
  *last_sample_ago = UTI_DiffTimespecsToDouble((struct timespec const *)now, (struct timespec const *)(& inst->sample_times[i]));
  *select_ok = inst->regression_ok;
  if (! *select_ok) {
    if (inst->n_samples < 3) {
      if (inst->n_samples == inst->max_samples) {
        *std_dev = CNF_GetMaxJitter();
        *select_ok = 1;
      }
    }
  }
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  return;
}
}
void SST_GetTrackingData(SST_Stats inst , struct timespec *ref_time , double *average_offset ,
                         double *offset_sd , double *frequency , double *frequency_sd ,
                         double *skew , double *root_delay , double *root_dispersion )
{
  int i ;
  int j ;
  double elapsed_sample ;
  {
  assert(inst->n_samples > 0);
  i = get_runsbuf_index(inst, inst->best_single_sample);
  j = get_buf_index(inst, inst->best_single_sample);
  *ref_time = inst->offset_time;
  *average_offset = inst->estimated_offset;
  *offset_sd = inst->estimated_offset_sd;
  *frequency = inst->estimated_frequency;
  *frequency_sd = inst->estimated_frequency_sd;
  *skew = inst->skew;
  *root_delay = inst->root_delays[j];
  elapsed_sample = UTI_DiffTimespecsToDouble((struct timespec const *)(& inst->offset_time),
                                             (struct timespec const *)(& inst->sample_times[i]));
  *root_dispersion = (inst->root_dispersions[j] + inst->skew * elapsed_sample) + *offset_sd;
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  return;
}
}
void SST_SlewSamples(SST_Stats inst , struct timespec *when , double dfreq , double doffset )
{
  int m ;
  int i ;
  double delta_time ;
  struct timespec *sample ;
  struct timespec prev ;
  double prev_offset ;
  double prev_freq ;
  char *tmp ;
  char *tmp___0 ;
  {
  if (! inst->n_samples) {
    return;
  }
  m = - inst->runs_samples;
  {
  while (1) {
    while_continue: ;
    if (! (m < inst->n_samples)) {
      goto while_break;
    }
    i = get_runsbuf_index(inst, m);
    sample = & inst->sample_times[i];
    prev = *sample;
    UTI_AdjustTimespec((struct timespec const *)sample, (struct timespec const *)when,
                       sample, & delta_time, dfreq, doffset);
    inst->offsets[i] += delta_time;
    m ++;
  }
  while_break: ;
  }
  prev = inst->offset_time;
  prev_offset = inst->estimated_offset;
  prev_freq = inst->estimated_frequency;
  UTI_AdjustTimespec((struct timespec const *)(& inst->offset_time), (struct timespec const *)when,
                     & inst->offset_time, & delta_time, dfreq, doffset);
  inst->estimated_offset += delta_time;
  inst->estimated_frequency = (inst->estimated_frequency - dfreq) / (1.0 - dfreq);
  {
  while (1) {
    while_continue___0: ;
    goto while_break___0;
  }
  while_break___0: ;
  }
  return;
}
}
void SST_CorrectOffset(SST_Stats inst , double doffset )
{
  int i ;
  int tmp ;
  {
  if (! inst->n_samples) {
    return;
  }
  i = - inst->runs_samples;
  {
  while (1) {
    while_continue: ;
    if (! (i < inst->n_samples)) {
      goto while_break;
    }
    tmp = get_runsbuf_index(inst, i);
    inst->offsets[tmp] += doffset;
    i ++;
  }
  while_break: ;
  }
  inst->estimated_offset += doffset;
  return;
}
}
void SST_AddDispersion(SST_Stats inst , double dispersion )
{
  int m ;
  int i ;
  {
  m = 0;
  {
  while (1) {
    while_continue: ;
    if (! (m < inst->n_samples)) {
      goto while_break;
    }
    i = get_buf_index(inst, m);
    inst->root_dispersions[i] += dispersion;
    inst->peer_dispersions[i] += dispersion;
    m ++;
  }
  while_break: ;
  }
  return;
}
}
double SST_PredictOffset(SST_Stats inst , struct timespec *when )
{
  double elapsed ;
  {
  if (inst->n_samples < 3) {
    if (inst->n_samples > 0) {
      return (inst->offsets[inst->last_sample]);
    } else {
      return (0.0);
    }
  } else {
    elapsed = UTI_DiffTimespecsToDouble((struct timespec const *)when, (struct timespec const *)(& inst->offset_time));
    return (inst->estimated_offset + elapsed * inst->estimated_frequency);
  }
}
}
double SST_MinRoundTripDelay(SST_Stats inst )
{
  {
  if (inst->fixed_min_delay > 0.0) {
    return (inst->fixed_min_delay);
  }
  if (! inst->n_samples) {
    return ((double )1.79769313486231570814527423731704357e+308L);
  }
  return (inst->peer_delays[inst->min_delay_sample]);
}
}
int SST_GetDelayTestData(SST_Stats inst , struct timespec *sample_time , double *last_sample_ago ,
                         double *predicted_offset , double *min_delay , double *skew ,
                         double *std_dev )
{
  {
  if (inst->n_samples < 6) {
    return (0);
  }
  *last_sample_ago = UTI_DiffTimespecsToDouble((struct timespec const *)sample_time,
                                               (struct timespec const *)(& inst->offset_time));
  *predicted_offset = inst->estimated_offset + *last_sample_ago * inst->estimated_frequency;
  *min_delay = SST_MinRoundTripDelay(inst);
  *skew = inst->skew;
  *std_dev = inst->std_dev;
  return (1);
}
}
int SST_SaveToFile(SST_Stats inst , FILE *out )
{
  int m ;
  int i ;
  int j ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  {
  if (inst->n_samples < 1) {
    return (0);
  }
  tmp = fprintf(out, (char const *)"%d %d\n", inst->n_samples, inst->asymmetry_run);
  if (tmp < 0) {
    return (0);
  }
  m = 0;
  {
  while (1) {
    while_continue: ;
    if (! (m < inst->n_samples)) {
      goto while_break;
    }
    i = get_runsbuf_index(inst, m);
    j = get_buf_index(inst, m);
    tmp___0 = UTI_TimespecToString((struct timespec const *)(& inst->sample_times[i]));
    tmp___1 = fprintf(out, (char const *)"%s %.6e %.6e %.6e %.6e %.6e %.6e\n", tmp___0,
                      inst->offsets[i], inst->orig_offsets[j], inst->peer_delays[i],
                      inst->peer_dispersions[j], inst->root_delays[j], inst->root_dispersions[j]);
    if (tmp___1 < 0) {
      return (0);
    }
    m ++;
  }
  while_break: ;
  }
  return (1);
}
}
int SST_LoadFromFile(SST_Stats inst , FILE *in )
{
  int i ;
  int n_samples___1 ;
  int arun ;
  struct timespec now ;
  double sample_time ;
  char line[256] ;
  char __attribute__((__access__(__write_only__,1,2))) *tmp ;
  int tmp___0 ;
  char __attribute__((__access__(__write_only__,1,2))) *tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  {
  tmp = fgets(line, (int )sizeof(line), in);
  if (tmp) {
    tmp___0 = sscanf((char const *)(line), (char const *)"%d %d", & n_samples___1,
                     & arun);
    if (tmp___0 != 2) {
      return (0);
    } else
    if (n_samples___1 < 1) {
      return (0);
    } else
    if (n_samples___1 > 64) {
      return (0);
    }
  } else {
    return (0);
  }
  SST_ResetInstance(inst);
  LCL_ReadCookedTime(& now, (double *)((void *)0));
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < n_samples___1)) {
      goto while_break;
    }
    tmp___1 = fgets(line, (int )sizeof(line), in);
    if (tmp___1) {
      tmp___2 = sscanf((char const *)(line), (char const *)"%lf %lf %lf %lf %lf %lf %lf",
                       & sample_time, & inst->offsets[i], & inst->orig_offsets[i],
                       & inst->peer_delays[i], & inst->peer_dispersions[i], & inst->root_delays[i],
                       & inst->root_dispersions[i]);
      if (tmp___2 != 7) {
        return (0);
      }
    } else {
      return (0);
    }
    tmp___3 = UTI_TimespecToDouble((struct timespec const *)(& now));
    tmp___4 = UTI_IsTimeOffsetSane((struct timespec const *)(& now), sample_time - tmp___3);
    if (! tmp___4) {
      return (0);
    }
    UTI_DoubleToTimespec(sample_time, & inst->sample_times[i]);
    tmp___5 = UTI_IsTimeOffsetSane((struct timespec const *)(& inst->sample_times[i]),
                                   - inst->offsets[i]);
    if (tmp___5) {
      tmp___6 = fabs(inst->peer_delays[i]);
      if (tmp___6 < 1.0e6) {
        tmp___7 = fabs(inst->peer_dispersions[i]);
        if (tmp___7 < 1.0e6) {
          tmp___8 = fabs(inst->root_delays[i]);
          if (tmp___8 < 1.0e6) {
            tmp___9 = fabs(inst->root_dispersions[i]);
            if (tmp___9 < 1.0e6) {
              if (i > 0) {
                tmp___10 = UTI_CompareTimespecs((struct timespec const *)(& inst->sample_times[i]),
                                                (struct timespec const *)(& inst->sample_times[i - 1]));
                if (tmp___10 <= 0) {
                  return (0);
                }
              }
            } else {
              return (0);
            }
          } else {
            return (0);
          }
        } else {
          return (0);
        }
      } else {
        return (0);
      }
    } else {
      return (0);
    }
    i ++;
  }
  while_break: ;
  }
  inst->n_samples = n_samples___1;
  inst->last_sample = inst->n_samples - 1;
  if (arun < 1000) {
    tmp___13 = arun;
  } else {
    tmp___13 = 1000;
  }
  if (-1000 > tmp___13) {
    inst->asymmetry_run = -1000;
  } else {
    if (arun < 1000) {
      tmp___12 = arun;
    } else {
      tmp___12 = 1000;
    }
    inst->asymmetry_run = tmp___12;
  }
  find_min_delay_sample(inst);
  SST_DoNewRegression(inst);
  return (1);
}
}
void SST_DoSourceReport(SST_Stats inst , RPT_SourceReport *report , struct timespec *now )
{
  int i ;
  int j ;
  struct timespec last_sample_time ;
  double tmp ;
  {
  if (inst->n_samples > 0) {
    i = get_runsbuf_index(inst, inst->n_samples - 1);
    j = get_buf_index(inst, inst->n_samples - 1);
    report->orig_latest_meas = inst->orig_offsets[j];
    report->latest_meas = inst->offsets[i];
    report->latest_meas_err = 0.5 * inst->root_delays[j] + inst->root_dispersions[j];
    last_sample_time = inst->sample_times[i];
    last_sample_time.tv_nsec = (__syscall_slong_t )0;
    tmp = UTI_DiffTimespecsToDouble((struct timespec const *)now, (struct timespec const *)(& last_sample_time));
    report->latest_meas_ago = (unsigned long )tmp;
  } else {
    report->latest_meas_ago = (unsigned long )((uint32_t )-1);
    report->orig_latest_meas = (double )0;
    report->latest_meas = (double )0;
    report->latest_meas_err = (double )0;
    report->stratum = 0;
  }
  return;
}
}
int SST_Samples(SST_Stats inst )
{
  {
  return (inst->n_samples);
}
}
void SST_DoSourcestatsReport(SST_Stats inst , RPT_SourcestatsReport *report , struct timespec *now )
{
  double dspan ;
  double elapsed ;
  double sample_elapsed ;
  int bi ;
  int bj ;
  int tmp ;
  double tmp___0 ;
  {
  report->n_samples = (unsigned long )inst->n_samples;
  report->n_runs = (unsigned long )inst->nruns;
  if (inst->n_samples > 0) {
    bi = get_runsbuf_index(inst, inst->best_single_sample);
    bj = get_buf_index(inst, inst->best_single_sample);
    tmp = get_runsbuf_index(inst, 0);
    dspan = UTI_DiffTimespecsToDouble((struct timespec const *)(& inst->sample_times[inst->last_sample]),
                                      (struct timespec const *)(& inst->sample_times[tmp]));
    elapsed = UTI_DiffTimespecsToDouble((struct timespec const *)now, (struct timespec const *)(& inst->offset_time));
    sample_elapsed = UTI_DiffTimespecsToDouble((struct timespec const *)now, (struct timespec const *)(& inst->sample_times[bi]));
    tmp___0 = round(dspan);
    report->span_seconds = (unsigned long )tmp___0;
    report->est_offset = inst->estimated_offset + elapsed * inst->estimated_frequency;
    report->est_offset_err = (inst->estimated_offset_sd + sample_elapsed * inst->skew) + (0.5 * inst->root_delays[bj] + inst->root_dispersions[bj]);
  } else {
    report->span_seconds = 0UL;
    report->est_offset = (double )0;
    report->est_offset_err = (double )0;
  }
  report->resid_freq_ppm = 1.0e6 * inst->estimated_frequency;
  report->skew_ppm = 1.0e6 * inst->skew;
  report->sd = inst->std_dev;
  return;
}
}
double SST_GetJitterAsymmetry(SST_Stats inst )
{
  {
  return (inst->asymmetry);
}
}
void DNS_Name2IPAddressAsync(char const *name , void (*handler)(DNS_Status status ,
                                                                  int n_addrs , IPAddr *ip_addrs ,
                                                                  void *anything ) ,
                             void *anything ) ;
extern NKC_Instance NKC_CreateInstance(IPSockAddr *address , char const *name ,
                                       uint32_t cert_set ) ;
extern void NKC_DestroyInstance(NKC_Instance inst ) ;
extern int NKC_Start(NKC_Instance inst ) ;
extern int NKC_IsActive(NKC_Instance inst ) ;
extern int NKC_GetNtsData(NKC_Instance inst , NKE_Context *context , NKE_Cookie *cookies ,
                          int *num_cookies , int max_cookies , IPSockAddr *ntp_address ) ;
extern int NKC_GetRetryFactor(NKC_Instance inst ) ;
NNC_Instance NNC_CreateInstance(IPSockAddr *nts_address , char const *name , uint32_t cert_set ,
                                uint16_t ntp_port___0 ) ;
void NNC_DestroyInstance(NNC_Instance inst ) ;
int NNC_PrepareForAuth(NNC_Instance inst ) ;
int NNC_GenerateRequestAuth(NNC_Instance inst , NTP_Packet *packet , NTP_PacketInfo *info ) ;
int NNC_CheckResponseAuth(NNC_Instance inst , NTP_Packet *packet , NTP_PacketInfo *info ) ;
void NNC_ChangeAddress(NNC_Instance inst , IPAddr *address ) ;
void NNC_DumpData(NNC_Instance inst ) ;
void NNC_GetReport(NNC_Instance inst , RPT_AuthReport *report ) ;
void NSD_Initialise(void)
{
  {
  return;
}
}
void NSD_Finalise(void)
{
  {
  return;
}
}
int NSD_SignAndSendPacket(uint32_t key_id , NTP_Packet *packet , NTP_PacketInfo *info ,
                          NTP_Remote_Address *remote_addr , NTP_Local_Address *local_addr )
{
  {
  return (0);
}
}
int CMC_GetKeyLength(CMC_Algorithm algorithm )
{
  {
  return (0);
}
}
CMC_Instance CMC_CreateInstance(CMC_Algorithm algorithm , unsigned char const *key ,
                                int length )
{
  {
  return ((CMC_Instance )((void *)0));
}
}
int CMC_Hash(CMC_Instance inst , void const *in , int in_len , unsigned char *out ,
             int out_len )
{
  {
  return (0);
}
}
void CMC_DestroyInstance(CMC_Instance inst )
{
  {
  return;
}
}
void NNS_Initialise(void)
{
  {
  return;
}
}
void NNS_Finalise(void)
{
  {
  return;
}
}
int NNS_CheckRequestAuth(NTP_Packet *packet , NTP_PacketInfo *info , uint32_t *kod )
{
  {
  *kod = (uint32_t )0;
  return (0);
}
}
int NNS_GenerateResponseAuth(NTP_Packet *request , NTP_PacketInfo *req_info , NTP_Packet *response ,
                             NTP_PacketInfo *res_info , uint32_t kod )
{
  {
  return (0);
}
}
NNC_Instance NNC_CreateInstance(IPSockAddr *nts_address , char const *name , uint32_t cert_set ,
                                uint16_t ntp_port___0 )
{
  {
  return ((NNC_Instance )((void *)0));
}
}
void NNC_DestroyInstance(NNC_Instance inst )
{
  {
  return;
}
}
int NNC_PrepareForAuth(NNC_Instance inst )
{
  {
  return (1);
}
}
static int logged = 0;
int NNC_GenerateRequestAuth(NNC_Instance inst , NTP_Packet *packet , NTP_PacketInfo *info )
{
  int tmp ;
  {
  if (logged) {
    tmp = -1;
  } else {
    tmp = 1;
  }
  LOG_Message((LOG_Severity )tmp, (char const *)"Missing NTS support");
  logged = 1;
  return (0);
}
}
int NNC_CheckResponseAuth(NNC_Instance inst , NTP_Packet *packet , NTP_PacketInfo *info )
{
  {
  return (0);
}
}
void NNC_ChangeAddress(NNC_Instance inst , IPAddr *address )
{
  {
  return;
}
}
void NNC_DumpData(NNC_Instance inst )
{
  {
  return;
}
}
void NNC_GetReport(NNC_Instance inst , RPT_AuthReport *report )
{
  {
  return;
}
}
void NKS_PreInitialise(uid_t uid , gid_t gid , int scfilter_level )
{
  {
  return;
}
}
void NKS_Initialise(void)
{
  {
  return;
}
}
void NKS_Finalise(void)
{
  {
  return;
}
}
void NKS_DumpKeys(void)
{
  {
  return;
}
}
void NKS_ReloadKeys(void)
{
  {
  return;
}
}
static struct stage stages[3] ;
static int enabled ;
static int leap_only_mode ;
static int locked ;
static double max_wander ;
static double max_freq ;
static double smooth_freq ;
static double smooth_offset ;
static struct timespec last_update ;
static void get_smoothing(struct timespec *now , double *poffset , double *pfreq ,
                          double *pwander )
{
  double elapsed ;
  double length ;
  double offset ;
  double freq___0 ;
  double wander ;
  int i ;
  {
  elapsed = UTI_DiffTimespecsToDouble((struct timespec const *)now, (struct timespec const *)(& last_update));
  offset = smooth_offset;
  freq___0 = smooth_freq;
  wander = 0.0;
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < 3)) {
      goto while_break;
    }
    if (elapsed <= 0.0) {
      goto while_break;
    }
    length = stages[i].length;
    if (length >= elapsed) {
      length = elapsed;
    }
    wander = stages[i].wander;
    offset -= (length * (2.0 * freq___0 + wander * length)) / 2.0;
    freq___0 += wander * length;
    elapsed -= length;
    i ++;
  }
  while_break: ;
  }
  if (elapsed > 0.0) {
    wander = 0.0;
    offset -= elapsed * freq___0;
  }
  *poffset = offset;
  *pfreq = freq___0;
  if (pwander) {
    *pwander = wander;
  }
  return;
}
}
static void update_stages(void)
{
  double s1 ;
  double s2 ;
  double s ;
  double l1 ;
  double l2 ;
  double l3 ;
  double lc ;
  double f ;
  double f2 ;
  double l1t[2] ;
  double l3t[2] ;
  double err[2] ;
  int i ;
  int dir ;
  {
  s1 = smooth_offset / max_wander;
  s2 = (smooth_freq * smooth_freq) / (2.0 * (max_wander * max_wander));
  i = 0;
  dir = -1;
  {
  while (1) {
    while_continue: ;
    if (! (i <= 1)) {
      goto while_break;
    }
    err[i] = 0.0;
    s = (double )dir * s1 + s2;
    if (s < 0.0) {
      err[i] += - s;
      s = 0.0;
    }
    l3t[i] = sqrt(s);
    l1t[i] = l3t[i] - ((double )dir * smooth_freq) / max_wander;
    if (l1t[i] < 0.0) {
      err[i] += l1t[i] * l1t[i];
      l1t[i] = 0.0;
    }
    i ++;
    dir += 2;
  }
  while_break: ;
  }
  if (err[0] < err[1]) {
    l1 = l1t[0];
    l3 = l3t[0];
    dir = -1;
  } else {
    l1 = l1t[1];
    l3 = l3t[1];
    dir = 1;
  }
  l2 = 0.0;
  f = ((double )dir * smooth_freq + l1 * max_wander) - max_freq;
  if (f > 0.0) {
    lc = f / max_wander;
    if (lc > l1) {
      lc = l1;
      f2 = (double )dir * smooth_freq;
    } else {
      f2 = max_freq;
    }
    l2 = lc * (2.0 + f / f2);
    l1 -= lc;
    l3 -= lc;
  }
  stages[0].wander = (double )dir * max_wander;
  stages[0].length = l1;
  stages[1].wander = 0.0;
  stages[1].length = l2;
  stages[2].wander = (double )(- dir) * max_wander;
  stages[2].length = l3;
  i = 0;
  {
  while (1) {
    while_continue___0: ;
    if (! (i < 3)) {
      goto while_break___0;
    }
    {
    while (1) {
      while_continue___1: ;
      goto while_break___1;
    }
    while_break___1: ;
    }
    i ++;
  }
  while_break___0: ;
  }
  return;
}
}
static void update_smoothing(struct timespec *now , double offset , double freq___0 )
{
  double tmp ;
  {
  if (locked) {
    tmp = REF_GetSkew();
    if (tmp / max_wander < (double )10000) {
      SMT_Activate(now);
    } else
    if (leap_only_mode) {
      SMT_Activate(now);
    }
    return;
  }
  get_smoothing(now, & smooth_offset, & smooth_freq, (double *)((void *)0));
  smooth_offset += offset;
  smooth_freq = (smooth_freq - freq___0) / (1.0 - freq___0);
  last_update = *now;
  update_stages();
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  return;
}
}
static void handle_slew___1(struct timespec *raw , struct timespec *cooked , double dfreq ,
                            double doffset , LCL_ChangeType change_type , void *anything )
{
  double delta ;
  int tmp ;
  {
  if ((unsigned int )change_type == 0U) {
    if (leap_only_mode) {
      update_smoothing(cooked, 0.0, 0.0);
    } else {
      update_smoothing(cooked, doffset, dfreq);
    }
  }
  tmp = UTI_IsZeroTimespec(& last_update);
  if (! tmp) {
    UTI_AdjustTimespec((struct timespec const *)(& last_update), (struct timespec const *)cooked,
                       & last_update, & delta, dfreq, doffset);
  }
  return;
}
}
void SMT_Initialise(void)
{
  {
  CNF_GetSmooth(& max_freq, & max_wander, & leap_only_mode);
  if (max_freq <= 0.0) {
    enabled = 0;
    return;
  } else
  if (max_wander <= 0.0) {
    enabled = 0;
    return;
  }
  enabled = 1;
  locked = 1;
  max_freq *= 1e-6;
  max_wander *= 1e-6;
  UTI_ZeroTimespec(& last_update);
  LCL_AddParameterChangeHandler(& handle_slew___1, (void *)0);
  return;
}
}
void SMT_Finalise(void)
{
  {
  if (! enabled) {
    return;
  }
  LCL_RemoveParameterChangeHandler(& handle_slew___1, (void *)0);
  return;
}
}
int SMT_IsEnabled(void)
{
  {
  return (enabled);
}
}
double SMT_GetOffset(struct timespec *now )
{
  double offset ;
  double freq___0 ;
  {
  if (! enabled) {
    return (0.0);
  }
  get_smoothing(now, & offset, & freq___0, (double *)((void *)0));
  return (offset);
}
}
void SMT_Activate(struct timespec *now )
{
  char *tmp ;
  {
  if (! enabled) {
    return;
  } else
  if (! locked) {
    return;
  }
  if (leap_only_mode) {
    tmp = " (leap seconds only)";
  } else {
    tmp = "";
  }
  LOG_Message((LOG_Severity )0, (char const *)"Time smoothing activated%s", tmp);
  locked = 0;
  last_update = *now;
  return;
}
}
void SMT_Reset(struct timespec *now )
{
  int i ;
  double tmp ;
  {
  if (! enabled) {
    return;
  }
  smooth_offset = 0.0;
  smooth_freq = 0.0;
  last_update = *now;
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < 3)) {
      goto while_break;
    }
    tmp = 0.0;
    stages[i].length = tmp;
    stages[i].wander = tmp;
    i ++;
  }
  while_break: ;
  }
  return;
}
}
void SMT_Leap(struct timespec *now , int leap )
{
  {
  if (! enabled) {
    return;
  } else
  if (! leap_only_mode) {
    return;
  }
  update_smoothing(now, (double )leap, 0.0);
  return;
}
}
int SMT_GetSmoothingReport(RPT_SmoothingReport *report , struct timespec *now )
{
  double length ;
  double elapsed ;
  int i ;
  {
  if (! enabled) {
    return (0);
  }
  report->active = ! locked;
  report->leap_only = leap_only_mode;
  get_smoothing(now, & report->offset, & report->freq_ppm, & report->wander_ppm);
  report->freq_ppm *= - 1.0e6;
  report->wander_ppm *= - 1.0e6;
  elapsed = UTI_DiffTimespecsToDouble((struct timespec const *)now, (struct timespec const *)(& last_update));
  if (! locked) {
    if (elapsed >= 0.0) {
      i = 0;
      length = 0.0;
      {
      while (1) {
        while_continue: ;
        if (! (i < 3)) {
          goto while_break;
        }
        length += stages[i].length;
        i ++;
      }
      while_break: ;
      }
      report->last_update_ago = elapsed;
      if (elapsed < length) {
        report->remaining_time = length - elapsed;
      } else {
        report->remaining_time = 0.0;
      }
    } else {
      report->last_update_ago = 0.0;
      report->remaining_time = 0.0;
    }
  } else {
    report->last_update_ago = 0.0;
    report->remaining_time = 0.0;
  }
  return (1);
}
}
void SYS_Null_Initialise(void) ;
void SYS_Null_Finalise(void) ;
void SYS_Linux_Initialise(void) ;
void SYS_Linux_Finalise(void) ;
extern void SYS_Linux_DropRoot(uid_t uid , gid_t gid , SYS_ProcessContext context ,
                               int clock_control ) ;
extern void SYS_Linux_EnableSystemCallFilter(int level , SYS_ProcessContext context ) ;
int SYS_Linux_CheckKernelVersion(int req_major , int req_minor ) ;
int SYS_Linux_OpenPHC(char const *path , int phc_index ) ;
int SYS_Linux_GetPHCSample(int fd___0 , int nocrossts , double precision , int *reading_mode ,
                           struct timespec *phc_ts , struct timespec *sys_ts , double *err ) ;
int SYS_Linux_SetPHCExtTimestamping(int fd___0 , int pin , int channel , int rising ,
                                    int falling , int enable ) ;
int SYS_Linux_ReadPHCExtTimestamp(int fd___0 , struct timespec *phc_ts , int *channel ) ;
void SYS_Posix_MemLockAll(void) ;
void SYS_Posix_SetScheduler(int priority ) ;
static int null_driver ;
void SYS_Initialise(int clock_control )
{
  {
  null_driver = ! clock_control;
  if (null_driver) {
    SYS_Null_Initialise();
    return;
  }
  SYS_Linux_Initialise();
  return;
}
}
void SYS_Finalise(void)
{
  {
  if (null_driver) {
    SYS_Null_Finalise();
    return;
  }
  SYS_Linux_Finalise();
  return;
}
}
void SYS_DropRoot(uid_t uid , gid_t gid , SYS_ProcessContext context )
{
  {
  {
  while (1) {
    while_continue: ;
    LOG_Message((LOG_Severity )3, (char const *)"dropping root privileges not supported");
    exit(1);
    goto while_break;
  }
  while_break: ;
  }
  return;
}
}
void SYS_EnableSystemCallFilter(int level , SYS_ProcessContext context )
{
  {
  {
  while (1) {
    while_continue: ;
    LOG_Message((LOG_Severity )3, (char const *)"system call filter not supported");
    exit(1);
    goto while_break;
  }
  while_break: ;
  }
  return;
}
}
void SYS_SetScheduler(int SchedPriority )
{
  {
  SYS_Posix_SetScheduler(SchedPriority);
  return;
}
}
void SYS_LockMemory(void)
{
  {
  SYS_Posix_MemLockAll();
  return;
}
}
static double freq ;
static double offset_register ;
static struct timespec last_update___0 ;
static void update_offset(void)
{
  struct timespec now ;
  double duration ;
  {
  LCL_ReadRawTime(& now);
  duration = UTI_DiffTimespecsToDouble((struct timespec const *)(& now), (struct timespec const *)(& last_update___0));
  offset_register += (1.0e-6 * freq) * duration;
  last_update___0 = now;
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  return;
}
}
static double read_frequency(void)
{
  {
  return (freq);
}
}
static double set_frequency(double freq_ppm )
{
  {
  update_offset();
  freq = freq_ppm;
  return (freq);
}
}
static void accrue_offset(double offset , double corr_rate )
{
  {
  offset_register += offset;
  return;
}
}
static int apply_step_offset(double offset )
{
  {
  return (0);
}
}
static void offset_convert(struct timespec *raw , double *corr , double *err )
{
  double duration ;
  {
  duration = UTI_DiffTimespecsToDouble((struct timespec const *)raw, (struct timespec const *)(& last_update___0));
  if (duration > 1000.0) {
    update_offset();
    duration = 0.0;
  }
  *corr = (- 1.0e-6 * freq) * duration - offset_register;
  if (err) {
    *err = 0.0;
  }
  return;
}
}
void SYS_Null_Initialise(void)
{
  {
  offset_register = 0.0;
  LCL_ReadRawTime(& last_update___0);
  lcl_RegisterSystemDrivers(& read_frequency, & set_frequency, & accrue_offset, & apply_step_offset,
                            & offset_convert, (void (*)(int leap , int tai_offset ))((void *)0),
                            (void (*)(int synchronised , double est_error , double max_error ))((void *)0));
  LOG_Message((LOG_Severity )0, (char const *)"Disabled control of system clock");
  return;
}
}
void SYS_Null_Finalise(void)
{
  {
  return;
}
}
static SCH_TimeoutID timeout_id ;
static LOG_FileID logfileid___1 ;
static char *filename ;
static double update_interval ;
static double T0 ;
static double k0 ;
static double k1 ;
static double k2 ;
static ARR_Instance points ;
static double get_tempcomp(double temp )
{
  unsigned int i ;
  struct Point *p1 ;
  struct Point *p2 ;
  void *tmp ;
  unsigned int tmp___0 ;
  {
  p1 = (struct Point *)((void *)0);
  p2 = (struct Point *)((void *)0);
  if (! points) {
    return ((k0 + (temp - T0) * k1) + ((temp - T0) * (temp - T0)) * k2);
  }
  i = 1U;
  {
  while (1) {
    while_continue: ;
    tmp___0 = ARR_GetSize(points);
    if (! (i < tmp___0)) {
      goto while_break;
    }
    tmp = ARR_GetElement(points, i);
    p2 = (struct Point *)tmp;
    if (p2->temp >= temp) {
      goto while_break;
    }
    i ++;
  }
  while_break: ;
  }
  p1 = p2 - 1;
  return (((temp - p1->temp) / (p2->temp - p1->temp)) * (p2->comp - p1->comp) + p1->comp);
}
}
static void read_timeout(void *arg )
{
  FILE *f ;
  double temp ;
  double comp ;
  struct timespec now ;
  char *tmp ;
  double tmp___0 ;
  int tmp___1 ;
  {
  f = UTI_OpenFile((char const *)((void *)0), (char const *)filename, (char const *)((void *)0),
                   (char )'r', (mode_t )0);
  if (f) {
    tmp___1 = fscanf(f, (char const *)"%lf", & temp);
    if (tmp___1 == 1) {
      comp = get_tempcomp(temp);
      tmp___0 = fabs(comp);
      if (tmp___0 <= 10.0) {
        comp = LCL_SetTempComp(comp);
        {
        while (1) {
          while_continue: ;
          goto while_break;
        }
        while_break: ;
        }
        if (logfileid___1 != -1) {
          LCL_ReadCookedTime(& now, (double *)((void *)0));
          tmp = UTI_TimeToLogForm(now.tv_sec);
          LOG_FileWrite(logfileid___1, (char const *)"%s %11.4e %11.4e", tmp, temp,
                        comp);
        }
      } else {
        LOG_Message((LOG_Severity )1, (char const *)"Temperature compensation of %.3f ppm exceeds sanity limit of %.1f",
                    comp, 10.0);
      }
    } else {
      LOG_Message((LOG_Severity )1, (char const *)"Could not read temperature from %s",
                  filename);
    }
  } else {
    LOG_Message((LOG_Severity )1, (char const *)"Could not read temperature from %s",
                filename);
  }
  if (f) {
    fclose(f);
  }
  timeout_id = SCH_AddTimeoutByDelay(update_interval, & read_timeout, (void *)0);
  return;
}
}
static void read_points(char const *filename___0 )
{
  FILE *f ;
  char line[256] ;
  struct Point *p ;
  void *tmp ;
  int tmp___0 ;
  char __attribute__((__access__(__write_only__,1,2))) *tmp___1 ;
  unsigned int tmp___2 ;
  {
  f = UTI_OpenFile((char const *)((void *)0), filename___0, (char const *)((void *)0),
                   (char )'R', (mode_t )0);
  points = ARR_CreateInstance((unsigned int )sizeof(struct Point ));
  {
  while (1) {
    while_continue: ;
    tmp___1 = fgets(line, (int )sizeof(line), f);
    if (! tmp___1) {
      goto while_break;
    }
    tmp = ARR_GetNewElement(points);
    p = (struct Point *)tmp;
    tmp___0 = sscanf((char const *)(line), (char const *)"%lf %lf", & p->temp,
                     & p->comp);
    if (tmp___0 != 2) {
      {
      while (1) {
        while_continue___0: ;
        LOG_Message((LOG_Severity )3, (char const *)"Could not read tempcomp point from %s",
                    filename___0);
        exit(1);
        goto while_break___0;
      }
      while_break___0: ;
      }
      goto while_break;
    }
  }
  while_break: ;
  }
  fclose(f);
  tmp___2 = ARR_GetSize(points);
  if (tmp___2 < 2U) {
    {
    while (1) {
      while_continue___1: ;
      LOG_Message((LOG_Severity )3, (char const *)"Not enough points in %s", filename___0);
      exit(1);
      goto while_break___1;
    }
    while_break___1: ;
    }
  }
  return;
}
}
void TMC_Initialise(void)
{
  char *point_file ;
  int tmp ;
  LOG_FileID tmp___0 ;
  int tmp___1 ;
  {
  CNF_GetTempComp(& filename, & update_interval, & point_file, & T0, & k0, & k1, & k2);
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
    return;
  }
  if (update_interval <= 0.0) {
    update_interval = 1.0;
  }
  if (point_file) {
    read_points((char const *)point_file);
  }
  tmp___1 = CNF_GetLogTempComp();
  if (tmp___1) {
    tmp___0 = LOG_FileOpen((char const *)"tempcomp", (char const *)"   Date (UTC) Time        Temp.       Comp.");
    logfileid___1 = tmp___0;
  } else {
    logfileid___1 = -1;
  }
  read_timeout((void *)0);
  return;
}
}
void TMC_Finalise(void)
{
  {
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
    return;
  }
  if (points) {
    ARR_DestroyInstance(points);
  }
  SCH_RemoveTimeout(timeout_id);
  return;
}
}
void UTI_ZeroTimespec(struct timespec *ts )
{
  {
  ts->tv_sec = (__time_t )0;
  ts->tv_nsec = (__syscall_slong_t )0;
  return;
}
}
int UTI_IsZeroTimespec(struct timespec *ts )
{
  int tmp ;
  {
  if (! ts->tv_sec) {
    if (! ts->tv_nsec) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
void UTI_TimevalToTimespec(struct timeval const *tv , struct timespec *ts )
{
  {
  ts->tv_sec = (__time_t )tv->tv_sec;
  ts->tv_nsec = (__syscall_slong_t )(1000L * tv->tv_usec);
  return;
}
}
void UTI_TimespecToTimeval(struct timespec const *ts , struct timeval *tv )
{
  {
  tv->tv_sec = (__time_t )ts->tv_sec;
  tv->tv_usec = (__suseconds_t )(ts->tv_nsec / 1000L);
  return;
}
}
double UTI_TimespecToDouble(struct timespec const *ts )
{
  {
  return ((double )ts->tv_sec + 1.0e-9 * (double )ts->tv_nsec);
}
}
void UTI_DoubleToTimespec(double d , struct timespec *ts )
{
  {
  ts->tv_sec = (__time_t )d;
  ts->tv_nsec = (__syscall_slong_t )(1.0e9 * (d - (double )ts->tv_sec));
  UTI_NormaliseTimespec(ts);
  return;
}
}
void UTI_NormaliseTimespec(struct timespec *ts )
{
  {
  if (ts->tv_nsec >= 1000000000L) {
    goto _L;
  } else
  if (ts->tv_nsec < 0L) {
    _L:
    ts->tv_sec += ts->tv_nsec / 1000000000L;
    ts->tv_nsec %= 1000000000L;
    if (ts->tv_nsec < 0L) {
      (ts->tv_sec) --;
      ts->tv_nsec += 1000000000L;
    }
  }
  return;
}
}
double UTI_TimevalToDouble(struct timeval const *tv )
{
  {
  return ((double )tv->tv_sec + 1.0e-6 * (double )tv->tv_usec);
}
}
void UTI_DoubleToTimeval(double a , struct timeval *b )
{
  double frac_part ;
  double tmp ;
  {
  b->tv_sec = (__time_t )a;
  frac_part = 1.0e6 * (a - (double )b->tv_sec);
  tmp = round(frac_part);
  b->tv_usec = (__suseconds_t )tmp;
  UTI_NormaliseTimeval(b);
  return;
}
}
void UTI_NormaliseTimeval(struct timeval *x )
{
  {
  if (x->tv_usec >= 1000000L) {
    x->tv_sec += x->tv_usec / 1000000L;
    x->tv_usec %= 1000000L;
  } else
  if (x->tv_usec <= -1000000L) {
    x->tv_sec += x->tv_usec / 1000000L;
    x->tv_usec %= 1000000L;
  }
  if (x->tv_usec < 0L) {
    (x->tv_sec) --;
    x->tv_usec += 1000000L;
  }
  return;
}
}
int UTI_CompareTimespecs(struct timespec const *a , struct timespec const *b )
{
  {
  if (a->tv_sec < b->tv_sec) {
    return (-1);
  }
  if (a->tv_sec > b->tv_sec) {
    return (1);
  }
  if (a->tv_nsec < b->tv_nsec) {
    return (-1);
  }
  if (a->tv_nsec > b->tv_nsec) {
    return (1);
  }
  return (0);
}
}
void UTI_DiffTimespecs(struct timespec *result , struct timespec const *a , struct timespec const *b )
{
  {
  result->tv_sec = (__time_t )(a->tv_sec - b->tv_sec);
  result->tv_nsec = (__syscall_slong_t )(a->tv_nsec - b->tv_nsec);
  UTI_NormaliseTimespec(result);
  return;
}
}
double UTI_DiffTimespecsToDouble(struct timespec const *a , struct timespec const *b )
{
  {
  return (((double )a->tv_sec - (double )b->tv_sec) + 1.0e-9 * (double )(a->tv_nsec - b->tv_nsec));
}
}
void UTI_AddDoubleToTimespec(struct timespec const *start , double increment , struct timespec *end )
{
  time_t int_part ;
  {
  int_part = (time_t )increment;
  end->tv_sec = (__time_t )(start->tv_sec + (__time_t )int_part);
  end->tv_nsec = (__syscall_slong_t )((double )start->tv_nsec + 1.0e9 * (increment - (double )int_part));
  UTI_NormaliseTimespec(end);
  return;
}
}
void UTI_AverageDiffTimespecs(struct timespec const *earlier , struct timespec const *later ,
                              struct timespec *average , double *diff )
{
  {
  *diff = UTI_DiffTimespecsToDouble(later, earlier);
  UTI_AddDoubleToTimespec(earlier, *diff / 2.0, average);
  return;
}
}
void UTI_AddDiffToTimespec(struct timespec const *a , struct timespec const *b ,
                           struct timespec const *c , struct timespec *result )
{
  double diff ;
  {
  diff = UTI_DiffTimespecsToDouble(a, b);
  UTI_AddDoubleToTimespec(c, diff, result);
  return;
}
}
static char buffer_pool[16][64] ;
static int pool_ptr = 0;
char *UTI_TimespecToString(struct timespec const *ts )
{
  char *result ;
  {
  pool_ptr = (pool_ptr + 1) % 16;
  result = buffer_pool[pool_ptr];
  snprintf(result, (size_t )64, (char const *)"%ld.%09lu", (int64_t )ts->tv_sec,
           (unsigned long )ts->tv_nsec);
  return (result);
}
}
char *UTI_Ntp64ToString(NTP_int64 const *ntp_ts )
{
  struct timespec ts ;
  char *tmp ;
  {
  UTI_Ntp64ToTimespec(ntp_ts, & ts);
  tmp = UTI_TimespecToString((struct timespec const *)(& ts));
  return (tmp);
}
}
char *UTI_RefidToString(uint32_t ref_id )
{
  unsigned int i ;
  unsigned int j ;
  unsigned int c ;
  char *result ;
  unsigned int tmp ;
  unsigned short const **tmp___0 ;
  {
  pool_ptr = (pool_ptr + 1) % 16;
  result = buffer_pool[pool_ptr];
  j = 0U;
  i = j;
  {
  while (1) {
    while_continue: ;
    if (i < 4U) {
      if (! (i < 63U)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    c = (ref_id >> (24U - i * 8U)) & 255U;
    tmp___0 = __ctype_b_loc();
    if ((int const )*(*tmp___0 + (int )c) & 16384) {
      tmp = j;
      j ++;
      *(result + tmp) = (char )c;
    }
    i ++;
  }
  while_break: ;
  }
  *(result + j) = (char )'\000';
  return (result);
}
}
char *UTI_IPToString(IPAddr const *addr )
{
  unsigned long a ;
  unsigned long b ;
  unsigned long c ;
  unsigned long d ;
  unsigned long ip ;
  uint8_t const *ip6 ;
  char *result ;
  {
  pool_ptr = (pool_ptr + 1) % 16;
  result = buffer_pool[pool_ptr];
  {
  if ((int )addr->family == 0) {
    goto case_0;
  }
  if ((int )addr->family == 1) {
    goto case_1;
  }
  if ((int )addr->family == 2) {
    goto case_2;
  }
  if ((int )addr->family == 3) {
    goto case_3;
  }
  goto switch_default;
  case_0:
  snprintf(result, (size_t )64, (char const *)"[UNSPEC]");
  goto switch_break;
  case_1:
  ip = (unsigned long )addr->addr.in4;
  a = (ip >> 24) & 255UL;
  b = (ip >> 16) & 255UL;
  c = (ip >> 8) & 255UL;
  d = ip & 255UL;
  snprintf(result, (size_t )64, (char const *)"%lu.%lu.%lu.%lu", a, b, c, d);
  goto switch_break;
  case_2:
  ip6 = (uint8_t const *)(addr->addr.in6);
  inet_ntop(10, (void const * __restrict )ip6, (char * __restrict )result, (socklen_t )64);
  goto switch_break;
  case_3:
  snprintf(result, (size_t )64, (char const *)"ID#%010u", addr->addr.id);
  goto switch_break;
  switch_default:
  snprintf(result, (size_t )64, (char const *)"[UNKNOWN]");
  switch_break: ;
  }
  return (result);
}
}
int UTI_StringToIP(char const *addr , IPAddr *ip )
{
  struct in_addr in4 ;
  struct in6_addr in6 ;
  int tmp ;
  int tmp___0 ;
  {
  tmp = inet_pton(2, (char const * __restrict )addr, (void * __restrict )(& in4));
  if (tmp > 0) {
    ip->family = (uint16_t )1;
    ip->_pad = (uint16_t )0;
    ip->addr.in4 = __bswap_32(in4.s_addr);
    return (1);
  }
  tmp___0 = inet_pton(10, (char const * __restrict )addr, (void * __restrict )(& in6));
  if (tmp___0 > 0) {
    ip->family = (uint16_t )2;
    ip->_pad = (uint16_t )0;
    memcpy((void *)(ip->addr.in6), (void const *)(in6.__in6_u.__u6_addr8), sizeof(ip->addr.in6));
    return (1);
  }
  return (0);
}
}
int UTI_IsStringIP(char const *string )
{
  IPAddr ip ;
  int tmp ;
  {
  tmp = UTI_StringToIP(string, & ip);
  return (tmp);
}
}
int UTI_StringToIdIP(char const *addr , IPAddr *ip )
{
  int tmp ;
  {
  tmp = sscanf(addr, (char const *)"ID#%u", & ip->addr.id);
  if (tmp == 1) {
    ip->family = (uint16_t )3;
    ip->_pad = (uint16_t )0;
    return (1);
  }
  return (0);
}
}
int UTI_IsIPReal(IPAddr const *ip )
{
  {
  {
  if ((int )ip->family == 2) {
    goto case_2;
  }
  if ((int )ip->family == 1) {
    goto case_2;
  }
  goto switch_default;
  case_2:
  case_1:
  return (1);
  switch_default:
  return (0);
  switch_break: ;
  }
}
}
static int MD5_hash = -1;
uint32_t UTI_IPToRefid(IPAddr const *ip )
{
  unsigned char buf[16] ;
  int tmp ;
  {
  {
  if ((int )ip->family == 1) {
    goto case_1;
  }
  if ((int )ip->family == 2) {
    goto case_2;
  }
  goto switch_break;
  case_1:
  return ((uint32_t )ip->addr.in4);
  case_2:
  if (MD5_hash < 0) {
    MD5_hash = HSH_GetHashId((HSH_Algorithm )10000);
  }
  if (MD5_hash < 0) {
    goto _L;
  } else {
    tmp = HSH_Hash(MD5_hash, (void const *)((unsigned char const *)(ip->addr.in6)),
                   (int )sizeof(ip->addr.in6), (void const *)((void *)0), 0, buf,
                   (int )sizeof(buf));
    if ((unsigned long )tmp != sizeof(buf)) {
      _L:
      {
      while (1) {
        while_continue: ;
        LOG_Message((LOG_Severity )3, (char const *)"Could not get MD5");
        exit(1);
        goto while_break;
      }
      while_break: ;
      }
    }
  }
  return (((((uint32_t )buf[0] << 24) | (unsigned int )((int )buf[1] << 16)) | (unsigned int )((int )buf[2] << 8)) | (unsigned int )buf[3]);
  switch_break: ;
  }
  return ((uint32_t )0);
}
}
static uint32_t seed = (uint32_t )0;
uint32_t UTI_IPToHash(IPAddr const *ip )
{
  unsigned char const *addr ;
  unsigned int i ;
  unsigned int len ;
  uint32_t hash ;
  {
  {
  if ((int )ip->family == 1) {
    goto case_1;
  }
  if ((int )ip->family == 2) {
    goto case_2;
  }
  if ((int )ip->family == 3) {
    goto case_3;
  }
  goto switch_default;
  case_1:
  addr = (unsigned char const *)((unsigned char *)(& ip->addr.in4));
  len = (unsigned int )sizeof(ip->addr.in4);
  goto switch_break;
  case_2:
  addr = (unsigned char const *)(ip->addr.in6);
  len = (unsigned int )sizeof(ip->addr.in6);
  goto switch_break;
  case_3:
  addr = (unsigned char const *)((unsigned char *)(& ip->addr.id));
  len = (unsigned int )sizeof(ip->addr.id);
  goto switch_break;
  switch_default:
  return ((uint32_t )0);
  switch_break: ;
  }
  {
  while (1) {
    while_continue: ;
    if (! (! seed)) {
      goto while_break;
    }
    UTI_GetRandomBytes((void *)(& seed), (unsigned int )sizeof(seed));
  }
  while_break: ;
  }
  i = 0U;
  hash = seed;
  {
  while (1) {
    while_continue___0: ;
    if (! (i < len)) {
      goto while_break___0;
    }
    hash = 71U * hash + (uint32_t )*(addr + i);
    i ++;
  }
  while_break___0: ;
  }
  return (hash + seed);
}
}
void UTI_IPHostToNetwork(IPAddr const *src , IPAddr *dest )
{
  {
  memset((void *)dest, 0, sizeof(IPAddr ));
  dest->family = __bswap_16((__uint16_t )src->family);
  {
  if ((int )src->family == 1) {
    goto case_1;
  }
  if ((int )src->family == 2) {
    goto case_2;
  }
  if ((int )src->family == 3) {
    goto case_3;
  }
  goto switch_default;
  case_1:
  dest->addr.in4 = __bswap_32((__uint32_t )src->addr.in4);
  goto switch_break;
  case_2:
  memcpy((void *)(dest->addr.in6), (void const *)(src->addr.in6), sizeof(dest->addr.in6));
  goto switch_break;
  case_3:
  dest->addr.id = __bswap_32((__uint32_t )src->addr.id);
  goto switch_break;
  switch_default:
  dest->family = __bswap_16((__uint16_t )0);
  switch_break: ;
  }
  return;
}
}
void UTI_IPNetworkToHost(IPAddr const *src , IPAddr *dest )
{
  {
  dest->family = __bswap_16((__uint16_t )src->family);
  dest->_pad = (uint16_t )0;
  {
  if ((int )dest->family == 1) {
    goto case_1;
  }
  if ((int )dest->family == 2) {
    goto case_2;
  }
  if ((int )dest->family == 3) {
    goto case_3;
  }
  goto switch_default;
  case_1:
  dest->addr.in4 = __bswap_32((__uint32_t )src->addr.in4);
  goto switch_break;
  case_2:
  memcpy((void *)(dest->addr.in6), (void const *)(src->addr.in6), sizeof(dest->addr.in6));
  goto switch_break;
  case_3:
  dest->addr.id = __bswap_32((__uint32_t )src->addr.id);
  goto switch_break;
  switch_default:
  dest->family = (uint16_t )0;
  switch_break: ;
  }
  return;
}
}
int UTI_CompareIPs(IPAddr const *a , IPAddr const *b , IPAddr const *mask )
{
  int i ;
  int d ;
  {
  if ((int )a->family != (int )b->family) {
    return ((int )((int )a->family - (int )b->family));
  }
  if (mask) {
    if ((int )mask->family != (int )b->family) {
      mask = (IPAddr const *)((void *)0);
    }
  }
  {
  if ((int )a->family == 0) {
    goto case_0;
  }
  if ((int )a->family == 1) {
    goto case_1;
  }
  if ((int )a->family == 2) {
    goto case_2;
  }
  if ((int )a->family == 3) {
    goto case_3;
  }
  goto switch_break;
  case_0:
  return (0);
  case_1:
  if (mask) {
    return ((int )((a->addr.in4 & mask->addr.in4) - (b->addr.in4 & mask->addr.in4)));
  } else {
    return ((int )(a->addr.in4 - b->addr.in4));
  }
  case_2:
  i = 0;
  d = 0;
  {
  while (1) {
    while_continue: ;
    if (! d) {
      if (! (i < 16)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if (mask) {
      d = ((int )a->addr.in6[i] & (int )mask->addr.in6[i]) - ((int )b->addr.in6[i] & (int )mask->addr.in6[i]);
    } else {
      d = (int )a->addr.in6[i] - (int )b->addr.in6[i];
    }
    i ++;
  }
  while_break: ;
  }
  return (d);
  case_3:
  return ((int )(a->addr.id - b->addr.id));
  switch_break: ;
  }
  return (0);
}
}
char *UTI_IPSockAddrToString(IPSockAddr const *sa )
{
  char *result ;
  char *tmp ;
  char *tmp___0 ;
  {
  pool_ptr = (pool_ptr + 1) % 16;
  result = buffer_pool[pool_ptr];
  tmp = UTI_IPToString((IPAddr const *)(& sa->ip_addr));
  if ((int )sa->ip_addr.family != 2) {
    tmp___0 = "%s:%hu";
  } else {
    tmp___0 = "[%s]:%hu";
  }
  snprintf(result, (size_t )64, (char const *)tmp___0, tmp, (int )sa->port);
  return (result);
}
}
char *UTI_TimeToLogForm(time_t t )
{
  struct tm *stm ;
  char *result ;
  {
  pool_ptr = (pool_ptr + 1) % 16;
  result = buffer_pool[pool_ptr];
  stm = gmtime((time_t const *)(& t));
  if (stm) {
    strftime((char * __restrict )result, (size_t )64, (char const * __restrict )"%Y-%m-%d %H:%M:%S",
             (struct tm const * __restrict )stm);
  } else {
    snprintf(result, (size_t )64, (char const *)"INVALID    INVALID ");
  }
  return (result);
}
}
void UTI_AdjustTimespec(struct timespec const *old_ts , struct timespec const *when ,
                        struct timespec *new_ts , double *delta_time , double dfreq ,
                        double doffset )
{
  double elapsed ;
  {
  elapsed = UTI_DiffTimespecsToDouble(when, old_ts);
  *delta_time = elapsed * dfreq - doffset;
  UTI_AddDoubleToTimespec(old_ts, *delta_time, new_ts);
  return;
}
}
void UTI_GetNtp64Fuzz(NTP_int64 *ts , int precision )
{
  int start ;
  int bits ;
  int tmp ;
  uint32_t tmp___0 ;
  {
  if (precision >= -32) {
    if (precision <= 32) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  assert(tmp);
  assert(sizeof(*ts) == 8UL);
  start = (int )(sizeof(*ts) - (unsigned long )(((precision + 32) + 7) / 8));
  tmp___0 = (uint32_t )0;
  ts->lo = tmp___0;
  ts->hi = tmp___0;
  UTI_GetRandomBytes((void *)((unsigned char *)ts + start), (unsigned int )(sizeof(*ts) - (unsigned long )start));
  bits = (precision + 32) % 8;
  if (bits) {
    *((unsigned char *)ts + start) = (unsigned char )((unsigned int )*((unsigned char *)ts + start) % (1U << bits));
  }
  return;
}
}
double UTI_Ntp32ToDouble(NTP_int32 x )
{
  __uint32_t tmp ;
  {
  tmp = __bswap_32(x);
  return ((double )tmp / 65536.0);
}
}
NTP_int32 UTI_DoubleToNtp32(double x )
{
  NTP_int32 r ;
  __uint32_t tmp ;
  {
  if (x >= 4294967295.0 / 65536.0) {
    r = 0xffffffff;
  } else
  if (x <= 0.0) {
    r = (NTP_int32 )0;
  } else {
    x *= 65536.0;
    r = (NTP_int32 )x;
    if ((double )r < x) {
      r ++;
    }
  }
  tmp = __bswap_32(r);
  return (tmp);
}
}
double UTI_Ntp32f28ToDouble(NTP_int32 x )
{
  uint32_t r ;
  __uint32_t tmp ;
  {
  tmp = __bswap_32(x);
  r = tmp;
  if (r == 0xffffffff) {
    return (4294967295.0 / 65536.0);
  }
  return ((double )r / (double )(1U << 28));
}
}
NTP_int32 UTI_DoubleToNtp32f28(double x )
{
  NTP_int32 r ;
  __uint32_t tmp ;
  {
  if (x >= 4294967295.0 / (double )(1U << 28)) {
    r = 0xffffffff;
  } else
  if (x <= 0.0) {
    r = (NTP_int32 )0;
  } else {
    x *= (double )(1U << 28);
    r = (NTP_int32 )x;
    if ((double )r < x) {
      r ++;
    }
  }
  tmp = __bswap_32(r);
  return (tmp);
}
}
void UTI_ZeroNtp64(NTP_int64 *ts )
{
  uint32_t tmp ;
  {
  tmp = __bswap_32((__uint32_t )0);
  ts->lo = tmp;
  ts->hi = tmp;
  return;
}
}
int UTI_IsZeroNtp64(NTP_int64 const *ts )
{
  int tmp ;
  {
  if (! ts->hi) {
    if (! ts->lo) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
int UTI_CompareNtp64(NTP_int64 const *a , NTP_int64 const *b )
{
  int32_t diff ;
  __uint32_t tmp ;
  __uint32_t tmp___0 ;
  __uint32_t tmp___1 ;
  __uint32_t tmp___2 ;
  int tmp___3 ;
  __uint32_t tmp___4 ;
  __uint32_t tmp___5 ;
  {
  if (a->hi == b->hi) {
    if (a->lo == b->lo) {
      return (0);
    }
  }
  tmp = __bswap_32((__uint32_t )a->hi);
  tmp___0 = __bswap_32((__uint32_t )b->hi);
  diff = (int32_t )(tmp - tmp___0);
  if (diff < 0) {
    return (-1);
  }
  if (diff > 0) {
    return (1);
  }
  tmp___4 = __bswap_32((__uint32_t )a->lo);
  tmp___5 = __bswap_32((__uint32_t )b->lo);
  if (tmp___4 < tmp___5) {
    tmp___3 = -1;
  } else {
    tmp___3 = 1;
  }
  return (tmp___3);
}
}
int UTI_IsEqualAnyNtp64(NTP_int64 const *a , NTP_int64 const *b1 , NTP_int64 const *b2 ,
                        NTP_int64 const *b3 )
{
  {
  if (b1) {
    if (a->lo == b1->lo) {
      if (a->hi == b1->hi) {
        return (1);
      }
    }
  }
  if (b2) {
    if (a->lo == b2->lo) {
      if (a->hi == b2->hi) {
        return (1);
      }
    }
  }
  if (b3) {
    if (a->lo == b3->lo) {
      if (a->hi == b3->hi) {
        return (1);
      }
    }
  }
  return (0);
}
}
void UTI_TimespecToNtp64(struct timespec const *src , NTP_int64 *dest , NTP_int64 const *fuzz )
{
  uint32_t hi ;
  uint32_t lo ;
  uint32_t sec ;
  uint32_t nsec ;
  {
  sec = (uint32_t )src->tv_sec;
  nsec = (uint32_t )src->tv_nsec;
  if (! nsec) {
    if (! sec) {
      lo = (uint32_t )0;
      hi = lo;
    } else {
      goto _L;
    }
  } else {
    _L:
    hi = __bswap_32((__uint32_t )((unsigned long )sec + 0x83aa7e80UL));
    lo = __bswap_32((__uint32_t )(4.294967296 * (double )nsec));
    if (fuzz) {
      hi ^= (unsigned int )fuzz->hi;
      lo ^= (unsigned int )fuzz->lo;
    }
  }
  dest->hi = hi;
  dest->lo = lo;
  return;
}
}
void UTI_Ntp64ToTimespec(NTP_int64 const *src , struct timespec *dest )
{
  uint32_t ntp_sec ;
  uint32_t ntp_frac ;
  int tmp ;
  {
  tmp = UTI_IsZeroNtp64(src);
  if (tmp) {
    UTI_ZeroTimespec(dest);
    return;
  }
  ntp_sec = __bswap_32((__uint32_t )src->hi);
  ntp_frac = __bswap_32((__uint32_t )src->lo);
  dest->tv_sec = (time_t )(ntp_sec - 2281963035U) + 72974235L;
  dest->tv_nsec = (__syscall_slong_t )((double )ntp_frac / 4.294967296);
  return;
}
}
double UTI_DiffNtp64ToDouble(NTP_int64 const *a , NTP_int64 const *b )
{
  __uint32_t tmp ;
  __uint32_t tmp___0 ;
  __uint32_t tmp___1 ;
  __uint32_t tmp___2 ;
  {
  tmp = __bswap_32((__uint32_t )a->hi);
  tmp___0 = __bswap_32((__uint32_t )b->hi);
  tmp___1 = __bswap_32((__uint32_t )a->lo);
  tmp___2 = __bswap_32((__uint32_t )b->lo);
  return ((double )((int32_t )(tmp - tmp___0)) + ((double )tmp___1 - (double )tmp___2) / (1.0e9 * 4.294967296));
}
}
int UTI_IsTimeOffsetSane(struct timespec const *ts , double offset )
{
  double t ;
  double tmp ;
  {
  if (offset > - 4294967296.0) {
    if (! (offset < 4294967296.0)) {
      return (0);
    }
  } else {
    return (0);
  }
  tmp = UTI_TimespecToDouble(ts);
  t = tmp + offset;
  if (t < 0.0) {
    return (0);
  }
  if (t < (double )72974235LL) {
    return (0);
  } else
  if (t > (double )(72974235LL + (1LL << 32))) {
    return (0);
  }
  return (1);
}
}
double UTI_Log2ToDouble(int l )
{
  {
  if (l >= 0) {
    if (l > 31) {
      l = 31;
    }
    return ((double )(1U << l));
  } else {
    if (l < -31) {
      l = -31;
    }
    return (1.0 / (double )(1U << - l));
  }
}
}
void UTI_TimespecNetworkToHost(Timespec const *src , struct timespec *dest )
{
  uint32_t sec_low ;
  uint32_t nsec ;
  uint32_t sec_high ;
  {
  sec_low = __bswap_32((__uint32_t )src->tv_sec_low);
  sec_high = __bswap_32((__uint32_t )src->tv_sec_high);
  if (sec_high == 2147483647U) {
    sec_high = (uint32_t )0;
  }
  dest->tv_sec = (__time_t )(((uint64_t )sec_high << 32) | (unsigned long )sec_low);
  nsec = __bswap_32((__uint32_t )src->tv_nsec);
  if (nsec < 999999999U) {
    dest->tv_nsec = (__syscall_slong_t )nsec;
  } else {
    dest->tv_nsec = (__syscall_slong_t )999999999U;
  }
  return;
}
}
void UTI_TimespecHostToNetwork(struct timespec const *src , Timespec *dest )
{
  {
  dest->tv_nsec = __bswap_32((__uint32_t )src->tv_nsec);
  dest->tv_sec_high = __bswap_32((__uint32_t )((uint64_t )src->tv_sec >> 32));
  dest->tv_sec_low = __bswap_32((__uint32_t )src->tv_sec);
  return;
}
}
double UTI_FloatNetworkToHost(Float f )
{
  int32_t exp___0 ;
  int32_t coef ;
  uint32_t x ;
  double tmp ;
  {
  x = __bswap_32((__uint32_t )f.f);
  exp___0 = (int32_t )(x >> ((int )sizeof(int32_t ) * 8 - 7));
  if (exp___0 >= 1 << 6) {
    exp___0 -= 1 << 7;
  }
  exp___0 -= (int )sizeof(int32_t ) * 8 - 7;
  coef = (int32_t )(x % (1U << ((int )sizeof(int32_t ) * 8 - 7)));
  if (coef >= 1 << (((int )sizeof(int32_t ) * 8 - 7) - 1)) {
    coef -= 1 << ((int )sizeof(int32_t ) * 8 - 7);
  }
  tmp = pow(2.0, (double )exp___0);
  return ((double )coef * tmp);
}
}
Float UTI_FloatHostToNetwork(double x )
{
  int32_t exp___0 ;
  int32_t coef ;
  int32_t neg ;
  Float f ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  __uint32_t tmp___2 ;
  {
  if (x < 0.0) {
    x = - x;
    neg = 1;
  } else
  if (x >= 0.0) {
    neg = 0;
  } else {
    x = 0.0;
    neg = 0;
  }
  if (x < 1.0e-100) {
    coef = 0;
    exp___0 = coef;
  } else
  if (x > 1.0e100) {
    exp___0 = - (- (1 << 6)) - 1;
    coef = (- (- (1 << (((int )sizeof(int32_t ) * 8 - 7) - 1))) - 1) + neg;
  } else {
    tmp = log(x);
    tmp___0 = log((double )2);
    exp___0 = (int32_t )(tmp / tmp___0 + (double )1);
    tmp___1 = pow(2.0, (double )(- exp___0 + ((int )sizeof(int32_t ) * 8 - 7)));
    coef = (int32_t )(x * tmp___1 + 0.5);
    assert(coef > 0);
    {
    while (1) {
      while_continue: ;
      if (! (coef > (- (- (1 << (((int )sizeof(int32_t ) * 8 - 7) - 1))) - 1) + neg)) {
        goto while_break;
      }
      coef >>= 1;
      exp___0 ++;
    }
    while_break: ;
    }
    if (exp___0 > - (- (1 << 6)) - 1) {
      exp___0 = - (- (1 << 6)) - 1;
      coef = (- (- (1 << (((int )sizeof(int32_t ) * 8 - 7) - 1))) - 1) + neg;
    } else
    if (exp___0 < - (1 << 6)) {
      if (exp___0 + ((int )sizeof(int32_t ) * 8 - 7) >= - (1 << 6)) {
        coef >>= - (1 << 6) - exp___0;
        exp___0 = - (1 << 6);
      } else {
        coef = 0;
        exp___0 = coef;
      }
    }
  }
  if (neg) {
    coef = (int32_t )(((uint32_t )(- coef) << 7) >> 7);
  }
  tmp___2 = __bswap_32(((uint32_t )exp___0 << ((int )sizeof(int32_t ) * 8 - 7)) | (unsigned int )coef);
  f.f = (int32_t )tmp___2;
  return (f);
}
}
CMC_Algorithm UTI_CmacNameToAlgorithm(char const *name )
{
  int tmp ;
  int tmp___0 ;
  {
  tmp___0 = strcmp(name, (char const *)"AES128");
  if (tmp___0 == 0) {
    return ((CMC_Algorithm )13);
  } else {
    tmp = strcmp(name, (char const *)"AES256");
    if (tmp == 0) {
      return ((CMC_Algorithm )14);
    }
  }
  return ((CMC_Algorithm )0);
}
}
HSH_Algorithm UTI_HashNameToAlgorithm(char const *name )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  {
  tmp___9 = strcmp(name, (char const *)"MD5");
  if (tmp___9 == 0) {
    return ((HSH_Algorithm )1);
  } else {
    tmp___8 = strcmp(name, (char const *)"SHA1");
    if (tmp___8 == 0) {
      return ((HSH_Algorithm )2);
    } else {
      tmp___7 = strcmp(name, (char const *)"SHA256");
      if (tmp___7 == 0) {
        return ((HSH_Algorithm )3);
      } else {
        tmp___6 = strcmp(name, (char const *)"SHA384");
        if (tmp___6 == 0) {
          return ((HSH_Algorithm )4);
        } else {
          tmp___5 = strcmp(name, (char const *)"SHA512");
          if (tmp___5 == 0) {
            return ((HSH_Algorithm )5);
          } else {
            tmp___4 = strcmp(name, (char const *)"SHA3-224");
            if (tmp___4 == 0) {
              return ((HSH_Algorithm )6);
            } else {
              tmp___3 = strcmp(name, (char const *)"SHA3-256");
              if (tmp___3 == 0) {
                return ((HSH_Algorithm )7);
              } else {
                tmp___2 = strcmp(name, (char const *)"SHA3-384");
                if (tmp___2 == 0) {
                  return ((HSH_Algorithm )8);
                } else {
                  tmp___1 = strcmp(name, (char const *)"SHA3-512");
                  if (tmp___1 == 0) {
                    return ((HSH_Algorithm )9);
                  } else {
                    tmp___0 = strcmp(name, (char const *)"TIGER");
                    if (tmp___0 == 0) {
                      return ((HSH_Algorithm )10);
                    } else {
                      tmp = strcmp(name, (char const *)"WHIRLPOOL");
                      if (tmp == 0) {
                        return ((HSH_Algorithm )11);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return ((HSH_Algorithm )0);
}
}
int UTI_FdSetCloexec(int fd___0 )
{
  int flags ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  {
  flags = fcntl(fd___0, 1);
  if (flags == -1) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  flags |= 1;
  tmp___3 = fcntl(fd___0, 2, flags);
  if (tmp___3 < 0) {
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
    return (0);
  }
  return (1);
}
}
void UTI_SetQuitSignalsHandler(void (*handler)(int ) , int ignore_sigpipe )
{
  struct sigaction sa ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  {
  sa.__sigaction_handler.sa_handler = handler;
  sa.sa_flags = 0x10000000;
  tmp = sigemptyset(& sa.sa_mask);
  if (tmp < 0) {
    {
    while (1) {
      while_continue: ;
      LOG_Message((LOG_Severity )3, (char const *)"sigemptyset() failed");
      exit(1);
      goto while_break;
    }
    while_break: ;
    }
  }
  tmp___0 = sigaction(2, (struct sigaction const * __restrict )(& sa), (struct sigaction * __restrict )((void *)0));
  if (tmp___0 < 0) {
    {
    while (1) {
      while_continue___0: ;
      LOG_Message((LOG_Severity )3, (char const *)"sigaction(%d) failed", 2);
      exit(1);
      goto while_break___0;
    }
    while_break___0: ;
    }
  }
  tmp___1 = sigaction(15, (struct sigaction const * __restrict )(& sa), (struct sigaction * __restrict )((void *)0));
  if (tmp___1 < 0) {
    {
    while (1) {
      while_continue___1: ;
      LOG_Message((LOG_Severity )3, (char const *)"sigaction(%d) failed", 15);
      exit(1);
      goto while_break___1;
    }
    while_break___1: ;
    }
  }
  tmp___2 = sigaction(3, (struct sigaction const * __restrict )(& sa), (struct sigaction * __restrict )((void *)0));
  if (tmp___2 < 0) {
    {
    while (1) {
      while_continue___2: ;
      LOG_Message((LOG_Severity )3, (char const *)"sigaction(%d) failed", 3);
      exit(1);
      goto while_break___2;
    }
    while_break___2: ;
    }
  }
  tmp___3 = sigaction(1, (struct sigaction const * __restrict )(& sa), (struct sigaction * __restrict )((void *)0));
  if (tmp___3 < 0) {
    {
    while (1) {
      while_continue___3: ;
      LOG_Message((LOG_Severity )3, (char const *)"sigaction(%d) failed", 1);
      exit(1);
      goto while_break___3;
    }
    while_break___3: ;
    }
  }
  if (ignore_sigpipe) {
    sa.__sigaction_handler.sa_handler = (void (*)(int ))1;
  }
  tmp___4 = sigaction(13, (struct sigaction const * __restrict )(& sa), (struct sigaction * __restrict )((void *)0));
  if (tmp___4 < 0) {
    {
    while (1) {
      while_continue___4: ;
      LOG_Message((LOG_Severity )3, (char const *)"sigaction(%d) failed", 13);
      exit(1);
      goto while_break___4;
    }
    while_break___4: ;
    }
  }
  return;
}
}
char *UTI_PathToDir(char const *path )
{
  char *dir ;
  char *slash ;
  size_t dir_len ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  {
  slash = strrchr(path, '/');
  if (! slash) {
    tmp = Strdup((char const *)".");
    return (tmp);
  }
  if ((unsigned long )slash == (unsigned long )path) {
    tmp___0 = Strdup((char const *)"/");
    return (tmp___0);
  }
  dir_len = (size_t )(slash - (char *)path);
  tmp___1 = Malloc(dir_len + 1UL);
  dir = (char *)tmp___1;
  memcpy((void *)dir, (void const *)path, dir_len);
  *(dir + dir_len) = (char )'\000';
  return (dir);
}
}
static int create_dir(char *p , mode_t mode___0 , uid_t uid , gid_t gid )
{
  int status ;
  struct stat buf ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  {
  status = stat((char const * __restrict )p, (struct stat * __restrict )(& buf));
  if (status < 0) {
    tmp___1 = __errno_location();
    if (*tmp___1 != 2) {
      tmp = __errno_location();
      tmp___0 = strerror(*tmp);
      LOG_Message((LOG_Severity )2, (char const *)"Could not access %s : %s", p,
                  tmp___0);
      return (0);
    }
  } else {
    if ((buf.st_mode & 61440U) == 16384U) {
      return (1);
    }
    LOG_Message((LOG_Severity )2, (char const *)"%s is not directory", p);
    return (0);
  }
  tmp___4 = mkdir((char const *)p, mode___0);
  if (tmp___4 < 0) {
    tmp___2 = __errno_location();
    tmp___3 = strerror(*tmp___2);
    LOG_Message((LOG_Severity )2, (char const *)"Could not create directory %s : %s",
                p, tmp___3);
    return (0);
  }
  tmp___7 = chown((char const *)p, uid, gid);
  if (tmp___7 < 0) {
    tmp___5 = __errno_location();
    tmp___6 = strerror(*tmp___5);
    LOG_Message((LOG_Severity )2, (char const *)"Could not change ownership of %s : %s",
                p, tmp___6);
    rmdir((char const *)p);
    return (0);
  }
  return (1);
}
}
int UTI_CreateDirAndParents(char const *path , mode_t mode___0 , uid_t uid , gid_t gid )
{
  char *p ;
  int i ;
  int j ;
  int k ;
  int last ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  gid_t tmp___4 ;
  uid_t tmp___5 ;
  mode_t tmp___6 ;
  int tmp___7 ;
  {
  tmp = strcmp(path, (char const *)".");
  if (! tmp) {
    return (1);
  }
  tmp___0 = strlen(path);
  tmp___1 = Malloc(1UL + tmp___0);
  p = (char *)tmp___1;
  k = 0;
  i = k;
  {
  while (1) {
    while_continue: ;
    tmp___2 = i;
    i ++;
    tmp___3 = k;
    k ++;
    *(p + tmp___2) = (char )*(path + tmp___3);
    if ((int const )*(path + k) == 47) {
      goto _L;
    } else
    if (! *(path + k)) {
      _L:
      last = 1;
      j = k;
      {
      while (1) {
        while_continue___0: ;
        if (! *(path + j)) {
          goto while_break___0;
        }
        if ((int const )*(path + j) != 47) {
          k = j - 1;
          last = 0;
          goto while_break___0;
        }
        j ++;
      }
      while_break___0: ;
      }
      *(p + i) = (char)0;
      if (last) {
        tmp___4 = gid;
      } else {
        tmp___4 = (gid_t )0;
      }
      if (last) {
        tmp___5 = uid;
      } else {
        tmp___5 = (uid_t )0;
      }
      if (last) {
        tmp___6 = mode___0;
      } else {
        tmp___6 = (mode_t )0755;
      }
      tmp___7 = create_dir(p, tmp___6, tmp___5, tmp___4);
      if (! tmp___7) {
        free((void *)p);
        return (0);
      }
      if (last) {
        goto while_break;
      }
    }
    if (! *(path + k)) {
      goto while_break;
    }
  }
  while_break: ;
  }
  free((void *)p);
  return (1);
}
}
int UTI_CheckDirPermissions(char const *path , mode_t perm , uid_t uid , gid_t gid )
{
  struct stat buf ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  {
  tmp___1 = stat((char const * __restrict )path, (struct stat * __restrict )(& buf));
  if (tmp___1) {
    tmp = __errno_location();
    tmp___0 = strerror(*tmp);
    LOG_Message((LOG_Severity )2, (char const *)"Could not access %s : %s", path,
                tmp___0);
    return (0);
  }
  if (! ((buf.st_mode & 61440U) == 16384U)) {
    LOG_Message((LOG_Severity )2, (char const *)"%s is not directory", path);
    return (0);
  }
  if ((buf.st_mode & 511U) & ~ perm) {
    LOG_Message((LOG_Severity )2, (char const *)"Wrong permissions on %s", path);
    return (0);
  }
  if (buf.st_uid != uid) {
    LOG_Message((LOG_Severity )2, (char const *)"Wrong owner of %s (%s != %u)",
                path, "UID", uid);
    return (0);
  }
  if (buf.st_gid != gid) {
    LOG_Message((LOG_Severity )2, (char const *)"Wrong owner of %s (%s != %u)",
                path, "GID", gid);
    return (0);
  }
  return (1);
}
}
static int join_path(char const *basedir , char const *name , char const *suffix ,
                     char *buffer , size_t length , LOG_Severity severity )
{
  char const *sep ;
  int tmp ;
  {
  if (! basedir) {
    basedir = (char const *)"";
    sep = (char const *)"";
  } else {
    sep = (char const *)"/";
  }
  if (! suffix) {
    suffix = (char const *)"";
  }
  tmp = snprintf(buffer, length, (char const *)"%s%s%s%s", basedir, sep, name, suffix);
  if ((size_t )tmp >= length) {
    LOG_Message(severity, (char const *)"File path %s%s%s%s too long", basedir,
                sep, name, suffix);
    return (0);
  }
  return (1);
}
}
FILE *UTI_OpenFile(char const *basedir , char const *name , char const *suffix ,
                   char mode___0 , mode_t perm )
{
  char const *file_mode ;
  char path[4096] ;
  LOG_Severity severity ;
  int fd___0 ;
  int flags ;
  FILE *file ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  {
  if ((int )mode___0 >= 65) {
    if ((int )mode___0 <= 90) {
      severity = (LOG_Severity )3;
    } else {
      severity = (LOG_Severity )2;
    }
  } else {
    severity = (LOG_Severity )2;
  }
  tmp = join_path(basedir, name, suffix, path, sizeof(path), severity);
  if (! tmp) {
    return ((FILE *)((void *)0));
  }
  {
  if ((int )mode___0 == 82) {
    goto case_82;
  }
  if ((int )mode___0 == 114) {
    goto case_82;
  }
  if ((int )mode___0 == 87) {
    goto case_87;
  }
  if ((int )mode___0 == 119) {
    goto case_87;
  }
  if ((int )mode___0 == 65) {
    goto case_65;
  }
  if ((int )mode___0 == 97) {
    goto case_65;
  }
  goto switch_default;
  case_82:
  case_114:
  flags = 00;
  file_mode = (char const *)"r";
  if ((int )severity != 3) {
    severity = (LOG_Severity )-1;
  }
  goto switch_break;
  case_87:
  case_119:
  flags = 193;
  file_mode = (char const *)"w";
  goto switch_break;
  case_65:
  case_97:
  flags = 132161;
  file_mode = (char const *)"a";
  goto switch_break;
  switch_default:
  assert(0);
  return ((FILE *)((void *)0));
  switch_break: ;
  }
  try_again:
  fd___0 = open((char const *)(path), flags, perm);
  if (fd___0 < 0) {
    tmp___3 = __errno_location();
    if (*tmp___3 == 17) {
      tmp___2 = unlink((char const *)(path));
      if (tmp___2 < 0) {
        tmp___0 = __errno_location();
        tmp___1 = strerror(*tmp___0);
        LOG_Message(severity, (char const *)"Could not remove %s : %s", path, tmp___1);
        return ((FILE *)((void *)0));
      }
      {
      while (1) {
        while_continue: ;
        goto while_break;
      }
      while_break: ;
      }
      goto try_again;
    }
    tmp___4 = __errno_location();
    tmp___5 = strerror(*tmp___4);
    LOG_Message(severity, (char const *)"Could not open %s : %s", path, tmp___5);
    return ((FILE *)((void *)0));
  }
  UTI_FdSetCloexec(fd___0);
  file = fdopen(fd___0, file_mode);
  if (! file) {
    tmp___6 = __errno_location();
    tmp___7 = strerror(*tmp___6);
    LOG_Message(severity, (char const *)"Could not open %s : %s", path, tmp___7);
    close(fd___0);
    return ((FILE *)((void *)0));
  }
  {
  while (1) {
    while_continue___0: ;
    goto while_break___0;
  }
  while_break___0: ;
  }
  return (file);
}
}
int UTI_RenameTempFile(char const *basedir , char const *name , char const *old_suffix ,
                       char const *new_suffix )
{
  char old_path[4096] ;
  char new_path[4096] ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  {
  tmp = join_path(basedir, name, old_suffix, old_path, sizeof(old_path), (LOG_Severity )2);
  if (! tmp) {
    return (0);
  }
  tmp___0 = join_path(basedir, name, new_suffix, new_path, sizeof(new_path), (LOG_Severity )2);
  if (! tmp___0) {
    goto error;
  }
  tmp___3 = rename((char const *)(old_path), (char const *)(new_path));
  if (tmp___3 < 0) {
    tmp___1 = __errno_location();
    tmp___2 = strerror(*tmp___1);
    LOG_Message((LOG_Severity )2, (char const *)"Could not replace %s with %s : %s",
                new_path, old_path, tmp___2);
    goto error;
  }
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  return (1);
  error:
  tmp___6 = unlink((char const *)(old_path));
  if (tmp___6 < 0) {
    tmp___4 = __errno_location();
    tmp___5 = strerror(*tmp___4);
    LOG_Message((LOG_Severity )2, (char const *)"Could not remove %s : %s", old_path,
                tmp___5);
  }
  return (0);
}
}
int UTI_RemoveFile(char const *basedir , char const *name , char const *suffix )
{
  char path[4096] ;
  struct stat buf ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  {
  tmp = join_path(basedir, name, suffix, path, sizeof(path), (LOG_Severity )2);
  if (! tmp) {
    return (0);
  }
  tmp___2 = stat((char const * __restrict )(path), (struct stat * __restrict )(& buf));
  if (tmp___2 < 0) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  tmp___5 = unlink((char const *)(path));
  if (tmp___5 < 0) {
    tmp___3 = __errno_location();
    tmp___4 = strerror(*tmp___3);
    LOG_Message((LOG_Severity )2, (char const *)"Could not remove %s : %s", path,
                tmp___4);
    return (0);
  }
  {
  while (1) {
    while_continue___0: ;
    goto while_break___0;
  }
  while_break___0: ;
  }
  return (1);
}
}
void UTI_DropRoot(uid_t uid , gid_t gid )
{
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  {
  tmp___1 = setgroups((size_t )0, (__gid_t const *)((void *)0));
  if (tmp___1) {
    {
    while (1) {
      while_continue: ;
      tmp = __errno_location();
      tmp___0 = strerror(*tmp);
      LOG_Message((LOG_Severity )3, (char const *)"setgroups() failed : %s", tmp___0);
      exit(1);
      goto while_break;
    }
    while_break: ;
    }
  }
  tmp___4 = setgid(gid);
  if (tmp___4) {
    {
    while (1) {
      while_continue___0: ;
      tmp___2 = __errno_location();
      tmp___3 = strerror(*tmp___2);
      LOG_Message((LOG_Severity )3, (char const *)"setgid(%u) failed : %s", gid,
                  tmp___3);
      exit(1);
      goto while_break___0;
    }
    while_break___0: ;
    }
  }
  tmp___7 = setuid(uid);
  if (tmp___7) {
    {
    while (1) {
      while_continue___1: ;
      tmp___5 = __errno_location();
      tmp___6 = strerror(*tmp___5);
      LOG_Message((LOG_Severity )3, (char const *)"setuid(%u) failed : %s", uid,
                  tmp___6);
      exit(1);
      goto while_break___1;
    }
    while_break___1: ;
    }
  }
  {
  while (1) {
    while_continue___2: ;
    goto while_break___2;
  }
  while_break___2: ;
  }
  return;
}
}
static FILE *urandom_file = (FILE *)((void *)0);
void UTI_GetRandomBytesUrandom(void *buf , unsigned int len )
{
  size_t tmp ;
  {
  if (! urandom_file) {
    urandom_file = UTI_OpenFile((char const *)((void *)0), (char const *)"/dev/urandom",
                                (char const *)((void *)0), (char )'R', (mode_t )0);
  }
  tmp = fread(buf, (size_t )1, (size_t )len, urandom_file);
  if (tmp != (size_t )len) {
    {
    while (1) {
      while_continue: ;
      LOG_Message((LOG_Severity )3, (char const *)"Can\'t read from %s", "/dev/urandom");
      exit(1);
      goto while_break;
    }
    while_break: ;
    }
  }
  return;
}
}
static unsigned int getrandom_buf_available = 0U;
static char rand_buf[256] ;
static void get_random_bytes_getrandom(char *buf , unsigned int len ) ;
static unsigned int disabled = 0U;
static void get_random_bytes_getrandom(char *buf , unsigned int len )
{
  unsigned int i ;
  ssize_t tmp ;
  {
  i = 0U;
  {
  while (1) {
    while_continue: ;
    if (! (i < len)) {
      goto while_break;
    }
    if (getrandom_buf_available == 0U) {
      if (disabled) {
        goto while_break;
      }
      tmp = getrandom((void *)(rand_buf), sizeof(rand_buf), 1U);
      if ((unsigned long )tmp != sizeof(rand_buf)) {
        disabled = 1U;
        goto while_break;
      }
      getrandom_buf_available = (unsigned int )sizeof(rand_buf);
    }
    getrandom_buf_available --;
    *(buf + i) = rand_buf[getrandom_buf_available];
    i ++;
  }
  while_break: ;
  }
  if (i < len) {
    UTI_GetRandomBytesUrandom((void *)buf, len);
  }
  return;
}
}
void UTI_GetRandomBytes(void *buf , unsigned int len )
{
  {
  get_random_bytes_getrandom((char *)buf, len);
  return;
}
}
void UTI_ResetGetRandomFunctions(void)
{
  {
  if (urandom_file) {
    fclose(urandom_file);
    urandom_file = (FILE *)((void *)0);
  }
  getrandom_buf_available = 0U;
  return;
}
}
int UTI_BytesToHex(void const *buf , unsigned int buf_len , char *hex , unsigned int hex_len )
{
  unsigned int i ;
  unsigned int l ;
  int tmp ;
  {
  if (hex_len < 1U) {
    return (0);
  }
  *(hex + 0) = (char )'\000';
  l = 0U;
  i = l;
  {
  while (1) {
    while_continue: ;
    if (! (i < buf_len)) {
      goto while_break;
    }
    if (l + 2U >= hex_len) {
      return (0);
    } else {
      tmp = snprintf(hex + l, (size_t )(hex_len - l), (char const *)"%02hhX", (int const )*((char const *)buf + i));
      if (tmp != 2) {
        return (0);
      }
    }
    i ++;
    l += 2U;
  }
  while_break: ;
  }
  return (1);
}
}
unsigned int UTI_HexToBytes(char const *hex , void *buf , unsigned int len )
{
  char *p ;
  char byte[3] ;
  unsigned int i ;
  char const *tmp ;
  char const *tmp___0 ;
  long tmp___1 ;
  unsigned int tmp___2 ;
  {
  i = 0U;
  {
  while (1) {
    while_continue: ;
    if (i < len) {
      if (! ((int const )*hex != 0)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    tmp = hex;
    hex ++;
    byte[0] = (char )*tmp;
    if ((int const )*hex == 0) {
      return (0U);
    }
    tmp___0 = hex;
    hex ++;
    byte[1] = (char )*tmp___0;
    byte[2] = (char )'\000';
    tmp___1 = strtol((char const * __restrict )(byte), (char ** __restrict )(& p),
                     16);
    *((char *)buf + i) = (char )tmp___1;
    if ((unsigned long )p != (unsigned long )(byte + 2)) {
      return (0U);
    }
    i ++;
  }
  while_break: ;
  }
  if ((int const )*hex == 0) {
    tmp___2 = i;
  } else {
    tmp___2 = 0U;
  }
  return (tmp___2);
}
}
int UTI_SplitString(char *string , char **words , int max_saved_words )
{
  char *s ;
  int i ;
  char *tmp ;
  unsigned short const **tmp___0 ;
  unsigned short const **tmp___1 ;
  {
  s = string;
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < max_saved_words)) {
      goto while_break;
    }
    *(words + i) = (char *)((void *)0);
    i ++;
  }
  while_break: ;
  }
  i = 0;
  {
  while (1) {
    while_continue___0: ;
    {
    while (1) {
      while_continue___1: ;
      if ((int )*s != 0) {
        tmp___0 = __ctype_b_loc();
        if (! ((int const )*(*tmp___0 + (int )((unsigned char )*s)) & 8192)) {
          goto while_break___1;
        }
      } else {
        goto while_break___1;
      }
      tmp = s;
      s ++;
      *tmp = (char )'\000';
    }
    while_break___1: ;
    }
    if ((int )*s == 0) {
      goto while_break___0;
    }
    if (i < max_saved_words) {
      *(words + i) = s;
    }
    {
    while (1) {
      while_continue___2: ;
      if ((int )*s != 0) {
        tmp___1 = __ctype_b_loc();
        if ((int const )*(*tmp___1 + (int )((unsigned char )*s)) & 8192) {
          goto while_break___2;
        }
      } else {
        goto while_break___2;
      }
      s ++;
    }
    while_break___2: ;
    }
    i ++;
  }
  while_break___0: ;
  }
  return (i);
}
}
void SYS_Generic_CompleteFreqDriver(double max_set_freq_ppm , double max_set_freq_delay ,
                                    double (*sys_read_freq)(void) , double (*sys_set_freq)(double freq_ppm ) ,
                                    int (*sys_apply_step_offset)(double offset ) ,
                                    double min_fastslew_offset , double max_fastslew_rate ,
                                    void (*sys_accrue_offset)(double offset , double corr_rate ) ,
                                    void (*sys_get_offset_correction)(struct timespec *raw ,
                                                                      double *corr ,
                                                                      double *err ) ,
                                    void (*sys_set_leap)(int leap , int tai_offset ) ,
                                    void (*sys_set_sync_status)(int synchronised ,
                                                                double est_error ,
                                                                double max_error ) ) ;
void SYS_Generic_Finalise(void) ;
static double (*drv_read_freq___0)(void) ;
static double (*drv_set_freq___0)(double freq_ppm ) ;
static void (*drv_set_sync_status___0)(int synchronised , double est_error , double max_error ) ;
static void (*drv_accrue_offset___0)(double offset , double corr_rate ) ;
static void (*drv_get_offset_correction)(struct timespec *raw , double *corr , double *err ) ;
static double base_freq ;
static double max_freq___0 ;
static double max_freq_change_delay ;
static double max_corr_freq ;
static double offset_register___0 ;
static double slew_freq ;
static struct timespec slew_start ;
static SCH_TimeoutID slew_timeout_id ;
static double correction_rate ;
static double slew_error ;
static double fastslew_min_offset ;
static double fastslew_max_rate ;
static int fastslew_active ;
static void handle_end_of_slew(void *anything ) ;
static void update_slew(void) ;
static void handle_step(struct timespec *raw , struct timespec *cooked , double dfreq ,
                        double doffset , LCL_ChangeType change_type , void *anything )
{
  {
  if ((unsigned int )change_type == 2U) {
    slew_start = *raw;
    offset_register___0 = 0.0;
    update_slew();
  } else
  if ((unsigned int )change_type == 1U) {
    UTI_AddDoubleToTimespec((struct timespec const *)(& slew_start), - doffset,
                            & slew_start);
  }
  return;
}
}
static void start_fastslew(void)
{
  {
  if (! drv_accrue_offset___0) {
    return;
  }
  (*drv_accrue_offset___0)(offset_register___0, 0.0);
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  offset_register___0 = 0.0;
  fastslew_active = 1;
  return;
}
}
static void stop_fastslew(struct timespec *now )
{
  double corr ;
  {
  if (! drv_get_offset_correction) {
    return;
  } else
  if (! fastslew_active) {
    return;
  }
  (*drv_get_offset_correction)(now, & corr, (double *)((void *)0));
  (*drv_accrue_offset___0)(corr, 0.0);
  offset_register___0 -= corr;
  return;
}
}
static double clamp_freq___0(double freq___0 )
{
  {
  if (freq___0 > max_freq___0) {
    return (max_freq___0);
  }
  if (freq___0 < - max_freq___0) {
    return (- max_freq___0);
  }
  return (freq___0);
}
}
static void update_slew(void)
{
  struct timespec now ;
  struct timespec end_of_slew ;
  double old_slew_freq ;
  double total_freq ;
  double corr_freq ;
  double duration ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  {
  SCH_RemoveTimeout(slew_timeout_id);
  LCL_ReadRawTime(& now);
  duration = UTI_DiffTimespecsToDouble((struct timespec const *)(& now), (struct timespec const *)(& slew_start));
  offset_register___0 -= slew_freq * duration;
  stop_fastslew(& now);
  tmp___0 = fabs(offset_register___0);
  if (tmp___0 < 1.0e-9) {
    duration = 1.0e4;
  } else {
    tmp = fabs(offset_register___0);
    duration = correction_rate / tmp;
    if (duration < 1.0) {
      duration = 1.0;
    }
  }
  corr_freq = offset_register___0 / duration;
  if (corr_freq < - max_corr_freq) {
    corr_freq = - max_corr_freq;
  } else
  if (corr_freq > max_corr_freq) {
    corr_freq = max_corr_freq;
  }
  if (drv_accrue_offset___0) {
    tmp___1 = fabs(corr_freq);
    if (tmp___1 >= fastslew_max_rate) {
      tmp___2 = fabs(offset_register___0);
      if (tmp___2 > fastslew_min_offset) {
        start_fastslew();
        corr_freq = 0.0;
      }
    }
  }
  total_freq = clamp_freq___0(base_freq + corr_freq * (1.0e6 - base_freq));
  total_freq = (*drv_set_freq___0)(total_freq);
  old_slew_freq = slew_freq;
  slew_freq = (total_freq - base_freq) / (1.0e6 - total_freq);
  slew_error = fabs((old_slew_freq - slew_freq) * max_freq_change_delay);
  if (slew_error >= 1.0e-9) {
    lcl_InvokeDispersionNotifyHandlers(slew_error);
  }
  tmp___3 = fabs(offset_register___0);
  if (tmp___3 < 1.0e-9) {
    duration = 1.0e4;
  } else
  if (offset_register___0 * slew_freq <= 0.0) {
    duration = 1.0e4;
  } else {
    duration = offset_register___0 / slew_freq;
    if (duration < 1.0) {
      duration = 1.0;
    } else
    if (duration > 1.0e4) {
      duration = 1.0e4;
    }
  }
  UTI_AddDoubleToTimespec((struct timespec const *)(& now), duration, & end_of_slew);
  slew_timeout_id = SCH_AddTimeout(& end_of_slew, & handle_end_of_slew, (void *)0);
  slew_start = now;
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  return;
}
}
static void handle_end_of_slew(void *anything )
{
  {
  slew_timeout_id = (SCH_TimeoutID )0;
  update_slew();
  return;
}
}
static double read_frequency___0(void)
{
  {
  return (base_freq);
}
}
static double set_frequency___0(double freq_ppm )
{
  {
  base_freq = freq_ppm;
  update_slew();
  return (base_freq);
}
}
static void accrue_offset___0(double offset , double corr_rate )
{
  {
  offset_register___0 += offset;
  correction_rate = corr_rate;
  update_slew();
  return;
}
}
static void offset_convert___0(struct timespec *raw , double *corr , double *err )
{
  double duration ;
  double fastslew_corr ;
  double fastslew_err ;
  double tmp ;
  {
  duration = UTI_DiffTimespecsToDouble((struct timespec const *)raw, (struct timespec const *)(& slew_start));
  if (drv_get_offset_correction) {
    if (fastslew_active) {
      (*drv_get_offset_correction)(raw, & fastslew_corr, & fastslew_err);
      if (fastslew_corr == 0.0) {
        if (fastslew_err == 0.0) {
          fastslew_active = 0;
        }
      }
    } else {
      fastslew_err = 0.0;
      fastslew_corr = fastslew_err;
    }
  } else {
    fastslew_err = 0.0;
    fastslew_corr = fastslew_err;
  }
  *corr = (slew_freq * duration + fastslew_corr) - offset_register___0;
  if (err) {
    *err = fastslew_err;
    tmp = fabs(duration);
    if (tmp <= max_freq_change_delay) {
      *err += slew_error;
    }
  }
  return;
}
}
static int apply_step_offset___0(double offset )
{
  struct timespec old_time ;
  struct timespec new_time ;
  struct timeval new_time_tv ;
  double err ;
  int tmp ;
  double tmp___0 ;
  {
  LCL_ReadRawTime(& old_time);
  UTI_AddDoubleToTimespec((struct timespec const *)(& old_time), - offset, & new_time);
  UTI_TimespecToTimeval((struct timespec const *)(& new_time), & new_time_tv);
  tmp = settimeofday((struct timeval const *)(& new_time_tv), (struct timezone const *)((void *)0));
  if (tmp < 0) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  LCL_ReadRawTime(& old_time);
  err = UTI_DiffTimespecsToDouble((struct timespec const *)(& old_time), (struct timespec const *)(& new_time));
  tmp___0 = fabs(err);
  lcl_InvokeDispersionNotifyHandlers(tmp___0);
  return (1);
}
}
static void set_sync_status(int synchronised , double est_error , double max_error )
{
  double offset ;
  {
  offset = fabs(offset_register___0);
  if (est_error < offset) {
    est_error = offset;
  }
  max_error += offset;
  if (drv_set_sync_status___0) {
    (*drv_set_sync_status___0)(synchronised, est_error, max_error);
  }
  return;
}
}
void SYS_Generic_CompleteFreqDriver(double max_set_freq_ppm , double max_set_freq_delay ,
                                    double (*sys_read_freq)(void) , double (*sys_set_freq)(double freq_ppm ) ,
                                    int (*sys_apply_step_offset)(double offset ) ,
                                    double min_fastslew_offset , double max_fastslew_rate ,
                                    void (*sys_accrue_offset)(double offset , double corr_rate ) ,
                                    void (*sys_get_offset_correction)(struct timespec *raw ,
                                                                      double *corr ,
                                                                      double *err ) ,
                                    void (*sys_set_leap)(int leap , int tai_offset ) ,
                                    void (*sys_set_sync_status)(int synchronised ,
                                                                double est_error ,
                                                                double max_error ) )
{
  double tmp ;
  int (*tmp___0)(double offset ) ;
  {
  max_freq___0 = max_set_freq_ppm;
  max_freq_change_delay = max_set_freq_delay * (1.0 + max_freq___0 / 1.0e6);
  drv_read_freq___0 = sys_read_freq;
  drv_set_freq___0 = sys_set_freq;
  drv_accrue_offset___0 = sys_accrue_offset;
  drv_get_offset_correction = sys_get_offset_correction;
  drv_set_sync_status___0 = sys_set_sync_status;
  base_freq = (*drv_read_freq___0)();
  slew_freq = 0.0;
  offset_register___0 = 0.0;
  tmp = CNF_GetMaxSlewRate();
  max_corr_freq = tmp / 1.0e6;
  fastslew_min_offset = min_fastslew_offset;
  fastslew_max_rate = max_fastslew_rate / 1.0e6;
  fastslew_active = 0;
  if (sys_apply_step_offset) {
    tmp___0 = sys_apply_step_offset;
  } else {
    tmp___0 = & apply_step_offset___0;
  }
  lcl_RegisterSystemDrivers(& read_frequency___0, & set_frequency___0, & accrue_offset___0,
                            tmp___0, & offset_convert___0, sys_set_leap, & set_sync_status);
  LCL_AddParameterChangeHandler(& handle_step, (void *)0);
  return;
}
}
void SYS_Generic_Finalise(void)
{
  struct timespec now ;
  double tmp ;
  {
  SCH_RemoveTimeout(slew_timeout_id);
  slew_timeout_id = (SCH_TimeoutID )0;
  tmp = clamp_freq___0(base_freq);
  (*drv_set_freq___0)(tmp);
  LCL_ReadRawTime(& now);
  stop_fastslew(& now);
  LCL_RemoveParameterChangeHandler(& handle_step, (void *)0);
  return;
}
}
extern int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) __attribute__((__nothrow__)) ;
void SYS_Timex_Initialise(void) ;
void SYS_Timex_InitialiseWithFunctions(double max_set_freq_ppm , double max_set_freq_delay ,
                                       double (*sys_read_freq)(void) , double (*sys_set_freq)(double freq_ppm ) ,
                                       int (*sys_apply_step_offset)(double offset ) ,
                                       double min_fastslew_offset , double max_fastslew_rate ,
                                       void (*sys_accrue_offset)(double offset , double corr_rate ) ,
                                       void (*sys_get_offset_correction)(struct timespec *raw ,
                                                                         double *corr ,
                                                                         double *err ) ) ;
void SYS_Timex_Finalise(void) ;
int SYS_Timex_Adjust(struct timex *txc , int ignore_error ) ;
static int nominal_tick ;
static int current_delta_tick ;
static int max_tick_bias ;
static int hz ;
static double dhz ;
static int have_setoffset ;
static int tick_update_hz ;
static int apply_step_offset___1(double offset )
{
  struct timex txc ;
  int tmp ;
  {
  txc.modes = 8448U;
  txc.time.tv_sec = (__time_t )(- offset);
  txc.time.tv_usec = (__suseconds_t )(1.0e9 * (- offset - (double )txc.time.tv_sec));
  if (txc.time.tv_usec < 0L) {
    (txc.time.tv_sec) --;
    txc.time.tv_usec += 1000000000L;
  }
  tmp = SYS_Timex_Adjust(& txc, 1);
  if (tmp < 0) {
    return (0);
  }
  return (1);
}
}
static double set_frequency___1(double freq_ppm )
{
  struct timex txc ;
  long required_tick ;
  double required_freq ;
  int required_delta_tick ;
  double tmp ;
  {
  tmp = round(freq_ppm / dhz);
  required_delta_tick = (int )tmp;
  if (hz <= 250) {
    if (required_delta_tick + 1 == current_delta_tick) {
      required_delta_tick = current_delta_tick;
    } else
    if (required_delta_tick - 1 == current_delta_tick) {
      required_delta_tick = current_delta_tick;
    }
  }
  required_freq = - (freq_ppm - dhz * (double )required_delta_tick);
  required_tick = (long )(nominal_tick - required_delta_tick);
  txc.modes = 16386U;
  txc.freq = (__syscall_slong_t )(required_freq * (double )(1 << 16));
  txc.tick = required_tick;
  SYS_Timex_Adjust(& txc, 0);
  current_delta_tick = required_delta_tick;
  return (dhz * (double )current_delta_tick - (double )txc.freq / (double )(1 << 16));
}
}
static double read_frequency___1(void)
{
  struct timex txc ;
  {
  txc.modes = 0U;
  SYS_Timex_Adjust(& txc, 0);
  current_delta_tick = (int )((__syscall_slong_t )nominal_tick - txc.tick);
  return (dhz * (double )current_delta_tick - (double )txc.freq / (double )(1 << 16));
}
}
static int guess_hz(void)
{
  struct timex txc ;
  int i ;
  int tick ;
  int tick_lo ;
  int tick_hi ;
  int ihz ;
  double tick_nominal ;
  {
  txc.modes = 0U;
  SYS_Timex_Adjust(& txc, 0);
  tick = (int )txc.tick;
  if (tick >= 9000) {
    if (tick <= 11000) {
      return (100);
    }
  }
  i = 4;
  {
  while (1) {
    while_continue: ;
    if (! (i < 16)) {
      goto while_break;
    }
    ihz = 1 << i;
    tick_nominal = 1.0e6 / (double )ihz;
    tick_lo = (int )(0.5 + (tick_nominal * 2.0) / 3.0);
    tick_hi = (int )(0.5 + (tick_nominal * 4.0) / 3.0);
    if (tick_lo < tick) {
      if (tick <= tick_hi) {
        return (ihz);
      }
    }
    i ++;
  }
  while_break: ;
  }
  {
  while (1) {
    while_continue___0: ;
    LOG_Message((LOG_Severity )3, (char const *)"Can\'t determine hz from tick %d",
                tick);
    exit(1);
    goto while_break___0;
  }
  while_break___0: ;
  }
  return (0);
}
}
static int get_hz(void)
{
  int hz___0 ;
  long tmp ;
  {
  tmp = sysconf(2);
  hz___0 = (int )tmp;
  if (hz___0 < 1) {
    return (0);
  }
  return (hz___0);
}
}
static int kernelvercmp(int major1 , int minor1 , int patch1 , int major2 , int minor2 ,
                        int patch2 )
{
  {
  if (major1 != major2) {
    return (major1 - major2);
  }
  if (minor1 != minor2) {
    return (minor1 - minor2);
  }
  return (patch1 - patch2);
}
}
static void get_kernel_version(int *major , int *minor , int *patch )
{
  struct utsname uts ;
  int tmp ;
  int tmp___0 ;
  {
  tmp = uname(& uts);
  if (tmp < 0) {
    {
    while (1) {
      while_continue: ;
      LOG_Message((LOG_Severity )3, (char const *)"uname() failed");
      exit(1);
      goto while_break;
    }
    while_break: ;
    }
  }
  *patch = 0;
  tmp___0 = sscanf((char const *)(uts.release), (char const *)"%d.%d.%d", major,
                   minor, patch);
  if (tmp___0 < 2) {
    {
    while (1) {
      while_continue___0: ;
      LOG_Message((LOG_Severity )3, (char const *)"Could not parse kernel version");
      exit(1);
      goto while_break___0;
    }
    while_break___0: ;
    }
  }
  return;
}
}
static void get_version_specific_details(void)
{
  int major ;
  int minor ;
  int patch ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  {
  hz = get_hz();
  if (! hz) {
    hz = guess_hz();
  }
  dhz = (double )hz;
  nominal_tick = (int )((1000000L + (long )(hz / 2)) / (long )hz);
  max_tick_bias = nominal_tick / 10;
  tick_update_hz = 100000;
  get_kernel_version(& major, & minor, & patch);
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  tmp = kernelvercmp(major, minor, patch, 2, 2, 0);
  if (tmp < 0) {
    {
    while (1) {
      while_continue___0: ;
      LOG_Message((LOG_Severity )3, (char const *)"Kernel version not supported, sorry.");
      exit(1);
      goto while_break___0;
    }
    while_break___0: ;
    }
  }
  tmp___1 = kernelvercmp(major, minor, patch, 2, 6, 27);
  if (tmp___1 >= 0) {
    tmp___2 = kernelvercmp(major, minor, patch, 2, 6, 33);
    if (tmp___2 < 0) {
      tick_update_hz = 2;
    } else {
      goto _L;
    }
  } else {
    _L:
    tmp___0 = kernelvercmp(major, minor, patch, 4, 19, 0);
    if (tmp___0 < 0) {
      tick_update_hz = 100;
    }
  }
  tmp___3 = kernelvercmp(major, minor, patch, 2, 6, 39);
  if (tmp___3 < 0) {
    have_setoffset = 0;
  } else {
    have_setoffset = 1;
  }
  {
  while (1) {
    while_continue___1: ;
    goto while_break___1;
  }
  while_break___1: ;
  }
  return;
}
}
static void reset_adjtime_offset(void)
{
  struct timex txc ;
  {
  txc.modes = 32769U;
  txc.offset = (__syscall_slong_t )0;
  SYS_Timex_Adjust(& txc, 0);
  return;
}
}
static int test_step_offset(void)
{
  struct timex txc ;
  int tmp ;
  int tmp___0 ;
  {
  txc.modes = 4U;
  txc.maxerror = (__syscall_slong_t )0;
  tmp = SYS_Timex_Adjust(& txc, 1);
  if (tmp < 0) {
    return (0);
  } else
  if (txc.maxerror != 0L) {
    return (0);
  }
  txc.modes = 8448U;
  txc.time.tv_sec = (__time_t )0;
  txc.time.tv_usec = (__suseconds_t )0;
  tmp___0 = SYS_Timex_Adjust(& txc, 1);
  if (tmp___0 < 0) {
    return (0);
  } else
  if (txc.maxerror < 100000L) {
    return (0);
  }
  return (1);
}
}
static void report_time_adjust_blockers(void)
{
  {
  return;
}
}
void SYS_Linux_Initialise(void)
{
  int tmp ;
  int (*tmp___0)(double offset ) ;
  {
  get_version_specific_details();
  report_time_adjust_blockers();
  reset_adjtime_offset();
  if (have_setoffset) {
    tmp = test_step_offset();
    if (! tmp) {
      LOG_Message((LOG_Severity )0, (char const *)"adjtimex() doesn\'t support ADJ_SETOFFSET");
      have_setoffset = 0;
    }
  }
  if (have_setoffset) {
    tmp___0 = & apply_step_offset___1;
  } else {
    tmp___0 = (int (*)(double offset ))((void *)0);
  }
  SYS_Timex_InitialiseWithFunctions((1.0e6 * (double )max_tick_bias) / (double )nominal_tick,
                                    1.0 / (double )tick_update_hz, & read_frequency___1,
                                    & set_frequency___1, tmp___0, 0.0, 0.0, (void (*)(double offset ,
                                                                                      double corr_rate ))((void *)0),
                                    (void (*)(struct timespec *raw , double *corr ,
                                              double *err ))((void *)0));
  return;
}
}
void SYS_Linux_Finalise(void)
{
  {
  SYS_Timex_Finalise();
  return;
}
}
int SYS_Linux_CheckKernelVersion(int req_major , int req_minor )
{
  int major ;
  int minor ;
  int patch ;
  int tmp ;
  {
  get_kernel_version(& major, & minor, & patch);
  tmp = kernelvercmp(req_major, req_minor, 0, major, minor, patch);
  return (tmp <= 0);
}
}
static int process_phc_readings(struct timespec (*ts)[3] , int n , double precision ,
                                struct timespec *phc_ts , struct timespec *sys_ts ,
                                double *err )
{
  double min_delay ;
  double delays[25] ;
  double phc_sum ;
  double sys_sum ;
  double sys_prec ;
  int i ;
  int combined ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  {
  min_delay = 0.0;
  if (n > 25) {
    return (0);
  }
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < n)) {
      goto while_break;
    }
    delays[i] = UTI_DiffTimespecsToDouble((struct timespec const *)(& (*(ts + i))[2]),
                                          (struct timespec const *)(& (*(ts + i))[0]));
    if (delays[i] < 0.0) {
      {
      while (1) {
        while_continue___0: ;
        goto while_break___0;
      }
      while_break___0: ;
      }
      return (0);
    }
    if (! i) {
      min_delay = delays[i];
    } else
    if (delays[i] < min_delay) {
      min_delay = delays[i];
    }
    i ++;
  }
  while_break: ;
  }
  sys_prec = LCL_GetSysPrecisionAsQuantum();
  combined = 0;
  i = combined;
  sys_sum = 0.0;
  phc_sum = sys_sum;
  {
  while (1) {
    while_continue___1: ;
    if (! (i < n)) {
      goto while_break___1;
    }
    if (sys_prec > precision) {
      tmp = sys_prec;
    } else {
      tmp = precision;
    }
    if (delays[i] > min_delay + tmp) {
      goto __Cont;
    }
    tmp___0 = UTI_DiffTimespecsToDouble((struct timespec const *)(& (*(ts + i))[1]),
                                        (struct timespec const *)(& (*(ts + 0))[1]));
    phc_sum += tmp___0;
    tmp___1 = UTI_DiffTimespecsToDouble((struct timespec const *)(& (*(ts + i))[0]),
                                        (struct timespec const *)(& (*(ts + 0))[0]));
    sys_sum += tmp___1 + delays[i] / 2.0;
    combined ++;
    __Cont:
    i ++;
  }
  while_break___1: ;
  }
  assert(combined);
  UTI_AddDoubleToTimespec((struct timespec const *)(& (*(ts + 0))[1]), phc_sum / (double )combined,
                          phc_ts);
  UTI_AddDoubleToTimespec((struct timespec const *)(& (*(ts + 0))[0]), sys_sum / (double )combined,
                          sys_ts);
  if (min_delay / 2.0 > precision) {
    *err = min_delay / 2.0;
  } else {
    *err = precision;
  }
  return (1);
}
}
static int get_phc_sample(int phc_fd , double precision , struct timespec *phc_ts ,
                          struct timespec *sys_ts , double *err )
{
  struct timespec ts[10][3] ;
  struct ptp_sys_offset sys_off ;
  int i ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  memset((void *)(& sys_off), 0, sizeof(sys_off));
  sys_off.n_samples = 10U;
  tmp___1 = ioctl(phc_fd, (unsigned long )(((1U << 30) | (unsigned int )(61 << 8)) | 5U) | (sizeof(struct ptp_sys_offset ) << 16),
                  & sys_off);
  if (tmp___1) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  i = 0;
  {
  while (1) {
    while_continue___0: ;
    if (! (i < 10)) {
      goto while_break___0;
    }
    ts[i][0].tv_sec = (__time_t )sys_off.ts[i * 2].sec;
    ts[i][0].tv_nsec = (__syscall_slong_t )sys_off.ts[i * 2].nsec;
    ts[i][1].tv_sec = (__time_t )sys_off.ts[i * 2 + 1].sec;
    ts[i][1].tv_nsec = (__syscall_slong_t )sys_off.ts[i * 2 + 1].nsec;
    ts[i][2].tv_sec = (__time_t )sys_off.ts[i * 2 + 2].sec;
    ts[i][2].tv_nsec = (__syscall_slong_t )sys_off.ts[i * 2 + 2].nsec;
    i ++;
  }
  while_break___0: ;
  }
  tmp___2 = process_phc_readings(ts, 10, precision, phc_ts, sys_ts, err);
  return (tmp___2);
}
}
static int get_extended_phc_sample(int phc_fd , double precision , struct timespec *phc_ts ,
                                   struct timespec *sys_ts , double *err )
{
  struct timespec ts[10][3] ;
  struct ptp_sys_offset_extended sys_off ;
  int i ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  memset((void *)(& sys_off), 0, sizeof(sys_off));
  sys_off.n_samples = 10U;
  tmp___1 = ioctl(phc_fd, (unsigned long )(((3U << 30) | (unsigned int )(61 << 8)) | 9U) | (sizeof(struct ptp_sys_offset_extended ) << 16),
                  & sys_off);
  if (tmp___1) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  i = 0;
  {
  while (1) {
    while_continue___0: ;
    if (! (i < 10)) {
      goto while_break___0;
    }
    ts[i][0].tv_sec = (__time_t )sys_off.ts[i][0].sec;
    ts[i][0].tv_nsec = (__syscall_slong_t )sys_off.ts[i][0].nsec;
    ts[i][1].tv_sec = (__time_t )sys_off.ts[i][1].sec;
    ts[i][1].tv_nsec = (__syscall_slong_t )sys_off.ts[i][1].nsec;
    ts[i][2].tv_sec = (__time_t )sys_off.ts[i][2].sec;
    ts[i][2].tv_nsec = (__syscall_slong_t )sys_off.ts[i][2].nsec;
    i ++;
  }
  while_break___0: ;
  }
  tmp___2 = process_phc_readings(ts, 10, precision, phc_ts, sys_ts, err);
  return (tmp___2);
}
}
static int get_precise_phc_sample(int phc_fd , double precision , struct timespec *phc_ts ,
                                  struct timespec *sys_ts , double *err )
{
  struct ptp_sys_offset_precise sys_off ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  {
  memset((void *)(& sys_off), 0, sizeof(sys_off));
  tmp___1 = ioctl(phc_fd, (unsigned long )(((3U << 30) | (unsigned int )(61 << 8)) | 8U) | (sizeof(struct ptp_sys_offset_precise ) << 16),
                  & sys_off);
  if (tmp___1) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  phc_ts->tv_sec = (__time_t )sys_off.device.sec;
  phc_ts->tv_nsec = (__syscall_slong_t )sys_off.device.nsec;
  sys_ts->tv_sec = (__time_t )sys_off.sys_realtime.sec;
  sys_ts->tv_nsec = (__syscall_slong_t )sys_off.sys_realtime.nsec;
  tmp___4 = LCL_GetSysPrecisionAsQuantum();
  if (tmp___4 > precision) {
    tmp___3 = LCL_GetSysPrecisionAsQuantum();
    *err = tmp___3;
  } else {
    *err = precision;
  }
  return (1);
}
}
int SYS_Linux_OpenPHC(char const *path , int phc_index )
{
  struct ptp_clock_caps caps ;
  char phc_path[64] ;
  int phc_fd ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  {
  if (! path) {
    tmp = snprintf(phc_path, sizeof(phc_path), (char const *)"/dev/ptp%d", phc_index);
    if ((unsigned long )tmp >= sizeof(phc_path)) {
      return (-1);
    }
    path = (char const *)(phc_path);
  }
  phc_fd = open(path, 00);
  if (phc_fd < 0) {
    tmp___0 = __errno_location();
    tmp___1 = strerror(*tmp___0);
    LOG_Message((LOG_Severity )2, (char const *)"Could not open %s : %s", path,
                tmp___1);
    return (-1);
  }
  tmp___4 = ioctl(phc_fd, (unsigned long )(((2U << 30) | (unsigned int )(61 << 8)) | 1U) | (sizeof(struct ptp_clock_caps ) << 16),
                  & caps);
  if (tmp___4) {
    tmp___2 = __errno_location();
    tmp___3 = strerror(*tmp___2);
    LOG_Message((LOG_Severity )2, (char const *)"ioctl(%s) failed : %s", "PTP_CLOCK_GETCAPS",
                tmp___3);
    close(phc_fd);
    return (-1);
  }
  UTI_FdSetCloexec(phc_fd);
  return (phc_fd);
}
}
int SYS_Linux_GetPHCSample(int fd___0 , int nocrossts , double precision , int *reading_mode ,
                           struct timespec *phc_ts , struct timespec *sys_ts , double *err )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  if (*reading_mode == 2) {
    goto _L___4;
  } else
  if (! *reading_mode) {
    _L___4:
    if (! nocrossts) {
      tmp___1 = get_precise_phc_sample(fd___0, precision, phc_ts, sys_ts, err);
      if (tmp___1) {
        *reading_mode = 2;
        return (1);
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else
  _L___3:
  _L___2:
  if (*reading_mode == 3) {
    goto _L___1;
  } else
  if (! *reading_mode) {
    _L___1:
    tmp___0 = get_extended_phc_sample(fd___0, precision, phc_ts, sys_ts, err);
    if (tmp___0) {
      *reading_mode = 3;
      return (1);
    } else {
      goto _L___0;
    }
  } else
  _L___0:
  if (*reading_mode == 1) {
    goto _L;
  } else
  if (! *reading_mode) {
    _L:
    tmp = get_phc_sample(fd___0, precision, phc_ts, sys_ts, err);
    if (tmp) {
      *reading_mode = 1;
      return (1);
    }
  }
  return (0);
}
}
int SYS_Linux_SetPHCExtTimestamping(int fd___0 , int pin , int channel , int rising ,
                                    int falling , int enable )
{
  struct ptp_extts_request extts_req ;
  struct ptp_pin_desc pin_desc ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  {
  memset((void *)(& pin_desc), 0, sizeof(pin_desc));
  pin_desc.index = (unsigned int )pin;
  if (enable) {
    pin_desc.func = 1U;
  } else {
    pin_desc.func = 0U;
  }
  pin_desc.chan = (unsigned int )channel;
  tmp___1 = ioctl(fd___0, (unsigned long )(((1U << 30) | (unsigned int )(61 << 8)) | 7U) | (sizeof(struct ptp_pin_desc ) << 16),
                  & pin_desc);
  if (tmp___1) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  memset((void *)(& extts_req), 0, sizeof(extts_req));
  extts_req.index = (unsigned int )channel;
  if (enable) {
    tmp___2 = 1;
  } else {
    tmp___2 = 0;
  }
  if (rising) {
    tmp___3 = 1 << 1;
  } else {
    tmp___3 = 0;
  }
  if (falling) {
    tmp___4 = 1 << 2;
  } else {
    tmp___4 = 0;
  }
  extts_req.flags = (unsigned int )((tmp___2 | tmp___3) | tmp___4);
  tmp___7 = ioctl(fd___0, (unsigned long )(((1U << 30) | (unsigned int )(61 << 8)) | 2U) | (sizeof(struct ptp_extts_request ) << 16),
                  & extts_req);
  if (tmp___7) {
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
    return (0);
  }
  return (1);
}
}
int SYS_Linux_ReadPHCExtTimestamp(int fd___0 , struct timespec *phc_ts , int *channel )
{
  struct ptp_extts_event extts_event ;
  ssize_t tmp ;
  {
  tmp = read(fd___0, (void *)(& extts_event), sizeof(extts_event));
  if ((unsigned long )tmp != sizeof(extts_event)) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  phc_ts->tv_sec = (__time_t )extts_event.t.sec;
  phc_ts->tv_nsec = (__syscall_slong_t )extts_event.t.nsec;
  *channel = (int )extts_event.index;
  return (1);
}
}
static int sys_status ;
static int sys_tai_offset ;
static double convert_timex_frequency(struct timex const *txc )
{
  double freq_ppm ;
  {
  freq_ppm = (double )txc->freq / (double )(1 << 16);
  return (- freq_ppm);
}
}
static double read_frequency___2(void)
{
  struct timex txc ;
  double tmp ;
  {
  txc.modes = 0U;
  SYS_Timex_Adjust(& txc, 0);
  tmp = convert_timex_frequency((struct timex const *)(& txc));
  return (tmp);
}
}
static double set_frequency___2(double freq_ppm )
{
  struct timex txc ;
  double tmp ;
  {
  txc.modes = 2U;
  txc.freq = (__syscall_slong_t )(freq_ppm * - ((double )(1 << 16)));
  SYS_Timex_Adjust(& txc, 0);
  tmp = convert_timex_frequency((struct timex const *)(& txc));
  return (tmp);
}
}
static void set_leap(int leap , int tai_offset )
{
  struct timex txc ;
  int applied ;
  int prev_status ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  {
  txc.modes = 0U;
  tmp = SYS_Timex_Adjust(& txc, 0);
  applied = tmp == 4;
  prev_status = sys_status;
  sys_status &= -49;
  if (leap > 0) {
    sys_status |= 0x0010;
  } else
  if (leap < 0) {
    sys_status |= 0x0020;
  }
  txc.modes = 16U;
  txc.status = sys_status;
  if (tai_offset) {
    txc.modes |= 128U;
    txc.constant = (__syscall_slong_t )tai_offset;
    if (applied) {
      if (! (sys_status & 48)) {
        if (prev_status & 0x0010) {
          tmp___0 = 1;
        } else {
          tmp___0 = -1;
        }
        sys_tai_offset += tmp___0;
      }
    }
    if (sys_tai_offset != tai_offset) {
      sys_tai_offset = tai_offset;
      LOG_Message((LOG_Severity )0, (char const *)"System clock TAI offset set to %d seconds",
                  tai_offset);
    }
  }
  SYS_Timex_Adjust(& txc, 0);
  if (prev_status != sys_status) {
    if (leap) {
      if (leap > 0) {
        tmp___1 = "set to insert";
      } else {
        tmp___1 = "set to delete";
      }
      tmp___3 = tmp___1;
    } else {
      if (applied) {
        tmp___2 = "reset after";
      } else {
        tmp___2 = "set to not insert/delete";
      }
      tmp___3 = tmp___2;
    }
    LOG_Message((LOG_Severity )0, (char const *)"System clock status %s leap second",
                tmp___3);
  }
  return;
}
}
static void set_sync_status___0(int synchronised , double est_error , double max_error )
{
  struct timex txc ;
  int tmp ;
  int tmp___0 ;
  {
  if (synchronised) {
    if (est_error > 16.0) {
      est_error = 16.0;
    }
    if (max_error >= 16.0) {
      max_error = 16.0;
      synchronised = 0;
    }
  } else {
    max_error = 16.0;
    est_error = max_error;
  }
  tmp = CNF_GetRtcSync();
  if (! tmp) {
    synchronised = 0;
  }
  if (synchronised) {
    sys_status &= -65;
  } else {
    sys_status |= 0x0040;
  }
  txc.modes = 28U;
  txc.status = sys_status;
  txc.esterror = (__syscall_slong_t )(est_error * 1.0e6);
  txc.maxerror = (__syscall_slong_t )(max_error * 1.0e6);
  tmp___0 = SYS_Timex_Adjust(& txc, 1);
  return;
}
}
static void initialise_timex(void)
{
  struct timex txc ;
  {
  sys_status = 0x0040;
  sys_tai_offset = 0;
  txc.modes = 17U;
  txc.status = 0x0001 | sys_status;
  txc.offset = (__syscall_slong_t )0;
  SYS_Timex_Adjust(& txc, 0);
  txc.modes = 16U;
  txc.status = sys_status;
  SYS_Timex_Adjust(& txc, 0);
  return;
}
}
void SYS_Timex_Initialise(void)
{
  {
  SYS_Timex_InitialiseWithFunctions(500.0, 1.0 / (double )100, (double (*)(void))((void *)0),
                                    (double (*)(double freq_ppm ))((void *)0), (int (*)(double offset ))((void *)0),
                                    0.0, 0.0, (void (*)(double offset , double corr_rate ))((void *)0),
                                    (void (*)(struct timespec *raw , double *corr ,
                                              double *err ))((void *)0));
  return;
}
}
void SYS_Timex_InitialiseWithFunctions(double max_set_freq_ppm , double max_set_freq_delay ,
                                       double (*sys_read_freq)(void) , double (*sys_set_freq)(double freq_ppm ) ,
                                       int (*sys_apply_step_offset)(double offset ) ,
                                       double min_fastslew_offset , double max_fastslew_rate ,
                                       void (*sys_accrue_offset)(double offset , double corr_rate ) ,
                                       void (*sys_get_offset_correction)(struct timespec *raw ,
                                                                         double *corr ,
                                                                         double *err ) )
{
  double (*tmp)(double freq_ppm ) ;
  double (*tmp___0)(void) ;
  {
  initialise_timex();
  if (sys_set_freq) {
    tmp = sys_set_freq;
  } else {
    tmp = & set_frequency___2;
  }
  if (sys_read_freq) {
    tmp___0 = sys_read_freq;
  } else {
    tmp___0 = & read_frequency___2;
  }
  SYS_Generic_CompleteFreqDriver(max_set_freq_ppm, max_set_freq_delay, tmp___0, tmp,
                                 sys_apply_step_offset, min_fastslew_offset, max_fastslew_rate,
                                 sys_accrue_offset, sys_get_offset_correction, & set_leap,
                                 & set_sync_status___0);
  return;
}
}
void SYS_Timex_Finalise(void)
{
  {
  SYS_Generic_Finalise();
  return;
}
}
int SYS_Timex_Adjust(struct timex *txc , int ignore_error )
{
  int state ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  {
  state = adjtimex(txc);
  if (state < 0) {
    tmp = __errno_location();
    tmp___0 = strerror(*tmp);
    if (ignore_error) {
      tmp___1 = -1;
    } else {
      tmp___1 = 3;
    }
    LOG_Message((LOG_Severity )tmp___1, (char const *)"adjtimex(0x%x) failed : %s",
                txc->modes, tmp___0);
  }
  return (state);
}
}
extern int ( __attribute__((__leaf__)) clone)(int (*__fn)(void *__arg ) , void *__child_stack ,
                                              int __flags , void *__arg , ...) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) unshare)(int __flags ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) sched_getcpu)(void) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) getcpu)(unsigned int * , unsigned int * ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setns)(int __fd , int __nstype ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) sched_setaffinity)(__pid_t __pid , size_t __cpusetsize ,
                                                          cpu_set_t const *__cpuset ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) sched_getaffinity)(__pid_t __pid , size_t __cpusetsize ,
                                                          cpu_set_t *__cpuset ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) pthread_tryjoin_np)(pthread_t __th , void **__thread_return ) __attribute__((__nothrow__)) ;
extern int pthread_timedjoin_np(pthread_t __th , void **__thread_return , struct timespec const *__abstime ) ;
extern int pthread_clockjoin_np(pthread_t __th , void **__thread_return , clockid_t __clockid ,
                                struct timespec const *__abstime ) ;
extern int ( __attribute__((__nonnull__(1,3), __leaf__)) pthread_attr_setaffinity_np)(pthread_attr_t *__attr ,
                                                                                      size_t __cpusetsize ,
                                                                                      cpu_set_t const *__cpuset ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,3), __leaf__)) pthread_attr_getaffinity_np)(pthread_attr_t const *__attr ,
                                                                                      size_t __cpusetsize ,
                                                                                      cpu_set_t *__cpuset ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_getattr_default_np)(pthread_attr_t *__attr ) __attribute__((__nothrow__)) ;
extern int pthread_attr_setsigmask_np(pthread_attr_t *__attr , __sigset_t const *sigmask ) ;
extern int pthread_attr_getsigmask_np(pthread_attr_t const *__attr , __sigset_t *sigmask ) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_setattr_default_np)(pthread_attr_t const *__attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2), __leaf__)) pthread_getattr_np)(pthread_t __th ,
                                                                           pthread_attr_t *__attr ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2), __leaf__)) pthread_getname_np)(pthread_t __target_thread ,
                                                                           char *__buf ,
                                                                           size_t __buflen ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2), __leaf__)) pthread_setname_np)(pthread_t __target_thread ,
                                                                           char const *__name ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) pthread_getconcurrency)(void) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) pthread_setconcurrency)(int __level ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) pthread_yield)(void) __asm__("sched_yield") __attribute__((__nothrow__,
__deprecated__("pthread_yield is deprecated, use sched_yield instead"))) ;
extern int ( __attribute__((__nonnull__(3), __leaf__)) pthread_setaffinity_np)(pthread_t __th ,
                                                                               size_t __cpusetsize ,
                                                                               cpu_set_t const *__cpuset ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(3), __leaf__)) pthread_getaffinity_np)(pthread_t __th ,
                                                                               size_t __cpusetsize ,
                                                                               cpu_set_t *__cpuset ) __attribute__((__nothrow__)) ;
extern void __pthread_register_cancel_defer(__pthread_unwind_buf_t *__buf ) ;
extern void __pthread_unregister_cancel_restore(__pthread_unwind_buf_t *__buf ) ;
extern int ( __attribute__((__nonnull__(1,3))) pthread_mutex_clocklock)(pthread_mutex_t *__mutex ,
                                                                        clockid_t __clockid ,
                                                                        struct timespec const *__abstime ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_consistent_np)(pthread_mutex_t * ) __asm__("pthread_mutex_consistent") __attribute__((__nothrow__,
__deprecated__("pthread_mutex_consistent_np is deprecated, use pthread_mutex_consistent"))) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_getrobust_np)(pthread_mutexattr_t * ,
                                                                                       int * ) __asm__("pthread_mutexattr_getrobust") __attribute__((__nothrow__,
__deprecated__("pthread_mutexattr_getrobust_np is deprecated, use pthread_mutexattr_getrobust"))) ;
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_setrobust_np)(pthread_mutexattr_t * ,
                                                                                       int ) __asm__("pthread_mutexattr_setrobust") __attribute__((__nothrow__,
__deprecated__("pthread_mutexattr_setrobust_np is deprecated, use pthread_mutexattr_setrobust"))) ;
extern int ( __attribute__((__nonnull__(1,3))) pthread_rwlock_clockrdlock)(pthread_rwlock_t *__rwlock ,
                                                                           clockid_t __clockid ,
                                                                           struct timespec const *__abstime ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,3))) pthread_rwlock_clockwrlock)(pthread_rwlock_t *__rwlock ,
                                                                           clockid_t __clockid ,
                                                                           struct timespec const *__abstime ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(1,2,4))) pthread_cond_clockwait)(pthread_cond_t *__cond ,
                                                                         pthread_mutex_t *__mutex ,
                                                                         __clockid_t __clock_id ,
                                                                         struct timespec const *__abstime ) ;
extern int ( __attribute__((__leaf__, __gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                      pthread_t __thread2 ) __attribute__((__nothrow__,
__const__)) ;
extern int ( __attribute__((__leaf__, __gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                      pthread_t __thread2 )
{
  {
  return (__thread1 == __thread2);
}
}
extern int ( __attribute__((__leaf__)) memfd_create)(char const *__name , unsigned int __flags ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) mlock2)(void const *__addr , size_t __length ,
                                               unsigned int __flags ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) pkey_alloc)(unsigned int __flags , unsigned int __access_rights ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) pkey_set)(int __key , unsigned int __access_rights ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) pkey_get)(int __key ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) pkey_free)(int __key ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) pkey_mprotect)(void *__addr , size_t __len ,
                                                      int __prot , int __pkey ) __attribute__((__nothrow__)) ;
extern void *( __attribute__((__leaf__)) mmap)(void *__addr , size_t __len , int __prot ,
                                               int __flags , int __fd , __off_t __offset ) __attribute__((__nothrow__)) ;
extern void *( __attribute__((__leaf__)) mmap64)(void *__addr , size_t __len , int __prot ,
                                                 int __flags , int __fd , __off64_t __offset ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) munmap)(void *__addr , size_t __len ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) mprotect)(void *__addr , size_t __len , int __prot ) __attribute__((__nothrow__)) ;
extern int msync(void *__addr , size_t __len , int __flags ) ;
extern int ( __attribute__((__leaf__)) madvise)(void *__addr , size_t __len , int __advice ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) posix_madvise)(void *__addr , size_t __len ,
                                                      int __advice ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) mlock)(void const *__addr , size_t __len ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) munlock)(void const *__addr , size_t __len ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) mlockall)(int __flags ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) munlockall)(void) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) mincore)(void *__start , size_t __len , unsigned char *__vec ) __attribute__((__nothrow__)) ;
extern void *( __attribute__((__leaf__)) mremap)(void *__addr , size_t __old_len ,
                                                 size_t __new_len , int __flags , ...) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) remap_file_pages)(void *__start , size_t __size ,
                                                         int __prot , size_t __pgoff ,
                                                         int __flags ) __attribute__((__nothrow__)) ;
extern int shm_open(char const *__name , int __oflag , mode_t __mode ) ;
extern int shm_unlink(char const *__name ) ;
extern int ( __attribute__((__leaf__)) prlimit)(__pid_t __pid , enum __rlimit_resource __resource ,
                                                struct rlimit const *__new_limit ,
                                                struct rlimit *__old_limit ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) prlimit64)(__pid_t __pid , enum __rlimit_resource __resource ,
                                                  struct rlimit64 const *__new_limit ,
                                                  struct rlimit64 *__old_limit ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2), __leaf__)) getrlimit)(__rlimit_resource_t __resource ,
                                                                  struct rlimit *__rlimits ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2), __leaf__)) getrlimit64)(__rlimit_resource_t __resource ,
                                                                    struct rlimit64 *__rlimits ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2), __leaf__)) setrlimit)(__rlimit_resource_t __resource ,
                                                                  struct rlimit const *__rlimits ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__nonnull__(2), __leaf__)) setrlimit64)(__rlimit_resource_t __resource ,
                                                                    struct rlimit64 const *__rlimits ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) getrusage)(__rusage_who_t __who , struct rusage *__usage ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) getpriority)(__priority_which_t __which , id_t __who ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) setpriority)(__priority_which_t __which , id_t __who ,
                                                    int __prio ) __attribute__((__nothrow__)) ;
void SYS_Posix_SetScheduler(int priority )
{
  struct sched_param sched ;
  int pmax ;
  int pmin ;
  pthread_t tmp ;
  int tmp___0 ;
  {
  if (priority < 1) {
    goto _L;
  } else
  if (priority > 99) {
    _L:
    {
    while (1) {
      while_continue: ;
      LOG_Message((LOG_Severity )3, (char const *)"Bad scheduler priority: %d",
                  priority);
      exit(1);
      goto while_break;
    }
    while_break: ;
    }
  }
  sched.sched_priority = priority;
  pmax = sched_get_priority_max(1);
  pmin = sched_get_priority_min(1);
  if (priority > pmax) {
    sched.sched_priority = pmax;
  } else
  if (priority < pmin) {
    sched.sched_priority = pmin;
  }
  tmp = pthread_self();
  tmp___0 = pthread_setschedparam(tmp, 1, (struct sched_param const *)(& sched));
  if (tmp___0 < 0) {
    LOG_Message((LOG_Severity )2, (char const *)"pthread_setschedparam() failed");
  } else {
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
  }
  return;
}
}
void SYS_Posix_MemLockAll(void)
{
  struct rlimit rlim ;
  int tmp ;
  int tmp___0 ;
  {
  rlim.rlim_max = (__rlim_t )-1;
  rlim.rlim_cur = (__rlim_t )-1;
  tmp = setrlimit((__rlimit_resource_t )8, (struct rlimit const *)(& rlim));
  if (tmp < 0) {
    LOG_Message((LOG_Severity )2, (char const *)"setrlimit() failed");
    return;
  }
  tmp___0 = mlockall(3);
  if (tmp___0 < 0) {
    LOG_Message((LOG_Severity )2, (char const *)"mlockall() failed");
  } else {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
  }
  return;
}
}
ADF_AuthTable ADF_CreateTable(void) ;
ADF_Status ADF_Allow(ADF_AuthTable table , IPAddr *ip , int subnet_bits ) ;
ADF_Status ADF_AllowAll(ADF_AuthTable table , IPAddr *ip , int subnet_bits ) ;
ADF_Status ADF_Deny(ADF_AuthTable table , IPAddr *ip , int subnet_bits ) ;
ADF_Status ADF_DenyAll(ADF_AuthTable table , IPAddr *ip , int subnet_bits ) ;
void ADF_DestroyTable(ADF_AuthTable table ) ;
int ADF_IsAllowed(ADF_AuthTable table , IPAddr *ip_addr ) ;
int ADF_IsAnyAllowed(ADF_AuthTable table , int family ) ;
int PKL_CommandLength(CMD_Request *r ) ;
int PKL_CommandPaddingLength(CMD_Request *r ) ;
int PKL_ReplyLength(CMD_Reply *r ) ;
static int sock_fdu ;
static int sock_fd4 ;
static int sock_fd6 ;
static int bound_sock_fd4 ;
static int initialised___5 = 0;
static char const permissions[72] =
  { (char const )0, (char const )2, (char const )2, (char const )2,
        (char const )2, (char const )2, (char const )2, (char const )2,
        (char const )2, (char const )2, (char const )0, (char const )2,
        (char const )2, (char const )2, (char const )0, (char const )0,
        (char const )2, (char const )2, (char const )2, (char const )2,
        (char const )2, (char const )2, (char const )2, (char const )2,
        (char const )2, (char const )2, (char const )2, (char const )2,
        (char const )2, (char const )2, (char const )2, (char const )2,
        (char const )2, (char const )0, (char const )0, (char const )0,
        (char const )2, (char const )2, (char const )2, (char const )2,
        (char const )2, (char const )0, (char const )2, (char const )2,
        (char const )0, (char const )2, (char const )2, (char const )2,
        (char const )2, (char const )2, (char const )2, (char const )0,
        (char const )2, (char const )2, (char const )2, (char const )2,
        (char const )2, (char const )2, (char const )2, (char const )2,
        (char const )2, (char const )2, (char const )2, (char const )2,
        (char const )2, (char const )0, (char const )2, (char const )2,
        (char const )2, (char const )2, (char const )2, (char const )2};
static ADF_AuthTable access_auth_table ;
static void read_from_cmd_socket(int sock_fd , int event , void *anything ) ;
static int open_socket___0(int family )
{
  char const *local_path ;
  char const *iface ;
  IPSockAddr local_addr ;
  int sock_fd ;
  int port ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  {
  {
  if (family == 2) {
    goto case_2;
  }
  if (family == 1) {
    goto case_2;
  }
  if (family == 0) {
    goto case_0;
  }
  goto switch_default;
  case_2:
  case_1:
  port = CNF_GetCommandPort();
  if (port == 0) {
    return (-5);
  } else {
    tmp = SCK_IsIpFamilyEnabled(family);
    if (! tmp) {
      return (-5);
    }
  }
  CNF_GetBindCommandAddress(family, & local_addr.ip_addr);
  local_addr.port = (uint16_t )port;
  tmp___0 = CNF_GetBindCommandInterface();
  iface = (char const *)tmp___0;
  sock_fd = SCK_OpenUdpSocket((IPSockAddr *)((void *)0), & local_addr, iface, 4);
  if (sock_fd < 0) {
    tmp___1 = UTI_IPSockAddrToString((IPSockAddr const *)(& local_addr));
    LOG_Message((LOG_Severity )2, (char const *)"Could not open command socket on %s",
                tmp___1);
    return (-5);
  }
  if (family == 1) {
    bound_sock_fd4 = local_addr.ip_addr.addr.in4 != 0U;
  }
  goto switch_break;
  case_0:
  tmp___2 = CNF_GetBindCommandPath();
  local_path = (char const *)tmp___2;
  sock_fd = SCK_OpenUnixDatagramSocket((char const *)((void *)0), local_path, 0);
  if (sock_fd < 0) {
    LOG_Message((LOG_Severity )2, (char const *)"Could not open command socket on %s",
                local_path);
    return (-5);
  }
  goto switch_break;
  switch_default:
  assert(0);
  switch_break: ;
  }
  SCH_AddFileHandler(sock_fd, 1, & read_from_cmd_socket, (void *)0);
  return (sock_fd);
}
}
static void do_size_checks(void)
{
  int i ;
  int request_length ;
  int padding_length ;
  int reply_length ;
  CMD_Request request ;
  CMD_Reply reply ;
  {
  assert((unsigned long )(& ((CMD_Request *)0)->data) == 20UL);
  assert((unsigned long )(& ((CMD_Reply *)0)->data) == 28UL);
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < 72)) {
      goto while_break;
    }
    request.version = (uint8_t )6;
    request.command = __bswap_16((__uint16_t )i);
    request_length = PKL_CommandLength(& request);
    padding_length = PKL_CommandPaddingLength(& request);
    if (padding_length > 484) {
      assert(0);
    } else
    if (padding_length > request_length) {
      assert(0);
    } else
    if ((unsigned long )request_length > sizeof(CMD_Request )) {
      assert(0);
    } else
    if (request_length) {
      if ((unsigned long )request_length < (unsigned long )(& ((CMD_Request *)0)->data)) {
        assert(0);
      }
    }
    i ++;
  }
  while_break: ;
  }
  i = 1;
  {
  while (1) {
    while_continue___0: ;
    if (! (i < 25)) {
      goto while_break___0;
    }
    reply.reply = __bswap_16((__uint16_t )i);
    reply.status = (uint16_t )0;
    reply_length = PKL_ReplyLength(& reply);
    if (reply_length) {
      if ((unsigned long )reply_length < (unsigned long )(& ((CMD_Reply *)0)->data)) {
        assert(0);
      } else {
        goto _L;
      }
    } else
    _L:
    if ((unsigned long )reply_length > sizeof(CMD_Reply )) {
      assert(0);
    }
    i ++;
  }
  while_break___0: ;
  }
  return;
}
}
void CAM_Initialise(void)
{
  {
  assert(! initialised___5);
  assert(sizeof(permissions) / sizeof(permissions[0]) == 72UL);
  do_size_checks();
  initialised___5 = 1;
  bound_sock_fd4 = 0;
  sock_fdu = -5;
  sock_fd4 = open_socket___0(1);
  sock_fd6 = open_socket___0(2);
  access_auth_table = ADF_CreateTable();
  return;
}
}
void CAM_Finalise(void)
{
  {
  if (sock_fdu != -5) {
    SCH_RemoveFileHandler(sock_fdu);
    SCK_RemoveSocket(sock_fdu);
    SCK_CloseSocket(sock_fdu);
    sock_fdu = -5;
  }
  if (sock_fd4 != -5) {
    SCH_RemoveFileHandler(sock_fd4);
    SCK_CloseSocket(sock_fd4);
    sock_fd4 = -5;
  }
  if (sock_fd6 != -5) {
    SCH_RemoveFileHandler(sock_fd6);
    SCK_CloseSocket(sock_fd6);
    sock_fd6 = -5;
  }
  ADF_DestroyTable(access_auth_table);
  initialised___5 = 0;
  return;
}
}
void CAM_OpenUnixSocket(void)
{
  char *tmp ;
  {
  tmp = CNF_GetBindCommandPath();
  if (tmp) {
    sock_fdu = open_socket___0(0);
  }
  return;
}
}
static void transmit_reply(int sock_fd , int request_length , SCK_Message *message )
{
  int tmp ;
  int tmp___0 ;
  {
  message->length = PKL_ReplyLength((CMD_Reply *)message->data);
  if (request_length < message->length) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return;
  }
  if ((unsigned int )message->addr_type == 1U) {
    tmp = SCK_IsLinkLocalIPAddress(& message->remote_addr.ip.ip_addr);
    if (! tmp) {
      message->if_index = -1;
    }
  }
  tmp___0 = SCK_SendMessage(sock_fd, message, 0);
  if (! tmp___0) {
    return;
  }
  return;
}
}
static void handle_dump(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  {
  SRC_DumpSources();
  NSR_DumpAuthData();
  NKS_DumpKeys();
  return;
}
}
static void handle_online(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  IPAddr address ;
  IPAddr mask ;
  int tmp ;
  {
  UTI_IPNetworkToHost((IPAddr const *)(& rx_message->data.online.mask), & mask);
  UTI_IPNetworkToHost((IPAddr const *)(& rx_message->data.online.address), & address);
  tmp = NSR_SetConnectivity(& mask, & address, (SRC_Connectivity )1);
  if (! tmp) {
    tx_message->status = __bswap_16((__uint16_t )4);
  }
  return;
}
}
static void handle_offline(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  IPAddr address ;
  IPAddr mask ;
  int tmp ;
  {
  UTI_IPNetworkToHost((IPAddr const *)(& rx_message->data.offline.mask), & mask);
  UTI_IPNetworkToHost((IPAddr const *)(& rx_message->data.offline.address), & address);
  tmp = NSR_SetConnectivity(& mask, & address, (SRC_Connectivity )0);
  if (! tmp) {
    tx_message->status = __bswap_16((__uint16_t )4);
  }
  return;
}
}
static void handle_onoffline(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  IPAddr address ;
  IPAddr mask ;
  int tmp ;
  int tmp___0 ;
  {
  mask.family = (uint16_t )0;
  address.family = mask.family;
  tmp = NSR_SetConnectivity(& mask, & address, (SRC_Connectivity )2);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  return;
}
}
static void handle_burst(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  IPAddr address ;
  IPAddr mask ;
  __uint32_t tmp ;
  __uint32_t tmp___0 ;
  int tmp___1 ;
  {
  UTI_IPNetworkToHost((IPAddr const *)(& rx_message->data.burst.mask), & mask);
  UTI_IPNetworkToHost((IPAddr const *)(& rx_message->data.burst.address), & address);
  tmp = __bswap_32((__uint32_t )rx_message->data.burst.n_total_samples);
  tmp___0 = __bswap_32((__uint32_t )rx_message->data.burst.n_good_samples);
  tmp___1 = NSR_InitiateSampleBurst((int )tmp___0, (int )tmp, & mask, & address);
  if (! tmp___1) {
    tx_message->status = __bswap_16((__uint16_t )4);
  }
  return;
}
}
static void handle_modify_minpoll(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  IPAddr address ;
  __uint32_t tmp ;
  int tmp___0 ;
  {
  UTI_IPNetworkToHost((IPAddr const *)(& rx_message->data.modify_minpoll.address),
                      & address);
  tmp = __bswap_32((__uint32_t )rx_message->data.modify_minpoll.new_minpoll);
  tmp___0 = NSR_ModifyMinpoll(& address, (int )tmp);
  if (! tmp___0) {
    tx_message->status = __bswap_16((__uint16_t )4);
  }
  return;
}
}
static void handle_modify_maxpoll(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  IPAddr address ;
  __uint32_t tmp ;
  int tmp___0 ;
  {
  UTI_IPNetworkToHost((IPAddr const *)(& rx_message->data.modify_minpoll.address),
                      & address);
  tmp = __bswap_32((__uint32_t )rx_message->data.modify_minpoll.new_minpoll);
  tmp___0 = NSR_ModifyMaxpoll(& address, (int )tmp);
  if (! tmp___0) {
    tx_message->status = __bswap_16((__uint16_t )4);
  }
  return;
}
}
static void handle_modify_maxdelay(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  IPAddr address ;
  double tmp ;
  int tmp___0 ;
  {
  UTI_IPNetworkToHost((IPAddr const *)(& rx_message->data.modify_maxdelay.address),
                      & address);
  tmp = UTI_FloatNetworkToHost(rx_message->data.modify_maxdelay.new_max_delay);
  tmp___0 = NSR_ModifyMaxdelay(& address, tmp);
  if (! tmp___0) {
    tx_message->status = __bswap_16((__uint16_t )4);
  }
  return;
}
}
static void handle_modify_maxdelayratio(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  IPAddr address ;
  double tmp ;
  int tmp___0 ;
  {
  UTI_IPNetworkToHost((IPAddr const *)(& rx_message->data.modify_maxdelayratio.address),
                      & address);
  tmp = UTI_FloatNetworkToHost(rx_message->data.modify_maxdelayratio.new_max_delay_ratio);
  tmp___0 = NSR_ModifyMaxdelayratio(& address, tmp);
  if (! tmp___0) {
    tx_message->status = __bswap_16((__uint16_t )4);
  }
  return;
}
}
static void handle_modify_maxdelaydevratio(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  IPAddr address ;
  double tmp ;
  int tmp___0 ;
  {
  UTI_IPNetworkToHost((IPAddr const *)(& rx_message->data.modify_maxdelaydevratio.address),
                      & address);
  tmp = UTI_FloatNetworkToHost(rx_message->data.modify_maxdelaydevratio.new_max_delay_dev_ratio);
  tmp___0 = NSR_ModifyMaxdelaydevratio(& address, tmp);
  if (! tmp___0) {
    tx_message->status = __bswap_16((__uint16_t )4);
  }
  return;
}
}
static void handle_modify_minstratum(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  IPAddr address ;
  __uint32_t tmp ;
  int tmp___0 ;
  {
  UTI_IPNetworkToHost((IPAddr const *)(& rx_message->data.modify_minpoll.address),
                      & address);
  tmp = __bswap_32((__uint32_t )rx_message->data.modify_minstratum.new_min_stratum);
  tmp___0 = NSR_ModifyMinstratum(& address, (int )tmp);
  if (! tmp___0) {
    tx_message->status = __bswap_16((__uint16_t )4);
  }
  return;
}
}
static void handle_modify_polltarget(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  IPAddr address ;
  __uint32_t tmp ;
  int tmp___0 ;
  {
  UTI_IPNetworkToHost((IPAddr const *)(& rx_message->data.modify_polltarget.address),
                      & address);
  tmp = __bswap_32((__uint32_t )rx_message->data.modify_polltarget.new_poll_target);
  tmp___0 = NSR_ModifyPolltarget(& address, (int )tmp);
  if (! tmp___0) {
    tx_message->status = __bswap_16((__uint16_t )4);
  }
  return;
}
}
static void handle_modify_maxupdateskew(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  double tmp ;
  {
  tmp = UTI_FloatNetworkToHost(rx_message->data.modify_maxupdateskew.new_max_update_skew);
  REF_ModifyMaxupdateskew(tmp);
  return;
}
}
static void handle_modify_makestep(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  double tmp ;
  __uint32_t tmp___0 ;
  {
  tmp = UTI_FloatNetworkToHost(rx_message->data.modify_makestep.threshold);
  tmp___0 = __bswap_32((__uint32_t )rx_message->data.modify_makestep.limit);
  REF_ModifyMakestep((int )tmp___0, tmp);
  return;
}
}
static void handle_settime(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  struct timespec ts ;
  double offset ;
  double dfreq_ppm ;
  double new_afreq_ppm ;
  int tmp ;
  int tmp___0 ;
  {
  UTI_TimespecNetworkToHost((Timespec const *)(& rx_message->data.settime.ts), & ts);
  tmp___0 = MNL_IsEnabled();
  if (tmp___0) {
    tmp = MNL_AcceptTimestamp(& ts, & offset, & dfreq_ppm, & new_afreq_ppm);
    if (tmp) {
      tx_message->reply = __bswap_16((__uint16_t )17);
      tx_message->data.manual_timestamp.offset = UTI_FloatHostToNetwork(offset);
      tx_message->data.manual_timestamp.dfreq_ppm = UTI_FloatHostToNetwork(dfreq_ppm);
      tx_message->data.manual_timestamp.new_afreq_ppm = UTI_FloatHostToNetwork(new_afreq_ppm);
    } else {
      tx_message->status = __bswap_16((__uint16_t )1);
    }
  } else {
    tx_message->status = __bswap_16((__uint16_t )6);
  }
  return;
}
}
static void handle_local(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  __uint32_t tmp ;
  double tmp___0 ;
  __uint32_t tmp___1 ;
  __uint32_t tmp___2 ;
  {
  tmp___2 = __bswap_32((__uint32_t )rx_message->data.local.on_off);
  if (tmp___2) {
    tmp = __bswap_32((__uint32_t )rx_message->data.local.orphan);
    tmp___0 = UTI_FloatNetworkToHost(rx_message->data.local.distance);
    tmp___1 = __bswap_32((__uint32_t )rx_message->data.local.stratum);
    REF_EnableLocal((int )tmp___1, tmp___0, (int )tmp);
  } else {
    REF_DisableLocal();
  }
  return;
}
}
static void handle_manual(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  int option ;
  __uint32_t tmp ;
  {
  tmp = __bswap_32((__uint32_t )rx_message->data.manual.option);
  option = (int )tmp;
  {
  if (option == 0) {
    goto case_0;
  }
  if (option == 1) {
    goto case_1;
  }
  if (option == 2) {
    goto case_2;
  }
  goto switch_default;
  case_0:
  MNL_Disable();
  goto switch_break;
  case_1:
  MNL_Enable();
  goto switch_break;
  case_2:
  MNL_Reset();
  goto switch_break;
  switch_default:
  tx_message->status = __bswap_16((__uint16_t )3);
  goto switch_break;
  switch_break: ;
  }
  return;
}
}
static void handle_n_sources(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  int n_sources___1 ;
  {
  n_sources___1 = SRC_ReadNumberOfSources();
  tx_message->reply = __bswap_16((__uint16_t )2);
  tx_message->data.n_sources.n_sources = __bswap_32((__uint32_t )n_sources___1);
  return;
}
}
static void handle_source_data(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  RPT_SourceReport report ;
  struct timespec now_corr ;
  __uint32_t tmp ;
  SRC_Type tmp___0 ;
  __uint16_t tmp___1 ;
  __uint32_t tmp___2 ;
  int tmp___3 ;
  {
  SCH_GetLastEventTime(& now_corr, (double *)((void *)0), (struct timespec *)((void *)0));
  tmp___2 = __bswap_32((__uint32_t )rx_message->data.source_data.index);
  tmp___3 = SRC_ReportSource((int )tmp___2, & report, & now_corr);
  if (tmp___3) {
    tmp = __bswap_32((__uint32_t )rx_message->data.source_data.index);
    tmp___0 = SRC_GetType((int )tmp);
    {
    if ((unsigned int )tmp___0 == 0U) {
      goto case_0;
    }
    if ((unsigned int )tmp___0 == 1U) {
      goto case_1;
    }
    goto switch_break;
    case_0:
    NSR_ReportSource(& report, & now_corr);
    goto switch_break;
    case_1:
    RCL_ReportSource(& report, & now_corr);
    goto switch_break;
    switch_break: ;
    }
    tx_message->reply = __bswap_16((__uint16_t )3);
    UTI_IPHostToNetwork((IPAddr const *)(& report.ip_addr), & tx_message->data.source_data.ip_addr);
    tx_message->data.source_data.stratum = __bswap_16((__uint16_t )report.stratum);
    tmp___1 = __bswap_16((__uint16_t )report.poll);
    tx_message->data.source_data.poll = (int16_t )tmp___1;
    {
    if ((unsigned int )report.state == 0U) {
      goto case_0___0;
    }
    if ((unsigned int )report.state == 1U) {
      goto case_1___0;
    }
    if ((unsigned int )report.state == 2U) {
      goto case_2;
    }
    if ((unsigned int )report.state == 3U) {
      goto case_3;
    }
    if ((unsigned int )report.state == 4U) {
      goto case_4;
    }
    if ((unsigned int )report.state == 5U) {
      goto case_5;
    }
    goto switch_break___0;
    case_0___0:
    tx_message->data.source_data.state = __bswap_16((__uint16_t )1);
    goto switch_break___0;
    case_1___0:
    tx_message->data.source_data.state = __bswap_16((__uint16_t )2);
    goto switch_break___0;
    case_2:
    tx_message->data.source_data.state = __bswap_16((__uint16_t )3);
    goto switch_break___0;
    case_3:
    tx_message->data.source_data.state = __bswap_16((__uint16_t )5);
    goto switch_break___0;
    case_4:
    tx_message->data.source_data.state = __bswap_16((__uint16_t )4);
    goto switch_break___0;
    case_5:
    tx_message->data.source_data.state = __bswap_16((__uint16_t )0);
    goto switch_break___0;
    switch_break___0: ;
    }
    {
    if ((unsigned int )report.mode == 0U) {
      goto case_0___1;
    }
    if ((unsigned int )report.mode == 1U) {
      goto case_1___1;
    }
    if ((unsigned int )report.mode == 2U) {
      goto case_2___0;
    }
    goto switch_break___1;
    case_0___1:
    tx_message->data.source_data.mode = __bswap_16((__uint16_t )0);
    goto switch_break___1;
    case_1___1:
    tx_message->data.source_data.mode = __bswap_16((__uint16_t )1);
    goto switch_break___1;
    case_2___0:
    tx_message->data.source_data.mode = __bswap_16((__uint16_t )2);
    goto switch_break___1;
    switch_break___1: ;
    }
    tx_message->data.source_data.flags = __bswap_16((__uint16_t )0);
    tx_message->data.source_data.reachability = __bswap_16((__uint16_t )report.reachability);
    tx_message->data.source_data.since_sample = __bswap_32((__uint32_t )report.latest_meas_ago);
    tx_message->data.source_data.orig_latest_meas = UTI_FloatHostToNetwork(report.orig_latest_meas);
    tx_message->data.source_data.latest_meas = UTI_FloatHostToNetwork(report.latest_meas);
    tx_message->data.source_data.latest_meas_err = UTI_FloatHostToNetwork(report.latest_meas_err);
  } else {
    tx_message->status = __bswap_16((__uint16_t )4);
  }
  return;
}
}
static void handle_rekey(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  {
  KEY_Reload();
  NKS_ReloadKeys();
  return;
}
}
static void handle_allowdeny(CMD_Request *rx_message , CMD_Reply *tx_message , int allow ,
                             int all )
{
  IPAddr ip ;
  int subnet_bits ;
  __uint32_t tmp ;
  int tmp___0 ;
  {
  UTI_IPNetworkToHost((IPAddr const *)(& rx_message->data.allow_deny.ip), & ip);
  tmp = __bswap_32((__uint32_t )rx_message->data.allow_deny.subnet_bits);
  subnet_bits = (int )tmp;
  tmp___0 = NCR_AddAccessRestriction(& ip, subnet_bits, allow, all);
  if (! tmp___0) {
    tx_message->status = __bswap_16((__uint16_t )7);
  }
  return;
}
}
static void handle_cmdallowdeny(CMD_Request *rx_message , CMD_Reply *tx_message ,
                                int allow , int all )
{
  IPAddr ip ;
  int subnet_bits ;
  __uint32_t tmp ;
  int tmp___0 ;
  {
  UTI_IPNetworkToHost((IPAddr const *)(& rx_message->data.allow_deny.ip), & ip);
  tmp = __bswap_32((__uint32_t )rx_message->data.allow_deny.subnet_bits);
  subnet_bits = (int )tmp;
  tmp___0 = CAM_AddAccessRestriction(& ip, subnet_bits, allow, all);
  if (! tmp___0) {
    tx_message->status = __bswap_16((__uint16_t )7);
  }
  return;
}
}
static void handle_accheck(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  IPAddr ip ;
  int tmp ;
  {
  UTI_IPNetworkToHost((IPAddr const *)(& rx_message->data.ac_check.ip), & ip);
  tmp = NCR_CheckAccessRestriction(& ip);
  if (tmp) {
    tx_message->status = __bswap_16((__uint16_t )8);
  } else {
    tx_message->status = __bswap_16((__uint16_t )9);
  }
  return;
}
}
static void handle_cmdaccheck(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  IPAddr ip ;
  int tmp ;
  {
  UTI_IPNetworkToHost((IPAddr const *)(& rx_message->data.ac_check.ip), & ip);
  tmp = CAM_CheckAccessRestriction(& ip);
  if (tmp) {
    tx_message->status = __bswap_16((__uint16_t )8);
  } else {
    tx_message->status = __bswap_16((__uint16_t )9);
  }
  return;
}
}
static void handle_add_source(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  NTP_Source_Type type ;
  SourceParameters params ;
  NSR_Status status ;
  char *name ;
  int pool ;
  int port ;
  __uint32_t tmp ;
  __uint32_t tmp___0 ;
  __uint32_t tmp___1 ;
  __uint32_t tmp___2 ;
  __uint32_t tmp___3 ;
  __uint32_t tmp___4 ;
  __uint32_t tmp___5 ;
  __uint32_t tmp___6 ;
  __uint32_t tmp___7 ;
  __uint32_t tmp___8 ;
  __uint32_t tmp___9 ;
  __uint32_t tmp___10 ;
  __uint32_t tmp___11 ;
  __uint32_t tmp___12 ;
  __uint32_t tmp___13 ;
  __uint32_t tmp___14 ;
  __uint32_t tmp___15 ;
  __uint32_t tmp___16 ;
  __uint32_t tmp___17 ;
  __uint32_t tmp___18 ;
  __uint32_t tmp___19 ;
  __uint32_t tmp___20 ;
  __uint32_t tmp___21 ;
  __uint32_t tmp___22 ;
  __uint32_t tmp___23 ;
  __uint32_t tmp___24 ;
  __uint32_t tmp___25 ;
  __uint32_t tmp___26 ;
  __uint32_t tmp___27 ;
  __uint32_t tmp___28 ;
  int tmp___29 ;
  __uint32_t tmp___30 ;
  __uint32_t tmp___31 ;
  int tmp___32 ;
  __uint32_t tmp___33 ;
  __uint32_t tmp___34 ;
  int tmp___35 ;
  __uint32_t tmp___36 ;
  __uint32_t tmp___37 ;
  int tmp___38 ;
  __uint32_t tmp___39 ;
  {
  tmp = __bswap_32(rx_message->data.ntp_source.type);
  {
  if (tmp == 1U) {
    goto case_1;
  }
  if (tmp == 2U) {
    goto case_2;
  }
  if (tmp == 3U) {
    goto case_3;
  }
  goto switch_default;
  case_1:
  type = (NTP_Source_Type )0;
  pool = 0;
  goto switch_break;
  case_2:
  type = (NTP_Source_Type )1;
  pool = 0;
  goto switch_break;
  case_3:
  type = (NTP_Source_Type )0;
  pool = 1;
  goto switch_break;
  switch_default:
  tx_message->status = __bswap_16((__uint16_t )3);
  return;
  switch_break: ;
  }
  name = (char *)(rx_message->data.ntp_source.name);
  if ((int )*(name + (sizeof(rx_message->data.ntp_source.name) - 1UL)) != 0) {
    tx_message->status = __bswap_16((__uint16_t )21);
    return;
  }
  tmp___0 = __bswap_32(rx_message->data.ntp_source.port);
  port = (int )tmp___0;
  tmp___1 = __bswap_32((__uint32_t )rx_message->data.ntp_source.minpoll);
  params.minpoll = (int )tmp___1;
  tmp___2 = __bswap_32((__uint32_t )rx_message->data.ntp_source.maxpoll);
  params.maxpoll = (int )tmp___2;
  tmp___3 = __bswap_32((__uint32_t )rx_message->data.ntp_source.presend_minpoll);
  params.presend_minpoll = (int )tmp___3;
  tmp___4 = __bswap_32(rx_message->data.ntp_source.min_stratum);
  params.min_stratum = (int )tmp___4;
  tmp___5 = __bswap_32(rx_message->data.ntp_source.poll_target);
  params.poll_target = (int )tmp___5;
  tmp___6 = __bswap_32(rx_message->data.ntp_source.version);
  params.version = (int )tmp___6;
  tmp___7 = __bswap_32(rx_message->data.ntp_source.max_sources);
  params.max_sources = (int )tmp___7;
  tmp___8 = __bswap_32((__uint32_t )rx_message->data.ntp_source.min_samples);
  params.min_samples = (int )tmp___8;
  tmp___9 = __bswap_32((__uint32_t )rx_message->data.ntp_source.max_samples);
  params.max_samples = (int )tmp___9;
  tmp___10 = __bswap_32((__uint32_t )rx_message->data.ntp_source.filter_length);
  params.filter_length = (int )tmp___10;
  params.authkey = __bswap_32(rx_message->data.ntp_source.authkey);
  tmp___11 = __bswap_32(rx_message->data.ntp_source.nts_port);
  params.nts_port = (int )tmp___11;
  params.cert_set = __bswap_32(rx_message->data.ntp_source.cert_set);
  params.max_delay = UTI_FloatNetworkToHost(rx_message->data.ntp_source.max_delay);
  params.max_delay_ratio = UTI_FloatNetworkToHost(rx_message->data.ntp_source.max_delay_ratio);
  params.max_delay_dev_ratio = UTI_FloatNetworkToHost(rx_message->data.ntp_source.max_delay_dev_ratio);
  params.min_delay = UTI_FloatNetworkToHost(rx_message->data.ntp_source.min_delay);
  params.asymmetry = UTI_FloatNetworkToHost(rx_message->data.ntp_source.asymmetry);
  params.offset = UTI_FloatNetworkToHost(rx_message->data.ntp_source.offset);
  tmp___13 = __bswap_32(rx_message->data.ntp_source.flags);
  if (tmp___13 & 1U) {
    params.connectivity = (SRC_Connectivity )1;
  } else {
    params.connectivity = (SRC_Connectivity )0;
  }
  tmp___15 = __bswap_32(rx_message->data.ntp_source.flags);
  if (tmp___15 & 2U) {
    params.auto_offline = 1;
  } else {
    params.auto_offline = 0;
  }
  tmp___17 = __bswap_32(rx_message->data.ntp_source.flags);
  if (tmp___17 & 4U) {
    params.iburst = 1;
  } else {
    params.iburst = 0;
  }
  tmp___19 = __bswap_32(rx_message->data.ntp_source.flags);
  if (tmp___19 & 128U) {
    params.interleaved = 1;
  } else {
    params.interleaved = 0;
  }
  tmp___21 = __bswap_32(rx_message->data.ntp_source.flags);
  if (tmp___21 & 256U) {
    params.burst = 1;
  } else {
    params.burst = 0;
  }
  tmp___23 = __bswap_32(rx_message->data.ntp_source.flags);
  if (tmp___23 & 512U) {
    params.nts = 1;
  } else {
    params.nts = 0;
  }
  tmp___25 = __bswap_32(rx_message->data.ntp_source.flags);
  if (tmp___25 & 1024U) {
    params.copy = 1;
  } else {
    params.copy = 0;
  }
  tmp___27 = __bswap_32(rx_message->data.ntp_source.flags);
  if (tmp___27 & 2048U) {
    params.ext_fields = 0x1;
  } else {
    params.ext_fields = 0;
  }
  tmp___30 = __bswap_32(rx_message->data.ntp_source.flags);
  if (tmp___30 & 8U) {
    tmp___29 = 0x2;
  } else {
    tmp___29 = 0;
  }
  tmp___33 = __bswap_32(rx_message->data.ntp_source.flags);
  if (tmp___33 & 16U) {
    tmp___32 = 0x1;
  } else {
    tmp___32 = 0;
  }
  tmp___36 = __bswap_32(rx_message->data.ntp_source.flags);
  if (tmp___36 & 32U) {
    tmp___35 = 0x4;
  } else {
    tmp___35 = 0;
  }
  tmp___39 = __bswap_32(rx_message->data.ntp_source.flags);
  if (tmp___39 & 64U) {
    tmp___38 = 0x8;
  } else {
    tmp___38 = 0;
  }
  params.sel_options = ((tmp___29 | tmp___32) | tmp___35) | tmp___38;
  status = NSR_AddSourceByName(name, port, pool, type, & params, (uint32_t *)((void *)0));
  {
  if ((unsigned int )status == 0U) {
    goto case_0;
  }
  if ((unsigned int )status == 6U) {
    goto case_6;
  }
  if ((unsigned int )status == 2U) {
    goto case_2___0;
  }
  if ((unsigned int )status == 3U) {
    goto case_3___0;
  }
  if ((unsigned int )status == 5U) {
    goto case_5;
  }
  if ((unsigned int )status == 1U) {
    goto case_1___0;
  }
  if ((unsigned int )status == 4U) {
    goto case_1___0;
  }
  goto switch_break___0;
  case_0:
  goto switch_break___0;
  case_6:
  NSR_ResolveSources();
  goto switch_break___0;
  case_2___0:
  tx_message->status = __bswap_16((__uint16_t )11);
  goto switch_break___0;
  case_3___0:
  tx_message->status = __bswap_16((__uint16_t )12);
  goto switch_break___0;
  case_5:
  tx_message->status = __bswap_16((__uint16_t )21);
  goto switch_break___0;
  case_1___0:
  case_4:
  assert(0);
  goto switch_break___0;
  switch_break___0: ;
  }
  return;
}
}
static void handle_del_source(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  NSR_Status status ;
  IPAddr ip_addr ;
  {
  UTI_IPNetworkToHost((IPAddr const *)(& rx_message->data.del_source.ip_addr), & ip_addr);
  status = NSR_RemoveSource(& ip_addr);
  {
  if ((unsigned int )status == 0U) {
    goto case_0;
  }
  if ((unsigned int )status == 1U) {
    goto case_1;
  }
  if ((unsigned int )status == 6U) {
    goto case_6;
  }
  if ((unsigned int )status == 5U) {
    goto case_6;
  }
  if ((unsigned int )status == 4U) {
    goto case_6;
  }
  if ((unsigned int )status == 2U) {
    goto case_6;
  }
  if ((unsigned int )status == 3U) {
    goto case_6;
  }
  goto switch_break;
  case_0:
  goto switch_break;
  case_1:
  tx_message->status = __bswap_16((__uint16_t )4);
  goto switch_break;
  case_6:
  case_5:
  case_4:
  case_2:
  case_3:
  assert(0);
  goto switch_break;
  switch_break: ;
  }
  return;
}
}
static void handle_writertc(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  int tmp ;
  {
  tmp = RTC_WriteParameters();
  {
  if (tmp == 0) {
    goto case_0;
  }
  if (tmp == 1) {
    goto case_1;
  }
  if (tmp == 2) {
    goto case_2;
  }
  goto switch_break;
  case_0:
  goto switch_break;
  case_1:
  tx_message->status = __bswap_16((__uint16_t )13);
  goto switch_break;
  case_2:
  tx_message->status = __bswap_16((__uint16_t )14);
  goto switch_break;
  switch_break: ;
  }
  return;
}
}
static void handle_dfreq(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  double dfreq ;
  {
  dfreq = UTI_FloatNetworkToHost(rx_message->data.dfreq.dfreq);
  LCL_AccumulateDeltaFrequency(dfreq * 1.0e-6);
  LOG_Message((LOG_Severity )0, (char const *)"Accumulated delta freq of %.3fppm",
              dfreq);
  return;
}
}
static void handle_doffset(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  double doffset ;
  int tmp ;
  {
  doffset = UTI_FloatNetworkToHost(rx_message->data.doffset.doffset);
  tmp = LCL_AccumulateOffset(doffset, 0.0);
  if (tmp) {
    LOG_Message((LOG_Severity )0, (char const *)"Accumulated delta offset of %.6f seconds",
                doffset);
  } else {
    tx_message->status = __bswap_16((__uint16_t )1);
  }
  return;
}
}
static void handle_tracking(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  RPT_TrackingReport rpt ;
  {
  REF_GetTrackingReport(& rpt);
  tx_message->reply = __bswap_16((__uint16_t )5);
  tx_message->data.tracking.ref_id = __bswap_32(rpt.ref_id);
  UTI_IPHostToNetwork((IPAddr const *)(& rpt.ip_addr), & tx_message->data.tracking.ip_addr);
  tx_message->data.tracking.stratum = __bswap_16((__uint16_t )rpt.stratum);
  tx_message->data.tracking.leap_status = __bswap_16((__uint16_t )rpt.leap_status);
  UTI_TimespecHostToNetwork((struct timespec const *)(& rpt.ref_time), & tx_message->data.tracking.ref_time);
  tx_message->data.tracking.current_correction = UTI_FloatHostToNetwork(rpt.current_correction);
  tx_message->data.tracking.last_offset = UTI_FloatHostToNetwork(rpt.last_offset);
  tx_message->data.tracking.rms_offset = UTI_FloatHostToNetwork(rpt.rms_offset);
  tx_message->data.tracking.freq_ppm = UTI_FloatHostToNetwork(rpt.freq_ppm);
  tx_message->data.tracking.resid_freq_ppm = UTI_FloatHostToNetwork(rpt.resid_freq_ppm);
  tx_message->data.tracking.skew_ppm = UTI_FloatHostToNetwork(rpt.skew_ppm);
  tx_message->data.tracking.root_delay = UTI_FloatHostToNetwork(rpt.root_delay);
  tx_message->data.tracking.root_dispersion = UTI_FloatHostToNetwork(rpt.root_dispersion);
  tx_message->data.tracking.last_update_interval = UTI_FloatHostToNetwork(rpt.last_update_interval);
  return;
}
}
static void handle_smoothing(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  RPT_SmoothingReport report ;
  struct timespec now ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  SCH_GetLastEventTime(& now, (double *)((void *)0), (struct timespec *)((void *)0));
  tmp = SMT_GetSmoothingReport(& report, & now);
  if (! tmp) {
    tx_message->status = __bswap_16((__uint16_t )6);
    return;
  }
  tx_message->reply = __bswap_16((__uint16_t )13);
  if (report.active) {
    tmp___0 = 0x1;
  } else {
    tmp___0 = 0;
  }
  if (report.leap_only) {
    tmp___1 = 0x2;
  } else {
    tmp___1 = 0;
  }
  tx_message->data.smoothing.flags = __bswap_32((__uint32_t )(tmp___0 | tmp___1));
  tx_message->data.smoothing.offset = UTI_FloatHostToNetwork(report.offset);
  tx_message->data.smoothing.freq_ppm = UTI_FloatHostToNetwork(report.freq_ppm);
  tx_message->data.smoothing.wander_ppm = UTI_FloatHostToNetwork(report.wander_ppm);
  tx_message->data.smoothing.last_update_ago = UTI_FloatHostToNetwork(report.last_update_ago);
  tx_message->data.smoothing.remaining_time = UTI_FloatHostToNetwork(report.remaining_time);
  return;
}
}
static void handle_smoothtime(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  struct timespec now ;
  int option ;
  int tmp ;
  __uint32_t tmp___0 ;
  {
  tmp = SMT_IsEnabled();
  if (! tmp) {
    tx_message->status = __bswap_16((__uint16_t )6);
    return;
  }
  tmp___0 = __bswap_32((__uint32_t )rx_message->data.smoothtime.option);
  option = (int )tmp___0;
  SCH_GetLastEventTime(& now, (double *)((void *)0), (struct timespec *)((void *)0));
  {
  if (option == 0) {
    goto case_0;
  }
  if (option == 1) {
    goto case_1;
  }
  goto switch_default;
  case_0:
  SMT_Reset(& now);
  goto switch_break;
  case_1:
  SMT_Activate(& now);
  goto switch_break;
  switch_default:
  tx_message->status = __bswap_16((__uint16_t )3);
  goto switch_break;
  switch_break: ;
  }
  return;
}
}
static void handle_sourcestats(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  int status ;
  RPT_SourcestatsReport report ;
  struct timespec now_corr ;
  __uint32_t tmp ;
  {
  SCH_GetLastEventTime(& now_corr, (double *)((void *)0), (struct timespec *)((void *)0));
  tmp = __bswap_32(rx_message->data.sourcestats.index);
  status = SRC_ReportSourcestats((int )tmp, & report, & now_corr);
  if (status) {
    tx_message->reply = __bswap_16((__uint16_t )6);
    tx_message->data.sourcestats.ref_id = __bswap_32(report.ref_id);
    UTI_IPHostToNetwork((IPAddr const *)(& report.ip_addr), & tx_message->data.sourcestats.ip_addr);
    tx_message->data.sourcestats.n_samples = __bswap_32((__uint32_t )report.n_samples);
    tx_message->data.sourcestats.n_runs = __bswap_32((__uint32_t )report.n_runs);
    tx_message->data.sourcestats.span_seconds = __bswap_32((__uint32_t )report.span_seconds);
    tx_message->data.sourcestats.resid_freq_ppm = UTI_FloatHostToNetwork(report.resid_freq_ppm);
    tx_message->data.sourcestats.skew_ppm = UTI_FloatHostToNetwork(report.skew_ppm);
    tx_message->data.sourcestats.sd = UTI_FloatHostToNetwork(report.sd);
    tx_message->data.sourcestats.est_offset = UTI_FloatHostToNetwork(report.est_offset);
    tx_message->data.sourcestats.est_offset_err = UTI_FloatHostToNetwork(report.est_offset_err);
  } else {
    tx_message->status = __bswap_16((__uint16_t )4);
  }
  return;
}
}
static void handle_rtcreport(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  int status ;
  RPT_RTC_Report report ;
  {
  status = RTC_GetReport(& report);
  if (status) {
    tx_message->reply = __bswap_16((__uint16_t )7);
    UTI_TimespecHostToNetwork((struct timespec const *)(& report.ref_time), & tx_message->data.rtc.ref_time);
    tx_message->data.rtc.n_samples = __bswap_16((__uint16_t )report.n_samples);
    tx_message->data.rtc.n_runs = __bswap_16((__uint16_t )report.n_runs);
    tx_message->data.rtc.span_seconds = __bswap_32((__uint32_t )report.span_seconds);
    tx_message->data.rtc.rtc_seconds_fast = UTI_FloatHostToNetwork(report.rtc_seconds_fast);
    tx_message->data.rtc.rtc_gain_rate_ppm = UTI_FloatHostToNetwork(report.rtc_gain_rate_ppm);
  } else {
    tx_message->status = __bswap_16((__uint16_t )13);
  }
  return;
}
}
static void handle_trimrtc(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  int tmp ;
  {
  tmp = RTC_Trim();
  if (! tmp) {
    tx_message->status = __bswap_16((__uint16_t )13);
  }
  return;
}
}
static void handle_cyclelogs(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  {
  LOG_CycleLogFiles();
  return;
}
}
static void handle_client_accesses_by_index(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  RPT_ClientAccessByIndex_Report report ;
  RPY_ClientAccesses_Client *client ;
  int n_indices ;
  uint32_t i ;
  uint32_t j ;
  uint32_t req_first_index ;
  uint32_t req_n_clients ;
  uint32_t req_min_hits ;
  uint32_t req_reset ;
  struct timespec now ;
  int tmp ;
  uint32_t tmp___0 ;
  {
  SCH_GetLastEventTime(& now, (double *)((void *)0), (struct timespec *)((void *)0));
  req_first_index = __bswap_32(rx_message->data.client_accesses_by_index.first_index);
  req_n_clients = __bswap_32(rx_message->data.client_accesses_by_index.n_clients);
  if (req_n_clients > 8U) {
    req_n_clients = (uint32_t )8;
  }
  req_min_hits = __bswap_32(rx_message->data.client_accesses_by_index.min_hits);
  req_reset = __bswap_32(rx_message->data.client_accesses_by_index.reset);
  n_indices = CLG_GetNumberOfIndices();
  if (n_indices < 0) {
    tx_message->status = __bswap_16((__uint16_t )15);
    return;
  }
  tx_message->reply = __bswap_16((__uint16_t )21);
  tx_message->data.client_accesses_by_index.n_indices = __bswap_32((__uint32_t )n_indices);
  i = req_first_index;
  j = (uint32_t )0;
  {
  while (1) {
    while_continue: ;
    if (i < (uint32_t )n_indices) {
      if (! (j < req_n_clients)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    tmp = CLG_GetClientAccessReportByIndex((int )i, (int )req_reset, req_min_hits,
                                           & report, & now);
    if (! tmp) {
      goto __Cont;
    }
    tmp___0 = j;
    j ++;
    client = & tx_message->data.client_accesses_by_index.clients[tmp___0];
    UTI_IPHostToNetwork((IPAddr const *)(& report.ip_addr), & client->ip);
    client->ntp_hits = __bswap_32(report.ntp_hits);
    client->nke_hits = __bswap_32(report.nke_hits);
    client->cmd_hits = __bswap_32(report.cmd_hits);
    client->ntp_drops = __bswap_32((__uint32_t )report.ntp_drops);
    client->nke_drops = __bswap_32((__uint32_t )report.nke_drops);
    client->cmd_drops = __bswap_32((__uint32_t )report.cmd_drops);
    client->ntp_interval = report.ntp_interval;
    client->nke_interval = report.nke_interval;
    client->cmd_interval = report.cmd_interval;
    client->ntp_timeout_interval = report.ntp_timeout_interval;
    client->last_ntp_hit_ago = __bswap_32(report.last_ntp_hit_ago);
    client->last_nke_hit_ago = __bswap_32(report.last_nke_hit_ago);
    client->last_cmd_hit_ago = __bswap_32(report.last_cmd_hit_ago);
    __Cont:
    i ++;
  }
  while_break: ;
  }
  tx_message->data.client_accesses_by_index.next_index = __bswap_32(i);
  tx_message->data.client_accesses_by_index.n_clients = __bswap_32(j);
  return;
}
}
static void handle_manual_list(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  int n_samples___1 ;
  int i ;
  RPY_ManualListSample *sample ;
  RPT_ManualSamplesReport report[16] ;
  {
  tx_message->reply = __bswap_16((__uint16_t )18);
  MNL_ReportSamples(report, 16, & n_samples___1);
  tx_message->data.manual_list.n_samples = __bswap_32((__uint32_t )n_samples___1);
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < n_samples___1)) {
      goto while_break;
    }
    sample = & tx_message->data.manual_list.samples[i];
    UTI_TimespecHostToNetwork((struct timespec const *)(& report[i].when), & sample->when);
    sample->slewed_offset = UTI_FloatHostToNetwork(report[i].slewed_offset);
    sample->orig_offset = UTI_FloatHostToNetwork(report[i].orig_offset);
    sample->residual = UTI_FloatHostToNetwork(report[i].residual);
    i ++;
  }
  while_break: ;
  }
  return;
}
}
static void handle_manual_delete(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  int index___0 ;
  __uint32_t tmp ;
  int tmp___0 ;
  {
  tmp = __bswap_32((__uint32_t )rx_message->data.manual_delete.index);
  index___0 = (int )tmp;
  tmp___0 = MNL_DeleteSample(index___0);
  if (! tmp___0) {
    tx_message->status = __bswap_16((__uint16_t )16);
  }
  return;
}
}
static void handle_make_step(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  int tmp ;
  {
  tmp = LCL_MakeStep();
  if (! tmp) {
    tx_message->status = __bswap_16((__uint16_t )1);
  }
  return;
}
}
static void handle_activity(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  RPT_ActivityReport report ;
  __uint32_t tmp ;
  __uint32_t tmp___0 ;
  __uint32_t tmp___1 ;
  __uint32_t tmp___2 ;
  __uint32_t tmp___3 ;
  {
  NSR_GetActivityReport(& report);
  tmp = __bswap_32((__uint32_t )report.online);
  tx_message->data.activity.online = (int32_t )tmp;
  tmp___0 = __bswap_32((__uint32_t )report.offline);
  tx_message->data.activity.offline = (int32_t )tmp___0;
  tmp___1 = __bswap_32((__uint32_t )report.burst_online);
  tx_message->data.activity.burst_online = (int32_t )tmp___1;
  tmp___2 = __bswap_32((__uint32_t )report.burst_offline);
  tx_message->data.activity.burst_offline = (int32_t )tmp___2;
  tmp___3 = __bswap_32((__uint32_t )report.unresolved);
  tx_message->data.activity.unresolved = (int32_t )tmp___3;
  tx_message->reply = __bswap_16((__uint16_t )12);
  return;
}
}
static void handle_reselect_distance(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  double dist ;
  {
  dist = UTI_FloatNetworkToHost(rx_message->data.reselect_distance.distance);
  SRC_SetReselectDistance(dist);
  return;
}
}
static void handle_reselect(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  {
  SRC_ReselectSource();
  return;
}
}
static void handle_refresh(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  {
  NSR_RefreshAddresses();
  return;
}
}
static void handle_server_stats(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  RPT_ServerStatsReport report ;
  {
  CLG_GetServerStatsReport(& report);
  tx_message->reply = __bswap_16((__uint16_t )24);
  tx_message->data.server_stats.ntp_hits = __bswap_32(report.ntp_hits);
  tx_message->data.server_stats.nke_hits = __bswap_32(report.nke_hits);
  tx_message->data.server_stats.cmd_hits = __bswap_32(report.cmd_hits);
  tx_message->data.server_stats.ntp_drops = __bswap_32(report.ntp_drops);
  tx_message->data.server_stats.nke_drops = __bswap_32(report.nke_drops);
  tx_message->data.server_stats.cmd_drops = __bswap_32(report.cmd_drops);
  tx_message->data.server_stats.log_drops = __bswap_32(report.log_drops);
  tx_message->data.server_stats.ntp_auth_hits = __bswap_32(report.ntp_auth_hits);
  tx_message->data.server_stats.ntp_interleaved_hits = __bswap_32(report.ntp_interleaved_hits);
  tx_message->data.server_stats.ntp_timestamps = __bswap_32(report.ntp_timestamps);
  tx_message->data.server_stats.ntp_span_seconds = __bswap_32(report.ntp_span_seconds);
  return;
}
}
static void handle_ntp_data(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  RPT_NTPReport report ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  UTI_IPNetworkToHost((IPAddr const *)(& rx_message->data.ntp_data.ip_addr), & report.remote_addr);
  tmp = NSR_GetNTPReport(& report);
  if (! tmp) {
    tx_message->status = __bswap_16((__uint16_t )4);
    return;
  }
  tx_message->reply = __bswap_16((__uint16_t )16);
  UTI_IPHostToNetwork((IPAddr const *)(& report.remote_addr), & tx_message->data.ntp_data.remote_addr);
  UTI_IPHostToNetwork((IPAddr const *)(& report.local_addr), & tx_message->data.ntp_data.local_addr);
  tx_message->data.ntp_data.remote_port = __bswap_16(report.remote_port);
  tx_message->data.ntp_data.leap = report.leap;
  tx_message->data.ntp_data.version = report.version;
  tx_message->data.ntp_data.mode = report.mode;
  tx_message->data.ntp_data.stratum = report.stratum;
  tx_message->data.ntp_data.poll = report.poll;
  tx_message->data.ntp_data.precision = report.precision;
  tx_message->data.ntp_data.root_delay = UTI_FloatHostToNetwork(report.root_delay);
  tx_message->data.ntp_data.root_dispersion = UTI_FloatHostToNetwork(report.root_dispersion);
  tx_message->data.ntp_data.ref_id = __bswap_32(report.ref_id);
  UTI_TimespecHostToNetwork((struct timespec const *)(& report.ref_time), & tx_message->data.ntp_data.ref_time);
  tx_message->data.ntp_data.offset = UTI_FloatHostToNetwork(report.offset);
  tx_message->data.ntp_data.peer_delay = UTI_FloatHostToNetwork(report.peer_delay);
  tx_message->data.ntp_data.peer_dispersion = UTI_FloatHostToNetwork(report.peer_dispersion);
  tx_message->data.ntp_data.response_time = UTI_FloatHostToNetwork(report.response_time);
  tx_message->data.ntp_data.jitter_asymmetry = UTI_FloatHostToNetwork(report.jitter_asymmetry);
  if (report.interleaved) {
    tmp___0 = 0x4000;
  } else {
    tmp___0 = 0;
  }
  if (report.authenticated) {
    tmp___1 = 0x8000;
  } else {
    tmp___1 = 0;
  }
  tx_message->data.ntp_data.flags = __bswap_16((__uint16_t )((((int )report.tests & 0x3ff) | tmp___0) | tmp___1));
  tx_message->data.ntp_data.tx_tss_char = (uint8_t )report.tx_tss_char;
  tx_message->data.ntp_data.rx_tss_char = (uint8_t )report.rx_tss_char;
  tx_message->data.ntp_data.total_tx_count = __bswap_32(report.total_tx_count);
  tx_message->data.ntp_data.total_rx_count = __bswap_32(report.total_rx_count);
  tx_message->data.ntp_data.total_valid_count = __bswap_32(report.total_valid_count);
  memset((void *)(tx_message->data.ntp_data.reserved), 0xff, sizeof(tx_message->data.ntp_data.reserved));
  return;
}
}
static void handle_shutdown(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  {
  LOG_Message((LOG_Severity )0, (char const *)"Received shutdown command");
  SCH_QuitProgram();
  return;
}
}
static void handle_ntp_source_name(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  IPAddr addr ;
  char *name ;
  size_t tmp ;
  {
  UTI_IPNetworkToHost((IPAddr const *)(& rx_message->data.ntp_source_name.ip_addr),
                      & addr);
  name = NSR_GetName(& addr);
  if (! name) {
    tx_message->status = __bswap_16((__uint16_t )4);
    return;
  }
  tx_message->reply = __bswap_16((__uint16_t )19);
  tmp = strlen((char const *)name);
  if (tmp >= sizeof(tx_message->data.ntp_source_name.name)) {
    memcpy((void *)(tx_message->data.ntp_source_name.name), (void const *)name,
           sizeof(tx_message->data.ntp_source_name.name));
  } else {
    strncpy((char *)(tx_message->data.ntp_source_name.name), (char const *)name,
            sizeof(tx_message->data.ntp_source_name.name));
  }
  return;
}
}
static void handle_reload_sources(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  {
  CNF_ReloadSources();
  return;
}
}
static void handle_reset_sources(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  struct timespec cooked_now ;
  struct timespec now ;
  {
  SRC_ResetSources();
  SCH_GetLastEventTime(& cooked_now, (double *)((void *)0), & now);
  LCL_NotifyExternalTimeStep(& now, & cooked_now, 0.0, 0.0);
  return;
}
}
static void handle_auth_data(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  RPT_AuthReport report ;
  IPAddr ip_addr ;
  int tmp ;
  {
  UTI_IPNetworkToHost((IPAddr const *)(& rx_message->data.auth_data.ip_addr), & ip_addr);
  tmp = NSR_GetAuthReport(& ip_addr, & report);
  if (! tmp) {
    tx_message->status = __bswap_16((__uint16_t )4);
    return;
  }
  tx_message->reply = __bswap_16((__uint16_t )20);
  {
  if ((unsigned int )report.mode == 0U) {
    goto case_0;
  }
  if ((unsigned int )report.mode == 1U) {
    goto case_1;
  }
  if ((unsigned int )report.mode == 4U) {
    goto case_4;
  }
  goto switch_default;
  case_0:
  tx_message->data.auth_data.mode = __bswap_16((__uint16_t )0);
  goto switch_break;
  case_1:
  tx_message->data.auth_data.mode = __bswap_16((__uint16_t )1);
  goto switch_break;
  case_4:
  tx_message->data.auth_data.mode = __bswap_16((__uint16_t )2);
  goto switch_break;
  switch_default:
  goto switch_break;
  switch_break: ;
  }
  tx_message->data.auth_data.key_type = __bswap_16((__uint16_t )report.key_type);
  tx_message->data.auth_data.key_id = __bswap_32(report.key_id);
  tx_message->data.auth_data.key_length = __bswap_16((__uint16_t )report.key_length);
  tx_message->data.auth_data.ke_attempts = __bswap_16((__uint16_t )report.ke_attempts);
  tx_message->data.auth_data.last_ke_ago = __bswap_32(report.last_ke_ago);
  tx_message->data.auth_data.cookies = __bswap_16((__uint16_t )report.cookies);
  tx_message->data.auth_data.cookie_length = __bswap_16((__uint16_t )report.cookie_length);
  tx_message->data.auth_data.nak = __bswap_16((__uint16_t )report.nak);
  return;
}
}
static uint16_t convert_select_options(int options )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  if (options & 0x2) {
    tmp = 0x2;
  } else {
    tmp = 0;
  }
  if (options & 0x1) {
    tmp___0 = 0x1;
  } else {
    tmp___0 = 0;
  }
  if (options & 0x4) {
    tmp___1 = 0x4;
  } else {
    tmp___1 = 0;
  }
  if (options & 0x8) {
    tmp___2 = 0x8;
  } else {
    tmp___2 = 0;
  }
  return ((uint16_t )(((tmp | tmp___0) | tmp___1) | tmp___2));
}
}
static void handle_select_data(CMD_Request *rx_message , CMD_Reply *tx_message )
{
  RPT_SelectReport report ;
  __uint32_t tmp ;
  int tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;
  {
  tmp = __bswap_32(rx_message->data.select_data.index);
  tmp___0 = SRC_GetSelectReport((int )tmp, & report);
  if (! tmp___0) {
    tx_message->status = __bswap_16((__uint16_t )4);
    return;
  }
  tx_message->reply = __bswap_16((__uint16_t )23);
  tx_message->data.select_data.ref_id = __bswap_32(report.ref_id);
  UTI_IPHostToNetwork((IPAddr const *)(& report.ip_addr), & tx_message->data.select_data.ip_addr);
  tx_message->data.select_data.state_char = (uint8_t )report.state_char;
  tx_message->data.select_data.authentication = (uint8_t )report.authentication;
  tx_message->data.select_data.leap = (uint8_t )report.leap;
  tmp___1 = convert_select_options(report.conf_options);
  tx_message->data.select_data.conf_options = __bswap_16(tmp___1);
  tmp___2 = convert_select_options(report.eff_options);
  tx_message->data.select_data.eff_options = __bswap_16(tmp___2);
  tx_message->data.select_data.last_sample_ago = __bswap_32(report.last_sample_ago);
  tx_message->data.select_data.score = UTI_FloatHostToNetwork(report.score);
  tx_message->data.select_data.hi_limit = UTI_FloatHostToNetwork(report.hi_limit);
  tx_message->data.select_data.lo_limit = UTI_FloatHostToNetwork(report.lo_limit);
  return;
}
}
static void read_from_cmd_socket(int sock_fd , int event , void *anything )
{
  SCK_Message *sck_message ;
  CMD_Request rx_message ;
  CMD_Reply tx_message ;
  IPAddr loopback_addr ;
  IPAddr remote_ip ;
  int read_length ;
  int expected_length ;
  int localhost ;
  int allowed ;
  int log_index ;
  uint16_t rx_command ;
  struct timespec now ;
  struct timespec cooked_now ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  {
  sck_message = SCK_ReceiveMessage(sock_fd, 0);
  if (! sck_message) {
    return;
  }
  read_length = sck_message->length;
  SCH_GetLastEventTime(& cooked_now, (double *)((void *)0), & now);
  {
  if ((unsigned int )sck_message->addr_type == 1U) {
    goto case_1;
  }
  if ((unsigned int )sck_message->addr_type == 2U) {
    goto case_2;
  }
  goto switch_default;
  case_1:
  if (sock_fd == sock_fd4) {
    tmp = 1;
  } else
  if (sock_fd == sock_fd6) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  assert(tmp);
  remote_ip = sck_message->remote_addr.ip.ip_addr;
  SCK_GetLoopbackIPAddress((int )remote_ip.family, & loopback_addr);
  tmp___0 = UTI_CompareIPs((IPAddr const *)(& remote_ip), (IPAddr const *)(& loopback_addr),
                           (IPAddr const *)((void *)0));
  localhost = tmp___0 == 0;
  if (! localhost) {
    tmp___2 = ADF_IsAllowed(access_auth_table, & remote_ip);
    if (! tmp___2) {
      {
      while (1) {
        while_continue: ;
        goto while_break;
      }
      while_break: ;
      }
      return;
    }
  }
  assert((int )remote_ip.family != 0);
  goto switch_break;
  case_2:
  assert(sock_fd == sock_fdu);
  remote_ip.family = (uint16_t )0;
  localhost = 1;
  goto switch_break;
  switch_default:
  {
  while (1) {
    while_continue___0: ;
    goto while_break___0;
  }
  while_break___0: ;
  }
  return;
  switch_break: ;
  }
  if ((unsigned long )read_length < (unsigned long )(& ((CMD_Request *)0)->data)) {
    goto _L;
  } else
  if ((unsigned long )read_length < (unsigned long )(& ((CMD_Reply *)0)->data)) {
    goto _L;
  } else
  if ((unsigned long )read_length > sizeof(CMD_Request )) {
    _L:
    {
    while (1) {
      while_continue___1: ;
      goto while_break___1;
    }
    while_break___1: ;
    }
    return;
  }
  memcpy((void *)(& rx_message), (void const *)sck_message->data, (size_t )read_length);
  if ((int )rx_message.pkt_type != 1) {
    goto _L___0;
  } else
  if ((int )rx_message.res1 != 0) {
    goto _L___0;
  } else
  if ((int )rx_message.res2 != 0) {
    _L___0:
    {
    while (1) {
      while_continue___2: ;
      goto while_break___2;
    }
    while_break___2: ;
    }
    return;
  }
  log_index = CLG_LogServiceAccess((CLG_Service )2, & remote_ip, & cooked_now);
  if (! localhost) {
    if (log_index >= 0) {
      tmp___3 = CLG_LimitServiceRate((CLG_Service )2, log_index);
      if (tmp___3) {
        {
        while (1) {
          while_continue___3: ;
          goto while_break___3;
        }
        while_break___3: ;
        }
        return;
      }
    }
  }
  expected_length = PKL_CommandLength(& rx_message);
  rx_command = __bswap_16(rx_message.command);
  memset((void *)(& tx_message), 0, sizeof(tx_message));
  sck_message->data = (void *)(& tx_message);
  sck_message->length = 0;
  tx_message.version = (uint8_t )6;
  tx_message.pkt_type = (uint8_t )2;
  tx_message.command = rx_message.command;
  tx_message.reply = __bswap_16((__uint16_t )1);
  tx_message.status = __bswap_16((__uint16_t )0);
  tx_message.sequence = rx_message.sequence;
  if ((int )rx_message.version != 6) {
    {
    while (1) {
      while_continue___4: ;
      goto while_break___4;
    }
    while_break___4: ;
    }
    if ((int )rx_message.version >= 5) {
      tx_message.status = __bswap_16((__uint16_t )18);
      transmit_reply(sock_fd, read_length, sck_message);
    }
    return;
  }
  if ((int )rx_command >= 72) {
    goto _L___1;
  } else
  if (expected_length < (int )((unsigned long )(& ((CMD_Request *)0)->data))) {
    _L___1:
    {
    while (1) {
      while_continue___5: ;
      goto while_break___5;
    }
    while_break___5: ;
    }
    tx_message.status = __bswap_16((__uint16_t )3);
    transmit_reply(sock_fd, read_length, sck_message);
    return;
  }
  if (read_length < expected_length) {
    {
    while (1) {
      while_continue___6: ;
      goto while_break___6;
    }
    while_break___6: ;
    }
    tx_message.status = __bswap_16((__uint16_t )19);
    transmit_reply(sock_fd, read_length, sck_message);
    return;
  }
  if ((int )rx_command >= 72) {
    assert(0);
  } else {
    if ((int )remote_ip.family == 0) {
      assert(sock_fd == sock_fdu);
      allowed = 1;
    } else {
      {
      if ((int const )permissions[rx_command] == 2) {
        goto case_2___0;
      }
      if ((int const )permissions[rx_command] == 1) {
        goto case_1___0;
      }
      if ((int const )permissions[rx_command] == 0) {
        goto case_0;
      }
      goto switch_default___0;
      case_2___0:
      allowed = 0;
      goto switch_break___0;
      case_1___0:
      allowed = localhost;
      goto switch_break___0;
      case_0:
      allowed = 1;
      goto switch_break___0;
      switch_default___0:
      assert(0);
      allowed = 0;
      switch_break___0: ;
      }
    }
    if (allowed) {
      {
      if ((int )rx_command == 0) {
        goto case_0___0;
      }
      if ((int )rx_command == 6) {
        goto case_6;
      }
      if ((int )rx_command == 1) {
        goto case_1___1;
      }
      if ((int )rx_command == 2) {
        goto case_2___1;
      }
      if ((int )rx_command == 3) {
        goto case_3;
      }
      if ((int )rx_command == 4) {
        goto case_4;
      }
      if ((int )rx_command == 5) {
        goto case_5;
      }
      if ((int )rx_command == 7) {
        goto case_7;
      }
      if ((int )rx_command == 8) {
        goto case_8;
      }
      if ((int )rx_command == 47) {
        goto case_47;
      }
      if ((int )rx_command == 9) {
        goto case_9;
      }
      if ((int )rx_command == 50) {
        goto case_50;
      }
      if ((int )rx_command == 10) {
        goto case_10;
      }
      if ((int )rx_command == 11) {
        goto case_11;
      }
      if ((int )rx_command == 56) {
        goto case_56;
      }
      if ((int )rx_command == 13) {
        goto case_13;
      }
      if ((int )rx_command == 14) {
        goto case_14;
      }
      if ((int )rx_command == 15) {
        goto case_15;
      }
      if ((int )rx_command == 16) {
        goto case_16;
      }
      if ((int )rx_command == 17) {
        goto case_17;
      }
      if ((int )rx_command == 18) {
        goto case_18;
      }
      if ((int )rx_command == 19) {
        goto case_19;
      }
      if ((int )rx_command == 20) {
        goto case_20;
      }
      if ((int )rx_command == 21) {
        goto case_21;
      }
      if ((int )rx_command == 22) {
        goto case_22;
      }
      if ((int )rx_command == 23) {
        goto case_23;
      }
      if ((int )rx_command == 24) {
        goto case_24;
      }
      if ((int )rx_command == 25) {
        goto case_25;
      }
      if ((int )rx_command == 26) {
        goto case_26;
      }
      if ((int )rx_command == 64) {
        goto case_64;
      }
      if ((int )rx_command == 29) {
        goto case_29;
      }
      if ((int )rx_command == 30) {
        goto case_30;
      }
      if ((int )rx_command == 31) {
        goto case_31;
      }
      if ((int )rx_command == 71) {
        goto case_71;
      }
      if ((int )rx_command == 33) {
        goto case_33;
      }
      if ((int )rx_command == 51) {
        goto case_51;
      }
      if ((int )rx_command == 52) {
        goto case_52;
      }
      if ((int )rx_command == 34) {
        goto case_34;
      }
      if ((int )rx_command == 35) {
        goto case_35;
      }
      if ((int )rx_command == 36) {
        goto case_36;
      }
      if ((int )rx_command == 37) {
        goto case_37;
      }
      if ((int )rx_command == 68) {
        goto case_68;
      }
      if ((int )rx_command == 41) {
        goto case_41;
      }
      if ((int )rx_command == 42) {
        goto case_42;
      }
      if ((int )rx_command == 43) {
        goto case_43;
      }
      if ((int )rx_command == 44) {
        goto case_44;
      }
      if ((int )rx_command == 49) {
        goto case_49;
      }
      if ((int )rx_command == 48) {
        goto case_48;
      }
      if ((int )rx_command == 45) {
        goto case_45;
      }
      if ((int )rx_command == 46) {
        goto case_46;
      }
      if ((int )rx_command == 53) {
        goto case_53;
      }
      if ((int )rx_command == 54) {
        goto case_54;
      }
      if ((int )rx_command == 57) {
        goto case_57;
      }
      if ((int )rx_command == 62) {
        goto case_62;
      }
      if ((int )rx_command == 63) {
        goto case_63;
      }
      if ((int )rx_command == 65) {
        goto case_65;
      }
      if ((int )rx_command == 66) {
        goto case_66;
      }
      if ((int )rx_command == 67) {
        goto case_67;
      }
      if ((int )rx_command == 69) {
        goto case_69;
      }
      if ((int )rx_command == 70) {
        goto case_70;
      }
      goto switch_default___1;
      case_0___0:
      goto switch_break___1;
      case_6:
      handle_dump(& rx_message, & tx_message);
      goto switch_break___1;
      case_1___1:
      handle_online(& rx_message, & tx_message);
      goto switch_break___1;
      case_2___1:
      handle_offline(& rx_message, & tx_message);
      goto switch_break___1;
      case_3:
      handle_burst(& rx_message, & tx_message);
      goto switch_break___1;
      case_4:
      handle_modify_minpoll(& rx_message, & tx_message);
      goto switch_break___1;
      case_5:
      handle_modify_maxpoll(& rx_message, & tx_message);
      goto switch_break___1;
      case_7:
      handle_modify_maxdelay(& rx_message, & tx_message);
      goto switch_break___1;
      case_8:
      handle_modify_maxdelayratio(& rx_message, & tx_message);
      goto switch_break___1;
      case_47:
      handle_modify_maxdelaydevratio(& rx_message, & tx_message);
      goto switch_break___1;
      case_9:
      handle_modify_maxupdateskew(& rx_message, & tx_message);
      goto switch_break___1;
      case_50:
      handle_modify_makestep(& rx_message, & tx_message);
      goto switch_break___1;
      case_10:
      tx_message.status = __bswap_16((__uint16_t )1);
      goto switch_break___1;
      case_11:
      handle_settime(& rx_message, & tx_message);
      goto switch_break___1;
      case_56:
      handle_local(& rx_message, & tx_message);
      goto switch_break___1;
      case_13:
      handle_manual(& rx_message, & tx_message);
      goto switch_break___1;
      case_14:
      handle_n_sources(& rx_message, & tx_message);
      goto switch_break___1;
      case_15:
      handle_source_data(& rx_message, & tx_message);
      goto switch_break___1;
      case_16:
      handle_rekey(& rx_message, & tx_message);
      goto switch_break___1;
      case_17:
      handle_allowdeny(& rx_message, & tx_message, 1, 0);
      goto switch_break___1;
      case_18:
      handle_allowdeny(& rx_message, & tx_message, 1, 1);
      goto switch_break___1;
      case_19:
      handle_allowdeny(& rx_message, & tx_message, 0, 0);
      goto switch_break___1;
      case_20:
      handle_allowdeny(& rx_message, & tx_message, 0, 1);
      goto switch_break___1;
      case_21:
      handle_cmdallowdeny(& rx_message, & tx_message, 1, 0);
      goto switch_break___1;
      case_22:
      handle_cmdallowdeny(& rx_message, & tx_message, 1, 1);
      goto switch_break___1;
      case_23:
      handle_cmdallowdeny(& rx_message, & tx_message, 0, 0);
      goto switch_break___1;
      case_24:
      handle_cmdallowdeny(& rx_message, & tx_message, 0, 1);
      goto switch_break___1;
      case_25:
      handle_accheck(& rx_message, & tx_message);
      goto switch_break___1;
      case_26:
      handle_cmdaccheck(& rx_message, & tx_message);
      goto switch_break___1;
      case_64:
      handle_add_source(& rx_message, & tx_message);
      goto switch_break___1;
      case_29:
      handle_del_source(& rx_message, & tx_message);
      goto switch_break___1;
      case_30:
      handle_writertc(& rx_message, & tx_message);
      goto switch_break___1;
      case_31:
      handle_dfreq(& rx_message, & tx_message);
      goto switch_break___1;
      case_71:
      handle_doffset(& rx_message, & tx_message);
      goto switch_break___1;
      case_33:
      handle_tracking(& rx_message, & tx_message);
      goto switch_break___1;
      case_51:
      handle_smoothing(& rx_message, & tx_message);
      goto switch_break___1;
      case_52:
      handle_smoothtime(& rx_message, & tx_message);
      goto switch_break___1;
      case_34:
      handle_sourcestats(& rx_message, & tx_message);
      goto switch_break___1;
      case_35:
      handle_rtcreport(& rx_message, & tx_message);
      goto switch_break___1;
      case_36:
      handle_trimrtc(& rx_message, & tx_message);
      goto switch_break___1;
      case_37:
      handle_cyclelogs(& rx_message, & tx_message);
      goto switch_break___1;
      case_68:
      handle_client_accesses_by_index(& rx_message, & tx_message);
      goto switch_break___1;
      case_41:
      handle_manual_list(& rx_message, & tx_message);
      goto switch_break___1;
      case_42:
      handle_manual_delete(& rx_message, & tx_message);
      goto switch_break___1;
      case_43:
      handle_make_step(& rx_message, & tx_message);
      goto switch_break___1;
      case_44:
      handle_activity(& rx_message, & tx_message);
      goto switch_break___1;
      case_49:
      handle_reselect_distance(& rx_message, & tx_message);
      goto switch_break___1;
      case_48:
      handle_reselect(& rx_message, & tx_message);
      goto switch_break___1;
      case_45:
      handle_modify_minstratum(& rx_message, & tx_message);
      goto switch_break___1;
      case_46:
      handle_modify_polltarget(& rx_message, & tx_message);
      goto switch_break___1;
      case_53:
      handle_refresh(& rx_message, & tx_message);
      goto switch_break___1;
      case_54:
      handle_server_stats(& rx_message, & tx_message);
      goto switch_break___1;
      case_57:
      handle_ntp_data(& rx_message, & tx_message);
      goto switch_break___1;
      case_62:
      handle_shutdown(& rx_message, & tx_message);
      goto switch_break___1;
      case_63:
      handle_onoffline(& rx_message, & tx_message);
      goto switch_break___1;
      case_65:
      handle_ntp_source_name(& rx_message, & tx_message);
      goto switch_break___1;
      case_66:
      handle_reset_sources(& rx_message, & tx_message);
      goto switch_break___1;
      case_67:
      handle_auth_data(& rx_message, & tx_message);
      goto switch_break___1;
      case_69:
      handle_select_data(& rx_message, & tx_message);
      goto switch_break___1;
      case_70:
      handle_reload_sources(& rx_message, & tx_message);
      goto switch_break___1;
      switch_default___1:
      {
      while (1) {
        while_continue___7: ;
        goto while_break___7;
      }
      while_break___7: ;
      }
      tx_message.status = __bswap_16((__uint16_t )1);
      goto switch_break___1;
      switch_break___1: ;
      }
    } else {
      tx_message.status = __bswap_16((__uint16_t )2);
    }
  }
  transmit_reply(sock_fd, read_length, sck_message);
  return;
}
}
int CAM_AddAccessRestriction(IPAddr *ip_addr , int subnet_bits , int allow , int all )
{
  ADF_Status status ;
  {
  if (allow) {
    if (all) {
      status = ADF_AllowAll(access_auth_table, ip_addr, subnet_bits);
    } else {
      status = ADF_Allow(access_auth_table, ip_addr, subnet_bits);
    }
  } else
  if (all) {
    status = ADF_DenyAll(access_auth_table, ip_addr, subnet_bits);
  } else {
    status = ADF_Deny(access_auth_table, ip_addr, subnet_bits);
  }
  if ((unsigned int )status == 1U) {
    return (0);
  } else
  if ((unsigned int )status == 0U) {
    return (1);
  } else {
    return (0);
  }
}
}
int CAM_CheckAccessRestriction(IPAddr *ip_addr )
{
  int tmp ;
  {
  tmp = ADF_IsAllowed(access_auth_table, ip_addr);
  return (tmp);
}
}
static int enabled___0 = 0;
static Sample samples[16] ;
static int n_samples ;
static void slew_samples(struct timespec *raw , struct timespec *cooked , double dfreq ,
                         double doffset , LCL_ChangeType change_type , void *not_used ) ;
void MNL_Initialise(void)
{
  int tmp ;
  {
  tmp = CNF_GetManualEnabled();
  if (tmp) {
    enabled___0 = 1;
  } else {
    enabled___0 = 0;
  }
  n_samples = 0;
  LCL_AddParameterChangeHandler(& slew_samples, (void *)0);
  return;
}
}
void MNL_Finalise(void)
{
  {
  LCL_RemoveParameterChangeHandler(& slew_samples, (void *)0);
  return;
}
}
static void estimate_and_set_system(struct timespec *now , int offset_provided , double offset ,
                                    double *reg_offset , double *dfreq_ppm , double *new_afreq_ppm )
{
  double agos[16] ;
  double offsets[16] ;
  double b0 ;
  double b1 ;
  int n_runs___0 ;
  int best_start ;
  int i ;
  double freq___0 ;
  double skew ;
  int found_freq ;
  double slew_by ;
  int tmp ;
  {
  freq___0 = 0.0;
  skew = 0.099999999;
  if (offset_provided) {
    b0 = offset;
  } else {
    b0 = 0.0;
  }
  freq___0 = 0.0;
  b1 = freq___0;
  found_freq = 0;
  if (n_samples > 1) {
    i = 0;
    {
    while (1) {
      while_continue: ;
      if (! (i < n_samples)) {
        goto while_break;
      }
      agos[i] = UTI_DiffTimespecsToDouble((struct timespec const *)(& samples[n_samples - 1].when),
                                          (struct timespec const *)(& samples[i].when));
      offsets[i] = samples[i].offset;
      i ++;
    }
    while_break: ;
    }
    tmp = RGR_FindBestRobustRegression(agos, offsets, n_samples, 1.0e-8, & b0, & b1,
                                       & n_runs___0, & best_start);
    if (tmp) {
      freq___0 = - b1;
      found_freq = 1;
    }
  } else {
    agos[0] = 0.0;
    offsets[0] = b0;
  }
  if (offset_provided) {
    slew_by = offset;
  } else {
    slew_by = b0;
  }
  if (found_freq) {
    LOG_Message((LOG_Severity )0, (char const *)"Making a frequency change of %.3f ppm and a slew of %.6f",
                1.0e6 * freq___0, slew_by);
    REF_SetManualReference(now, slew_by, freq___0, skew);
  } else {
    LOG_Message((LOG_Severity )0, (char const *)"Making a slew of %.6f", slew_by);
    REF_SetManualReference(now, slew_by, 0.0, skew);
  }
  if (reg_offset) {
    *reg_offset = b0;
  }
  if (dfreq_ppm) {
    *dfreq_ppm = 1.0e6 * freq___0;
  }
  if (new_afreq_ppm) {
    *new_afreq_ppm = LCL_ReadAbsoluteFrequency();
  }
  i = 0;
  {
  while (1) {
    while_continue___0: ;
    if (! (i < n_samples)) {
      goto while_break___0;
    }
    samples[i].residual = offsets[i] - (b0 + agos[i] * b1);
    i ++;
  }
  while_break___0: ;
  }
  return;
}
}
int MNL_AcceptTimestamp(struct timespec *ts , double *reg_offset , double *dfreq_ppm ,
                        double *new_afreq_ppm )
{
  struct timespec now ;
  double offset ;
  double diff ;
  int i ;
  int tmp ;
  {
  if (enabled___0) {
    LCL_ReadCookedTime(& now, (double *)((void *)0));
    tmp = UTI_IsTimeOffsetSane((struct timespec const *)ts, 0.0);
    if (! tmp) {
      return (0);
    }
    if (n_samples) {
      diff = UTI_DiffTimespecsToDouble((struct timespec const *)(& now), (struct timespec const *)(& samples[n_samples - 1].when));
      if (diff < 1.0) {
        return (0);
      }
    }
    offset = UTI_DiffTimespecsToDouble((struct timespec const *)(& now), (struct timespec const *)ts);
    if (n_samples == 16) {
      i = 1;
      {
      while (1) {
        while_continue: ;
        if (! (i < n_samples)) {
          goto while_break;
        }
        samples[i - 1] = samples[i];
        i ++;
      }
      while_break: ;
      }
      n_samples --;
    }
    samples[n_samples].when = now;
    samples[n_samples].offset = offset;
    samples[n_samples].orig_offset = offset;
    n_samples ++;
    estimate_and_set_system(& now, 1, offset, reg_offset, dfreq_ppm, new_afreq_ppm);
    return (1);
  } else {
    return (0);
  }
}
}
static void slew_samples(struct timespec *raw , struct timespec *cooked , double dfreq ,
                         double doffset , LCL_ChangeType change_type , void *not_used )
{
  double delta_time ;
  int i ;
  {
  if ((unsigned int )change_type == 2U) {
    MNL_Reset();
  }
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < n_samples)) {
      goto while_break;
    }
    UTI_AdjustTimespec((struct timespec const *)(& samples[i].when), (struct timespec const *)cooked,
                       & samples[i].when, & delta_time, dfreq, doffset);
    samples[i].offset += delta_time;
    i ++;
  }
  while_break: ;
  }
  return;
}
}
void MNL_Enable(void)
{
  {
  enabled___0 = 1;
  return;
}
}
void MNL_Disable(void)
{
  {
  enabled___0 = 0;
  return;
}
}
void MNL_Reset(void)
{
  {
  n_samples = 0;
  return;
}
}
int MNL_IsEnabled(void)
{
  {
  return (enabled___0);
}
}
void MNL_ReportSamples(RPT_ManualSamplesReport *report , int max , int *n )
{
  int i ;
  {
  if (n_samples > max) {
    *n = max;
  } else {
    *n = n_samples;
  }
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (i < n_samples) {
      if (! (i < max)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    (report + i)->when = samples[i].when;
    (report + i)->slewed_offset = samples[i].offset;
    (report + i)->orig_offset = samples[i].orig_offset;
    (report + i)->residual = samples[i].residual;
    i ++;
  }
  while_break: ;
  }
  return;
}
}
int MNL_DeleteSample(int index___0 )
{
  int i ;
  struct timespec now ;
  {
  if (index___0 < 0) {
    return (0);
  } else
  if (index___0 >= n_samples) {
    return (0);
  }
  i = index___0;
  {
  while (1) {
    while_continue: ;
    if (! (i < n_samples - 1)) {
      goto while_break;
    }
    samples[i] = samples[i + 1];
    i ++;
  }
  while_break: ;
  }
  n_samples --;
  LCL_ReadCookedTime(& now, (double *)((void *)0));
  estimate_and_set_system(& now, 0, 0.0, (double *)((void *)0), (double *)((void *)0),
                          (double *)((void *)0));
  return (1);
}
}
static struct request_length const request_lengths[72] =
  { {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.null.EOR)), (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.null.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.null.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.online.EOR)),
      (uint16_t )0UL},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.offline.EOR)), (uint16_t )0UL},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.burst.EOR)),
      (uint16_t )0UL},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.modify_minpoll.EOR)),
      (uint16_t )0UL},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.modify_maxpoll.EOR)),
      (uint16_t )0UL},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.dump.EOR)), (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.null.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.dump.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.modify_maxdelay.EOR)),
      (uint16_t )0UL},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.modify_maxdelayratio.EOR)),
      (uint16_t )0UL},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.modify_maxupdateskew.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.null.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.modify_maxupdateskew.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.logon.EOR)),
      (uint16_t )0UL},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.settime.EOR)), (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.manual_timestamp.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.settime.EOR))},
        {(uint16_t )0,
      (uint16_t )0},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.manual.EOR)), (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.null.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.manual.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.null.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.n_sources.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.null.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.source_data.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.source_data.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.source_data.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.null.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.null.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.null.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.allow_deny.EOR)),
      (uint16_t )0UL},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.allow_deny.EOR)), (uint16_t )0UL},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.allow_deny.EOR)),
      (uint16_t )0UL},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.allow_deny.EOR)), (uint16_t )0UL},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.allow_deny.EOR)),
      (uint16_t )0UL},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.allow_deny.EOR)), (uint16_t )0UL},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.allow_deny.EOR)),
      (uint16_t )0UL},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.allow_deny.EOR)), (uint16_t )0UL},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.ac_check.EOR)),
      (uint16_t )0UL},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.ac_check.EOR)), (uint16_t )0UL},
        {(uint16_t )0,
      (uint16_t )0},
        {(uint16_t )0, (uint16_t )0},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.del_source.EOR)), (uint16_t )0UL},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.null.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.null.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.null.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.dfreq.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.null.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.dfreq.EOR))},
        {(uint16_t )0,
      (uint16_t )0},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.null.EOR)), (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.tracking.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.null.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.sourcestats.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.sourcestats.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.sourcestats.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.null.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.rtc.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.null.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.null.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.null.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.null.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.null.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.null.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.null.EOR))},
        {(uint16_t )0,
      (uint16_t )0},
        {(uint16_t )0, (uint16_t )0},
        {(uint16_t )0, (uint16_t )0},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.null.EOR)), (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.manual_list.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.null.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.manual_delete.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.null.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.manual_delete.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.null.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.null.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.null.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.null.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.activity.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.null.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.modify_minstratum.EOR)),
      (uint16_t )0UL},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.modify_polltarget.EOR)),
      (uint16_t )0UL},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.modify_maxdelaydevratio.EOR)),
      (uint16_t )0UL},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.null.EOR)), (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.null.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.null.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.reselect_distance.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.null.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.reselect_distance.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.modify_makestep.EOR)),
      (uint16_t )0UL},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.null.EOR)), (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.smoothing.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.null.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.smoothtime.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.null.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.smoothtime.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.null.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.null.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.null.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.null.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.server_stats.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.null.EOR))},
        {(uint16_t )0,
      (uint16_t )0},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.local.EOR)), (uint16_t )0UL},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.ntp_data.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.ntp_data.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.ntp_data.EOR))},
        {(uint16_t )0,
      (uint16_t )0},
        {(uint16_t )0, (uint16_t )0},
        {(uint16_t )0, (uint16_t )0},
        {(uint16_t )0, (uint16_t )0},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.null.EOR)), (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.null.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.null.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.null.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.null.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.null.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.ntp_source.EOR)),
      (uint16_t )0UL},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.ntp_source_name.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.ntp_source_name.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.ntp_source_name.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.null.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.null.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.null.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.auth_data.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.auth_data.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.auth_data.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.client_accesses_by_index.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.client_accesses_by_index.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.client_accesses_by_index.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.select_data.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.select_data.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.select_data.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.null.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.null.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.null.EOR))},
        {(uint16_t )((unsigned long )(& ((CMD_Request *)0)->data.doffset.EOR)),
      (uint16_t )((unsigned long )(& ((CMD_Reply *)0)->data.null.EOR) - (unsigned long )(& ((CMD_Request *)0)->data.doffset.EOR))}};
static uint16_t const reply_lengths[25] =
  { (uint16_t const )0, (uint16_t const )((unsigned long )(& ((CMD_Reply *)0)->data.null.EOR)), (uint16_t const )((unsigned long )(& ((CMD_Reply *)0)->data.n_sources.EOR)), (uint16_t const )((unsigned long )(& ((CMD_Reply *)0)->data.source_data.EOR)),
        (uint16_t const )0, (uint16_t const )((unsigned long )(& ((CMD_Reply *)0)->data.tracking.EOR)), (uint16_t const )((unsigned long )(& ((CMD_Reply *)0)->data.sourcestats.EOR)), (uint16_t const )((unsigned long )(& ((CMD_Reply *)0)->data.rtc.EOR)),
        (uint16_t const )0, (uint16_t const )0, (uint16_t const )0, (uint16_t const )0,
        (uint16_t const )((unsigned long )(& ((CMD_Reply *)0)->data.activity.EOR)), (uint16_t const )((unsigned long )(& ((CMD_Reply *)0)->data.smoothing.EOR)), (uint16_t const )0, (uint16_t const )0,
        (uint16_t const )((unsigned long )(& ((CMD_Reply *)0)->data.ntp_data.EOR)), (uint16_t const )((unsigned long )(& ((CMD_Reply *)0)->data.manual_timestamp.EOR)), (uint16_t const )((unsigned long )(& ((CMD_Reply *)0)->data.manual_list.EOR)), (uint16_t const )((unsigned long )(& ((CMD_Reply *)0)->data.ntp_source_name.EOR)),
        (uint16_t const )((unsigned long )(& ((CMD_Reply *)0)->data.auth_data.EOR)), (uint16_t const )((unsigned long )(& ((CMD_Reply *)0)->data.client_accesses_by_index.EOR)), (uint16_t const )0, (uint16_t const )((unsigned long )(& ((CMD_Reply *)0)->data.select_data.EOR)),
        (uint16_t const )((unsigned long )(& ((CMD_Reply *)0)->data.server_stats.EOR))};
int PKL_CommandLength(CMD_Request *r )
{
  uint32_t type ;
  int command_length ;
  __uint16_t tmp ;
  int tmp___0 ;
  {
  assert(sizeof(request_lengths) / sizeof(request_lengths[0]) == 72UL);
  tmp = __bswap_16(r->command);
  type = (uint32_t )tmp;
  if (type >= 72U) {
    return (0);
  }
  command_length = (int )request_lengths[type].command;
  if (! command_length) {
    return (0);
  }
  tmp___0 = PKL_CommandPaddingLength(r);
  return (command_length + tmp___0);
}
}
int PKL_CommandPaddingLength(CMD_Request *r )
{
  uint32_t type ;
  __uint16_t tmp ;
  __uint16_t tmp___0 ;
  {
  if ((int )r->version < 6) {
    return (0);
  }
  tmp = __bswap_16(r->command);
  type = (uint32_t )tmp;
  if (type >= 72U) {
    return (0);
  }
  tmp___0 = __bswap_16(r->command);
  return ((int )request_lengths[tmp___0].padding);
}
}
int PKL_ReplyLength(CMD_Reply *r )
{
  uint32_t type ;
  __uint16_t tmp ;
  {
  assert(sizeof(reply_lengths) / sizeof(reply_lengths[0]) == 25UL);
  tmp = __bswap_16(r->reply);
  type = (uint32_t )tmp;
  if (type < 1U) {
    return (0);
  } else
  if (type >= 25U) {
    return (0);
  }
  return ((int )reply_lengths[type]);
}
}
NAU_Instance NAU_CreateNoneInstance(void) ;
NAU_Instance NAU_CreateSymmetricInstance(uint32_t key_id ) ;
NAU_Instance NAU_CreateNtsInstance(IPSockAddr *nts_address , char const *name ,
                                   uint32_t cert_set , uint16_t ntp_port___0 ) ;
void NAU_DestroyInstance(NAU_Instance instance ) ;
int NAU_IsAuthEnabled(NAU_Instance instance ) ;
int NAU_GetSuggestedNtpVersion(NAU_Instance instance ) ;
int NAU_PrepareRequestAuth(NAU_Instance instance ) ;
int NAU_GenerateRequestAuth(NAU_Instance instance , NTP_Packet *request , NTP_PacketInfo *info ) ;
int NAU_CheckRequestAuth(NTP_Packet *request , NTP_PacketInfo *info , uint32_t *kod ) ;
int NAU_GenerateResponseAuth(NTP_Packet *request , NTP_PacketInfo *request_info ,
                             NTP_Packet *response , NTP_PacketInfo *response_info ,
                             NTP_Remote_Address *remote_addr , NTP_Local_Address *local_addr ,
                             uint32_t kod ) ;
int NAU_CheckResponseAuth(NAU_Instance instance , NTP_Packet *response , NTP_PacketInfo *info ) ;
void NAU_ChangeAddress(NAU_Instance instance , IPAddr *address ) ;
void NAU_DumpData(NAU_Instance instance ) ;
void NAU_GetReport(NAU_Instance instance , RPT_AuthReport *report ) ;
static int generate_symmetric_auth(uint32_t key_id , NTP_Packet *packet , NTP_PacketInfo *info )
{
  int auth_len ;
  int max_auth_len ;
  int tmp ;
  {
  if ((unsigned long )(info->length + 20) > sizeof(*packet)) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  if (info->version == 4) {
    tmp = 24;
  } else {
    tmp = 68;
  }
  max_auth_len = tmp - 4;
  if ((unsigned long )max_auth_len < (sizeof(*packet) - (unsigned long )info->length) - 4UL) {
    max_auth_len = max_auth_len;
  } else {
    max_auth_len = (int )((sizeof(*packet) - (unsigned long )info->length) - 4UL);
  }
  auth_len = KEY_GenerateAuth(key_id, (void const *)packet, info->length, ((unsigned char *)packet + info->length) + 4,
                              max_auth_len);
  if (auth_len < 16) {
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
    return (0);
  }
  *((uint32_t *)((unsigned char *)packet + info->length)) = __bswap_32(key_id);
  info->auth.mac.start = info->length;
  info->auth.mac.length = 4 + auth_len;
  info->auth.mac.key_id = key_id;
  info->length += info->auth.mac.length;
  return (1);
}
}
static int check_symmetric_auth(NTP_Packet *packet , NTP_PacketInfo *info )
{
  int trunc_len ;
  int tmp ;
  {
  if (info->auth.mac.length < 20) {
    return (0);
  }
  if (info->version == 4) {
    if (info->auth.mac.length <= 24) {
      trunc_len = 24;
    } else {
      trunc_len = 68;
    }
  } else {
    trunc_len = 68;
  }
  tmp = KEY_CheckAuth(info->auth.mac.key_id, (void const *)packet, info->auth.mac.start,
                      (unsigned char const *)(((unsigned char *)packet + info->auth.mac.start) + 4),
                      info->auth.mac.length - 4, trunc_len - 4);
  if (! tmp) {
    return (0);
  }
  return (1);
}
}
static NAU_Instance create_instance(NTP_AuthMode mode___0 )
{
  NAU_Instance instance ;
  void *tmp ;
  {
  tmp = Malloc(sizeof(struct NAU_Instance_Record ));
  instance = (struct NAU_Instance_Record *)tmp;
  instance->mode = mode___0;
  instance->key_id = (uint32_t )0;
  instance->nts = (NNC_Instance )((void *)0);
  assert(sizeof(instance->key_id) == 4UL);
  return (instance);
}
}
NAU_Instance NAU_CreateNoneInstance(void)
{
  NAU_Instance tmp ;
  {
  tmp = create_instance((NTP_AuthMode )0);
  return (tmp);
}
}
NAU_Instance NAU_CreateSymmetricInstance(uint32_t key_id )
{
  NAU_Instance instance ;
  NAU_Instance tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  tmp = create_instance((NTP_AuthMode )1);
  instance = tmp;
  instance->key_id = key_id;
  tmp___1 = KEY_KeyKnown(key_id);
  if (tmp___1) {
    tmp___0 = KEY_CheckKeyLength(key_id);
    if (! tmp___0) {
      LOG_Message((LOG_Severity )1, (char const *)"Key %u is %s", key_id, "too short");
    }
  } else {
    LOG_Message((LOG_Severity )1, (char const *)"Key %u is %s", key_id, "missing");
  }
  return (instance);
}
}
NAU_Instance NAU_CreateNtsInstance(IPSockAddr *nts_address , char const *name ,
                                   uint32_t cert_set , uint16_t ntp_port___0 )
{
  NAU_Instance instance ;
  NAU_Instance tmp ;
  {
  tmp = create_instance((NTP_AuthMode )4);
  instance = tmp;
  instance->nts = NNC_CreateInstance(nts_address, name, cert_set, ntp_port___0);
  return (instance);
}
}
void NAU_DestroyInstance(NAU_Instance instance )
{
  {
  if ((unsigned int )instance->mode == 4U) {
    NNC_DestroyInstance(instance->nts);
  }
  free((void *)instance);
  return;
}
}
int NAU_IsAuthEnabled(NAU_Instance instance )
{
  {
  return ((unsigned int )instance->mode != 0U);
}
}
int NAU_GetSuggestedNtpVersion(NAU_Instance instance )
{
  int tmp ;
  {
  if ((unsigned int )instance->mode == 1U) {
    tmp = KEY_GetAuthLength(instance->key_id);
    if ((unsigned long )tmp + sizeof(instance->key_id) > 24UL) {
      return (3);
    }
  }
  return (4);
}
}
int NAU_PrepareRequestAuth(NAU_Instance instance )
{
  int tmp ;
  {
  {
  if ((unsigned int )instance->mode == 4U) {
    goto case_4;
  }
  goto switch_default;
  case_4:
  tmp = NNC_PrepareForAuth(instance->nts);
  if (! tmp) {
    return (0);
  }
  goto switch_break;
  switch_default:
  goto switch_break;
  switch_break: ;
  }
  return (1);
}
}
int NAU_GenerateRequestAuth(NAU_Instance instance , NTP_Packet *request , NTP_PacketInfo *info )
{
  int tmp ;
  int tmp___0 ;
  {
  {
  if ((unsigned int )instance->mode == 0U) {
    goto case_0;
  }
  if ((unsigned int )instance->mode == 1U) {
    goto case_1;
  }
  if ((unsigned int )instance->mode == 4U) {
    goto case_4;
  }
  goto switch_default;
  case_0:
  goto switch_break;
  case_1:
  tmp = generate_symmetric_auth(instance->key_id, request, info);
  if (! tmp) {
    return (0);
  }
  goto switch_break;
  case_4:
  tmp___0 = NNC_GenerateRequestAuth(instance->nts, request, info);
  if (! tmp___0) {
    return (0);
  }
  goto switch_break;
  switch_default:
  assert(0);
  switch_break: ;
  }
  info->auth.mode = instance->mode;
  return (1);
}
}
int NAU_CheckRequestAuth(NTP_Packet *request , NTP_PacketInfo *info , uint32_t *kod )
{
  int tmp ;
  int tmp___0 ;
  {
  *kod = (uint32_t )0;
  {
  if ((unsigned int )info->auth.mode == 0U) {
    goto case_0;
  }
  if ((unsigned int )info->auth.mode == 1U) {
    goto case_1;
  }
  if ((unsigned int )info->auth.mode == 2U) {
    goto case_2;
  }
  if ((unsigned int )info->auth.mode == 3U) {
    goto case_3;
  }
  if ((unsigned int )info->auth.mode == 4U) {
    goto case_4;
  }
  goto switch_default;
  case_0:
  goto switch_break;
  case_1:
  tmp = check_symmetric_auth(request, info);
  if (! tmp) {
    return (0);
  }
  goto switch_break;
  case_2:
  goto switch_break;
  case_3:
  return (0);
  case_4:
  tmp___0 = NNS_CheckRequestAuth(request, info, kod);
  if (! tmp___0) {
    return (0);
  }
  goto switch_break;
  switch_default:
  return (0);
  switch_break: ;
  }
  return (1);
}
}
int NAU_GenerateResponseAuth(NTP_Packet *request , NTP_PacketInfo *request_info ,
                             NTP_Packet *response , NTP_PacketInfo *response_info ,
                             NTP_Remote_Address *remote_addr , NTP_Local_Address *local_addr ,
                             uint32_t kod )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  {
  if ((unsigned int )request_info->auth.mode == 0U) {
    goto case_0;
  }
  if ((unsigned int )request_info->auth.mode == 1U) {
    goto case_1;
  }
  if ((unsigned int )request_info->auth.mode == 2U) {
    goto case_2;
  }
  if ((unsigned int )request_info->auth.mode == 4U) {
    goto case_4;
  }
  goto switch_default;
  case_0:
  goto switch_break;
  case_1:
  tmp = generate_symmetric_auth(request_info->auth.mac.key_id, response, response_info);
  if (! tmp) {
    return (0);
  }
  goto switch_break;
  case_2:
  tmp___0 = NSD_SignAndSendPacket(request_info->auth.mac.key_id, response, response_info,
                                  remote_addr, local_addr);
  if (! tmp___0) {
    return (0);
  }
  return (0);
  case_4:
  tmp___1 = NNS_GenerateResponseAuth(request, request_info, response, response_info,
                                     kod);
  if (! tmp___1) {
    return (0);
  }
  goto switch_break;
  switch_default:
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  return (0);
  switch_break: ;
  }
  response_info->auth.mode = request_info->auth.mode;
  return (1);
}
}
int NAU_CheckResponseAuth(NAU_Instance instance , NTP_Packet *response , NTP_PacketInfo *info )
{
  int tmp ;
  int tmp___0 ;
  {
  if ((unsigned int )info->auth.mode != (unsigned int )instance->mode) {
    return (0);
  }
  {
  if ((unsigned int )info->auth.mode == 0U) {
    goto case_0;
  }
  if ((unsigned int )info->auth.mode == 1U) {
    goto case_1;
  }
  if ((unsigned int )info->auth.mode == 4U) {
    goto case_4;
  }
  goto switch_default;
  case_0:
  goto switch_break;
  case_1:
  if (info->auth.mac.key_id != instance->key_id) {
    return (0);
  }
  tmp = check_symmetric_auth(response, info);
  if (! tmp) {
    return (0);
  }
  goto switch_break;
  case_4:
  tmp___0 = NNC_CheckResponseAuth(instance->nts, response, info);
  if (! tmp___0) {
    return (0);
  }
  goto switch_break;
  switch_default:
  return (0);
  switch_break: ;
  }
  return (1);
}
}
void NAU_ChangeAddress(NAU_Instance instance , IPAddr *address )
{
  {
  {
  if ((unsigned int )instance->mode == 1U) {
    goto case_1;
  }
  if ((unsigned int )instance->mode == 0U) {
    goto case_1;
  }
  if ((unsigned int )instance->mode == 4U) {
    goto case_4;
  }
  goto switch_default;
  case_1:
  case_0:
  goto switch_break;
  case_4:
  NNC_ChangeAddress(instance->nts, address);
  goto switch_break;
  switch_default:
  assert(0);
  switch_break: ;
  }
  return;
}
}
void NAU_DumpData(NAU_Instance instance )
{
  {
  {
  if ((unsigned int )instance->mode == 4U) {
    goto case_4;
  }
  goto switch_default;
  case_4:
  NNC_DumpData(instance->nts);
  goto switch_break;
  switch_default:
  goto switch_break;
  switch_break: ;
  }
  return;
}
}
void NAU_GetReport(NAU_Instance instance , RPT_AuthReport *report )
{
  {
  memset((void *)report, 0, sizeof(*report));
  report->mode = instance->mode;
  report->last_ke_ago = (uint32_t )-1;
  {
  if ((unsigned int )instance->mode == 0U) {
    goto case_0;
  }
  if ((unsigned int )instance->mode == 1U) {
    goto case_1;
  }
  if ((unsigned int )instance->mode == 4U) {
    goto case_4;
  }
  goto switch_default;
  case_0:
  goto switch_break;
  case_1:
  report->key_id = instance->key_id;
  KEY_GetKeyInfo(instance->key_id, & report->key_type, & report->key_length);
  goto switch_break;
  case_4:
  NNC_GetReport(instance->nts, report);
  goto switch_break;
  switch_default:
  assert(0);
  switch_break: ;
  }
  return;
}
}
int NEF_SetField(unsigned char *buffer , int buffer_length , int start , int type ,
                 void *body , int body_length , int *length ) ;
int NEF_AddBlankField(NTP_Packet *packet , NTP_PacketInfo *info , int type , int body_length ,
                      void **body ) ;
int NEF_AddField(NTP_Packet *packet , NTP_PacketInfo *info , int type , void *body ,
                 int body_length ) ;
int NEF_ParseSingleField(unsigned char *buffer , int buffer_length , int start , int *length ,
                         int *type , void **body , int *body_length ) ;
int NEF_ParseField(NTP_Packet *packet , int packet_length , int start , int *length ,
                   int *type , void **body , int *body_length ) ;
static LOG_FileID logfileid___2 ;
static int log_raw_measurements ;
static ARR_Instance broadcasts___0 ;
static int server_sock_fd4 ;
static int server_sock_fd6 ;
static ADF_AuthTable access_auth_table___0 ;
static double server_mono_offset ;
static uint32_t server_mono_epoch ;
static char const leap_chars[4] = { (char const )'N', (char const )'+', (char const )'-', (char const )'?'};
static char const tss_chars[3] = { (char const )'D', (char const )'K', (char const )'H'};
static void transmit_timeout(void *arg ) ;
static double get_transmit_delay(NCR_Instance inst , int on_tx , double last_tx ) ;
static double get_separation(int poll ) ;
static int parse_packet(NTP_Packet *packet , int length , NTP_PacketInfo *info ) ;
static void set_connectivity(NCR_Instance inst , SRC_Connectivity connectivity ) ;
static void do_size_checks___0(void)
{
  {
  assert(sizeof(NTP_int32 ) == 4UL);
  assert(sizeof(NTP_int64 ) == 8UL);
  assert((unsigned long )(& ((NTP_Packet *)0)->lvm) == 0UL);
  assert((unsigned long )(& ((NTP_Packet *)0)->stratum) == 1UL);
  assert((unsigned long )(& ((NTP_Packet *)0)->poll) == 2UL);
  assert((unsigned long )(& ((NTP_Packet *)0)->precision) == 3UL);
  assert((unsigned long )(& ((NTP_Packet *)0)->root_delay) == 4UL);
  assert((unsigned long )(& ((NTP_Packet *)0)->root_dispersion) == 8UL);
  assert((unsigned long )(& ((NTP_Packet *)0)->reference_id) == 12UL);
  assert((unsigned long )(& ((NTP_Packet *)0)->reference_ts) == 16UL);
  assert((unsigned long )(& ((NTP_Packet *)0)->originate_ts) == 24UL);
  assert((unsigned long )(& ((NTP_Packet *)0)->receive_ts) == 32UL);
  assert((unsigned long )(& ((NTP_Packet *)0)->transmit_ts) == 40UL);
  return;
}
}
static void do_time_checks(void)
{
  struct timespec now ;
  time_t warning_advance ;
  struct timespec ts1 ;
  struct timespec ts2 ;
  NTP_int64 nts1 ;
  NTP_int64 nts2 ;
  int r ;
  int tmp ;
  char *tmp___0 ;
  {
  warning_advance = (time_t )315360000;
  ts1.tv_sec = (__time_t )72974235LL;
  ts1.tv_nsec = (__syscall_slong_t )1;
  ts2.tv_sec = (__time_t )72974234LL;
  ts2.tv_nsec = (__syscall_slong_t )1;
  UTI_TimespecToNtp64((struct timespec const *)(& ts1), & nts1, (NTP_int64 const *)((void *)0));
  UTI_TimespecToNtp64((struct timespec const *)(& ts2), & nts2, (NTP_int64 const *)((void *)0));
  UTI_Ntp64ToTimespec((NTP_int64 const *)(& nts1), & ts1);
  UTI_Ntp64ToTimespec((NTP_int64 const *)(& nts2), & ts2);
  if ((long long )ts1.tv_sec == 72974235LL) {
    if (((unsigned long long )ts1.tv_sec + (1ULL << 32)) - 1ULL == (unsigned long long )ts2.tv_sec) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  r = tmp;
  assert(r);
  LCL_ReadRawTime(& now);
  if (ts2.tv_sec - now.tv_sec < warning_advance) {
    tmp___0 = UTI_TimeToLogForm(ts2.tv_sec);
    LOG_Message((LOG_Severity )1, (char const *)"Assumed NTP time ends at %s!",
                tmp___0);
  }
  return;
}
}
static void zero_local_timestamp(NTP_Local_Timestamp *ts )
{
  {
  UTI_ZeroTimespec(& ts->ts);
  ts->err = 0.0;
  ts->source = (NTP_Timestamp_Source )0;
  return;
}
}
static void handle_slew___2(struct timespec *raw , struct timespec *cooked , double dfreq ,
                            double doffset , LCL_ChangeType change_type , void *anything )
{
  {
  if ((unsigned int )change_type == 0U) {
    server_mono_offset += doffset;
  } else {
    UTI_GetRandomBytes((void *)(& server_mono_epoch), (unsigned int )sizeof(server_mono_epoch));
    server_mono_offset = 0.0;
  }
  return;
}
}
void NCR_Initialise(void)
{
  int tmp ;
  LOG_FileID tmp___0 ;
  int tmp___1 ;
  {
  do_size_checks___0();
  do_time_checks();
  tmp___1 = CNF_GetLogMeasurements(& log_raw_measurements);
  if (tmp___1) {
    tmp___0 = LOG_FileOpen((char const *)"measurements", (char const *)"   Date (UTC) Time     IP Address   L St 123 567 ABCD  LP RP Score    Offset  Peer del. Peer disp.  Root del. Root disp. Refid     MTxRx");
    logfileid___2 = tmp___0;
  } else {
    logfileid___2 = -1;
  }
  access_auth_table___0 = ADF_CreateTable();
  broadcasts___0 = ARR_CreateInstance((unsigned int )sizeof(BroadcastDestination ));
  server_sock_fd4 = -2;
  server_sock_fd6 = -2;
  LCL_AddParameterChangeHandler(& handle_slew___2, (void *)0);
  handle_slew___2((struct timespec *)((void *)0), (struct timespec *)((void *)0),
                  0.0, 0.0, (LCL_ChangeType )2, (void *)0);
  return;
}
}
void NCR_Finalise(void)
{
  unsigned int i ;
  void *tmp ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  {
  LCL_RemoveParameterChangeHandler(& handle_slew___2, (void *)0);
  if (server_sock_fd4 != -2) {
    NIO_CloseServerSocket(server_sock_fd4);
  }
  if (server_sock_fd6 != -2) {
    NIO_CloseServerSocket(server_sock_fd6);
  }
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp___1 = ARR_GetSize(broadcasts___0);
    if (! (i < tmp___1)) {
      goto while_break;
    }
    tmp = ARR_GetElement(broadcasts___0, i);
    NIO_CloseServerSocket(((BroadcastDestination *)tmp)->local_addr.sock_fd);
    tmp___0 = ARR_GetElement(broadcasts___0, i);
    NAU_DestroyInstance(((BroadcastDestination *)tmp___0)->auth);
    i ++;
  }
  while_break: ;
  }
  ARR_DestroyInstance(broadcasts___0);
  ADF_DestroyTable(access_auth_table___0);
  return;
}
}
static void restart_timeout(NCR_Instance inst , double delay )
{
  int tmp ;
  double tmp___0 ;
  {
  if (inst->tx_suspended) {
    assert(! inst->tx_timeout_id);
    return;
  }
  SCH_RemoveTimeout(inst->rx_timeout_id);
  inst->rx_timeout_id = (SCH_TimeoutID )0;
  SCH_RemoveTimeout(inst->tx_timeout_id);
  if ((unsigned int )inst->mode == 3U) {
    tmp = 1;
  } else {
    tmp = 2;
  }
  tmp___0 = get_separation(inst->local_poll);
  inst->tx_timeout_id = SCH_AddTimeoutInClass(delay, tmp___0, 0.02, (SCH_TimeoutClass )tmp,
                                              & transmit_timeout, (void *)inst);
  return;
}
}
static void start_initial_timeout(NCR_Instance inst )
{
  double delay ;
  double last_tx ;
  struct timespec now ;
  double tmp ;
  int tmp___0 ;
  {
  if (! inst->tx_timeout_id) {
    SRC_SetActive(inst->source);
  }
  tmp___0 = UTI_IsZeroTimespec(& inst->local_tx.ts);
  if (tmp___0) {
    delay = 0.0;
  } else {
    SCH_GetLastEventTime(& now, (double *)((void *)0), (struct timespec *)((void *)0));
    last_tx = UTI_DiffTimespecsToDouble((struct timespec const *)(& now), (struct timespec const *)(& inst->local_tx.ts));
    if (last_tx < 0.0) {
      last_tx = 0.0;
    }
    tmp = get_transmit_delay(inst, 0, 0.0);
    delay = tmp - last_tx;
  }
  if (delay < 0.2) {
    delay = 0.2;
  }
  restart_timeout(inst, delay);
  return;
}
}
static void close_client_socket(NCR_Instance inst )
{
  {
  if ((unsigned int )inst->mode == 3U) {
    if (inst->local_addr.sock_fd != -2) {
      NIO_CloseClientSocket(inst->local_addr.sock_fd);
      inst->local_addr.sock_fd = -2;
    }
  }
  SCH_RemoveTimeout(inst->rx_timeout_id);
  inst->rx_timeout_id = (SCH_TimeoutID )0;
  return;
}
}
static void take_offline(NCR_Instance inst )
{
  {
  inst->opmode = (OperatingMode )0;
  SCH_RemoveTimeout(inst->tx_timeout_id);
  inst->tx_timeout_id = (SCH_TimeoutID )0;
  SRC_ResetReachability(inst->source);
  SRC_UnsetActive(inst->source);
  close_client_socket(inst);
  NCR_ResetInstance(inst);
  return;
}
}
NCR_Instance NCR_CreateInstance(NTP_Remote_Address *remote_addr , NTP_Source_Type type ,
                                SourceParameters *params , char const *name )
{
  NCR_Instance result ;
  void *tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  int tmp___9 ;
  IPSockAddr nts_address ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  uint32_t tmp___14 ;
  {
  tmp = Malloc(sizeof(struct NCR_Instance_Record ));
  result = (struct NCR_Instance_Record *)tmp;
  result->remote_addr = *remote_addr;
  result->local_addr.ip_addr.family = (uint16_t )0;
  result->local_addr.if_index = -1;
  {
  if ((unsigned int )type == 0U) {
    goto case_0;
  }
  if ((unsigned int )type == 1U) {
    goto case_1;
  }
  goto switch_default;
  case_0:
  result->local_addr.sock_fd = -2;
  result->mode = (NTP_Mode )3;
  goto switch_break;
  case_1:
  result->local_addr.sock_fd = NIO_OpenServerSocket(remote_addr);
  result->mode = (NTP_Mode )1;
  goto switch_break;
  switch_default:
  assert(0);
  switch_break: ;
  }
  result->interleaved = params->interleaved;
  result->minpoll = params->minpoll;
  if (result->minpoll < -6) {
    result->minpoll = 6;
  } else
  if (result->minpoll > 24) {
    result->minpoll = 24;
  }
  result->maxpoll = params->maxpoll;
  if (result->maxpoll < -6) {
    result->maxpoll = 10;
  } else
  if (result->maxpoll > 24) {
    result->maxpoll = 24;
  }
  if (result->maxpoll < result->minpoll) {
    result->maxpoll = result->minpoll;
  }
  result->min_stratum = params->min_stratum;
  if (result->min_stratum >= 16) {
    result->min_stratum = 15;
  }
  result->presend_minpoll = params->presend_minpoll;
  if (result->presend_minpoll <= 24) {
    if ((unsigned int )result->mode != 3U) {
      result->presend_minpoll = 25;
    }
  }
  if (params->max_delay < 1.0e3) {
    tmp___2 = params->max_delay;
  } else {
    tmp___2 = 1.0e3;
  }
  if (0.0 > tmp___2) {
    result->max_delay = 0.0;
  } else {
    if (params->max_delay < 1.0e3) {
      tmp___1 = params->max_delay;
    } else {
      tmp___1 = 1.0e3;
    }
    result->max_delay = tmp___1;
  }
  if (params->max_delay_ratio < 1.0e6) {
    tmp___5 = params->max_delay_ratio;
  } else {
    tmp___5 = 1.0e6;
  }
  if (0.0 > tmp___5) {
    result->max_delay_ratio = 0.0;
  } else {
    if (params->max_delay_ratio < 1.0e6) {
      tmp___4 = params->max_delay_ratio;
    } else {
      tmp___4 = 1.0e6;
    }
    result->max_delay_ratio = tmp___4;
  }
  if (params->max_delay_dev_ratio < 1.0e6) {
    tmp___8 = params->max_delay_dev_ratio;
  } else {
    tmp___8 = 1.0e6;
  }
  if (0.0 > tmp___8) {
    result->max_delay_dev_ratio = 0.0;
  } else {
    if (params->max_delay_dev_ratio < 1.0e6) {
      tmp___7 = params->max_delay_dev_ratio;
    } else {
      tmp___7 = 1.0e6;
    }
    result->max_delay_dev_ratio = tmp___7;
  }
  result->offset_correction = params->offset;
  result->auto_iburst = params->iburst;
  result->auto_burst = params->burst;
  result->auto_offline = params->auto_offline;
  if (params->copy) {
    if ((unsigned int )result->mode == 3U) {
      tmp___9 = 1;
    } else {
      tmp___9 = 0;
    }
  } else {
    tmp___9 = 0;
  }
  result->copy = tmp___9;
  result->poll_target = params->poll_target;
  result->ext_field_flags = params->ext_fields;
  if (params->nts) {
    if ((unsigned int )result->mode == 1U) {
      LOG_Message((LOG_Severity )1, (char const *)"NTS not supported with peers");
    }
    nts_address.ip_addr = remote_addr->ip_addr;
    nts_address.port = (uint16_t )params->nts_port;
    result->auth = NAU_CreateNtsInstance(& nts_address, name, params->cert_set, result->remote_addr.port);
  } else
  if (params->authkey != 0U) {
    result->auth = NAU_CreateSymmetricInstance(params->authkey);
  } else {
    result->auth = NAU_CreateNoneInstance();
  }
  if (result->ext_field_flags) {
    result->version = 4;
  } else
  if (result->interleaved) {
    result->version = 4;
  } else {
    result->version = NAU_GetSuggestedNtpVersion(result->auth);
  }
  if (params->version) {
    if (params->version < 4) {
      tmp___12 = params->version;
    } else {
      tmp___12 = 4;
    }
    if (1 > tmp___12) {
      result->version = 1;
    } else {
      if (params->version < 4) {
        tmp___11 = params->version;
      } else {
        tmp___11 = 4;
      }
      result->version = tmp___11;
    }
  }
  tmp___13 = NAU_IsAuthEnabled(result->auth);
  tmp___14 = UTI_IPToRefid((IPAddr const *)(& remote_addr->ip_addr));
  result->source = SRC_CreateNewInstance(tmp___14, (SRC_Type )0, tmp___13, params->sel_options,
                                         & result->remote_addr.ip_addr, params->min_samples,
                                         params->max_samples, params->min_delay, params->asymmetry);
  if (params->filter_length >= 1) {
    result->filter = SPF_CreateInstance(params->filter_length, params->filter_length,
                                        16.0, 0.0);
  } else {
    result->filter = (SPF_Instance )((void *)0);
  }
  result->rx_timeout_id = (SCH_TimeoutID )0;
  result->tx_timeout_id = (SCH_TimeoutID )0;
  result->tx_suspended = 1;
  result->opmode = (OperatingMode )0;
  result->local_poll = result->minpoll;
  result->poll_score = 0.0;
  zero_local_timestamp(& result->local_tx);
  result->burst_good_samples_to_go = 0;
  result->burst_total_samples_to_go = 0;
  memset((void *)(& result->report), 0, sizeof(result->report));
  NCR_ResetInstance(result);
  set_connectivity(result, params->connectivity);
  return (result);
}
}
void NCR_DestroyInstance(NCR_Instance instance )
{
  {
  if ((unsigned int )instance->opmode != 0U) {
    take_offline(instance);
  }
  if ((unsigned int )instance->mode == 1U) {
    NIO_CloseServerSocket(instance->local_addr.sock_fd);
  }
  if (instance->filter) {
    SPF_DestroyInstance(instance->filter);
  }
  NAU_DestroyInstance(instance->auth);
  SRC_DestroyInstance(instance->source);
  free((void *)instance);
  return;
}
}
void NCR_StartInstance(NCR_Instance instance )
{
  {
  instance->tx_suspended = 0;
  if ((unsigned int )instance->opmode != 0U) {
    start_initial_timeout(instance);
  }
  return;
}
}
void NCR_ResetInstance(NCR_Instance instance )
{
  {
  instance->tx_count = 0U;
  instance->presend_done = 0;
  instance->remote_poll = 0;
  instance->remote_stratum = 0;
  instance->remote_root_delay = 0.0;
  instance->remote_root_dispersion = 0.0;
  instance->remote_mono_epoch = (uint32_t )0;
  instance->mono_doffset = 0.0;
  instance->valid_rx = 0;
  instance->valid_timestamps = 0;
  UTI_ZeroNtp64(& instance->remote_ntp_monorx);
  UTI_ZeroNtp64(& instance->remote_ntp_rx);
  UTI_ZeroNtp64(& instance->remote_ntp_tx);
  UTI_ZeroNtp64(& instance->local_ntp_rx);
  UTI_ZeroNtp64(& instance->local_ntp_tx);
  zero_local_timestamp(& instance->local_rx);
  zero_local_timestamp(& instance->prev_local_tx);
  instance->prev_local_poll = 0;
  instance->prev_tx_count = 0U;
  instance->updated_init_timestamps = 0;
  UTI_ZeroNtp64(& instance->init_remote_ntp_tx);
  zero_local_timestamp(& instance->init_local_rx);
  if (instance->filter) {
    SPF_DropSamples(instance->filter);
  }
  return;
}
}
void NCR_ResetPoll(NCR_Instance instance )
{
  double tmp ;
  {
  if (instance->local_poll != instance->minpoll) {
    instance->local_poll = instance->minpoll;
    if (instance->tx_timeout_id) {
      tmp = get_transmit_delay(instance, 0, 0.0);
      restart_timeout(instance, tmp);
    }
  }
  return;
}
}
void NCR_ChangeRemoteAddress(NCR_Instance inst , NTP_Remote_Address *remote_addr ,
                             int ntp_only )
{
  uint32_t tmp ;
  {
  memset((void *)(& inst->report), 0, sizeof(inst->report));
  NCR_ResetInstance(inst);
  if (! ntp_only) {
    NAU_ChangeAddress(inst->auth, & remote_addr->ip_addr);
  }
  inst->remote_addr = *remote_addr;
  if ((unsigned int )inst->mode == 3U) {
    close_client_socket(inst);
  } else {
    NIO_CloseServerSocket(inst->local_addr.sock_fd);
    inst->local_addr.ip_addr.family = (uint16_t )0;
    inst->local_addr.if_index = -1;
    inst->local_addr.sock_fd = NIO_OpenServerSocket(remote_addr);
  }
  tmp = UTI_IPToRefid((IPAddr const *)(& remote_addr->ip_addr));
  SRC_SetRefid(inst->source, tmp, & inst->remote_addr.ip_addr);
  SRC_ResetInstance(inst->source);
  return;
}
}
static void adjust_poll(NCR_Instance inst , double adj )
{
  int tmp ;
  SST_Stats tmp___0 ;
  double tmp___1 ;
  {
  inst->poll_score += adj;
  if (inst->poll_score >= 1.0) {
    inst->local_poll += (int )inst->poll_score;
    inst->poll_score -= (double )((int )inst->poll_score);
  }
  if (inst->poll_score < 0.0) {
    inst->local_poll += (int )(inst->poll_score - 1.0);
    inst->poll_score -= (double )((int )(inst->poll_score - 1.0));
  }
  if (inst->local_poll < inst->minpoll) {
    inst->local_poll = inst->minpoll;
    inst->poll_score = (double )0;
  } else
  if (inst->local_poll > inst->maxpoll) {
    inst->local_poll = inst->maxpoll;
    inst->poll_score = 1.0;
  }
  if (inst->local_poll < 0) {
    tmp = SRC_IsReachable(inst->source);
    if (tmp) {
      tmp___0 = SRC_GetSourcestats(inst->source);
      tmp___1 = SST_MinRoundTripDelay(tmp___0);
      if (tmp___1 > 0.01) {
        inst->local_poll = 0;
      }
    } else {
      inst->local_poll = 0;
    }
  }
  return;
}
}
static double get_poll_adj(NCR_Instance inst , double error_in_estimate , double peer_distance )
{
  double poll_adj ;
  int samples___0 ;
  double tmp ;
  double tmp___0 ;
  SST_Stats tmp___1 ;
  {
  if (error_in_estimate > peer_distance) {
    tmp = log(error_in_estimate / peer_distance);
    tmp___0 = log(2.0);
    poll_adj = - tmp / tmp___0;
  } else {
    tmp___1 = SRC_GetSourcestats(inst->source);
    samples___0 = SST_Samples(tmp___1);
    poll_adj = ((double )samples___0 / (double )inst->poll_target - 1.0) / (double )inst->poll_target;
    if (samples___0 < inst->poll_target) {
      poll_adj *= 2.0;
    }
  }
  return (poll_adj);
}
}
static int get_transmit_poll(NCR_Instance inst )
{
  int poll ;
  int tmp ;
  {
  poll = inst->local_poll;
  if ((unsigned int )inst->mode == 1U) {
    if (poll > inst->remote_poll) {
      tmp = SRC_IsReachable(inst->source);
      if (tmp) {
        if (inst->remote_poll > inst->minpoll) {
          poll = inst->remote_poll;
        } else {
          poll = inst->minpoll;
        }
      }
    }
  }
  return (poll);
}
}
static double get_transmit_delay(NCR_Instance inst , int on_tx , double last_tx )
{
  int poll_to_use ;
  int stratum_diff ;
  double delay_time ;
  int tmp ;
  {
  poll_to_use = get_transmit_poll(inst);
  delay_time = UTI_Log2ToDouble(poll_to_use);
  {
  if ((unsigned int )inst->opmode == 0U) {
    goto case_0;
  }
  if ((unsigned int )inst->opmode == 1U) {
    goto case_1;
  }
  if ((unsigned int )inst->opmode == 2U) {
    goto case_2;
  }
  if ((unsigned int )inst->opmode == 3U) {
    goto case_2;
  }
  goto switch_default___0;
  case_0:
  assert(0);
  goto switch_break;
  case_1:
  {
  if ((unsigned int )inst->mode == 3U) {
    goto case_3;
  }
  if ((unsigned int )inst->mode == 1U) {
    goto case_1___0;
  }
  goto switch_default;
  case_3:
  if (inst->presend_done) {
    delay_time = 2.0;
  }
  goto switch_break___0;
  case_1___0:
  tmp = REF_GetOurStratum();
  stratum_diff = inst->remote_stratum - tmp;
  if (stratum_diff > 0) {
    if (last_tx * 1.1 < delay_time) {
      delay_time *= 1.1;
    } else {
      goto _L;
    }
  } else
  _L:
  if (! on_tx) {
    if (! stratum_diff) {
      if (last_tx / delay_time > 1.1 - 0.5) {
        delay_time *= 1.1;
      }
    }
  }
  if (last_tx > 0.0) {
    delay_time -= last_tx;
  }
  if (delay_time < 0.0) {
    delay_time = 0.0;
  }
  goto switch_break___0;
  switch_default:
  assert(0);
  goto switch_break___0;
  switch_break___0: ;
  }
  goto switch_break;
  case_2:
  case_3___0:
  if (2.0 < 0.25 * delay_time) {
    delay_time = 2.0;
  } else {
    delay_time = 0.25 * delay_time;
  }
  goto switch_break;
  switch_default___0:
  assert(0);
  goto switch_break;
  switch_break: ;
  }
  return (delay_time);
}
}
static double get_separation(int poll )
{
  double separation ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  {
  if (poll >= -6) {
    if (poll <= 24) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  assert(tmp);
  separation = UTI_Log2ToDouble(poll - 3);
  if (separation < 0.2) {
    tmp___3 = separation;
  } else {
    tmp___3 = 0.2;
  }
  if (0.002 > tmp___3) {
    tmp___2 = 0.002;
  } else {
    if (separation < 0.2) {
      tmp___1 = separation;
    } else {
      tmp___1 = 0.2;
    }
    tmp___2 = tmp___1;
  }
  return (tmp___2);
}
}
static void receive_timeout(void *arg )
{
  NCR_Instance inst ;
  char *tmp ;
  {
  inst = (NCR_Instance )arg;
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  inst->rx_timeout_id = (SCH_TimeoutID )0;
  close_client_socket(inst);
  return;
}
}
static int add_ext_exp1(NTP_Packet *message , NTP_PacketInfo *info , struct timespec *rx ,
                        double root_delay , double root_dispersion )
{
  struct timespec mono_rx ;
  NTP_ExtFieldExp1 exp1 ;
  NTP_int64 ts_fuzz ;
  int tmp ;
  {
  memset((void *)(& exp1), 0, sizeof(exp1));
  exp1.magic = __bswap_32(0xF5BEDD9AU);
  if ((unsigned int )info->mode != 3U) {
    exp1.root_delay = UTI_DoubleToNtp32f28(root_delay);
    exp1.root_dispersion = UTI_DoubleToNtp32f28(root_dispersion);
    if (rx) {
      UTI_AddDoubleToTimespec((struct timespec const *)rx, server_mono_offset, & mono_rx);
    } else {
      UTI_ZeroTimespec(& mono_rx);
    }
    UTI_GetNtp64Fuzz(& ts_fuzz, (int )message->precision);
    UTI_TimespecToNtp64((struct timespec const *)(& mono_rx), & exp1.mono_receive_ts,
                        (NTP_int64 const *)(& ts_fuzz));
    exp1.mono_epoch = __bswap_32(server_mono_epoch);
  }
  tmp = NEF_AddField(message, info, 0xF323, (void *)(& exp1), (int )sizeof(exp1));
  if (! tmp) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  info->ext_field_flags |= 0x1;
  return (1);
}
}
static int transmit_packet(NTP_Mode my_mode , int interleaved , int my_poll , int version ,
                           uint32_t kod , int ext_field_flags , NAU_Instance auth ,
                           NTP_int64 *remote_ntp_rx , NTP_int64 *remote_ntp_tx , NTP_Local_Timestamp *local_rx ,
                           NTP_Local_Timestamp *local_tx , NTP_int64 *local_ntp_rx ,
                           NTP_int64 *local_ntp_tx , NTP_Remote_Address *where_to ,
                           NTP_Local_Address *from , NTP_Packet *request , NTP_PacketInfo *request_info )
{
  NTP_PacketInfo info ;
  NTP_Packet message ;
  struct timespec local_receive ;
  struct timespec local_transmit ;
  double smooth_offset___0 ;
  double local_transmit_err ;
  int ret ;
  int precision ;
  NTP_int64 ts_fuzz ;
  int are_we_synchronised___0 ;
  int our_stratum___0 ;
  int smooth_time ;
  NTP_Leap leap_status ;
  uint32_t our_ref_id___0 ;
  struct timespec our_ref_time___0 ;
  double our_root_delay___0 ;
  double our_root_dispersion___0 ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  REF_LeapMode tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  struct timespec *tmp___9 ;
  int tmp___10 ;
  struct timespec *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  __uint32_t tmp___14 ;
  __uint32_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  {
  if (auth) {
    tmp = 1;
  } else
  if (request) {
    if (request_info) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  assert(tmp);
  if (version > 4) {
    version = 4;
  }
  if (interleaved) {
    if (! remote_ntp_rx) {
      interleaved = 0;
    } else
    if (! local_tx) {
      interleaved = 0;
    } else {
      tmp___0 = UTI_IsZeroTimespec(& local_tx->ts);
      if (tmp___0) {
        interleaved = 0;
      }
    }
  }
  smooth_time = 0;
  smooth_offset___0 = 0.0;
  SCH_GetLastEventTime(& local_transmit, (double *)((void *)0), (struct timespec *)((void *)0));
  if ((unsigned int )my_mode == 3U) {
    precision = 32;
    our_ref_id___0 = (uint32_t )0;
    our_stratum___0 = (int )our_ref_id___0;
    leap_status = (NTP_Leap )our_stratum___0;
    our_root_dispersion___0 = 0.0;
    our_root_delay___0 = our_root_dispersion___0;
    UTI_ZeroTimespec(& our_ref_time___0);
  } else {
    REF_GetReferenceParams(& local_transmit, & are_we_synchronised___0, & leap_status,
                           & our_stratum___0, & our_ref_id___0, & our_ref_time___0,
                           & our_root_delay___0, & our_root_dispersion___0);
    tmp___4 = SMT_IsEnabled();
    if (tmp___4) {
      if ((unsigned int )my_mode == 4U) {
        goto _L;
      } else
      if ((unsigned int )my_mode == 5U) {
        _L:
        smooth_offset___0 = SMT_GetOffset(& local_transmit);
        tmp___1 = fabs(smooth_offset___0);
        tmp___2 = LCL_GetSysPrecisionAsQuantum();
        smooth_time = tmp___1 > tmp___2;
        tmp___3 = REF_GetLeapMode();
        if ((unsigned int )tmp___3 == 1U) {
          if ((unsigned int )leap_status == 1U) {
            leap_status = (NTP_Leap )0;
          } else
          if ((unsigned int )leap_status == 2U) {
            leap_status = (NTP_Leap )0;
          }
        }
      }
    }
    precision = LCL_GetSysPrecisionAsLog();
  }
  if (smooth_time) {
    tmp___5 = UTI_IsZeroTimespec(& local_rx->ts);
    if (tmp___5) {
      local_receive = local_rx->ts;
    } else {
      our_ref_id___0 = (uint32_t )0x7F7F01FFUL;
      UTI_AddDoubleToTimespec((struct timespec const *)(& our_ref_time___0), smooth_offset___0,
                              & our_ref_time___0);
      UTI_AddDoubleToTimespec((struct timespec const *)(& local_rx->ts), smooth_offset___0,
                              & local_receive);
    }
  } else {
    local_receive = local_rx->ts;
  }
  if (kod != 0U) {
    leap_status = (NTP_Leap )3;
    our_stratum___0 = 0;
    our_ref_id___0 = kod;
  }
  message.lvm = (uint8_t )(((((unsigned int )leap_status << 6) & 192U) | (unsigned int )((version << 3) & 0x38)) | ((unsigned int )my_mode & 7U));
  if (our_stratum___0 < 16) {
    message.stratum = (uint8_t )our_stratum___0;
  } else {
    message.stratum = (uint8_t )0;
  }
  message.poll = (int8_t )my_poll;
  message.precision = (int8_t )precision;
  message.root_delay = UTI_DoubleToNtp32(our_root_delay___0);
  message.root_dispersion = UTI_DoubleToNtp32(our_root_dispersion___0);
  message.reference_id = __bswap_32(our_ref_id___0);
  UTI_TimespecToNtp64((struct timespec const *)(& our_ref_time___0), & message.reference_ts,
                      (NTP_int64 const *)((void *)0));
  if ((unsigned int )my_mode != 3U) {
    goto _L___0;
  } else
  if (interleaved) {
    _L___0:
    if (interleaved) {
      message.originate_ts = *remote_ntp_rx;
    } else {
      message.originate_ts = *remote_ntp_tx;
    }
    {
    while (1) {
      while_continue: ;
      UTI_GetNtp64Fuzz(& ts_fuzz, precision);
      UTI_TimespecToNtp64((struct timespec const *)(& local_receive), & message.receive_ts,
                          (NTP_int64 const *)(& ts_fuzz));
      tmp___6 = UTI_IsZeroNtp64((NTP_int64 const *)(& message.receive_ts));
      if (tmp___6) {
        goto while_break;
      } else {
        tmp___7 = UTI_IsEqualAnyNtp64((NTP_int64 const *)(& message.receive_ts),
                                      (NTP_int64 const *)(& message.originate_ts),
                                      (NTP_int64 const *)local_ntp_rx, (NTP_int64 const *)((void *)0));
        if (! tmp___7) {
          goto while_break;
        }
      }
    }
    while_break: ;
    }
  } else {
    UTI_ZeroNtp64(& message.originate_ts);
    UTI_ZeroNtp64(& message.receive_ts);
  }
  tmp___8 = parse_packet(& message, (int )((unsigned long )(& ((NTP_Packet *)0)->extensions)),
                         & info);
  if (! tmp___8) {
    return (0);
  }
  if (ext_field_flags) {
    if (ext_field_flags & 0x1) {
      if (smooth_time) {
        tmp___9 = (struct timespec *)((void *)0);
      } else {
        tmp___9 = & local_receive;
      }
      tmp___10 = add_ext_exp1(& message, & info, tmp___9, our_root_delay___0, our_root_dispersion___0);
      if (! tmp___10) {
        return (0);
      }
    }
  }
  {
  while (1) {
    while_continue___0: ;
    UTI_GetNtp64Fuzz(& ts_fuzz, precision);
    if (! interleaved) {
      if (precision < 32) {
        LCL_ReadCookedTime(& local_transmit, & local_transmit_err);
        if (smooth_time) {
          UTI_AddDoubleToTimespec((struct timespec const *)(& local_transmit), smooth_offset___0,
                                  & local_transmit);
        }
      }
    }
    if (interleaved) {
      tmp___11 = & local_tx->ts;
    } else {
      tmp___11 = & local_transmit;
    }
    UTI_TimespecToNtp64((struct timespec const *)tmp___11, & message.transmit_ts,
                        (NTP_int64 const *)(& ts_fuzz));
    tmp___12 = UTI_IsZeroNtp64((NTP_int64 const *)(& message.transmit_ts));
    if (tmp___12) {
      goto while_break___0;
    } else {
      tmp___13 = UTI_IsEqualAnyNtp64((NTP_int64 const *)(& message.transmit_ts),
                                     (NTP_int64 const *)(& message.receive_ts),
                                     (NTP_int64 const *)(& message.originate_ts),
                                     (NTP_int64 const *)local_ntp_tx);
      if (! tmp___13) {
        goto while_break___0;
      }
    }
  }
  while_break___0: ;
  }
  if ((unsigned int )my_mode == 4U) {
    tmp___14 = __bswap_32((__uint32_t )1);
    message.receive_ts.lo |= tmp___14;
    tmp___15 = __bswap_32((__uint32_t )1);
    message.transmit_ts.lo &= ~ tmp___15;
  } else
  if ((unsigned int )my_mode == 2U) {
    tmp___14 = __bswap_32((__uint32_t )1);
    message.receive_ts.lo |= tmp___14;
    tmp___15 = __bswap_32((__uint32_t )1);
    message.transmit_ts.lo &= ~ tmp___15;
  }
  if (auth) {
    tmp___16 = NAU_GenerateRequestAuth(auth, & message, & info);
    if (! tmp___16) {
      {
      while (1) {
        while_continue___1: ;
        goto while_break___1;
      }
      while_break___1: ;
      }
      return (0);
    }
  } else {
    tmp___17 = NAU_GenerateResponseAuth(request, request_info, & message, & info,
                                        where_to, from, kod);
    if (! tmp___17) {
      {
      while (1) {
        while_continue___2: ;
        goto while_break___2;
      }
      while_break___2: ;
      }
      return (0);
    }
  }
  if (request_info) {
    if (request_info->length < info.length) {
      {
      while (1) {
        while_continue___3: ;
        goto while_break___3;
      }
      while_break___3: ;
      }
      return (0);
    }
  }
  if (local_tx) {
    LCL_ReadCookedTime(& local_transmit, & local_transmit_err);
  }
  ret = NIO_SendPacket(& message, where_to, from, info.length, (unsigned long )local_tx != (unsigned long )((void *)0));
  if (local_tx) {
    if (smooth_time) {
      UTI_AddDoubleToTimespec((struct timespec const *)(& local_transmit), smooth_offset___0,
                              & local_transmit);
    }
    local_tx->ts = local_transmit;
    local_tx->err = local_transmit_err;
    local_tx->source = (NTP_Timestamp_Source )0;
  }
  if (local_ntp_rx) {
    *local_ntp_rx = message.receive_ts;
  }
  if (local_ntp_tx) {
    *local_ntp_tx = message.transmit_ts;
  }
  return (ret);
}
}
static void transmit_timeout(void *arg )
{
  NCR_Instance inst ;
  NTP_Local_Address local_addr ;
  int interleaved ;
  int initial ;
  int sent ;
  int tmp ;
  char *tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  NTP_Local_Timestamp *tmp___6 ;
  NTP_int64 *tmp___7 ;
  NTP_int64 *tmp___8 ;
  int tmp___9 ;
  double tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  double tmp___13 ;
  {
  inst = (NCR_Instance )arg;
  inst->tx_timeout_id = (SCH_TimeoutID )0;
  {
  if ((unsigned int )inst->opmode == 3U) {
    goto case_3;
  }
  if ((unsigned int )inst->opmode == 2U) {
    goto case_2;
  }
  if ((unsigned int )inst->opmode == 1U) {
    goto case_1;
  }
  goto switch_default;
  case_3:
  if (inst->burst_total_samples_to_go <= 1) {
    inst->opmode = (OperatingMode )1;
  }
  goto switch_break;
  case_2:
  if (inst->burst_total_samples_to_go <= 0) {
    take_offline(inst);
  }
  goto switch_break;
  case_1:
  if (inst->auto_burst) {
    if (inst->local_poll > inst->minpoll) {
      if (1 << (inst->local_poll - inst->minpoll) < 4) {
        tmp = 1 << (inst->local_poll - inst->minpoll);
      } else {
        tmp = 4;
      }
      NCR_InitiateSampleBurst(inst, 1, tmp);
    }
  }
  goto switch_break;
  switch_default:
  goto switch_break;
  switch_break: ;
  }
  if ((unsigned int )inst->opmode == 0U) {
    return;
  }
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  tmp___2 = NAU_PrepareRequestAuth(inst->auth);
  if (! tmp___2) {
    if (inst->burst_total_samples_to_go > 0) {
      (inst->burst_total_samples_to_go) --;
    }
    adjust_poll(inst, 0.25);
    SRC_UpdateReachability(inst->source, 0);
    tmp___1 = get_transmit_delay(inst, 1, 0.0);
    restart_timeout(inst, tmp___1);
    return;
  }
  if ((unsigned int )inst->mode == 3U) {
    close_client_socket(inst);
    assert(inst->local_addr.sock_fd == -2);
    inst->local_addr.sock_fd = NIO_OpenClientSocket(& inst->remote_addr);
  }
  local_addr.ip_addr.family = (uint16_t )0;
  local_addr.if_index = -1;
  local_addr.sock_fd = inst->local_addr.sock_fd;
  if (inst->interleaved) {
    if ((unsigned int )inst->mode == 3U) {
      if (inst->tx_count < 4U) {
        tmp___3 = 1;
      } else {
        goto _L;
      }
    } else
    _L:
    if ((unsigned int )inst->mode == 1U) {
      if (inst->prev_tx_count == 1U) {
        if (inst->tx_count == 0U) {
          tmp___3 = 1;
        } else {
          tmp___3 = 0;
        }
      } else {
        tmp___3 = 0;
      }
    } else {
      tmp___3 = 0;
    }
  } else {
    tmp___3 = 0;
  }
  interleaved = tmp___3;
  if ((unsigned int )inst->mode == 1U) {
    if (! inst->valid_rx) {
      tmp___4 = UTI_IsZeroNtp64((NTP_int64 const *)(& inst->init_remote_ntp_tx));
      if (tmp___4) {
        tmp___5 = 0;
      } else {
        tmp___5 = 1;
      }
    } else {
      tmp___5 = 0;
    }
  } else {
    tmp___5 = 0;
  }
  initial = tmp___5;
  inst->valid_rx = 0;
  inst->updated_init_timestamps = 0;
  if (initial) {
    inst->valid_timestamps = 0;
  }
  if (inst->presend_minpoll <= inst->local_poll) {
    if (! inst->presend_done) {
      if (! inst->burst_total_samples_to_go) {
        if (interleaved) {
          inst->presend_done = 2;
        } else {
          inst->presend_done = 1;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else
  _L___1:
  _L___0:
  if (inst->presend_done > 0) {
    (inst->presend_done) --;
  }
  if (initial) {
    tmp___6 = & inst->init_local_rx;
  } else {
    tmp___6 = & inst->local_rx;
  }
  if (initial) {
    tmp___7 = & inst->init_remote_ntp_tx;
  } else {
    tmp___7 = & inst->remote_ntp_tx;
  }
  if (initial) {
    tmp___8 = (NTP_int64 *)((void *)0);
  } else {
    tmp___8 = & inst->remote_ntp_rx;
  }
  sent = transmit_packet(inst->mode, interleaved, inst->local_poll, inst->version,
                         (uint32_t )0, inst->ext_field_flags, inst->auth, tmp___8,
                         tmp___7, tmp___6, & inst->local_tx, & inst->local_ntp_rx,
                         & inst->local_ntp_tx, & inst->remote_addr, & local_addr,
                         (NTP_Packet *)((void *)0), (NTP_PacketInfo *)((void *)0));
  (inst->tx_count) ++;
  if (sent) {
    (inst->report.total_tx_count) ++;
  }
  if (inst->tx_count >= 2U) {
    if (sent) {
      tmp___11 = SRC_IsSyncPeer(inst->source);
      if (tmp___11) {
        tmp___10 = 0.1;
      } else {
        tmp___10 = 0.25;
      }
      adjust_poll(inst, tmp___10);
    }
    SRC_UpdateReachability(inst->source, 0);
  }
  if (! sent) {
    if (inst->auto_offline) {
      NCR_SetConnectivity(inst, (SRC_Connectivity )0);
    }
  }
  {
  if ((unsigned int )inst->opmode == 3U) {
    goto case_3___0;
  }
  if ((unsigned int )inst->opmode == 2U) {
    goto case_2___0;
  }
  if ((unsigned int )inst->opmode == 0U) {
    goto case_0;
  }
  goto switch_default___0;
  case_3___0:
  if (! sent) {
    tmp___12 = SRC_IsReachable(inst->source);
    if (! tmp___12) {
      goto switch_break___0;
    }
  }
  case_2___0:
  (inst->burst_total_samples_to_go) --;
  goto switch_break___0;
  case_0:
  return;
  switch_default___0:
  goto switch_break___0;
  switch_break___0: ;
  }
  tmp___13 = get_transmit_delay(inst, 1, 0.0);
  restart_timeout(inst, tmp___13);
  if ((unsigned int )inst->mode == 3U) {
    inst->rx_timeout_id = SCH_AddTimeoutByDelay(inst->max_delay + 4.0, & receive_timeout,
                                                (void *)inst);
  }
  return;
}
}
static int is_zero_data(unsigned char *data , int length )
{
  int i ;
  {
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < length)) {
      goto while_break;
    }
    if ((int )*(data + i) != 0) {
      return (0);
    }
    i ++;
  }
  while_break: ;
  }
  return (1);
}
}
static int parse_packet(NTP_Packet *packet , int length , NTP_PacketInfo *info )
{
  int parsed ;
  int remainder___0 ;
  int ef_length ;
  int ef_type ;
  int ef_body_length ;
  unsigned char *data ;
  void *ef_body ;
  int tmp ;
  int tmp___0 ;
  __uint32_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  __uint32_t tmp___4 ;
  {
  if (length < (int )((unsigned long )(& ((NTP_Packet *)0)->extensions))) {
    goto _L;
  } else
  if ((unsigned int )length % 4U != 0U) {
    _L:
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  info->length = length;
  info->version = ((int )packet->lvm >> 3) & 0x7;
  info->mode = (NTP_Mode )((int )packet->lvm & 0x7);
  info->ext_fields = 0;
  info->ext_field_flags = 0;
  info->auth.mode = (NTP_AuthMode )0;
  if (info->version < 1) {
    goto _L___0;
  } else
  if (info->version > 4) {
    _L___0:
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
    return (0);
  }
  data = (unsigned char *)((void *)packet);
  parsed = (int )((unsigned long )(& ((NTP_Packet *)0)->extensions));
  remainder___0 = info->length - parsed;
  if (remainder___0 <= 0) {
    return (1);
  }
  assert(remainder___0 % 4 == 0);
  if (info->version <= 3) {
    info->auth.mode = (NTP_AuthMode )1;
    info->auth.mac.start = parsed;
    info->auth.mac.length = remainder___0;
    info->auth.mac.key_id = __bswap_32(*((uint32_t *)(data + parsed)));
    if (info->version == 3) {
      if (info->auth.mac.key_id != 0U) {
        if (remainder___0 == 20) {
          tmp___0 = is_zero_data((data + parsed) + 4, remainder___0 - 4);
          if (tmp___0) {
            info->auth.mode = (NTP_AuthMode )2;
          } else {
            goto _L___1;
          }
        } else
        _L___1:
        if (remainder___0 == 72) {
          tmp = is_zero_data((data + parsed) + 8, remainder___0 - 8);
          if (tmp) {
            info->auth.mode = (NTP_AuthMode )3;
          }
        }
      }
    }
    return (1);
  }
  if (remainder___0 == 4) {
    tmp___1 = __bswap_32(*((uint32_t *)(data + parsed)));
    if (tmp___1 == 0U) {
      info->auth.mode = (NTP_AuthMode )1;
      info->auth.mac.start = parsed;
      info->auth.mac.length = remainder___0;
      info->auth.mac.key_id = (uint32_t )0;
      return (1);
    }
  }
  {
  while (1) {
    while_continue___1: ;
    if (! (remainder___0 > 0)) {
      goto while_break___1;
    }
    if (remainder___0 >= 20) {
      if (remainder___0 <= 24) {
        goto while_break___1;
      }
    }
    tmp___2 = NEF_ParseField(packet, info->length, parsed, & ef_length, & ef_type,
                             & ef_body, & ef_body_length);
    if (! tmp___2) {
      {
      while (1) {
        while_continue___2: ;
        goto while_break___2;
      }
      while_break___2: ;
      }
      return (0);
    }
    if (ef_length > 0) {
      if (ef_length % 4 == 0) {
        tmp___3 = 1;
      } else {
        tmp___3 = 0;
      }
    } else {
      tmp___3 = 0;
    }
    assert(tmp___3);
    {
    if (ef_type == 0x0404) {
      goto case_1028;
    }
    if (ef_type == 0x0304) {
      goto case_1028;
    }
    if (ef_type == 0x0204) {
      goto case_1028;
    }
    if (ef_type == 0x0104) {
      goto case_1028;
    }
    if (ef_type == 0xF323) {
      goto case_62243;
    }
    goto switch_default;
    case_1028:
    case_772:
    case_516:
    case_260:
    info->auth.mode = (NTP_AuthMode )4;
    goto switch_break;
    case_62243:
    if ((unsigned long )ef_body_length == sizeof(NTP_ExtFieldExp1 )) {
      tmp___4 = __bswap_32(((NTP_ExtFieldExp1 *)ef_body)->magic);
      if (tmp___4 == 0xF5BEDD9AU) {
        info->ext_field_flags |= 0x1;
      }
    }
    goto switch_break;
    switch_default:
    {
    while (1) {
      while_continue___3: ;
      goto while_break___3;
    }
    while_break___3: ;
    }
    switch_break: ;
    }
    (info->ext_fields) ++;
    parsed += ef_length;
    remainder___0 = info->length - parsed;
  }
  while_break___1: ;
  }
  if (remainder___0 == 0) {
    return (1);
  } else
  if (remainder___0 >= 20) {
    info->auth.mode = (NTP_AuthMode )1;
    info->auth.mac.start = parsed;
    info->auth.mac.length = remainder___0;
    info->auth.mac.key_id = __bswap_32(*((uint32_t *)(data + parsed)));
    return (1);
  }
  {
  while (1) {
    while_continue___4: ;
    goto while_break___4;
  }
  while_break___4: ;
  }
  return (0);
}
}
static int check_delay_ratio(NCR_Instance inst , SST_Stats stats , struct timespec *sample_time ,
                             double delay )
{
  double last_sample_ago ;
  double predicted_offset ;
  double min_delay ;
  double skew ;
  double std_dev ;
  double max_delay ;
  int tmp ;
  double tmp___0 ;
  {
  if (inst->max_delay_ratio < 1.0) {
    return (1);
  } else {
    tmp = SST_GetDelayTestData(stats, sample_time, & last_sample_ago, & predicted_offset,
                               & min_delay, & skew, & std_dev);
    if (! tmp) {
      return (1);
    }
  }
  tmp___0 = LCL_GetMaxClockError();
  max_delay = min_delay * inst->max_delay_ratio + last_sample_ago * (skew + tmp___0);
  if (delay <= max_delay) {
    return (1);
  }
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  return (0);
}
}
static int check_delay_dev_ratio(NCR_Instance inst , SST_Stats stats , struct timespec *sample_time ,
                                 double offset , double delay )
{
  double last_sample_ago ;
  double predicted_offset ;
  double min_delay ;
  double skew ;
  double std_dev ;
  double delta ;
  double max_delta ;
  double error_in_estimate ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  {
  tmp = SST_GetDelayTestData(stats, sample_time, & last_sample_ago, & predicted_offset,
                             & min_delay, & skew, & std_dev);
  if (! tmp) {
    return (1);
  }
  tmp___0 = LCL_GetMaxClockError();
  max_delta = std_dev * inst->max_delay_dev_ratio + last_sample_ago * (skew + tmp___0);
  delta = (delay - min_delay) / 2.0;
  if (delta <= max_delta) {
    return (1);
  }
  error_in_estimate = offset + predicted_offset;
  tmp___1 = fabs(error_in_estimate);
  if (tmp___1 - delta > max_delta) {
    return (1);
  }
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  return (0);
}
}
static int check_sync_loop(NCR_Instance inst , NTP_Packet *message , NTP_Local_Address *local_addr ,
                           struct timespec *local_ts )
{
  double our_root_delay___0 ;
  double our_root_dispersion___0 ;
  int are_we_synchronised___0 ;
  int our_stratum___0 ;
  struct timespec our_ref_time___0 ;
  NTP_Leap leap_status ;
  uint32_t our_ref_id___0 ;
  int tmp ;
  REF_Mode tmp___0 ;
  uint32_t tmp___1 ;
  __uint32_t tmp___2 ;
  NTP_int64 ntp_ref_time ;
  char *tmp___3 ;
  int tmp___4 ;
  __uint32_t tmp___5 ;
  NTP_int32 tmp___6 ;
  int tmp___7 ;
  {
  tmp = NIO_IsServerSocketOpen();
  if (tmp) {
    tmp___0 = REF_GetMode();
    if ((unsigned int )tmp___0 != 0U) {
      return (1);
    }
  } else {
    return (1);
  }
  if ((int )message->stratum > 1) {
    tmp___1 = UTI_IPToRefid((IPAddr const *)(& local_addr->ip_addr));
    tmp___2 = __bswap_32(tmp___1);
    if (message->reference_id == tmp___2) {
      return (0);
    }
  }
  REF_GetReferenceParams(local_ts, & are_we_synchronised___0, & leap_status, & our_stratum___0,
                         & our_ref_id___0, & our_ref_time___0, & our_root_delay___0,
                         & our_root_dispersion___0);
  if ((int )message->stratum == our_stratum___0) {
    tmp___5 = __bswap_32(our_ref_id___0);
    if (message->reference_id == tmp___5) {
      tmp___6 = UTI_DoubleToNtp32(our_root_delay___0);
      if (message->root_delay == tmp___6) {
        tmp___7 = UTI_IsZeroNtp64((NTP_int64 const *)(& message->reference_ts));
        if (! tmp___7) {
          UTI_TimespecToNtp64((struct timespec const *)(& our_ref_time___0), & ntp_ref_time,
                              (NTP_int64 const *)((void *)0));
          tmp___4 = UTI_CompareNtp64((NTP_int64 const *)(& message->reference_ts),
                                     (NTP_int64 const *)(& ntp_ref_time));
          if (tmp___4 == 0) {
            {
            while (1) {
              while_continue: ;
              goto while_break;
            }
            while_break: ;
            }
            return (0);
          }
        }
      }
    }
  }
  return (1);
}
}
static void process_sample(NCR_Instance inst , NTP_Sample *sample )
{
  double estimated_offset ;
  double error_in_estimate ;
  double filtered_sample_ago ;
  NTP_Sample filtered_sample ;
  int filtered_samples ;
  int tmp ;
  double tmp___0 ;
  SST_Stats tmp___1 ;
  SST_Stats tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  {
  if (inst->filter) {
    SPF_AccumulateSample(inst->filter, sample);
    filtered_samples = SPF_GetNumberOfSamples(inst->filter);
    tmp = SPF_GetFilteredSample(inst->filter, & filtered_sample);
    if (! tmp) {
      return;
    }
    filtered_sample_ago = UTI_DiffTimespecsToDouble((struct timespec const *)(& sample->time),
                                                    (struct timespec const *)(& filtered_sample.time));
    tmp___0 = UTI_Log2ToDouble(inst->local_poll);
    if (filtered_sample_ago > (double )(4 * filtered_samples) * tmp___0) {
      {
      while (1) {
        while_continue: ;
        goto while_break;
      }
      while_break: ;
      }
      return;
    }
    sample = & filtered_sample;
  }
  tmp___1 = SRC_GetSourcestats(inst->source);
  estimated_offset = SST_PredictOffset(tmp___1, & sample->time);
  error_in_estimate = fabs(- sample->offset - estimated_offset);
  if (inst->mono_doffset != 0.0) {
    tmp___3 = fabs(inst->mono_doffset);
    if (tmp___3 <= 16.0) {
      {
      while (1) {
        while_continue___0: ;
        goto while_break___0;
      }
      while_break___0: ;
      }
      tmp___2 = SRC_GetSourcestats(inst->source);
      SST_CorrectOffset(tmp___2, inst->mono_doffset);
    }
  }
  inst->mono_doffset = 0.0;
  SRC_AccumulateSample(inst->source, sample);
  SRC_SelectSource(inst->source);
  tmp___4 = get_poll_adj(inst, error_in_estimate, sample->peer_dispersion + 0.5 * sample->peer_delay);
  adjust_poll(inst, tmp___4);
  return;
}
}
static int process_response(NCR_Instance inst , NTP_Local_Address *local_addr , NTP_Local_Timestamp *rx_ts ,
                            NTP_Packet *message , NTP_PacketInfo *info )
{
  NTP_Sample sample ;
  SST_Stats stats ;
  int pkt_leap ;
  int pkt_version ;
  uint32_t pkt_refid ;
  double pkt_root_delay ;
  double pkt_root_dispersion ;
  double skew ;
  double source_freq_lo ;
  double source_freq_hi ;
  int test1 ;
  int test2n ;
  int test2i ;
  int test2 ;
  int test3 ;
  int test5 ;
  int test6 ;
  int test7 ;
  int interleaved_packet ;
  int valid_packet ;
  int synced_packet ;
  int testA ;
  int testB ;
  int testC ;
  int testD ;
  int good_packet ;
  int kod_rate ;
  int parsed ;
  int ef_length ;
  int ef_type ;
  int ef_body_length ;
  void *ef_body ;
  NTP_ExtFieldExp1 *ef_exp1 ;
  NTP_Local_Timestamp local_receive ;
  NTP_Local_Timestamp local_transmit ;
  double remote_interval ;
  double local_interval ;
  double response_time ;
  double delay_time ;
  double precision ;
  double mono_doffset ;
  int updated_timestamps ;
  int tmp ;
  __uint32_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  struct timespec remote_receive ;
  struct timespec remote_transmit ;
  struct timespec remote_request_receive ;
  struct timespec local_average ;
  struct timespec remote_average ;
  struct timespec prev_remote_transmit ;
  double prev_remote_poll_interval ;
  double root_delay ;
  double root_dispersion ;
  double tmp___17 ;
  double tmp___18 ;
  double tmp___19 ;
  __uint32_t tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  double tmp___24 ;
  double tmp___25 ;
  double tmp___26 ;
  double tmp___27 ;
  double tmp___28 ;
  double tmp___29 ;
  double tmp___30 ;
  double tmp___31 ;
  double tmp___32 ;
  double tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  double tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  int tmp___49 ;
  __uint32_t tmp___50 ;
  int tmp___51 ;
  double tmp___52 ;
  double tmp___53 ;
  char *tmp___54 ;
  double tmp___55 ;
  int tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  {
  stats = SRC_GetSourcestats(inst->source);
  ef_exp1 = (NTP_ExtFieldExp1 *)((void *)0);
  if (inst->ext_field_flags & info->ext_field_flags) {
    parsed = (int )((unsigned long )(& ((NTP_Packet *)0)->extensions));
    {
    while (1) {
      while_continue: ;
      if (! (parsed < info->length)) {
        goto while_break;
      }
      tmp = NEF_ParseField(message, info->length, parsed, & ef_length, & ef_type,
                           & ef_body, & ef_body_length);
      if (! tmp) {
        goto while_break;
      }
      {
      if (ef_type == 0xF323) {
        goto case_62243;
      }
      goto switch_break;
      case_62243:
      if (inst->ext_field_flags & 0x1) {
        if ((unsigned long )ef_body_length == sizeof(*ef_exp1)) {
          tmp___0 = __bswap_32(((NTP_ExtFieldExp1 *)ef_body)->magic);
          if (tmp___0 == 0xF5BEDD9AU) {
            ef_exp1 = (NTP_ExtFieldExp1 *)ef_body;
          }
        }
      }
      goto switch_break;
      switch_break: ;
      }
      parsed += ef_length;
    }
    while_break: ;
    }
  }
  pkt_leap = ((int )message->lvm >> 6) & 0x3;
  pkt_version = ((int )message->lvm >> 3) & 0x7;
  pkt_refid = __bswap_32(message->reference_id);
  if (ef_exp1) {
    pkt_root_delay = UTI_Ntp32f28ToDouble(ef_exp1->root_delay);
    pkt_root_dispersion = UTI_Ntp32f28ToDouble(ef_exp1->root_dispersion);
  } else {
    pkt_root_delay = UTI_Ntp32ToDouble(message->root_delay);
    pkt_root_dispersion = UTI_Ntp32ToDouble(message->root_dispersion);
  }
  tmp___1 = UTI_CompareNtp64((NTP_int64 const *)(& message->receive_ts), (NTP_int64 const *)(& inst->remote_ntp_rx));
  if (tmp___1) {
    tmp___3 = 1;
  } else {
    tmp___2 = UTI_CompareNtp64((NTP_int64 const *)(& message->transmit_ts), (NTP_int64 const *)(& inst->remote_ntp_tx));
    if (tmp___2) {
      tmp___3 = 1;
    } else {
      tmp___3 = 0;
    }
  }
  test1 = tmp___3;
  tmp___4 = UTI_CompareNtp64((NTP_int64 const *)(& message->originate_ts), (NTP_int64 const *)(& inst->local_ntp_tx));
  if (tmp___4) {
    tmp___5 = 0;
  } else {
    tmp___5 = 1;
  }
  test2n = tmp___5;
  if (inst->interleaved) {
    tmp___6 = UTI_CompareNtp64((NTP_int64 const *)(& message->originate_ts), (NTP_int64 const *)(& inst->local_ntp_rx));
    if (tmp___6) {
      tmp___7 = 0;
    } else {
      tmp___7 = 1;
    }
  } else {
    tmp___7 = 0;
  }
  test2i = tmp___7;
  if (test2n) {
    tmp___8 = 1;
  } else
  if (test2i) {
    tmp___8 = 1;
  } else {
    tmp___8 = 0;
  }
  test2 = tmp___8;
  if (! test2n) {
    if (test2i) {
      tmp___9 = 1;
    } else {
      tmp___9 = 0;
    }
  } else {
    tmp___9 = 0;
  }
  interleaved_packet = tmp___9;
  tmp___10 = UTI_IsZeroNtp64((NTP_int64 const *)(& message->originate_ts));
  if (tmp___10) {
    tmp___13 = 0;
  } else {
    tmp___11 = UTI_IsZeroNtp64((NTP_int64 const *)(& message->receive_ts));
    if (tmp___11) {
      tmp___13 = 0;
    } else {
      tmp___12 = UTI_IsZeroNtp64((NTP_int64 const *)(& message->transmit_ts));
      if (tmp___12) {
        tmp___13 = 0;
      } else {
        tmp___13 = 1;
      }
    }
  }
  test3 = tmp___13;
  test5 = NAU_CheckResponseAuth(inst->auth, message, info);
  if (pkt_leap != 3) {
    if ((int )message->stratum < 16) {
      if ((int )message->stratum != 0) {
        tmp___14 = 1;
      } else {
        tmp___14 = 0;
      }
    } else {
      tmp___14 = 0;
    }
  } else {
    tmp___14 = 0;
  }
  test6 = tmp___14;
  test7 = pkt_root_delay / 2.0 + pkt_root_dispersion < 16.0;
  if (test1) {
    if (test2) {
      if (test3) {
        if (test5) {
          tmp___15 = 1;
        } else {
          tmp___15 = 0;
        }
      } else {
        tmp___15 = 0;
      }
    } else {
      tmp___15 = 0;
    }
  } else {
    tmp___15 = 0;
  }
  valid_packet = tmp___15;
  if (valid_packet) {
    if (test6) {
      if (test7) {
        tmp___16 = 1;
      } else {
        tmp___16 = 0;
      }
    } else {
      tmp___16 = 0;
    }
  } else {
    tmp___16 = 0;
  }
  synced_packet = tmp___16;
  kod_rate = 0;
  if (test1) {
    if (test2) {
      if (test5) {
        if (pkt_leap == 3) {
          if ((int )message->stratum == 0) {
            if ((unsigned long )pkt_refid == 0x52415445UL) {
              kod_rate = 1;
            }
          }
        }
      }
    }
  }
  if (synced_packet) {
    if (! interleaved_packet) {
      goto _L___2;
    } else
    if (inst->valid_timestamps) {
      _L___2:
      if (ef_exp1) {
        tmp___20 = __bswap_32(ef_exp1->mono_epoch);
        if (inst->remote_mono_epoch == tmp___20) {
          tmp___21 = UTI_IsZeroNtp64((NTP_int64 const *)(& ef_exp1->mono_receive_ts));
          if (tmp___21) {
            mono_doffset = 0.0;
          } else {
            tmp___22 = UTI_IsZeroNtp64((NTP_int64 const *)(& inst->remote_ntp_monorx));
            if (tmp___22) {
              mono_doffset = 0.0;
            } else {
              tmp___17 = UTI_DiffNtp64ToDouble((NTP_int64 const *)(& ef_exp1->mono_receive_ts),
                                               (NTP_int64 const *)(& inst->remote_ntp_monorx));
              tmp___18 = UTI_DiffNtp64ToDouble((NTP_int64 const *)(& message->receive_ts),
                                               (NTP_int64 const *)(& inst->remote_ntp_rx));
              mono_doffset = tmp___17 - tmp___18;
              tmp___19 = fabs(mono_doffset);
              if (tmp___19 > 16.0) {
                mono_doffset = 0.0;
              }
            }
          }
        } else {
          mono_doffset = 0.0;
        }
      } else {
        mono_doffset = 0.0;
      }
      if (interleaved_packet) {
        tmp___23 = UTI_IsZeroTimespec(& inst->prev_local_tx.ts);
        if (tmp___23) {
          _L:
          UTI_Ntp64ToTimespec((NTP_int64 const *)(& message->receive_ts), & remote_receive);
          UTI_Ntp64ToTimespec((NTP_int64 const *)(& inst->remote_ntp_rx), & remote_request_receive);
          local_transmit = inst->local_tx;
          if (pkt_root_delay > inst->remote_root_delay) {
            root_delay = pkt_root_delay;
          } else {
            root_delay = inst->remote_root_delay;
          }
          if (pkt_root_dispersion > inst->remote_root_dispersion) {
            root_dispersion = pkt_root_dispersion;
          } else {
            root_dispersion = inst->remote_root_dispersion;
          }
        } else {
          tmp___24 = UTI_DiffTimespecsToDouble((struct timespec const *)(& inst->local_tx.ts),
                                               (struct timespec const *)(& inst->local_rx.ts));
          tmp___25 = UTI_DiffTimespecsToDouble((struct timespec const *)(& inst->local_rx.ts),
                                               (struct timespec const *)(& inst->prev_local_tx.ts));
          if (0.1 * tmp___24 > tmp___25) {
            UTI_Ntp64ToTimespec((NTP_int64 const *)(& inst->remote_ntp_rx), & remote_receive);
            UTI_AddDoubleToTimespec((struct timespec const *)(& remote_receive),
                                    - mono_doffset, & remote_receive);
            remote_request_receive = remote_receive;
            local_transmit = inst->prev_local_tx;
            root_delay = inst->remote_root_delay;
            root_dispersion = inst->remote_root_dispersion;
          } else {
            goto _L;
          }
        }
        UTI_Ntp64ToTimespec((NTP_int64 const *)(& message->transmit_ts), & remote_transmit);
        UTI_AddDoubleToTimespec((struct timespec const *)(& remote_transmit), - mono_doffset,
                                & remote_transmit);
        UTI_Ntp64ToTimespec((NTP_int64 const *)(& inst->remote_ntp_tx), & prev_remote_transmit);
        local_receive = inst->local_rx;
      } else {
        UTI_Ntp64ToTimespec((NTP_int64 const *)(& message->receive_ts), & remote_receive);
        UTI_Ntp64ToTimespec((NTP_int64 const *)(& message->transmit_ts), & remote_transmit);
        UTI_ZeroTimespec(& prev_remote_transmit);
        remote_request_receive = remote_receive;
        local_receive = *rx_ts;
        local_transmit = inst->local_tx;
        root_delay = pkt_root_delay;
        root_dispersion = pkt_root_dispersion;
      }
      UTI_AverageDiffTimespecs((struct timespec const *)(& remote_receive), (struct timespec const *)(& remote_transmit),
                               & remote_average, & remote_interval);
      UTI_AverageDiffTimespecs((struct timespec const *)(& local_transmit.ts), (struct timespec const *)(& local_receive.ts),
                               & local_average, & local_interval);
      tmp___26 = UTI_DiffTimespecsToDouble((struct timespec const *)(& remote_transmit),
                                           (struct timespec const *)(& remote_request_receive));
      response_time = fabs(tmp___26);
      tmp___27 = LCL_GetSysPrecisionAsQuantum();
      tmp___28 = UTI_Log2ToDouble((int )message->precision);
      precision = tmp___27 + tmp___28;
      sample.peer_delay = fabs(local_interval - remote_interval);
      if (sample.peer_delay < precision) {
        sample.peer_delay = precision;
      }
      sample.offset = UTI_DiffTimespecsToDouble((struct timespec const *)(& remote_average),
                                                (struct timespec const *)(& local_average));
      sample.offset += inst->offset_correction;
      sample.time = local_average;
      SST_GetFrequencyRange(stats, & source_freq_lo, & source_freq_hi);
      skew = (source_freq_hi - source_freq_lo) / 2.0;
      if (local_transmit.err > local_receive.err) {
        tmp___32 = local_transmit.err;
      } else {
        tmp___32 = local_receive.err;
      }
      if (precision > tmp___32) {
        tmp___31 = precision;
      } else {
        if (local_transmit.err > local_receive.err) {
          tmp___30 = local_transmit.err;
        } else {
          tmp___30 = local_receive.err;
        }
        tmp___31 = tmp___30;
      }
      tmp___33 = fabs(local_interval);
      sample.peer_dispersion = tmp___31 + skew * tmp___33;
      sample.root_delay = root_delay + sample.peer_delay;
      sample.root_dispersion = root_dispersion + sample.peer_dispersion;
      if (inst->remote_poll < inst->prev_local_poll) {
        tmp___34 = inst->remote_poll;
      } else {
        tmp___34 = inst->prev_local_poll;
      }
      prev_remote_poll_interval = UTI_Log2ToDouble(tmp___34);
      if (sample.peer_delay - sample.peer_dispersion <= inst->max_delay) {
        if (precision <= inst->max_delay) {
          if ((unsigned int )inst->mode == 3U) {
            if (response_time > 4.0) {
              tmp___37 = 0;
            } else {
              goto _L___0;
            }
          } else
          _L___0:
          if ((unsigned int )inst->mode == 1U) {
            if (interleaved_packet) {
              if (sample.peer_delay > 0.5 * prev_remote_poll_interval) {
                tmp___37 = 0;
              } else {
                tmp___35 = UTI_CompareNtp64((NTP_int64 const *)(& message->receive_ts),
                                            (NTP_int64 const *)(& message->transmit_ts));
                if (tmp___35 <= 0) {
                  tmp___37 = 0;
                } else
                if (inst->remote_poll <= inst->prev_local_poll) {
                  tmp___36 = UTI_DiffTimespecsToDouble((struct timespec const *)(& remote_transmit),
                                                       (struct timespec const *)(& prev_remote_transmit));
                  if (tmp___36 > 1.5 * prev_remote_poll_interval) {
                    tmp___37 = 0;
                  } else {
                    tmp___37 = 1;
                  }
                } else {
                  tmp___37 = 1;
                }
              }
            } else {
              tmp___37 = 1;
            }
          } else {
            tmp___37 = 1;
          }
        } else {
          tmp___37 = 0;
        }
      } else {
        tmp___37 = 0;
      }
      testA = tmp___37;
      testB = check_delay_ratio(inst, stats, & sample.time, sample.peer_delay);
      testC = check_delay_dev_ratio(inst, stats, & sample.time, sample.offset, sample.peer_delay);
      testD = check_sync_loop(inst, message, local_addr, & rx_ts->ts);
    } else {
      goto _L___1;
    }
  } else {
    _L___1:
    response_time = 0.0;
    local_interval = response_time;
    remote_interval = local_interval;
    sample.peer_dispersion = 0.0;
    sample.peer_delay = sample.peer_dispersion;
    sample.offset = sample.peer_delay;
    sample.root_dispersion = 0.0;
    sample.root_delay = sample.root_dispersion;
    sample.time = rx_ts->ts;
    mono_doffset = 0.0;
    local_receive = *rx_ts;
    local_transmit = inst->local_tx;
    testD = 0;
    testC = testD;
    testB = testC;
    testA = testB;
  }
  if (testA) {
    if (testB) {
      if (testC) {
        if (testD) {
          tmp___38 = 1;
        } else {
          tmp___38 = 0;
        }
      } else {
        tmp___38 = 0;
      }
    } else {
      tmp___38 = 0;
    }
  } else {
    tmp___38 = 0;
  }
  good_packet = tmp___38;
  if ((unsigned int )inst->mode == 3U) {
    if (valid_packet) {
      if (! inst->valid_rx) {
        goto _L___5;
      } else {
        goto _L___8;
      }
    } else {
      goto _L___8;
    }
  } else
  _L___8:
  _L___7:
  if ((unsigned int )inst->mode == 1U) {
    if (valid_packet) {
      if (! inst->valid_rx) {
        goto _L___5;
      } else {
        tmp___42 = UTI_CompareNtp64((NTP_int64 const *)(& inst->remote_ntp_tx),
                                    (NTP_int64 const *)(& message->transmit_ts));
        if (tmp___42 < 0) {
          _L___5:
          _L___3:
          inst->remote_ntp_rx = message->receive_ts;
          inst->remote_ntp_tx = message->transmit_ts;
          inst->local_rx = *rx_ts;
          inst->valid_timestamps = synced_packet;
          UTI_ZeroNtp64(& inst->init_remote_ntp_tx);
          zero_local_timestamp(& inst->init_local_rx);
          inst->updated_init_timestamps = 0;
          updated_timestamps = 2;
          if (ef_exp1) {
            tmp___39 = UTI_IsZeroNtp64((NTP_int64 const *)(& ef_exp1->mono_receive_ts));
            if (tmp___39) {
              inst->remote_mono_epoch = (uint32_t )0;
              UTI_ZeroNtp64(& inst->remote_ntp_monorx);
              inst->mono_doffset = 0.0;
            } else {
              inst->remote_mono_epoch = __bswap_32(ef_exp1->mono_epoch);
              inst->remote_ntp_monorx = ef_exp1->mono_receive_ts;
              inst->mono_doffset += mono_doffset;
            }
          } else {
            inst->remote_mono_epoch = (uint32_t )0;
            UTI_ZeroNtp64(& inst->remote_ntp_monorx);
            inst->mono_doffset = 0.0;
          }
          if (interleaved_packet) {
            inst->prev_local_tx = inst->local_tx;
          } else {
            zero_local_timestamp(& inst->prev_local_tx);
          }
        } else {
          goto _L___6;
        }
      }
    } else {
      goto _L___6;
    }
  } else
  _L___6:
  _L___4:
  if ((unsigned int )inst->mode == 1U) {
    if (test1) {
      tmp___40 = UTI_IsZeroNtp64((NTP_int64 const *)(& message->transmit_ts));
      if (tmp___40) {
        updated_timestamps = 0;
      } else
      if (test5) {
        if (! inst->updated_init_timestamps) {
          inst->init_remote_ntp_tx = message->transmit_ts;
          inst->init_local_rx = *rx_ts;
          inst->updated_init_timestamps = 1;
          updated_timestamps = 1;
        } else {
          tmp___41 = UTI_CompareNtp64((NTP_int64 const *)(& inst->init_remote_ntp_tx),
                                      (NTP_int64 const *)(& message->transmit_ts));
          if (tmp___41 < 0) {
            inst->init_remote_ntp_tx = message->transmit_ts;
            inst->init_local_rx = *rx_ts;
            inst->updated_init_timestamps = 1;
            updated_timestamps = 1;
          } else {
            updated_timestamps = 0;
          }
        }
      } else {
        updated_timestamps = 0;
      }
    } else {
      updated_timestamps = 0;
    }
  } else {
    updated_timestamps = 0;
  }
  if (inst->valid_rx) {
    test3 = 0;
    test2 = test3;
    good_packet = 0;
    synced_packet = good_packet;
    valid_packet = synced_packet;
  } else
  if (valid_packet) {
    if (inst->presend_done) {
      testA = 0;
      good_packet = 0;
    }
    inst->valid_rx = 1;
  }
  if ((unsigned long )((unsigned int )local_receive.source) >= sizeof(tss_chars)) {
    assert(0);
  } else
  if ((unsigned long )((unsigned int )local_transmit.source) >= sizeof(tss_chars)) {
    assert(0);
  }
  {
  while (1) {
    while_continue___0: ;
    goto while_break___0;
  }
  while_break___0: ;
  }
  {
  while (1) {
    while_continue___1: ;
    goto while_break___1;
  }
  while_break___1: ;
  }
  {
  while (1) {
    while_continue___2: ;
    goto while_break___2;
  }
  while_break___2: ;
  }
  {
  while (1) {
    while_continue___3: ;
    goto while_break___3;
  }
  while_break___3: ;
  }
  {
  while (1) {
    while_continue___4: ;
    goto while_break___4;
  }
  while_break___4: ;
  }
  if (valid_packet) {
    inst->remote_poll = (int )message->poll;
    if ((int )message->stratum != 0) {
      if ((int )message->stratum < 16) {
        tmp___49 = (int )message->stratum;
      } else {
        tmp___49 = 16;
      }
      inst->remote_stratum = tmp___49;
    } else {
      inst->remote_stratum = 16;
    }
    inst->remote_root_delay = pkt_root_delay;
    inst->remote_root_dispersion = pkt_root_dispersion;
    inst->prev_local_poll = inst->local_poll;
    inst->prev_tx_count = inst->tx_count;
    inst->tx_count = 0U;
    SRC_UpdateReachability(inst->source, synced_packet);
    if (synced_packet) {
      if (inst->copy) {
        if (inst->remote_stratum > 0) {
          (inst->remote_stratum) --;
          tmp___50 = __bswap_32(message->reference_id);
          SRC_SetRefid(inst->source, tmp___50, & inst->remote_addr.ip_addr);
        }
      }
      if (inst->remote_stratum > inst->min_stratum) {
        tmp___51 = inst->remote_stratum;
      } else {
        tmp___51 = inst->min_stratum;
      }
      SRC_UpdateStatus(inst->source, tmp___51, (NTP_Leap )pkt_leap);
    }
    if (good_packet) {
      process_sample(inst, & sample);
      {
      if ((unsigned int )inst->opmode == 2U) {
        goto case_2;
      }
      if ((unsigned int )inst->opmode == 3U) {
        goto case_2;
      }
      goto switch_default;
      case_2:
      case_3:
      (inst->burst_good_samples_to_go) --;
      if (inst->burst_good_samples_to_go <= 0) {
        if ((unsigned int )inst->opmode == 3U) {
          inst->opmode = (OperatingMode )1;
        } else {
          take_offline(inst);
        }
      }
      goto switch_break___0;
      switch_default:
      goto switch_break___0;
      switch_break___0: ;
      }
    } else {
      if (testD) {
        tmp___52 = 0.02;
      } else {
        tmp___52 = 0.1;
      }
      adjust_poll(inst, tmp___52);
    }
    close_client_socket(inst);
    inst->local_addr.ip_addr = local_addr->ip_addr;
    inst->local_addr.if_index = local_addr->if_index;
    if ((unsigned int )inst->opmode != 0U) {
      tmp___53 = UTI_DiffTimespecsToDouble((struct timespec const *)(& inst->local_rx.ts),
                                           (struct timespec const *)(& inst->local_tx.ts));
      delay_time = get_transmit_delay(inst, 0, tmp___53);
      if (kod_rate) {
        tmp___54 = UTI_IPToString((IPAddr const *)(& inst->remote_addr.ip_addr));
        LOG_Message((LOG_Severity )1, (char const *)"Received KoD RATE from %s",
                    tmp___54);
        tmp___55 = UTI_Log2ToDouble(inst->local_poll);
        delay_time += (double )4 * tmp___55;
        if ((unsigned int )inst->opmode == 2U) {
          inst->burst_good_samples_to_go = 0;
        } else
        if ((unsigned int )inst->opmode == 3U) {
          inst->burst_good_samples_to_go = 0;
        }
      }
      assert((int )inst->tx_timeout_id);
      restart_timeout(inst, delay_time);
    }
    inst->report.remote_addr = inst->remote_addr.ip_addr;
    inst->report.local_addr = inst->local_addr.ip_addr;
    inst->report.remote_port = inst->remote_addr.port;
    inst->report.leap = (uint8_t )pkt_leap;
    inst->report.version = (uint8_t )pkt_version;
    inst->report.mode = (uint8_t )((int )message->lvm & 0x7);
    inst->report.stratum = message->stratum;
    inst->report.poll = message->poll;
    inst->report.precision = message->precision;
    inst->report.root_delay = pkt_root_delay;
    inst->report.root_dispersion = pkt_root_dispersion;
    inst->report.ref_id = pkt_refid;
    UTI_Ntp64ToTimespec((NTP_int64 const *)(& message->reference_ts), & inst->report.ref_time);
    inst->report.offset = sample.offset;
    inst->report.peer_delay = sample.peer_delay;
    inst->report.peer_dispersion = sample.peer_dispersion;
    inst->report.response_time = response_time;
    inst->report.jitter_asymmetry = SST_GetJitterAsymmetry(stats);
    inst->report.tests = (uint16_t )((((((((((((((((((test1 << 1) | test2) << 1) | test3) << 1) | test5) << 1) | test6) << 1) | test7) << 1) | testA) << 1) | testB) << 1) | testC) << 1) | testD);
    inst->report.interleaved = interleaved_packet;
    inst->report.authenticated = NAU_IsAuthEnabled(inst->auth);
    inst->report.tx_tss_char = (char )tss_chars[local_transmit.source];
    inst->report.rx_tss_char = (char )tss_chars[local_receive.source];
    (inst->report.total_valid_count) ++;
  }
  if (logfileid___2 != -1) {
    if (log_raw_measurements) {
      goto _L___9;
    } else
    if (synced_packet) {
      _L___9:
      if (interleaved_packet) {
        tmp___56 = 'I';
      } else {
        tmp___56 = 'B';
      }
      tmp___57 = UTI_IPToString((IPAddr const *)(& inst->remote_addr.ip_addr));
      tmp___58 = UTI_TimeToLogForm(sample.time.tv_sec);
      LOG_FileWrite(logfileid___2, (char const *)"%s %-15s %1c %2d %1d%1d%1d %1d%1d%1d %1d%1d%1d%d  %2d %2d %4.2f %10.3e %10.3e %10.3e %10.3e %10.3e %08X %1d%1c %1c %1c",
                    tmp___58, tmp___57, (int const )leap_chars[pkt_leap], (int )message->stratum,
                    test1, test2, test3, test5, test6, test7, testA, testB, testC,
                    testD, inst->local_poll, (int )message->poll, inst->poll_score,
                    sample.offset, sample.peer_delay, sample.peer_dispersion, pkt_root_delay,
                    pkt_root_dispersion, pkt_refid, (int )message->lvm & 0x7, tmp___56,
                    (int const )tss_chars[local_transmit.source], (int const )tss_chars[local_receive.source]);
    }
  }
  return (good_packet);
}
}
int NCR_ProcessRxKnown(NCR_Instance inst , NTP_Local_Address *local_addr , NTP_Local_Timestamp *rx_ts ,
                       NTP_Packet *message , int length )
{
  int proc_packet ;
  int proc_as_unknown ;
  NTP_PacketInfo info ;
  int tmp ;
  int tmp___0 ;
  {
  (inst->report.total_rx_count) ++;
  tmp = parse_packet(message, length, & info);
  if (! tmp) {
    return (0);
  }
  proc_packet = 0;
  proc_as_unknown = 0;
  {
  if ((unsigned int )info.mode == 1U) {
    goto case_1;
  }
  if ((unsigned int )info.mode == 2U) {
    goto case_2___0;
  }
  if ((unsigned int )info.mode == 3U) {
    goto case_3___0;
  }
  if ((unsigned int )info.mode == 4U) {
    goto case_4;
  }
  if ((unsigned int )info.mode == 5U) {
    goto case_5;
  }
  goto switch_default___2;
  case_1:
  {
  if ((unsigned int )inst->mode == 1U) {
    goto case_1___0;
  }
  if ((unsigned int )inst->mode == 2U) {
    goto case_2;
  }
  if ((unsigned int )inst->mode == 3U) {
    goto case_3;
  }
  goto switch_default;
  case_1___0:
  proc_packet = 1;
  goto switch_break___0;
  case_2:
  goto switch_break___0;
  case_3:
  proc_as_unknown = 1;
  goto switch_break___0;
  switch_default:
  goto switch_break___0;
  switch_break___0: ;
  }
  goto switch_break;
  case_2___0:
  {
  if ((unsigned int )inst->mode == 1U) {
    goto case_1___1;
  }
  if ((unsigned int )inst->mode == 2U) {
    goto case_2___1;
  }
  goto switch_default___0;
  case_1___1:
  proc_packet = 1;
  goto switch_break___1;
  case_2___1:
  goto switch_break___1;
  switch_default___0:
  goto switch_break___1;
  switch_break___1: ;
  }
  goto switch_break;
  case_3___0:
  proc_as_unknown = 1;
  goto switch_break;
  case_4:
  {
  if ((unsigned int )inst->mode == 3U) {
    goto case_3___1;
  }
  goto switch_default___1;
  case_3___1:
  proc_packet = 1;
  goto switch_break___2;
  switch_default___1:
  goto switch_break___2;
  switch_break___2: ;
  }
  goto switch_break;
  case_5:
  goto switch_break;
  switch_default___2:
  goto switch_break;
  switch_break: ;
  }
  if (proc_packet) {
    if (local_addr->sock_fd != inst->local_addr.sock_fd) {
      {
      while (1) {
        while_continue: ;
        goto while_break;
      }
      while_break: ;
      }
      return (0);
    }
    if ((unsigned int )inst->opmode == 0U) {
      goto _L;
    } else
    if (inst->tx_suspended) {
      _L:
      {
      while (1) {
        while_continue___0: ;
        goto while_break___0;
      }
      while_break___0: ;
      }
      return (0);
    }
    tmp___0 = process_response(inst, local_addr, rx_ts, message, & info);
    return (tmp___0);
  } else
  if (proc_as_unknown) {
    NCR_ProcessRxUnknown(& inst->remote_addr, local_addr, rx_ts, message, length);
    return (0);
  } else {
    {
    while (1) {
      while_continue___1: ;
      goto while_break___1;
    }
    while_break___1: ;
    }
    return (0);
  }
}
}
void NCR_ProcessRxUnknown(NTP_Remote_Address *remote_addr , NTP_Local_Address *local_addr ,
                          NTP_Local_Timestamp *rx_ts , NTP_Packet *message , int length )
{
  NTP_PacketInfo info ;
  NTP_Mode my_mode ;
  NTP_Local_Timestamp local_tx ;
  NTP_Local_Timestamp *tx_ts ;
  NTP_int64 ntp_rx ;
  NTP_int64 *local_ntp_rx ;
  int log_index ;
  int interleaved ;
  int poll ;
  int version ;
  uint32_t kod ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  __uint32_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  struct timespec *tmp___8 ;
  {
  tmp = NIO_IsServerSocket(local_addr->sock_fd);
  if (! tmp) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return;
  }
  tmp___0 = parse_packet(message, length, & info);
  if (! tmp___0) {
    return;
  }
  tmp___2 = ADF_IsAllowed(access_auth_table___0, & remote_addr->ip_addr);
  if (! tmp___2) {
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
    return;
  }
  {
  if ((unsigned int )info.mode == 1U) {
    goto case_1;
  }
  if ((unsigned int )info.mode == 3U) {
    goto case_3;
  }
  if ((unsigned int )info.mode == 0U) {
    goto case_0;
  }
  goto switch_default;
  case_1:
  my_mode = (NTP_Mode )2;
  goto switch_break;
  case_3:
  my_mode = (NTP_Mode )4;
  goto switch_break;
  case_0:
  if (info.version == 1) {
    if ((int )remote_addr->port != 123) {
      my_mode = (NTP_Mode )4;
      goto switch_break;
    }
  }
  switch_default:
  {
  while (1) {
    while_continue___1: ;
    goto while_break___1;
  }
  while_break___1: ;
  }
  return;
  switch_break: ;
  }
  kod = (uint32_t )0;
  log_index = CLG_LogServiceAccess((CLG_Service )0, & remote_addr->ip_addr, & rx_ts->ts);
  if (log_index >= 0) {
    tmp___3 = CLG_LimitServiceRate((CLG_Service )0, log_index);
    if (tmp___3) {
      {
      while (1) {
        while_continue___2: ;
        goto while_break___2;
      }
      while_break___2: ;
      }
      return;
    }
  }
  tmp___4 = NAU_CheckRequestAuth(message, & info, & kod);
  if (tmp___4) {
    if ((unsigned int )info.auth.mode != 0U) {
      if ((unsigned int )info.auth.mode != 2U) {
        CLG_LogAuthNtpRequest();
      }
    }
  } else {
    {
    while (1) {
      while_continue___3: ;
      goto while_break___3;
    }
    while_break___3: ;
    }
    if (kod == 0U) {
      return;
    }
  }
  local_ntp_rx = (NTP_int64 *)((void *)0);
  tx_ts = (NTP_Local_Timestamp *)((void *)0);
  interleaved = 0;
  if (kod == 0U) {
    if (log_index >= 0) {
      if (info.version == 4) {
        tmp___5 = __bswap_32((__uint32_t )1);
        if (message->originate_ts.lo & tmp___5) {
          tmp___6 = UTI_CompareNtp64((NTP_int64 const *)(& message->receive_ts),
                                     (NTP_int64 const *)(& message->transmit_ts));
          if (tmp___6 != 0) {
            ntp_rx = message->originate_ts;
            local_ntp_rx = & ntp_rx;
            UTI_ZeroTimespec(& local_tx.ts);
            interleaved = CLG_GetNtpTxTimestamp(& ntp_rx, & local_tx.ts);
            tx_ts = & local_tx;
            if (interleaved) {
              CLG_DisableNtpTimestamps(& ntp_rx);
            }
          }
        }
      }
    }
  }
  poll = CLG_GetNtpMinPoll();
  if (poll > (int )message->poll) {
    poll = poll;
  } else {
    poll = (int )message->poll;
  }
  version = info.version;
  tmp___7 = transmit_packet(my_mode, interleaved, poll, version, kod, info.ext_field_flags,
                            (NAU_Instance )((void *)0), & message->receive_ts, & message->transmit_ts,
                            rx_ts, tx_ts, local_ntp_rx, (NTP_int64 *)((void *)0),
                            remote_addr, local_addr, message, & info);
  if (! tmp___7) {
    return;
  }
  if (local_ntp_rx) {
    if (tx_ts) {
      tmp___8 = & tx_ts->ts;
    } else {
      tmp___8 = (struct timespec *)((void *)0);
    }
    CLG_SaveNtpTimestamps(local_ntp_rx, tmp___8);
  }
  return;
}
}
static void update_tx_timestamp(NTP_Local_Timestamp *tx_ts , NTP_Local_Timestamp *new_tx_ts ,
                                NTP_int64 *local_ntp_rx , NTP_int64 *local_ntp_tx ,
                                NTP_Packet *message )
{
  double delay ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  tmp = UTI_IsZeroTimespec(& tx_ts->ts);
  if (tmp) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return;
  }
  if (local_ntp_rx) {
    tmp___0 = UTI_CompareNtp64((NTP_int64 const *)(& message->receive_ts), (NTP_int64 const *)local_ntp_rx);
    if (tmp___0) {
      goto _L;
    } else {
      goto _L___0;
    }
  } else
  _L___0:
  if (local_ntp_tx) {
    tmp___1 = UTI_CompareNtp64((NTP_int64 const *)(& message->transmit_ts), (NTP_int64 const *)local_ntp_tx);
    if (tmp___1) {
      _L:
      {
      while (1) {
        while_continue___0: ;
        goto while_break___0;
      }
      while_break___0: ;
      }
      return;
    }
  }
  delay = UTI_DiffTimespecsToDouble((struct timespec const *)(& new_tx_ts->ts),
                                    (struct timespec const *)(& tx_ts->ts));
  if (delay < 0.0) {
    goto _L___1;
  } else
  if (delay > 1.0) {
    _L___1:
    {
    while (1) {
      while_continue___1: ;
      goto while_break___1;
    }
    while_break___1: ;
    }
    return;
  }
  *tx_ts = *new_tx_ts;
  {
  while (1) {
    while_continue___2: ;
    goto while_break___2;
  }
  while_break___2: ;
  }
  return;
}
}
void NCR_ProcessTxKnown(NCR_Instance inst , NTP_Local_Address *local_addr , NTP_Local_Timestamp *tx_ts ,
                        NTP_Packet *message , int length )
{
  NTP_PacketInfo info ;
  int tmp ;
  {
  tmp = parse_packet(message, length, & info);
  if (! tmp) {
    return;
  }
  if ((unsigned int )info.mode != 3U) {
    if ((unsigned int )info.mode != 1U) {
      NCR_ProcessTxUnknown(& inst->remote_addr, local_addr, tx_ts, message, length);
      return;
    }
  }
  update_tx_timestamp(& inst->local_tx, tx_ts, & inst->local_ntp_rx, & inst->local_ntp_tx,
                      message);
  return;
}
}
void NCR_ProcessTxUnknown(NTP_Remote_Address *remote_addr , NTP_Local_Address *local_addr ,
                          NTP_Local_Timestamp *tx_ts , NTP_Packet *message , int length )
{
  NTP_Local_Timestamp old_tx ;
  NTP_Local_Timestamp new_tx ;
  NTP_int64 *local_ntp_rx ;
  NTP_PacketInfo info ;
  int tmp ;
  double tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  tmp = parse_packet(message, length, & info);
  if (! tmp) {
    return;
  }
  if ((unsigned int )info.mode == 5U) {
    return;
  }
  tmp___1 = SMT_IsEnabled();
  if (tmp___1) {
    if ((unsigned int )info.mode == 4U) {
      tmp___0 = SMT_GetOffset(& tx_ts->ts);
      UTI_AddDoubleToTimespec((struct timespec const *)(& tx_ts->ts), tmp___0, & tx_ts->ts);
    }
  }
  local_ntp_rx = & message->receive_ts;
  new_tx = *tx_ts;
  tmp___2 = CLG_GetNtpTxTimestamp(local_ntp_rx, & old_tx.ts);
  if (! tmp___2) {
    return;
  }
  CLG_UndoNtpTxTimestampSlew(local_ntp_rx, & new_tx.ts);
  update_tx_timestamp(& old_tx, & new_tx, local_ntp_rx, (NTP_int64 *)((void *)0),
                      message);
  CLG_UpdateNtpTxTimestamp(local_ntp_rx, & new_tx.ts);
  return;
}
}
void NCR_SlewTimes(NCR_Instance inst , struct timespec *when , double dfreq , double doffset )
{
  double delta ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  tmp = UTI_IsZeroTimespec(& inst->local_rx.ts);
  if (! tmp) {
    UTI_AdjustTimespec((struct timespec const *)(& inst->local_rx.ts), (struct timespec const *)when,
                       & inst->local_rx.ts, & delta, dfreq, doffset);
  }
  tmp___0 = UTI_IsZeroTimespec(& inst->local_tx.ts);
  if (! tmp___0) {
    UTI_AdjustTimespec((struct timespec const *)(& inst->local_tx.ts), (struct timespec const *)when,
                       & inst->local_tx.ts, & delta, dfreq, doffset);
  }
  tmp___1 = UTI_IsZeroTimespec(& inst->prev_local_tx.ts);
  if (! tmp___1) {
    UTI_AdjustTimespec((struct timespec const *)(& inst->prev_local_tx.ts), (struct timespec const *)when,
                       & inst->prev_local_tx.ts, & delta, dfreq, doffset);
  }
  tmp___2 = UTI_IsZeroTimespec(& inst->init_local_rx.ts);
  if (! tmp___2) {
    UTI_AdjustTimespec((struct timespec const *)(& inst->init_local_rx.ts), (struct timespec const *)when,
                       & inst->init_local_rx.ts, & delta, dfreq, doffset);
  }
  if (inst->filter) {
    SPF_SlewSamples(inst->filter, when, dfreq, doffset);
  }
  return;
}
}
static void set_connectivity(NCR_Instance inst , SRC_Connectivity connectivity )
{
  int tmp ;
  int tmp___0 ;
  {
  if ((unsigned int )connectivity == 2U) {
    tmp___0 = NIO_IsServerConnectable(& inst->remote_addr);
    if (tmp___0) {
      connectivity = (SRC_Connectivity )1;
    } else {
      connectivity = (SRC_Connectivity )0;
    }
  }
  {
  if ((unsigned int )connectivity == 1U) {
    goto case_1;
  }
  if ((unsigned int )connectivity == 0U) {
    goto case_0___0;
  }
  goto switch_default___1;
  case_1:
  {
  if ((unsigned int )inst->opmode == 1U) {
    goto case_1___0;
  }
  if ((unsigned int )inst->opmode == 0U) {
    goto case_0;
  }
  if ((unsigned int )inst->opmode == 3U) {
    goto case_3;
  }
  if ((unsigned int )inst->opmode == 2U) {
    goto case_2;
  }
  goto switch_default;
  case_1___0:
  goto switch_break___0;
  case_0:
  inst->opmode = (OperatingMode )1;
  NCR_ResetInstance(inst);
  start_initial_timeout(inst);
  if (inst->auto_iburst) {
    NCR_InitiateSampleBurst(inst, 4, 8);
  }
  goto switch_break___0;
  case_3:
  goto switch_break___0;
  case_2:
  inst->opmode = (OperatingMode )3;
  goto switch_break___0;
  switch_default:
  assert(0);
  switch_break___0: ;
  }
  goto switch_break;
  case_0___0:
  {
  if ((unsigned int )inst->opmode == 1U) {
    goto case_1___1;
  }
  if ((unsigned int )inst->opmode == 0U) {
    goto case_0___1;
  }
  if ((unsigned int )inst->opmode == 3U) {
    goto case_3___0;
  }
  if ((unsigned int )inst->opmode == 2U) {
    goto case_2___0;
  }
  goto switch_default___0;
  case_1___1:
  take_offline(inst);
  goto switch_break___1;
  case_0___1:
  goto switch_break___1;
  case_3___0:
  inst->opmode = (OperatingMode )2;
  goto switch_break___1;
  case_2___0:
  goto switch_break___1;
  switch_default___0:
  assert(0);
  switch_break___1: ;
  }
  goto switch_break;
  switch_default___1:
  assert(0);
  switch_break: ;
  }
  return;
}
}
void NCR_SetConnectivity(NCR_Instance inst , SRC_Connectivity connectivity )
{
  OperatingMode prev_opmode ;
  int was_online ;
  int is_online ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  {
  prev_opmode = inst->opmode;
  set_connectivity(inst, connectivity);
  if ((unsigned int )prev_opmode == 1U) {
    tmp = 1;
  } else
  if ((unsigned int )prev_opmode == 3U) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  was_online = tmp;
  if ((unsigned int )inst->opmode == 1U) {
    tmp___0 = 1;
  } else
  if ((unsigned int )inst->opmode == 3U) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  is_online = tmp___0;
  if (was_online != is_online) {
    if (is_online) {
      tmp___1 = "online";
    } else {
      tmp___1 = "offline";
    }
    tmp___2 = UTI_IPToString((IPAddr const *)(& inst->remote_addr.ip_addr));
    LOG_Message((LOG_Severity )0, (char const *)"Source %s %s", tmp___2, tmp___1);
  }
  return;
}
}
void NCR_ModifyMinpoll(NCR_Instance inst , int new_minpoll )
{
  char *tmp ;
  {
  if (new_minpoll < -6) {
    return;
  } else
  if (new_minpoll > 24) {
    return;
  }
  inst->minpoll = new_minpoll;
  tmp = UTI_IPToString((IPAddr const *)(& inst->remote_addr.ip_addr));
  LOG_Message((LOG_Severity )0, (char const *)"Source %s new minpoll %d", tmp, new_minpoll);
  if (inst->maxpoll < inst->minpoll) {
    NCR_ModifyMaxpoll(inst, inst->minpoll);
  }
  return;
}
}
void NCR_ModifyMaxpoll(NCR_Instance inst , int new_maxpoll )
{
  char *tmp ;
  {
  if (new_maxpoll < -6) {
    return;
  } else
  if (new_maxpoll > 24) {
    return;
  }
  inst->maxpoll = new_maxpoll;
  tmp = UTI_IPToString((IPAddr const *)(& inst->remote_addr.ip_addr));
  LOG_Message((LOG_Severity )0, (char const *)"Source %s new maxpoll %d", tmp, new_maxpoll);
  if (inst->minpoll > inst->maxpoll) {
    NCR_ModifyMinpoll(inst, inst->maxpoll);
  }
  return;
}
}
void NCR_ModifyMaxdelay(NCR_Instance inst , double new_max_delay )
{
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  char *tmp___2 ;
  {
  if (new_max_delay < 1.0e3) {
    tmp___1 = new_max_delay;
  } else {
    tmp___1 = 1.0e3;
  }
  if (0.0 > tmp___1) {
    inst->max_delay = 0.0;
  } else {
    if (new_max_delay < 1.0e3) {
      tmp___0 = new_max_delay;
    } else {
      tmp___0 = 1.0e3;
    }
    inst->max_delay = tmp___0;
  }
  tmp___2 = UTI_IPToString((IPAddr const *)(& inst->remote_addr.ip_addr));
  LOG_Message((LOG_Severity )0, (char const *)"Source %s new maxdelay %f", tmp___2,
              inst->max_delay);
  return;
}
}
void NCR_ModifyMaxdelayratio(NCR_Instance inst , double new_max_delay_ratio )
{
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  char *tmp___2 ;
  {
  if (new_max_delay_ratio < 1.0e6) {
    tmp___1 = new_max_delay_ratio;
  } else {
    tmp___1 = 1.0e6;
  }
  if (0.0 > tmp___1) {
    inst->max_delay_ratio = 0.0;
  } else {
    if (new_max_delay_ratio < 1.0e6) {
      tmp___0 = new_max_delay_ratio;
    } else {
      tmp___0 = 1.0e6;
    }
    inst->max_delay_ratio = tmp___0;
  }
  tmp___2 = UTI_IPToString((IPAddr const *)(& inst->remote_addr.ip_addr));
  LOG_Message((LOG_Severity )0, (char const *)"Source %s new maxdelayratio %f",
              tmp___2, inst->max_delay_ratio);
  return;
}
}
void NCR_ModifyMaxdelaydevratio(NCR_Instance inst , double new_max_delay_dev_ratio )
{
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  char *tmp___2 ;
  {
  if (new_max_delay_dev_ratio < 1.0e6) {
    tmp___1 = new_max_delay_dev_ratio;
  } else {
    tmp___1 = 1.0e6;
  }
  if (0.0 > tmp___1) {
    inst->max_delay_dev_ratio = 0.0;
  } else {
    if (new_max_delay_dev_ratio < 1.0e6) {
      tmp___0 = new_max_delay_dev_ratio;
    } else {
      tmp___0 = 1.0e6;
    }
    inst->max_delay_dev_ratio = tmp___0;
  }
  tmp___2 = UTI_IPToString((IPAddr const *)(& inst->remote_addr.ip_addr));
  LOG_Message((LOG_Severity )0, (char const *)"Source %s new maxdelaydevratio %f",
              tmp___2, inst->max_delay_dev_ratio);
  return;
}
}
void NCR_ModifyMinstratum(NCR_Instance inst , int new_min_stratum )
{
  char *tmp ;
  {
  inst->min_stratum = new_min_stratum;
  tmp = UTI_IPToString((IPAddr const *)(& inst->remote_addr.ip_addr));
  LOG_Message((LOG_Severity )0, (char const *)"Source %s new minstratum %d", tmp,
              new_min_stratum);
  return;
}
}
void NCR_ModifyPolltarget(NCR_Instance inst , int new_poll_target )
{
  char *tmp ;
  {
  inst->poll_target = new_poll_target;
  tmp = UTI_IPToString((IPAddr const *)(& inst->remote_addr.ip_addr));
  LOG_Message((LOG_Severity )0, (char const *)"Source %s new polltarget %d", tmp,
              new_poll_target);
  return;
}
}
void NCR_InitiateSampleBurst(NCR_Instance inst , int n_good_samples , int n_total_samples )
{
  {
  if ((unsigned int )inst->mode == 3U) {
    {
    if ((unsigned int )inst->opmode == 3U) {
      goto case_3;
    }
    if ((unsigned int )inst->opmode == 2U) {
      goto case_3;
    }
    if ((unsigned int )inst->opmode == 0U) {
      goto case_0;
    }
    if ((unsigned int )inst->opmode == 1U) {
      goto case_0;
    }
    goto switch_default;
    case_3:
    case_2:
    goto switch_break;
    case_0:
    case_1:
    if ((unsigned int )inst->opmode == 1U) {
      inst->opmode = (OperatingMode )3;
    } else {
      inst->opmode = (OperatingMode )2;
    }
    inst->burst_good_samples_to_go = n_good_samples;
    inst->burst_total_samples_to_go = n_total_samples;
    start_initial_timeout(inst);
    goto switch_break;
    switch_default:
    assert(0);
    goto switch_break;
    switch_break: ;
    }
  }
  return;
}
}
void NCR_ReportSource(NCR_Instance inst , RPT_SourceReport *report , struct timespec *now )
{
  {
  report->poll = get_transmit_poll(inst);
  {
  if ((unsigned int )inst->mode == 3U) {
    goto case_3;
  }
  if ((unsigned int )inst->mode == 1U) {
    goto case_1;
  }
  goto switch_default;
  case_3:
  report->mode = (enum __anonenum_mode_14858290 )0;
  goto switch_break;
  case_1:
  report->mode = (enum __anonenum_mode_14858290 )1;
  goto switch_break;
  switch_default:
  assert(0);
  switch_break: ;
  }
  return;
}
}
void NCR_GetAuthReport(NCR_Instance inst , RPT_AuthReport *report )
{
  {
  NAU_GetReport(inst->auth, report);
  return;
}
}
void NCR_GetNTPReport(NCR_Instance inst , RPT_NTPReport *report )
{
  {
  *report = inst->report;
  return;
}
}
int NCR_AddAccessRestriction(IPAddr *ip_addr , int subnet_bits , int allow , int all )
{
  ADF_Status status ;
  NTP_Remote_Address remote_addr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  if (allow) {
    if (all) {
      status = ADF_AllowAll(access_auth_table___0, ip_addr, subnet_bits);
    } else {
      status = ADF_Allow(access_auth_table___0, ip_addr, subnet_bits);
    }
  } else
  if (all) {
    status = ADF_DenyAll(access_auth_table___0, ip_addr, subnet_bits);
  } else {
    status = ADF_Deny(access_auth_table___0, ip_addr, subnet_bits);
  }
  if ((unsigned int )status != 0U) {
    return (0);
  }
  if (allow) {
    if (server_sock_fd4 == -2) {
      tmp = ADF_IsAnyAllowed(access_auth_table___0, 1);
      if (tmp) {
        remote_addr.ip_addr.family = (uint16_t )1;
        remote_addr.port = (uint16_t )0;
        server_sock_fd4 = NIO_OpenServerSocket(& remote_addr);
      }
    }
    if (server_sock_fd6 == -2) {
      tmp___0 = ADF_IsAnyAllowed(access_auth_table___0, 2);
      if (tmp___0) {
        remote_addr.ip_addr.family = (uint16_t )2;
        remote_addr.port = (uint16_t )0;
        server_sock_fd6 = NIO_OpenServerSocket(& remote_addr);
      }
    }
  } else {
    if (server_sock_fd4 != -2) {
      tmp___1 = ADF_IsAnyAllowed(access_auth_table___0, 1);
      if (! tmp___1) {
        NIO_CloseServerSocket(server_sock_fd4);
        server_sock_fd4 = -2;
      }
    }
    if (server_sock_fd6 != -2) {
      tmp___2 = ADF_IsAnyAllowed(access_auth_table___0, 2);
      if (! tmp___2) {
        NIO_CloseServerSocket(server_sock_fd6);
        server_sock_fd6 = -2;
      }
    }
  }
  return (1);
}
}
int NCR_CheckAccessRestriction(IPAddr *ip_addr )
{
  int tmp ;
  {
  tmp = ADF_IsAllowed(access_auth_table___0, ip_addr);
  return (tmp);
}
}
void NCR_IncrementActivityCounters(NCR_Instance inst , int *online , int *offline ,
                                   int *burst_online , int *burst_offline )
{
  {
  {
  if ((unsigned int )inst->opmode == 2U) {
    goto case_2;
  }
  if ((unsigned int )inst->opmode == 3U) {
    goto case_3;
  }
  if ((unsigned int )inst->opmode == 1U) {
    goto case_1;
  }
  if ((unsigned int )inst->opmode == 0U) {
    goto case_0;
  }
  goto switch_default;
  case_2:
  (*burst_offline) ++;
  goto switch_break;
  case_3:
  (*burst_online) ++;
  goto switch_break;
  case_1:
  (*online) ++;
  goto switch_break;
  case_0:
  (*offline) ++;
  goto switch_break;
  switch_default:
  assert(0);
  goto switch_break;
  switch_break: ;
  }
  return;
}
}
NTP_Remote_Address *NCR_GetRemoteAddress(NCR_Instance inst )
{
  {
  return (& inst->remote_addr);
}
}
uint32_t NCR_GetLocalRefid(NCR_Instance inst )
{
  uint32_t tmp ;
  {
  tmp = UTI_IPToRefid((IPAddr const *)(& inst->local_addr.ip_addr));
  return (tmp);
}
}
int NCR_IsSyncPeer(NCR_Instance inst )
{
  int tmp ;
  {
  tmp = SRC_IsSyncPeer(inst->source);
  return (tmp);
}
}
void NCR_DumpAuthData(NCR_Instance inst )
{
  {
  NAU_DumpData(inst->auth);
  return;
}
}
static void broadcast_timeout(void *arg )
{
  BroadcastDestination *destination ;
  NTP_int64 orig_ts ;
  NTP_Local_Timestamp recv_ts ;
  int poll ;
  void *tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  {
  tmp = ARR_GetElement(broadcasts___0, (unsigned int )((long )arg));
  destination = (BroadcastDestination *)tmp;
  tmp___0 = log((double )destination->interval);
  tmp___1 = log(2.0);
  tmp___2 = round(tmp___0 / tmp___1);
  poll = (int )tmp___2;
  UTI_ZeroNtp64(& orig_ts);
  zero_local_timestamp(& recv_ts);
  transmit_packet((NTP_Mode )5, 0, poll, 4, (uint32_t )0, 0, destination->auth, & orig_ts,
                  & orig_ts, & recv_ts, (NTP_Local_Timestamp *)((void *)0), (NTP_int64 *)((void *)0),
                  (NTP_int64 *)((void *)0), & destination->addr, & destination->local_addr,
                  (NTP_Packet *)((void *)0), (NTP_PacketInfo *)((void *)0));
  tmp___3 = get_separation(poll);
  SCH_AddTimeoutInClass((double )destination->interval, tmp___3, 0.02, (SCH_TimeoutClass )3,
                        & broadcast_timeout, arg);
  return;
}
}
void NCR_AddBroadcastDestination(NTP_Remote_Address *addr , int interval )
{
  BroadcastDestination *destination ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  {
  tmp = ARR_GetNewElement(broadcasts___0);
  destination = (BroadcastDestination *)tmp;
  destination->addr = *addr;
  destination->local_addr.ip_addr.family = (uint16_t )0;
  destination->local_addr.if_index = -1;
  destination->local_addr.sock_fd = NIO_OpenServerSocket(& destination->addr);
  destination->auth = NAU_CreateNoneInstance();
  if (interval < 1 << 24) {
    tmp___2 = interval;
  } else {
    tmp___2 = 1 << 24;
  }
  if (1 > tmp___2) {
    destination->interval = 1;
  } else {
    if (interval < 1 << 24) {
      tmp___1 = interval;
    } else {
      tmp___1 = 1 << 24;
    }
    destination->interval = tmp___1;
  }
  tmp___3 = ARR_GetSize(broadcasts___0);
  SCH_AddTimeoutInClass((double )destination->interval, 0.2, 0.02, (SCH_TimeoutClass )3,
                        & broadcast_timeout, (void *)((long )(tmp___3 - 1U)));
  return;
}
}
static int format_field(unsigned char *buffer , int buffer_length , int start , int type ,
                        int body_length , int *length , void **body )
{
  struct ExtFieldHeader *header ;
  {
  if (buffer_length < 0) {
    return (0);
  } else
  if (start < 0) {
    return (0);
  } else
  if (buffer_length <= start) {
    return (0);
  } else
  if ((unsigned long )(buffer_length - start) < sizeof(*header)) {
    return (0);
  } else
  if (start % 4 != 0) {
    return (0);
  }
  header = (struct ExtFieldHeader *)(buffer + start);
  if (body_length < 0) {
    return (0);
  } else
  if (sizeof(*header) + (unsigned long )body_length > 65535UL) {
    return (0);
  } else
  if (((unsigned long )start + sizeof(*header)) + (unsigned long )body_length > (unsigned long )buffer_length) {
    return (0);
  } else
  if (body_length % 4 != 0) {
    return (0);
  }
  header->type = __bswap_16((__uint16_t )type);
  header->length = __bswap_16((__uint16_t )(sizeof(*header) + (unsigned long )body_length));
  *length = (int )(sizeof(*header) + (unsigned long )body_length);
  *body = (void *)(header + 1);
  return (1);
}
}
int NEF_SetField(unsigned char *buffer , int buffer_length , int start , int type ,
                 void *body , int body_length , int *length )
{
  void *ef_body ;
  int tmp ;
  {
  tmp = format_field(buffer, buffer_length, start, type, body_length, length, & ef_body);
  if (! tmp) {
    return (0);
  }
  memcpy(ef_body, (void const *)body, (size_t )body_length);
  return (1);
}
}
int NEF_AddBlankField(NTP_Packet *packet , NTP_PacketInfo *info , int type , int body_length ,
                      void **body )
{
  int ef_length ;
  int length ;
  int tmp ;
  {
  length = info->length;
  if (length < (int )((unsigned long )(& ((NTP_Packet *)0)->extensions))) {
    return (0);
  } else
  if ((unsigned long )length >= sizeof(*packet)) {
    return (0);
  } else
  if (length % 4 != 0) {
    return (0);
  }
  if (info->version != 4) {
    return (0);
  }
  tmp = format_field((unsigned char *)packet, (int )sizeof(*packet), length, type,
                     body_length, & ef_length, body);
  if (! tmp) {
    return (0);
  }
  if (ef_length < 16) {
    return (0);
  }
  info->length += ef_length;
  (info->ext_fields) ++;
  return (1);
}
}
int NEF_AddField(NTP_Packet *packet , NTP_PacketInfo *info , int type , void *body ,
                 int body_length )
{
  void *ef_body ;
  int tmp ;
  {
  tmp = NEF_AddBlankField(packet, info, type, body_length, & ef_body);
  if (! tmp) {
    return (0);
  }
  memcpy(ef_body, (void const *)body, (size_t )body_length);
  return (1);
}
}
int NEF_ParseSingleField(unsigned char *buffer , int buffer_length , int start , int *length ,
                         int *type , void **body , int *body_length )
{
  struct ExtFieldHeader *header ;
  int ef_length ;
  __uint16_t tmp ;
  __uint16_t tmp___0 ;
  {
  if (buffer_length < 0) {
    return (0);
  } else
  if (start < 0) {
    return (0);
  } else
  if (buffer_length <= start) {
    return (0);
  } else
  if ((unsigned long )(buffer_length - start) < sizeof(*header)) {
    return (0);
  }
  header = (struct ExtFieldHeader *)(buffer + start);
  assert(sizeof(*header) == 4UL);
  tmp = __bswap_16(header->length);
  ef_length = (int )tmp;
  if (ef_length < (int )sizeof(*header)) {
    return (0);
  } else
  if (start + ef_length > buffer_length) {
    return (0);
  } else
  if (ef_length % 4 != 0) {
    return (0);
  }
  if (length) {
    *length = ef_length;
  }
  if (type) {
    tmp___0 = __bswap_16(header->type);
    *type = (int )tmp___0;
  }
  if (body) {
    *body = (void *)(header + 1);
  }
  if (body_length) {
    *body_length = (int )((unsigned long )ef_length - sizeof(*header));
  }
  return (1);
}
}
int NEF_ParseField(NTP_Packet *packet , int packet_length , int start , int *length ,
                   int *type , void **body , int *body_length )
{
  int ef_length ;
  int tmp ;
  {
  if (packet_length <= (int )((unsigned long )(& ((NTP_Packet *)0)->extensions))) {
    return (0);
  } else
  if ((unsigned long )packet_length > sizeof(*packet)) {
    return (0);
  } else
  if (packet_length <= start) {
    return (0);
  } else
  if (packet_length % 4 != 0) {
    return (0);
  } else
  if (start < (int )((unsigned long )(& ((NTP_Packet *)0)->extensions))) {
    return (0);
  } else
  if (start % 4 != 0) {
    return (0);
  }
  if ((((int )packet->lvm >> 3) & 0x7) != 4) {
    return (0);
  }
  if (packet_length - start <= 24) {
    return (0);
  }
  tmp = NEF_ParseSingleField((unsigned char *)packet, packet_length, start, & ef_length,
                             type, body, body_length);
  if (! tmp) {
    return (0);
  }
  if (ef_length < 16) {
    return (0);
  }
  if (length) {
    *length = ef_length;
  }
  return (1);
}
}
void NIO_Linux_Initialise(void) ;
void NIO_Linux_Finalise(void) ;
int NIO_Linux_SetTimestampSocketOptions(int sock_fd , int client_only , int *events ) ;
int NIO_Linux_ProcessEvent(int sock_fd , int event ) ;
int NIO_Linux_ProcessMessage(SCK_Message *message , NTP_Local_Address *local_addr ,
                             NTP_Local_Timestamp *local_ts , int event ) ;
void NIO_Linux_RequestTxTimestamp(SCK_Message *message , int sock_fd ) ;
void NIO_Linux_NotifySocketClosing(int sock_fd ) ;
static int server_sock_fd4___0 ;
static int server_sock_fd6___0 ;
static int client_sock_fd4 ;
static int client_sock_fd6 ;
static int server_sock_ref4 ;
static int server_sock_ref6 ;
static int separate_client_sockets ;
static int permanent_server_sockets ;
static int bound_server_sock_fd4 ;
static int ptp_port___0 ;
static int ptp_sock_fd4 ;
static int ptp_sock_fd6 ;
static PTP_NtpMessage *ptp_message ;
static int initialised___6 = 0;
static void read_from_socket(int sock_fd , int event , void *anything ) ;
static int open_socket___1(int family , int local_port , int client_only , IPSockAddr *remote_addr )
{
  int sock_fd ;
  int sock_flags ;
  int dscp ;
  int events ;
  IPSockAddr local_addr ;
  char *iface ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  {
  events = 1;
  tmp = SCK_IsIpFamilyEnabled(family);
  if (! tmp) {
    return (-1);
  }
  if (! client_only) {
    CNF_GetBindAddress(family, & local_addr.ip_addr);
    iface = CNF_GetBindNtpInterface();
  } else {
    CNF_GetBindAcquisitionAddress(family, & local_addr.ip_addr);
    iface = CNF_GetBindAcquisitionInterface();
  }
  local_addr.port = (uint16_t )local_port;
  sock_flags = 20;
  if (! client_only) {
    sock_flags |= 2;
  }
  sock_fd = SCK_OpenUdpSocket(remote_addr, & local_addr, (char const *)iface, sock_flags);
  if (sock_fd < 0) {
    if (! client_only) {
      tmp___0 = UTI_IPSockAddrToString((IPSockAddr const *)(& local_addr));
      LOG_Message((LOG_Severity )2, (char const *)"Could not open NTP socket on %s",
                  tmp___0);
    }
    return (-1);
  }
  dscp = CNF_GetNtpDscp();
  if (dscp > 0) {
    if (dscp < 64) {
      tmp___1 = SCK_SetIntOption(sock_fd, 0, 1, dscp << 2);
      if (tmp___1) {
        tmp___2 = 0;
      } else {
        tmp___2 = 1;
      }
    }
  }
  if (! client_only) {
    if (family == 1) {
      if ((int )local_addr.port > 0) {
        bound_server_sock_fd4 = local_addr.ip_addr.addr.in4 != 0U;
      }
    }
  }
  tmp___5 = NIO_Linux_SetTimestampSocketOptions(sock_fd, client_only, & events);
  if (! tmp___5) {
    tmp___3 = SCK_EnableKernelRxTimestamping(sock_fd);
    if (tmp___3) {
      tmp___4 = 0;
    } else {
      tmp___4 = 1;
    }
  }
  SCH_AddFileHandler(sock_fd, events, & read_from_socket, (void *)0);
  return (sock_fd);
}
}
static int open_separate_client_socket(IPSockAddr *remote_addr )
{
  int tmp ;
  {
  tmp = open_socket___1((int )remote_addr->ip_addr.family, 0, 1, remote_addr);
  return (tmp);
}
}
static void close_socket(int sock_fd )
{
  {
  if (sock_fd == -1) {
    return;
  }
  NIO_Linux_NotifySocketClosing(sock_fd);
  SCH_RemoveFileHandler(sock_fd);
  SCK_CloseSocket(sock_fd);
  return;
}
}
void NIO_Initialise(void)
{
  int server_port ;
  int client_port ;
  int tmp ;
  void *tmp___0 ;
  {
  assert(! initialised___6);
  initialised___6 = 1;
  NIO_Linux_Initialise();
  server_port = CNF_GetNTPPort();
  client_port = CNF_GetAcquisitionPort();
  separate_client_sockets = client_port < 0;
  if (client_port < 0) {
    client_port = 0;
  }
  if (! server_port) {
    tmp = 1;
  } else
  if (! separate_client_sockets) {
    if (client_port == server_port) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  permanent_server_sockets = tmp;
  server_sock_fd4___0 = -1;
  server_sock_fd6___0 = -1;
  client_sock_fd4 = -1;
  client_sock_fd6 = -1;
  server_sock_ref4 = 0;
  server_sock_ref6 = 0;
  if (permanent_server_sockets) {
    if (server_port) {
      server_sock_fd4___0 = open_socket___1(1, server_port, 0, (IPSockAddr *)((void *)0));
      server_sock_fd6___0 = open_socket___1(2, server_port, 0, (IPSockAddr *)((void *)0));
    }
  }
  if (! separate_client_sockets) {
    if (client_port != server_port) {
      client_sock_fd4 = open_socket___1(1, client_port, 1, (IPSockAddr *)((void *)0));
      client_sock_fd6 = open_socket___1(2, client_port, 1, (IPSockAddr *)((void *)0));
    } else
    if (! server_port) {
      client_sock_fd4 = open_socket___1(1, client_port, 1, (IPSockAddr *)((void *)0));
      client_sock_fd6 = open_socket___1(2, client_port, 1, (IPSockAddr *)((void *)0));
    } else {
      client_sock_fd4 = server_sock_fd4___0;
      client_sock_fd6 = server_sock_fd6___0;
    }
  }
  if (server_port) {
    if (permanent_server_sockets) {
      if (server_sock_fd4___0 == -1) {
        if (server_sock_fd6___0 == -1) {
          goto _L;
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    } else {
      goto _L___2;
    }
  } else
  _L___2:
  _L___1:
  _L___0:
  if (! separate_client_sockets) {
    if (client_sock_fd4 == -1) {
      if (client_sock_fd6 == -1) {
        _L:
        {
        while (1) {
          while_continue: ;
          LOG_Message((LOG_Severity )3, (char const *)"Could not open NTP sockets");
          exit(1);
          goto while_break;
        }
        while_break: ;
        }
      }
    }
  }
  ptp_port___0 = CNF_GetPtpPort();
  ptp_sock_fd4 = -1;
  ptp_sock_fd6 = -1;
  ptp_message = (PTP_NtpMessage *)((void *)0);
  if (ptp_port___0 > 0) {
    ptp_sock_fd4 = open_socket___1(1, ptp_port___0, 0, (IPSockAddr *)((void *)0));
    ptp_sock_fd6 = open_socket___1(2, ptp_port___0, 0, (IPSockAddr *)((void *)0));
    tmp___0 = Malloc(sizeof(PTP_NtpMessage ));
    ptp_message = (PTP_NtpMessage *)tmp___0;
  }
  return;
}
}
void NIO_Finalise(void)
{
  {
  if (server_sock_fd4___0 != client_sock_fd4) {
    close_socket(client_sock_fd4);
  }
  close_socket(server_sock_fd4___0);
  client_sock_fd4 = -1;
  server_sock_fd4___0 = client_sock_fd4;
  if (server_sock_fd6___0 != client_sock_fd6) {
    close_socket(client_sock_fd6);
  }
  close_socket(server_sock_fd6___0);
  client_sock_fd6 = -1;
  server_sock_fd6___0 = client_sock_fd6;
  close_socket(ptp_sock_fd4);
  close_socket(ptp_sock_fd6);
  ptp_sock_fd6 = -1;
  ptp_sock_fd4 = ptp_sock_fd6;
  free((void *)ptp_message);
  NIO_Linux_Finalise();
  initialised___6 = 0;
  return;
}
}
int NIO_OpenClientSocket(NTP_Remote_Address *remote_addr )
{
  int tmp ;
  int tmp___0 ;
  {
  {
  if ((int )remote_addr->ip_addr.family == 1) {
    goto case_1;
  }
  if ((int )remote_addr->ip_addr.family == 2) {
    goto case_2;
  }
  goto switch_default;
  case_1:
  if (ptp_port___0 > 0) {
    if ((int )remote_addr->port == ptp_port___0) {
      return (ptp_sock_fd4);
    }
  }
  if (separate_client_sockets) {
    tmp = open_separate_client_socket(remote_addr);
    return (tmp);
  }
  return (client_sock_fd4);
  case_2:
  if (ptp_port___0 > 0) {
    if ((int )remote_addr->port == ptp_port___0) {
      return (ptp_sock_fd6);
    }
  }
  if (separate_client_sockets) {
    tmp___0 = open_separate_client_socket(remote_addr);
    return (tmp___0);
  }
  return (client_sock_fd6);
  switch_default:
  return (-1);
  switch_break: ;
  }
}
}
int NIO_OpenServerSocket(NTP_Remote_Address *remote_addr )
{
  int tmp ;
  int tmp___0 ;
  {
  {
  if ((int )remote_addr->ip_addr.family == 1) {
    goto case_1;
  }
  if ((int )remote_addr->ip_addr.family == 2) {
    goto case_2;
  }
  goto switch_default;
  case_1:
  if (ptp_port___0 > 0) {
    if ((int )remote_addr->port == ptp_port___0) {
      return (ptp_sock_fd4);
    }
  }
  if (permanent_server_sockets) {
    return (server_sock_fd4___0);
  }
  if (server_sock_fd4___0 == -1) {
    tmp = CNF_GetNTPPort();
    server_sock_fd4___0 = open_socket___1(1, tmp, 0, (IPSockAddr *)((void *)0));
  }
  if (server_sock_fd4___0 != -1) {
    server_sock_ref4 ++;
  }
  return (server_sock_fd4___0);
  case_2:
  if (ptp_port___0 > 0) {
    if ((int )remote_addr->port == ptp_port___0) {
      return (ptp_sock_fd6);
    }
  }
  if (permanent_server_sockets) {
    return (server_sock_fd6___0);
  }
  if (server_sock_fd6___0 == -1) {
    tmp___0 = CNF_GetNTPPort();
    server_sock_fd6___0 = open_socket___1(2, tmp___0, 0, (IPSockAddr *)((void *)0));
  }
  if (server_sock_fd6___0 != -1) {
    server_sock_ref6 ++;
  }
  return (server_sock_fd6___0);
  switch_default:
  return (-1);
  switch_break: ;
  }
}
}
static int is_ptp_socket(int sock_fd )
{
  int tmp ;
  {
  if (ptp_port___0 > 0) {
    if (sock_fd != -1) {
      if (sock_fd == ptp_sock_fd4) {
        tmp = 1;
      } else
      if (sock_fd == ptp_sock_fd6) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
void NIO_CloseClientSocket(int sock_fd )
{
  int tmp ;
  {
  tmp = is_ptp_socket(sock_fd);
  if (tmp) {
    return;
  }
  if (separate_client_sockets) {
    close_socket(sock_fd);
  }
  return;
}
}
void NIO_CloseServerSocket(int sock_fd )
{
  int tmp ;
  {
  if (permanent_server_sockets) {
    return;
  } else
  if (sock_fd == -1) {
    return;
  } else {
    tmp = is_ptp_socket(sock_fd);
    if (tmp) {
      return;
    }
  }
  if (sock_fd == server_sock_fd4___0) {
    server_sock_ref4 --;
    if (server_sock_ref4 <= 0) {
      close_socket(server_sock_fd4___0);
      server_sock_fd4___0 = -1;
    }
  } else
  if (sock_fd == server_sock_fd6___0) {
    server_sock_ref6 --;
    if (server_sock_ref6 <= 0) {
      close_socket(server_sock_fd6___0);
      server_sock_fd6___0 = -1;
    }
  } else {
    assert(0);
  }
  return;
}
}
int NIO_IsServerSocket(int sock_fd )
{
  int tmp ;
  int tmp___0 ;
  {
  if (sock_fd != -1) {
    if (sock_fd == server_sock_fd4___0) {
      tmp___0 = 1;
    } else
    if (sock_fd == server_sock_fd6___0) {
      tmp___0 = 1;
    } else {
      tmp = is_ptp_socket(sock_fd);
      if (tmp) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
    }
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
int NIO_IsServerSocketOpen(void)
{
  int tmp ;
  {
  if (server_sock_fd4___0 != -1) {
    tmp = 1;
  } else
  if (server_sock_fd6___0 != -1) {
    tmp = 1;
  } else
  if (ptp_sock_fd4 != -1) {
    tmp = 1;
  } else
  if (ptp_sock_fd6 != -1) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
int NIO_IsServerConnectable(NTP_Remote_Address *remote_addr )
{
  int sock_fd ;
  {
  sock_fd = open_separate_client_socket(remote_addr);
  if (sock_fd == -1) {
    return (0);
  }
  close_socket(sock_fd);
  return (1);
}
}
static void process_message(SCK_Message *message , int sock_fd , int event )
{
  NTP_Local_Address local_addr ;
  NTP_Local_Timestamp local_ts ;
  struct timespec sched_ts ;
  int tmp ;
  double tmp___0 ;
  int tmp___1 ;
  {
  SCH_GetLastEventTime(& local_ts.ts, & local_ts.err, (struct timespec *)((void *)0));
  local_ts.source = (NTP_Timestamp_Source )0;
  sched_ts = local_ts.ts;
  if ((unsigned int )message->addr_type != 1U) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return;
  }
  local_addr.ip_addr = message->local_addr.ip;
  local_addr.if_index = message->if_index;
  local_addr.sock_fd = sock_fd;
  tmp = NIO_Linux_ProcessMessage(message, & local_addr, & local_ts, event);
  if (tmp) {
    return;
  }
  if ((unsigned int )local_ts.source != 0U) {
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
  }
  tmp___1 = NIO_UnwrapMessage(message, sock_fd);
  if (! tmp___1) {
    return;
  }
  if (message->length < (int )((unsigned long )(& ((NTP_Packet *)0)->extensions))) {
    goto _L;
  } else
  if ((unsigned long )message->length > sizeof(NTP_Packet )) {
    _L:
    {
    while (1) {
      while_continue___1: ;
      goto while_break___1;
    }
    while_break___1: ;
    }
    return;
  }
  NSR_ProcessRx(& message->remote_addr.ip, & local_addr, & local_ts, (NTP_Packet *)message->data,
                message->length);
  return;
}
}
static void read_from_socket(int sock_fd , int event , void *anything )
{
  SCK_Message *messages ;
  int i ;
  int received ;
  int flags ;
  int tmp ;
  {
  flags = 0;
  tmp = NIO_Linux_ProcessEvent(sock_fd, event);
  if (tmp) {
    return;
  }
  if (event == 4) {
    flags |= 1;
  }
  messages = SCK_ReceiveMessages(sock_fd, flags, & received);
  if (! messages) {
    return;
  }
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < received)) {
      goto while_break;
    }
    process_message(messages + i, sock_fd, event);
    i ++;
  }
  while_break: ;
  }
  return;
}
}
int NIO_UnwrapMessage(SCK_Message *message , int sock_fd )
{
  PTP_NtpMessage *msg ;
  int tmp ;
  __uint16_t tmp___0 ;
  __uint16_t tmp___1 ;
  __uint16_t tmp___2 ;
  __uint16_t tmp___3 ;
  {
  tmp = is_ptp_socket(sock_fd);
  if (! tmp) {
    return (1);
  }
  if (message->length <= (int )((unsigned long )(& ((PTP_NtpMessage *)0)->ntp_msg))) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  msg = (PTP_NtpMessage *)message->data;
  if ((int )msg->header.type != 1) {
    goto _L;
  } else
  if ((int )msg->header.version != 2) {
    goto _L;
  } else {
    tmp___0 = __bswap_16(msg->header.length);
    if ((int )tmp___0 != message->length) {
      goto _L;
    } else
    if ((int )msg->header.domain != 123) {
      goto _L;
    } else {
      tmp___1 = __bswap_16(msg->header.flags);
      if ((int )tmp___1 != 1 << 10) {
        goto _L;
      } else {
        tmp___2 = __bswap_16(msg->tlv_header.type);
        if ((int )tmp___2 != 0x2023) {
          goto _L;
        } else {
          tmp___3 = __bswap_16(msg->tlv_header.length);
          if ((int )tmp___3 != message->length - (int )((unsigned long )(& ((PTP_NtpMessage *)0)->ntp_msg))) {
            _L:
            {
            while (1) {
              while_continue___0: ;
              goto while_break___0;
            }
            while_break___0: ;
            }
            return (0);
          }
        }
      }
    }
  }
  message->data = (void *)((char *)message->data + (int )((unsigned long )(& ((PTP_NtpMessage *)0)->ntp_msg)));
  message->length -= (int )((unsigned long )(& ((PTP_NtpMessage *)0)->ntp_msg));
  {
  while (1) {
    while_continue___1: ;
    goto while_break___1;
  }
  while_break___1: ;
  }
  return (1);
}
}
static int wrap_message(SCK_Message *message , int sock_fd )
{
  int tmp ;
  {
  assert((int )((unsigned long )(& ((PTP_NtpMessage *)0)->ntp_msg)) == 48);
  tmp = is_ptp_socket(sock_fd);
  if (! tmp) {
    return (1);
  }
  if (! ptp_message) {
    return (0);
  }
  if (message->length < (int )((unsigned long )(& ((NTP_Packet *)0)->extensions))) {
    goto _L;
  } else
  if ((unsigned long )(message->length + (int )((unsigned long )(& ((PTP_NtpMessage *)0)->ntp_msg))) > sizeof(*ptp_message)) {
    _L:
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  memset((void *)ptp_message, 0, (size_t )((int )((unsigned long )(& ((PTP_NtpMessage *)0)->ntp_msg))));
  ptp_message->header.type = (uint8_t )1;
  ptp_message->header.version = (uint8_t )2;
  ptp_message->header.length = __bswap_16((__uint16_t )((int )((unsigned long )(& ((PTP_NtpMessage *)0)->ntp_msg)) + message->length));
  ptp_message->header.domain = (uint8_t )123;
  ptp_message->header.flags = __bswap_16((__uint16_t )(1 << 10));
  ptp_message->tlv_header.type = __bswap_16((__uint16_t )0x2023);
  ptp_message->tlv_header.length = __bswap_16((__uint16_t )message->length);
  memcpy((void *)((char *)ptp_message + (int )((unsigned long )(& ((PTP_NtpMessage *)0)->ntp_msg))),
         (void const *)message->data, (size_t )message->length);
  message->data = (void *)ptp_message;
  message->length += (int )((unsigned long )(& ((PTP_NtpMessage *)0)->ntp_msg));
  {
  while (1) {
    while_continue___0: ;
    goto while_break___0;
  }
  while_break___0: ;
  }
  return (1);
}
}
int NIO_SendPacket(NTP_Packet *packet , NTP_Remote_Address *remote_addr , NTP_Local_Address *local_addr ,
                   int length , int process_tx )
{
  SCK_Message message ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  {
  assert(initialised___6);
  if (local_addr->sock_fd == -1) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  SCK_InitMessage(& message, (SCK_AddressType )1);
  message.data = (void *)packet;
  message.length = length;
  tmp___0 = wrap_message(& message, local_addr->sock_fd);
  if (! tmp___0) {
    return (0);
  }
  tmp___1 = NIO_IsServerSocket(local_addr->sock_fd);
  if (tmp___1) {
    message.remote_addr.ip.ip_addr = remote_addr->ip_addr;
    message.remote_addr.ip.port = remote_addr->port;
  } else
  if (! separate_client_sockets) {
    message.remote_addr.ip.ip_addr = remote_addr->ip_addr;
    message.remote_addr.ip.port = remote_addr->port;
  }
  message.local_addr.ip = local_addr->ip_addr;
  tmp___3 = SCK_IsLinkLocalIPAddress(& message.remote_addr.ip.ip_addr);
  if (tmp___3) {
    message.if_index = local_addr->if_index;
  } else {
    message.if_index = -1;
  }
  if (process_tx) {
    NIO_Linux_RequestTxTimestamp(& message, local_addr->sock_fd);
  }
  tmp___4 = SCK_SendMessage(local_addr->sock_fd, & message, 0);
  if (! tmp___4) {
    return (0);
  }
  return (1);
}
}
static ARR_Instance records ;
static int n_sources___0 ;
static int auto_start_sources = 0;
static int record_lock ;
static uint32_t last_address_id = (uint32_t )0;
static uint32_t last_conf_id = (uint32_t )0;
static struct UnresolvedSource *unresolved_sources = (struct UnresolvedSource *)((void *)0);
static int resolving_interval = 0;
static int resolving_restart = 0;
static SCH_TimeoutID resolving_id ;
static struct UnresolvedSource *resolving_source = (struct UnresolvedSource *)((void *)0);
static void (*resolving_end_handler)(void) = (void (*)(void))((void *)0);
static ARR_Instance pools ;
static struct AddressUpdate saved_address_update ;
static void resolve_sources(void) ;
static void rehash_records(void) ;
static void handle_saved_address_update(void) ;
static void clean_source_record(SourceRecord *record ) ;
static void remove_pool_sources(int pool_id , int tentative , int unresolved ) ;
static void remove_unresolved_source(struct UnresolvedSource *us ) ;
static void slew_sources___0(struct timespec *raw , struct timespec *cooked , double dfreq ,
                             double doffset , LCL_ChangeType change_type , void *anything ) ;
static int initialised___7 = 0;
static SourceRecord *get_record(unsigned int index___0 )
{
  void *tmp ;
  {
  tmp = ARR_GetElement(records, index___0);
  return ((SourceRecord *)tmp);
}
}
static struct SourcePool *get_pool(unsigned int index___0 )
{
  void *tmp ;
  {
  tmp = ARR_GetElement(pools, index___0);
  return ((struct SourcePool *)tmp);
}
}
void NSR_Initialise(void)
{
  {
  n_sources___0 = 0;
  initialised___7 = 1;
  records = ARR_CreateInstance((unsigned int )sizeof(SourceRecord ));
  rehash_records();
  pools = ARR_CreateInstance((unsigned int )sizeof(struct SourcePool ));
  LCL_AddParameterChangeHandler(& slew_sources___0, (void *)0);
  return;
}
}
void NSR_Finalise(void)
{
  {
  NSR_RemoveAllSources();
  LCL_RemoveParameterChangeHandler(& slew_sources___0, (void *)0);
  ARR_DestroyInstance(records);
  ARR_DestroyInstance(pools);
  {
  while (1) {
    while_continue: ;
    if (! unresolved_sources) {
      goto while_break;
    }
    remove_unresolved_source(unresolved_sources);
  }
  while_break: ;
  }
  initialised___7 = 0;
  return;
}
}
static int find_slot(IPAddr *ip_addr , int *slot )
{
  SourceRecord *record ;
  uint32_t hash ;
  unsigned int i ;
  unsigned int size ;
  int tmp ;
  {
  size = ARR_GetSize(records);
  *slot = 0;
  {
  if ((int )ip_addr->family == 3) {
    goto case_3;
  }
  if ((int )ip_addr->family == 2) {
    goto case_3;
  }
  if ((int )ip_addr->family == 1) {
    goto case_3;
  }
  goto switch_default;
  case_3:
  case_2:
  case_1:
  goto switch_break;
  switch_default:
  return (0);
  switch_break: ;
  }
  hash = UTI_IPToHash((IPAddr const *)ip_addr);
  i = 0U;
  {
  while (1) {
    while_continue: ;
    if (! (i < size / 2U)) {
      goto while_break;
    }
    *slot = (int )((hash + (i + i * i) / 2U) % size);
    record = get_record((unsigned int )*slot);
    if (! record->remote_addr) {
      goto while_break;
    }
    tmp = UTI_CompareIPs((IPAddr const *)(& (record->remote_addr)->ip_addr), (IPAddr const *)ip_addr,
                         (IPAddr const *)((void *)0));
    if (tmp == 0) {
      return (1);
    }
    i ++;
  }
  while_break: ;
  }
  return (0);
}
}
static int find_slot2(NTP_Remote_Address *remote_addr , int *slot )
{
  int tmp ;
  SourceRecord *tmp___0 ;
  int tmp___1 ;
  SourceRecord *tmp___2 ;
  {
  tmp = find_slot(& remote_addr->ip_addr, slot);
  if (! tmp) {
    return (0);
  }
  tmp___2 = get_record((unsigned int )*slot);
  if ((int )(tmp___2->remote_addr)->port == (int )remote_addr->port) {
    tmp___1 = 2;
  } else {
    tmp___1 = 1;
  }
  return (tmp___1);
}
}
static int check_hashtable_size(unsigned int sources___0 , unsigned int size )
{
  {
  return (sources___0 * 2U <= size);
}
}
static void rehash_records(void)
{
  SourceRecord *temp_records ;
  unsigned int i ;
  unsigned int old_size ;
  unsigned int new_size ;
  int slot ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  SourceRecord *tmp___2 ;
  int tmp___3 ;
  SourceRecord *tmp___4 ;
  {
  assert(! record_lock);
  old_size = ARR_GetSize(records);
  tmp = Malloc2((size_t )old_size, sizeof(SourceRecord ));
  temp_records = (SourceRecord *)tmp;
  tmp___0 = ARR_GetElements(records);
  memcpy((void *)temp_records, (void const *)tmp___0, (unsigned long )old_size * sizeof(SourceRecord ));
  new_size = 1U;
  {
  while (1) {
    while_continue: ;
    tmp___1 = check_hashtable_size((unsigned int )n_sources___0, new_size);
    if (tmp___1) {
      goto while_break;
    }
    new_size *= 2U;
  }
  while_break: ;
  }
  ARR_SetSize(records, new_size);
  i = 0U;
  {
  while (1) {
    while_continue___0: ;
    if (! (i < new_size)) {
      goto while_break___0;
    }
    tmp___2 = get_record(i);
    tmp___2->remote_addr = (NTP_Remote_Address *)((void *)0);
    i ++;
  }
  while_break___0: ;
  }
  i = 0U;
  {
  while (1) {
    while_continue___1: ;
    if (! (i < old_size)) {
      goto while_break___1;
    }
    if (! (temp_records + i)->remote_addr) {
      goto __Cont;
    }
    tmp___3 = find_slot2((temp_records + i)->remote_addr, & slot);
    if (tmp___3 != 0) {
      assert(0);
    }
    tmp___4 = get_record((unsigned int )slot);
    *tmp___4 = *(temp_records + i);
    __Cont:
    i ++;
  }
  while_break___1: ;
  }
  free((void *)temp_records);
  return;
}
}
static NSR_Status add_source(NTP_Remote_Address *remote_addr , char *name , NTP_Source_Type type ,
                             SourceParameters *params , int pool_id , uint32_t conf_id )
{
  SourceRecord *record ;
  int slot ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  struct SourcePool *tmp___6 ;
  struct SourcePool *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  {
  assert(initialised___7);
  tmp___11 = find_slot2(remote_addr, & slot);
  if (tmp___11 != 0) {
    return ((NSR_Status )2);
  } else
  if (! name) {
    tmp___10 = UTI_IsIPReal((IPAddr const *)(& remote_addr->ip_addr));
    if (tmp___10) {
      goto _L___1;
    } else {
      return ((NSR_Status )5);
    }
  } else
  _L___1:
  if (n_sources___0 >= 65536) {
    return ((NSR_Status )3);
  } else
  if ((int )remote_addr->ip_addr.family != 1) {
    if ((int )remote_addr->ip_addr.family != 2) {
      if ((int )remote_addr->ip_addr.family != 3) {
        return ((NSR_Status )4);
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0:
    _L:
    n_sources___0 ++;
    tmp___0 = ARR_GetSize(records);
    tmp___1 = check_hashtable_size((unsigned int )n_sources___0, tmp___0);
    if (! tmp___1) {
      rehash_records();
      tmp = find_slot2(remote_addr, & slot);
      if (tmp != 0) {
        assert(0);
      }
    }
    assert(! record_lock);
    record_lock = 1;
    record = get_record((unsigned int )slot);
    if (! name) {
      tmp___3 = 1;
    } else {
      tmp___2 = UTI_IsStringIP((char const *)name);
      if (tmp___2) {
        tmp___3 = 0;
      } else {
        tmp___3 = 1;
      }
    }
    assert(tmp___3);
    if (name) {
      tmp___5 = name;
    } else {
      tmp___4 = UTI_IPToString((IPAddr const *)(& remote_addr->ip_addr));
      tmp___5 = tmp___4;
    }
    record->name = Strdup((char const *)tmp___5);
    record->data = NCR_CreateInstance(remote_addr, type, params, (char const *)record->name);
    record->remote_addr = NCR_GetRemoteAddress(record->data);
    record->pool_id = pool_id;
    record->tentative = 1;
    record->conf_id = conf_id;
    record_lock = 0;
    if (record->pool_id != -1) {
      tmp___6 = get_pool((unsigned int )record->pool_id);
      (tmp___6->sources) ++;
      tmp___8 = UTI_IsIPReal((IPAddr const *)(& remote_addr->ip_addr));
      if (! tmp___8) {
        tmp___7 = get_pool((unsigned int )record->pool_id);
        (tmp___7->unresolved_sources) ++;
      }
    }
    if (auto_start_sources) {
      tmp___9 = UTI_IsIPReal((IPAddr const *)(& remote_addr->ip_addr));
      if (tmp___9) {
        NCR_StartInstance(record->data);
      }
    }
    handle_saved_address_update();
    return ((NSR_Status )0);
  }
}
}
static NSR_Status change_source_address(NTP_Remote_Address *old_addr , NTP_Remote_Address *new_addr ,
                                        int replacement )
{
  int slot1 ;
  int slot2 ;
  int found ;
  SourceRecord *record ;
  LOG_Severity severity ;
  char *name ;
  NTP_Remote_Address *tmp ;
  int tmp___0 ;
  struct SourcePool *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct SourcePool *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  {
  found = find_slot2(old_addr, & slot1);
  if (found != 2) {
    return ((NSR_Status )1);
  }
  found = find_slot2(new_addr, & slot2);
  if (found == 2) {
    return ((NSR_Status )2);
  } else
  if (found != 0) {
    if (slot1 != slot2) {
      return ((NSR_Status )2);
    }
  }
  assert(! record_lock);
  record_lock = 1;
  record = get_record((unsigned int )slot1);
  NCR_ChangeRemoteAddress(record->data, new_addr, ! replacement);
  tmp = NCR_GetRemoteAddress(record->data);
  if ((unsigned long )record->remote_addr != (unsigned long )tmp) {
    assert(0);
  } else {
    tmp___0 = UTI_CompareIPs((IPAddr const *)(& (record->remote_addr)->ip_addr),
                             (IPAddr const *)(& new_addr->ip_addr), (IPAddr const *)((void *)0));
    if (tmp___0 != 0) {
      assert(0);
    }
  }
  tmp___2 = UTI_IsIPReal((IPAddr const *)(& old_addr->ip_addr));
  if (! tmp___2) {
    tmp___3 = UTI_IsIPReal((IPAddr const *)(& new_addr->ip_addr));
    if (tmp___3) {
      if (auto_start_sources) {
        NCR_StartInstance(record->data);
      }
      if (record->pool_id != -1) {
        tmp___1 = get_pool((unsigned int )record->pool_id);
        (tmp___1->unresolved_sources) --;
      }
    }
  }
  if (! record->tentative) {
    record->tentative = 1;
    if (record->pool_id != -1) {
      tmp___4 = get_pool((unsigned int )record->pool_id);
      (tmp___4->confirmed_sources) --;
    }
  }
  record_lock = 0;
  name = record->name;
  tmp___6 = UTI_IsIPReal((IPAddr const *)(& old_addr->ip_addr));
  if (tmp___6) {
    severity = (LOG_Severity )0;
  } else {
    severity = (LOG_Severity )-1;
  }
  if (found == 0) {
    rehash_records();
    tmp___7 = UTI_IPToString((IPAddr const *)(& new_addr->ip_addr));
    if (replacement) {
      tmp___8 = "replaced with";
    } else {
      tmp___8 = "changed to";
    }
    tmp___9 = UTI_IPToString((IPAddr const *)(& old_addr->ip_addr));
    LOG_Message(severity, (char const *)"Source %s %s %s (%s)", tmp___9, tmp___8,
                tmp___7, name);
  } else {
    tmp___10 = UTI_IPToString((IPAddr const *)(& new_addr->ip_addr));
    LOG_Message(severity, (char const *)"Source %s (%s) changed port to %d", tmp___10,
                name, (int )new_addr->port);
  }
  return ((NSR_Status )0);
}
}
static void handle_saved_address_update(void)
{
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  NSR_Status tmp___2 ;
  {
  tmp = UTI_IsIPReal((IPAddr const *)(& saved_address_update.old_address.ip_addr));
  if (! tmp) {
    return;
  }
  tmp___2 = change_source_address(& saved_address_update.old_address, & saved_address_update.new_address,
                                  0);
  if ((unsigned int )tmp___2 != 0U) {
    tmp___0 = UTI_IPSockAddrToString((IPSockAddr const *)(& saved_address_update.new_address));
    tmp___1 = UTI_IPSockAddrToString((IPSockAddr const *)(& saved_address_update.old_address));
    LOG_Message((LOG_Severity )2, (char const *)"Could not change %s to %s", tmp___1,
                tmp___0);
  }
  saved_address_update.old_address.ip_addr.family = (uint16_t )0;
  return;
}
}
static int replace_source_connectable(NTP_Remote_Address *old_addr , NTP_Remote_Address *new_addr )
{
  char *tmp ;
  int tmp___0 ;
  NSR_Status tmp___1 ;
  {
  tmp___0 = NIO_IsServerConnectable(new_addr);
  if (! tmp___0) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  tmp___1 = change_source_address(old_addr, new_addr, 1);
  if ((unsigned int )tmp___1 == 2U) {
    return (0);
  }
  handle_saved_address_update();
  return (1);
}
}
static void process_resolved_name(struct UnresolvedSource *us , IPAddr *ip_addrs ,
                                  int n_addrs )
{
  NTP_Remote_Address old_addr ;
  NTP_Remote_Address new_addr ;
  SourceRecord *record ;
  unsigned short first ;
  int i ;
  int j ;
  char *tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  {
  first = (unsigned short)0;
  if (us->random_order) {
    UTI_GetRandomBytes((void *)(& first), (unsigned int )sizeof(first));
  }
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < n_addrs)) {
      goto while_break;
    }
    new_addr.ip_addr = *(ip_addrs + ((unsigned int )i + (unsigned int )first) % (unsigned int )n_addrs);
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
    if (us->pool_id != -1) {
      j = 0;
      {
      while (1) {
        while_continue___1: ;
        tmp___1 = ARR_GetSize(records);
        if (! ((unsigned int )j < tmp___1)) {
          goto while_break___1;
        }
        record = get_record((unsigned int )j);
        if (! record->remote_addr) {
          goto __Cont;
        } else
        if (record->pool_id != us->pool_id) {
          goto __Cont;
        } else {
          tmp___0 = UTI_IsIPReal((IPAddr const *)(& (record->remote_addr)->ip_addr));
          if (tmp___0) {
            goto __Cont;
          }
        }
        old_addr = *(record->remote_addr);
        new_addr.port = old_addr.port;
        replace_source_connectable(& old_addr, & new_addr);
        goto while_break___1;
        __Cont:
        j ++;
      }
      while_break___1: ;
      }
    } else {
      new_addr.port = us->address.port;
      tmp___2 = replace_source_connectable(& us->address, & new_addr);
      if (tmp___2) {
        goto while_break;
      }
    }
    i ++;
  }
  while_break: ;
  }
  return;
}
}
static int is_resolved(struct UnresolvedSource *us )
{
  int slot ;
  struct SourcePool *tmp ;
  int tmp___0 ;
  {
  if (us->pool_id != -1) {
    tmp = get_pool((unsigned int )us->pool_id);
    return (tmp->unresolved_sources <= 0);
  } else {
    tmp___0 = find_slot2(& us->address, & slot);
    return (tmp___0 == 0);
  }
}
}
static void resolve_sources_timeout(void *arg )
{
  {
  resolving_id = (SCH_TimeoutID )0;
  resolve_sources();
  return;
}
}
static void name_resolve_handler(DNS_Status status , int n_addrs , IPAddr *ip_addrs ,
                                 void *anything )
{
  struct UnresolvedSource *us ;
  struct UnresolvedSource *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  {
  us = (struct UnresolvedSource *)anything;
  assert((unsigned long )us == (unsigned long )resolving_source);
  assert(resolving_id == 0U);
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  {
  if ((unsigned int )status == 1U) {
    goto case_1;
  }
  if ((unsigned int )status == 0U) {
    goto case_0;
  }
  if ((unsigned int )status == 2U) {
    goto case_2;
  }
  goto switch_default;
  case_1:
  goto switch_break;
  case_0:
  process_resolved_name(us, ip_addrs, n_addrs);
  goto switch_break;
  case_2:
  LOG_Message((LOG_Severity )1, (char const *)"Invalid host %s", us->name);
  goto switch_break;
  switch_default:
  assert(0);
  switch_break: ;
  }
  next = us->next;
  if ((unsigned int )status == 2U) {
    remove_unresolved_source(us);
  } else {
    tmp = UTI_IsIPReal((IPAddr const *)(& us->address.ip_addr));
    if (tmp) {
      remove_unresolved_source(us);
    } else {
      tmp___0 = is_resolved(us);
      if (tmp___0) {
        remove_unresolved_source(us);
      }
    }
  }
  if (! next) {
    if (resolving_restart) {
      next = unresolved_sources;
      resolving_restart = 0;
    }
  }
  resolving_source = next;
  if (next) {
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
    DNS_Name2IPAddressAsync((char const *)next->name, & name_resolve_handler, (void *)next);
  } else {
    if (unresolved_sources) {
      if (resolving_interval + 1 < 9) {
        tmp___3 = resolving_interval + 1;
      } else {
        tmp___3 = 9;
      }
      if (2 > tmp___3) {
        resolving_interval = 2;
      } else {
        if (resolving_interval + 1 < 9) {
          tmp___2 = resolving_interval + 1;
        } else {
          tmp___2 = 9;
        }
        resolving_interval = tmp___2;
      }
      resolving_id = SCH_AddTimeoutByDelay((double )(7 * (1 << resolving_interval)),
                                           & resolve_sources_timeout, (void *)0);
    } else {
      resolving_interval = 0;
    }
    if (resolving_end_handler) {
      (*resolving_end_handler)();
    }
  }
  return;
}
}
static void resolve_sources(void)
{
  struct UnresolvedSource *us ;
  struct UnresolvedSource *next ;
  struct UnresolvedSource *i ;
  int tmp ;
  {
  assert(! resolving_source);
  i = unresolved_sources;
  {
  while (1) {
    while_continue: ;
    if (! i) {
      goto while_break;
    }
    next = i->next;
    tmp = is_resolved(i);
    if (tmp) {
      remove_unresolved_source(i);
    }
    i = next;
  }
  while_break: ;
  }
  if (! unresolved_sources) {
    return;
  }
  DNS_Reload();
  us = unresolved_sources;
  resolving_source = us;
  {
  while (1) {
    while_continue___0: ;
    goto while_break___0;
  }
  while_break___0: ;
  }
  DNS_Name2IPAddressAsync((char const *)us->name, & name_resolve_handler, (void *)us);
  return;
}
}
static void append_unresolved_source(struct UnresolvedSource *us )
{
  struct UnresolvedSource **i ;
  {
  i = & unresolved_sources;
  {
  while (1) {
    while_continue: ;
    if (! *i) {
      goto while_break;
    }
    i = & (*i)->next;
  }
  while_break: ;
  }
  *i = us;
  us->next = (struct UnresolvedSource *)((void *)0);
  return;
}
}
static void remove_unresolved_source(struct UnresolvedSource *us )
{
  struct UnresolvedSource **i ;
  {
  i = & unresolved_sources;
  {
  while (1) {
    while_continue: ;
    if (! *i) {
      goto while_break;
    }
    if ((unsigned long )*i == (unsigned long )us) {
      *i = us->next;
      free((void *)us->name);
      free((void *)us);
      goto while_break;
    }
    i = & (*i)->next;
  }
  while_break: ;
  }
  return;
}
}
static int get_unused_pool_id(void)
{
  struct UnresolvedSource *us ;
  int i ;
  struct SourcePool *tmp ;
  unsigned int tmp___0 ;
  {
  i = 0;
  {
  while (1) {
    while_continue: ;
    tmp___0 = ARR_GetSize(pools);
    if (! ((unsigned int )i < tmp___0)) {
      goto while_break;
    }
    tmp = get_pool((unsigned int )i);
    if (tmp->sources > 0) {
      goto __Cont;
    }
    us = unresolved_sources;
    {
    while (1) {
      while_continue___0: ;
      if (! us) {
        goto while_break___0;
      }
      if (us->pool_id == i) {
        goto while_break___0;
      }
      us = us->next;
    }
    while_break___0: ;
    }
    if (us) {
      goto __Cont;
    }
    return (i);
    __Cont:
    i ++;
  }
  while_break: ;
  }
  return (-1);
}
}
NSR_Status NSR_AddSource(NTP_Remote_Address *remote_addr , NTP_Source_Type type ,
                         SourceParameters *params , uint32_t *conf_id )
{
  NSR_Status s ;
  {
  s = add_source(remote_addr, (char *)((void *)0), type, params, -1, last_conf_id + 1U);
  if ((unsigned int )s != 0U) {
    return (s);
  }
  last_conf_id ++;
  if (conf_id) {
    *conf_id = last_conf_id;
  }
  return (s);
}
}
NSR_Status NSR_AddSourceByName(char *name , int port , int pool , NTP_Source_Type type ,
                               SourceParameters *params , uint32_t *conf_id )
{
  struct UnresolvedSource *us ;
  struct SourcePool *sp ;
  NTP_Remote_Address remote_addr ;
  int i ;
  int new_sources ;
  int pool_id ;
  NSR_Status tmp ;
  int tmp___0 ;
  unsigned short const **tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  NSR_Status tmp___8 ;
  {
  tmp___0 = UTI_StringToIP((char const *)name, & remote_addr.ip_addr);
  if (tmp___0) {
    remote_addr.port = (uint16_t )port;
    tmp = NSR_AddSource(& remote_addr, type, params, conf_id);
    return (tmp);
  }
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! ((int )*(name + i) != 0)) {
      goto while_break;
    }
    tmp___1 = __ctype_b_loc();
    if (! ((int const )*(*tmp___1 + (int )((unsigned char )*(name + i))) & 32768)) {
      return ((NSR_Status )5);
    }
    i ++;
  }
  while_break: ;
  }
  tmp___2 = Malloc(sizeof(struct UnresolvedSource ));
  us = (struct UnresolvedSource *)tmp___2;
  us->name = Strdup((char const *)name);
  us->random_order = 0;
  remote_addr.ip_addr.family = (uint16_t )3;
  last_address_id ++;
  remote_addr.ip_addr.addr.id = last_address_id;
  remote_addr.port = (uint16_t )port;
  if (! pool) {
    us->pool_id = -1;
    us->address = remote_addr;
    new_sources = 1;
  } else {
    pool_id = get_unused_pool_id();
    if (pool_id != -1) {
      sp = get_pool((unsigned int )pool_id);
    } else {
      tmp___3 = ARR_GetNewElement(pools);
      sp = (struct SourcePool *)tmp___3;
      tmp___4 = ARR_GetSize(pools);
      pool_id = (int )(tmp___4 - 1U);
    }
    sp->sources = 0;
    sp->unresolved_sources = 0;
    sp->confirmed_sources = 0;
    if (params->max_sources < 16) {
      tmp___7 = params->max_sources;
    } else {
      tmp___7 = 16;
    }
    if (1 > tmp___7) {
      sp->max_sources = 1;
    } else {
      if (params->max_sources < 16) {
        tmp___6 = params->max_sources;
      } else {
        tmp___6 = 16;
      }
      sp->max_sources = tmp___6;
    }
    us->pool_id = pool_id;
    us->address.ip_addr.family = (uint16_t )0;
    if (2 * sp->max_sources < 16) {
      new_sources = 2 * sp->max_sources;
    } else {
      new_sources = 16;
    }
  }
  append_unresolved_source(us);
  last_conf_id ++;
  if (conf_id) {
    *conf_id = last_conf_id;
  }
  i = 0;
  {
  while (1) {
    while_continue___0: ;
    if (! (i < new_sources)) {
      goto while_break___0;
    }
    if (i > 0) {
      last_address_id ++;
      remote_addr.ip_addr.addr.id = last_address_id;
    }
    tmp___8 = add_source(& remote_addr, name, type, params, us->pool_id, last_conf_id);
    if ((unsigned int )tmp___8 != 0U) {
      return ((NSR_Status )3);
    }
    i ++;
  }
  while_break___0: ;
  }
  return ((NSR_Status )6);
}
}
void NSR_SetSourceResolvingEndHandler(void (*handler)(void) )
{
  {
  resolving_end_handler = handler;
  return;
}
}
void NSR_ResolveSources(void)
{
  {
  if (unresolved_sources) {
    if (! resolving_source) {
      if (resolving_id != 0U) {
        SCH_RemoveTimeout(resolving_id);
        resolving_id = (SCH_TimeoutID )0;
        resolving_interval --;
      }
      resolve_sources();
    } else {
      resolving_restart = 1;
    }
  } else
  if (resolving_end_handler) {
    (*resolving_end_handler)();
  }
  return;
}
}
void NSR_StartSources(void)
{
  NTP_Remote_Address *addr ;
  unsigned int i ;
  SourceRecord *tmp ;
  int tmp___0 ;
  SourceRecord *tmp___1 ;
  unsigned int tmp___2 ;
  {
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp___2 = ARR_GetSize(records);
    if (! (i < tmp___2)) {
      goto while_break;
    }
    tmp = get_record(i);
    addr = tmp->remote_addr;
    if (! addr) {
      goto __Cont;
    } else {
      tmp___0 = UTI_IsIPReal((IPAddr const *)(& addr->ip_addr));
      if (! tmp___0) {
        goto __Cont;
      }
    }
    tmp___1 = get_record(i);
    NCR_StartInstance(tmp___1->data);
    __Cont:
    i ++;
  }
  while_break: ;
  }
  return;
}
}
void NSR_AutoStartSources(void)
{
  {
  auto_start_sources = 1;
  return;
}
}
static void clean_source_record(SourceRecord *record )
{
  struct SourcePool *pool ;
  struct SourcePool *tmp ;
  int tmp___0 ;
  {
  assert((int )record->remote_addr);
  if (record->pool_id != -1) {
    tmp = get_pool((unsigned int )record->pool_id);
    pool = tmp;
    (pool->sources) --;
    tmp___0 = UTI_IsIPReal((IPAddr const *)(& (record->remote_addr)->ip_addr));
    if (! tmp___0) {
      (pool->unresolved_sources) --;
    }
    if (! record->tentative) {
      (pool->confirmed_sources) --;
    }
    if (pool->max_sources > pool->sources) {
      pool->max_sources = pool->sources;
    }
  }
  record->remote_addr = (NTP_Remote_Address *)((void *)0);
  NCR_DestroyInstance(record->data);
  free((void *)record->name);
  n_sources___0 --;
  return;
}
}
NSR_Status NSR_RemoveSource(IPAddr *address )
{
  int slot ;
  int tmp ;
  SourceRecord *tmp___0 ;
  {
  assert(initialised___7);
  tmp = find_slot(address, & slot);
  if (tmp == 0) {
    return ((NSR_Status )1);
  }
  tmp___0 = get_record((unsigned int )slot);
  clean_source_record(tmp___0);
  rehash_records();
  return ((NSR_Status )0);
}
}
void NSR_RemoveSourcesById(uint32_t conf_id )
{
  SourceRecord *record ;
  unsigned int i ;
  unsigned int tmp ;
  {
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp = ARR_GetSize(records);
    if (! (i < tmp)) {
      goto while_break;
    }
    record = get_record(i);
    if (! record->remote_addr) {
      goto __Cont;
    } else
    if (record->conf_id != conf_id) {
      goto __Cont;
    }
    clean_source_record(record);
    __Cont:
    i ++;
  }
  while_break: ;
  }
  rehash_records();
  return;
}
}
void NSR_RemoveAllSources(void)
{
  SourceRecord *record ;
  unsigned int i ;
  unsigned int tmp ;
  {
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp = ARR_GetSize(records);
    if (! (i < tmp)) {
      goto while_break;
    }
    record = get_record(i);
    if (! record->remote_addr) {
      goto __Cont;
    }
    clean_source_record(record);
    __Cont:
    i ++;
  }
  while_break: ;
  }
  rehash_records();
  return;
}
}
static void resolve_source_replacement(SourceRecord *record )
{
  struct UnresolvedSource *us ;
  char *tmp ;
  void *tmp___0 ;
  {
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  tmp___0 = Malloc(sizeof(struct UnresolvedSource ));
  us = (struct UnresolvedSource *)tmp___0;
  us->name = Strdup((char const *)record->name);
  us->random_order = record->tentative;
  us->pool_id = -1;
  us->address = *(record->remote_addr);
  append_unresolved_source(us);
  NSR_ResolveSources();
  return;
}
}
static struct timespec last_replacement ;
void NSR_HandleBadSource(IPAddr *address )
{
  struct timespec now ;
  SourceRecord *record ;
  IPAddr ip_addr ;
  double diff ;
  int slot ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  {
  tmp = find_slot(address, & slot);
  if (! tmp) {
    return;
  }
  record = get_record((unsigned int )slot);
  tmp___0 = UTI_StringToIP((char const *)record->name, & ip_addr);
  if (tmp___0) {
    tmp___1 = UTI_CompareIPs((IPAddr const *)(& (record->remote_addr)->ip_addr),
                             (IPAddr const *)(& ip_addr), (IPAddr const *)((void *)0));
    if (tmp___1 == 0) {
      return;
    }
  }
  SCH_GetLastEventTime((struct timespec *)((void *)0), (double *)((void *)0), & now);
  diff = UTI_DiffTimespecsToDouble((struct timespec const *)(& now), (struct timespec const *)(& last_replacement));
  tmp___2 = fabs(diff);
  if (tmp___2 < (double )(7 * (1 << 8))) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return;
  }
  last_replacement = now;
  resolve_source_replacement(record);
  return;
}
}
void NSR_RefreshAddresses(void)
{
  SourceRecord *record ;
  unsigned int i ;
  unsigned int tmp ;
  {
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp = ARR_GetSize(records);
    if (! (i < tmp)) {
      goto while_break;
    }
    record = get_record(i);
    if (! record->remote_addr) {
      goto __Cont;
    }
    resolve_source_replacement(record);
    __Cont:
    i ++;
  }
  while_break: ;
  }
  return;
}
}
NSR_Status NSR_UpdateSourceNtpAddress(NTP_Remote_Address *old_addr , NTP_Remote_Address *new_addr )
{
  int slot ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  NSR_Status tmp___3 ;
  int tmp___4 ;
  {
  tmp = UTI_IsIPReal((IPAddr const *)(& old_addr->ip_addr));
  if (tmp) {
    tmp___0 = UTI_IsIPReal((IPAddr const *)(& new_addr->ip_addr));
    if (! tmp___0) {
      return ((NSR_Status )4);
    }
  } else {
    return ((NSR_Status )4);
  }
  tmp___1 = UTI_CompareIPs((IPAddr const *)(& old_addr->ip_addr), (IPAddr const *)(& new_addr->ip_addr),
                           (IPAddr const *)((void *)0));
  if (tmp___1 != 0) {
    tmp___2 = find_slot(& new_addr->ip_addr, & slot);
    if (tmp___2) {
      return ((NSR_Status )2);
    }
  }
  if (! record_lock) {
    tmp___3 = change_source_address(old_addr, new_addr, 0);
    return (tmp___3);
  }
  tmp___4 = UTI_IsIPReal((IPAddr const *)(& saved_address_update.old_address.ip_addr));
  if (tmp___4) {
    return ((NSR_Status )3);
  }
  saved_address_update.old_address = *old_addr;
  saved_address_update.new_address = *new_addr;
  return ((NSR_Status )0);
}
}
static void remove_pool_sources(int pool_id , int tentative , int unresolved )
{
  SourceRecord *record ;
  unsigned int i ;
  unsigned int removed ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  {
  removed = 0U;
  i = removed;
  {
  while (1) {
    while_continue: ;
    tmp___2 = ARR_GetSize(records);
    if (! (i < tmp___2)) {
      goto while_break;
    }
    record = get_record(i);
    if (! record->remote_addr) {
      goto __Cont;
    } else
    if (record->pool_id != pool_id) {
      goto __Cont;
    }
    if (tentative) {
      if (! record->tentative) {
        goto __Cont;
      } else {
        goto _L;
      }
    } else
    _L:
    if (unresolved) {
      tmp = UTI_IsIPReal((IPAddr const *)(& (record->remote_addr)->ip_addr));
      if (tmp) {
        goto __Cont;
      }
    }
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
    clean_source_record(record);
    removed ++;
    __Cont:
    i ++;
  }
  while_break: ;
  }
  if (removed) {
    rehash_records();
  }
  return;
}
}
uint32_t NSR_GetLocalRefid(IPAddr *address )
{
  int slot ;
  int tmp ;
  SourceRecord *tmp___0 ;
  uint32_t tmp___1 ;
  {
  tmp = find_slot(address, & slot);
  if (! tmp) {
    return ((uint32_t )0);
  }
  tmp___0 = get_record((unsigned int )slot);
  tmp___1 = NCR_GetLocalRefid(tmp___0->data);
  return (tmp___1);
}
}
char *NSR_GetName(IPAddr *address )
{
  int slot ;
  int tmp ;
  SourceRecord *tmp___0 ;
  {
  tmp = find_slot(address, & slot);
  if (! tmp) {
    return ((char *)((void *)0));
  }
  tmp___0 = get_record((unsigned int )slot);
  return (tmp___0->name);
}
}
void NSR_ProcessRx(NTP_Remote_Address *remote_addr , NTP_Local_Address *local_addr ,
                   NTP_Local_Timestamp *rx_ts , NTP_Packet *message , int length )
{
  SourceRecord *record ;
  struct SourcePool *pool ;
  int slot ;
  int tmp ;
  int tmp___0 ;
  {
  assert(initialised___7);
  if (((int )message->lvm & 0x7) != 3) {
    tmp___0 = find_slot2(remote_addr, & slot);
    if (tmp___0 == 2) {
      record = get_record((unsigned int )slot);
      tmp = NCR_ProcessRxKnown(record->data, local_addr, rx_ts, message, length);
      if (! tmp) {
        return;
      }
      if (record->tentative) {
        record->tentative = 0;
        if (record->pool_id != -1) {
          pool = get_pool((unsigned int )record->pool_id);
          (pool->confirmed_sources) ++;
          {
          while (1) {
            while_continue: ;
            goto while_break;
          }
          while_break: ;
          }
          if (pool->confirmed_sources >= pool->max_sources) {
            remove_pool_sources(record->pool_id, 1, 0);
          }
        }
      }
    } else {
      NCR_ProcessRxUnknown(remote_addr, local_addr, rx_ts, message, length);
    }
  } else {
    NCR_ProcessRxUnknown(remote_addr, local_addr, rx_ts, message, length);
  }
  return;
}
}
void NSR_ProcessTx(NTP_Remote_Address *remote_addr , NTP_Local_Address *local_addr ,
                   NTP_Local_Timestamp *tx_ts , NTP_Packet *message , int length )
{
  SourceRecord *record ;
  int slot ;
  int tmp ;
  {
  if (((int )message->lvm & 0x7) != 4) {
    tmp = find_slot2(remote_addr, & slot);
    if (tmp == 2) {
      record = get_record((unsigned int )slot);
      NCR_ProcessTxKnown(record->data, local_addr, tx_ts, message, length);
    } else {
      NCR_ProcessTxUnknown(remote_addr, local_addr, tx_ts, message, length);
    }
  } else {
    NCR_ProcessTxUnknown(remote_addr, local_addr, tx_ts, message, length);
  }
  return;
}
}
static void slew_sources___0(struct timespec *raw , struct timespec *cooked , double dfreq ,
                             double doffset , LCL_ChangeType change_type , void *anything )
{
  SourceRecord *record ;
  unsigned int i ;
  unsigned int tmp ;
  {
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp = ARR_GetSize(records);
    if (! (i < tmp)) {
      goto while_break;
    }
    record = get_record(i);
    if (record->remote_addr) {
      if ((unsigned int )change_type == 2U) {
        NCR_ResetInstance(record->data);
        NCR_ResetPoll(record->data);
      } else {
        NCR_SlewTimes(record->data, cooked, dfreq, doffset);
      }
    }
    i ++;
  }
  while_break: ;
  }
  return;
}
}
int NSR_SetConnectivity(IPAddr *mask , IPAddr *address , SRC_Connectivity connectivity )
{
  SourceRecord *record ;
  SourceRecord *syncpeer ;
  unsigned int i ;
  unsigned int any ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  {
  if ((unsigned int )connectivity != 0U) {
    NSR_ResolveSources();
  }
  any = 0U;
  syncpeer = (SourceRecord *)((void *)0);
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp___2 = ARR_GetSize(records);
    if (! (i < tmp___2)) {
      goto while_break;
    }
    record = get_record(i);
    if (record->remote_addr) {
      if ((int )address->family == 0) {
        if ((unsigned int )connectivity != 2U) {
          goto _L;
        } else {
          tmp___0 = UTI_IsIPReal((IPAddr const *)(& (record->remote_addr)->ip_addr));
          if (tmp___0) {
            goto _L;
          } else {
            goto _L___0;
          }
        }
      } else {
        _L___0:
        tmp___1 = UTI_CompareIPs((IPAddr const *)(& (record->remote_addr)->ip_addr),
                                 (IPAddr const *)address, (IPAddr const *)mask);
        if (! tmp___1) {
          _L:
          any = 1U;
          tmp = NCR_IsSyncPeer(record->data);
          if (tmp) {
            syncpeer = record;
            goto __Cont;
          }
          NCR_SetConnectivity(record->data, connectivity);
        }
      }
    }
    __Cont:
    i ++;
  }
  while_break: ;
  }
  if (syncpeer) {
    NCR_SetConnectivity(syncpeer->data, connectivity);
  }
  return ((int )any);
}
}
int NSR_ModifyMinpoll(IPAddr *address , int new_minpoll )
{
  int slot ;
  int tmp ;
  SourceRecord *tmp___0 ;
  {
  tmp = find_slot(address, & slot);
  if (! tmp) {
    return (0);
  }
  tmp___0 = get_record((unsigned int )slot);
  NCR_ModifyMinpoll(tmp___0->data, new_minpoll);
  return (1);
}
}
int NSR_ModifyMaxpoll(IPAddr *address , int new_maxpoll )
{
  int slot ;
  int tmp ;
  SourceRecord *tmp___0 ;
  {
  tmp = find_slot(address, & slot);
  if (! tmp) {
    return (0);
  }
  tmp___0 = get_record((unsigned int )slot);
  NCR_ModifyMaxpoll(tmp___0->data, new_maxpoll);
  return (1);
}
}
int NSR_ModifyMaxdelay(IPAddr *address , double new_max_delay )
{
  int slot ;
  int tmp ;
  SourceRecord *tmp___0 ;
  {
  tmp = find_slot(address, & slot);
  if (! tmp) {
    return (0);
  }
  tmp___0 = get_record((unsigned int )slot);
  NCR_ModifyMaxdelay(tmp___0->data, new_max_delay);
  return (1);
}
}
int NSR_ModifyMaxdelayratio(IPAddr *address , double new_max_delay_ratio )
{
  int slot ;
  int tmp ;
  SourceRecord *tmp___0 ;
  {
  tmp = find_slot(address, & slot);
  if (! tmp) {
    return (0);
  }
  tmp___0 = get_record((unsigned int )slot);
  NCR_ModifyMaxdelayratio(tmp___0->data, new_max_delay_ratio);
  return (1);
}
}
int NSR_ModifyMaxdelaydevratio(IPAddr *address , double new_max_delay_dev_ratio )
{
  int slot ;
  int tmp ;
  SourceRecord *tmp___0 ;
  {
  tmp = find_slot(address, & slot);
  if (! tmp) {
    return (0);
  }
  tmp___0 = get_record((unsigned int )slot);
  NCR_ModifyMaxdelaydevratio(tmp___0->data, new_max_delay_dev_ratio);
  return (1);
}
}
int NSR_ModifyMinstratum(IPAddr *address , int new_min_stratum )
{
  int slot ;
  int tmp ;
  SourceRecord *tmp___0 ;
  {
  tmp = find_slot(address, & slot);
  if (! tmp) {
    return (0);
  }
  tmp___0 = get_record((unsigned int )slot);
  NCR_ModifyMinstratum(tmp___0->data, new_min_stratum);
  return (1);
}
}
int NSR_ModifyPolltarget(IPAddr *address , int new_poll_target )
{
  int slot ;
  int tmp ;
  SourceRecord *tmp___0 ;
  {
  tmp = find_slot(address, & slot);
  if (! tmp) {
    return (0);
  }
  tmp___0 = get_record((unsigned int )slot);
  NCR_ModifyPolltarget(tmp___0->data, new_poll_target);
  return (1);
}
}
int NSR_InitiateSampleBurst(int n_good_samples , int n_total_samples , IPAddr *mask ,
                            IPAddr *address )
{
  SourceRecord *record ;
  unsigned int i ;
  int any ;
  int tmp ;
  unsigned int tmp___0 ;
  {
  any = 0;
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp___0 = ARR_GetSize(records);
    if (! (i < tmp___0)) {
      goto while_break;
    }
    record = get_record(i);
    if (record->remote_addr) {
      if ((int )address->family == 0) {
        any = 1;
        NCR_InitiateSampleBurst(record->data, n_good_samples, n_total_samples);
      } else {
        tmp = UTI_CompareIPs((IPAddr const *)(& (record->remote_addr)->ip_addr),
                             (IPAddr const *)address, (IPAddr const *)mask);
        if (! tmp) {
          any = 1;
          NCR_InitiateSampleBurst(record->data, n_good_samples, n_total_samples);
        }
      }
    }
    i ++;
  }
  while_break: ;
  }
  return (any);
}
}
void NSR_ReportSource(RPT_SourceReport *report , struct timespec *now )
{
  int slot ;
  SourceRecord *tmp ;
  int tmp___0 ;
  {
  tmp___0 = find_slot(& report->ip_addr, & slot);
  if (tmp___0) {
    tmp = get_record((unsigned int )slot);
    NCR_ReportSource(tmp->data, report, now);
  } else {
    report->poll = 0;
    report->latest_meas_ago = 0UL;
  }
  return;
}
}
int NSR_GetAuthReport(IPAddr *address , RPT_AuthReport *report )
{
  int slot ;
  int tmp ;
  SourceRecord *tmp___0 ;
  {
  tmp = find_slot(address, & slot);
  if (! tmp) {
    return (0);
  }
  tmp___0 = get_record((unsigned int )slot);
  NCR_GetAuthReport(tmp___0->data, report);
  return (1);
}
}
int NSR_GetNTPReport(RPT_NTPReport *report )
{
  int slot ;
  int tmp ;
  SourceRecord *tmp___0 ;
  {
  tmp = find_slot(& report->remote_addr, & slot);
  if (! tmp) {
    return (0);
  }
  tmp___0 = get_record((unsigned int )slot);
  NCR_GetNTPReport(tmp___0->data, report);
  return (1);
}
}
void NSR_GetActivityReport(RPT_ActivityReport *report )
{
  SourceRecord *record ;
  unsigned int i ;
  int tmp ;
  unsigned int tmp___0 ;
  {
  report->online = 0;
  report->offline = 0;
  report->burst_online = 0;
  report->burst_offline = 0;
  report->unresolved = 0;
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp___0 = ARR_GetSize(records);
    if (! (i < tmp___0)) {
      goto while_break;
    }
    record = get_record(i);
    if (! record->remote_addr) {
      goto __Cont;
    }
    tmp = UTI_IsIPReal((IPAddr const *)(& (record->remote_addr)->ip_addr));
    if (tmp) {
      NCR_IncrementActivityCounters(record->data, & report->online, & report->offline,
                                    & report->burst_online, & report->burst_offline);
    } else {
      (report->unresolved) ++;
    }
    __Cont:
    i ++;
  }
  while_break: ;
  }
  return;
}
}
void NSR_DumpAuthData(void)
{
  SourceRecord *record ;
  int i ;
  unsigned int tmp ;
  {
  i = 0;
  {
  while (1) {
    while_continue: ;
    tmp = ARR_GetSize(records);
    if (! ((unsigned int )i < tmp)) {
      goto while_break;
    }
    record = get_record((unsigned int )i);
    if (! record->remote_addr) {
      goto __Cont;
    }
    NCR_DumpAuthData(record->data);
    __Cont:
    i ++;
  }
  while_break: ;
  }
  return;
}
}
static void split_ip6(IPAddr *ip , uint32_t *dst )
{
  int i ;
  {
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < 4)) {
      goto while_break;
    }
    *(dst + i) = ((((uint32_t )ip->addr.in6[i * 4] << 24) | (unsigned int )((int )ip->addr.in6[i * 4 + 1] << 16)) | (unsigned int )((int )ip->addr.in6[i * 4 + 2] << 8)) | (unsigned int )ip->addr.in6[i * 4 + 3];
    i ++;
  }
  while_break: ;
  }
  return;
}
}
__inline static uint32_t get_subnet(uint32_t *addr , unsigned int where )
{
  int off ;
  {
  off = (int )(where / 32U);
  where %= 32U;
  return ((uint32_t )((unsigned long )(*(addr + off) >> (28U - where)) & ((1UL << 4) - 1UL)));
}
}
ADF_AuthTable ADF_CreateTable(void)
{
  ADF_AuthTable result ;
  void *tmp ;
  {
  tmp = Malloc(sizeof(struct ADF_AuthTableInst ));
  result = (struct ADF_AuthTableInst *)tmp;
  result->base4.state = (State )0;
  result->base4.extended = (struct _TableNode *)((void *)0);
  result->base6.state = (State )0;
  result->base6.extended = (struct _TableNode *)((void *)0);
  return (result);
}
}
static void close_node(TableNode *node )
{
  int i ;
  TableNode *child_node ;
  {
  if ((unsigned long )node->extended != (unsigned long )((void *)0)) {
    i = 0;
    {
    while (1) {
      while_continue: ;
      if (! ((unsigned long )i < 1UL << 4)) {
        goto while_break;
      }
      child_node = node->extended + i;
      close_node(child_node);
      i ++;
    }
    while_break: ;
    }
    free((void *)node->extended);
    node->extended = (struct _TableNode *)((void *)0);
  }
  return;
}
}
static void open_node(TableNode *node )
{
  int i ;
  TableNode *child_node ;
  void *tmp ;
  {
  if ((unsigned long )node->extended == (unsigned long )((void *)0)) {
    tmp = Malloc2(1UL << 4, sizeof(struct _TableNode ));
    node->extended = (struct _TableNode *)tmp;
    i = 0;
    {
    while (1) {
      while_continue: ;
      if (! ((unsigned long )i < 1UL << 4)) {
        goto while_break;
      }
      child_node = node->extended + i;
      child_node->state = (State )2;
      child_node->extended = (struct _TableNode *)((void *)0);
      i ++;
    }
    while_break: ;
    }
  }
  return;
}
}
static ADF_Status set_subnet(TableNode *start_node , uint32_t *ip , int ip_len , int subnet_bits ,
                             State new_state , int delete_children )
{
  int bits_to_go ;
  int bits_consumed ;
  uint32_t subnet ;
  TableNode *node ;
  int N ;
  int i ;
  int j ;
  TableNode *this_node ;
  uint32_t tmp ;
  {
  bits_consumed = 0;
  bits_to_go = subnet_bits;
  node = start_node;
  if (subnet_bits < 0) {
    return ((ADF_Status )1);
  } else
  if (subnet_bits > 32 * ip_len) {
    return ((ADF_Status )1);
  } else {
    if ((bits_to_go & 3) == 0) {
      {
      while (1) {
        while_continue: ;
        if (! (bits_to_go > 0)) {
          goto while_break;
        }
        subnet = get_subnet(ip, (unsigned int )bits_consumed);
        if (! node->extended) {
          open_node(node);
        }
        node = node->extended + subnet;
        bits_to_go -= 4;
        bits_consumed += 4;
      }
      while_break: ;
      }
      if (delete_children) {
        close_node(node);
      }
      node->state = new_state;
    } else {
      {
      while (1) {
        while_continue___0: ;
        if (! (bits_to_go >= 4)) {
          goto while_break___0;
        }
        subnet = get_subnet(ip, (unsigned int )bits_consumed);
        if (! node->extended) {
          open_node(node);
        }
        node = node->extended + subnet;
        bits_to_go -= 4;
        bits_consumed += 4;
      }
      while_break___0: ;
      }
      N = 1 << (4 - bits_to_go);
      tmp = get_subnet(ip, (unsigned int )bits_consumed);
      subnet = tmp & (unsigned int )(~ (N - 1));
      assert((unsigned long )(subnet + (uint32_t )N) <= 1UL << 4);
      if (! node->extended) {
        open_node(node);
      }
      i = (int )subnet;
      j = 0;
      {
      while (1) {
        while_continue___1: ;
        if (! (j < N)) {
          goto while_break___1;
        }
        this_node = node->extended + i;
        if (delete_children) {
          close_node(this_node);
        }
        this_node->state = new_state;
        i ++;
        j ++;
      }
      while_break___1: ;
      }
    }
    return ((ADF_Status )0);
  }
}
}
static ADF_Status set_subnet_(ADF_AuthTable table , IPAddr *ip_addr , int subnet_bits ,
                              State new_state , int delete_children )
{
  uint32_t ip6[4] ;
  ADF_Status tmp ;
  ADF_Status tmp___0 ;
  ADF_Status tmp___1 ;
  ADF_Status tmp___2 ;
  {
  {
  if ((int )ip_addr->family == 1) {
    goto case_1;
  }
  if ((int )ip_addr->family == 2) {
    goto case_2;
  }
  if ((int )ip_addr->family == 0) {
    goto case_0;
  }
  goto switch_default;
  case_1:
  tmp = set_subnet(& table->base4, & ip_addr->addr.in4, 1, subnet_bits, new_state,
                   delete_children);
  return (tmp);
  case_2:
  split_ip6(ip_addr, ip6);
  tmp___0 = set_subnet(& table->base6, ip6, 4, subnet_bits, new_state, delete_children);
  return (tmp___0);
  case_0:
  if (subnet_bits != 0) {
    return ((ADF_Status )1);
  }
  memset((void *)(ip6), 0, sizeof(ip6));
  tmp___1 = set_subnet(& table->base4, ip6, 1, 0, new_state, delete_children);
  if ((unsigned int )tmp___1 == 0U) {
    tmp___2 = set_subnet(& table->base6, ip6, 4, 0, new_state, delete_children);
    if ((unsigned int )tmp___2 == 0U) {
      return ((ADF_Status )0);
    }
  }
  goto switch_break;
  switch_default:
  goto switch_break;
  switch_break: ;
  }
  return ((ADF_Status )1);
}
}
ADF_Status ADF_Allow(ADF_AuthTable table , IPAddr *ip , int subnet_bits )
{
  ADF_Status tmp ;
  {
  tmp = set_subnet_(table, ip, subnet_bits, (State )1, 0);
  return (tmp);
}
}
ADF_Status ADF_AllowAll(ADF_AuthTable table , IPAddr *ip , int subnet_bits )
{
  ADF_Status tmp ;
  {
  tmp = set_subnet_(table, ip, subnet_bits, (State )1, 1);
  return (tmp);
}
}
ADF_Status ADF_Deny(ADF_AuthTable table , IPAddr *ip , int subnet_bits )
{
  ADF_Status tmp ;
  {
  tmp = set_subnet_(table, ip, subnet_bits, (State )0, 0);
  return (tmp);
}
}
ADF_Status ADF_DenyAll(ADF_AuthTable table , IPAddr *ip , int subnet_bits )
{
  ADF_Status tmp ;
  {
  tmp = set_subnet_(table, ip, subnet_bits, (State )0, 1);
  return (tmp);
}
}
void ADF_DestroyTable(ADF_AuthTable table )
{
  {
  close_node(& table->base4);
  close_node(& table->base6);
  free((void *)table);
  return;
}
}
static int check_ip_in_node(TableNode *start_node , uint32_t *ip )
{
  uint32_t subnet ;
  int bits_consumed ;
  int result ;
  int finished ;
  TableNode *node ;
  State state ;
  {
  bits_consumed = 0;
  result = 0;
  finished = 0;
  state = (State )0;
  node = start_node;
  {
  while (1) {
    while_continue: ;
    if ((unsigned int )node->state != 2U) {
      state = node->state;
    }
    if (node->extended) {
      subnet = get_subnet(ip, (unsigned int )bits_consumed);
      node = node->extended + subnet;
      bits_consumed += 4;
    } else {
      finished = 1;
    }
    if (! (! finished)) {
      goto while_break;
    }
  }
  while_break: ;
  }
  {
  if ((unsigned int )state == 1U) {
    goto case_1;
  }
  if ((unsigned int )state == 0U) {
    goto case_0;
  }
  if ((unsigned int )state == 2U) {
    goto case_2;
  }
  goto switch_break;
  case_1:
  result = 1;
  goto switch_break;
  case_0:
  result = 0;
  goto switch_break;
  case_2:
  assert(0);
  goto switch_break;
  switch_break: ;
  }
  return (result);
}
}
int ADF_IsAllowed(ADF_AuthTable table , IPAddr *ip_addr )
{
  uint32_t ip6[4] ;
  int tmp ;
  int tmp___0 ;
  {
  {
  if ((int )ip_addr->family == 1) {
    goto case_1;
  }
  if ((int )ip_addr->family == 2) {
    goto case_2;
  }
  goto switch_default;
  case_1:
  tmp = check_ip_in_node(& table->base4, & ip_addr->addr.in4);
  return (tmp);
  case_2:
  split_ip6(ip_addr, ip6);
  tmp___0 = check_ip_in_node(& table->base6, ip6);
  return (tmp___0);
  switch_default:
  return (0);
  switch_break: ;
  }
}
}
static int is_any_allowed(TableNode *node , State parent )
{
  State state ;
  int i ;
  int tmp ;
  {
  if ((unsigned int )node->state != 2U) {
    state = node->state;
  } else {
    state = parent;
  }
  assert((unsigned int )state != 2U);
  if (node->extended) {
    i = 0;
    {
    while (1) {
      while_continue: ;
      if (! ((unsigned long )i < 1UL << 4)) {
        goto while_break;
      }
      tmp = is_any_allowed(node->extended + i, state);
      if (tmp) {
        return (1);
      }
      i ++;
    }
    while_break: ;
    }
  } else
  if ((unsigned int )state == 1U) {
    return (1);
  }
  return (0);
}
}
int ADF_IsAnyAllowed(ADF_AuthTable table , int family )
{
  int tmp ;
  int tmp___0 ;
  {
  {
  if (family == 1) {
    goto case_1;
  }
  if (family == 2) {
    goto case_2;
  }
  goto switch_default;
  case_1:
  tmp = is_any_allowed(& table->base4, (State )2);
  return (tmp);
  case_2:
  tmp___0 = is_any_allowed(& table->base6, (State )2);
  return (tmp___0);
  switch_default:
  return (0);
  switch_break: ;
  }
}
}
static ARR_Instance records___0 ;
static unsigned int slots ;
static unsigned int max_slots ;
static uint32_t ts_offset ;
static uint16_t max_tokens[3] ;
static uint16_t tokens_per_hit[3] ;
static int token_shift[3] ;
static int leak_rate[3] ;
static int limit_interval[3] ;
static int active ;
static NtpTimestampMap ntp_ts_map ;
static uint32_t total_hits[3] ;
static uint32_t total_drops[3] ;
static uint32_t total_ntp_auth_hits ;
static uint32_t total_ntp_interleaved_hits ;
static uint32_t total_record_drops ;
static int expand_hashtable(void) ;
static void handle_slew___3(struct timespec *raw , struct timespec *cooked , double dfreq ,
                            double doffset , LCL_ChangeType change_type , void *anything ) ;
static int compare_ts(uint32_t x , uint32_t y )
{
  int tmp ;
  {
  if (x == y) {
    return (0);
  }
  if (y == 0U) {
    return (1);
  }
  if ((int32_t )(x - y) > 0) {
    tmp = 1;
  } else {
    tmp = -1;
  }
  return (tmp);
}
}
static int compare_total_hits(Record *x , Record *y )
{
  uint32_t x_hits ;
  uint32_t y_hits ;
  int i ;
  int tmp ;
  {
  i = 0;
  y_hits = (uint32_t )0;
  x_hits = y_hits;
  {
  while (1) {
    while_continue: ;
    if (! (i < 3)) {
      goto while_break;
    }
    x_hits += x->hits[i];
    y_hits += y->hits[i];
    i ++;
  }
  while_break: ;
  }
  if (x_hits > y_hits) {
    tmp = 1;
  } else {
    tmp = -1;
  }
  return (tmp);
}
}
static Record *get_record___0(IPAddr *ip )
{
  uint32_t last_hit ;
  uint32_t oldest_hit ;
  Record *record ;
  Record *oldest_record ;
  unsigned int first ;
  unsigned int i ;
  unsigned int j ;
  uint32_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  {
  last_hit = (uint32_t )0;
  oldest_hit = (uint32_t )0;
  if (! active) {
    return ((Record *)((void *)0));
  } else
  if ((int )ip->family != 1) {
    if ((int )ip->family != 2) {
      return ((Record *)((void *)0));
    }
  }
  {
  while (1) {
    while_continue: ;
    tmp = UTI_IPToHash((IPAddr const *)ip);
    first = (tmp % slots) * (1U << 4);
    i = 0U;
    oldest_record = (Record *)((void *)0);
    {
    while (1) {
      while_continue___0: ;
      if (! (i < 1U << 4)) {
        goto while_break___0;
      }
      tmp___0 = ARR_GetElement(records___0, first + i);
      record = (Record *)tmp___0;
      tmp___1 = UTI_CompareIPs((IPAddr const *)ip, (IPAddr const *)(& record->ip_addr),
                               (IPAddr const *)((void *)0));
      if (! tmp___1) {
        return (record);
      }
      if ((int )record->ip_addr.family == 0) {
        goto while_break___0;
      }
      j = 0U;
      {
      while (1) {
        while_continue___1: ;
        if (! (j < 3U)) {
          goto while_break___1;
        }
        if (j == 0U) {
          last_hit = record->last_hit[j];
        } else {
          tmp___2 = compare_ts(last_hit, record->last_hit[j]);
          if (tmp___2 < 0) {
            last_hit = record->last_hit[j];
          }
        }
        j ++;
      }
      while_break___1: ;
      }
      if (! oldest_record) {
        oldest_record = record;
        oldest_hit = last_hit;
      } else {
        tmp___3 = compare_ts(oldest_hit, last_hit);
        if (tmp___3 > 0) {
          oldest_record = record;
          oldest_hit = last_hit;
        } else
        if (oldest_hit == last_hit) {
          tmp___4 = compare_total_hits(oldest_record, record);
          if (tmp___4 > 0) {
            oldest_record = record;
            oldest_hit = last_hit;
          }
        }
      }
      i ++;
    }
    while_break___0: ;
    }
    if ((int )record->ip_addr.family == 0) {
      goto while_break;
    }
    tmp___5 = expand_hashtable();
    if (tmp___5) {
      goto while_continue;
    }
    record = oldest_record;
    total_record_drops ++;
    goto while_break;
  }
  while_break: ;
  }
  record->ip_addr = *ip;
  i = 0U;
  {
  while (1) {
    while_continue___2: ;
    if (! (i < 3U)) {
      goto while_break___2;
    }
    record->last_hit[i] = (uint32_t )0;
    i ++;
  }
  while_break___2: ;
  }
  i = 0U;
  {
  while (1) {
    while_continue___3: ;
    if (! (i < 3U)) {
      goto while_break___3;
    }
    record->hits[i] = (uint32_t )0;
    i ++;
  }
  while_break___3: ;
  }
  i = 0U;
  {
  while (1) {
    while_continue___4: ;
    if (! (i < 3U)) {
      goto while_break___4;
    }
    record->drops[i] = (uint16_t )0;
    i ++;
  }
  while_break___4: ;
  }
  i = 0U;
  {
  while (1) {
    while_continue___5: ;
    if (! (i < 3U)) {
      goto while_break___5;
    }
    record->tokens[i] = max_tokens[i];
    i ++;
  }
  while_break___5: ;
  }
  i = 0U;
  {
  while (1) {
    while_continue___6: ;
    if (! (i < 3U)) {
      goto while_break___6;
    }
    record->rate[i] = (int8_t )-128;
    i ++;
  }
  while_break___6: ;
  }
  record->ntp_timeout_rate = (int8_t )-128;
  record->drop_flags = (uint8_t )0;
  return (record);
}
}
static int expand_hashtable(void)
{
  ARR_Instance old_records ;
  Record *old_record ;
  Record *new_record ;
  unsigned int i ;
  void *tmp ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  {
  old_records = records___0;
  if (2U * slots > max_slots) {
    return (0);
  }
  records___0 = ARR_CreateInstance((unsigned int )sizeof(Record ));
  if (1U > 2U * slots) {
    slots = 1U;
  } else {
    slots = 2U * slots;
  }
  assert(slots <= max_slots);
  ARR_SetSize(records___0, slots * (1U << 4));
  i = 0U;
  {
  while (1) {
    while_continue: ;
    if (! (i < slots * (1U << 4))) {
      goto while_break;
    }
    tmp = ARR_GetElement(records___0, i);
    new_record = (Record *)tmp;
    new_record->ip_addr.family = (uint16_t )0;
    i ++;
  }
  while_break: ;
  }
  if (! old_records) {
    return (1);
  }
  i = 0U;
  {
  while (1) {
    while_continue___0: ;
    tmp___1 = ARR_GetSize(old_records);
    if (! (i < tmp___1)) {
      goto while_break___0;
    }
    tmp___0 = ARR_GetElement(old_records, i);
    old_record = (Record *)tmp___0;
    if ((int )old_record->ip_addr.family == 0) {
      goto __Cont;
    }
    new_record = get_record___0(& old_record->ip_addr);
    assert((int )new_record);
    *new_record = *old_record;
    __Cont:
    i ++;
  }
  while_break___0: ;
  }
  ARR_DestroyInstance(old_records);
  return (1);
}
}
static void set_bucket_params(int interval , int burst , uint16_t *max_tokens___0 ,
                              uint16_t *tokens_per_packet , int *token_shift___0 )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  {
  if (interval < 12) {
    tmp___1 = interval;
  } else {
    tmp___1 = 12;
  }
  if (-19 > tmp___1) {
    interval = -19;
  } else {
    if (interval < 12) {
      tmp___0 = interval;
    } else {
      tmp___0 = 12;
    }
    interval = tmp___0;
  }
  if (burst < 255) {
    tmp___4 = burst;
  } else {
    tmp___4 = 255;
  }
  if (1 > tmp___4) {
    burst = 1;
  } else {
    if (burst < 255) {
      tmp___3 = burst;
    } else {
      tmp___3 = 255;
    }
    burst = tmp___3;
  }
  if (interval >= -4) {
    *token_shift___0 = 0;
    {
    while (1) {
      while_continue: ;
      if (! (*token_shift___0 < interval + 4)) {
        goto while_break;
      }
      if ((unsigned int )(burst << ((4 + interval) - *token_shift___0)) < 1U << 16) {
        goto while_break;
      }
      (*token_shift___0) ++;
    }
    while_break: ;
    }
  } else {
    *token_shift___0 = interval + 4;
    *tokens_per_packet = (uint16_t )1;
    if (1U << - *token_shift___0 > (unsigned int )burst) {
      burst = (int )(1U << - *token_shift___0);
    } else {
      burst = burst;
    }
  }
  *tokens_per_packet = (uint16_t )(1U << ((4 + interval) - *token_shift___0));
  *max_tokens___0 = (uint16_t )((int )*tokens_per_packet * burst);
  {
  while (1) {
    while_continue___0: ;
    goto while_break___0;
  }
  while_break___0: ;
  }
  return;
}
}
void CLG_Initialise(void)
{
  int i ;
  int interval ;
  int burst ;
  int lrate ;
  int slots2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned long tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  {
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < 3)) {
      goto while_break;
    }
    max_tokens[i] = (uint16_t )0;
    tokens_per_hit[i] = (uint16_t )0;
    token_shift[i] = 0;
    leak_rate[i] = 0;
    limit_interval[i] = -19;
    {
    if (i == 0) {
      goto case_0;
    }
    if (i == 1) {
      goto case_1;
    }
    if (i == 2) {
      goto case_2;
    }
    goto switch_default;
    case_0:
    tmp = CNF_GetNTPRateLimit(& interval, & burst, & lrate);
    if (! tmp) {
      goto __Cont;
    }
    goto switch_break;
    case_1:
    tmp___0 = CNF_GetNtsRateLimit(& interval, & burst, & lrate);
    if (! tmp___0) {
      goto __Cont;
    }
    goto switch_break;
    case_2:
    tmp___1 = CNF_GetCommandRateLimit(& interval, & burst, & lrate);
    if (! tmp___1) {
      goto __Cont;
    }
    goto switch_break;
    switch_default:
    assert(0);
    switch_break: ;
    }
    set_bucket_params(interval, burst, & max_tokens[i], & tokens_per_hit[i], & token_shift[i]);
    if (lrate < 4) {
      tmp___4 = lrate;
    } else {
      tmp___4 = 4;
    }
    if (1 > tmp___4) {
      leak_rate[i] = 1;
    } else {
      if (lrate < 4) {
        tmp___3 = lrate;
      } else {
        tmp___3 = 4;
      }
      leak_rate[i] = tmp___3;
    }
    if (interval < 12) {
      tmp___7 = interval;
    } else {
      tmp___7 = 12;
    }
    if (-19 > tmp___7) {
      limit_interval[i] = -19;
    } else {
      if (interval < 12) {
        tmp___6 = interval;
      } else {
        tmp___6 = 12;
      }
      limit_interval[i] = tmp___6;
    }
    __Cont:
    i ++;
  }
  while_break: ;
  }
  tmp___8 = CNF_GetNoClientLog();
  if (tmp___8) {
    tmp___9 = 0;
  } else {
    tmp___9 = 1;
  }
  active = tmp___9;
  if (! active) {
    i = 0;
    {
    while (1) {
      while_continue___0: ;
      if (! (i < 3)) {
        goto while_break___0;
      }
      if (leak_rate[i] != 0) {
        {
        while (1) {
          while_continue___1: ;
          LOG_Message((LOG_Severity )3, (char const *)"Rate limiting cannot be enabled with noclientlog");
          exit(1);
          goto while_break___1;
        }
        while_break___1: ;
        }
      }
      i ++;
    }
    while_break___0: ;
    }
    return;
  }
  tmp___10 = CNF_GetClientLogLimit();
  max_slots = (unsigned int )(tmp___10 / ((((sizeof(Record ) + sizeof(NtpTimestamps )) * (unsigned long )(1U << 4)) * 3UL) / 2UL));
  if (max_slots < 1U << 20) {
    tmp___13 = max_slots;
  } else {
    tmp___13 = 1U << 20;
  }
  if (1U > tmp___13) {
    max_slots = 1U;
  } else {
    if (max_slots < 1U << 20) {
      tmp___12 = max_slots;
    } else {
      tmp___12 = 1U << 20;
    }
    max_slots = tmp___12;
  }
  slots2 = 0;
  {
  while (1) {
    while_continue___2: ;
    if (! (1U << (slots2 + 1) <= max_slots)) {
      goto while_break___2;
    }
    slots2 ++;
  }
  while_break___2: ;
  }
  {
  while (1) {
    while_continue___3: ;
    goto while_break___3;
  }
  while_break___3: ;
  }
  slots = 0U;
  records___0 = (ARR_Instance )((void *)0);
  expand_hashtable();
  UTI_GetRandomBytes((void *)(& ts_offset), (unsigned int )sizeof(ts_offset));
  ts_offset %= 1000000000U / (1U << 4);
  ntp_ts_map.timestamps = (ARR_Instance )((void *)0);
  ntp_ts_map.first = (uint32_t )0;
  ntp_ts_map.size = (uint32_t )0;
  ntp_ts_map.max_size = 1U << (slots2 + 4);
  ntp_ts_map.cached_index = (uint32_t )0;
  ntp_ts_map.cached_rx_ts = (uint64_t )0ULL;
  ntp_ts_map.slew_epoch = (uint16_t )0;
  ntp_ts_map.slew_offset = 0.0;
  LCL_AddParameterChangeHandler(& handle_slew___3, (void *)0);
  return;
}
}
void CLG_Finalise(void)
{
  {
  if (! active) {
    return;
  }
  ARR_DestroyInstance(records___0);
  if (ntp_ts_map.timestamps) {
    ARR_DestroyInstance(ntp_ts_map.timestamps);
  }
  LCL_RemoveParameterChangeHandler(& handle_slew___3, (void *)0);
  return;
}
}
static uint32_t get_ts_from_timespec(struct timespec *ts )
{
  uint32_t sec ;
  uint32_t nsec ;
  {
  sec = (uint32_t )ts->tv_sec;
  nsec = (uint32_t )ts->tv_nsec;
  nsec += ts_offset;
  if (nsec >= 1000000000U) {
    nsec -= 1000000000U;
    sec ++;
  }
  return ((sec << 4) | (140740U * (nsec >> 15) >> 28));
}
}
static void update_record(CLG_Service service , Record *record , struct timespec *now )
{
  uint32_t interval ;
  uint32_t now_ts ;
  uint32_t prev_hit ;
  uint32_t tokens ;
  int interval2 ;
  int tshift ;
  int mtokens ;
  int8_t *rate ;
  {
  now_ts = get_ts_from_timespec(now);
  prev_hit = record->last_hit[service];
  record->last_hit[service] = now_ts;
  (record->hits[service]) ++;
  interval = now_ts - prev_hit;
  if (prev_hit == 0U) {
    return;
  } else
  if ((int32_t )interval < 0) {
    return;
  }
  tshift = token_shift[service];
  mtokens = (int )max_tokens[service];
  if (tshift >= 0) {
    tokens = (now_ts >> tshift) - (prev_hit >> tshift);
  } else
  if (now_ts - prev_hit > (uint32_t )mtokens) {
    tokens = (uint32_t )mtokens;
  } else {
    tokens = (now_ts - prev_hit) << - tshift;
  }
  if ((uint32_t )record->tokens[service] + tokens < (uint32_t )mtokens) {
    record->tokens[service] = (uint16_t )((uint32_t )record->tokens[service] + tokens);
  } else {
    record->tokens[service] = (uint16_t )mtokens;
  }
  if (interval) {
    interval += interval >> 1;
    interval2 = -16;
    {
    while (1) {
      while_continue: ;
      if (! (interval2 < 56)) {
        goto while_break;
      }
      if (interval <= 1U) {
        goto while_break;
      }
      interval >>= 1;
      interval2 += 4;
    }
    while_break: ;
    }
  } else {
    interval2 = -20;
  }
  if ((unsigned int )service == 0U) {
    if ((unsigned int )record->drop_flags & (1U << (unsigned int )service)) {
      rate = & record->ntp_timeout_rate;
    } else {
      rate = & record->rate[service];
    }
  } else {
    rate = & record->rate[service];
  }
  if ((int )*rate == -128) {
    *rate = (int8_t )(- interval2);
  } else
  if ((int )*rate < - interval2) {
    *rate = (int8_t )((int )*rate + 1);
  } else
  if ((int )*rate > - interval2) {
    if ((int )*rate > 10 - interval2) {
      *rate = (int8_t )(10 - interval2);
    } else {
      *rate = (int8_t )((((int )*rate - interval2) - 1) / 2);
    }
  }
  return;
}
}
static int get_index(Record *record )
{
  void *tmp ;
  {
  tmp = ARR_GetElements(records___0);
  return ((int )(record - (Record *)tmp));
}
}
int CLG_GetClientIndex(IPAddr *client )
{
  Record *record ;
  int tmp ;
  {
  record = get_record___0(client);
  if ((unsigned long )record == (unsigned long )((void *)0)) {
    return (-1);
  }
  tmp = get_index(record);
  return (tmp);
}
}
static void check_service_number(CLG_Service service )
{
  int tmp ;
  {
  if ((unsigned int )service >= 0U) {
    if ((unsigned int )service <= 3U) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  assert(tmp);
  return;
}
}
int CLG_LogServiceAccess(CLG_Service service , IPAddr *client , struct timespec *now )
{
  Record *record ;
  int tmp ;
  int tmp___0 ;
  {
  check_service_number(service);
  (total_hits[service]) ++;
  record = get_record___0(client);
  if ((unsigned long )record == (unsigned long )((void *)0)) {
    return (-1);
  }
  update_record(service, record, now);
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  tmp___0 = get_index(record);
  return (tmp___0);
}
}
static uint32_t rnd ;
static int limit_response_random(int leak_rate___0 ) ;
static int bits_left = 0;
static int limit_response_random(int leak_rate___0 )
{
  int r ;
  {
  if (bits_left < leak_rate___0) {
    UTI_GetRandomBytes((void *)(& rnd), (unsigned int )sizeof(rnd));
    bits_left = (int )(8UL * sizeof(rnd));
  }
  if (rnd % (1U << leak_rate___0)) {
    r = 1;
  } else {
    r = 0;
  }
  rnd >>= leak_rate___0;
  bits_left -= leak_rate___0;
  return (r);
}
}
int CLG_LimitServiceRate(CLG_Service service , int index___0 )
{
  Record *record ;
  int drop ;
  void *tmp ;
  {
  check_service_number(service);
  if ((int )tokens_per_hit[service] == 0) {
    return (0);
  }
  tmp = ARR_GetElement(records___0, (unsigned int )index___0);
  record = (Record *)tmp;
  record->drop_flags = (uint8_t )((unsigned int )record->drop_flags & ~ (1U << (unsigned int )service));
  if ((int )record->tokens[service] >= (int )tokens_per_hit[service]) {
    record->tokens[service] = (uint16_t )((int )record->tokens[service] - (int )tokens_per_hit[service]);
    return (0);
  }
  drop = limit_response_random(leak_rate[service]);
  if ((unsigned int )service == 0U) {
    if ((int )record->ntp_timeout_rate != -128) {
      if ((int )record->ntp_timeout_rate > (int )record->rate[service] + 4) {
        drop = ! drop;
      }
    }
  }
  if (! drop) {
    record->tokens[service] = (uint16_t )0;
    return (0);
  }
  record->drop_flags = (uint8_t )((unsigned int )record->drop_flags | (1U << (unsigned int )service));
  record->drops[service] = (uint16_t )((int )record->drops[service] + 1);
  (total_drops[service]) ++;
  return (1);
}
}
void CLG_LogAuthNtpRequest(void)
{
  {
  total_ntp_auth_hits ++;
  return;
}
}
int CLG_GetNtpMinPoll(void)
{
  {
  return (limit_interval[0]);
}
}
static NtpTimestamps *get_ntp_tss(uint32_t index___0 )
{
  void *tmp ;
  {
  tmp = ARR_GetElement(ntp_ts_map.timestamps, (ntp_ts_map.first + index___0) & (ntp_ts_map.max_size - 1U));
  return ((NtpTimestamps *)tmp);
}
}
static int find_ntp_rx_ts(uint64_t rx_ts , uint32_t *index___0 )
{
  uint64_t rx_x ;
  uint64_t rx_lo ;
  uint64_t rx_hi ;
  uint64_t step ;
  uint32_t i ;
  uint32_t x ;
  uint32_t lo ;
  uint32_t hi ;
  NtpTimestamps *tmp ;
  NtpTimestamps *tmp___0 ;
  NtpTimestamps *tmp___1 ;
  {
  if (ntp_ts_map.cached_rx_ts == rx_ts) {
    if ((unsigned long long )rx_ts != 0ULL) {
      *index___0 = ntp_ts_map.cached_index;
      return (1);
    }
  }
  if (ntp_ts_map.size == 0U) {
    *index___0 = (uint32_t )0;
    return (0);
  }
  lo = (uint32_t )0;
  hi = ntp_ts_map.size - 1U;
  tmp = get_ntp_tss(lo);
  rx_lo = tmp->rx_ts;
  tmp___0 = get_ntp_tss(hi);
  rx_hi = tmp___0->rx_ts;
  if ((int64_t )(rx_ts - rx_lo) < 0L) {
    *index___0 = (uint32_t )0;
    return (0);
  } else
  if ((int64_t )(rx_ts - rx_hi) > 0L) {
    *index___0 = ntp_ts_map.size;
    return (0);
  }
  i = (uint32_t )0;
  {
  while (1) {
    while_continue: ;
    if (rx_ts == rx_hi) {
      ntp_ts_map.cached_index = hi;
      *index___0 = ntp_ts_map.cached_index;
      ntp_ts_map.cached_rx_ts = rx_ts;
      return (1);
    } else
    if (rx_ts == rx_lo) {
      ntp_ts_map.cached_index = lo;
      *index___0 = ntp_ts_map.cached_index;
      ntp_ts_map.cached_rx_ts = rx_ts;
      return (1);
    } else
    if (lo + 1U == hi) {
      *index___0 = hi;
      return (0);
    }
    if (hi - lo > 3U) {
      if (i % 2U == 0U) {
        step = (rx_hi - rx_lo) / (uint64_t )(hi - lo);
        if (step == 0UL) {
          step = (uint64_t )1;
        }
        x = (uint32_t )((uint64_t )lo + (rx_ts - rx_lo) / step);
      } else {
        x = lo + (hi - lo) / 2U;
      }
    } else {
      x = lo + (hi - lo) / 2U;
    }
    if (x <= lo) {
      x = lo + 1U;
    } else
    if (x >= hi) {
      x = hi - 1U;
    }
    tmp___1 = get_ntp_tss(x);
    rx_x = tmp___1->rx_ts;
    if ((int64_t )(rx_x - rx_ts) <= 0L) {
      lo = x;
      rx_lo = rx_x;
    } else {
      hi = x;
      rx_hi = rx_x;
    }
    i ++;
  }
  while_break: ;
  }
}
}
static uint64_t ntp64_to_int64(NTP_int64 *ts )
{
  __uint32_t tmp ;
  __uint32_t tmp___0 ;
  {
  tmp = __bswap_32(ts->hi);
  tmp___0 = __bswap_32(ts->lo);
  return (((uint64_t )tmp << 32) | (unsigned long )tmp___0);
}
}
static void int64_to_ntp64(uint64_t ts , NTP_int64 *ntp_ts )
{
  {
  ntp_ts->hi = __bswap_32((__uint32_t )(ts >> 32));
  ntp_ts->lo = __bswap_32((__uint32_t )ts);
  return;
}
}
static uint32_t push_ntp_tss(uint32_t index___0 )
{
  {
  if (ntp_ts_map.size < ntp_ts_map.max_size) {
    (ntp_ts_map.size) ++;
  } else {
    ntp_ts_map.first = (ntp_ts_map.first + 1U) % ntp_ts_map.max_size;
    if (index___0 > 0U) {
      index___0 --;
    }
  }
  return (index___0);
}
}
static void set_ntp_tx_offset(NtpTimestamps *tss , NTP_int64 *rx_ts , struct timespec *tx_ts )
{
  struct timespec ts ;
  {
  if (! tx_ts) {
    tss->flags = (uint16_t )((int )tss->flags & -3);
    return;
  }
  UTI_Ntp64ToTimespec((NTP_int64 const *)rx_ts, & ts);
  UTI_DiffTimespecs(& ts, (struct timespec const *)tx_ts, (struct timespec const *)(& ts));
  if (ts.tv_sec < -2L) {
    tss->flags = (uint16_t )((int )tss->flags & -3);
    return;
  } else
  if (ts.tv_sec > 1L) {
    tss->flags = (uint16_t )((int )tss->flags & -3);
    return;
  }
  tss->tx_ts_offset = (int32_t )ts.tv_nsec + (int32_t )ts.tv_sec * 1000000000;
  tss->flags = (uint16_t )((int )tss->flags | 2);
  return;
}
}
static void get_ntp_tx(NtpTimestamps *tss , struct timespec *tx_ts )
{
  int32_t offset ;
  NTP_int64 ntp_ts ;
  {
  offset = tss->tx_ts_offset;
  if ((int )tss->flags & 2) {
    int64_to_ntp64(tss->rx_ts, & ntp_ts);
    UTI_Ntp64ToTimespec((NTP_int64 const *)(& ntp_ts), tx_ts);
    if (offset >= 1000000000) {
      offset = (int32_t )((unsigned int )offset - 1000000000U);
      (tx_ts->tv_sec) ++;
    }
    tx_ts->tv_nsec += (__syscall_slong_t )offset;
    UTI_NormaliseTimespec(tx_ts);
  } else {
    UTI_ZeroTimespec(tx_ts);
  }
  return;
}
}
void CLG_SaveNtpTimestamps(NTP_int64 *rx_ts , struct timespec *tx_ts )
{
  NtpTimestamps *tss ;
  uint32_t i ;
  uint32_t index___0 ;
  uint64_t rx ;
  NtpTimestamps *tmp ;
  int tmp___0 ;
  NtpTimestamps *tmp___1 ;
  NtpTimestamps *tmp___2 ;
  NtpTimestamps *tmp___3 ;
  {
  if (! active) {
    return;
  }
  if (! ntp_ts_map.timestamps) {
    ntp_ts_map.timestamps = ARR_CreateInstance((unsigned int )sizeof(NtpTimestamps ));
    ARR_SetSize(ntp_ts_map.timestamps, ntp_ts_map.max_size);
  }
  rx = ntp64_to_int64(rx_ts);
  if ((unsigned long long )rx == 0ULL) {
    return;
  }
  tmp___0 = find_ntp_rx_ts(rx, & index___0);
  if (tmp___0) {
    tmp = get_ntp_tss(index___0);
    tmp->flags = (uint16_t )((int )tmp->flags | 1);
    return;
  }
  assert(index___0 <= ntp_ts_map.size);
  if (index___0 == ntp_ts_map.size) {
    index___0 = push_ntp_tss(index___0);
  } else {
    {
    while (1) {
      while_continue: ;
      if (index___0 < ntp_ts_map.size) {
        tmp___1 = get_ntp_tss(ntp_ts_map.size - 1U);
        if (! ((unsigned long long )(tmp___1->rx_ts - rx) > (unsigned long long )(1LL << 32))) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
      (ntp_ts_map.size) --;
    }
    while_break: ;
    }
    if (index___0 + 64U >= ntp_ts_map.size) {
      index___0 = push_ntp_tss(index___0);
      i = ntp_ts_map.size - 1U;
      {
      while (1) {
        while_continue___0: ;
        if (! (i > index___0)) {
          goto while_break___0;
        }
        tmp___2 = get_ntp_tss(i);
        tmp___3 = get_ntp_tss(i - 1U);
        *tmp___2 = *tmp___3;
        i --;
      }
      while_break___0: ;
      }
    } else
    if (index___0 > 0U) {
      index___0 --;
    }
  }
  ntp_ts_map.cached_index = index___0;
  ntp_ts_map.cached_rx_ts = rx;
  tss = get_ntp_tss(index___0);
  tss->rx_ts = rx;
  tss->flags = (uint16_t )0;
  tss->slew_epoch = ntp_ts_map.slew_epoch;
  set_ntp_tx_offset(tss, rx_ts, tx_ts);
  {
  while (1) {
    while_continue___1: ;
    goto while_break___1;
  }
  while_break___1: ;
  }
  return;
}
}
static void handle_slew___3(struct timespec *raw , struct timespec *cooked , double dfreq ,
                            double doffset , LCL_ChangeType change_type , void *anything )
{
  {
  if ((unsigned int )change_type == 2U) {
    ntp_ts_map.size = (uint32_t )0;
    ntp_ts_map.cached_rx_ts = (uint64_t )0ULL;
  }
  ntp_ts_map.slew_epoch = (uint16_t )((int )ntp_ts_map.slew_epoch + 1);
  ntp_ts_map.slew_offset = doffset;
  return;
}
}
void CLG_UndoNtpTxTimestampSlew(NTP_int64 *rx_ts , struct timespec *tx_ts )
{
  uint32_t index___0 ;
  uint64_t tmp ;
  int tmp___0 ;
  NtpTimestamps *tmp___1 ;
  {
  if (! ntp_ts_map.timestamps) {
    return;
  }
  tmp = ntp64_to_int64(rx_ts);
  tmp___0 = find_ntp_rx_ts(tmp, & index___0);
  if (! tmp___0) {
    return;
  }
  tmp___1 = get_ntp_tss(index___0);
  if ((int )((uint16_t )((unsigned int )tmp___1->slew_epoch + 1U)) == (int )ntp_ts_map.slew_epoch) {
    UTI_AddDoubleToTimespec((struct timespec const *)tx_ts, ntp_ts_map.slew_offset,
                            tx_ts);
  }
  return;
}
}
void CLG_UpdateNtpTxTimestamp(NTP_int64 *rx_ts , struct timespec *tx_ts )
{
  uint32_t index___0 ;
  uint64_t tmp ;
  int tmp___0 ;
  NtpTimestamps *tmp___1 ;
  {
  if (! ntp_ts_map.timestamps) {
    return;
  }
  tmp = ntp64_to_int64(rx_ts);
  tmp___0 = find_ntp_rx_ts(tmp, & index___0);
  if (! tmp___0) {
    return;
  }
  tmp___1 = get_ntp_tss(index___0);
  set_ntp_tx_offset(tmp___1, rx_ts, tx_ts);
  return;
}
}
int CLG_GetNtpTxTimestamp(NTP_int64 *rx_ts , struct timespec *tx_ts )
{
  NtpTimestamps *tss ;
  uint32_t index___0 ;
  uint64_t tmp ;
  int tmp___0 ;
  {
  if (! ntp_ts_map.timestamps) {
    return (0);
  }
  tmp = ntp64_to_int64(rx_ts);
  tmp___0 = find_ntp_rx_ts(tmp, & index___0);
  if (! tmp___0) {
    return (0);
  }
  tss = get_ntp_tss(index___0);
  if ((int )tss->flags & 1) {
    return (0);
  }
  get_ntp_tx(tss, tx_ts);
  return (1);
}
}
void CLG_DisableNtpTimestamps(NTP_int64 *rx_ts )
{
  uint32_t index___0 ;
  NtpTimestamps *tmp ;
  uint64_t tmp___0 ;
  int tmp___1 ;
  {
  if (! ntp_ts_map.timestamps) {
    return;
  }
  tmp___0 = ntp64_to_int64(rx_ts);
  tmp___1 = find_ntp_rx_ts(tmp___0, & index___0);
  if (tmp___1) {
    tmp = get_ntp_tss(index___0);
    tmp->flags = (uint16_t )((int )tmp->flags | 1);
  }
  total_ntp_interleaved_hits ++;
  return;
}
}
int CLG_GetNumberOfIndices(void)
{
  unsigned int tmp ;
  {
  if (! active) {
    return (-1);
  }
  tmp = ARR_GetSize(records___0);
  return ((int )tmp);
}
}
static int get_interval(int rate )
{
  int tmp ;
  {
  if (rate == -128) {
    return (127);
  }
  if (rate > 0) {
    tmp = 2;
  } else {
    tmp = -2;
  }
  rate += tmp;
  return (rate / -4);
}
}
static uint32_t get_last_ago(uint32_t x , uint32_t y )
{
  {
  if (y == 0U) {
    return ((uint32_t )-1);
  } else
  if ((int32_t )(x - y) < 0) {
    return ((uint32_t )-1);
  }
  return ((x - y) >> 4);
}
}
int CLG_GetClientAccessReportByIndex(int index___0 , int reset , uint32_t min_hits ,
                                     RPT_ClientAccessByIndex_Report *report , struct timespec *now )
{
  Record *record ;
  uint32_t now_ts ;
  int i ;
  int r ;
  unsigned int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  {
  if (! active) {
    return (0);
  } else
  if (index___0 < 0) {
    return (0);
  } else {
    tmp = ARR_GetSize(records___0);
    if ((unsigned int )index___0 >= tmp) {
      return (0);
    }
  }
  tmp___0 = ARR_GetElement(records___0, (unsigned int )index___0);
  record = (Record *)tmp___0;
  if ((int )record->ip_addr.family == 0) {
    return (0);
  }
  if (min_hits == 0U) {
    r = 1;
  } else {
    r = 0;
    i = r;
    {
    while (1) {
      while_continue: ;
      if (! (i < 3)) {
        goto while_break;
      }
      if (record->hits[i] >= min_hits) {
        r = 1;
        goto while_break;
      }
      i ++;
    }
    while_break: ;
    }
  }
  if (r) {
    now_ts = get_ts_from_timespec(now);
    report->ip_addr = record->ip_addr;
    report->ntp_hits = record->hits[0];
    report->nke_hits = record->hits[1];
    report->cmd_hits = record->hits[2];
    report->ntp_drops = record->drops[0];
    report->nke_drops = record->drops[1];
    report->cmd_drops = record->drops[2];
    tmp___1 = get_interval((int )record->rate[0]);
    report->ntp_interval = (int8_t )tmp___1;
    tmp___2 = get_interval((int )record->rate[1]);
    report->nke_interval = (int8_t )tmp___2;
    tmp___3 = get_interval((int )record->rate[2]);
    report->cmd_interval = (int8_t )tmp___3;
    tmp___4 = get_interval((int )record->ntp_timeout_rate);
    report->ntp_timeout_interval = (int8_t )tmp___4;
    report->last_ntp_hit_ago = get_last_ago(now_ts, record->last_hit[0]);
    report->last_nke_hit_ago = get_last_ago(now_ts, record->last_hit[1]);
    report->last_cmd_hit_ago = get_last_ago(now_ts, record->last_hit[2]);
  }
  if (reset) {
    i = 0;
    {
    while (1) {
      while_continue___0: ;
      if (! (i < 3)) {
        goto while_break___0;
      }
      record->hits[i] = (uint32_t )0;
      record->drops[i] = (uint16_t )0;
      i ++;
    }
    while_break___0: ;
    }
  }
  return (r);
}
}
void CLG_GetServerStatsReport(RPT_ServerStatsReport *report )
{
  NtpTimestamps *tmp ;
  NtpTimestamps *tmp___0 ;
  {
  report->ntp_hits = total_hits[0];
  report->nke_hits = total_hits[1];
  report->cmd_hits = total_hits[2];
  report->ntp_drops = total_drops[0];
  report->nke_drops = total_drops[1];
  report->cmd_drops = total_drops[2];
  report->log_drops = total_record_drops;
  report->ntp_auth_hits = total_ntp_auth_hits;
  report->ntp_interleaved_hits = total_ntp_interleaved_hits;
  report->ntp_timestamps = ntp_ts_map.size;
  if (ntp_ts_map.size > 1U) {
    tmp = get_ntp_tss(ntp_ts_map.size - 1U);
    tmp___0 = get_ntp_tss((uint32_t )0);
    report->ntp_span_seconds = (uint32_t )((tmp->rx_ts - tmp___0->rx_ts) >> 32);
  } else {
    report->ntp_span_seconds = (uint32_t )0;
  }
  return;
}
}
static ARR_Instance keys ;
static int cache_valid ;
static uint32_t cache_key_id ;
static int cache_key_pos ;
static void free_keys(void)
{
  unsigned int i ;
  Key *key ;
  void *tmp ;
  unsigned int tmp___0 ;
  {
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp___0 = ARR_GetSize(keys);
    if (! (i < tmp___0)) {
      goto while_break;
    }
    tmp = ARR_GetElement(keys, i);
    key = (Key *)tmp;
    {
    if ((unsigned int )key->class == 0U) {
      goto case_0;
    }
    if ((unsigned int )key->class == 1U) {
      goto case_1;
    }
    goto switch_default;
    case_0:
    free((void *)key->data.ntp_mac.value);
    goto switch_break;
    case_1:
    CMC_DestroyInstance(key->data.cmac);
    goto switch_break;
    switch_default:
    assert(0);
    switch_break: ;
    }
    i ++;
  }
  while_break: ;
  }
  ARR_SetSize(keys, 0U);
  cache_valid = 0;
  return;
}
}
void KEY_Initialise(void)
{
  {
  keys = ARR_CreateInstance((unsigned int )sizeof(Key ));
  cache_valid = 0;
  KEY_Reload();
  return;
}
}
void KEY_Finalise(void)
{
  {
  free_keys();
  ARR_DestroyInstance(keys);
  return;
}
}
static Key *get_key(unsigned int index___0 )
{
  void *tmp ;
  {
  tmp = ARR_GetElements(keys);
  return ((Key *)tmp + index___0);
}
}
static int decode_key(char *key )
{
  int len ;
  size_t tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  tmp = strlen((char const *)key);
  len = (int )tmp;
  tmp___2 = strncmp((char const *)key, (char const *)"ASCII:", (size_t )6);
  if (tmp___2) {
    tmp___1 = strncmp((char const *)key, (char const *)"HEX:", (size_t )4);
    if (tmp___1) {
      return (len);
    } else {
      tmp___0 = UTI_HexToBytes((char const *)(key + 4), (void *)key, (unsigned int )len);
      return ((int )tmp___0);
    }
  } else {
    memmove((void *)key, (void const *)(key + 6), (size_t )(len - 6));
    return (len - 6);
  }
}
}
static int compare_keys_by_id(void const *a , void const *b )
{
  Key const *c ;
  Key const *d ;
  {
  c = (Key const *)a;
  d = (Key const *)b;
  if (c->id < d->id) {
    return (-1);
  } else
  if (c->id > d->id) {
    return (1);
  } else {
    return (0);
  }
}
}
void KEY_Reload(void)
{
  unsigned int i ;
  unsigned int line_number___0 ;
  unsigned int key_length ;
  unsigned int cmac_key_length ;
  FILE *in ;
  char line[2048] ;
  char *key_file ;
  char *key_value ;
  char const *key_type ;
  HSH_Algorithm hash_algorithm ;
  CMC_Algorithm cmac_algorithm ;
  int hash_id ;
  Key key ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char __attribute__((__access__(__write_only__,1,2))) *tmp___3 ;
  unsigned int tmp___4 ;
  void *tmp___5 ;
  Key *tmp___6 ;
  Key *tmp___7 ;
  Key *tmp___8 ;
  unsigned int tmp___9 ;
  {
  free_keys();
  key_file = CNF_GetKeysFile();
  line_number___0 = 0U;
  if (! key_file) {
    return;
  }
  in = UTI_OpenFile((char const *)((void *)0), (char const *)key_file, (char const *)((void *)0),
                    (char )'r', (mode_t )0);
  if (! in) {
    LOG_Message((LOG_Severity )1, (char const *)"Could not open keyfile %s", key_file);
    return;
  }
  {
  while (1) {
    while_continue: ;
    tmp___3 = fgets(line, (int )sizeof(line), in);
    if (! tmp___3) {
      goto while_break;
    }
    line_number___0 ++;
    CPS_NormalizeLine(line);
    if (! line[0]) {
      goto while_continue;
    }
    memset((void *)(& key), 0, sizeof(key));
    tmp = CPS_ParseKey(line, & key.id, & key_type, & key_value);
    if (! tmp) {
      LOG_Message((LOG_Severity )1, (char const *)"Could not parse key at line %u in file %s",
                  line_number___0, key_file);
      goto while_continue;
    }
    tmp___0 = decode_key(key_value);
    key_length = (unsigned int )tmp___0;
    if (key_length == 0U) {
      LOG_Message((LOG_Severity )1, (char const *)"Could not decode key %u", key.id);
      goto while_continue;
    }
    hash_algorithm = UTI_HashNameToAlgorithm(key_type);
    cmac_algorithm = UTI_CmacNameToAlgorithm(key_type);
    if ((unsigned int )hash_algorithm != 0U) {
      hash_id = HSH_GetHashId(hash_algorithm);
      if (hash_id < 0) {
        LOG_Message((LOG_Severity )1, (char const *)"Unsupported %s in key %u",
                    "hash function", key.id);
        goto while_continue;
      }
      key.class = (KeyClass )0;
      key.type = (int )hash_algorithm;
      key.length = (int )key_length;
      tmp___1 = Malloc2((size_t )key_length, sizeof(unsigned char ));
      key.data.ntp_mac.value = (unsigned char *)tmp___1;
      memcpy((void *)key.data.ntp_mac.value, (void const *)key_value, (size_t )key_length);
      key.data.ntp_mac.hash_id = hash_id;
    } else
    if ((unsigned int )cmac_algorithm != 0U) {
      tmp___2 = CMC_GetKeyLength(cmac_algorithm);
      cmac_key_length = (unsigned int )tmp___2;
      if (cmac_key_length == 0U) {
        LOG_Message((LOG_Severity )1, (char const *)"Unsupported %s in key %u",
                    "cipher", key.id);
        goto while_continue;
      } else
      if (cmac_key_length != key_length) {
        LOG_Message((LOG_Severity )1, (char const *)"Invalid length of %s key %u (expected %u bits)",
                    key_type, key.id, 8U * cmac_key_length);
        goto while_continue;
      }
      key.class = (KeyClass )1;
      key.type = (int )cmac_algorithm;
      key.length = (int )key_length;
      key.data.cmac = CMC_CreateInstance(cmac_algorithm, (unsigned char const *)((unsigned char *)key_value),
                                         (int )key_length);
      assert((int )key.data.cmac);
    } else {
      LOG_Message((LOG_Severity )1, (char const *)"Invalid type in key %u", key.id);
      goto while_continue;
    }
    ARR_AppendElement(keys, (void *)(& key));
  }
  while_break: ;
  }
  fclose(in);
  tmp___4 = ARR_GetSize(keys);
  tmp___5 = ARR_GetElements(keys);
  qsort(tmp___5, (size_t )tmp___4, sizeof(Key ), & compare_keys_by_id);
  i = 1U;
  {
  while (1) {
    while_continue___0: ;
    tmp___9 = ARR_GetSize(keys);
    if (! (i < tmp___9)) {
      goto while_break___0;
    }
    tmp___7 = get_key(i - 1U);
    tmp___8 = get_key(i);
    if (tmp___7->id == tmp___8->id) {
      tmp___6 = get_key(i - 1U);
      LOG_Message((LOG_Severity )1, (char const *)"Detected duplicate key %u", tmp___6->id);
    }
    i ++;
  }
  while_break___0: ;
  }
  memset((void *)(line), 0, sizeof(line));
  return;
}
}
static int lookup_key(uint32_t id )
{
  Key specimen ;
  Key *where ;
  Key *keys_ptr ;
  int pos ;
  void *tmp ;
  unsigned int tmp___0 ;
  void *tmp___1 ;
  {
  tmp = ARR_GetElements(keys);
  keys_ptr = (Key *)tmp;
  specimen.id = id;
  tmp___0 = ARR_GetSize(keys);
  tmp___1 = bsearch((void const *)((void *)(& specimen)), (void const *)keys_ptr,
                    (size_t )tmp___0, sizeof(Key ), & compare_keys_by_id);
  where = (Key *)tmp___1;
  if (! where) {
    return (-1);
  } else {
    pos = (int )(where - keys_ptr);
    return (pos);
  }
}
}
static Key *get_key_by_id(uint32_t key_id )
{
  int position ;
  Key *tmp ;
  Key *tmp___0 ;
  {
  if (cache_valid) {
    if (key_id == cache_key_id) {
      tmp = get_key((unsigned int )cache_key_pos);
      return (tmp);
    }
  }
  position = lookup_key(key_id);
  if (position >= 0) {
    cache_valid = 1;
    cache_key_pos = position;
    cache_key_id = key_id;
    tmp___0 = get_key((unsigned int )position);
    return (tmp___0);
  }
  return ((Key *)((void *)0));
}
}
int KEY_KeyKnown(uint32_t key_id )
{
  Key *tmp ;
  {
  tmp = get_key_by_id(key_id);
  return ((unsigned long )tmp != (unsigned long )((void *)0));
}
}
int KEY_GetAuthLength(uint32_t key_id )
{
  unsigned char buf[64] ;
  Key *key ;
  int tmp ;
  int tmp___0 ;
  {
  key = get_key_by_id(key_id);
  if (! key) {
    return (0);
  }
  {
  if ((unsigned int )key->class == 0U) {
    goto case_0;
  }
  if ((unsigned int )key->class == 1U) {
    goto case_1;
  }
  goto switch_default;
  case_0:
  tmp = HSH_Hash(key->data.ntp_mac.hash_id, (void const *)(buf), 0, (void const *)(buf),
                 0, buf, (int )sizeof(buf));
  return (tmp);
  case_1:
  tmp___0 = CMC_Hash(key->data.cmac, (void const *)(buf), 0, buf, (int )sizeof(buf));
  return (tmp___0);
  switch_default:
  assert(0);
  return (0);
  switch_break: ;
  }
}
}
int KEY_CheckKeyLength(uint32_t key_id )
{
  Key *key ;
  {
  key = get_key_by_id(key_id);
  if (! key) {
    return (0);
  }
  return (key->length >= 10);
}
}
int KEY_GetKeyInfo(uint32_t key_id , int *type , int *bits )
{
  Key *key ;
  {
  key = get_key_by_id(key_id);
  if (! key) {
    return (0);
  }
  *type = key->type;
  *bits = 8 * key->length;
  return (1);
}
}
static int generate_auth(Key *key , void const *data , int data_len , unsigned char *auth ,
                         int auth_len )
{
  int tmp ;
  int tmp___0 ;
  {
  {
  if ((unsigned int )key->class == 0U) {
    goto case_0;
  }
  if ((unsigned int )key->class == 1U) {
    goto case_1;
  }
  goto switch_default;
  case_0:
  tmp = HSH_Hash(key->data.ntp_mac.hash_id, (void const *)key->data.ntp_mac.value,
                 key->length, data, data_len, auth, auth_len);
  return (tmp);
  case_1:
  tmp___0 = CMC_Hash(key->data.cmac, data, data_len, auth, auth_len);
  return (tmp___0);
  switch_default:
  return (0);
  switch_break: ;
  }
}
}
static int check_auth(Key *key , void const *data , int data_len , unsigned char const *auth ,
                      int auth_len , int trunc_len )
{
  unsigned char buf[64] ;
  int hash_len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  hash_len = generate_auth(key, data, data_len, buf, (int )sizeof(buf));
  if (hash_len < trunc_len) {
    tmp = hash_len;
  } else {
    tmp = trunc_len;
  }
  if (tmp == auth_len) {
    tmp___0 = memcmp((void const *)(buf), (void const *)auth, (size_t )auth_len);
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
int KEY_GenerateAuth(uint32_t key_id , void const *data , int data_len , unsigned char *auth ,
                     int auth_len )
{
  Key *key ;
  int tmp ;
  {
  key = get_key_by_id(key_id);
  if (! key) {
    return (0);
  }
  tmp = generate_auth(key, data, data_len, auth, auth_len);
  return (tmp);
}
}
int KEY_CheckAuth(uint32_t key_id , void const *data , int data_len , unsigned char const *auth ,
                  int auth_len , int trunc_len )
{
  Key *key ;
  int tmp ;
  {
  key = get_key_by_id(key_id);
  if (! key) {
    return (0);
  }
  tmp = check_auth(key, data, data_len, auth, auth_len, trunc_len);
  return (tmp);
}
}
extern void ( __attribute__((__leaf__)) setrpcent)(int __stayopen ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) endrpcent)(void) __attribute__((__nothrow__)) ;
extern struct rpcent *( __attribute__((__leaf__)) getrpcbyname)(char const *__name ) __attribute__((__nothrow__)) ;
extern struct rpcent *( __attribute__((__leaf__)) getrpcbynumber)(int __number ) __attribute__((__nothrow__)) ;
extern struct rpcent *( __attribute__((__leaf__)) getrpcent)(void) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) getrpcbyname_r)(char const *__name , struct rpcent *__result_buf ,
                                                       char *__buffer , size_t __buflen ,
                                                       struct rpcent **__result ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) getrpcbynumber_r)(int __number , struct rpcent *__result_buf ,
                                                         char *__buffer , size_t __buflen ,
                                                         struct rpcent **__result ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) getrpcent_r)(struct rpcent *__result_buf ,
                                                    char *__buffer , size_t __buflen ,
                                                    struct rpcent **__result ) __attribute__((__nothrow__)) ;
extern int *( __attribute__((__leaf__)) __h_errno_location)(void) __attribute__((__nothrow__,
__const__)) ;
extern void ( __attribute__((__leaf__)) herror)(char const *__str ) __attribute__((__nothrow__)) ;
extern char const *( __attribute__((__leaf__)) hstrerror)(int __err_num ) __attribute__((__nothrow__)) ;
extern void sethostent(int __stay_open ) ;
extern void endhostent(void) ;
extern struct hostent *gethostent(void) ;
extern struct hostent *gethostbyaddr(void const *__addr , __socklen_t __len , int __type ) ;
extern struct hostent *gethostbyname(char const *__name ) ;
extern struct hostent *gethostbyname2(char const *__name , int __af ) ;
extern int gethostent_r(struct hostent * __restrict __result_buf , char * __restrict __buf ,
                        size_t __buflen , struct hostent ** __restrict __result ,
                        int * __restrict __h_errnop ) ;
extern int gethostbyaddr_r(void const * __restrict __addr , __socklen_t __len ,
                           int __type , struct hostent * __restrict __result_buf ,
                           char * __restrict __buf , size_t __buflen , struct hostent ** __restrict __result ,
                           int * __restrict __h_errnop ) ;
extern int gethostbyname_r(char const * __restrict __name , struct hostent * __restrict __result_buf ,
                           char * __restrict __buf , size_t __buflen , struct hostent ** __restrict __result ,
                           int * __restrict __h_errnop ) ;
extern int gethostbyname2_r(char const * __restrict __name , int __af , struct hostent * __restrict __result_buf ,
                            char * __restrict __buf , size_t __buflen , struct hostent ** __restrict __result ,
                            int * __restrict __h_errnop ) ;
extern void setnetent(int __stay_open ) ;
extern void endnetent(void) ;
extern struct netent *getnetent(void) ;
extern struct netent *getnetbyaddr(uint32_t __net , int __type ) ;
extern struct netent *getnetbyname(char const *__name ) ;
extern int getnetent_r(struct netent * __restrict __result_buf , char * __restrict __buf ,
                       size_t __buflen , struct netent ** __restrict __result , int * __restrict __h_errnop ) ;
extern int getnetbyaddr_r(uint32_t __net , int __type , struct netent * __restrict __result_buf ,
                          char * __restrict __buf , size_t __buflen , struct netent ** __restrict __result ,
                          int * __restrict __h_errnop ) ;
extern int getnetbyname_r(char const * __restrict __name , struct netent * __restrict __result_buf ,
                          char * __restrict __buf , size_t __buflen , struct netent ** __restrict __result ,
                          int * __restrict __h_errnop ) ;
extern void setservent(int __stay_open ) ;
extern void endservent(void) ;
extern struct servent *getservent(void) ;
extern struct servent *getservbyname(char const *__name , char const *__proto ) ;
extern struct servent *getservbyport(int __port , char const *__proto ) ;
extern int getservent_r(struct servent * __restrict __result_buf , char * __restrict __buf ,
                        size_t __buflen , struct servent ** __restrict __result ) ;
extern int getservbyname_r(char const * __restrict __name , char const * __restrict __proto ,
                           struct servent * __restrict __result_buf , char * __restrict __buf ,
                           size_t __buflen , struct servent ** __restrict __result ) ;
extern int getservbyport_r(int __port , char const * __restrict __proto , struct servent * __restrict __result_buf ,
                           char * __restrict __buf , size_t __buflen , struct servent ** __restrict __result ) ;
extern void setprotoent(int __stay_open ) ;
extern void endprotoent(void) ;
extern struct protoent *getprotoent(void) ;
extern struct protoent *getprotobyname(char const *__name ) ;
extern struct protoent *getprotobynumber(int __proto ) ;
extern int getprotoent_r(struct protoent * __restrict __result_buf , char * __restrict __buf ,
                         size_t __buflen , struct protoent ** __restrict __result ) ;
extern int getprotobyname_r(char const * __restrict __name , struct protoent * __restrict __result_buf ,
                            char * __restrict __buf , size_t __buflen , struct protoent ** __restrict __result ) ;
extern int getprotobynumber_r(int __proto , struct protoent * __restrict __result_buf ,
                              char * __restrict __buf , size_t __buflen , struct protoent ** __restrict __result ) ;
extern int setnetgrent(char const *__netgroup ) ;
extern void endnetgrent(void) ;
extern int getnetgrent(char ** __restrict __hostp , char ** __restrict __userp ,
                       char ** __restrict __domainp ) ;
extern int innetgr(char const *__netgroup , char const *__host , char const *__user ,
                   char const *__domain ) ;
extern int getnetgrent_r(char ** __restrict __hostp , char ** __restrict __userp ,
                         char ** __restrict __domainp , char * __restrict __buffer ,
                         size_t __buflen ) ;
extern int rcmd(char ** __restrict __ahost , unsigned short __rport , char const * __restrict __locuser ,
                char const * __restrict __remuser , char const * __restrict __cmd ,
                int * __restrict __fd2p ) ;
extern int rcmd_af(char ** __restrict __ahost , unsigned short __rport , char const * __restrict __locuser ,
                   char const * __restrict __remuser , char const * __restrict __cmd ,
                   int * __restrict __fd2p , sa_family_t __af ) ;
extern int rexec(char ** __restrict __ahost , int __rport , char const * __restrict __name ,
                 char const * __restrict __pass , char const * __restrict __cmd ,
                 int * __restrict __fd2p ) ;
extern int rexec_af(char ** __restrict __ahost , int __rport , char const * __restrict __name ,
                    char const * __restrict __pass , char const * __restrict __cmd ,
                    int * __restrict __fd2p , sa_family_t __af ) ;
extern int ruserok(char const *__rhost , int __suser , char const *__remuser ,
                   char const *__locuser ) ;
extern int ruserok_af(char const *__rhost , int __suser , char const *__remuser ,
                      char const *__locuser , sa_family_t __af ) ;
extern int iruserok(uint32_t __raddr , int __suser , char const *__remuser , char const *__locuser ) ;
extern int iruserok_af(void const *__raddr , int __suser , char const *__remuser ,
                       char const *__locuser , sa_family_t __af ) ;
extern int rresvport(int *__alport ) ;
extern int rresvport_af(int *__alport , sa_family_t __af ) ;
extern int getaddrinfo(char const * __restrict __name , char const * __restrict __service ,
                       struct addrinfo const * __restrict __req , struct addrinfo ** __restrict __pai ) ;
extern void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) __attribute__((__nothrow__)) ;
extern char const *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) __attribute__((__nothrow__)) ;
extern int getnameinfo(struct sockaddr const * __restrict __sa , socklen_t __salen ,
                       char * __restrict __host , socklen_t __hostlen , char * __restrict __serv ,
                       socklen_t __servlen , int __flags ) ;
extern int getaddrinfo_a(int __mode , struct gaicb ** __restrict __list , int __ent ,
                         struct sigevent * __restrict __sig ) ;
extern int gai_suspend(struct gaicb const **__list , int __ent , struct timespec const *__timeout ) ;
extern int ( __attribute__((__leaf__)) gai_error)(struct gaicb *__req ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) gai_cancel)(struct gaicb *__gaicbp ) __attribute__((__nothrow__)) ;
extern struct _ns_flagdata const _ns_flagdata[] ;
extern int ( __attribute__((__leaf__)) ns_msg_getflag)(ns_msg , int ) __attribute__((__nothrow__)) ;
extern unsigned int ( __attribute__((__leaf__)) ns_get16)(unsigned char const * ) __attribute__((__nothrow__)) ;
extern unsigned long ( __attribute__((__leaf__)) ns_get32)(unsigned char const * ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) ns_put16)(unsigned int , unsigned char * ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) ns_put32)(unsigned long , unsigned char * ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ns_initparse)(unsigned char const * , int ,
                                                     ns_msg * ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ns_skiprr)(unsigned char const * , unsigned char const * ,
                                                  ns_sect , int ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ns_parserr)(ns_msg * , ns_sect , int , ns_rr * ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ns_sprintrr)(ns_msg const * , ns_rr const * ,
                                                    char const * , char const * ,
                                                    char * , size_t ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__leaf__)) ns_sprintrrf)(unsigned char const * , size_t ,
                                                     char const * , ns_class ,
                                                     ns_type , unsigned long , unsigned char const * ,
                                                     size_t , char const * , char const * ,
                                                     char * , size_t ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__leaf__)) ns_format_ttl)(unsigned long , char * , size_t ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__leaf__)) ns_parse_ttl)(char const * , unsigned long * ) __attribute__((__nothrow__,
__deprecated__)) ;
extern uint32_t ( __attribute__((__leaf__)) ns_datetosecs)(char const * , int * ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__leaf__)) ns_name_ntol)(unsigned char const * , unsigned char * ,
                                                     size_t ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ns_name_ntop)(unsigned char const * , char * ,
                                                     size_t ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ns_name_pton)(char const * , unsigned char * ,
                                                     size_t ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ns_name_unpack)(unsigned char const * , unsigned char const * ,
                                                       unsigned char const * , unsigned char * ,
                                                       size_t ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ns_name_pack)(unsigned char const * , unsigned char * ,
                                                     int , unsigned char const ** ,
                                                     unsigned char const ** ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ns_name_uncompress)(unsigned char const * ,
                                                           unsigned char const * ,
                                                           unsigned char const * ,
                                                           char * , size_t ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ns_name_compress)(char const * , unsigned char * ,
                                                         size_t , unsigned char const ** ,
                                                         unsigned char const ** ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ns_name_skip)(unsigned char const ** , unsigned char const * ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) ns_name_rollback)(unsigned char const * ,
                                                          unsigned char const ** ,
                                                          unsigned char const ** ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) ns_samedomain)(char const * , char const * ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__leaf__)) ns_subdomain)(char const * , char const * ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__leaf__)) ns_makecanon)(char const * , char * , size_t ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__leaf__)) ns_samename)(char const * , char const * ) __attribute__((__nothrow__,
__deprecated__)) ;
extern struct __res_state *__res_state(void) __attribute__((__const__)) ;
extern void ( __attribute__((__leaf__)) __fp_nquery)(unsigned char const * , int ,
                                                     FILE * ) __attribute__((__nothrow__,
__deprecated__)) ;
extern void ( __attribute__((__leaf__)) __fp_query)(unsigned char const * , FILE * ) __attribute__((__nothrow__,
__deprecated__)) ;
extern char const *( __attribute__((__leaf__)) __hostalias)(char const * ) __attribute__((__nothrow__,
__deprecated__("use getaddrinfo instead"))) ;
extern void ( __attribute__((__leaf__)) __p_query)(unsigned char const * ) __attribute__((__nothrow__,
__deprecated__)) ;
extern void ( __attribute__((__leaf__)) __res_close)(void) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __res_init)(void) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __res_isourserver)(struct sockaddr_in const * ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__leaf__)) res_mkquery)(int , char const * , int ,
                                                    int , unsigned char const * ,
                                                    int , unsigned char const * ,
                                                    unsigned char * , int ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) res_query)(char const * , int , int , unsigned char * ,
                                                  int ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) res_querydomain)(char const * , char const * ,
                                                        int , int , unsigned char * ,
                                                        int ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) res_search)(char const * , int , int ,
                                                   unsigned char * , int ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) res_send)(unsigned char const * , int ,
                                                 unsigned char * , int ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) res_hnok)(char const * ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) res_ownok)(char const * ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) res_mailok)(char const * ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) res_dnok)(char const * ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __sym_ston)(struct res_sym const * , char const * ,
                                                   int * ) __attribute__((__nothrow__,
__deprecated__)) ;
extern char const *( __attribute__((__leaf__)) __sym_ntos)(struct res_sym const * ,
                                                             int , int * ) __attribute__((__nothrow__,
__deprecated__)) ;
extern char const *( __attribute__((__leaf__)) __sym_ntop)(struct res_sym const * ,
                                                             int , int * ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__leaf__)) __b64_ntop)(unsigned char const * , size_t ,
                                                   char * , size_t ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __b64_pton)(char const * , unsigned char * ,
                                                   size_t ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) __loc_aton)(char const *__ascii , unsigned char *__binary ) __attribute__((__nothrow__,
__deprecated__)) ;
extern char const *( __attribute__((__leaf__)) __loc_ntoa)(unsigned char const *__binary ,
                                                             char *__ascii ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__leaf__)) dn_skipname)(unsigned char const * , unsigned char const * ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) __putlong)(uint32_t , unsigned char * ) __attribute__((__nothrow__,
__deprecated__("use NS_PUT16 instead"))) ;
extern void ( __attribute__((__leaf__)) __putshort)(uint16_t , unsigned char * ) __attribute__((__nothrow__,
__deprecated__("use NS_PUT32 instead"))) ;
extern char const *( __attribute__((__leaf__)) __p_class)(int ) __attribute__((__nothrow__,
__deprecated__)) ;
extern char const *( __attribute__((__leaf__)) __p_time)(uint32_t ) __attribute__((__nothrow__,
__deprecated__)) ;
extern char const *( __attribute__((__leaf__)) __p_type)(int ) __attribute__((__nothrow__,
__deprecated__)) ;
extern char const *( __attribute__((__leaf__)) __p_rcode)(int ) __attribute__((__nothrow__,
__deprecated__)) ;
extern unsigned char const *( __attribute__((__leaf__)) __p_cdnname)(unsigned char const * ,
                                                                       unsigned char const * ,
                                                                       int , FILE * ) __attribute__((__nothrow__,
__deprecated__)) ;
extern unsigned char const *( __attribute__((__leaf__)) __p_cdname)(unsigned char const * ,
                                                                      unsigned char const * ,
                                                                      FILE * ) __attribute__((__nothrow__,
__deprecated__)) ;
extern unsigned char const *( __attribute__((__leaf__)) __p_fqnname)(unsigned char const *__cp ,
                                                                       unsigned char const *__msg ,
                                                                       int , char * ,
                                                                       int ) __attribute__((__nothrow__,
__deprecated__)) ;
extern unsigned char const *( __attribute__((__leaf__)) __p_fqname)(unsigned char const * ,
                                                                      unsigned char const * ,
                                                                      FILE * ) __attribute__((__nothrow__,
__deprecated__)) ;
extern char const *( __attribute__((__leaf__)) __p_option)(unsigned long __option ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__leaf__)) __dn_count_labels)(char const * ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__leaf__)) dn_comp)(char const * , unsigned char * ,
                                                int , unsigned char ** , unsigned char ** ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) dn_expand)(unsigned char const * , unsigned char const * ,
                                                  unsigned char const * , char * ,
                                                  int ) __attribute__((__nothrow__)) ;
extern unsigned int ( __attribute__((__leaf__)) __res_randomid)(void) __attribute__((__nothrow__,
__deprecated__("use getentropy instead"))) ;
extern int ( __attribute__((__leaf__)) __res_nameinquery)(char const * , int ,
                                                          int , unsigned char const * ,
                                                          unsigned char const * ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__leaf__)) __res_queriesmatch)(unsigned char const * ,
                                                           unsigned char const * ,
                                                           unsigned char const * ,
                                                           unsigned char const * ) __attribute__((__nothrow__,
__deprecated__)) ;
extern int ( __attribute__((__leaf__)) __res_ninit)(res_state ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) __fp_resstat)(res_state const , FILE * ) __attribute__((__nothrow__,
__deprecated__)) ;
extern char const *( __attribute__((__leaf__)) __res_hostalias)(res_state const ,
                                                                  char const * ,
                                                                  char * , size_t ) __attribute__((__nothrow__,
__deprecated__("use getaddrinfo instead"))) ;
extern int ( __attribute__((__leaf__)) res_nquery)(res_state , char const * , int ,
                                                   int , unsigned char * , int ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) res_nsearch)(res_state , char const * ,
                                                    int , int , unsigned char * ,
                                                    int ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) res_nquerydomain)(res_state , char const * ,
                                                         char const * , int , int ,
                                                         unsigned char * , int ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) res_nmkquery)(res_state , int , char const * ,
                                                     int , int , unsigned char const * ,
                                                     int , unsigned char const * ,
                                                     unsigned char * , int ) __attribute__((__nothrow__)) ;
extern int ( __attribute__((__leaf__)) res_nsend)(res_state , unsigned char const * ,
                                                  int , unsigned char * , int ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) __res_nclose)(res_state ) __attribute__((__nothrow__)) ;
static int address_family = 0;
void DNS_SetAddressFamily(int family )
{
  {
  address_family = family;
  return;
}
}
DNS_Status DNS_Name2IPAddress(char const *name , IPAddr *ip_addrs , int max_addrs )
{
  struct addrinfo hints ;
  struct addrinfo *res ;
  struct addrinfo *ai ;
  int i ;
  int result ;
  IPAddr ip ;
  int tmp ;
  int tmp___0 ;
  {
  if (max_addrs < 16) {
    max_addrs = max_addrs;
  } else {
    max_addrs = 16;
  }
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < max_addrs)) {
      goto while_break;
    }
    (ip_addrs + i)->family = (uint16_t )0;
    i ++;
  }
  while_break: ;
  }
  tmp = UTI_StringToIP(name, & ip);
  if (tmp) {
    if (address_family != 0) {
      if ((int )ip.family != address_family) {
        return ((DNS_Status )2);
      }
    }
    if (max_addrs >= 1) {
      *(ip_addrs + 0) = ip;
    }
    return ((DNS_Status )0);
  }
  memset((void *)(& hints), 0, sizeof(hints));
  {
  if (address_family == 1) {
    goto case_1;
  }
  if (address_family == 2) {
    goto case_2;
  }
  goto switch_default;
  case_1:
  hints.ai_family = 2;
  goto switch_break;
  case_2:
  hints.ai_family = 10;
  goto switch_break;
  switch_default:
  hints.ai_family = 0;
  switch_break: ;
  }
  hints.ai_socktype = 2;
  result = getaddrinfo((char const * __restrict )name, (char const * __restrict )((void *)0),
                       (struct addrinfo const * __restrict )(& hints), (struct addrinfo ** __restrict )(& res));
  if (result) {
    return ((DNS_Status )1);
  }
  ai = res;
  i = 0;
  {
  while (1) {
    while_continue___0: ;
    if (i < max_addrs) {
      if (! ((unsigned long )ai != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
    {
    if (ai->ai_family == 2) {
      goto case_2___0;
    }
    if (ai->ai_family == 10) {
      goto case_10;
    }
    goto switch_break___0;
    case_2___0:
    if (address_family != 0) {
      if (address_family != 1) {
        goto __Cont;
      }
    }
    (ip_addrs + i)->family = (uint16_t )1;
    (ip_addrs + i)->addr.in4 = __bswap_32(((struct sockaddr_in *)ai->ai_addr)->sin_addr.s_addr);
    i ++;
    goto switch_break___0;
    case_10:
    if (address_family != 0) {
      if (address_family != 2) {
        goto __Cont;
      }
    }
    if (((struct sockaddr_in6 *)ai->ai_addr)->sin6_scope_id != 0U) {
      goto __Cont;
    }
    (ip_addrs + i)->family = (uint16_t )2;
    memcpy((void *)(& (ip_addrs + i)->addr.in6), (void const *)(& ((struct sockaddr_in6 *)ai->ai_addr)->sin6_addr.__in6_u.__u6_addr8),
           sizeof(ip_addrs->addr.in6));
    i ++;
    goto switch_break___0;
    switch_break___0: ;
    }
    __Cont:
    ai = ai->ai_next;
  }
  while_break___0: ;
  }
  freeaddrinfo(res);
  if (! max_addrs) {
    tmp___0 = 0;
  } else
  if ((int )(ip_addrs + 0)->family != 0) {
    tmp___0 = 0;
  } else {
    tmp___0 = 2;
  }
  return ((DNS_Status )tmp___0);
}
}
int DNS_IPAddress2Name(IPAddr *ip_addr , char *name , int len )
{
  char *result ;
  struct sockaddr_in6 saddr ;
  IPSockAddr ip_saddr ;
  socklen_t slen ;
  char hbuf[1025] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  result = (char *)((void *)0);
  ip_saddr.ip_addr = *ip_addr;
  ip_saddr.port = (uint16_t )0;
  tmp = SCK_IPSockAddrToSockaddr(& ip_saddr, (struct sockaddr *)(& saddr), (int )sizeof(saddr));
  slen = (socklen_t )tmp;
  tmp___0 = getnameinfo((struct sockaddr const * __restrict )((struct sockaddr *)(& saddr)),
                        slen, (char * __restrict )(hbuf), (socklen_t )sizeof(hbuf),
                        (char * __restrict )((void *)0), (socklen_t )0, 0);
  if (! tmp___0) {
    result = hbuf;
  }
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    result = UTI_IPToString((IPAddr const *)ip_addr);
  }
  tmp___1 = snprintf(name, (size_t )len, (char const *)"%s", result);
  if (tmp___1 >= len) {
    return (0);
  }
  return (1);
}
}
void DNS_Reload(void)
{
  {
  __res_init();
  return;
}
}
RefclockDriver RCL_SHM_driver ;
RefclockDriver RCL_SOCK_driver ;
RefclockDriver RCL_PPS_driver ;
RefclockDriver RCL_PHC_driver ;
static ARR_Instance refclocks ;
static LOG_FileID logfileid___3 ;
static int valid_sample_time(RCL_Instance instance , struct timespec *sample_time ) ;
static int pps_stratum(RCL_Instance instance , struct timespec *ts ) ;
static void poll_timeout(void *arg ) ;
static void slew_samples___0(struct timespec *raw , struct timespec *cooked , double dfreq ,
                             double doffset , LCL_ChangeType change_type , void *anything ) ;
static void add_dispersion___0(double dispersion , void *anything ) ;
static void log_sample(RCL_Instance instance , struct timespec *sample_time , int filtered ,
                       int pulse , double raw_offset , double cooked_offset , double dispersion ) ;
static RCL_Instance get_refclock(unsigned int index___0 )
{
  void *tmp ;
  {
  tmp = ARR_GetElement(refclocks, index___0);
  return (*((RCL_Instance *)tmp));
}
}
void RCL_Initialise(void)
{
  unsigned int tmp ;
  int tmp___0 ;
  LOG_FileID tmp___1 ;
  int tmp___2 ;
  {
  refclocks = ARR_CreateInstance((unsigned int )sizeof(RCL_Instance ));
  CNF_AddRefclocks();
  tmp = ARR_GetSize(refclocks);
  if (tmp > 0U) {
    LCL_AddParameterChangeHandler(& slew_samples___0, (void *)0);
    LCL_AddDispersionNotifyHandler(& add_dispersion___0, (void *)0);
  }
  tmp___2 = CNF_GetLogRefclocks();
  if (tmp___2) {
    tmp___1 = LOG_FileOpen((char const *)"refclocks", (char const *)"   Date (UTC) Time         Refid  DP L P  Raw offset   Cooked offset      Disp.");
    logfileid___3 = tmp___1;
  } else {
    logfileid___3 = -1;
  }
  return;
}
}
void RCL_Finalise(void)
{
  unsigned int i ;
  RCL_Instance inst ;
  RCL_Instance tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  {
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp___0 = ARR_GetSize(refclocks);
    if (! (i < tmp___0)) {
      goto while_break;
    }
    tmp = get_refclock(i);
    inst = tmp;
    if ((inst->driver)->fini) {
      (*((inst->driver)->fini))(inst);
    }
    SPF_DestroyInstance(inst->filter);
    free((void *)inst->driver_parameter);
    SRC_DestroyInstance(inst->source);
    free((void *)inst);
    i ++;
  }
  while_break: ;
  }
  tmp___1 = ARR_GetSize(refclocks);
  if (tmp___1 > 0U) {
    LCL_RemoveParameterChangeHandler(& slew_samples___0, (void *)0);
    LCL_RemoveDispersionNotifyHandler(& add_dispersion___0, (void *)0);
  }
  ARR_DestroyInstance(refclocks);
  return;
}
}
int RCL_AddRefclock(RefclockParameters *params )
{
  RCL_Instance inst ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int i ;
  size_t tmp___6 ;
  unsigned char ref[5] ;
  unsigned int index___0 ;
  unsigned int tmp___7 ;
  int max_samples___0 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  {
  tmp = Malloc(sizeof(struct RCL_Instance_Record ));
  inst = (struct RCL_Instance_Record *)tmp;
  tmp___0 = ARR_GetNewElement(refclocks);
  *((RCL_Instance *)tmp___0) = inst;
  tmp___4 = strcmp((char const *)params->driver_name, (char const *)"SHM");
  if (tmp___4 == 0) {
    inst->driver = & RCL_SHM_driver;
  } else {
    tmp___3 = strcmp((char const *)params->driver_name, (char const *)"SOCK");
    if (tmp___3 == 0) {
      inst->driver = & RCL_SOCK_driver;
    } else {
      tmp___2 = strcmp((char const *)params->driver_name, (char const *)"PPS");
      if (tmp___2 == 0) {
        inst->driver = & RCL_PPS_driver;
      } else {
        tmp___1 = strcmp((char const *)params->driver_name, (char const *)"PHC");
        if (tmp___1 == 0) {
          inst->driver = & RCL_PHC_driver;
        } else {
          {
          while (1) {
            while_continue: ;
            LOG_Message((LOG_Severity )3, (char const *)"unknown refclock driver %s",
                        params->driver_name);
            exit(1);
            goto while_break;
          }
          while_break: ;
          }
        }
      }
    }
  }
  if (! (inst->driver)->init) {
    if (! (inst->driver)->poll) {
      {
      while (1) {
        while_continue___0: ;
        LOG_Message((LOG_Severity )3, (char const *)"refclock driver %s is not compiled in",
                    params->driver_name);
        exit(1);
        goto while_break___0;
      }
      while_break___0: ;
      }
    }
  }
  if (params->tai) {
    tmp___5 = CNF_GetLeapSecTimezone();
    if (! tmp___5) {
      {
      while (1) {
        while_continue___1: ;
        LOG_Message((LOG_Severity )3, (char const *)"refclock tai option requires leapsectz");
        exit(1);
        goto while_break___1;
      }
      while_break___1: ;
      }
    }
  }
  inst->data = (void *)0;
  inst->driver_parameter = Strdup((char const *)params->driver_parameter);
  inst->driver_parameter_length = 0;
  inst->driver_poll = params->driver_poll;
  inst->poll = params->poll;
  inst->driver_polled = 0;
  inst->leap_status = 0;
  inst->pps_forced = params->pps_forced;
  inst->pps_rate = params->pps_rate;
  inst->pps_active = 0;
  inst->max_lock_age = params->max_lock_age;
  inst->stratum = params->stratum;
  inst->tai = params->tai;
  inst->lock_ref = params->lock_ref_id;
  inst->offset = params->offset;
  inst->delay = params->delay;
  inst->precision = LCL_GetSysPrecisionAsQuantum();
  if (inst->precision > params->precision) {
    inst->precision = inst->precision;
  } else {
    inst->precision = params->precision;
  }
  inst->pulse_width = params->pulse_width;
  inst->timeout_id = (SCH_TimeoutID )-1;
  inst->source = (SRC_Instance )((void *)0);
  if (inst->driver_parameter) {
    tmp___6 = strlen((char const *)inst->driver_parameter);
    inst->driver_parameter_length = (int )tmp___6;
    i = 0;
    {
    while (1) {
      while_continue___2: ;
      if (! (i < inst->driver_parameter_length)) {
        goto while_break___2;
      }
      if ((int )*(inst->driver_parameter + i) == 58) {
        *(inst->driver_parameter + i) = (char )'\000';
      }
      i ++;
    }
    while_break___2: ;
    }
  }
  if (inst->pps_rate < 1) {
    inst->pps_rate = 1;
  }
  if (params->ref_id) {
    inst->ref_id = params->ref_id;
  } else {
    ref[0] = (unsigned char)0;
    ref[1] = (unsigned char)0;
    ref[2] = (unsigned char)0;
    ref[3] = (unsigned char)0;
    ref[4] = (unsigned char)0;
    tmp___7 = ARR_GetSize(refclocks);
    index___0 = tmp___7 - 1U;
    snprintf((char *)(ref), sizeof(ref), (char const *)"%3.3s", params->driver_name);
    ref[3] = (unsigned char )(index___0 % 10U + 48U);
    if (index___0 >= 10U) {
      ref[2] = (unsigned char )((index___0 / 10U) % 10U + 48U);
    }
    inst->ref_id = ((((uint32_t )ref[0] << 24) | (unsigned int )((int )ref[1] << 16)) | (unsigned int )((int )ref[2] << 8)) | (unsigned int )ref[3];
  }
  if ((inst->driver)->poll) {
    if (inst->driver_poll > inst->poll) {
      inst->driver_poll = inst->poll;
    }
    max_samples___0 = 1 << (inst->poll - inst->driver_poll);
    if (max_samples___0 < params->filter_length) {
      if (max_samples___0 < 4) {
        tmp___8 = UTI_RefidToString(inst->ref_id);
        LOG_Message((LOG_Severity )1, (char const *)"Setting filter length for %s to %d",
                    tmp___8, max_samples___0);
      }
      params->filter_length = max_samples___0;
    }
  }
  if ((inst->driver)->init) {
    tmp___9 = (*((inst->driver)->init))(inst);
    if (! tmp___9) {
      {
      while (1) {
        while_continue___3: ;
        LOG_Message((LOG_Severity )3, (char const *)"refclock %s initialisation failed",
                    params->driver_name);
        exit(1);
        goto while_break___3;
      }
      while_break___3: ;
      }
    }
  }
  if (params->filter_length < 4) {
    tmp___10 = params->filter_length;
  } else {
    tmp___10 = 4;
  }
  inst->filter = SPF_CreateInstance(tmp___10, params->filter_length, params->max_dispersion,
                                    0.6);
  inst->source = SRC_CreateNewInstance(inst->ref_id, (SRC_Type )1, 0, params->sel_options,
                                       (IPAddr *)((void *)0), params->min_samples,
                                       params->max_samples, 0.0, 0.0);
  {
  while (1) {
    while_continue___4: ;
    goto while_break___4;
  }
  while_break___4: ;
  }
  return (1);
}
}
void RCL_StartRefclocks(void)
{
  unsigned int i ;
  unsigned int j ;
  unsigned int n ;
  unsigned int lock_index ;
  RCL_Instance inst ;
  RCL_Instance tmp ;
  RCL_Instance inst2 ;
  RCL_Instance tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  double tmp___3 ;
  char *tmp___4 ;
  {
  n = ARR_GetSize(refclocks);
  i = 0U;
  {
  while (1) {
    while_continue: ;
    if (! (i < n)) {
      goto while_break;
    }
    tmp = get_refclock(i);
    inst = tmp;
    SRC_SetActive(inst->source);
    inst->timeout_id = SCH_AddTimeoutByDelay(0.0, & poll_timeout, (void *)inst);
    lock_index = 4294967295U;
    if (inst->lock_ref != 0U) {
      j = 0U;
      {
      while (1) {
        while_continue___0: ;
        if (! (j < n)) {
          goto while_break___0;
        }
        tmp___0 = get_refclock(j);
        inst2 = tmp___0;
        if (inst->lock_ref != inst2->ref_id) {
          goto __Cont;
        }
        if ((inst->driver)->poll) {
          if ((inst2->driver)->poll) {
            tmp___3 = UTI_Log2ToDouble(inst2->driver_poll);
            if ((double )inst->max_lock_age / (double )inst->pps_rate < tmp___3) {
              tmp___1 = UTI_RefidToString(inst2->ref_id);
              tmp___2 = UTI_RefidToString(inst->ref_id);
              LOG_Message((LOG_Severity )1, (char const *)"%s maxlockage too small for %s",
                          tmp___2, tmp___1);
            }
          }
        }
        lock_index = j;
        goto while_break___0;
        __Cont:
        j ++;
      }
      while_break___0: ;
      }
      if (lock_index == 4294967295U) {
        tmp___4 = UTI_RefidToString(inst->lock_ref);
        LOG_Message((LOG_Severity )1, (char const *)"Invalid lock refid %s", tmp___4);
      } else
      if (lock_index == i) {
        tmp___4 = UTI_RefidToString(inst->lock_ref);
        LOG_Message((LOG_Severity )1, (char const *)"Invalid lock refid %s", tmp___4);
      }
    }
    inst->lock_ref = lock_index;
    i ++;
  }
  while_break: ;
  }
  return;
}
}
void RCL_ReportSource(RPT_SourceReport *report , struct timespec *now )
{
  unsigned int i ;
  uint32_t ref_id ;
  RCL_Instance inst ;
  RCL_Instance tmp ;
  unsigned int tmp___0 ;
  {
  assert((int )report->ip_addr.family == 1);
  ref_id = report->ip_addr.addr.in4;
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp___0 = ARR_GetSize(refclocks);
    if (! (i < tmp___0)) {
      goto while_break;
    }
    tmp = get_refclock(i);
    inst = tmp;
    if (inst->ref_id == ref_id) {
      report->poll = inst->poll;
      report->mode = (enum __anonenum_mode_14858290 )2;
      goto while_break;
    }
    i ++;
  }
  while_break: ;
  }
  return;
}
}
void RCL_SetDriverData(RCL_Instance instance , void *data )
{
  {
  instance->data = data;
  return;
}
}
void *RCL_GetDriverData(RCL_Instance instance )
{
  {
  return (instance->data);
}
}
char *RCL_GetDriverParameter(RCL_Instance instance )
{
  {
  return (instance->driver_parameter);
}
}
static char *get_next_driver_option(RCL_Instance instance , char *option )
{
  size_t tmp ;
  {
  if ((unsigned long )option == (unsigned long )((void *)0)) {
    option = instance->driver_parameter;
  }
  tmp = strlen((char const *)option);
  option += tmp + 1UL;
  if ((unsigned long )option >= (unsigned long )(instance->driver_parameter + instance->driver_parameter_length)) {
    return ((char *)((void *)0));
  }
  return (option);
}
}
void RCL_CheckDriverOptions(RCL_Instance instance , char const **options )
{
  char *option ;
  int i ;
  int len ;
  size_t tmp ;
  int tmp___0 ;
  {
  option = get_next_driver_option(instance, (char *)((void *)0));
  {
  while (1) {
    while_continue: ;
    if (! option) {
      goto while_break;
    }
    i = 0;
    {
    while (1) {
      while_continue___0: ;
      if (options) {
        if (! *(options + i)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      tmp = strlen(*(options + i));
      len = (int )tmp;
      tmp___0 = strncmp(*(options + i), (char const *)option, (size_t )len);
      if (! tmp___0) {
        if ((int )*(option + len) == 61) {
          goto while_break___0;
        } else
        if ((int )*(option + len) == 0) {
          goto while_break___0;
        }
      }
      i ++;
    }
    while_break___0: ;
    }
    if (! options) {
      goto _L;
    } else
    if (! *(options + i)) {
      _L:
      {
      while (1) {
        while_continue___1: ;
        LOG_Message((LOG_Severity )3, (char const *)"Invalid refclock driver option %s",
                    option);
        exit(1);
        goto while_break___1;
      }
      while_break___1: ;
      }
    }
    option = get_next_driver_option(instance, option);
  }
  while_break: ;
  }
  return;
}
}
char *RCL_GetDriverOption(RCL_Instance instance , char *name )
{
  char *option ;
  int len ;
  size_t tmp ;
  int tmp___0 ;
  {
  tmp = strlen((char const *)name);
  len = (int )tmp;
  option = get_next_driver_option(instance, (char *)((void *)0));
  {
  while (1) {
    while_continue: ;
    if (! option) {
      goto while_break;
    }
    tmp___0 = strncmp((char const *)name, (char const *)option, (size_t )len);
    if (! tmp___0) {
      if ((int )*(option + len) == 61) {
        return ((option + len) + 1);
      }
      if ((int )*(option + len) == 0) {
        return (option + len);
      }
    }
    option = get_next_driver_option(instance, option);
  }
  while_break: ;
  }
  return ((char *)((void *)0));
}
}
static int convert_tai_offset(struct timespec *sample_time , double *offset )
{
  struct timespec tai_ts ;
  struct timespec utc_ts ;
  int tai_offset ;
  {
  UTI_AddDoubleToTimespec((struct timespec const *)sample_time, *offset, & tai_ts);
  tai_offset = REF_GetTaiOffset(& tai_ts);
  UTI_AddDoubleToTimespec((struct timespec const *)(& tai_ts), (double )(- tai_offset),
                          & utc_ts);
  tai_offset = REF_GetTaiOffset(& utc_ts);
  if (! tai_offset) {
    return (0);
  }
  *offset -= (double )tai_offset;
  return (1);
}
}
static int accumulate_sample(RCL_Instance instance , struct timespec *sample_time ,
                             double offset , double dispersion )
{
  NTP_Sample sample ;
  int tmp ;
  {
  sample.time = *sample_time;
  sample.offset = offset;
  sample.peer_delay = instance->delay;
  sample.root_delay = instance->delay;
  sample.peer_dispersion = dispersion;
  sample.root_dispersion = dispersion;
  tmp = SPF_AccumulateSample(instance->filter, & sample);
  return (tmp);
}
}
int RCL_AddSample(RCL_Instance instance , struct timespec *sample_time , double offset ,
                  int leap )
{
  double correction ;
  double dispersion ;
  struct timespec cooked_time ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  {
  if (instance->pps_forced) {
    tmp = RCL_AddPulse(instance, sample_time, - offset);
    return (tmp);
  }
  LCL_GetOffsetCorrection(sample_time, & correction, & dispersion);
  UTI_AddDoubleToTimespec((struct timespec const *)sample_time, correction, & cooked_time);
  dispersion += instance->precision;
  tmp___0 = UTI_IsTimeOffsetSane((struct timespec const *)sample_time, offset);
  if (tmp___0) {
    tmp___1 = valid_sample_time(instance, & cooked_time);
    if (! tmp___1) {
      return (0);
    }
  } else {
    return (0);
  }
  {
  if (leap == 2) {
    goto case_2;
  }
  if (leap == 1) {
    goto case_2;
  }
  if (leap == 0) {
    goto case_2;
  }
  goto switch_default;
  case_2:
  case_1:
  case_0:
  instance->leap_status = leap;
  goto switch_break;
  switch_default:
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  return (0);
  switch_break: ;
  }
  if (instance->tai) {
    tmp___2 = convert_tai_offset(sample_time, & offset);
    if (! tmp___2) {
      {
      while (1) {
        while_continue___0: ;
        goto while_break___0;
      }
      while_break___0: ;
      }
      return (0);
    }
  }
  tmp___3 = accumulate_sample(instance, & cooked_time, (offset - correction) + instance->offset,
                              dispersion);
  if (! tmp___3) {
    return (0);
  }
  instance->pps_active = 0;
  log_sample(instance, & cooked_time, 0, 0, offset, (offset - correction) + instance->offset,
             dispersion);
  if (! (instance->driver)->poll) {
    (instance->driver_polled) ++;
  }
  return (1);
}
}
int RCL_AddPulse(RCL_Instance instance , struct timespec *pulse_time , double second )
{
  double correction ;
  double dispersion ;
  struct timespec cooked_time ;
  int tmp ;
  int tmp___0 ;
  {
  LCL_GetOffsetCorrection(pulse_time, & correction, & dispersion);
  UTI_AddDoubleToTimespec((struct timespec const *)pulse_time, correction, & cooked_time);
  second += correction;
  tmp = UTI_IsTimeOffsetSane((struct timespec const *)pulse_time, 0.0);
  if (! tmp) {
    return (0);
  }
  tmp___0 = RCL_AddCookedPulse(instance, & cooked_time, second, dispersion, correction);
  return (tmp___0);
}
}
static int check_pulse_edge(RCL_Instance instance , double offset , double distance )
{
  double max_error ;
  double tmp ;
  {
  if (instance->pulse_width <= 0.0) {
    return (1);
  }
  max_error = 1.0 / (double )instance->pps_rate - instance->pulse_width;
  if (instance->pulse_width < max_error) {
    max_error = instance->pulse_width;
  } else {
    max_error = max_error;
  }
  max_error *= 0.5;
  tmp = fabs(offset);
  if (tmp > max_error) {
    goto _L;
  } else
  if (distance > max_error) {
    _L:
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  return (1);
}
}
int RCL_AddCookedPulse(RCL_Instance instance , struct timespec *cooked_time , double second ,
                       double dispersion , double raw_correction )
{
  double offset ;
  int rate ;
  NTP_Leap leap ;
  int tmp ;
  int tmp___0 ;
  RCL_Instance lock_refclock ;
  NTP_Sample ref_sample ;
  double sample_diff ;
  double shift ;
  int tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  int tmp___6 ;
  struct timespec ref_time ;
  int is_synchronised ;
  int stratum ;
  double root_delay ;
  double root_dispersion ;
  double distance ;
  uint32_t ref_id ;
  double tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  {
  tmp = UTI_IsTimeOffsetSane((struct timespec const *)cooked_time, second);
  if (tmp) {
    tmp___0 = valid_sample_time(instance, cooked_time);
    if (! tmp___0) {
      return (0);
    }
  } else {
    return (0);
  }
  leap = (NTP_Leap )0;
  dispersion += instance->precision;
  rate = instance->pps_rate;
  offset = - second + instance->offset;
  offset -= (double )((long )(offset * (double )rate)) / (double )rate;
  if (offset < - 0.5 / (double )rate) {
    offset += 1.0 / (double )rate;
  } else
  if (offset >= 0.5 / (double )rate) {
    offset -= 1.0 / (double )rate;
  }
  if (instance->lock_ref != 4294967295U) {
    lock_refclock = get_refclock(instance->lock_ref);
    tmp___1 = SPF_GetLastSample(lock_refclock->filter, & ref_sample);
    if (! tmp___1) {
      {
      while (1) {
        while_continue: ;
        goto while_break;
      }
      while_break: ;
      }
      return (0);
    }
    tmp___2 = SPF_GetAvgSampleDispersion(lock_refclock->filter);
    ref_sample.root_dispersion += tmp___2;
    sample_diff = UTI_DiffTimespecsToDouble((struct timespec const *)cooked_time,
                                            (struct timespec const *)(& ref_sample.time));
    tmp___3 = fabs(sample_diff);
    if (tmp___3 >= (double )instance->max_lock_age / (double )rate) {
      {
      while (1) {
        while_continue___0: ;
        goto while_break___0;
      }
      while_break___0: ;
      }
      return (0);
    }
    tmp___4 = round((ref_sample.offset - offset) * (double )rate);
    shift = tmp___4 / (double )rate;
    offset += shift;
    tmp___5 = fabs(ref_sample.offset - offset);
    if ((tmp___5 + ref_sample.root_dispersion) + dispersion > 0.4 / (double )rate) {
      {
      while (1) {
        while_continue___1: ;
        goto while_break___1;
      }
      while_break___1: ;
      }
      return (0);
    }
    tmp___6 = check_pulse_edge(instance, ref_sample.offset - offset, 0.0);
    if (! tmp___6) {
      return (0);
    }
    leap = (NTP_Leap )lock_refclock->leap_status;
    {
    while (1) {
      while_continue___2: ;
      goto while_break___2;
    }
    while_break___2: ;
    }
  } else {
    REF_GetReferenceParams(cooked_time, & is_synchronised, & leap, & stratum, & ref_id,
                           & ref_time, & root_delay, & root_dispersion);
    tmp___7 = fabs(root_delay);
    distance = tmp___7 / (double )2 + root_dispersion;
    if ((unsigned int )leap == 3U) {
      goto _L;
    } else
    if (distance >= 0.5 / (double )rate) {
      _L:
      {
      while (1) {
        while_continue___3: ;
        goto while_break___3;
      }
      while_break___3: ;
      }
      SPF_DropSamples(instance->filter);
      return (0);
    }
    tmp___8 = check_pulse_edge(instance, offset, distance);
    if (! tmp___8) {
      return (0);
    }
  }
  tmp___9 = accumulate_sample(instance, cooked_time, offset, dispersion);
  if (! tmp___9) {
    return (0);
  }
  instance->leap_status = (int )leap;
  instance->pps_active = 1;
  log_sample(instance, cooked_time, 0, 1, (offset + raw_correction) - instance->offset,
             offset, dispersion);
  if (! (instance->driver)->poll) {
    (instance->driver_polled) ++;
  }
  return (1);
}
}
double RCL_GetPrecision(RCL_Instance instance )
{
  {
  return (instance->precision);
}
}
int RCL_GetDriverPoll(RCL_Instance instance )
{
  {
  return (instance->driver_poll);
}
}
static int valid_sample_time(RCL_Instance instance , struct timespec *sample_time )
{
  struct timespec now ;
  double diff ;
  char *tmp ;
  char *tmp___0 ;
  double tmp___1 ;
  {
  LCL_ReadCookedTime(& now, (double *)((void *)0));
  diff = UTI_DiffTimespecsToDouble((struct timespec const *)(& now), (struct timespec const *)sample_time);
  if (diff < 0.0) {
    goto _L;
  } else {
    tmp___1 = UTI_Log2ToDouble(instance->poll + 1);
    if (diff > tmp___1) {
      _L:
      {
      while (1) {
        while_continue: ;
        goto while_break;
      }
      while_break: ;
      }
      return (0);
    }
  }
  return (1);
}
}
static int pps_stratum(RCL_Instance instance , struct timespec *ts )
{
  struct timespec ref_time ;
  int is_synchronised ;
  int stratum ;
  unsigned int i ;
  double root_delay ;
  double root_dispersion ;
  NTP_Leap leap ;
  uint32_t ref_id ;
  RCL_Instance refclock ;
  unsigned int tmp ;
  {
  REF_GetReferenceParams(ts, & is_synchronised, & leap, & stratum, & ref_id, & ref_time,
                         & root_delay, & root_dispersion);
  if (ref_id == instance->ref_id) {
    return (stratum - 1);
  } else
  if (! is_synchronised) {
    if ((unsigned int )leap != 3U) {
      return (stratum - 1);
    }
  }
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp = ARR_GetSize(refclocks);
    if (! (i < tmp)) {
      goto while_break;
    }
    refclock = get_refclock(i);
    if (refclock->ref_id == ref_id) {
      if (refclock->pps_active) {
        if (refclock->lock_ref == 4294967295U) {
          return (stratum - 1);
        }
      }
    }
    i ++;
  }
  while_break: ;
  }
  return (0);
}
}
static void poll_timeout(void *arg )
{
  NTP_Sample sample ;
  int poll ;
  int stratum ;
  RCL_Instance inst ;
  int tmp ;
  double tmp___0 ;
  {
  inst = (RCL_Instance )arg;
  poll = inst->poll;
  if ((inst->driver)->poll) {
    poll = inst->driver_poll;
    (*((inst->driver)->poll))(inst);
    (inst->driver_polled) ++;
  }
  if ((inst->driver)->poll) {
    if (! (inst->driver_polled < 1 << (inst->poll - inst->driver_poll))) {
      goto _L;
    }
  } else {
    _L:
    inst->driver_polled = 0;
    tmp = SPF_GetFilteredSample(inst->filter, & sample);
    if (tmp) {
      if (inst->pps_active) {
        if (inst->lock_ref == 4294967295U) {
          stratum = pps_stratum(inst, & sample.time);
        } else {
          stratum = inst->stratum;
        }
      } else {
        stratum = inst->stratum;
      }
      SRC_UpdateReachability(inst->source, 1);
      SRC_UpdateStatus(inst->source, stratum, (NTP_Leap )inst->leap_status);
      SRC_AccumulateSample(inst->source, & sample);
      SRC_SelectSource(inst->source);
      log_sample(inst, & sample.time, 1, 0, 0.0, sample.offset, sample.peer_dispersion);
    } else {
      SRC_UpdateReachability(inst->source, 0);
    }
  }
  tmp___0 = UTI_Log2ToDouble(poll);
  inst->timeout_id = SCH_AddTimeoutByDelay(tmp___0, & poll_timeout, arg);
  return;
}
}
static void slew_samples___0(struct timespec *raw , struct timespec *cooked , double dfreq ,
                             double doffset , LCL_ChangeType change_type , void *anything )
{
  unsigned int i ;
  RCL_Instance tmp ;
  RCL_Instance tmp___0 ;
  unsigned int tmp___1 ;
  {
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp___1 = ARR_GetSize(refclocks);
    if (! (i < tmp___1)) {
      goto while_break;
    }
    if ((unsigned int )change_type == 2U) {
      tmp = get_refclock(i);
      SPF_DropSamples(tmp->filter);
    } else {
      tmp___0 = get_refclock(i);
      SPF_SlewSamples(tmp___0->filter, cooked, dfreq, doffset);
    }
    i ++;
  }
  while_break: ;
  }
  return;
}
}
static void add_dispersion___0(double dispersion , void *anything )
{
  unsigned int i ;
  RCL_Instance tmp ;
  unsigned int tmp___0 ;
  {
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp___0 = ARR_GetSize(refclocks);
    if (! (i < tmp___0)) {
      goto while_break;
    }
    tmp = get_refclock(i);
    SPF_AddDispersion(tmp->filter, dispersion);
    i ++;
  }
  while_break: ;
  }
  return;
}
}
static void log_sample(RCL_Instance instance , struct timespec *sample_time , int filtered ,
                       int pulse , double raw_offset , double cooked_offset , double dispersion )
{
  char sync_stats[4] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  {
  sync_stats[0] = (char )'N';
  sync_stats[1] = (char )'+';
  sync_stats[2] = (char )'-';
  sync_stats[3] = (char )'?';
  if (logfileid___3 == -1) {
    return;
  }
  if (! filtered) {
    tmp = UTI_RefidToString(instance->ref_id);
    tmp___0 = UTI_TimeToLogForm(sample_time->tv_sec);
    LOG_FileWrite(logfileid___3, (char const *)"%s.%06d %-5s %3d %1c %1d %13.6e %13.6e %10.3e",
                  tmp___0, (int )sample_time->tv_nsec / 1000, tmp, instance->driver_polled,
                  (int )sync_stats[instance->leap_status], pulse, raw_offset, cooked_offset,
                  dispersion);
  } else {
    tmp___1 = UTI_RefidToString(instance->ref_id);
    tmp___2 = UTI_TimeToLogForm(sample_time->tv_sec);
    LOG_FileWrite(logfileid___3, (char const *)"%s.%06d %-5s   - %1c -       -       %13.6e %10.3e",
                  tmp___2, (int )sample_time->tv_nsec / 1000, tmp___1, (int )sync_stats[instance->leap_status],
                  cooked_offset, dispersion);
  }
  return;
}
}
HCL_Instance HCL_CreateInstance(int min_samples___0 , int max_samples___0 , double min_separation ) ;
void HCL_DestroyInstance(HCL_Instance clock___0 ) ;
int HCL_NeedsNewSample(HCL_Instance clock___0 , struct timespec *now ) ;
void HCL_AccumulateSample(HCL_Instance clock___0 , struct timespec *hw_ts , struct timespec *local_ts ,
                          double err ) ;
int HCL_CookTime(HCL_Instance clock___0 , struct timespec *raw , struct timespec *cooked ,
                 double *err ) ;
static void read_ext_pulse(int fd___0 , int event , void *anything ) ;
static int phc_initialise(RCL_Instance instance )
{
  char const *options[6] ;
  struct phc_instance *phc ;
  int phc_fd ;
  int rising_edge ;
  char *path ;
  char *s ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  double tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  {
  options[0] = (char const *)"nocrossts";
  options[1] = (char const *)"extpps";
  options[2] = (char const *)"pin";
  options[3] = (char const *)"channel";
  options[4] = (char const *)"clear";
  options[5] = (char const *)((void *)0);
  RCL_CheckDriverOptions(instance, options);
  path = RCL_GetDriverParameter(instance);
  phc_fd = SYS_Linux_OpenPHC((char const *)path, 0);
  if (phc_fd < 0) {
    {
    while (1) {
      while_continue: ;
      LOG_Message((LOG_Severity )3, (char const *)"Could not open PHC");
      exit(1);
      goto while_break;
    }
    while_break: ;
    }
  }
  tmp = Malloc(sizeof(struct phc_instance ));
  phc = (struct phc_instance *)tmp;
  phc->fd = phc_fd;
  phc->mode = 0;
  tmp___1 = RCL_GetDriverOption(instance, "nocrossts");
  if (tmp___1) {
    phc->nocrossts = 1;
  } else {
    phc->nocrossts = 0;
  }
  tmp___3 = RCL_GetDriverOption(instance, "extpps");
  if (tmp___3) {
    phc->extpps = 1;
  } else {
    phc->extpps = 0;
  }
  if (phc->extpps) {
    s = RCL_GetDriverOption(instance, "pin");
    if (s) {
      tmp___4 = atoi((char const *)s);
      phc->pin = tmp___4;
    } else {
      phc->pin = 0;
    }
    s = RCL_GetDriverOption(instance, "channel");
    if (s) {
      tmp___5 = atoi((char const *)s);
      phc->channel = tmp___5;
    } else {
      phc->channel = 0;
    }
    tmp___7 = RCL_GetDriverOption(instance, "clear");
    if (tmp___7) {
      rising_edge = 0;
    } else {
      rising_edge = 1;
    }
    tmp___8 = RCL_GetDriverPoll(instance);
    tmp___9 = UTI_Log2ToDouble(tmp___8);
    phc->clock = HCL_CreateInstance(0, 16, tmp___9);
    tmp___10 = SYS_Linux_SetPHCExtTimestamping(phc->fd, phc->pin, phc->channel, rising_edge,
                                               ! rising_edge, 1);
    if (! tmp___10) {
      {
      while (1) {
        while_continue___0: ;
        LOG_Message((LOG_Severity )3, (char const *)"Could not enable external PHC timestamping");
        exit(1);
        goto while_break___0;
      }
      while_break___0: ;
      }
    }
    SCH_AddFileHandler(phc->fd, 1, & read_ext_pulse, (SCH_ArbitraryArgument )instance);
  } else {
    tmp___11 = 0;
    phc->channel = tmp___11;
    phc->pin = tmp___11;
    phc->clock = (HCL_Instance )((void *)0);
  }
  RCL_SetDriverData(instance, (void *)phc);
  return (1);
}
}
static void phc_finalise(RCL_Instance instance )
{
  struct phc_instance *phc ;
  void *tmp ;
  {
  tmp = RCL_GetDriverData(instance);
  phc = (struct phc_instance *)tmp;
  if (phc->extpps) {
    SCH_RemoveFileHandler(phc->fd);
    SYS_Linux_SetPHCExtTimestamping(phc->fd, phc->pin, phc->channel, 0, 0, 0);
    HCL_DestroyInstance(phc->clock);
  }
  close(phc->fd);
  free((void *)phc);
  return;
}
}
static void read_ext_pulse(int fd___0 , int event , void *anything )
{
  RCL_Instance instance ;
  struct phc_instance *phc ;
  struct timespec phc_ts ;
  struct timespec local_ts ;
  double local_err ;
  int channel ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  {
  instance = (RCL_Instance )anything;
  tmp = RCL_GetDriverData(instance);
  phc = (struct phc_instance *)tmp;
  tmp___0 = SYS_Linux_ReadPHCExtTimestamp(phc->fd, & phc_ts, & channel);
  if (! tmp___0) {
    return;
  }
  if (channel != phc->channel) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return;
  }
  tmp___1 = HCL_CookTime(phc->clock, & phc_ts, & local_ts, & local_err);
  if (! tmp___1) {
    return;
  }
  tmp___2 = UTI_DiffTimespecsToDouble((struct timespec const *)(& phc_ts), (struct timespec const *)(& local_ts));
  RCL_AddCookedPulse(instance, & local_ts, 1.0e-9 * (double )local_ts.tv_nsec, local_err,
                     tmp___2);
  return;
}
}
static int phc_poll(RCL_Instance instance )
{
  struct phc_instance *phc ;
  struct timespec phc_ts ;
  struct timespec sys_ts ;
  struct timespec local_ts ;
  double offset ;
  double phc_err ;
  double local_err ;
  void *tmp ;
  double tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  tmp = RCL_GetDriverData(instance);
  phc = (struct phc_instance *)tmp;
  tmp___0 = RCL_GetPrecision(instance);
  tmp___1 = SYS_Linux_GetPHCSample(phc->fd, phc->nocrossts, tmp___0, & phc->mode,
                                   & phc_ts, & sys_ts, & phc_err);
  if (! tmp___1) {
    return (0);
  }
  if (phc->extpps) {
    LCL_CookTime(& sys_ts, & local_ts, & local_err);
    HCL_AccumulateSample(phc->clock, & phc_ts, & local_ts, phc_err + local_err);
    return (0);
  }
  offset = UTI_DiffTimespecsToDouble((struct timespec const *)(& phc_ts), (struct timespec const *)(& sys_ts));
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  tmp___2 = RCL_AddSample(instance, & sys_ts, offset, 0);
  return (tmp___2);
}
}
RefclockDriver RCL_PHC_driver = {& phc_initialise, & phc_finalise, & phc_poll};
RefclockDriver RCL_PPS_driver = {(int (*)(RCL_Instance instance ))((void *)0), (void (*)(RCL_Instance instance ))((void *)0),
    (int (*)(RCL_Instance instance ))((void *)0)};
static int shm_initialise(RCL_Instance instance )
{
  char const *options[2] ;
  int id ;
  int param ;
  int perm ;
  char *s ;
  struct shmTime *shm ;
  char *tmp ;
  long tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  {
  options[0] = (char const *)"perm";
  options[1] = (char const *)((void *)0);
  RCL_CheckDriverOptions(instance, options);
  tmp = RCL_GetDriverParameter(instance);
  param = atoi((char const *)tmp);
  s = RCL_GetDriverOption(instance, "perm");
  if (s) {
    tmp___0 = strtol((char const * __restrict )s, (char ** __restrict )((void *)0),
                     8);
    perm = (int )(tmp___0 & 511L);
  } else {
    perm = 0600;
  }
  id = shmget(0x4e545030 + param, sizeof(struct shmTime ), 01000 | perm);
  if (id == -1) {
    {
    while (1) {
      while_continue: ;
      tmp___1 = __errno_location();
      tmp___2 = strerror(*tmp___1);
      LOG_Message((LOG_Severity )3, (char const *)"shmget() failed : %s", tmp___2);
      exit(1);
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  tmp___3 = shmat(id, (void const *)0, 0);
  shm = (struct shmTime *)tmp___3;
  if ((long )shm == -1L) {
    {
    while (1) {
      while_continue___0: ;
      tmp___4 = __errno_location();
      tmp___5 = strerror(*tmp___4);
      LOG_Message((LOG_Severity )3, (char const *)"shmat() failed : %s", tmp___5);
      exit(1);
      goto while_break___0;
    }
    while_break___0: ;
    }
    return (0);
  }
  RCL_SetDriverData(instance, (void *)shm);
  return (1);
}
}
static void shm_finalise(RCL_Instance instance )
{
  void *tmp ;
  {
  tmp = RCL_GetDriverData(instance);
  shmdt((void const *)tmp);
  return;
}
}
static int shm_poll(RCL_Instance instance )
{
  struct timespec receive_ts ;
  struct timespec clock_ts ;
  struct shmTime t ;
  struct shmTime *shm ;
  double offset ;
  void *tmp ;
  int tmp___0 ;
  {
  tmp = RCL_GetDriverData(instance);
  shm = (struct shmTime *)tmp;
  t = *shm;
  if (t.mode == 1) {
    if (t.count != shm->count) {
      goto _L;
    } else {
      goto _L___1;
    }
  } else
  _L___1:
  if (t.mode == 0) {
    goto _L___0;
  } else
  if (t.mode == 1) {
    _L___0:
    if (! t.valid) {
      _L:
      {
      while (1) {
        while_continue: ;
        goto while_break;
      }
      while_break: ;
      }
      return (0);
    }
  } else {
    goto _L;
  }
  shm->valid = (int volatile )0;
  receive_ts.tv_sec = t.receiveTimeStampSec;
  clock_ts.tv_sec = t.clockTimeStampSec;
  if (t.clockTimeStampNSec / 1000 == t.clockTimeStampUSec) {
    if (t.receiveTimeStampNSec / 1000 == t.receiveTimeStampUSec) {
      receive_ts.tv_nsec = (__syscall_slong_t )t.receiveTimeStampNSec;
      clock_ts.tv_nsec = (__syscall_slong_t )t.clockTimeStampNSec;
    } else {
      receive_ts.tv_nsec = (__syscall_slong_t )(1000 * t.receiveTimeStampUSec);
      clock_ts.tv_nsec = (__syscall_slong_t )(1000 * t.clockTimeStampUSec);
    }
  } else {
    receive_ts.tv_nsec = (__syscall_slong_t )(1000 * t.receiveTimeStampUSec);
    clock_ts.tv_nsec = (__syscall_slong_t )(1000 * t.clockTimeStampUSec);
  }
  UTI_NormaliseTimespec(& clock_ts);
  UTI_NormaliseTimespec(& receive_ts);
  offset = UTI_DiffTimespecsToDouble((struct timespec const *)(& clock_ts), (struct timespec const *)(& receive_ts));
  tmp___0 = RCL_AddSample(instance, & receive_ts, offset, t.leap);
  return (tmp___0);
}
}
RefclockDriver RCL_SHM_driver = {& shm_initialise, & shm_finalise, & shm_poll};
static void read_sample(int sockfd , int event , void *anything )
{
  struct sock_sample sample ;
  struct timespec ts ;
  RCL_Instance instance ;
  int s ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  {
  instance = (RCL_Instance )anything;
  tmp = recv(sockfd, (void *)(& sample), sizeof(sample), 0);
  s = (int )tmp;
  if (s < 0) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return;
  }
  if ((unsigned long )s != sizeof(sample)) {
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
    return;
  }
  if (sample.magic != 0x534f434b) {
    {
    while (1) {
      while_continue___1: ;
      goto while_break___1;
    }
    while_break___1: ;
    }
    return;
  }
  UTI_TimevalToTimespec((struct timeval const *)(& sample.tv), & ts);
  UTI_NormaliseTimespec(& ts);
  if (sample.pulse) {
    RCL_AddPulse(instance, & ts, sample.offset);
  } else {
    RCL_AddSample(instance, & ts, sample.offset, sample.leap);
  }
  return;
}
}
static int sock_initialise(RCL_Instance instance )
{
  int sockfd ;
  char *path ;
  {
  RCL_CheckDriverOptions(instance, (char const **)((void *)0));
  path = RCL_GetDriverParameter(instance);
  sockfd = SCK_OpenUnixDatagramSocket((char const *)((void *)0), (char const *)path,
                                      0);
  if (sockfd < 0) {
    {
    while (1) {
      while_continue: ;
      LOG_Message((LOG_Severity )3, (char const *)"Could not open socket %s", path);
      exit(1);
      goto while_break;
    }
    while_break: ;
    }
  }
  RCL_SetDriverData(instance, (void *)((long )sockfd));
  SCH_AddFileHandler(sockfd, 1, & read_sample, (SCH_ArbitraryArgument )instance);
  return (1);
}
}
static void sock_finalise(RCL_Instance instance )
{
  int sockfd ;
  void *tmp ;
  {
  tmp = RCL_GetDriverData(instance);
  sockfd = (int )((long )tmp);
  SCH_RemoveFileHandler(sockfd);
  SCK_RemoveSocket(sockfd);
  SCK_CloseSocket(sockfd);
  return;
}
}
RefclockDriver RCL_SOCK_driver = {& sock_initialise, & sock_finalise, (int (*)(RCL_Instance instance ))((void *)0)};
static pthread_mutex_t privops_lock = {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
static void *start_resolving(void *anything )
{
  struct DNS_Async_Instance *inst ;
  ssize_t tmp ;
  {
  inst = (struct DNS_Async_Instance *)anything;
  pthread_mutex_lock(& privops_lock);
  inst->status = DNS_Name2IPAddress(inst->name, inst->addresses, 16);
  pthread_mutex_unlock(& privops_lock);
  tmp = write(inst->pipe[1], (void const *)"", (size_t )1);
  return ((void *)0);
}
}
static void end_resolving(int fd___0 , int event , void *anything )
{
  struct DNS_Async_Instance *inst ;
  int i ;
  int tmp ;
  {
  inst = (struct DNS_Async_Instance *)anything;
  tmp = pthread_join(inst->thread, (void **)((void *)0));
  if (tmp) {
    {
    while (1) {
      while_continue: ;
      LOG_Message((LOG_Severity )3, (char const *)"pthread_join() failed");
      exit(1);
      goto while_break;
    }
    while_break: ;
    }
  }
  SCH_RemoveFileHandler(inst->pipe[0]);
  close(inst->pipe[0]);
  close(inst->pipe[1]);
  i = 0;
  {
  while (1) {
    while_continue___0: ;
    if ((unsigned int )inst->status == 0U) {
      if (i < 16) {
        if (! ((int )inst->addresses[i].family != 0)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
    } else {
      goto while_break___0;
    }
    i ++;
  }
  while_break___0: ;
  }
  (*(inst->handler))(inst->status, i, inst->addresses, inst->arg);
  free((void *)inst);
  return;
}
}
void DNS_Name2IPAddressAsync(char const *name , void (*handler)(DNS_Status status ,
                                                                  int n_addrs , IPAddr *ip_addrs ,
                                                                  void *anything ) ,
                             void *anything )
{
  struct DNS_Async_Instance *inst ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  tmp = Malloc(sizeof(struct DNS_Async_Instance ));
  inst = (struct DNS_Async_Instance *)tmp;
  inst->name = name;
  inst->handler = handler;
  inst->arg = anything;
  inst->status = (DNS_Status )2;
  tmp___0 = pipe((int *)(inst->pipe));
  if (tmp___0) {
    {
    while (1) {
      while_continue: ;
      LOG_Message((LOG_Severity )3, (char const *)"pipe() failed");
      exit(1);
      goto while_break;
    }
    while_break: ;
    }
  }
  UTI_FdSetCloexec(inst->pipe[0]);
  UTI_FdSetCloexec(inst->pipe[1]);
  tmp___1 = pthread_create((pthread_t * __restrict )(& inst->thread), (pthread_attr_t const * __restrict )((void *)0),
                           & start_resolving, (void * __restrict )inst);
  if (tmp___1) {
    {
    while (1) {
      while_continue___0: ;
      LOG_Message((LOG_Severity )3, (char const *)"pthread_create() failed");
      exit(1);
      goto while_break___0;
    }
    while_break___0: ;
    }
  }
  SCH_AddFileHandler(inst->pipe[0], 1, & end_resolving, (SCH_ArbitraryArgument )inst);
  return;
}
}
static void handle_slew___4(struct timespec *raw , struct timespec *cooked , double dfreq ,
                            double doffset , LCL_ChangeType change_type , void *anything )
{
  HCL_Instance clock___0 ;
  double delta ;
  {
  clock___0 = (HCL_Instance )anything;
  if (clock___0->n_samples) {
    UTI_AdjustTimespec((struct timespec const *)(& clock___0->local_ref), (struct timespec const *)cooked,
                       & clock___0->local_ref, & delta, dfreq, doffset);
  }
  if (clock___0->valid_coefs) {
    clock___0->frequency /= 1.0 - dfreq;
  }
  return;
}
}
HCL_Instance HCL_CreateInstance(int min_samples___0 , int max_samples___0 , double min_separation )
{
  HCL_Instance clock___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  {
  if (min_samples___0 < 64) {
    tmp___1 = min_samples___0;
  } else {
    tmp___1 = 64;
  }
  if (2 > tmp___1) {
    min_samples___0 = 2;
  } else {
    if (min_samples___0 < 64) {
      tmp___0 = min_samples___0;
    } else {
      tmp___0 = 64;
    }
    min_samples___0 = tmp___0;
  }
  if (max_samples___0 < 64) {
    tmp___4 = max_samples___0;
  } else {
    tmp___4 = 64;
  }
  if (2 > tmp___4) {
    max_samples___0 = 2;
  } else {
    if (max_samples___0 < 64) {
      tmp___3 = max_samples___0;
    } else {
      tmp___3 = 64;
    }
    max_samples___0 = tmp___3;
  }
  if (min_samples___0 > max_samples___0) {
    max_samples___0 = min_samples___0;
  } else {
    max_samples___0 = max_samples___0;
  }
  tmp___5 = Malloc(sizeof(struct HCL_Instance_Record ));
  clock___0 = (struct HCL_Instance_Record *)tmp___5;
  tmp___6 = Malloc2((size_t )max_samples___0, sizeof(double ));
  clock___0->x_data = (double *)tmp___6;
  tmp___7 = Malloc2((size_t )max_samples___0, sizeof(double ));
  clock___0->y_data = (double *)tmp___7;
  *(clock___0->x_data + (max_samples___0 - 1)) = 0.0;
  *(clock___0->y_data + (max_samples___0 - 1)) = 0.0;
  clock___0->min_samples = min_samples___0;
  clock___0->max_samples = max_samples___0;
  clock___0->n_samples = 0;
  clock___0->valid_coefs = 0;
  clock___0->min_separation = min_separation;
  LCL_AddParameterChangeHandler(& handle_slew___4, (void *)clock___0);
  return (clock___0);
}
}
void HCL_DestroyInstance(HCL_Instance clock___0 )
{
  {
  LCL_RemoveParameterChangeHandler(& handle_slew___4, (void *)clock___0);
  free((void *)clock___0->y_data);
  free((void *)clock___0->x_data);
  free((void *)clock___0);
  return;
}
}
int HCL_NeedsNewSample(HCL_Instance clock___0 , struct timespec *now )
{
  double tmp ;
  double tmp___0 ;
  {
  if (! clock___0->n_samples) {
    return (1);
  } else {
    tmp = UTI_DiffTimespecsToDouble((struct timespec const *)now, (struct timespec const *)(& clock___0->local_ref));
    tmp___0 = fabs(tmp);
    if (tmp___0 >= clock___0->min_separation) {
      return (1);
    }
  }
  return (0);
}
}
void HCL_AccumulateSample(HCL_Instance clock___0 , struct timespec *hw_ts , struct timespec *local_ts ,
                          double err )
{
  double hw_delta ;
  double local_delta ;
  double local_freq ;
  double raw_freq ;
  int i ;
  int n_runs___0 ;
  int best_start ;
  double tmp ;
  double tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  {
  tmp = LCL_ReadAbsoluteFrequency();
  local_freq = 1.0 - tmp / 1.0e6;
  if (clock___0->n_samples) {
    if (clock___0->n_samples >= clock___0->max_samples) {
      (clock___0->n_samples) --;
    }
    hw_delta = UTI_DiffTimespecsToDouble((struct timespec const *)hw_ts, (struct timespec const *)(& clock___0->hw_ref));
    tmp___0 = UTI_DiffTimespecsToDouble((struct timespec const *)local_ts, (struct timespec const *)(& clock___0->local_ref));
    local_delta = tmp___0 / local_freq;
    if (hw_delta <= 0.0) {
      goto _L;
    } else
    if (local_delta < clock___0->min_separation / 2.0) {
      _L:
      clock___0->n_samples = 0;
      {
      while (1) {
        while_continue: ;
        goto while_break;
      }
      while_break: ;
      }
    }
    i = clock___0->max_samples - clock___0->n_samples;
    {
    while (1) {
      while_continue___0: ;
      if (! (i < clock___0->max_samples)) {
        goto while_break___0;
      }
      *(clock___0->y_data + (i - 1)) = *(clock___0->y_data + i) - hw_delta;
      *(clock___0->x_data + (i - 1)) = *(clock___0->x_data + i) - local_delta;
      i ++;
    }
    while_break___0: ;
    }
  }
  (clock___0->n_samples) ++;
  clock___0->hw_ref = *hw_ts;
  clock___0->local_ref = *local_ts;
  clock___0->last_err = err;
  clock___0->valid_coefs = RGR_FindBestRobustRegression((clock___0->x_data + clock___0->max_samples) - clock___0->n_samples,
                                                        (clock___0->y_data + clock___0->max_samples) - clock___0->n_samples,
                                                        clock___0->n_samples, 1.0e-10,
                                                        & clock___0->offset, & raw_freq,
                                                        & n_runs___0, & best_start);
  if (! clock___0->valid_coefs) {
    {
    while (1) {
      while_continue___1: ;
      goto while_break___1;
    }
    while_break___1: ;
    }
    return;
  }
  clock___0->frequency = raw_freq / local_freq;
  if (clock___0->n_samples > clock___0->min_samples) {
    if (best_start < clock___0->n_samples - clock___0->min_samples) {
      tmp___1 = best_start;
    } else {
      tmp___1 = clock___0->n_samples - clock___0->min_samples;
    }
    clock___0->n_samples -= tmp___1;
  }
  tmp___2 = fabs(clock___0->offset);
  if (tmp___2 > err) {
    goto _L___0;
  } else {
    tmp___3 = fabs(clock___0->frequency - 1.0);
    if (tmp___3 > 2.0 / 3.0) {
      _L___0:
      {
      while (1) {
        while_continue___2: ;
        goto while_break___2;
      }
      while_break___2: ;
      }
      clock___0->n_samples = 0;
      clock___0->valid_coefs = 0;
    }
  }
  {
  while (1) {
    while_continue___3: ;
    goto while_break___3;
  }
  while_break___3: ;
  }
  return;
}
}
int HCL_CookTime(HCL_Instance clock___0 , struct timespec *raw , struct timespec *cooked ,
                 double *err )
{
  double offset ;
  double elapsed ;
  {
  if (! clock___0->valid_coefs) {
    return (0);
  }
  elapsed = UTI_DiffTimespecsToDouble((struct timespec const *)raw, (struct timespec const *)(& clock___0->hw_ref));
  offset = elapsed / clock___0->frequency - clock___0->offset;
  UTI_AddDoubleToTimespec((struct timespec const *)(& clock___0->local_ref), offset,
                          cooked);
  if (err) {
    *err = clock___0->last_err;
  }
  return (1);
}
}
extern int ( __attribute__((__leaf__)) getifaddrs)(struct ifaddrs **__ifap ) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) freeifaddrs)(struct ifaddrs *__ifa ) __attribute__((__nothrow__)) ;
__inline static void ethtool_cmd_speed_set(struct ethtool_cmd *ep , __u32 speed )
{
  {
  ep->speed = (__u16 )(speed & 65535U);
  ep->speed_hi = (__u16 )(speed >> 16);
  return;
}
}
__inline static __u32 ethtool_cmd_speed(struct ethtool_cmd const *ep )
{
  {
  return ((__u32 )(((int )ep->speed_hi << 16) | (int )ep->speed));
}
}
__inline static __u64 ethtool_get_flow_spec_ring(__u64 ring_cookie )
{
  {
  return (4294967295ULL & ring_cookie);
}
}
__inline static __u64 ethtool_get_flow_spec_ring_vf(__u64 ring_cookie )
{
  {
  return ((1095216660480ULL & ring_cookie) >> 32);
}
}
__inline static int ethtool_validate_speed(__u32 speed )
{
  int tmp ;
  {
  if (speed <= 2147483647U) {
    tmp = 1;
  } else
  if (speed == 4294967295U) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
__inline static int ethtool_validate_duplex(__u8 duplex )
{
  {
  {
  if ((int )duplex == 0xff) {
    goto case_255;
  }
  if ((int )duplex == 0x01) {
    goto case_255;
  }
  if ((int )duplex == 0x00) {
    goto case_255;
  }
  goto switch_break;
  case_255:
  case_1:
  case_0:
  return (1);
  switch_break: ;
  }
  return (0);
}
}
extern unsigned int ( __attribute__((__leaf__)) if_nametoindex)(char const *__ifname ) __attribute__((__nothrow__)) ;
extern char *( __attribute__((__leaf__)) if_indextoname)(unsigned int __ifindex ,
                                                         char *__ifname ) __attribute__((__nothrow__,
__access__(__write_only__,2))) ;
extern struct if_nameindex *( __attribute__((__leaf__)) if_nameindex)(void) __attribute__((__nothrow__)) ;
extern void ( __attribute__((__leaf__)) if_freenameindex)(struct if_nameindex *__ptr ) __attribute__((__nothrow__)) ;
static ARR_Instance interfaces ;
static int ts_flags ;
static int ts_tx_flags ;
static int permanent_ts_options ;
static int monitored_socket ;
static int suspended_socket ;
static SCH_TimeoutID resume_timeout_id ;
static int dummy_rxts_socket ;
static int add_interface(CNF_HwTsInterface *conf_iface )
{
  struct ethtool_ts_info ts_info ;
  struct hwtstamp_config ts_config ;
  struct ifreq req ;
  int sock_fd ;
  int if_index ;
  int phc_fd ;
  int req_hwts_flags ;
  int rx_filter ;
  unsigned int i ;
  struct Interface *iface ;
  void *tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;
  double tmp___18 ;
  char *tmp___19 ;
  {
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp___1 = ARR_GetSize(interfaces);
    if (! (i < tmp___1)) {
      goto while_break;
    }
    tmp = ARR_GetElement(interfaces, i);
    tmp___0 = strcmp((char const *)conf_iface->name, (char const *)(((struct Interface *)tmp)->name));
    if (! tmp___0) {
      return (1);
    }
    i ++;
  }
  while_break: ;
  }
  sock_fd = SCK_OpenUdpSocket((IPSockAddr *)((void *)0), (IPSockAddr *)((void *)0),
                              (char const *)((void *)0), 0);
  if (sock_fd < 0) {
    return (0);
  }
  memset((void *)(& req), 0, sizeof(req));
  memset((void *)(& ts_info), 0, sizeof(ts_info));
  tmp___2 = snprintf(req.ifr_ifrn.ifrn_name, sizeof(req.ifr_ifrn.ifrn_name), (char const *)"%s",
                     conf_iface->name);
  if ((unsigned long )tmp___2 >= sizeof(req.ifr_ifrn.ifrn_name)) {
    SCK_CloseSocket(sock_fd);
    return (0);
  }
  tmp___5 = ioctl(sock_fd, 35123UL, & req);
  if (tmp___5) {
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
    SCK_CloseSocket(sock_fd);
    return (0);
  }
  if_index = req.ifr_ifru.ifru_ivalue;
  ts_info.cmd = (__u32 )0x00000041;
  req.ifr_ifru.ifru_data = (char *)(& ts_info);
  tmp___8 = ioctl(sock_fd, 35142UL, & req);
  if (tmp___8) {
    {
    while (1) {
      while_continue___1: ;
      goto while_break___1;
    }
    while_break___1: ;
    }
    SCK_CloseSocket(sock_fd);
    return (0);
  }
  req_hwts_flags = 69;
  if ((ts_info.so_timestamping & (unsigned int )req_hwts_flags) != (unsigned int )req_hwts_flags) {
    {
    while (1) {
      while_continue___2: ;
      goto while_break___2;
    }
    while_break___2: ;
    }
    SCK_CloseSocket(sock_fd);
    return (0);
  }
  if (ts_info.phc_index < 0) {
    {
    while (1) {
      while_continue___3: ;
      goto while_break___3;
    }
    while_break___3: ;
    }
    SCK_CloseSocket(sock_fd);
    return (0);
  }
  {
  if ((unsigned int )conf_iface->rxfilter == 0U) {
    goto case_0;
  }
  if ((unsigned int )conf_iface->rxfilter == 1U) {
    goto case_1;
  }
  if ((unsigned int )conf_iface->rxfilter == 2U) {
    goto case_2;
  }
  if ((unsigned int )conf_iface->rxfilter == 3U) {
    goto case_3;
  }
  goto switch_default;
  case_0:
  if (ts_info.rx_filters & (unsigned int )(1 << 15)) {
    rx_filter = 15;
  } else
  if (ts_info.rx_filters & (unsigned int )(1 << 1)) {
    rx_filter = 1;
  } else {
    rx_filter = 0;
  }
  goto switch_break;
  case_1:
  rx_filter = 0;
  goto switch_break;
  case_2:
  rx_filter = 15;
  goto switch_break;
  case_3:
  if (ts_info.rx_filters & (unsigned int )(1 << 6)) {
    rx_filter = 6;
  } else
  if (ts_info.rx_filters & (unsigned int )(1 << 12)) {
    rx_filter = 12;
  } else {
    rx_filter = 0;
  }
  goto switch_break;
  switch_default:
  rx_filter = 1;
  goto switch_break;
  switch_break: ;
  }
  ts_config.flags = 0;
  ts_config.tx_type = 1;
  ts_config.rx_filter = rx_filter;
  req.ifr_ifru.ifru_data = (char *)(& ts_config);
  tmp___15 = ioctl(sock_fd, 35248UL, & req);
  if (tmp___15) {
    tmp___9 = __errno_location();
    tmp___10 = strerror(*tmp___9);
    tmp___13 = __errno_location();
    if (*tmp___13 == 1) {
      tmp___12 = 2;
    } else {
      tmp___12 = -1;
    }
    LOG_Message((LOG_Severity )tmp___12, (char const *)"ioctl(%s) failed : %s",
                "SIOCSHWTSTAMP", tmp___10);
    req.ifr_ifru.ifru_data = (char *)(& ts_config);
    tmp___14 = ioctl(sock_fd, 35249UL, & req);
    if (tmp___14) {
      SCK_CloseSocket(sock_fd);
      return (0);
    } else
    if (ts_config.tx_type != 1) {
      SCK_CloseSocket(sock_fd);
      return (0);
    } else
    if (ts_config.rx_filter != rx_filter) {
      SCK_CloseSocket(sock_fd);
      return (0);
    }
  }
  SCK_CloseSocket(sock_fd);
  phc_fd = SYS_Linux_OpenPHC((char const *)((void *)0), ts_info.phc_index);
  if (phc_fd < 0) {
    return (0);
  }
  tmp___16 = ARR_GetNewElement(interfaces);
  iface = (struct Interface *)tmp___16;
  snprintf(iface->name, sizeof(iface->name), (char const *)"%s", conf_iface->name);
  iface->if_index = if_index;
  iface->phc_fd = phc_fd;
  iface->phc_mode = 0;
  iface->phc_nocrossts = conf_iface->nocrossts;
  iface->link_speed = 1000;
  iface->l2_udp4_ntp_start = 42;
  iface->l2_udp6_ntp_start = 62;
  iface->precision = conf_iface->precision;
  iface->tx_comp = conf_iface->tx_comp;
  iface->rx_comp = conf_iface->rx_comp;
  if (conf_iface->minpoll > -6) {
    tmp___17 = conf_iface->minpoll;
  } else {
    tmp___17 = -6;
  }
  tmp___18 = UTI_Log2ToDouble(tmp___17);
  iface->clock = HCL_CreateInstance(conf_iface->min_samples, conf_iface->max_samples,
                                    tmp___18);
  if (ts_config.rx_filter == 0) {
    tmp___19 = "(TX only) ";
  } else {
    tmp___19 = "";
  }
  LOG_Message((LOG_Severity )0, (char const *)"Enabled HW timestamping %son %s",
              tmp___19, iface->name);
  return (1);
}
}
static int add_all_interfaces(CNF_HwTsInterface *conf_iface_all )
{
  CNF_HwTsInterface conf_iface ;
  struct ifaddrs *ifaddr ;
  struct ifaddrs *ifa ;
  int r ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  conf_iface = *conf_iface_all;
  tmp___1 = getifaddrs(& ifaddr);
  if (tmp___1) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return (0);
  }
  r = 0;
  ifa = ifaddr;
  {
  while (1) {
    while_continue___0: ;
    if (! ifa) {
      goto while_break___0;
    }
    conf_iface.name = ifa->ifa_name;
    tmp___2 = add_interface(& conf_iface);
    if (tmp___2) {
      r = 1;
    }
    ifa = ifa->ifa_next;
  }
  while_break___0: ;
  }
  freeifaddrs(ifaddr);
  return (r);
}
}
static void update_interface_speed(struct Interface *iface )
{
  struct ethtool_cmd cmd ;
  struct ifreq req ;
  int sock_fd ;
  int link_speed ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  __u32 tmp___2 ;
  {
  sock_fd = SCK_OpenUdpSocket((IPSockAddr *)((void *)0), (IPSockAddr *)((void *)0),
                              (char const *)((void *)0), 0);
  if (sock_fd < 0) {
    return;
  }
  memset((void *)(& req), 0, sizeof(req));
  memset((void *)(& cmd), 0, sizeof(cmd));
  snprintf(req.ifr_ifrn.ifrn_name, sizeof(req.ifr_ifrn.ifrn_name), (char const *)"%s",
           iface->name);
  cmd.cmd = (__u32 )0x00000001;
  req.ifr_ifru.ifru_data = (char *)(& cmd);
  tmp___1 = ioctl(sock_fd, 35142UL, & req);
  if (tmp___1) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    SCK_CloseSocket(sock_fd);
    return;
  }
  SCK_CloseSocket(sock_fd);
  tmp___2 = ethtool_cmd_speed((struct ethtool_cmd const *)(& cmd));
  link_speed = (int )tmp___2;
  if (iface->link_speed != link_speed) {
    iface->link_speed = link_speed;
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
  }
  return;
}
}
static int check_timestamping_option(int option )
{
  int sock_fd ;
  int tmp ;
  {
  sock_fd = SCK_OpenUdpSocket((IPSockAddr *)((void *)0), (IPSockAddr *)((void *)0),
                              (char const *)((void *)0), 0);
  if (sock_fd < 0) {
    return (0);
  }
  tmp = SCK_SetIntOption(sock_fd, 1, 37, option);
  if (! tmp) {
    SCK_CloseSocket(sock_fd);
    return (0);
  }
  SCK_CloseSocket(sock_fd);
  return (1);
}
}
static int open_dummy_socket(void)
{
  int sock_fd ;
  int events ;
  int tmp ;
  {
  events = 0;
  sock_fd = SCK_OpenUdpSocket((IPSockAddr *)((void *)0), (IPSockAddr *)((void *)0),
                              (char const *)((void *)0), 0);
  if (sock_fd < 0) {
    return (-3);
  }
  tmp = NIO_Linux_SetTimestampSocketOptions(sock_fd, 1, & events);
  if (! tmp) {
    SCK_CloseSocket(sock_fd);
    return (-3);
  }
  return (sock_fd);
}
}
void NIO_Linux_Initialise(void)
{
  CNF_HwTsInterface *conf_iface ;
  unsigned int i ;
  int hwts ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  {
  interfaces = ARR_CreateInstance((unsigned int )sizeof(struct Interface ));
  hwts = 0;
  i = (unsigned int )hwts;
  {
  while (1) {
    while_continue: ;
    tmp___1 = CNF_GetHwTsInterface(i, & conf_iface);
    if (! tmp___1) {
      goto while_break;
    }
    tmp = strcmp((char const *)"*", (char const *)conf_iface->name);
    if (! tmp) {
      goto __Cont;
    }
    tmp___0 = add_interface(conf_iface);
    if (! tmp___0) {
      {
      while (1) {
        while_continue___0: ;
        LOG_Message((LOG_Severity )3, (char const *)"Could not enable HW timestamping on %s",
                    conf_iface->name);
        exit(1);
        goto while_break___0;
      }
      while_break___0: ;
      }
    }
    hwts = 1;
    __Cont:
    i ++;
  }
  while_break: ;
  }
  i = 0U;
  {
  while (1) {
    while_continue___1: ;
    tmp___4 = CNF_GetHwTsInterface(i, & conf_iface);
    if (! tmp___4) {
      goto while_break___1;
    }
    tmp___2 = strcmp((char const *)"*", (char const *)conf_iface->name);
    if (tmp___2) {
      goto __Cont___0;
    }
    tmp___3 = add_all_interfaces(conf_iface);
    if (tmp___3) {
      hwts = 1;
    }
    goto while_break___1;
    __Cont___0:
    i ++;
  }
  while_break___1: ;
  }
  ts_flags = 24;
  ts_tx_flags = 2;
  if (hwts) {
    ts_flags |= 68;
    ts_tx_flags |= 1;
    tmp___5 = check_timestamping_option(8192);
    if (tmp___5) {
      ts_flags |= 8192;
    }
    tmp___6 = check_timestamping_option(16384);
    if (tmp___6) {
      ts_flags |= 16384;
    }
  }
  ts_flags |= 1024;
  tmp___7 = SYS_Linux_CheckKernelVersion(4, 7);
  if (tmp___7) {
    tmp___8 = 0;
  } else {
    tmp___8 = 1;
  }
  permanent_ts_options = tmp___8;
  monitored_socket = -3;
  suspended_socket = -3;
  dummy_rxts_socket = -3;
  return;
}
}
void NIO_Linux_Finalise(void)
{
  struct Interface *iface ;
  unsigned int i ;
  void *tmp ;
  unsigned int tmp___0 ;
  {
  if (dummy_rxts_socket != -3) {
    SCK_CloseSocket(dummy_rxts_socket);
  }
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp___0 = ARR_GetSize(interfaces);
    if (! (i < tmp___0)) {
      goto while_break;
    }
    tmp = ARR_GetElement(interfaces, i);
    iface = (struct Interface *)tmp;
    HCL_DestroyInstance(iface->clock);
    close(iface->phc_fd);
    i ++;
  }
  while_break: ;
  }
  ARR_DestroyInstance(interfaces);
  return;
}
}
int NIO_Linux_SetTimestampSocketOptions(int sock_fd , int client_only , int *events )
{
  int val ;
  int flags ;
  int tmp ;
  int tmp___0 ;
  {
  if (! ts_flags) {
    return (0);
  }
  val = 1;
  flags = ts_flags;
  if (client_only) {
    flags |= ts_tx_flags;
  } else
  if (permanent_ts_options) {
    flags |= ts_tx_flags;
  }
  tmp = SCK_SetIntOption(sock_fd, 1, 45, val);
  if (! tmp) {
    ts_flags = 0;
    return (0);
  }
  tmp___0 = SCK_SetIntOption(sock_fd, 1, 37, flags);
  if (! tmp___0) {
    ts_flags = 0;
    return (0);
  }
  *events |= 4;
  return (1);
}
}
static void resume_socket(int sock_fd )
{
  char *tmp ;
  {
  if (monitored_socket == sock_fd) {
    monitored_socket = -3;
  }
  if (sock_fd == -3) {
    return;
  } else
  if (sock_fd != suspended_socket) {
    return;
  }
  suspended_socket = -3;
  SCH_SetFileHandlerEvent(sock_fd, 1, 1);
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  if (resume_timeout_id) {
    SCH_RemoveTimeout(resume_timeout_id);
    resume_timeout_id = (SCH_TimeoutID )0;
  }
  return;
}
}
static void resume_timeout(void *arg )
{
  {
  resume_timeout_id = (SCH_TimeoutID )0;
  resume_socket(suspended_socket);
  return;
}
}
static void suspend_socket(int sock_fd )
{
  {
  resume_socket(suspended_socket);
  suspended_socket = sock_fd;
  SCH_SetFileHandlerEvent(suspended_socket, 1, 0);
  resume_timeout_id = SCH_AddTimeoutByDelay(200.0e-6, & resume_timeout, (void *)0);
  {
  while (1) {
    while_continue: ;
    goto while_break;
  }
  while_break: ;
  }
  return;
}
}
int NIO_Linux_ProcessEvent(int sock_fd , int event )
{
  {
  if (sock_fd != monitored_socket) {
    return (0);
  }
  if (event == 1) {
    suspend_socket(monitored_socket);
    monitored_socket = -3;
    return (1);
  }
  return (0);
}
}
static struct Interface *get_interface(int if_index )
{
  struct Interface *iface ;
  unsigned int i ;
  void *tmp ;
  unsigned int tmp___0 ;
  {
  i = 0U;
  {
  while (1) {
    while_continue: ;
    tmp___0 = ARR_GetSize(interfaces);
    if (! (i < tmp___0)) {
      goto while_break;
    }
    tmp = ARR_GetElement(interfaces, i);
    iface = (struct Interface *)tmp;
    if (iface->if_index != if_index) {
      goto __Cont;
    }
    return (iface);
    __Cont:
    i ++;
  }
  while_break: ;
  }
  return ((struct Interface *)((void *)0));
}
}
static void process_hw_timestamp(struct Interface *iface , struct timespec *hw_ts ,
                                 NTP_Local_Timestamp *local_ts , int rx_ntp_length ,
                                 int family , int l2_length )
{
  struct timespec sample_phc_ts ;
  struct timespec sample_sys_ts ;
  struct timespec sample_local_ts ;
  struct timespec ts ;
  double rx_correction ;
  double ts_delay ;
  double phc_err ;
  double local_err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  {
  tmp___0 = HCL_NeedsNewSample(iface->clock, & local_ts->ts);
  if (tmp___0) {
    tmp = SYS_Linux_GetPHCSample(iface->phc_fd, iface->phc_nocrossts, iface->precision,
                                 & iface->phc_mode, & sample_phc_ts, & sample_sys_ts,
                                 & phc_err);
    if (! tmp) {
      return;
    }
    LCL_CookTime(& sample_sys_ts, & sample_local_ts, & local_err);
    HCL_AccumulateSample(iface->clock, & sample_phc_ts, & sample_local_ts, phc_err + local_err);
    update_interface_speed(iface);
  }
  if (rx_ntp_length) {
    if (iface->link_speed) {
      if (! l2_length) {
        if (family == 1) {
          tmp___1 = iface->l2_udp4_ntp_start;
        } else {
          tmp___1 = iface->l2_udp6_ntp_start;
        }
        l2_length = tmp___1 + rx_ntp_length;
      }
      l2_length += 4;
      rx_correction = (double )l2_length / ((1.0e6 / (double )8) * (double )iface->link_speed);
      UTI_AddDoubleToTimespec((struct timespec const *)hw_ts, rx_correction, hw_ts);
    }
  }
  tmp___2 = HCL_CookTime(iface->clock, hw_ts, & ts, & local_err);
  if (! tmp___2) {
    return;
  }
  if (! rx_ntp_length) {
    if (iface->tx_comp) {
      UTI_AddDoubleToTimespec((struct timespec const *)(& ts), iface->tx_comp, & ts);
    } else {
      goto _L;
    }
  } else
  _L:
  if (rx_ntp_length) {
    if (iface->rx_comp) {
      UTI_AddDoubleToTimespec((struct timespec const *)(& ts), - iface->rx_comp,
                              & ts);
    }
  }
  ts_delay = UTI_DiffTimespecsToDouble((struct timespec const *)(& local_ts->ts),
                                       (struct timespec const *)(& ts));
  tmp___3 = fabs(ts_delay);
  if (tmp___3 > 1.0) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return;
  }
  local_ts->ts = ts;
  local_ts->err = local_err;
  local_ts->source = (NTP_Timestamp_Source )2;
  return;
}
}
static void process_sw_timestamp(struct timespec *sw_ts , NTP_Local_Timestamp *local_ts )
{
  double ts_delay ;
  double local_err ;
  struct timespec ts ;
  double tmp ;
  {
  LCL_CookTime(sw_ts, & ts, & local_err);
  ts_delay = UTI_DiffTimespecsToDouble((struct timespec const *)(& local_ts->ts),
                                       (struct timespec const *)(& ts));
  tmp = fabs(ts_delay);
  if (tmp > 1.0) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return;
  }
  local_ts->ts = ts;
  local_ts->err = local_err;
  local_ts->source = (NTP_Timestamp_Source )1;
  return;
}
}
static int extract_udp_data(unsigned char *msg , NTP_Remote_Address *remote_addr ,
                            int len )
{
  unsigned char *msg_start ;
  int ihl ;
  uint32_t addr ;
  int eh_len ;
  int next_header ;
  __uint16_t tmp ;
  {
  msg_start = msg;
  remote_addr->ip_addr.family = (uint16_t )0;
  remote_addr->port = (uint16_t )0;
  if (len < 12) {
    return (0);
  }
  len -= 12;
  msg += 12;
  {
  while (1) {
    while_continue: ;
    if (len >= 4) {
      if ((int )*(msg + 0) == 0x81) {
        if (! ((int )*(msg + 1) == 0x00)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    len -= 4;
    msg += 4;
  }
  while_break: ;
  }
  if (len < 2) {
    return (0);
  } else
  if ((int )*(msg + 0) == 0x08) {
    if (! ((int )*(msg + 1) == 0x00)) {
      goto _L;
    }
  } else
  _L:
  if ((int )*(msg + 0) == 0x86) {
    if (! ((int )*(msg + 1) == 0xdd)) {
      return (0);
    }
  } else {
    return (0);
  }
  len -= 2;
  msg += 2;
  if (len >= 20) {
    if ((int )*(msg + 0) >> 4 == 4) {
      ihl = ((int )*(msg + 0) & 0xf) * 4;
      if (len < ihl + 8) {
        return (0);
      } else
      if ((int )*(msg + 9) != 17) {
        return (0);
      }
      memcpy((void *)(& addr), (void const *)(msg + 16), sizeof(addr));
      remote_addr->ip_addr.addr.in4 = __bswap_32(addr);
      remote_addr->port = __bswap_16(*((uint16_t *)((msg + ihl) + 2)));
      remote_addr->ip_addr.family = (uint16_t )1;
      len -= ihl + 8;
      msg += ihl + 8;
    } else {
      goto _L___0;
    }
  } else
  _L___0:
  if (len >= 48) {
    if ((int )*(msg + 0) >> 4 == 6) {
      next_header = (int )*(msg + 6);
      memcpy((void *)(& remote_addr->ip_addr.addr.in6), (void const *)(msg + 24),
             sizeof(remote_addr->ip_addr.addr.in6));
      len -= 40;
      msg += 40;
      {
      while (1) {
        while_continue___0: ;
        if (! (next_header != 17)) {
          goto while_break___0;
        }
        {
        if (next_header == 44) {
          goto case_44;
        }
        if (next_header == 135) {
          goto case_135;
        }
        if (next_header == 60) {
          goto case_135;
        }
        if (next_header == 43) {
          goto case_135;
        }
        if (next_header == 0) {
          goto case_135;
        }
        if (next_header == 51) {
          goto case_51;
        }
        goto switch_default;
        case_44:
        tmp = __bswap_16(*((uint16_t *)(msg + 2)));
        if ((int )tmp >> 3 != 0) {
          return (0);
        }
        eh_len = 8;
        goto switch_break;
        case_135:
        case_60:
        case_43:
        case_0:
        eh_len = 8 * ((int )*(msg + 1) + 1);
        goto switch_break;
        case_51:
        eh_len = 4 * ((int )*(msg + 1) + 2);
        goto switch_break;
        switch_default:
        return (0);
        switch_break: ;
        }
        if (eh_len < 8) {
          return (0);
        } else
        if (len < eh_len + 8) {
          return (0);
        }
        next_header = (int )*(msg + 0);
        len -= eh_len;
        msg += eh_len;
      }
      while_break___0: ;
      }
      remote_addr->port = __bswap_16(*((uint16_t *)(msg + 2)));
      remote_addr->ip_addr.family = (uint16_t )2;
      len -= 8;
      msg += 8;
    } else {
      return (0);
    }
  } else {
    return (0);
  }
  if (len > 0) {
    memmove((void *)msg_start, (void const *)msg, (size_t )len);
  }
  return (len);
}
}
int NIO_Linux_ProcessMessage(SCK_Message *message , NTP_Local_Address *local_addr ,
                             NTP_Local_Timestamp *local_ts , int event )
{
  struct Interface *iface ;
  int is_tx ;
  int ts_if_index ;
  int l2_length ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  {
  is_tx = event == 4;
  iface = (struct Interface *)((void *)0);
  ts_if_index = message->timestamp.if_index;
  if (ts_if_index == -1) {
    ts_if_index = message->if_index;
  }
  l2_length = message->timestamp.l2_length;
  tmp___0 = UTI_IsZeroTimespec(& message->timestamp.hw);
  if (! tmp___0) {
    iface = get_interface(ts_if_index);
    if (iface) {
      if (! is_tx) {
        tmp = message->length;
      } else {
        tmp = 0;
      }
      process_hw_timestamp(iface, & message->timestamp.hw, local_ts, tmp, (int )message->remote_addr.ip.ip_addr.family,
                           l2_length);
    } else {
      {
      while (1) {
        while_continue: ;
        goto while_break;
      }
      while_break: ;
      }
    }
    if (is_tx) {
      resume_socket(local_addr->sock_fd);
    }
  }
  if ((unsigned int )local_ts->source == 0U) {
    tmp___1 = UTI_IsZeroTimespec(& message->timestamp.kernel);
    if (! tmp___1) {
      if (! is_tx) {
        process_sw_timestamp(& message->timestamp.kernel, local_ts);
      } else {
        tmp___2 = UTI_IsZeroTimespec(& message->timestamp.hw);
        if (tmp___2) {
          process_sw_timestamp(& message->timestamp.kernel, local_ts);
        }
      }
    }
  }
  if (! is_tx) {
    if ((unsigned int )local_ts->source == 0U) {
      if (ts_flags) {
        {
        while (1) {
          while_continue___0: ;
          goto while_break___0;
        }
        while_break___0: ;
        }
        if (dummy_rxts_socket == -3) {
          dummy_rxts_socket = open_dummy_socket();
        }
      }
    }
  }
  if (! is_tx) {
    return (0);
  }
  l2_length = message->length;
  message->length = extract_udp_data((unsigned char *)message->data, & message->remote_addr.ip,
                                     message->length);
  {
  while (1) {
    while_continue___1: ;
    goto while_break___1;
  }
  while_break___1: ;
  }
  if (iface) {
    if (message->length) {
      if ((int )message->remote_addr.ip.ip_addr.family == 1) {
        iface->l2_udp4_ntp_start = l2_length - message->length;
      } else
      if ((int )message->remote_addr.ip.ip_addr.family == 2) {
        iface->l2_udp6_ntp_start = l2_length - message->length;
      }
    }
  }
  if ((unsigned int )local_ts->source == 0U) {
    {
    while (1) {
      while_continue___2: ;
      goto while_break___2;
    }
    while_break___2: ;
    }
    return (1);
  }
  tmp___4 = NIO_UnwrapMessage(message, local_addr->sock_fd);
  if (! tmp___4) {
    return (1);
  }
  if (message->length < (int )((unsigned long )(& ((NTP_Packet *)0)->extensions))) {
    return (1);
  } else
  if ((unsigned long )message->length > sizeof(NTP_Packet )) {
    return (1);
  }
  NSR_ProcessTx(& message->remote_addr.ip, local_addr, local_ts, (NTP_Packet *)message->data,
                message->length);
  return (1);
}
}
void NIO_Linux_RequestTxTimestamp(SCK_Message *message , int sock_fd )
{
  int tmp ;
  int tmp___0 ;
  {
  if (! ts_flags) {
    return;
  }
  if (ts_tx_flags & 1) {
    tmp = NIO_IsServerSocket(sock_fd);
    if (! tmp) {
      monitored_socket = sock_fd;
    }
  }
  if (permanent_ts_options) {
    return;
  } else {
    tmp___0 = NIO_IsServerSocket(sock_fd);
    if (! tmp___0) {
      return;
    }
  }
  message->timestamp.tx_flags = ts_tx_flags;
  return;
}
}
void NIO_Linux_NotifySocketClosing(int sock_fd )
{
  {
  resume_socket(sock_fd);
  return;
}
}
static void measurement_timeout(void *any ) ;
static void read_from_device(int fd_ , int event , void *any ) ;
static OperatingMode operating_mode = (OperatingMode )0;
static int fd ;
static int measurement_period = 15;
static SCH_TimeoutID timeout_id___0 = (SCH_TimeoutID )0;
static int skip_interrupts ;
static time_t *rtc_sec = (time_t *)((void *)0);
static time_t rtc_ref ;
static struct timespec *system_times = (struct timespec *)((void *)0);
static int n_samples___0 ;
static int n_samples_since_regression ;
static int n_runs ;
static int coefs_valid ;
static time_t coef_ref_time ;
static double coef_seconds_fast ;
static double coef_gain_rate ;
static double saved_coef_gain_rate ;
static double autotrim_threshold ;
static char *coefs_file_name ;
static int tried_to_load_coefs = 0;
static int valid_coefs_from_file = 0;
static time_t file_ref_time ;
static double file_ref_offset ;
static double file_rate_ppm ;
static int rtc_on_utc___0 ;
static LOG_FileID logfileid___4 ;
static void (*after_init_hook)(void * ) = (void (*)(void * ))((void *)0);
static void *after_init_hook_arg = (void *)0;
static void discard_samples(int new_first )
{
  int n_to_save ;
  int tmp ;
  {
  if (new_first >= 0) {
    if (new_first < n_samples___0) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  assert(tmp);
  n_to_save = n_samples___0 - new_first;
  memmove((void *)rtc_sec, (void const *)(rtc_sec + new_first), (unsigned long )n_to_save * sizeof(time_t ));
  memmove((void *)system_times, (void const *)(system_times + new_first), (unsigned long )n_to_save * sizeof(struct timespec ));
  n_samples___0 = n_to_save;
  return;
}
}
static void accumulate_sample___0(time_t rtc , struct timespec *sys )
{
  {
  if (n_samples___0 == 64) {
    discard_samples(4);
  }
  if (n_samples___0 > 0) {
    if (*(rtc_sec + (n_samples___0 - 1)) >= rtc) {
      {
      while (1) {
        while_continue: ;
        goto while_break;
      }
      while_break: ;
      }
      n_samples___0 = 0;
    }
  }
  rtc_ref = rtc;
  *(rtc_sec + n_samples___0) = rtc;
  *(system_times + n_samples___0) = *sys;
  n_samples_since_regression ++;
  n_samples___0 ++;
  return;
}
}
static void run_regression(int new_sample , int *valid , time_t *ref , double *fast ,
                           double *slope )
{
  double rtc_rel[64] ;
  double offsets[64] ;
  int i ;
  double est_intercept ;
  double est_slope ;
  int best_new_start ;
  int tmp ;
  {
  if (n_samples___0 > 0) {
    i = 0;
    {
    while (1) {
      while_continue: ;
      if (! (i < n_samples___0)) {
        goto while_break;
      }
      rtc_rel[i] = (double )(*(rtc_sec + i) - rtc_ref);
      offsets[i] = ((double )(rtc_ref - (system_times + i)->tv_sec) - 1.0e-9 * (double )(system_times + i)->tv_nsec) + rtc_rel[i];
      i ++;
    }
    while_break: ;
    }
    tmp = RGR_FindBestRobustRegression(rtc_rel, offsets, n_samples___0, 1.0e-9, & est_intercept,
                                       & est_slope, & n_runs, & best_new_start);
    if (tmp) {
      *valid = 1;
      *ref = rtc_ref;
      *fast = est_intercept;
      *slope = est_slope;
      if (best_new_start > 0) {
        discard_samples(best_new_start);
      }
    }
  }
  return;
}
}
static void slew_samples___1(struct timespec *raw , struct timespec *cooked , double dfreq ,
                             double doffset , LCL_ChangeType change_type , void *anything )
{
  int i ;
  double delta_time ;
  double old_seconds_fast ;
  double old_gain_rate ;
  {
  if ((unsigned int )change_type == 2U) {
    n_samples___0 = 0;
  }
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < n_samples___0)) {
      goto while_break;
    }
    UTI_AdjustTimespec((struct timespec const *)(system_times + i), (struct timespec const *)cooked,
                       system_times + i, & delta_time, dfreq, doffset);
    i ++;
  }
  while_break: ;
  }
  old_seconds_fast = coef_seconds_fast;
  old_gain_rate = coef_gain_rate;
  if (coefs_valid) {
    coef_seconds_fast += doffset;
    coef_gain_rate += dfreq * (1.0 - coef_gain_rate);
  }
  {
  while (1) {
    while_continue___0: ;
    goto while_break___0;
  }
  while_break___0: ;
  }
  return;
}
}
static struct tm *rtc_from_t(time_t const *t )
{
  struct tm *tmp ;
  struct tm *tmp___0 ;
  {
  if (rtc_on_utc___0) {
    tmp = gmtime(t);
    return (tmp);
  } else {
    tmp___0 = localtime(t);
    return (tmp___0);
  }
}
}
static time_t t_from_rtc(struct tm *stm )
{
  struct tm temp1 ;
  struct tm temp2 ;
  struct tm *tm ;
  long diff ;
  time_t t1 ;
  time_t t2 ;
  struct tm *tmp ;
  struct tm *tmp___0 ;
  {
  temp1 = *stm;
  temp1.tm_isdst = 0;
  t1 = mktime(& temp1);
  if (rtc_on_utc___0) {
    tmp = gmtime((time_t const *)(& t1));
    tm = tmp;
  } else {
    tmp___0 = localtime((time_t const *)(& t1));
    tm = tmp___0;
  }
  if (! tm) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    return ((time_t )-1);
  }
  temp2 = *tm;
  temp2.tm_isdst = 0;
  t2 = mktime(& temp2);
  diff = t2 - t1;
  if (t1 - diff == -1L) {
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
  }
  return (t1 - diff);
}
}
static void read_hwclock_file(char const *hwclock_file___0 )
{
  FILE *in ;
  char line[256] ;
  int i ;
  char __attribute__((__access__(__write_only__,1,2))) *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  if (! hwclock_file___0) {
    return;
  } else
  if (! *(hwclock_file___0 + 0)) {
    return;
  }
  in = UTI_OpenFile((char const *)((void *)0), hwclock_file___0, (char const *)((void *)0),
                    (char )'r', (mode_t )0);
  if (! in) {
    return;
  }
  i = 0;
  {
  while (1) {
    while_continue: ;
    if (! (i < 3)) {
      goto while_break;
    }
    tmp = fgets(line, (int )sizeof(line), in);
    if (! tmp) {
      goto while_break;
    }
    i ++;
  }
  while_break: ;
  }
  fclose(in);
  if (i == 3) {
    tmp___1 = strncmp((char const *)(line), (char const *)"LOCAL", (size_t )5);
    if (tmp___1) {
      goto _L;
    } else {
      rtc_on_utc___0 = 0;
    }
  } else
  _L:
  if (i == 3) {
    tmp___0 = strncmp((char const *)(line), (char const *)"UTC", (size_t )3);
    if (tmp___0) {
      LOG_Message((LOG_Severity )1, (char const *)"Could not read RTC LOCAL/UTC setting from %s",
                  hwclock_file___0);
    } else {
      rtc_on_utc___0 = 1;
    }
  } else {
    LOG_Message((LOG_Severity )1, (char const *)"Could not read RTC LOCAL/UTC setting from %s",
                hwclock_file___0);
  }
  return;
}
}
static void setup_config(void)
{
  int tmp ;
  char *tmp___0 ;
  {
  tmp = CNF_GetRtcOnUtc();
  if (tmp) {
    rtc_on_utc___0 = 1;
  } else {
    rtc_on_utc___0 = 0;
  }
  tmp___0 = CNF_GetHwclockFile();
  read_hwclock_file((char const *)tmp___0);
  autotrim_threshold = CNF_GetRtcAutotrim();
  return;
}
}
static void read_coefs_from_file(void)
{
  double ref_time ;
  FILE *in ;
  int tmp ;
  {
  if (! tried_to_load_coefs) {
    valid_coefs_from_file = 0;
    tried_to_load_coefs = 1;
    if (coefs_file_name) {
      in = UTI_OpenFile((char const *)((void *)0), (char const *)coefs_file_name,
                        (char const *)((void *)0), (char )'r', (mode_t )0);
      if (in) {
        tmp = fscanf(in, (char const *)"%d%lf%lf%lf", & valid_coefs_from_file, & ref_time,
                     & file_ref_offset, & file_rate_ppm);
        if (tmp == 4) {
          file_ref_time = (time_t )ref_time;
        } else {
          LOG_Message((LOG_Severity )1, (char const *)"Could not read coefficients from %s",
                      coefs_file_name);
        }
        fclose(in);
      }
    }
  }
  return;
}
}
static int write_coefs_to_file(int valid , time_t ref_time , double offset , double rate )
{
  FILE *out ;
  int tmp ;
  {
  out = UTI_OpenFile((char const *)((void *)0), (char const *)coefs_file_name,
                     (char const *)".tmp", (char )'w', (mode_t )0644);
  if (! out) {
    return (2);
  }
  fprintf(out, (char const *)"%1d %.0f %.6f %.3f\n", valid, (double )ref_time, offset,
          1.0e6 * rate);
  fclose(out);
  tmp = UTI_RenameTempFile((char const *)((void *)0), (char const *)coefs_file_name,
                           (char const *)".tmp", (char const *)((void *)0));
  if (! tmp) {
    return (2);
  }
  return (0);
}
}
static int switch_interrupts(int on_off )
{
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  {
  if (on_off) {
    tmp___2 = (unsigned int )(112 << 8) | 3U;
  } else {
    tmp___2 = (unsigned int )(112 << 8) | 4U;
  }
  tmp___3 = ioctl(fd, (unsigned long )tmp___2, 0);
  if (tmp___3 < 0) {
    tmp = __errno_location();
    tmp___0 = strerror(*tmp);
    if (on_off) {
      tmp___1 = "enable";
    } else {
      tmp___1 = "disable";
    }
    LOG_Message((LOG_Severity )2, (char const *)"Could not %s RTC interrupt : %s",
                tmp___1, tmp___0);
    return (0);
  }
  if (on_off) {
    skip_interrupts = 1;
  }
  return (1);
}
}
int RTC_Linux_Initialise(void)
{
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  LOG_FileID tmp___8 ;
  int tmp___9 ;
  {
  tmp = CNF_GetRtcDevice();
  fd = open((char const *)tmp, 02);
  if (fd < 0) {
    tmp___0 = __errno_location();
    tmp___1 = strerror(*tmp___0);
    tmp___2 = CNF_GetRtcDevice();
    LOG_Message((LOG_Severity )2, (char const *)"Could not open RTC device %s : %s",
                tmp___2, tmp___1);
    return (0);
  }
  tmp___3 = switch_interrupts(1);
  if (tmp___3) {
    tmp___4 = switch_interrupts(0);
    if (! tmp___4) {
      close(fd);
      return (0);
    }
  } else {
    close(fd);
    return (0);
  }
  UTI_FdSetCloexec(fd);
  tmp___5 = Malloc2((size_t )64, sizeof(time_t ));
  rtc_sec = (time_t *)tmp___5;
  tmp___6 = Malloc2((size_t )64, sizeof(struct timespec ));
  system_times = (struct timespec *)tmp___6;
  setup_config();
  coefs_file_name = CNF_GetRtcFile();
  n_samples___0 = 0;
  n_samples_since_regression = 0;
  n_runs = 0;
  coefs_valid = 0;
  measurement_period = 15;
  operating_mode = (OperatingMode )0;
  SCH_AddFileHandler(fd, 1, & read_from_device, (void *)0);
  LCL_AddParameterChangeHandler(& slew_samples___1, (void *)0);
  tmp___9 = CNF_GetLogRtc();
  if (tmp___9) {
    tmp___8 = LOG_FileOpen((char const *)"rtc", (char const *)"   Date (UTC) Time   RTC fast (s) Val   Est fast (s)   Slope (ppm)  Ns  Nr Meas");
    logfileid___4 = tmp___8;
  } else {
    logfileid___4 = -1;
  }
  return (1);
}
}
void RTC_Linux_Finalise(void)
{
  {
  SCH_RemoveTimeout(timeout_id___0);
  timeout_id___0 = (SCH_TimeoutID )0;
  if (fd >= 0) {
    SCH_RemoveFileHandler(fd);
    switch_interrupts(0);
    close(fd);
    RTC_Linux_WriteParameters();
  }
  if (rtc_sec) {
    LCL_RemoveParameterChangeHandler(& slew_samples___1, (void *)0);
  }
  free((void *)rtc_sec);
  free((void *)system_times);
  return;
}
}
static void measurement_timeout(void *any )
{
  {
  timeout_id___0 = (SCH_TimeoutID )0;
  switch_interrupts(1);
  return;
}
}
static void set_rtc(time_t new_rtc_time )
{
  struct tm rtc_tm ;
  struct rtc_time rtc_raw ;
  int status ;
  struct tm *tmp ;
  {
  tmp = rtc_from_t((time_t const *)(& new_rtc_time));
  rtc_tm = *tmp;
  rtc_raw.tm_sec = rtc_tm.tm_sec;
  rtc_raw.tm_min = rtc_tm.tm_min;
  rtc_raw.tm_hour = rtc_tm.tm_hour;
  rtc_raw.tm_mday = rtc_tm.tm_mday;
  rtc_raw.tm_mon = rtc_tm.tm_mon;
  rtc_raw.tm_year = rtc_tm.tm_year;
  rtc_raw.tm_wday = rtc_tm.tm_wday;
  rtc_raw.tm_yday = rtc_tm.tm_yday;
  rtc_raw.tm_isdst = rtc_tm.tm_isdst;
  status = ioctl(fd, (unsigned long )(((1U << 30) | (unsigned int )(112 << 8)) | 10U) | (sizeof(struct rtc_time ) << 16),
                 & rtc_raw);
  if (status < 0) {
    LOG_Message((LOG_Severity )2, (char const *)"Could not set RTC time");
  }
  return;
}
}
static void handle_initial_trim(void)
{
  double rate ;
  long delta_time ;
  double rtc_error_now ;
  double sys_error_now ;
  {
  run_regression(1, & coefs_valid, & coef_ref_time, & coef_seconds_fast, & coef_gain_rate);
  n_samples_since_regression = 0;
  n_samples___0 = 0;
  read_coefs_from_file();
  if (valid_coefs_from_file) {
    delta_time = coef_ref_time - file_ref_time;
    rate = 1.0e-6 * file_rate_ppm;
    rtc_error_now = file_ref_offset + rate * (double )delta_time;
    sys_error_now = rtc_error_now - coef_seconds_fast;
    LCL_AccumulateOffset(sys_error_now, 0.0);
    LOG_Message((LOG_Severity )0, (char const *)"System clock off from RTC by %f seconds (slew)",
                sys_error_now);
  } else {
    LOG_Message((LOG_Severity )1, (char const *)"No valid rtcfile coefficients");
  }
  coefs_valid = 0;
  (*after_init_hook)(after_init_hook_arg);
  operating_mode = (OperatingMode )0;
  return;
}
}
static void handle_relock_after_trim(void)
{
  int valid ;
  time_t ref ;
  double fast ;
  double slope ;
  {
  valid = 0;
  run_regression(1, & valid, & ref, & fast, & slope);
  if (valid) {
    write_coefs_to_file(1, ref, fast, saved_coef_gain_rate);
  } else {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
  }
  coefs_valid = 0;
  n_samples___0 = 0;
  n_samples_since_regression = 0;
  operating_mode = (OperatingMode )0;
  measurement_period = 15;
  return;
}
}
static void maybe_autotrim(void)
{
  double tmp ;
  int tmp___0 ;
  {
  if ((unsigned int )operating_mode != 0U) {
    return;
  } else
  if (! coefs_valid) {
    return;
  } else
  if (n_samples_since_regression) {
    return;
  }
  if (autotrim_threshold <= 0.0) {
    return;
  } else {
    tmp = fabs(coef_seconds_fast);
    if (tmp < autotrim_threshold) {
      return;
    }
  }
  tmp___0 = REF_GetOurStratum();
  if (tmp___0 >= 16) {
    return;
  }
  RTC_Linux_Trim();
  return;
}
}
static void process_reading(time_t rtc_time , struct timespec *system_time )
{
  double rtc_fast ;
  char *tmp ;
  {
  accumulate_sample___0(rtc_time, system_time);
  {
  if ((unsigned int )operating_mode == 0U) {
    goto case_0;
  }
  if ((unsigned int )operating_mode == 1U) {
    goto case_1;
  }
  if ((unsigned int )operating_mode == 2U) {
    goto case_2;
  }
  goto switch_default;
  case_0:
  if (n_samples_since_regression >= 1) {
    run_regression(1, & coefs_valid, & coef_ref_time, & coef_seconds_fast, & coef_gain_rate);
    n_samples_since_regression = 0;
    maybe_autotrim();
  }
  goto switch_break;
  case_1:
  if (n_samples_since_regression >= 8) {
    handle_initial_trim();
  }
  goto switch_break;
  case_2:
  if (n_samples_since_regression >= 8) {
    handle_relock_after_trim();
  }
  goto switch_break;
  switch_default:
  assert(0);
  goto switch_break;
  switch_break: ;
  }
  if (logfileid___4 != -1) {
    rtc_fast = (double )(rtc_time - system_time->tv_sec) - 1.0e-9 * (double )system_time->tv_nsec;
    tmp = UTI_TimeToLogForm(system_time->tv_sec);
    LOG_FileWrite(logfileid___4, (char const *)"%s %14.6f %1d  %14.6f  %12.3f  %2d  %2d %4d",
                  tmp, rtc_fast, coefs_valid, coef_seconds_fast, coef_gain_rate * 1.0e6,
                  n_samples___0, n_runs, measurement_period);
  }
  return;
}
}
static void read_from_device(int fd_ , int event , void *any )
{
  int status ;
  unsigned long data ;
  struct timespec sys_time ;
  struct rtc_time rtc_raw ;
  struct tm rtc_tm ;
  time_t rtc_t ;
  int error ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  {
  error = 0;
  tmp = read(fd, (void *)(& data), sizeof(data));
  status = (int )tmp;
  if (status < 0) {
    tmp___0 = __errno_location();
    tmp___1 = strerror(*tmp___0);
    tmp___2 = CNF_GetRtcDevice();
    LOG_Message((LOG_Severity )2, (char const *)"Could not read flags %s : %s",
                tmp___2, tmp___1);
    SCH_RemoveFileHandler(fd);
    switch_interrupts(0);
    close(fd);
    fd = -1;
    return;
  }
  if (skip_interrupts > 0) {
    skip_interrupts --;
    return;
  }
  if ((data & 16UL) == 16UL) {
    SCH_GetLastEventTime(& sys_time, (double *)((void *)0), (struct timespec *)((void *)0));
    status = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(112 << 8)) | 9U) | (sizeof(struct rtc_time ) << 16),
                   & rtc_raw);
    if (status < 0) {
      tmp___3 = __errno_location();
      tmp___4 = strerror(*tmp___3);
      tmp___5 = CNF_GetRtcDevice();
      LOG_Message((LOG_Severity )2, (char const *)"Could not read time from %s : %s",
                  tmp___5, tmp___4);
      error = 1;
      goto turn_off_interrupt;
    }
    rtc_tm.tm_sec = rtc_raw.tm_sec;
    rtc_tm.tm_min = rtc_raw.tm_min;
    rtc_tm.tm_hour = rtc_raw.tm_hour;
    rtc_tm.tm_mday = rtc_raw.tm_mday;
    rtc_tm.tm_mon = rtc_raw.tm_mon;
    rtc_tm.tm_year = rtc_raw.tm_year;
    rtc_t = t_from_rtc(& rtc_tm);
    if (rtc_t == -1L) {
      error = 1;
      goto turn_off_interrupt;
    }
    process_reading(rtc_t, & sys_time);
    if (n_samples___0 < 4) {
      measurement_period = 15;
    } else
    if (n_samples___0 < 6) {
      measurement_period = 15 << 1;
    } else
    if (n_samples___0 < 10) {
      measurement_period = 15 << 2;
    } else
    if (n_samples___0 < 14) {
      measurement_period = 15 << 3;
    } else {
      measurement_period = 15 << 4;
    }
  }
  turn_off_interrupt:
  {
  if ((unsigned int )operating_mode == 1U) {
    goto case_1;
  }
  if ((unsigned int )operating_mode == 2U) {
    goto case_2;
  }
  if ((unsigned int )operating_mode == 0U) {
    goto case_0;
  }
  goto switch_default;
  case_1:
  if (error) {
    {
    while (1) {
      while_continue: ;
      goto while_break;
    }
    while_break: ;
    }
    operating_mode = (OperatingMode )0;
    (*after_init_hook)(after_init_hook_arg);
    switch_interrupts(0);
    timeout_id___0 = SCH_AddTimeoutByDelay((double )measurement_period, & measurement_timeout,
                                           (void *)0);
  }
  goto switch_break;
  case_2:
  if (error) {
    {
    while (1) {
      while_continue___0: ;
      goto while_break___0;
    }
    while_break___0: ;
    }
    operating_mode = (OperatingMode )0;
    switch_interrupts(0);
    timeout_id___0 = SCH_AddTimeoutByDelay((double )measurement_period, & measurement_timeout,
                                           (void *)0);
  }
  goto switch_break;
  case_0:
  switch_interrupts(0);
  timeout_id___0 = SCH_AddTimeoutByDelay((double )measurement_period, & measurement_timeout,
                                         (void *)0);
  goto switch_break;
  switch_default:
  assert(0);
  goto switch_break;
  switch_break: ;
  }
  return;
}
}
void RTC_Linux_TimeInit(void (*after_hook)(void * ) , void *anything )
{
  {
  after_init_hook = after_hook;
  after_init_hook_arg = anything;
  operating_mode = (OperatingMode )1;
  timeout_id___0 = (SCH_TimeoutID )0;
  switch_interrupts(1);
  return;
}
}
void RTC_Linux_StartMeasurements(void)
{
  {
  measurement_timeout((void *)0);
  return;
}
}
int RTC_Linux_WriteParameters(void)
{
  int retval ;
  {
  if (fd < 0) {
    return (1);
  }
  if (coefs_valid) {
    retval = write_coefs_to_file(1, coef_ref_time, coef_seconds_fast, coef_gain_rate);
  } else {
    retval = 0;
  }
  return (retval);
}
}
int RTC_Linux_TimePreInit(time_t driftfile_time )
{
  int fd___0 ;
  int status ;
  struct rtc_time rtc_raw ;
  struct rtc_time rtc_raw_retry ;
  struct tm rtc_tm ;
  time_t rtc_t ;
  double accumulated_error ;
  double sys_offset ;
  struct timespec new_sys_time ;
  struct timespec old_sys_time ;
  char *tmp ;
  int tmp___0 ;
  double tmp___1 ;
  {
  coefs_file_name = CNF_GetRtcFile();
  setup_config();
  read_coefs_from_file();
  tmp = CNF_GetRtcDevice();
  fd___0 = open((char const *)tmp, 00);
  if (fd___0 < 0) {
    return (0);
  }
  {
  while (1) {
    while_continue: ;
    status = ioctl(fd___0, (unsigned long )(((2U << 30) | (unsigned int )(112 << 8)) | 9U) | (sizeof(struct rtc_time ) << 16),
                   & rtc_raw);
    if (status >= 0) {
      status = ioctl(fd___0, (unsigned long )(((2U << 30) | (unsigned int )(112 << 8)) | 9U) | (sizeof(struct rtc_time ) << 16),
                     & rtc_raw_retry);
    }
    if (status >= 0) {
      if (! (rtc_raw.tm_sec != rtc_raw_retry.tm_sec)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
  }
  while_break: ;
  }
  LCL_ReadCookedTime(& old_sys_time, (double *)((void *)0));
  close(fd___0);
  if (status >= 0) {
    rtc_tm.tm_sec = rtc_raw.tm_sec;
    rtc_tm.tm_min = rtc_raw.tm_min;
    rtc_tm.tm_hour = rtc_raw.tm_hour;
    rtc_tm.tm_mday = rtc_raw.tm_mday;
    rtc_tm.tm_mon = rtc_raw.tm_mon;
    rtc_tm.tm_year = rtc_raw.tm_year;
    rtc_t = t_from_rtc(& rtc_tm);
    if (rtc_t != -1L) {
      if (valid_coefs_from_file) {
        accumulated_error = file_ref_offset + ((double )(rtc_t - file_ref_time) * 1.0e-6) * file_rate_ppm;
      } else {
        accumulated_error = 0.0;
      }
      new_sys_time.tv_sec = rtc_t;
      new_sys_time.tv_nsec = (__syscall_slong_t )500000000;
      UTI_AddDoubleToTimespec((struct timespec const *)(& new_sys_time), - accumulated_error,
                              & new_sys_time);
      if (new_sys_time.tv_sec < driftfile_time) {
        LOG_Message((LOG_Severity )1, (char const *)"RTC time before last driftfile modification (ignored)");
        return (0);
      }
      sys_offset = UTI_DiffTimespecsToDouble((struct timespec const *)(& old_sys_time),
                                             (struct timespec const *)(& new_sys_time));
      tmp___1 = fabs(sys_offset);
      if (tmp___1 >= 1.0) {
        tmp___0 = LCL_ApplyStepOffset(sys_offset);
        if (tmp___0) {
          LOG_Message((LOG_Severity )0, (char const *)"System time set from RTC");
        }
      }
    } else {
      return (0);
    }
  } else {
    return (0);
  }
  return (1);
}
}
int RTC_Linux_GetReport(RPT_RTC_Report *report )
{
  {
  report->ref_time.tv_sec = coef_ref_time;
  report->ref_time.tv_nsec = (__syscall_slong_t )0;
  report->n_samples = (unsigned long )n_samples___0;
  report->n_runs = (unsigned long )n_runs;
  if (n_samples___0 > 1) {
    report->span_seconds = (unsigned long )(*(rtc_sec + (n_samples___0 - 1)) - *(rtc_sec + 0));
  } else {
    report->span_seconds = 0UL;
  }
  report->rtc_seconds_fast = coef_seconds_fast;
  report->rtc_gain_rate_ppm = 1.0e6 * coef_gain_rate;
  return (1);
}
}
int RTC_Linux_Trim(void)
{
  struct timespec now ;
  double tmp ;
  {
  saved_coef_gain_rate = coef_gain_rate;
  tmp = fabs(coef_seconds_fast);
  if (tmp > 1.0) {
    LOG_Message((LOG_Severity )0, (char const *)"RTC wrong by %.3f seconds (step)",
                coef_seconds_fast);
    LCL_ReadCookedTime(& now, (double *)((void *)0));
    set_rtc(now.tv_sec);
    n_samples___0 = 0;
    operating_mode = (OperatingMode )2;
    coef_seconds_fast = (double )(- now.tv_nsec) / 1.0e9 + 0.5;
    coef_ref_time = now.tv_sec;
    SCH_RemoveTimeout(timeout_id___0);
    timeout_id___0 = (SCH_TimeoutID )0;
    switch_interrupts(1);
  }
  return (1);
}
}
void MD5Init(MD5_CTX *mdContext ) ;
void MD5Update(MD5_CTX *mdContext , unsigned char const *inBuf , unsigned int inLen ) ;
void MD5Final(MD5_CTX *mdContext ) ;
static void Transform(UINT4 *buf , UINT4 *in ) ;
static unsigned char const PADDING[64] =
  { (unsigned char const )0x80, (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00,
        (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00,
        (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00,
        (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00,
        (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00,
        (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00,
        (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00,
        (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00,
        (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00,
        (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00,
        (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00,
        (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00,
        (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00,
        (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00,
        (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00,
        (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00, (unsigned char const )0x00};
void MD5Init(MD5_CTX *mdContext )
{
  UINT4 tmp ;
  {
  tmp = (UINT4 )0;
  mdContext->i[1] = tmp;
  mdContext->i[0] = tmp;
  mdContext->buf[0] = (UINT4 )0x67452301;
  mdContext->buf[1] = 0xefcdab89;
  mdContext->buf[2] = 0x98badcfe;
  mdContext->buf[3] = (UINT4 )0x10325476;
  return;
}
}
void MD5Update(MD5_CTX *mdContext , unsigned char const *inBuf , unsigned int inLen )
{
  UINT4 in[16] ;
  int mdi ;
  unsigned int i ;
  unsigned int ii ;
  int tmp ;
  unsigned char const *tmp___0 ;
  unsigned int tmp___1 ;
  {
  mdi = (int )((mdContext->i[0] >> 3) & 63U);
  if (mdContext->i[0] + (inLen << 3) < mdContext->i[0]) {
    (mdContext->i[1]) ++;
  }
  mdContext->i[0] += inLen << 3;
  mdContext->i[1] += inLen >> 29;
  {
  while (1) {
    while_continue: ;
    tmp___1 = inLen;
    inLen --;
    if (! tmp___1) {
      goto while_break;
    }
    tmp = mdi;
    mdi ++;
    tmp___0 = inBuf;
    inBuf ++;
    mdContext->in[tmp] = (unsigned char )*tmp___0;
    if (mdi == 0x40) {
      i = 0U;
      ii = 0U;
      {
      while (1) {
        while_continue___0: ;
        if (! (i < 16U)) {
          goto while_break___0;
        }
        in[i] = ((((UINT4 )mdContext->in[ii + 3U] << 24) | ((UINT4 )mdContext->in[ii + 2U] << 16)) | ((UINT4 )mdContext->in[ii + 1U] << 8)) | (UINT4 )mdContext->in[ii];
        i ++;
        ii += 4U;
      }
      while_break___0: ;
      }
      Transform(mdContext->buf, in);
      mdi = 0;
    }
  }
  while_break: ;
  }
  return;
}
}
void MD5Final(MD5_CTX *mdContext )
{
  UINT4 in[16] ;
  int mdi ;
  unsigned int i ;
  unsigned int ii ;
  unsigned int padLen ;
  {
  in[14] = mdContext->i[0];
  in[15] = mdContext->i[1];
  mdi = (int )((mdContext->i[0] >> 3) & 63U);
  if (mdi < 56) {
    padLen = (unsigned int )(56 - mdi);
  } else {
    padLen = (unsigned int )(120 - mdi);
  }
  MD5Update(mdContext, PADDING, padLen);
  i = 0U;
  ii = 0U;
  {
  while (1) {
    while_continue: ;
    if (! (i < 14U)) {
      goto while_break;
    }
    in[i] = ((((UINT4 )mdContext->in[ii + 3U] << 24) | ((UINT4 )mdContext->in[ii + 2U] << 16)) | ((UINT4 )mdContext->in[ii + 1U] << 8)) | (UINT4 )mdContext->in[ii];
    i ++;
    ii += 4U;
  }
  while_break: ;
  }
  Transform(mdContext->buf, in);
  i = 0U;
  ii = 0U;
  {
  while (1) {
    while_continue___0: ;
    if (! (i < 4U)) {
      goto while_break___0;
    }
    mdContext->digest[ii] = (unsigned char )(mdContext->buf[i] & 255U);
    mdContext->digest[ii + 1U] = (unsigned char )((mdContext->buf[i] >> 8) & 255U);
    mdContext->digest[ii + 2U] = (unsigned char )((mdContext->buf[i] >> 16) & 255U);
    mdContext->digest[ii + 3U] = (unsigned char )((mdContext->buf[i] >> 24) & 255U);
    i ++;
    ii += 4U;
  }
  while_break___0: ;
  }
  return;
}
}
static void Transform(UINT4 *buf , UINT4 *in )
{
  UINT4 a ;
  UINT4 b ;
  UINT4 c ;
  UINT4 d ;
  {
  a = *(buf + 0);
  b = *(buf + 1);
  c = *(buf + 2);
  d = *(buf + 3);
  a += (((b & c) | (~ b & d)) + *(in + 0)) + 0xd76aa478;
  a = (a << 7) | (a >> 25);
  a += b;
  d += (((a & b) | (~ a & c)) + *(in + 1)) + 0xe8c7b756;
  d = (d << 12) | (d >> 20);
  d += a;
  c += (((d & a) | (~ d & b)) + *(in + 2)) + 606105819U;
  c = (c << 17) | (c >> 15);
  c += d;
  b += (((c & d) | (~ c & a)) + *(in + 3)) + 0xc1bdceee;
  b = (b << 22) | (b >> 10);
  b += c;
  a += (((b & c) | (~ b & d)) + *(in + 4)) + 0xf57c0faf;
  a = (a << 7) | (a >> 25);
  a += b;
  d += (((a & b) | (~ a & c)) + *(in + 5)) + 1200080426U;
  d = (d << 12) | (d >> 20);
  d += a;
  c += (((d & a) | (~ d & b)) + *(in + 6)) + 0xa8304613;
  c = (c << 17) | (c >> 15);
  c += d;
  b += (((c & d) | (~ c & a)) + *(in + 7)) + 0xfd469501;
  b = (b << 22) | (b >> 10);
  b += c;
  a += (((b & c) | (~ b & d)) + *(in + 8)) + 1770035416U;
  a = (a << 7) | (a >> 25);
  a += b;
  d += (((a & b) | (~ a & c)) + *(in + 9)) + 0x8b44f7af;
  d = (d << 12) | (d >> 20);
  d += a;
  c += (((d & a) | (~ d & b)) + *(in + 10)) + 0xffff5bb1;
  c = (c << 17) | (c >> 15);
  c += d;
  b += (((c & d) | (~ c & a)) + *(in + 11)) + 0x895cd7be;
  b = (b << 22) | (b >> 10);
  b += c;
  a += (((b & c) | (~ b & d)) + *(in + 12)) + 1804603682U;
  a = (a << 7) | (a >> 25);
  a += b;
  d += (((a & b) | (~ a & c)) + *(in + 13)) + 0xfd987193;
  d = (d << 12) | (d >> 20);
  d += a;
  c += (((d & a) | (~ d & b)) + *(in + 14)) + 0xa679438e;
  c = (c << 17) | (c >> 15);
  c += d;
  b += (((c & d) | (~ c & a)) + *(in + 15)) + 1236535329U;
  b = (b << 22) | (b >> 10);
  b += c;
  a += (((b & d) | (c & ~ d)) + *(in + 1)) + 0xf61e2562;
  a = (a << 5) | (a >> 27);
  a += b;
  d += (((a & c) | (b & ~ c)) + *(in + 6)) + 0xc040b340;
  d = (d << 9) | (d >> 23);
  d += a;
  c += (((d & b) | (a & ~ b)) + *(in + 11)) + 643717713U;
  c = (c << 14) | (c >> 18);
  c += d;
  b += (((c & a) | (d & ~ a)) + *(in + 0)) + 0xe9b6c7aa;
  b = (b << 20) | (b >> 12);
  b += c;
  a += (((b & d) | (c & ~ d)) + *(in + 5)) + 0xd62f105d;
  a = (a << 5) | (a >> 27);
  a += b;
  d += (((a & c) | (b & ~ c)) + *(in + 10)) + 38016083U;
  d = (d << 9) | (d >> 23);
  d += a;
  c += (((d & b) | (a & ~ b)) + *(in + 15)) + 0xd8a1e681;
  c = (c << 14) | (c >> 18);
  c += d;
  b += (((c & a) | (d & ~ a)) + *(in + 4)) + 0xe7d3fbc8;
  b = (b << 20) | (b >> 12);
  b += c;
  a += (((b & d) | (c & ~ d)) + *(in + 9)) + 568446438U;
  a = (a << 5) | (a >> 27);
  a += b;
  d += (((a & c) | (b & ~ c)) + *(in + 14)) + 0xc33707d6;
  d = (d << 9) | (d >> 23);
  d += a;
  c += (((d & b) | (a & ~ b)) + *(in + 3)) + 0xf4d50d87;
  c = (c << 14) | (c >> 18);
  c += d;
  b += (((c & a) | (d & ~ a)) + *(in + 8)) + 1163531501U;
  b = (b << 20) | (b >> 12);
  b += c;
  a += (((b & d) | (c & ~ d)) + *(in + 13)) + 0xa9e3e905;
  a = (a << 5) | (a >> 27);
  a += b;
  d += (((a & c) | (b & ~ c)) + *(in + 2)) + 0xfcefa3f8;
  d = (d << 9) | (d >> 23);
  d += a;
  c += (((d & b) | (a & ~ b)) + *(in + 7)) + 1735328473U;
  c = (c << 14) | (c >> 18);
  c += d;
  b += (((c & a) | (d & ~ a)) + *(in + 12)) + 0x8d2a4c8a;
  b = (b << 20) | (b >> 12);
  b += c;
  a += (((b ^ c) ^ d) + *(in + 5)) + 0xfffa3942;
  a = (a << 4) | (a >> 28);
  a += b;
  d += (((a ^ b) ^ c) + *(in + 8)) + 0x8771f681;
  d = (d << 11) | (d >> 21);
  d += a;
  c += (((d ^ a) ^ b) + *(in + 11)) + 1839030562U;
  c = (c << 16) | (c >> 16);
  c += d;
  b += (((c ^ d) ^ a) + *(in + 14)) + 0xfde5380c;
  b = (b << 23) | (b >> 9);
  b += c;
  a += (((b ^ c) ^ d) + *(in + 1)) + 0xa4beea44;
  a = (a << 4) | (a >> 28);
  a += b;
  d += (((a ^ b) ^ c) + *(in + 4)) + 1272893353U;
  d = (d << 11) | (d >> 21);
  d += a;
  c += (((d ^ a) ^ b) + *(in + 7)) + 0xf6bb4b60;
  c = (c << 16) | (c >> 16);
  c += d;
  b += (((c ^ d) ^ a) + *(in + 10)) + 0xbebfbc70;
  b = (b << 23) | (b >> 9);
  b += c;
  a += (((b ^ c) ^ d) + *(in + 13)) + 681279174U;
  a = (a << 4) | (a >> 28);
  a += b;
  d += (((a ^ b) ^ c) + *(in + 0)) + 0xeaa127fa;
  d = (d << 11) | (d >> 21);
  d += a;
  c += (((d ^ a) ^ b) + *(in + 3)) + 0xd4ef3085;
  c = (c << 16) | (c >> 16);
  c += d;
  b += (((c ^ d) ^ a) + *(in + 6)) + 76029189U;
  b = (b << 23) | (b >> 9);
  b += c;
  a += (((b ^ c) ^ d) + *(in + 9)) + 0xd9d4d039;
  a = (a << 4) | (a >> 28);
  a += b;
  d += (((a ^ b) ^ c) + *(in + 12)) + 0xe6db99e5;
  d = (d << 11) | (d >> 21);
  d += a;
  c += (((d ^ a) ^ b) + *(in + 15)) + 530742520U;
  c = (c << 16) | (c >> 16);
  c += d;
  b += (((c ^ d) ^ a) + *(in + 2)) + 0xc4ac5665;
  b = (b << 23) | (b >> 9);
  b += c;
  a += ((c ^ (b | ~ d)) + *(in + 0)) + 0xf4292244;
  a = (a << 6) | (a >> 26);
  a += b;
  d += ((b ^ (a | ~ c)) + *(in + 7)) + 1126891415U;
  d = (d << 10) | (d >> 22);
  d += a;
  c += ((a ^ (d | ~ b)) + *(in + 14)) + 0xab9423a7;
  c = (c << 15) | (c >> 17);
  c += d;
  b += ((d ^ (c | ~ a)) + *(in + 5)) + 0xfc93a039;
  b = (b << 21) | (b >> 11);
  b += c;
  a += ((c ^ (b | ~ d)) + *(in + 12)) + 1700485571U;
  a = (a << 6) | (a >> 26);
  a += b;
  d += ((b ^ (a | ~ c)) + *(in + 3)) + 0x8f0ccc92;
  d = (d << 10) | (d >> 22);
  d += a;
  c += ((a ^ (d | ~ b)) + *(in + 10)) + 0xffeff47d;
  c = (c << 15) | (c >> 17);
  c += d;
  b += ((d ^ (c | ~ a)) + *(in + 1)) + 0x85845dd1;
  b = (b << 21) | (b >> 11);
  b += c;
  a += ((c ^ (b | ~ d)) + *(in + 8)) + 1873313359U;
  a = (a << 6) | (a >> 26);
  a += b;
  d += ((b ^ (a | ~ c)) + *(in + 15)) + 0xfe2ce6e0;
  d = (d << 10) | (d >> 22);
  d += a;
  c += ((a ^ (d | ~ b)) + *(in + 6)) + 0xa3014314;
  c = (c << 15) | (c >> 17);
  c += d;
  b += ((d ^ (c | ~ a)) + *(in + 13)) + 1309151649U;
  b = (b << 21) | (b >> 11);
  b += c;
  a += ((c ^ (b | ~ d)) + *(in + 4)) + 0xf7537e82;
  a = (a << 6) | (a >> 26);
  a += b;
  d += ((b ^ (a | ~ c)) + *(in + 11)) + 0xbd3af235;
  d = (d << 10) | (d >> 22);
  d += a;
  c += ((a ^ (d | ~ b)) + *(in + 2)) + 718787259U;
  c = (c << 15) | (c >> 17);
  c += d;
  b += ((d ^ (c | ~ a)) + *(in + 9)) + 0xeb86d391;
  b = (b << 21) | (b >> 11);
  b += c;
  *(buf + 0) += a;
  *(buf + 1) += b;
  *(buf + 2) += c;
  *(buf + 3) += d;
  return;
}
}
static MD5_CTX ctx ;
int HSH_GetHashId(HSH_Algorithm algorithm )
{
  {
  if ((unsigned int )algorithm != 1U) {
    if ((unsigned int )algorithm != 10000U) {
      return (-1);
    }
  }
  return (0);
}
}
int HSH_Hash(int id , void const *in1 , int in1_len , void const *in2 , int in2_len ,
             unsigned char *out , int out_len )
{
  {
  if (in1_len < 0) {
    return (0);
  } else
  if (in2_len < 0) {
    return (0);
  } else
  if (out_len < 0) {
    return (0);
  }
  MD5Init(& ctx);
  MD5Update(& ctx, (unsigned char const *)in1, (unsigned int )in1_len);
  if (in2) {
    MD5Update(& ctx, (unsigned char const *)in2, (unsigned int )in2_len);
  }
  MD5Final(& ctx);
  if (out_len < 16) {
    out_len = out_len;
  } else {
    out_len = 16;
  }
  memcpy((void *)out, (void const *)(ctx.digest), (size_t )out_len);
  return (out_len);
}
}
void HSH_Finalise(void)
{
  {
  return;
}
}
