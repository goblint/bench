/* Generated by CIL v. 1.3.5 */
/* print_CIL_Input is true */

#line 41 "/usr/include/i386/_types.h"
typedef unsigned char __uint8_t;
#line 43 "/usr/include/i386/_types.h"
typedef unsigned short __uint16_t;
#line 44 "/usr/include/i386/_types.h"
typedef int __int32_t;
#line 45 "/usr/include/i386/_types.h"
typedef unsigned int __uint32_t;
#line 46 "/usr/include/i386/_types.h"
typedef long long __int64_t;
#line 70 "/usr/include/i386/_types.h"
typedef int __darwin_ct_rune_t;
#line 90 "/usr/include/i386/_types.h"
typedef unsigned long __darwin_size_t;
#line 96 "/usr/include/i386/_types.h"
typedef __builtin_va_list __darwin_va_list;
#line 102 "/usr/include/i386/_types.h"
typedef int __darwin_wchar_t;
#line 107 "/usr/include/i386/_types.h"
typedef __darwin_wchar_t __darwin_rune_t;
#line 115 "/usr/include/i386/_types.h"
typedef unsigned long __darwin_clock_t;
#line 116 "/usr/include/i386/_types.h"
typedef __uint32_t __darwin_socklen_t;
#line 117 "/usr/include/i386/_types.h"
typedef long __darwin_ssize_t;
#line 118 "/usr/include/i386/_types.h"
typedef long __darwin_time_t;
#line 58 "/usr/include/sys/_types.h"
struct __darwin_pthread_handler_rec {
   void (*__routine)(void * ) ;
   void *__arg ;
   struct __darwin_pthread_handler_rec *__next ;
};
#line 64 "/usr/include/sys/_types.h"
struct _opaque_pthread_attr_t {
   long __sig ;
   char __opaque[36] ;
};
#line 65 "/usr/include/sys/_types.h"
struct _opaque_pthread_cond_t {
   long __sig ;
   char __opaque[24] ;
};
#line 66 "/usr/include/sys/_types.h"
struct _opaque_pthread_condattr_t {
   long __sig ;
   char __opaque[4] ;
};
#line 67 "/usr/include/sys/_types.h"
struct _opaque_pthread_mutex_t {
   long __sig ;
   char __opaque[40] ;
};
#line 68 "/usr/include/sys/_types.h"
struct _opaque_pthread_mutexattr_t {
   long __sig ;
   char __opaque[8] ;
};
#line 72 "/usr/include/sys/_types.h"
struct _opaque_pthread_t {
   long __sig ;
   struct __darwin_pthread_handler_rec *__cleanup_stack ;
   char __opaque[596] ;
};
#line 94 "/usr/include/sys/_types.h"
typedef __int64_t __darwin_blkcnt_t;
#line 95 "/usr/include/sys/_types.h"
typedef __int32_t __darwin_blksize_t;
#line 96 "/usr/include/sys/_types.h"
typedef __int32_t __darwin_dev_t;
#line 99 "/usr/include/sys/_types.h"
typedef __uint32_t __darwin_gid_t;
#line 105 "/usr/include/sys/_types.h"
typedef __uint32_t __darwin_ino_t;
#line 109 "/usr/include/sys/_types.h"
typedef __uint16_t __darwin_mode_t;
#line 110 "/usr/include/sys/_types.h"
typedef __int64_t __darwin_off_t;
#line 111 "/usr/include/sys/_types.h"
typedef __int32_t __darwin_pid_t;
#line 112 "/usr/include/sys/_types.h"
typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;
#line 114 "/usr/include/sys/_types.h"
typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;
#line 116 "/usr/include/sys/_types.h"
typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;
#line 119 "/usr/include/sys/_types.h"
typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;
#line 121 "/usr/include/sys/_types.h"
typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;
#line 129 "/usr/include/sys/_types.h"
typedef struct _opaque_pthread_t *__darwin_pthread_t;
#line 132 "/usr/include/sys/_types.h"
typedef __int32_t __darwin_suseconds_t;
#line 133 "/usr/include/sys/_types.h"
typedef __uint32_t __darwin_uid_t;
#line 70 "/usr/include/stdio.h"
typedef __darwin_va_list va_list;
#line 75 "/usr/include/stdio.h"
typedef __darwin_off_t off_t;
#line 80 "/usr/include/stdio.h"
typedef __darwin_size_t size_t;
#line 87 "/usr/include/stdio.h"
typedef __darwin_off_t fpos_t;
#line 98 "/usr/include/stdio.h"
struct __sbuf {
   unsigned char *_base ;
   int _size ;
};
#line 104
struct __sFILEX;
#line 132 "/usr/include/stdio.h"
struct __sFILE {
   unsigned char *_p ;
   int _r ;
   int _w ;
   short _flags ;
   short _file ;
   struct __sbuf _bf ;
   int _lbfsize ;
   void *_cookie ;
   int (*_close)(void * ) ;
   int (*_read)(void * , char * , int  ) ;
   fpos_t (*_seek)(void * , fpos_t  , int  ) ;
   int (*_write)(void * , char const   * , int  ) ;
   struct __sbuf _ub ;
   struct __sFILEX *_extra ;
   int _ur ;
   unsigned char _ubuf[3] ;
   unsigned char _nbuf[1] ;
   struct __sbuf _lb ;
   int _blksize ;
   fpos_t _offset ;
};
#line 132 "/usr/include/stdio.h"
typedef struct __sFILE FILE;
#line 90 "/usr/include/sys/wait.h"
typedef __darwin_pid_t pid_t;
#line 163 "/usr/include/sys/signal.h"
typedef __darwin_pthread_attr_t pthread_attr_t;
#line 178 "/usr/include/sys/signal.h"
typedef __darwin_uid_t uid_t;
#line 100 "/usr/include/sys/_structs.h"
struct timeval {
   __darwin_time_t tv_sec ;
   __darwin_suseconds_t tv_usec ;
};
#line 257 "/usr/include/stdlib.h"
typedef __darwin_dev_t dev_t;
#line 262 "/usr/include/stdlib.h"
typedef __darwin_mode_t mode_t;
#line 70 "/usr/include/string.h"
typedef __darwin_ssize_t ssize_t;
#line 88 "/usr/include/sys/_structs.h"
struct timespec {
   __darwin_time_t tv_sec ;
   long tv_nsec ;
};
#line 77 "/usr/include/time.h"
typedef __darwin_clock_t clock_t;
#line 87 "/usr/include/time.h"
typedef __darwin_time_t time_t;
#line 90 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char *tm_zone ;
};
#line 81 "/usr/include/runetype.h"
struct __anonstruct__RuneEntry_8 {
   __darwin_rune_t __min ;
   __darwin_rune_t __max ;
   __darwin_rune_t __map ;
   __uint32_t *__types ;
};
#line 81 "/usr/include/runetype.h"
typedef struct __anonstruct__RuneEntry_8 _RuneEntry;
#line 88 "/usr/include/runetype.h"
struct __anonstruct__RuneRange_9 {
   int __nranges ;
   _RuneEntry *__ranges ;
};
#line 88 "/usr/include/runetype.h"
typedef struct __anonstruct__RuneRange_9 _RuneRange;
#line 93 "/usr/include/runetype.h"
struct __anonstruct__RuneCharClass_10 {
   char __name[14] ;
   __uint32_t __mask ;
};
#line 93 "/usr/include/runetype.h"
typedef struct __anonstruct__RuneCharClass_10 _RuneCharClass;
#line 98 "/usr/include/runetype.h"
struct __anonstruct__RuneLocale_11 {
   char __magic[8] ;
   char __encoding[32] ;
   __darwin_rune_t (*__sgetrune)(char const   * , __darwin_size_t  , char const   ** ) ;
   int (*__sputrune)(__darwin_rune_t  , char * , __darwin_size_t  , char ** ) ;
   __darwin_rune_t __invalid_rune ;
   __uint32_t __runetype[256] ;
   __darwin_rune_t __maplower[256] ;
   __darwin_rune_t __mapupper[256] ;
   _RuneRange __runetype_ext ;
   _RuneRange __maplower_ext ;
   _RuneRange __mapupper_ext ;
   void *__variable ;
   int __variable_len ;
   int __ncharclasses ;
   _RuneCharClass *__charclasses ;
};
#line 98 "/usr/include/runetype.h"
typedef struct __anonstruct__RuneLocale_11 _RuneLocale;
#line 377 "/usr/include/sys/fcntl.h"
#pragma pack(4)
#line 385
#pragma pack()
#line 66 "/usr/include/signal.h"
typedef __darwin_pthread_t pthread_t;
#line 37 "huge.h"
typedef unsigned int digit;
#line 52 "huge.h"
struct huge_number {
   long size ;
   digit *d ;
};
#line 52 "huge.h"
typedef struct huge_number Huge;
#line 53 "zebedee.c"
typedef Huge *mpz_t;
#line 99 "../blowfish-0.9.5a/blowfish.h"
struct bf_key_st {
   unsigned int P[18] ;
   unsigned int S[1024] ;
};
#line 99 "../blowfish-0.9.5a/blowfish.h"
typedef struct bf_key_st BF_KEY;
#line 261 "../zlib-1.2.3/zconf.h"
typedef unsigned char Byte;
#line 264 "../zlib-1.2.3/zconf.h"
typedef unsigned long uLong;
#line 270 "../zlib-1.2.3/zconf.h"
typedef Byte Bytef;
#line 275 "../zlib-1.2.3/zconf.h"
typedef uLong uLongf;
#line 11 "sha.h"
typedef unsigned char SHA_BYTE;
#line 17 "sha.h"
typedef unsigned int SHA_LONG;
#line 23 "sha.h"
struct __anonstruct_SHA_INFO_14 {
   SHA_LONG digest[5] ;
   SHA_LONG count_lo ;
   SHA_LONG count_hi ;
   SHA_LONG data[16] ;
   int local ;
};
#line 23 "sha.h"
typedef struct __anonstruct_SHA_INFO_14 SHA_INFO;
#line 110 "/usr/include/sys/types.h"
typedef __darwin_blkcnt_t blkcnt_t;
#line 115 "/usr/include/sys/types.h"
typedef __darwin_blksize_t blksize_t;
#line 120 "/usr/include/sys/types.h"
typedef __darwin_gid_t gid_t;
#line 126 "/usr/include/sys/types.h"
typedef __uint32_t in_addr_t;
#line 131 "/usr/include/sys/types.h"
typedef __uint16_t in_port_t;
#line 135 "/usr/include/sys/types.h"
typedef __darwin_ino_t ino_t;
#line 157 "/usr/include/sys/types.h"
typedef __uint16_t nlink_t;
#line 184 "/usr/include/sys/_structs.h"
struct fd_set {
   __int32_t fds_bits[(int )((1024U + (sizeof(__int32_t ) * 8U - 1U)) / (sizeof(__int32_t ) * 8U))] ;
};
#line 184 "/usr/include/sys/_structs.h"
typedef struct fd_set fd_set;
#line 322 "/usr/include/sys/types.h"
//typedef __darwin_pthread_cond_t pthread_cond_t;
#line 326 "/usr/include/sys/types.h"
typedef __darwin_pthread_condattr_t pthread_condattr_t;
#line 330 "/usr/include/sys/types.h"
typedef __darwin_pthread_mutex_t pthread_mutex_t;
#line 334 "/usr/include/sys/types.h"
typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;
#line 85 "/usr/include/sys/times.h"
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
#line 103 "/usr/include/sys/socket.h"
typedef __uint8_t sa_family_t;
#line 108 "/usr/include/sys/socket.h"
typedef __darwin_socklen_t socklen_t;
#line 210 "/usr/include/sys/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 294 "/usr/include/sys/socket.h"
struct sockaddr {
   __uint8_t sa_len ;
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 228 "/usr/include/sys/stat.h"
struct stat {
   dev_t st_dev ;
   ino_t st_ino ;
   mode_t st_mode ;
   nlink_t st_nlink ;
   uid_t st_uid ;
   gid_t st_gid ;
   dev_t st_rdev ;
   struct timespec st_atimespec ;
   struct timespec st_mtimespec ;
   struct timespec st_ctimespec ;
   off_t st_size ;
   blkcnt_t st_blocks ;
   blksize_t st_blksize ;
   __uint32_t st_flags ;
   __uint32_t st_gen ;
   __int32_t st_lspare ;
   __int64_t st_qspare[2] ;
};
#line 89 "/usr/include/sys/dirent.h"
#pragma pack(4)
#line 92 "/usr/include/sys/dirent.h"
struct dirent {
   ino_t d_ino ;
   __uint16_t d_reclen ;
   __uint8_t d_type ;
   __uint8_t d_namlen ;
   char d_name[256] ;
};
#line 101
#pragma pack()
#line 68 "/usr/include/dirent.h"
struct _telldir;
#line 71 "/usr/include/dirent.h"
struct __anonstruct_DIR_15 {
   int __dd_fd ;
   long __dd_loc ;
   long __dd_size ;
   char *__dd_buf ;
   int __dd_len ;
   long __dd_seek ;
   long __dd_rewind ;
   int __dd_flags ;
   __darwin_pthread_mutex_t __dd_lock ;
   struct _telldir *__dd_td ;
};
#line 71 "/usr/include/dirent.h"
typedef struct __anonstruct_DIR_15 DIR;
#line 304 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 362 "/usr/include/netinet/in.h"
struct sockaddr_in {
   __uint8_t sin_len ;
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   char sin_zero[8] ;
};
#line 115 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 137 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 281 "zebedee.c"
struct __anonstruct_BFState_t_17 {
   BF_KEY key ;
   unsigned char iVec[8] ;
   int pos ;
   unsigned char cryptBuf[16383] ;
};
#line 281 "zebedee.c"
typedef struct __anonstruct_BFState_t_17 BFState_t;
#line 300 "zebedee.c"
struct PortList_s {
   unsigned short lo ;
   unsigned short hi ;
   char *host ;
   struct sockaddr_in addr ;
   struct in_addr *addrList ;
   struct PortList_s *next ;
   unsigned long mask ;
   unsigned short type ;
};
#line 300 "zebedee.c"
typedef struct PortList_s PortList_t;
#line 319 "zebedee.c"
struct MsgBuf_s {
   unsigned short maxSize ;
   unsigned short size ;
   unsigned char data[16383] ;
   unsigned char tmp[16633] ;
   unsigned short cmpInfo ;
   BFState_t *bfRead ;
   BFState_t *bfWrite ;
   unsigned long readCount ;
   unsigned long bytesIn ;
   unsigned long expBytesIn ;
   unsigned long writeCount ;
   unsigned long bytesOut ;
   unsigned long expBytesOut ;
};
#line 319 "zebedee.c"
typedef struct MsgBuf_s MsgBuf_t;
#line 342
enum __anonenum_LogType_t_18 {
    LOGFILE_NULL = 0,
    LOGFILE_SYSLOG = 1,
    LOGFILE_LOCAL = 2
} ;
#line 357 "zebedee.c"
struct KeyInfo_s {
   unsigned long token ;
   char *key ;
   time_t expiry ;
   struct KeyInfo_s *prev ;
   struct KeyInfo_s *next ;
};
#line 357 "zebedee.c"
typedef struct KeyInfo_s KeyInfo_t;
#line 372 "zebedee.c"
struct FnArgs_s {
   int fd ;
   unsigned short port ;
   struct sockaddr_in addr ;
   int listenFd ;
   int inLine ;
   int udpMode ;
};
#line 372 "zebedee.c"
typedef struct FnArgs_s FnArgs_t;
#line 388 "zebedee.c"
struct HndInfo_s {
   unsigned long id ;
   int fd ;
   struct sockaddr_in fromAddr ;
   struct sockaddr_in localAddr ;
   struct HndInfo_s *prev ;
   struct HndInfo_s *next ;
};
#line 388 "zebedee.c"
typedef struct HndInfo_s HndInfo_t;
#line 141 "sha_func.c"
union __anonunion_u_3 {
   unsigned char bytes[4] ;
   SHA_LONG integer ;
};
#line 38 "huge.h"
typedef unsigned int wdigit;
#line 39 "huge.h"
typedef unsigned long long twodigits;
#line 40 "huge.h"
typedef long long stwodigits;
#line 1 "zebedee.o"





/* mypthr */

pthread_t my_pthread_self(void){
  pthread_t x;
  return x;
}

#define pthread_self my_pthread_self


struct _my_pthread_cond_t {
  pthread_mutex_t mut;
  int             val;
};

typedef struct _my_pthread_cond_t my_pthread_cond_t;

void my_pthread_cond_wait(my_pthread_cond_t *cond,pthread_mutex_t *mut){
  int b = 0;
  pthread_mutex_unlock(mut);
  while (b != 1){
    pthread_mutex_lock(&cond->mut);
    b = cond->val;
    pthread_mutex_unlock(&cond->mut);
  }
  pthread_mutex_lock(&cond->mut);
  cond->val = 0;
  pthread_mutex_unlock(&cond->mut);
  pthread_mutex_lock(mut);
}

void my_pthread_cond_signal(my_pthread_cond_t *cond){
  pthread_mutex_lock(&cond->mut);
  cond->val = 1;
  pthread_mutex_unlock(&cond->mut);
}

void my_pthread_cond_init(my_pthread_cond_t * cond, void  * ca){
  pthread_mutex_lock(&cond->mut);
  cond->val = 0;
  pthread_mutex_unlock(&cond->mut);
}

#define pthread_cond_t         my_pthread_cond_t
#define pthread_cond_init      my_pthread_cond_init
#define pthread_cond_wait      my_pthread_cond_wait
#define pthread_cond_signal    my_pthread_cond_signal
#define pthread_cond_broadcast my_pthread_cond_signal


/* mypthr */




#pragma merger(0,"/var/folders/3v/3vE4RtlEGkGI18-fANNMsk+++TI/-Tmp-/cil-qbA37saF.i","-O3")
#line 24 "zebedee.c"
char *zebedee_c_rcsid  =    (char *)"$Id: zebedee.c,v 1.25 2002/05/28 06:31:15 ndwinton Exp $";
#line 167 "/usr/include/stdio.h"
extern FILE *__stdinp ;
#line 168
extern FILE *__stdoutp ;
#line 169
extern FILE *__stderrp ;
#line 250
extern int fclose(FILE * ) ;
#line 251
extern int feof(FILE * ) ;
#line 253
extern int fflush(FILE * ) ;
#line 256
extern char *fgets(char * , int  , FILE * ) ;
#line 257
extern FILE *fopen(char const   * , char const   * ) ;
#line 258
extern int fprintf(FILE * , char const   *  , ...) ;
#line 261
extern size_t fread(void * , size_t  , size_t  , FILE * ) ;
#line 277
extern int printf(char const   *  , ...) ;
#line 287
extern int sprintf(char * , char const   *  , ...) ;
#line 288
extern int sscanf(char const   * , char const   *  , ...) ;
#line 333
extern FILE *popen(char const   * , char const   * ) ;
#line 341
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 345
extern int vsnprintf(char * , size_t  , char const   * , va_list  ) ;
#line 413 "/usr/include/sys/signal.h"
extern void (*signal(int  , void (*)(int  ) ))(int  ) ;
#line 44 "/usr/include/libkern/i386/_OSByteOrder.h"
__inline static __uint16_t _OSSwapInt16(__uint16_t _data ) 
{ 

  {
#line 50
  return ((unsigned short )(((int )_data << 8) | ((int )_data >> 8)));
}
}
#line 53 "/usr/include/libkern/i386/_OSByteOrder.h"
__inline static __uint32_t _OSSwapInt32(__uint32_t _data ) 
{ 
  return ((_data >> 24) &       0xff) |
         ((_data >>  8) &     0xff00) |
         ((_data <<  8) &   0xff0000) |
         ((_data << 24) & 0xff000000) ;
/*  {
#line 59
  __asm__  ("bswap   %0": "+r" (_data));
#line 60
  return (_data);
}
*/
}
#line 256 "/usr/include/sys/wait.h"
extern pid_t waitpid(pid_t  , int * , int  )  __asm__("_waitpid$UNIX2003")  ;
#line 157 "/usr/include/stdlib.h"
extern void *calloc(size_t  , size_t  ) ;
#line 159
extern  __attribute__((__noreturn__)) void exit(int  ) ;
#line 160
extern void free(void * ) ;
#line 161
extern char *getenv(char const   * ) ;
#line 169
extern void *malloc(size_t  ) ;
#line 175
extern int rand(void) ;
#line 176
extern void *realloc(void * , size_t  ) ;
#line 177
extern void srand(unsigned int  ) ;
#line 187
extern unsigned long strtoul(char const   * , char ** , int  ) ;
#line 82 "/usr/include/string.h"
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 83
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 84
extern void *memmove(void * , void const   * , size_t  ) ;
#line 85
extern void *memset(void * , int  , size_t  ) ;
#line 91
extern char *strchr(char const   * , int  ) ;
#line 92
extern int strcmp(char const   * , char const   * ) ;
#line 94
extern char *strcpy(char * , char const   * ) ;
#line 96
extern char *strerror(int  )  __asm__("_strerror$UNIX2003")  ;
#line 98
extern size_t strlen(char const   * ) ;
#line 100
extern int strncmp(char const   * , char const   * , size_t  ) ;
#line 106
extern char *strrchr(char const   * , int  ) ;
#line 130
extern int strcasecmp(char const   * , char const   * ) ;
#line 76 "/usr/include/assert.h"
extern  __attribute__((__noreturn__)) void __assert_rtn(char const   * , char const   * ,
                                                        int  , char const   * ) ;
#line 74 "/usr/include/sys/errno.h"
extern int *__error(void) ;
#line 128 "/usr/include/time.h"
extern struct tm *gmtime(time_t const   * ) ;
#line 129
extern struct tm *localtime(time_t const   * ) ;
#line 131
extern size_t strftime(char * , size_t  , char const   * , struct tm  const  * )  __asm__("_strftime$UNIX2003")  ;
#line 133
extern time_t time(time_t * ) ;
#line 132 "/usr/include/runetype.h"
extern _RuneLocale _DefaultRuneLocale ;
#line 151 "/usr/include/ctype.h"
__inline static int isascii(int _c ) 
{ 

  {
#line 154
  return ((_c & -128) == 0);
}
}
#line 165
extern int __maskrune(__darwin_ct_rune_t  , unsigned long  ) ;
#line 169 "/usr/include/ctype.h"
__inline static int __istype(__darwin_ct_rune_t _c , unsigned long _f ) 
{ int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 175
  tmp___5 = isascii(_c);
#line 175
  if (tmp___5) {
#line 175
    tmp___2 = ! (! ((unsigned long )_DefaultRuneLocale.__runetype[_c] & _f));
  } else {
#line 175
    tmp___3 = __maskrune(_c, _f);
#line 175
    if (tmp___3) {
#line 175
      tmp___4 = 1;
    } else {
#line 175
      tmp___4 = 0;
    }
#line 175
    tmp___2 = tmp___4;
  }
#line 175
  return (tmp___2);
}
}
#line 180 "/usr/include/ctype.h"
__inline static __darwin_ct_rune_t __isctype(__darwin_ct_rune_t _c , unsigned long _f ) 
{ int tmp ;

  {
#line 186
  if (_c < 0) {
#line 186
    tmp = 0;
  } else {
#line 186
    if (_c >= 256) {
#line 186
      tmp = 0;
    } else {
#line 186
      tmp = ! (! ((unsigned long )_DefaultRuneLocale.__runetype[_c] & _f));
    }
  }
#line 186
  return (tmp);
}
}
#line 205
extern __darwin_ct_rune_t __toupper(__darwin_ct_rune_t  ) ;
#line 206
extern __darwin_ct_rune_t __tolower(__darwin_ct_rune_t  ) ;
#line 271 "/usr/include/ctype.h"
__inline static int isprint(int _c ) 
{ int tmp ;

  {
#line 274
  tmp = __istype(_c, 262144UL);
#line 274
  return (tmp);
}
}
#line 283 "/usr/include/ctype.h"
__inline static int isspace(int _c ) 
{ int tmp ;

  {
#line 286
  tmp = __istype(_c, 16384UL);
#line 286
  return (tmp);
}
}
#line 296 "/usr/include/ctype.h"
__inline static int isxdigit(int _c ) 
{ int tmp ;

  {
#line 299
  tmp = __isctype(_c, 65536UL);
#line 299
  return (tmp);
}
}
#line 308 "/usr/include/ctype.h"
__inline static int tolower(int _c ) 
{ int tmp ;

  {
#line 311
  tmp = __tolower(_c);
#line 311
  return (tmp);
}
}
#line 314 "/usr/include/ctype.h"
__inline static int toupper(int _c ) 
{ int tmp ;

  {
#line 317
  tmp = __toupper(_c);
#line 317
  return (tmp);
}
}
#line 418 "/usr/include/sys/fcntl.h"
extern int open(char const   * , int   , ...)  __asm__("_open$UNIX2003")  ;
#line 75 "huge.h"
Huge *huge_from_string(char *str , char **pend , int base ) ;
#line 90
char *huge_format(Huge *a , int base ) ;
#line 110
Huge *huge_powmod(Huge *a , Huge *b , Huge *c ) ;
#line 106 "../blowfish-0.9.5a/blowfish.h"
extern void BF_set_key(BF_KEY *key , int len , unsigned char const   *data ) ;
#line 115
extern void BF_cfb64_encrypt(unsigned char const   *in , unsigned char *out , long length ,
                             BF_KEY const   *schedule , unsigned char *ivec , int *num ,
                             int enc ) ;
#line 1024 "../zlib-1.2.3/zlib.h"
extern int compress2(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ,
                     int level ) ;
#line 1047
extern int uncompress(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ) ;
#line 244 "../bzip2-1.0.3/bzlib.h"
extern int BZ2_bzBuffToBuffCompress(char *dest , unsigned int *destLen , char *source ,
                                    unsigned int sourceLen , int blockSize100k , int verbosity ,
                                    int workFactor ) ;
#line 254
extern int BZ2_bzBuffToBuffDecompress(char *dest , unsigned int *destLen , char *source ,
                                      unsigned int sourceLen , int small , int verbosity ) ;
#line 30 "sha.h"
void sha_init(SHA_INFO *sha_info ) ;
#line 31
void sha_update(SHA_INFO *sha_info , SHA_BYTE *buffer___0 , int count ) ;
#line 32
void sha_final(SHA_INFO *sha_info ) ;
#line 190 "/usr/include/sys/_structs.h"
__inline static int __darwin_fd_isset(int _n , struct fd_set *_p ) 
{ 

  {
#line 193
  return (_p->fds_bits[(unsigned int )_n / (sizeof(__int32_t ) * 8U)] & (1 << (unsigned int )_n % (sizeof(__int32_t ) * 8U)));
}
}
#line 39 "/usr/include/sys/_select.h"
extern int select(int  , fd_set * , fd_set * , fd_set * , struct timeval * )  __asm__("_select$UNIX2003")  ;
#line 93 "/usr/include/sys/times.h"
extern clock_t times(struct tms * ) ;
#line 557 "/usr/include/sys/socket.h"
extern int accept(int  , struct sockaddr * , socklen_t * )  __asm__("_accept$UNIX2003")  ;
#line 559
extern int bind(int  , struct sockaddr  const  * , socklen_t  )  __asm__("_bind$UNIX2003")  ;
#line 560
extern int connect(int  , struct sockaddr  const  * , socklen_t  )  __asm__("_connect$UNIX2003")  ;
#line 561
extern int getpeername(int  , struct sockaddr * , socklen_t * )  __asm__("_getpeername$UNIX2003")  ;
#line 563
extern int getsockname(int  , struct sockaddr * , socklen_t * )  __asm__("_getsockname$UNIX2003")  ;
#line 566
extern int listen(int  , int  )  __asm__("_listen$UNIX2003")  ;
#line 567
extern ssize_t recv(int  , void * , size_t  , int  )  __asm__("_recv$UNIX2003")  ;
#line 568
extern ssize_t recvfrom(int  , void * , size_t  , int  , struct sockaddr * , socklen_t * )  __asm__("_recvfrom$UNIX2003")  ;
#line 571
extern ssize_t send(int  , void const   * , size_t  , int  )  __asm__("_send$UNIX2003")  ;
#line 573
extern ssize_t sendto(int  , void const   * , size_t  , int  , struct sockaddr  const  * ,
                      socklen_t  )  __asm__("_sendto$UNIX2003")  ;
#line 575
extern int setsockopt(int  , int  , int  , void const   * , socklen_t  ) ;
#line 578
extern int socket(int  , int  , int  ) ;
#line 430 "/usr/include/sys/stat.h"
extern int stat(char const   * , struct stat * )  __asm__("_stat")  ;
#line 106 "/usr/include/dirent.h"
extern int closedir(DIR * )  __asm__("_closedir$UNIX2003")  ;
#line 110
extern DIR *opendir(char const   * )  __asm__("_opendir$UNIX2003")  ;
#line 114
extern struct dirent *readdir(DIR * )  __asm__("_readdir")  ;
#line 97 "/usr/include/arpa/inet.h"
extern in_addr_t inet_addr(char const   * ) ;
#line 268 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   * ) ;
#line 279
extern struct servent *getservbyname(char const   * , char const   * ) ;
#line 416 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int  ) ;
#line 422
extern int close(int  )  __asm__("_close$UNIX2003")  ;
#line 433
extern int execl(char const   * , char const   *  , ...) ;
#line 441
extern pid_t fork(void) ;
#line 451
extern int gethostname(char * , size_t  ) ;
#line 454
extern int getopt(int  , char * const  * , char const   * )  __asm__("_getopt$UNIX2003")  ;
#line 457
extern pid_t getpid(void) ;
#line 473
extern ssize_t read(int  , void * , size_t  )  __asm__("_read$UNIX2003")  ;
#line 487
extern pid_t setsid(void) ;
#line 511
extern char *optarg ;
#line 512
extern int optind ;
#line 216 "/usr/include/sys/syslog.h"
extern void syslog(int  , char const   *  , ...) ;
#line 264 "/usr/include/pthread.h"
extern int pthread_attr_init(pthread_attr_t * ) ;
#line 265
extern int pthread_attr_setdetachstate(pthread_attr_t * , int  ) ;
#line 279
extern int pthread_attr_setstacksize(pthread_attr_t * , size_t  ) ;
#line 282
//extern int pthread_cond_broadcast(pthread_cond_t * ) ;
#line 284
//extern int pthread_cond_init(pthread_cond_t * , pthread_condattr_t const   * )  __asm__("_pthread_cond_init$UNIX2003")  ;
#line 290
//extern int pthread_cond_wait(pthread_cond_t * , pthread_mutex_t * )  __asm__("_pthread_cond_wait$UNIX2003")  ;
#line 298
extern int pthread_create(pthread_t * , pthread_attr_t const   * , void *(*)(void * ) ,
                          void * ) ;
#line 314
extern int pthread_mutex_init(pthread_mutex_t * , pthread_mutexattr_t const   * ) ;
#line 315
extern int pthread_mutex_lock(pthread_mutex_t * ) ;
#line 318
extern int pthread_mutex_unlock(pthread_mutex_t * ) ;
#line 343
//extern pthread_t pthread_self(void) ;
#line 156 "zebedee.c"
pthread_mutex_t Mutex[5]  ;
#line 157 "zebedee.c"
pthread_cond_t Condition[1]  ;
#line 158 "zebedee.c"
pthread_attr_t ThreadAttr  ;
#line 411 "zebedee.c"
FILE *LogFileP  =    (FILE *)((void *)0);
#line 412 "zebedee.c"
enum __anonenum_LogType_t_18 LogFileType  =    2;
#line 413 "zebedee.c"
unsigned short LogLevel  =    (unsigned short)1;
#line 414 "zebedee.c"
char *Program  =    (char *)"zebedee";
#line 415 "zebedee.c"
char *Generator  =    (char *)"";
#line 416 "zebedee.c"
char *Modulus  =    (char *)"";
#line 417 "zebedee.c"
char *PrivateKey  =    (char *)((void *)0);
#line 418 "zebedee.c"
unsigned short KeyLength  =    (unsigned short)128;
#line 419 "zebedee.c"
unsigned short MinKeyLength  =    (unsigned short)0;
#line 420 "zebedee.c"
unsigned short CompressInfo  =    (unsigned short)6;
#line 421 "zebedee.c"
int IsDetached  =    1;
#line 422 "zebedee.c"
int IsServer  =    0;
#line 423 "zebedee.c"
int Debug  =    0;
#line 424 "zebedee.c"
char *CommandString  =    (char *)((void *)0);
#line 425 "zebedee.c"
unsigned short ServerPort  =    (unsigned short)0;
#line 426 "zebedee.c"
PortList_t *ClientPorts  =    (PortList_t *)((void *)0);
#line 427 "zebedee.c"
PortList_t *TargetPorts  =    (PortList_t *)((void *)0);
#line 428 "zebedee.c"
char *ServerHost  =    (char *)((void *)0);
#line 429 "zebedee.c"
char *TargetHost  =    (char *)"localhost";
#line 430 "zebedee.c"
char *IdentityFile  =    (char *)((void *)0);
#line 431 "zebedee.c"
PortList_t *AllowedTargets  =    (PortList_t *)((void *)0);
#line 432 "zebedee.c"
PortList_t *AllowedDefault  =    (PortList_t *)((void *)0);
#line 433 "zebedee.c"
PortList_t *AllowedPeers  =    (PortList_t *)((void *)0);
#line 434 "zebedee.c"
char *KeyGenCmd  =    (char *)((void *)0);
#line 435 "zebedee.c"
unsigned short KeyGenLevel  =    (unsigned short)2;
#line 436 "zebedee.c"
int TimestampLog  =    0;
#line 437 "zebedee.c"
int MultiUse  =    1;
#line 438 "zebedee.c"
unsigned short MaxBufSize  =    (unsigned short)8192;
#line 439 "zebedee.c"
unsigned long CurrentToken  =    0UL;
#line 440 "zebedee.c"
unsigned short KeyLifetime  =    (unsigned short)3600;
#line 441 "zebedee.c"
int UdpMode  =    0;
#line 442 "zebedee.c"
int TcpMode  =    1;
#line 443 "zebedee.c"
unsigned short TcpTimeout  =    (unsigned short)0;
#line 444 "zebedee.c"
unsigned short UdpTimeout  =    (unsigned short)300;
#line 445 "zebedee.c"
char *ListenIp  =    (char *)((void *)0);
#line 446 "zebedee.c"
int ListenMode  =    0;
#line 447 "zebedee.c"
char *ClientHost  =    (char *)((void *)0);
#line 448 "zebedee.c"
int ListenSock  =    -1;
#line 449 "zebedee.c"
unsigned short ConnectTimeout  =    (unsigned short)300;
#line 450 "zebedee.c"
unsigned short ReadTimeout  =    (unsigned short)0;
#line 451 "zebedee.c"
int ActiveCount  =    0;
#line 452 "zebedee.c"
char *ProxyHost  =    (char *)((void *)0);
#line 453 "zebedee.c"
unsigned short ProxyPort  =    (unsigned short)0;
#line 454 "zebedee.c"
int Transparent  =    0;
#line 455 "zebedee.c"
char *FieldSeparator  =    (char *)((void *)0);
#line 456 "zebedee.c"
char *SharedKey  =    (char *)((void *)0);
#line 457 "zebedee.c"
char *SharedKeyGenCmd  =    (char *)((void *)0);
#line 458 "zebedee.c"
int DumpData  =    0;
#line 471 "zebedee.c"
struct KeyInfo_s ClientKeyList  =    {0UL, (char *)((void *)0), 0L, (struct KeyInfo_s *)((void *)0), (struct KeyInfo_s *)((void *)0)};
#line 473 "zebedee.c"
struct KeyInfo_s ServerKeyList  =    {0UL, (char *)((void *)0), 0L, (struct KeyInfo_s *)((void *)0), (struct KeyInfo_s *)((void *)0)};
#line 475 "zebedee.c"
HndInfo_t HandlerList  ;
#line 484
void threadInit(void) ;
#line 485
void mutexInit(void) ;
#line 486
void mutexLock(int num ) ;
#line 487
void mutexUnlock(int num ) ;
#line 488
void conditionInit(void) ;
#line 489
void conditionSignal(int num ) ;
#line 490
void conditionWait(int condNum , int mutexNum ) ;
#line 491
unsigned long threadPid(void) ;
#line 492
unsigned long threadTid(void) ;
#line 493
void incrActiveCount(int num ) ;
#line 494
void waitForInactivity(void) ;
#line 496
void logToSystemLog(unsigned short level , char *msg ) ;
#line 497
void timestamp(char *timeBuf , int local ) ;
#line 498
void message(unsigned short level , int err , char *fmt  , ...) ;
#line 499
void dumpData(char const   *prefix , unsigned char *data , unsigned short size ) ;
#line 501
int readData(int fd , unsigned char *buffer___0 , unsigned short size ) ;
#line 502
int readUShort(int fd , unsigned short *resultP ) ;
#line 503
int writeData(int fd , unsigned char *buffer___0 , unsigned short size ) ;
#line 504
int writeUShort(int fd , unsigned short value ) ;
#line 506
MsgBuf_t *makeMsgBuf(unsigned short maxSize , unsigned short cmpInfo ) ;
#line 507
void freeMsgBuf(MsgBuf_t *msg ) ;
#line 508
void getMsgBuf(MsgBuf_t *msg , void *buffer___0 , unsigned short size ) ;
#line 509
void setMsgBuf(MsgBuf_t *msg , void *buffer___0 , unsigned short size ) ;
#line 511
int readMessage(int fd , MsgBuf_t *msg , unsigned short thisSize ) ;
#line 512
int writeMessage(int fd , MsgBuf_t *msg ) ;
#line 514
int requestResponse(int fd , unsigned short request , unsigned short *responseP ) ;
#line 516
int getHostAddress(char const   *host , struct sockaddr_in *addrP , struct in_addr **addrList ,
                   unsigned long *maskP ) ;
#line 517
char *ipString(struct in_addr addr , char *buf ) ;
#line 518
int makeConnection(char const   *host , unsigned short port , int udpMode , int useProxy ,
                   struct sockaddr_in *fromAddrP , struct sockaddr_in *toAddrP ) ;
#line 519
int proxyConnection(char const   *host , unsigned short port , struct sockaddr_in *toAddrP ) ;
#line 520
int sendSpoofed(int fd , char *buf , int len , struct sockaddr_in *toAddrP , struct sockaddr_in *fromAddrP ) ;
#line 521
int makeListener(unsigned short *portP , char *listenIp , int udpMode ) ;
#line 522
void setNoLinger(int fd ) ;
#line 523
void setKeepAlive(int fd ) ;
#line 524
int acceptConnection(int listenFd , char const   *host , int loop , unsigned short timeout ) ;
#line 526
void headerSetUShort(unsigned char *hdrBuf , unsigned short value , int offset ) ;
#line 527
void headerSetULong(unsigned char *hdrBuf , unsigned long value , int offset ) ;
#line 528
unsigned short headerGetUShort(unsigned char *hdrBuf , int offset ) ;
#line 529
unsigned long headerGetULong(unsigned char *hdrBuf , int offset ) ;
#line 531
BFState_t *setupBlowfish(char *keyStr , unsigned short keyBits ) ;
#line 532
char *generateKey(void) ;
#line 533
char *runKeyGenCommand(char *keyGenCmd ) ;
#line 534
void generateNonce(unsigned char *nonce ) ;
#line 535
char *generateSessionKey(char *secretKey , unsigned char *cNonce , unsigned char *sNonce ,
                         unsigned short keyBits ) ;
#line 536
unsigned short hexStrToBits(char *hexStr , unsigned short bits , unsigned char *bitVec ) ;
#line 537
char *diffieHellman(char *genStr , char *modStr , char *expStr ) ;
#line 538
void makeChallenge(unsigned char *challenge ) ;
#line 539
void challengeAnswer(unsigned char *challenge ) ;
#line 540
int clientPerformChallenge(int serverFd , MsgBuf_t *msg ) ;
#line 541
int serverPerformChallenge(int clientFd , MsgBuf_t *msg ) ;
#line 543
void freeKeyInfo(KeyInfo_t *info ) ;
#line 544
char *findKeyByToken(KeyInfo_t *list , unsigned long token ) ;
#line 545
void addKeyInfoToList(KeyInfo_t *list , unsigned long token , char *key ) ;
#line 546
unsigned long generateToken(KeyInfo_t *list , unsigned long oldToken ) ;
#line 547
unsigned long getCurrentToken(void) ;
#line 549
int spawnCommand(unsigned short port , char *cmdFormat ) ;
#line 550
int filterLoop(int localFd , int remoteFd , MsgBuf_t *msgBuf , struct sockaddr_in *toAddrP ,
               struct sockaddr_in *fromAddrP , int replyFd , int udpMode ) ;
#line 554
void hashStrings(char *hashBuf  , ...) ;
#line 555
void hashFile(char *hashBuf , char *fileName ) ;
#line 556
int checkIdentity(char *idFile , char *generator , char *modulus , char *key ) ;
#line 557
char *generateIdentity(char *generator , char *modulus , char *exponent ) ;
#line 559
unsigned long spawnHandler(void (*handler)(FnArgs_t * ) , int listenFd , int clientFd ,
                           int inLine , struct sockaddr_in *addrP , int udpMode ) ;
#line 560
int findHandler(struct sockaddr_in *fromAddrP , struct sockaddr_in *localAddrP ) ;
#line 561
void addHandler(struct sockaddr_in *fromAddrP , unsigned long id , int fd , struct sockaddr_in *localAddrP ) ;
#line 562
void removeHandler(struct sockaddr_in *addrP ) ;
#line 564
void clientListener(PortList_t *ports ) ;
#line 565
int makeClientListeners(PortList_t *ports , fd_set *listenSetP , int udpMode ) ;
#line 566
void client(FnArgs_t *argP ) ;
#line 567
void prepareToDetach(void) ;
#line 568
void makeDetached(void) ;
#line 569
void serverListener(unsigned short *portPtr ) ;
#line 570
void serverInitiator(char *clientHost , unsigned short port , unsigned short timeout ) ;
#line 571
int allowRedirect(unsigned short port , struct sockaddr_in *addrP , int udpMode ,
                  char **hostP ) ;
#line 572
int checkPeerAddress(int fd , struct sockaddr_in *addrP ) ;
#line 573
int countPorts(PortList_t *list ) ;
#line 574
unsigned short mapPort(unsigned short localPort , char **hostP , struct sockaddr_in *addrP ) ;
#line 575
void server(FnArgs_t *argP ) ;
#line 577
unsigned short scanPortRange(char const   *str , unsigned short *loP , unsigned short *hiP ,
                             unsigned short *typeP ) ;
#line 579
void setBoolean(char *value , int *resultP ) ;
#line 580
void setUShort(char *value , unsigned short *resultP ) ;
#line 581
void setPort(char *value , unsigned short *resultP ) ;
#line 582
PortList_t *newPortList(unsigned short lo , unsigned short hi , char *host , unsigned short type ) ;
#line 583
PortList_t *allocPortList(unsigned short lo , unsigned short hi , char *host , struct in_addr *addrP ,
                          struct in_addr *addrList , unsigned long mask , unsigned short type ) ;
#line 584
void setPortList(char *value , PortList_t **listP , char *host , int zeroOk ) ;
#line 585
void setTarget(char *value ) ;
#line 586
void setTunnel(char *value ) ;
#line 587
void setAllowedPeer(char *value ) ;
#line 588
void setString(char *value , char **resultP ) ;
#line 589
void setLogFile(char *newFile ) ;
#line 590
void setCmpInfo(char *value , unsigned short *resultP ) ;
#line 591
void readConfigFile(char const   *fileName , int level ) ;
#line 592
int parseConfigLine(char const   *lineBuf , int level ) ;
#line 594
char *cleanHexString(char *str ) ;
#line 596
void usage(void) ;
#line 598
void sigpipeCatcher(int sig ) ;
#line 599
void sigchldCatcher(int sig ) ;
#line 600
void sigusr1Catcher(int sig ) ;
#line 615 "zebedee.c"
void threadInit(void) 
{ 

  {
#line 618
  mutexInit();
#line 619
  conditionInit();
#line 621
  pthread_attr_init(& ThreadAttr);
#line 622
  pthread_attr_setstacksize(& ThreadAttr, 49152UL);
#line 623
  pthread_attr_setdetachstate(& ThreadAttr, 2);
#line 625
  return;
}
}
#line 633 "zebedee.c"
void mutexInit(void) 
{ int i ;

  {
#line 646
  i = 0;
#line 646
  while (i < 5) {
#line 648
    pthread_mutex_init(& Mutex[i], (pthread_mutexattr_t const   *)((void *)0));
#line 646
    i ++;
  }
#line 651
  return;
}
}
#line 659 "zebedee.c"
void mutexLock(int num ) 
{ long tmp ;

  {
#line 662
  tmp = __builtin_expect((long )(! (num < 5)), 0L);
#line 662
  if (tmp) {
#line 662
    __assert_rtn("mutexLock", "zebedee.c", 662, "num < MUTEX_MAX");
  }
#line 667
  pthread_mutex_lock(& Mutex[num]);
#line 669
  return;
}
}
#line 677 "zebedee.c"
void mutexUnlock(int num ) 
{ long tmp ;

  {
#line 680
  tmp = __builtin_expect((long )(! (num < 5)), 0L);
#line 680
  if (tmp) {
#line 680
    __assert_rtn("mutexUnlock", "zebedee.c", 680, "num < MUTEX_MAX");
  }
#line 685
  pthread_mutex_unlock(& Mutex[num]);
#line 687
  return;
}
}
#line 695 "zebedee.c"
void conditionInit(void) 
{ int i ;

  {
#line 711
  i = 0;
#line 711
  while (i < 1) {
#line 713
    pthread_cond_init(& Condition[i], (pthread_condattr_t const   *)((void *)0));
#line 711
    i ++;
  }
#line 716
  return;
}
}
#line 724 "zebedee.c"
void conditionSignal(int num ) 
{ long tmp ;

  {
#line 727
  tmp = __builtin_expect((long )(! (num < 1)), 0L);
#line 727
  if (tmp) {
#line 727
    __assert_rtn("conditionSignal", "zebedee.c", 727, "num < COND_MAX");
  }
#line 732
  pthread_cond_broadcast(& Condition[num]);
#line 734
  return;
}
}
#line 743 "zebedee.c"
void conditionWait(int condNum , int mutexNum ) 
{ int tmp ;
  long tmp___0 ;

  {
#line 746
  if (condNum < 1) {
#line 746
    if (mutexNum < 5) {
#line 746
      tmp = 0;
    } else {
#line 746
      tmp = 1;
    }
  } else {
#line 746
    tmp = 1;
  }
#line 746
  tmp___0 = __builtin_expect((long )tmp, 0L);
#line 746
  if (tmp___0) {
#line 746
    __assert_rtn("conditionWait", "zebedee.c", 746, "condNum < COND_MAX && mutexNum < MUTEX_MAX");
  }
#line 753
  pthread_cond_wait(& Condition[condNum], & Mutex[mutexNum]);
#line 755
  return;
}
}
#line 763 "zebedee.c"
unsigned long threadPid(void) 
{ unsigned long tmp ;

  {
#line 769
  tmp = (unsigned long )getpid();
#line 769
  return (tmp);
}
}
#line 779 "zebedee.c"
unsigned long threadTid(void) 
{ unsigned long tmp ;

  {
#line 785
  tmp = (unsigned long )pthread_self();
#line 785
  return (tmp);
}
}
#line 799 "zebedee.c"
void incrActiveCount(int num ) 
{ 

  {
#line 802
  mutexLock(4);
#line 803
  ActiveCount += num;
#line 804
  if (ActiveCount == 0) {
#line 806
    conditionSignal(0);
  }
#line 808
  mutexUnlock(4);
#line 809
  return;
}
}
#line 818 "zebedee.c"
void waitForInactivity(void) 
{ 

  {
#line 822
  mutexLock(4);
#line 823
  while (ActiveCount) {
#line 825
    conditionWait(0, 4);
  }
#line 827
  mutexUnlock(4);
#line 831
  return;
}
}
#line 845 "zebedee.c"
void timestamp(char *timeBuf , int local ) 
{ time_t now ;
  struct tm *tmPtr ;

  {
#line 853
  mutexLock(0);
#line 854
  time(& now);
#line 855
  if (local) {
#line 857
    tmPtr = localtime((time_t const   *)(& now));
  } else {
#line 861
    tmPtr = gmtime((time_t const   *)(& now));
  }
#line 863
  strftime(timeBuf, 20UL, "%Y-%m-%d-%H:%M:%S", (struct tm  const  *)tmPtr);
#line 864
  mutexUnlock(0);
#line 865
  return;
}
}
#line 874 "zebedee.c"
void logToSystemLog(unsigned short level , char *msg ) 
{ int logLevel ;

  {
#line 909
  switch ((int )level) {
  case 0: 
#line 912
  logLevel = 3;
#line 913
  break;
  case 1: 
#line 916
  logLevel = 5;
#line 917
  break;
  case 2: 
#line 920
  logLevel = 6;
#line 921
  break;
  default: 
#line 924
  logLevel = 7;
#line 925
  break;
  }
#line 928
  syslog(logLevel, (char const   *)msg);
#line 930
  return;
}
}
#line 943 "zebedee.c"
void message(unsigned short level , int err , char *fmt  , ...) 
{ FILE *fp ;
  va_list args ;
  char timeBuf[20] ;
  char *timePtr ;
  char msgBuf[1024] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
#line 946
  fp = LogFileP;
#line 949
  timePtr = (char *)((void *)0);
#line 953
  if ((int )level > (int )LogLevel) {
#line 953
    return;
  } else {
#line 953
    if ((int )LogFileType == 0) {
#line 953
      return;
    }
  }
#line 961
  if (IsDetached == -1) {
#line 961
    if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 961
      return;
    }
  }
#line 963
  __builtin_va_start(args, fmt);
#line 965
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 967
    fp = __stderrp;
  }
#line 970
  if (TimestampLog) {
#line 972
    timestamp(timeBuf, 1);
#line 973
    timePtr = timeBuf;
  }
#line 985
  if (level) {
#line 985
    tmp = "";
  } else {
#line 985
    tmp = "ERROR: ";
  }
#line 985
  if (timePtr) {
#line 985
    tmp___0 = ": ";
  } else {
#line 985
    tmp___0 = "";
  }
#line 985
  if (timePtr) {
#line 985
    tmp___1 = (char const   *)timePtr;
  } else {
#line 985
    tmp___1 = "";
  }
#line 985
  tmp___2 = threadTid();
#line 985
  tmp___3 = threadPid();
#line 985
  snprintf(msgBuf, (unsigned long )sizeof(msgBuf), "%s(%lu/%lu): %s%s%.*s%s", Program,
           tmp___3 % 100000UL, tmp___2 % 100000UL, tmp___1, tmp___0, level, "          ",
           tmp);
#line 990
  tmp___4 = strlen((char const   *)(msgBuf));
#line 990
  tmp___5 = strlen((char const   *)(msgBuf));
#line 990
  vsnprintf(msgBuf + tmp___5, (size_t )sizeof(msgBuf) - tmp___4, (char const   *)fmt,
            args);
#line 993
  __builtin_va_end(args);
#line 995
  if (err) {
#line 997
    tmp___6 = strerror(err);
#line 997
    tmp___7 = strlen((char const   *)(msgBuf));
#line 997
    tmp___8 = strlen((char const   *)(msgBuf));
#line 997
    snprintf(msgBuf + tmp___8, (size_t )sizeof(msgBuf) - tmp___7, ": (%s)", tmp___6);
  }
#line 1003
  mutexLock(0);
#line 1005
  switch ((int )LogFileType) {
  case 2: 
#line 1008
  fprintf(fp, "%s\n", msgBuf);
#line 1009
  fflush(fp);
#line 1010
  break;
  case 1: 
#line 1013
  logToSystemLog(level, msgBuf);
#line 1014
  break;
  default: ;
#line 1017
  break;
  }
#line 1020
  mutexUnlock(0);
#line 1022
  return;
}
}
#line 1035 "zebedee.c"
static char *hex  =    (char *)"0123456789abcdef";
#line 1030 "zebedee.c"
void dumpData(char const   *prefix , unsigned char *data , unsigned short size ) 
{ unsigned short i ;
  unsigned char buf[128] ;
  unsigned char *bptr ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  int tmp___3 ;
  unsigned char *tmp___4 ;

  {
#line 1034
  bptr = (unsigned char *)((void *)0);
#line 1037
  if (! DumpData) {
#line 1037
    return;
  }
#line 1039
  bptr = buf;
#line 1040
  i = (unsigned short)0;
#line 1040
  while ((int )i < (int )size) {
#line 1042
    tmp___3 = isprint((int )(*(data + i)));
#line 1042
    if (tmp___3) {
#line 1044
      tmp = bptr;
#line 1044
      bptr ++;
#line 1044
      (*tmp) = (*(data + i));
#line 1045
      tmp___0 = bptr;
#line 1045
      bptr ++;
#line 1045
      (*tmp___0) = (unsigned char )' ';
    } else {
#line 1049
      tmp___1 = bptr;
#line 1049
      bptr ++;
#line 1049
      (*tmp___1) = (unsigned char )(*(hex + (((int )(*(data + i)) >> 4) & 15)));
#line 1050
      tmp___2 = bptr;
#line 1050
      bptr ++;
#line 1050
      (*tmp___2) = (unsigned char )(*(hex + ((int )(*(data + i)) & 15)));
    }
#line 1052
    tmp___4 = bptr;
#line 1052
    bptr ++;
#line 1052
    (*tmp___4) = (unsigned char )' ';
#line 1054
    if ((int )i % 16 == 15) {
#line 1056
      (*(bptr - 1)) = (unsigned char )'\000';
#line 1057
      message((unsigned short)5, 0, (char *)"%s %04hx %s", prefix, (int )i - 15, buf);
#line 1058
      bptr = buf;
    }
#line 1040
    i = (unsigned short )((int )i + 1);
  }
#line 1062
  if ((int )i % 16) {
#line 1064
    (*bptr) = (unsigned char )'\000';
#line 1065
    message((unsigned short)5, 0, (char *)"%s %04hx %s", prefix, (int )i - (int )i % 16,
            buf);
#line 1066
    bptr = buf;
  }
#line 1068
  return;
}
}
#line 1102
//extern int ( /* missing proto */  __builtin_bzero)() ;
#line 1084 "zebedee.c"
int readData(int fd , unsigned char *buffer___0 , unsigned short size ) 
{ int num ;
  char *bufP ;
  unsigned short total ;
  struct timeval delay ;
  fd_set testSet ;
  int ready ;
  int __fd ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 1087
  num = 0;
#line 1088
  bufP = (char *)((void *)0);
#line 1089
  total = (unsigned short)0;
#line 1094
  bufP = (char *)buffer___0;
#line 1095
  while (1) {
#line 1097
    if ((int )ReadTimeout != 0) {
#line 1099
      delay.tv_sec = (long )ReadTimeout;
#line 1100
      delay.tv_usec = 0;
#line 1102
      __builtin_bzero(& testSet, sizeof(testSet));
#line 1103
      while (1) {
#line 1103
        __fd = fd;
#line 1103
        testSet.fds_bits[(unsigned int )__fd / (sizeof(__int32_t ) * 8U)] |= 1 << (unsigned int )__fd % (sizeof(__int32_t ) * 8U);
#line 1103
        break;
      }
#line 1105
      ready = select(fd + 1, & testSet, (fd_set *)0, (fd_set *)0, & delay);
#line 1107
      if (ready == 0) {
#line 1109
        tmp = __error();
#line 1109
        message((unsigned short)0, (*tmp), (char *)"timed out reading data");
#line 1110
        return (-1);
      }
    }
#line 1114
    message((unsigned short)5, 0, (char *)"readData: receiving %d of %d", (int )size - (int )total,
            size);
#line 1115
    num = (int )recv(fd, (void *)(bufP + (int )total), (unsigned long )((int )size - (int )total),
                     0);
#line 1115
    if (num <= 0) {
#line 1117
      tmp___0 = __error();
#line 1117
      message((unsigned short)5, (*tmp___0), (char *)"readData: EOF or error");
#line 1119
      return (num);
    }
#line 1121
    message((unsigned short)5, 0, (char *)"readData: read %d byte(s)", num);
#line 1122
    total = (unsigned short )((int )total + (int )((unsigned short )num));
#line 1095
    if (! ((int )total < (int )size)) {
#line 1095
      break;
    }
  }
#line 1126
  return ((int )total);
}
}
#line 1139 "zebedee.c"
int readUShort(int fd , unsigned short *resultP ) 
{ int num ;
  unsigned char buffer___0[2] ;

  {
#line 1142
  num = 0;
#line 1145
  num = readData(fd, buffer___0, (unsigned short)2);
#line 1145
  if (num != 2) {
#line 1147
    return (num);
  }
#line 1150
  (*resultP) = (unsigned short )(((int )((unsigned short )buffer___0[0]) << 8) + (int )((unsigned short )buffer___0[1]));
#line 1151
  message((unsigned short)4, 0, (char *)"readUShort: read %hu", (*resultP));
#line 1153
  return (num);
}
}
#line 1163 "zebedee.c"
int writeData(int fd , unsigned char *buffer___0 , unsigned short size ) 
{ int num ;
  char *bufP ;
  unsigned short total ;
  int *tmp ;

  {
#line 1166
  num = 0;
#line 1167
  bufP = (char *)((void *)0);
#line 1168
  total = (unsigned short)0;
#line 1170
  bufP = (char *)buffer___0;
#line 1171
  while (1) {
#line 1173
    message((unsigned short)5, 0, (char *)"writeData: sending %d of %d", (int )size - (int )total,
            size);
#line 1174
    num = (int )send(fd, (void const   *)(bufP + (int )total), (unsigned long )((int )size - (int )total),
                     0);
#line 1174
    if (num <= 0) {
#line 1177
      tmp = __error();
#line 1177
      message((unsigned short)5, (*tmp), (char *)"writeData: EOF or error");
#line 1178
      return (num);
    }
#line 1180
    total = (unsigned short )((int )total + (int )((unsigned short )num));
#line 1181
    message((unsigned short)5, 0, (char *)"writeData: sent %d byte(s)", num);
#line 1171
    if (! ((int )total < (int )size)) {
#line 1171
      break;
    }
  }
#line 1185
  return ((int )total);
}
}
#line 1194 "zebedee.c"
int writeUShort(int fd , unsigned short value ) 
{ unsigned char buf[2] ;
  int tmp ;

  {
#line 1199
  message((unsigned short)4, 0, (char *)"writeUShort: writing %hu", value);
#line 1201
  buf[0] = (unsigned char )(((int )value >> 8) & 255);
#line 1202
  buf[1] = (unsigned char )((int )value & 255);
#line 1204
  tmp = writeData(fd, buf, (unsigned short)2);
#line 1204
  return (tmp);
}
}
#line 1213 "zebedee.c"
MsgBuf_t *makeMsgBuf(unsigned short maxSize , unsigned short cmpInfo ) 
{ MsgBuf_t *msg ;
  int *tmp ;

  {
#line 1219
  msg = (MsgBuf_t *)malloc((unsigned long )sizeof(MsgBuf_t ));
#line 1219
  if ((unsigned int )msg == (unsigned int )((void *)0)) {
#line 1221
    tmp = __error();
#line 1221
    message((unsigned short)0, (*tmp), (char *)"Failed to allocate message structure");
#line 1222
    return ((MsgBuf_t *)((void *)0));
  }
#line 1225
  msg->maxSize = maxSize;
#line 1226
  msg->size = (unsigned short)0;
#line 1227
  msg->cmpInfo = cmpInfo;
#line 1228
  msg->bfRead = (BFState_t *)((void *)0);
#line 1229
  msg->bfWrite = (BFState_t *)((void *)0);
#line 1230
  msg->readCount = 0UL;
#line 1231
  msg->bytesIn = 0UL;
#line 1232
  msg->expBytesIn = 0UL;
#line 1233
  msg->writeCount = 0UL;
#line 1234
  msg->bytesOut = 0UL;
#line 1235
  msg->expBytesOut = 0UL;
#line 1237
  return (msg);
}
}
#line 1246 "zebedee.c"
void freeMsgBuf(MsgBuf_t *msg ) 
{ 

  {
#line 1249
  if (msg) {
#line 1251
    if (msg->bfRead) {
#line 1251
      free((void *)msg->bfRead);
    }
#line 1252
    if (msg->bfWrite) {
#line 1252
      free((void *)msg->bfWrite);
    }
#line 1253
    free((void *)msg);
  }
#line 1255
  return;
}
}
#line 1264 "zebedee.c"
void getMsgBuf(MsgBuf_t *msg , void *buffer___0 , unsigned short size ) 
{ int tmp ;

  {
#line 1267
  if ((int )msg->size > (int )size) {
#line 1269
    message((unsigned short)0, 0, (char *)"supplied buffer too small for received message (%hu > %hu)",
            msg->size, size);
  }
#line 1272
  if ((int )size < (int )msg->size) {
#line 1272
    tmp = (int )size;
  } else {
#line 1272
    tmp = (int )msg->size;
  }
#line 1272
  memcpy(buffer___0, (void const   *)(msg->data), (unsigned long )tmp);
#line 1273
  return;
}
}
#line 1282 "zebedee.c"
void setMsgBuf(MsgBuf_t *msg , void *buffer___0 , unsigned short size ) 
{ 

  {
#line 1285
  msg->size = size;
#line 1286
  memcpy((void *)(msg->data), (void const   *)buffer___0, (unsigned long )size);
#line 1287
  return;
}
}
#line 1302 "zebedee.c"
int readMessage(int fd , MsgBuf_t *msg , unsigned short thisSize ) 
{ unsigned short hdr ;
  unsigned short size ;
  unsigned short flags ;
  int num ;
  unsigned long uncmpSize ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;

  {
#line 1308
  num = 0;
#line 1309
  uncmpSize = 16383UL;
#line 1314
  num = readUShort(fd, & hdr);
#line 1314
  if (num != 2) {
#line 1314
    return (num);
  }
#line 1318
  flags = (unsigned short )(((int )hdr >> 14) & 3);
#line 1319
  size = (unsigned short )((int )hdr & 16383);
#line 1323
  if (thisSize) {
#line 1323
    tmp = (int )size > (int )thisSize;
  } else {
#line 1323
    tmp = (int )size > (int )msg->maxSize;
  }
#line 1323
  if (tmp) {
#line 1325
    message((unsigned short)0, 0, (char *)"incoming message size too big (%hu > %hu)",
            size, msg->maxSize);
#line 1326
    return (-1);
  }
#line 1329
  msg->size = size;
#line 1330
  msg->readCount ++;
#line 1331
  msg->bytesIn += (unsigned long )size;
#line 1333
  if ((int )flags & 1) {
#line 1333
    tmp___0 = "compressed";
  } else {
#line 1333
    tmp___0 = "uncompressed";
  }
#line 1333
  if ((int )flags & 2) {
#line 1333
    tmp___1 = "encrypted";
  } else {
#line 1333
    tmp___1 = "unencrypted";
  }
#line 1333
  message((unsigned short)4, 0, (char *)"readMessage: message size = %hu, %s, %s",
          size, tmp___1, tmp___0);
#line 1339
  num = readData(fd, msg->tmp, size);
#line 1339
  if (num != (int )size) {
#line 1339
    return (num);
  }
#line 1343
  if ((int )flags & 2) {
#line 1345
    if ((unsigned int )msg->bfRead == (unsigned int )((void *)0)) {
#line 1347
      message((unsigned short)0, 0, (char *)"message with encryption flag sent with no encryption context");
#line 1348
      return (-1);
    }
#line 1351
    BF_cfb64_encrypt((unsigned char const   *)(msg->tmp), (msg->bfRead)->cryptBuf,
                     (long )size, (BF_KEY const   *)(& (msg->bfRead)->key), (msg->bfRead)->iVec,
                     & (msg->bfRead)->pos, 0);
#line 1354
    memcpy((void *)(msg->tmp), (void const   *)((msg->bfRead)->cryptBuf), (unsigned long )size);
  }
#line 1359
  if ((int )flags & 1) {
#line 1361
    switch (((int )msg->cmpInfo >> 8) & 255) {
    case 0: 
#line 1364
    num = uncompress(msg->data, & uncmpSize, (Bytef const   *)(msg->tmp), (unsigned long )size);
#line 1364
    if (num != 0) {
#line 1367
      tmp___2 = __error();
#line 1367
      message((unsigned short)0, (*tmp___2), (char *)"uncompressing message data (zlib status = %d)",
              num);
#line 1368
      tmp___3 = __error();
#line 1368
      (*tmp___3) = 0;
#line 1369
      return (-1);
    }
#line 1371
    break;
    case 1: 
#line 1375
    num = BZ2_bzBuffToBuffDecompress((char *)(msg->data), (unsigned int *)(& uncmpSize),
                                     (char *)(msg->tmp), (unsigned int )size, 0, 0);
#line 1375
    if (num != 0) {
#line 1381
      tmp___4 = __error();
#line 1381
      message((unsigned short)0, (*tmp___4), (char *)"uncompressing message data (bzip2 status = %d)",
              num);
#line 1382
      tmp___5 = __error();
#line 1382
      (*tmp___5) = 0;
#line 1383
      return (-1);
    }
#line 1385
    break;
    default: 
#line 1392
    message((unsigned short)0, 0, (char *)"invalid compression info in readMessage (%#hx)",
            msg->cmpInfo);
#line 1393
    return (-1);
#line 1394
    break;
    }
#line 1397
    size = (unsigned short )uncmpSize;
#line 1397
    msg->size = size;
#line 1398
    message((unsigned short)4, 0, (char *)"readMessage: uncompressed size = %hu",
            size);
  } else {
#line 1402
    memcpy((void *)(msg->data), (void const   *)(msg->tmp), (unsigned long )size);
  }
#line 1405
  msg->expBytesIn += (unsigned long )size;
#line 1407
  return ((int )size);
}
}
#line 1425 "zebedee.c"
int writeMessage(int fd , MsgBuf_t *msg ) 
{ unsigned short size ;
  unsigned short hdr ;
  int num ;
  unsigned long cmpSize ;
  unsigned short flags ;
  unsigned char *data ;
  int *tmp ;
  int *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 1428
  size = msg->size;
#line 1430
  num = 0;
#line 1431
  cmpSize = 16633UL;
#line 1432
  flags = (unsigned short)0;
#line 1433
  data = msg->data;
#line 1438
  if (msg->cmpInfo) {
#line 1438
    if ((int )msg->size > 32) {
#line 1440
      switch (((int )msg->cmpInfo >> 8) & 255) {
      case 0: 
#line 1443
      num = compress2(msg->tmp + 2, & cmpSize, (Byte const   *)(msg->data), (unsigned long )size,
                      (int )msg->cmpInfo & 255);
#line 1443
      if (num != 0) {
#line 1447
        tmp = __error();
#line 1447
        message((unsigned short)0, (*tmp), (char *)"compressing data (zlib status = %d)",
                num);
#line 1448
        cmpSize = (unsigned long )msg->size;
      }
#line 1450
      break;
      case 1: 
#line 1454
      num = BZ2_bzBuffToBuffCompress((char *)(msg->tmp + 2), (unsigned int *)(& cmpSize),
                                     (char *)(msg->data), (unsigned int )size, (int )msg->cmpInfo & 255,
                                     0, 0);
#line 1454
      if (num != 0) {
#line 1461
        tmp___0 = __error();
#line 1461
        message((unsigned short)0, (*tmp___0), (char *)"compressing data (bzip2 status = %d)",
                num);
      }
#line 1463
      break;
      default: 
#line 1471
      cmpSize = (unsigned long )size;
#line 1472
      break;
      }
#line 1477
      if (cmpSize < (unsigned long )size) {
#line 1479
        message((unsigned short)4, 0, (char *)"writeMessage: message compressed from %hu to %lu bytes",
                msg->size, cmpSize);
#line 1480
        data = msg->tmp + 2;
#line 1481
        size = (unsigned short )cmpSize;
#line 1482
        flags = (unsigned short )((int )flags | 1);
      }
    }
  }
#line 1488
  if (msg->bfWrite) {
#line 1490
    BF_cfb64_encrypt((unsigned char const   *)data, (msg->bfWrite)->cryptBuf, (long )size,
                     (BF_KEY const   *)(& (msg->bfWrite)->key), (msg->bfWrite)->iVec,
                     & (msg->bfWrite)->pos, 1);
#line 1493
    memcpy((void *)(msg->tmp + 2), (void const   *)((msg->bfWrite)->cryptBuf), (unsigned long )size);
#line 1494
    flags = (unsigned short )((int )flags | 2);
  } else {
#line 1498
    memmove((void *)(msg->tmp + 2), (void const   *)data, (unsigned long )size);
  }
#line 1503
  hdr = (unsigned short )((int )size | ((int )flags << 14));
#line 1505
  msg->tmp[0] = (unsigned char )(((int )hdr >> 8) & 255);
#line 1506
  msg->tmp[1] = (unsigned char )((int )hdr & 255);
#line 1510
  if ((int )flags & 1) {
#line 1510
    tmp___1 = "compressed";
  } else {
#line 1510
    tmp___1 = "uncompressed";
  }
#line 1510
  if ((int )flags & 2) {
#line 1510
    tmp___2 = "encrypted";
  } else {
#line 1510
    tmp___2 = "unencrypted";
  }
#line 1510
  message((unsigned short)4, 0, (char *)"writeMessage: message size = %hu, %s, %s",
          size, tmp___2, tmp___1);
#line 1514
  num = writeData(fd, msg->tmp, (unsigned short )((int )size + 2));
#line 1514
  if (num != (int )size + 2) {
#line 1514
    return (num);
  }
#line 1516
  msg->writeCount ++;
#line 1517
  msg->bytesOut += (unsigned long )size;
#line 1518
  msg->expBytesOut += (unsigned long )msg->size;
#line 1519
  return ((int )msg->size);
}
}
#line 1530 "zebedee.c"
int requestResponse(int fd , unsigned short request , unsigned short *responseP ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 1535
  tmp = writeUShort(fd, request);
#line 1535
  if (tmp != 2) {
#line 1537
    return (0);
  }
#line 1542
  tmp___0 = readUShort(fd, responseP);
#line 1542
  if (tmp___0 != 2) {
#line 1544
    return (0);
  }
#line 1547
  return (1);
}
}
#line 1563 "zebedee.c"
int getHostAddress(char const   *host , struct sockaddr_in *addrP , struct in_addr **addrList ,
                   unsigned long *maskP ) 
{ struct hostent *entry ;
  int result ;
  int count ;
  int i ;
  char *s ;
  char *hostCopy ;
  unsigned short bits ;
  size_t tmp ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___4 ;

  {
#line 1569
  entry = (struct hostent *)((void *)0);
#line 1570
  result = 1;
#line 1571
  count = 0;
#line 1572
  i = 0;
#line 1573
  s = (char *)((void *)0);
#line 1574
  hostCopy = (char *)((void *)0);
#line 1575
  bits = (unsigned short)32;
#line 1578
  mutexLock(0);
#line 1585
  s = strchr(host, '/');
#line 1585
  if ((unsigned int )s != (unsigned int )((void *)0)) {
#line 1587
    tmp = strlen(host);
#line 1587
    hostCopy = (char *)malloc(tmp + 1UL);
#line 1588
    if (! hostCopy) {
#line 1590
      tmp___1 = __error();
#line 1590
      (*tmp___1) = 0;
#line 1591
      result = 0;
    } else {
#line 1588
      tmp___2 = sscanf(host, "%[^/]/%hu", hostCopy, & bits);
#line 1588
      if (tmp___2 != 2) {
#line 1590
        tmp___1 = __error();
#line 1590
        (*tmp___1) = 0;
#line 1591
        result = 0;
      }
    }
#line 1593
    host = (char const   *)hostCopy;
#line 1594
    if (maskP) {
#line 1596
      if ((int )bits <= 0) {
#line 1596
        bits = (unsigned short)32;
      } else {
#line 1596
        if ((int )bits > 32) {
#line 1596
          bits = (unsigned short)32;
        }
      }
#line 1597
      (*maskP) = (unsigned long )_OSSwapInt32(4294967295U << (32 - (int )bits));
    }
  }
#line 1606
  addrP->sin_addr.s_addr = inet_addr(host);
#line 1606
  if (addrP->sin_addr.s_addr == 4294967295U) {
#line 1608
    entry = gethostbyname(host);
#line 1608
    if ((unsigned int )entry == (unsigned int )((void *)0)) {
#line 1610
      tmp___4 = __error();
#line 1610
      (*tmp___4) = 0;
#line 1611
      result = 0;
    } else {
#line 1615
      memcpy((void *)(& addrP->sin_addr), (void const   *)(*(entry->h_addr_list + 0)),
             (unsigned long )entry->h_length);
    }
  }
#line 1621
  if ((unsigned int )addrList != (unsigned int )((void *)0)) {
#line 1623
    if (entry) {
#line 1625
      count = 0;
#line 1625
      while ((*(entry->h_addr_list + count))) {
#line 1625
        count ++;
      }
#line 1629
      (*addrList) = (struct in_addr *)calloc((unsigned long )(count + 1), (unsigned long )sizeof(struct in_addr ));
#line 1630
      if ((unsigned int )(*addrList) == (unsigned int )((void *)0)) {
#line 1632
        result = 0;
      } else {
#line 1636
        i = 0;
#line 1636
        while (i < count) {
#line 1638
          memcpy((void *)((*addrList) + i), (void const   *)(*(entry->h_addr_list + i)),
                 (unsigned long )sizeof(struct in_addr ));
#line 1636
          i ++;
        }
#line 1640
        memset((void *)((*addrList) + i), 255, (unsigned long )sizeof(struct in_addr ));
      }
    } else {
#line 1645
      (*addrList) = (struct in_addr *)calloc(2UL, (unsigned long )sizeof(struct in_addr ));
#line 1646
      memcpy((void *)((*addrList) + 0), (void const   *)(& addrP->sin_addr), (unsigned long )sizeof(struct in_addr ));
#line 1647
      memset((void *)((*addrList) + 1), 255, (unsigned long )sizeof(struct in_addr ));
    }
  }
#line 1651
  if (hostCopy) {
#line 1653
    free((void *)hostCopy);
  }
#line 1656
  mutexUnlock(0);
#line 1658
  return (result);
}
}
#line 1668 "zebedee.c"
char *ipString(struct in_addr addr , char *buf ) 
{ unsigned long val ;

  {
#line 1671
  val = (unsigned long )_OSSwapInt32(addr.s_addr);
#line 1672
  sprintf(buf, "%d.%d.%d.%d", (val >> 24) & 255UL, (val >> 16) & 255UL, (val >> 8) & 255UL,
          val & 255UL);
#line 1677
  return (buf);
}
}
#line 1694 "zebedee.c"
int makeConnection(char const   *host , unsigned short port , int udpMode , int useProxy ,
                   struct sockaddr_in *fromAddrP , struct sockaddr_in *toAddrP ) 
{ int sfd ;
  struct sockaddr_in addr ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  __uint16_t tmp___8 ;
  int tmp___9 ;

  {
#line 1699
  sfd = -1;
#line 1705
  if ((unsigned int )host != (unsigned int )((void *)0)) {
#line 1705
    if ((int )port != 0) {
#line 1705
      tmp = 0;
    } else {
#line 1705
      tmp = 1;
    }
  } else {
#line 1705
    tmp = 1;
  }
#line 1705
  tmp___0 = __builtin_expect((long )tmp, 0L);
#line 1705
  if (tmp___0) {
#line 1705
    __assert_rtn("makeConnection", "zebedee.c", 1705, "host != NULL && port != 0");
  }
#line 1712
  if (! udpMode) {
#line 1712
    if (useProxy) {
#line 1716
      if (ProxyHost) {
#line 1716
        if (ProxyPort) {
#line 1718
          tmp___1 = proxyConnection(host, port, toAddrP);
#line 1718
          return (tmp___1);
        }
      }
    }
  }
#line 1724
  if (udpMode) {
#line 1724
    tmp___4 = 2;
  } else {
#line 1724
    tmp___4 = 1;
  }
#line 1724
  sfd = socket(2, tmp___4, 0);
#line 1724
  if (sfd < 0) {
#line 1726
    tmp___2 = __error();
#line 1726
    message((unsigned short)0, (*tmp___2), (char *)"socket creation failed");
#line 1727
    tmp___3 = __error();
#line 1727
    (*tmp___3) = 0;
#line 1728
    return (-1);
  }
#line 1745
  if (fromAddrP) {
#line 1745
    if (fromAddrP->sin_addr.s_addr) {
#line 1756
      memset((void *)(& addr), 0, (unsigned long )sizeof(addr));
#line 1757
      addr.sin_addr.s_addr = fromAddrP->sin_addr.s_addr;
#line 1758
      tmp___6 = bind(sfd, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                     sizeof(addr));
#line 1758
      if (tmp___6 < 0) {
#line 1760
        tmp___5 = __error();
#line 1760
        message((unsigned short)1, (*tmp___5), (char *)"WARNING: failed to set connection source address -- ignored");
      }
    }
  }
#line 1768
  memset((void *)(& addr), 0, (unsigned long )sizeof(addr));
#line 1769
  tmp___7 = getHostAddress(host, & addr, (struct in_addr **)((void *)0), (unsigned long *)((void *)0));
#line 1769
  if (! tmp___7) {
#line 1771
    message((unsigned short)0, 0, (char *)"can\'t resolve host or address \'%s\'",
            host);
#line 1772
    return (-1);
  }
#line 1774
  addr.sin_family = (unsigned char)2;
#line 1775
  tmp___8 = _OSSwapInt16(port);
#line 1775
  addr.sin_port = (unsigned short )((int )tmp___8);
#line 1777
  if (! udpMode) {
#line 1781
    setNoLinger(sfd);
#line 1785
    tmp___9 = connect(sfd, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                      sizeof(addr));
#line 1785
    if (tmp___9 < 0) {
#line 1787
      close(sfd);
#line 1788
      return (-1);
    }
  }
#line 1794
  if (toAddrP) {
#line 1796
    memcpy((void *)toAddrP, (void const   *)(& addr), (unsigned long )sizeof(addr));
  }
#line 1799
  return (sfd);
}
}
#line 1817 "zebedee.c"
int proxyConnection(char const   *host , unsigned short port , struct sockaddr_in *toAddrP ) 
{ int fd ;
  char buf[1025] ;
  int num ;
  int total ;
  char *bufP ;
  long tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  size_t tmp___2 ;
  ssize_t tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1821
  fd = -1;
#line 1823
  num = 0;
#line 1824
  total = 0;
#line 1825
  bufP = (char *)((void *)0);
#line 1828
  tmp = __builtin_expect((long )(! ((unsigned int )ProxyHost != (unsigned int )((void *)0))),
                         0L);
#line 1828
  if (tmp) {
#line 1828
    __assert_rtn("proxyConnection", "zebedee.c", 1828, "ProxyHost != NULL");
  }
#line 1832
  message((unsigned short)4, 0, (char *)"connecting to %s:%hu via proxy %s:%hu", host,
          port, ProxyHost, ProxyPort);
#line 1834
  fd = makeConnection((char const   *)ProxyHost, ProxyPort, 0, 0, (struct sockaddr_in *)((void *)0),
                      toAddrP);
#line 1834
  if (fd == -1) {
#line 1836
    tmp___0 = __error();
#line 1836
    message((unsigned short)0, (*tmp___0), (char *)"can\'t connect to proxy server at %s:%hu",
            ProxyHost, ProxyPort);
#line 1837
    return (-1);
  }
#line 1840
  message((unsigned short)5, 0, (char *)"connected to proxy");
#line 1851
  buf[1024] = (char )'\000';
#line 1852
  snprintf(buf, (unsigned long )(sizeof(buf) - 1U), "CONNECT %s:%hu HTTP/1.0\r\nUser-Agent: Zebedee\r\n\r\n",
           host, port);
#line 1853
  tmp___2 = strlen((char const   *)(buf));
#line 1853
  tmp___3 = send(fd, (void const   *)(buf), tmp___2, 0);
#line 1853
  if (tmp___3 <= 0L) {
#line 1855
    tmp___1 = __error();
#line 1855
    message((unsigned short)0, (*tmp___1), (char *)"failed writing to proxy server");
  }
#line 1858
  message((unsigned short)5, 0, (char *)"written connect string");
#line 1869
  bufP = buf;
#line 1870
  while (1) {
#line 1872
    num = (int )recv(fd, (void *)bufP, (unsigned long )(1024 - total), 0);
#line 1872
    if (num <= 0) {
#line 1874
      tmp___4 = __error();
#line 1874
      message((unsigned short)0, (*tmp___4), (char *)"failed reading response from proxy");
#line 1875
      close(fd);
#line 1876
      return (-1);
    }
#line 1878
    total += num;
#line 1879
    bufP += num;
#line 1880
    (*bufP) = (char )'\000';
#line 1881
    message((unsigned short)5, 0, (char *)"read %d bytes from proxy: %s", num, bufP - num);
#line 1870
    if (total < 1024) {
#line 1870
      tmp___5 = strncmp((char const   *)(bufP - 4), "\r\n\r\n", 4UL);
#line 1870
      if (! tmp___5) {
#line 1870
        break;
      }
    } else {
#line 1870
      break;
    }
  }
#line 1887
  tmp___6 = strncmp((char const   *)(buf), "HTTP/1.0 200", 12UL);
#line 1887
  if (tmp___6) {
#line 1889
    bufP = strchr((char const   *)(buf), '\r');
#line 1889
    if ((unsigned int )bufP != (unsigned int )((void *)0)) {
#line 1891
      (*bufP) = (char )'\000';
    }
#line 1893
    message((unsigned short)0, 0, (char *)"proxy server refused connection to %s:%h (%s)",
            host, port, buf);
#line 1894
    close(fd);
#line 1895
    return (-1);
  }
#line 1898
  message((unsigned short)4, 0, (char *)"connection via proxy successful");
#line 1900
  return (fd);
}
}
#line 1910 "zebedee.c"
int sendSpoofed(int fd , char *buf , int len , struct sockaddr_in *toAddrP , struct sockaddr_in *fromAddrP ) 
{ 

  {
#line 1971
  return (-1);
}
}
#line 1988 "zebedee.c"
int makeListener(unsigned short *portP , char *listenIp , int udpMode ) 
{ int sfd ;
  struct sockaddr_in addr ;
  int addrLen ;
  int trueVal ;
  char ipBuf[16] ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  __uint16_t tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  __uint16_t tmp___13 ;
  int *tmp___14 ;

  {
#line 1991
  sfd = -1;
#line 1993
  addrLen = (int )sizeof(addr);
#line 1994
  trueVal = 1;
#line 2000
  if (udpMode) {
#line 2000
    tmp___0 = 2;
  } else {
#line 2000
    tmp___0 = 1;
  }
#line 2000
  sfd = socket(2, tmp___0, 0);
#line 2000
  if (sfd < 0) {
#line 2002
    tmp = __error();
#line 2002
    message((unsigned short)0, (*tmp), (char *)"can\'t create listener socket");
    goto failure;
  }
#line 2008
  if (portP) {
#line 2008
    if ((*portP)) {
#line 2010
      tmp___1 = setsockopt(sfd, 65535, 4, (void const   *)((char *)(& trueVal)), sizeof(trueVal));
#line 2010
      if (tmp___1 < 0) {
#line 2012
        message((unsigned short)1, 0, (char *)"Warning: failed to set SO_REUSEADDR option on socket");
      }
    }
  }
#line 2016
  memset((void *)(& addr), 0, (unsigned long )sizeof(addr));
#line 2017
  addr.sin_addr.s_addr = 0U;
#line 2018
  if ((unsigned int )listenIp != (unsigned int )((void *)0)) {
#line 2020
    tmp___3 = getHostAddress((char const   *)listenIp, & addr, (struct in_addr **)((void *)0),
                             (unsigned long *)((void *)0));
#line 2020
    if (! tmp___3) {
#line 2022
      message((unsigned short)0, 0, (char *)"can\'t resolve listen address \'%s\'",
              listenIp);
    }
  }
#line 2025
  addr.sin_family = (unsigned char)2;
#line 2026
  if (portP) {
#line 2026
    tmp___5 = _OSSwapInt16((*portP));
#line 2026
    addr.sin_port = (unsigned short )((int )tmp___5);
  } else {
#line 2026
    addr.sin_port = (unsigned short)0;
  }
#line 2027
  tmp___6 = ipString(addr.sin_addr, ipBuf);
#line 2027
  message((unsigned short)5, 0, (char *)"listening on %s", tmp___6);
#line 2029
  tmp___8 = bind(sfd, (struct sockaddr  const  *)((struct sockaddr *)(& addr)), (unsigned int )addrLen);
#line 2029
  if (tmp___8 < 0) {
#line 2031
    tmp___7 = __error();
#line 2031
    message((unsigned short)0, (*tmp___7), (char *)"listener bind failed");
    goto failure;
  }
#line 2035
  if (! udpMode) {
#line 2037
    tmp___10 = listen(sfd, 5);
#line 2037
    if (tmp___10 < 0) {
#line 2039
      tmp___9 = __error();
#line 2039
      message((unsigned short)0, (*tmp___9), (char *)"listen failed");
      goto failure;
    }
  }
#line 2044
  if (portP) {
#line 2048
    memset((void *)(& addr), 0, (unsigned long )sizeof(addr));
#line 2049
    tmp___12 = getsockname(sfd, (struct sockaddr *)(& addr), (socklen_t *)(& addrLen));
#line 2049
    if (tmp___12) {
#line 2051
      tmp___11 = __error();
#line 2051
      message((unsigned short)0, (*tmp___11), (char *)"can\'t get local port number");
      goto failure;
    }
#line 2054
    tmp___13 = _OSSwapInt16(addr.sin_port);
#line 2054
    (*portP) = (unsigned short )((int )tmp___13);
  }
#line 2057
  return (sfd);
  failure: 
#line 2060
  if (sfd != -1) {
#line 2062
    close(sfd);
  }
#line 2064
  tmp___14 = __error();
#line 2064
  (*tmp___14) = -1;
#line 2065
  return (-1);
}
}
#line 2074 "zebedee.c"
void setNoLinger(int fd ) 
{ struct linger lingerVal ;
  int tmp ;

  {
#line 2079
  lingerVal.l_onoff = 0;
#line 2080
  lingerVal.l_linger = 0;
#line 2081
  tmp = setsockopt(fd, 65535, 128, (void const   *)((char *)(& lingerVal)), sizeof(lingerVal));
#line 2081
  if (tmp < 0) {
#line 2084
    message((unsigned short)1, 0, (char *)"Warning: failed to set SO_LINGER option on socket");
  }
#line 2086
  return;
}
}
#line 2094 "zebedee.c"
void setKeepAlive(int fd ) 
{ int trueVal ;
  int tmp ;

  {
#line 2097
  trueVal = 1;
#line 2099
  tmp = setsockopt(fd, 65535, 8, (void const   *)((char *)(& trueVal)), sizeof(trueVal));
#line 2099
  if (tmp < 0) {
#line 2102
    message((unsigned short)1, 0, (char *)"Warning: failed to set SO_KEEPALIVE option on socket");
  }
#line 2104
  return;
}
}
#line 2122 "zebedee.c"
int acceptConnection(int listenFd , char const   *host , int loop , unsigned short timeout ) 
{ struct sockaddr_in fromAddr ;
  struct sockaddr_in hostAddr ;
  int addrLen ;
  int serverFd ;
  struct timeval delay ;
  fd_set testSet ;
  int ready ;
  struct in_addr *addrList ;
  struct in_addr *addrPtr ;
  unsigned long mask ;
  char ipBuf[16] ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int __fd ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;

  {
#line 2128
  serverFd = -1;
#line 2132
  addrList = (struct in_addr *)((void *)0);
#line 2133
  addrPtr = (struct in_addr *)((void *)0);
#line 2134
  mask = 4294967295UL;
#line 2138
  memset((void *)(& hostAddr), 0, (unsigned long )sizeof(hostAddr));
#line 2139
  tmp___1 = strcmp(host, "*");
#line 2139
  if (tmp___1 == 0) {
#line 2141
    mask = 0UL;
#line 2142
    hostAddr.sin_addr.s_addr = 0U;
  } else {
#line 2146
    tmp___0 = getHostAddress(host, & hostAddr, & addrList, & mask);
#line 2146
    if (! tmp___0) {
#line 2148
      message((unsigned short)0, 0, (char *)"can\'t resolve host or address \'%s\'",
              host);
#line 2149
      close(serverFd);
#line 2150
      tmp = __error();
#line 2150
      (*tmp) = 0;
#line 2151
      return (-1);
    }
  }
#line 2155
  while (1) {
#line 2157
    message((unsigned short)3, 0, (char *)"waiting to accept connection");
#line 2159
    delay.tv_sec = (long )timeout;
#line 2160
    delay.tv_usec = 0;
#line 2162
    __builtin_bzero(& testSet, sizeof(testSet));
#line 2163
    while (1) {
#line 2163
      __fd = listenFd;
#line 2163
      testSet.fds_bits[(unsigned int )__fd / (sizeof(__int32_t ) * 8U)] |= 1 << (unsigned int )__fd % (sizeof(__int32_t ) * 8U);
#line 2163
      break;
    }
#line 2165
    ready = select(listenFd + 1, & testSet, (fd_set *)0, (fd_set *)0, & delay);
#line 2167
    if (ready == 0) {
#line 2169
      message((unsigned short)0, 0, (char *)"timed out waiting to accept connection");
      goto failure;
    }
#line 2175
    if (ready < 0) {
#line 2175
      tmp___4 = __error();
#line 2175
      if ((*tmp___4) != 4) {
#line 2177
        tmp___3 = __error();
#line 2177
        if ((*tmp___3) != 4) {
#line 2179
          tmp___2 = __error();
#line 2179
          message((unsigned short)0, (*tmp___2), (char *)"error in select waiting for client to accept connection");
          goto failure;
        } else {
#line 2184
          continue;
        }
      }
    }
#line 2190
    addrLen = (int )sizeof(struct sockaddr_in );
#line 2191
    memset((void *)(& fromAddr), 0, (unsigned long )sizeof(fromAddr));
#line 2192
    serverFd = accept(listenFd, (struct sockaddr *)(& fromAddr), (socklen_t *)(& addrLen));
#line 2192
    if (serverFd < 0) {
      goto failure;
    }
#line 2205
    if (((unsigned long )fromAddr.sin_addr.s_addr & mask) == ((unsigned long )hostAddr.sin_addr.s_addr & mask)) {
#line 2209
      break;
    } else {
#line 2215
      addrPtr = addrList;
#line 2215
      while (addrPtr->s_addr != 4294967295U) {
#line 2217
        if (((unsigned long )fromAddr.sin_addr.s_addr & mask) == ((unsigned long )addrPtr->s_addr & mask)) {
#line 2220
          break;
        }
#line 2215
        addrPtr ++;
      }
#line 2224
      if (addrPtr->s_addr != 4294967295U) {
#line 2227
        break;
      }
    }
#line 2231
    tmp___5 = ipString(fromAddr.sin_addr, ipBuf);
#line 2231
    message((unsigned short)1, 0, (char *)"Warning: connection from %s rejected, does not match server host %s",
            tmp___5, host);
#line 2233
    close(serverFd);
#line 2234
    tmp___6 = __error();
#line 2234
    (*tmp___6) = 0;
#line 2235
    if (! loop) {
      goto failure;
    }
  }
#line 2243
  if (addrList) {
#line 2245
    free((void *)addrList);
  }
#line 2248
  tmp___7 = ipString(fromAddr.sin_addr, ipBuf);
#line 2248
  message((unsigned short)3, 0, (char *)"accepted connection from %s", tmp___7);
#line 2255
  setNoLinger(serverFd);
#line 2256
  setKeepAlive(serverFd);
#line 2258
  return (serverFd);
  failure: 
#line 2261
  if (addrList) {
#line 2261
    free((void *)addrList);
  }
#line 2262
  return (-1);
}
}
#line 2272 "zebedee.c"
void headerSetUShort(unsigned char *hdrBuf , unsigned short value , int offset ) 
{ 

  {
#line 2275
  (*(hdrBuf + offset)) = (unsigned char )(((int )value >> 8) & 255);
#line 2276
  (*(hdrBuf + (offset + 1))) = (unsigned char )((int )value & 255);
#line 2277
  return;
}
}
#line 2286 "zebedee.c"
void headerSetULong(unsigned char *hdrBuf , unsigned long value , int offset ) 
{ 

  {
#line 2289
  (*(hdrBuf + offset)) = (unsigned char )((value >> 24) & 255UL);
#line 2290
  (*(hdrBuf + (offset + 1))) = (unsigned char )((value >> 16) & 255UL);
#line 2291
  (*(hdrBuf + (offset + 2))) = (unsigned char )((value >> 8) & 255UL);
#line 2292
  (*(hdrBuf + (offset + 3))) = (unsigned char )(value & 255UL);
#line 2293
  return;
}
}
#line 2302 "zebedee.c"
unsigned short headerGetUShort(unsigned char *hdrBuf , int offset ) 
{ 

  {
#line 2305
  return ((unsigned short )(((int )((unsigned short )(*(hdrBuf + offset))) << 8) + (int )((unsigned short )(*(hdrBuf + (offset + 1))))));
}
}
#line 2315 "zebedee.c"
unsigned long headerGetULong(unsigned char *hdrBuf , int offset ) 
{ 

  {
#line 2318
  return (((((unsigned long )(*(hdrBuf + offset)) << 24) + ((unsigned long )(*(hdrBuf + (offset + 1))) << 16)) + ((unsigned long )(*(hdrBuf + (offset + 2))) << 8)) + (unsigned long )(*(hdrBuf + (offset + 3))));
}
}
#line 2345 "zebedee.c"
BFState_t *setupBlowfish(char *keyStr , unsigned short keyBits ) 
{ BFState_t *bf ;
  unsigned char keyData[72] ;
  int keyBytes ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 2348
  bf = (BFState_t *)((void *)0);
#line 2355
  if ((int )keyBits == 0) {
#line 2355
    return ((BFState_t *)((void *)0));
  }
#line 2359
  bf = (BFState_t *)malloc((unsigned long )sizeof(BFState_t ));
#line 2359
  if ((unsigned int )bf == (unsigned int )((void *)0)) {
#line 2361
    tmp = __error();
#line 2361
    message((unsigned short)0, (*tmp), (char *)"out of memory allocating Blowfish state data");
#line 2362
    tmp___0 = __error();
#line 2362
    (*tmp___0) = 0;
#line 2363
    return ((BFState_t *)((void *)0));
  }
#line 2366
  keyBytes = (int )hexStrToBits(keyStr, keyBits, keyData);
#line 2368
  memset((void *)bf, 0, (unsigned long )sizeof(BFState_t ));
#line 2369
  BF_set_key(& bf->key, keyBytes, (unsigned char const   *)(keyData));
#line 2370
  memcpy((void *)(bf->iVec), (void const   *)"Time4Bed", 8UL);
#line 2371
  bf->pos = 0;
#line 2373
  return (bf);
}
}
#line 2410 "zebedee.c"
char *generateKey(void) 
{ SHA_INFO sha ;
  time_t now ;
  time_t tmp ;
  unsigned long pid ;
  unsigned long tmp___0 ;
  unsigned long tid ;
  unsigned long tmp___1 ;
  char *result ;
  size_t tmp___2 ;
  clock_t ticks ;
  struct tms tms ;
  int fd ;
  int tmp___4 ;
  char buffer___0[8] ;
  int i ;
  struct stat sbuf ;
  struct dirent *entryP ;
  DIR *dir ;
  DIR *tmp___5 ;
  char name[1024] ;
  char *tmp___6 ;

  {
#line 2414
  tmp = time((time_t *)((void *)0));
#line 2414
  now = tmp;
#line 2415
  tmp___0 = threadPid();
#line 2415
  pid = tmp___0;
#line 2416
  tmp___1 = threadTid();
#line 2416
  tid = tmp___1;
#line 2417
  result = (char *)((void *)0);
#line 2422
  if (PrivateKey) {
#line 2424
    tmp___2 = strlen((char const   *)PrivateKey);
#line 2424
    result = (char *)malloc(tmp___2 + 1UL);
#line 2424
    if ((unsigned int )result == (unsigned int )((void *)0)) {
#line 2426
      return ((char *)((void *)0));
    }
#line 2428
    strcpy(result, (char const   *)PrivateKey);
#line 2429
    return (result);
  }
#line 2438
  if (KeyGenCmd) {
#line 2438
    result = runKeyGenCommand(KeyGenCmd);
#line 2438
    if ((unsigned int )result != (unsigned int )((void *)0)) {
#line 2440
      return (result);
    }
  }
#line 2448
  sha_init(& sha);
#line 2462
  sha_update(& sha, (SHA_BYTE *)(& now), (int )sizeof(now));
#line 2463
  sha_update(& sha, (SHA_BYTE *)(& pid), (int )sizeof(pid));
#line 2464
  sha_update(& sha, (SHA_BYTE *)(& tid), (int )sizeof(tid));
#line 2585
  ticks = times(& tms);
#line 2587
  sha_update(& sha, (SHA_BYTE *)(& ticks), (int )sizeof(ticks));
#line 2588
  sha_update(& sha, (SHA_BYTE *)(& tms), (int )sizeof(tms));
#line 2591
  if ((int )KeyGenLevel == 2) {
#line 2608
    tmp___4 = open("/dev/urandom", 0);
#line 2608
    fd = tmp___4;
#line 2612
    if (fd == -1) {
#line 2612
      fd = open("/dev/random", 0);
#line 2612
      if (fd == -1) {
#line 2614
        message((unsigned short)3, 0, (char *)"can\'t open /dev/urandom or /dev/random -- downgrading keygenlevel");
#line 2615
        KeyGenLevel = (unsigned short )((int )KeyGenLevel - 1);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 2619
      i = 0;
#line 2619
      while (i < 10) {
#line 2621
        read(fd, (void *)(buffer___0), 8UL);
#line 2622
        sha_update(& sha, (SHA_BYTE *)(buffer___0), 8);
#line 2619
        i ++;
      }
#line 2624
      close(fd);
    }
  }
#line 2628
  if ((int )KeyGenLevel == 1) {
#line 2643
    tmp___5 = opendir("/proc");
#line 2643
    dir = tmp___5;
#line 2647
    if ((unsigned int )dir == (unsigned int )((void *)0)) {
#line 2649
      message((unsigned short)4, 0, (char *)"can\'t open /proc -- downgrading keygenlevel");
#line 2650
      KeyGenLevel = (unsigned short )((int )KeyGenLevel - 1);
    } else {
#line 2654
      while (1) {
#line 2654
        entryP = readdir(dir);
#line 2654
        if (! ((unsigned int )entryP != (unsigned int )((void *)0))) {
#line 2654
          break;
        }
#line 2656
        snprintf(name, (unsigned long )sizeof(name), "/proc/%s", entryP->d_name);
#line 2657
        stat((char const   *)(name), & sbuf);
#line 2658
        sha_update(& sha, (SHA_BYTE *)entryP, (int )sizeof(struct dirent ));
#line 2659
        sha_update(& sha, (SHA_BYTE *)(& sbuf), (int )sizeof(sbuf));
      }
#line 2661
      closedir(dir);
    }
  }
#line 2668
  sha_final(& sha);
#line 2672
  if (sha.digest[0] == 0U) {
#line 2672
    if (sha.digest[1] == 0U) {
#line 2672
      if (sha.digest[2] == 0U) {
#line 2672
        if (sha.digest[3] == 0U) {
#line 2672
          if (sha.digest[4] == 0U) {
#line 2676
            tmp___6 = generateKey();
#line 2676
            return (tmp___6);
          } else {
#line 2672
            if (sha.digest[4] == 1U) {
#line 2676
              tmp___6 = generateKey();
#line 2676
              return (tmp___6);
            }
          }
        }
      }
    }
  }
#line 2679
  result = (char *)malloc(41UL);
#line 2679
  if ((unsigned int )result == (unsigned int )((void *)0)) {
#line 2681
    return ((char *)((void *)0));
  }
#line 2684
  sprintf(result, "%08lx%08lx%08lx%08lx%08lx", (unsigned long )sha.digest[0], (unsigned long )sha.digest[1],
          (unsigned long )sha.digest[2], (unsigned long )sha.digest[3], (unsigned long )sha.digest[4]);
#line 2689
  return (result);
}
}
#line 2703 "zebedee.c"
char *runKeyGenCommand(char *keyGenCmd ) 
{ FILE *fp ;
  char buf[1024] ;
  char *result ;
  int *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___4 ;
  char const   *tmp___5 ;

  {
#line 2708
  result = (char *)((void *)0);
#line 2711
  if ((unsigned int )keyGenCmd == (unsigned int )((void *)0)) {
#line 2713
    message((unsigned short)3, 0, (char *)"no key generation command specified");
#line 2714
    return ((char *)((void *)0));
  }
#line 2717
  fp = popen((char const   *)keyGenCmd, "r");
#line 2717
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 2719
    tmp = __error();
#line 2719
    message((unsigned short)0, (*tmp), (char *)"failed to spawn key generation command \'%s\'",
            keyGenCmd);
#line 2720
    return ((char *)((void *)0));
  }
#line 2723
  tmp___4 = fgets(buf, 1024, fp);
#line 2723
  if ((unsigned int )tmp___4 != (unsigned int )((void *)0)) {
#line 2725
    tmp___2 = strlen((char const   *)(buf));
#line 2725
    result = (char *)malloc(tmp___2 + 1UL);
#line 2725
    if ((unsigned int )result != (unsigned int )((void *)0)) {
#line 2727
      tmp___0 = sscanf((char const   *)(buf), "%[0-9a-fA-F]", result);
#line 2727
      if (tmp___0 != 1) {
#line 2730
        free((void *)result);
#line 2731
        result = (char *)((void *)0);
      } else {
#line 2727
        tmp___1 = strlen((char const   *)(buf));
#line 2727
        if (tmp___1 < 10UL) {
#line 2730
          free((void *)result);
#line 2731
          result = (char *)((void *)0);
        }
      }
    }
  }
#line 2736
  fclose(fp);
#line 2738
  if (result) {
#line 2738
    tmp___5 = "not null";
  } else {
#line 2738
    tmp___5 = "NULL";
  }
#line 2738
  message((unsigned short)3, 0, (char *)"key generation result %s", tmp___5);
#line 2739
  return (result);
}
}
#line 2753 "zebedee.c"
void generateNonce(unsigned char *nonce ) 
{ SHA_INFO sha ;
  time_t now ;
  time_t tmp ;
  unsigned long pid ;
  unsigned long tmp___0 ;
  unsigned long tid ;
  unsigned long tmp___1 ;
  int i ;
  clock_t ticks ;
  struct tms tms ;

  {
#line 2757
  tmp = time((time_t *)((void *)0));
#line 2757
  now = tmp;
#line 2758
  tmp___0 = threadPid();
#line 2758
  pid = tmp___0;
#line 2759
  tmp___1 = threadTid();
#line 2759
  tid = tmp___1;
#line 2762
  sha_init(& sha);
#line 2764
  sha_update(& sha, (SHA_BYTE *)(& now), (int )sizeof(now));
#line 2765
  sha_update(& sha, (SHA_BYTE *)(& pid), (int )sizeof(pid));
#line 2766
  sha_update(& sha, (SHA_BYTE *)(& tid), (int )sizeof(tid));
#line 2793
  ticks = times(& tms);
#line 2795
  sha_update(& sha, (SHA_BYTE *)(& ticks), (int )sizeof(ticks));
#line 2796
  sha_update(& sha, (SHA_BYTE *)(& tms), (int )sizeof(tms));
#line 2800
  sha_final(& sha);
#line 2802
  i = 0;
#line 2802
  while (i < 8) {
#line 2804
    (*(nonce + i)) = (unsigned char )((sha.digest[i / 4] >> (i % 4) * 8) & 255U);
#line 2802
    i ++;
  }
#line 2806
  return;
}
}
#line 2815 "zebedee.c"
char *generateSessionKey(char *secretKey , unsigned char *cNonce , unsigned char *sNonce ,
                         unsigned short keyBits ) 
{ SHA_INFO sha ;
  unsigned short bits ;
  unsigned short nybbles ;
  unsigned short len ;
  unsigned short tmp ;
  char *result ;

  {
#line 2820
  bits = (unsigned short)0;
#line 2821
  nybbles = (unsigned short)0;
#line 2822
  tmp = (unsigned short )strlen((char const   *)secretKey);
#line 2822
  len = tmp;
#line 2823
  result = (char *)((void *)0);
#line 2826
  bits = (unsigned short)0;
#line 2826
  while ((int )bits < (int )keyBits) {
#line 2828
    sha_init(& sha);
#line 2829
    sha_update(& sha, cNonce, 8);
#line 2830
    sha_update(& sha, sNonce, 8);
#line 2831
    nybbles = (unsigned short )((int )bits / 4);
#line 2832
    if ((int )nybbles > (int )len) {
#line 2834
      nybbles = (unsigned short )((int )nybbles % (int )len);
    }
#line 2836
    sha_update(& sha, (SHA_BYTE *)(secretKey + (int )nybbles), (int )len - (int )nybbles);
#line 2837
    sha_final(& sha);
#line 2839
    result = (char *)realloc((void *)result, (unsigned long )(((int )bits / 160 + 1) * 40 + 1));
#line 2839
    if ((unsigned int )result == (unsigned int )((void *)0)) {
#line 2841
      return ((char *)((void *)0));
    }
#line 2844
    sprintf(result + ((int )bits / 160) * 40, "%08lx%08lx%08lx%08lx%08lx", (unsigned long )sha.digest[0],
            (unsigned long )sha.digest[1], (unsigned long )sha.digest[2], (unsigned long )sha.digest[3],
            (unsigned long )sha.digest[4]);
#line 2826
    bits = (unsigned short )((int )bits + 160);
  }
#line 2851
  return (result);
}
}
#line 2865 "zebedee.c"
unsigned short hexStrToBits(char *hexStr , unsigned short bits , unsigned char *bitVec ) 
{ int i ;
  unsigned char byte ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 2870
  tmp = (int )strlen((char const   *)hexStr);
#line 2870
  len = tmp;
#line 2873
  memset((void *)bitVec, 0, 72UL);
#line 2877
  if ((int )((unsigned int )((int )bits + 3) / 4U) < len) {
#line 2879
    len = (int )((unsigned int )((int )bits + 3) / 4U);
  }
#line 2884
  if (len > 144) {
#line 2886
    len = 144;
  }
#line 2891
  i = 0;
#line 2891
  while (i < len) {
#line 2893
    byte = (unsigned char )'\000';
#line 2897
    if ((int )(*(hexStr + i)) >= 48) {
#line 2897
      if ((int )(*(hexStr + i)) <= 57) {
#line 2899
        byte = (unsigned char )(((int )(*(hexStr + i)) - 48) << 4);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 2901
      tmp___1 = toupper((int )(*(hexStr + i)));
#line 2901
      if (tmp___1 >= 65) {
#line 2901
        tmp___2 = toupper((int )(*(hexStr + i)));
#line 2901
        if (tmp___2 <= 70) {
#line 2903
          tmp___0 = toupper((int )(*(hexStr + i)));
#line 2903
          byte = (unsigned char )(((tmp___0 - 65) + 10) << 4);
        }
      }
    }
#line 2908
    if (i + 1 < len) {
#line 2910
      if ((int )(*(hexStr + (i + 1))) >= 48) {
#line 2910
        if ((int )(*(hexStr + (i + 1))) <= 57) {
#line 2912
          byte = (unsigned char )((int )byte | ((int )(*(hexStr + (i + 1))) - 48));
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 2914
        tmp___4 = toupper((int )(*(hexStr + (i + 1))));
#line 2914
        if (tmp___4 >= 65) {
#line 2914
          tmp___5 = toupper((int )(*(hexStr + (i + 1))));
#line 2914
          if (tmp___5 <= 70) {
#line 2916
            tmp___3 = toupper((int )(*(hexStr + (i + 1))));
#line 2916
            byte = (unsigned char )((int )byte | ((tmp___3 - 65) + 10));
          }
        }
      }
    }
#line 2920
    (*(bitVec + i / 2)) = byte;
#line 2891
    i += 2;
  }
#line 2925
  return ((unsigned short )(i / 2));
}
}
#line 2940 "zebedee.c"
char *diffieHellman(char *genStr , char *modStr , char *expStr ) 
{ mpz_t gen ;
  mpz_t mod ;
  mpz_t exp ;
  mpz_t key ;
  char *keyStr ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 2944
  keyStr = (char *)((void *)0);
#line 2947
  if ((unsigned int )genStr == (unsigned int )((void *)0)) {
#line 2947
    genStr = (char *)"2";
  } else {
#line 2947
    if ((int )(*genStr) == 0) {
#line 2947
      genStr = (char *)"2";
    }
  }
#line 2948
  if ((unsigned int )modStr == (unsigned int )((void *)0)) {
#line 2948
    modStr = (char *)"f488fd584e49dbcd20b49de49107366b336c380d451d0f7c88b31c7c5b2d8ef6f3c923c043f0a55b188d8ebb558cb85d38d334fd7c175743a31d186cde33212cb52aff3ce1b1294018118d7c84a70a72d686c40319c807297aca950cd9969fabd00a509b0246d3083d66a45d419f9c7cbd894b221926baaba25ec355e92f78c7";
  } else {
#line 2948
    if ((int )(*modStr) == 0) {
#line 2948
      modStr = (char *)"f488fd584e49dbcd20b49de49107366b336c380d451d0f7c88b31c7c5b2d8ef6f3c923c043f0a55b188d8ebb558cb85d38d334fd7c175743a31d186cde33212cb52aff3ce1b1294018118d7c84a70a72d686c40319c807297aca950cd9969fabd00a509b0246d3083d66a45d419f9c7cbd894b221926baaba25ec355e92f78c7";
    }
  }
#line 2950
  gen = huge_from_string(genStr, (char **)((void *)0), 16);
#line 2951
  mod = huge_from_string(modStr, (char **)((void *)0), 16);
#line 2952
  exp = huge_from_string(expStr, (char **)((void *)0), 16);
#line 2955
  key = huge_powmod(gen, exp, mod);
#line 2957
  keyStr = huge_format(key, 16);
#line 2959
  if (gen) {
#line 2959
    if (gen->size >= 0L) {
#line 2959
      tmp = gen->size;
    } else {
#line 2959
      tmp = - gen->size;
    }
#line 2959
    memset((void *)gen, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp);
#line 2959
    free((void *)gen);
  }
#line 2959
  gen = (Huge *)0;
#line 2960
  if (exp) {
#line 2960
    if (exp->size >= 0L) {
#line 2960
      tmp___0 = exp->size;
    } else {
#line 2960
      tmp___0 = - exp->size;
    }
#line 2960
    memset((void *)exp, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___0);
#line 2960
    free((void *)exp);
  }
#line 2960
  exp = (Huge *)0;
#line 2961
  if (mod) {
#line 2961
    if (mod->size >= 0L) {
#line 2961
      tmp___1 = mod->size;
    } else {
#line 2961
      tmp___1 = - mod->size;
    }
#line 2961
    memset((void *)mod, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___1);
#line 2961
    free((void *)mod);
  }
#line 2961
  mod = (Huge *)0;
#line 2962
  if (key) {
#line 2962
    if (key->size >= 0L) {
#line 2962
      tmp___2 = key->size;
    } else {
#line 2962
      tmp___2 = - key->size;
    }
#line 2962
    memset((void *)key, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___2);
#line 2962
    free((void *)key);
  }
#line 2962
  key = (Huge *)0;
#line 2964
  return (keyStr);
}
}
#line 2974 "zebedee.c"
void makeChallenge(unsigned char *challenge ) 
{ struct tms tms ;
  clock_t ticks ;
  clock_t tmp ;

  {
#line 2982
  tmp = times(& tms);
#line 2982
  ticks = tmp;
#line 2983
  memcpy((void *)challenge, (void const   *)(& ticks), 4UL);
#line 2985
  return;
}
}
#line 2993 "zebedee.c"
void challengeAnswer(unsigned char *challenge ) 
{ int i ;

  {
#line 2998
  i = 0;
#line 2998
  while (i < 4) {
#line 3000
    (*(challenge + i)) = (unsigned char )((int )(*(challenge + i)) ^ 42);
#line 2998
    i ++;
  }
#line 3002
  return;
}
}
#line 3014 "zebedee.c"
int clientPerformChallenge(int serverFd , MsgBuf_t *msg ) 
{ unsigned char challenge[4] ;
  unsigned char myChallenge[4] ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 3023
  message((unsigned short)3, 0, (char *)"reading challenge from server");
#line 3025
  tmp___0 = readMessage(serverFd, msg, (unsigned short)4);
#line 3025
  if (tmp___0 <= 0) {
#line 3027
    tmp = __error();
#line 3027
    message((unsigned short)0, (*tmp), (char *)"failed to read challenge from server");
#line 3028
    return (0);
  }
#line 3030
  getMsgBuf(msg, (void *)(challenge), (unsigned short)4);
#line 3032
  message((unsigned short)3, 0, (char *)"read challenge");
#line 3036
  challengeAnswer(challenge);
#line 3038
  message((unsigned short)3, 0, (char *)"writing challenge response");
#line 3040
  setMsgBuf(msg, (void *)(challenge), (unsigned short)4);
#line 3041
  tmp___2 = writeMessage(serverFd, msg);
#line 3041
  if (tmp___2 != 4) {
#line 3043
    tmp___1 = __error();
#line 3043
    message((unsigned short)0, (*tmp___1), (char *)"failed writing challenge response to server");
#line 3044
    return (0);
  }
#line 3046
  message((unsigned short)3, 0, (char *)"wrote challenge response");
#line 3050
  makeChallenge(myChallenge);
#line 3052
  message((unsigned short)3, 0, (char *)"sending challenge to server");
#line 3054
  setMsgBuf(msg, (void *)(myChallenge), (unsigned short)4);
#line 3055
  tmp___4 = writeMessage(serverFd, msg);
#line 3055
  if (tmp___4 != 4) {
#line 3057
    tmp___3 = __error();
#line 3057
    message((unsigned short)0, (*tmp___3), (char *)"failed writing challenge to server");
#line 3058
    return (0);
  }
#line 3060
  message((unsigned short)3, 0, (char *)"wrote challenge");
#line 3062
  message((unsigned short)3, 0, (char *)"reading challenge response from server");
#line 3064
  tmp___6 = readMessage(serverFd, msg, (unsigned short)4);
#line 3064
  if (tmp___6 <= 0) {
#line 3066
    tmp___5 = __error();
#line 3066
    message((unsigned short)0, (*tmp___5), (char *)"failed to read challenge response from server");
#line 3067
    return (0);
  }
#line 3069
  getMsgBuf(msg, (void *)(challenge), (unsigned short)4);
#line 3071
  message((unsigned short)3, 0, (char *)"read challenge response");
#line 3075
  challengeAnswer(myChallenge);
#line 3077
  tmp___7 = memcmp((void const   *)(challenge), (void const   *)(myChallenge), 4UL);
#line 3077
  if (tmp___7 != 0) {
#line 3079
    message((unsigned short)0, 0, (char *)"server responded incorrectly to challenge");
#line 3080
    return (0);
  }
#line 3083
  memset((void *)(challenge), 0, 4UL);
#line 3084
  memset((void *)(myChallenge), 0, 4UL);
#line 3086
  return (1);
}
}
#line 3099 "zebedee.c"
int serverPerformChallenge(int clientFd , MsgBuf_t *msg ) 
{ unsigned char challenge[4] ;
  unsigned char myChallenge[4] ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
#line 3108
  makeChallenge(myChallenge);
#line 3110
  message((unsigned short)3, 0, (char *)"sending challenge to client");
#line 3112
  setMsgBuf(msg, (void *)(myChallenge), (unsigned short)4);
#line 3113
  tmp___0 = writeMessage(clientFd, msg);
#line 3113
  if (tmp___0 != 4) {
#line 3115
    tmp = __error();
#line 3115
    message((unsigned short)0, (*tmp), (char *)"failed writing challenge to client");
#line 3116
    return (0);
  }
#line 3118
  message((unsigned short)3, 0, (char *)"wrote challenge");
#line 3120
  message((unsigned short)3, 0, (char *)"reading challenge response from client");
#line 3122
  tmp___2 = readMessage(clientFd, msg, (unsigned short)4);
#line 3122
  if (tmp___2 <= 0) {
#line 3124
    tmp___1 = __error();
#line 3124
    message((unsigned short)0, (*tmp___1), (char *)"failed to read challenge response from client");
#line 3125
    return (0);
  }
#line 3127
  getMsgBuf(msg, (void *)(challenge), (unsigned short)4);
#line 3129
  message((unsigned short)3, 0, (char *)"read challenge response");
#line 3133
  challengeAnswer(myChallenge);
#line 3135
  tmp___3 = memcmp((void const   *)(challenge), (void const   *)(myChallenge), 4UL);
#line 3135
  if (tmp___3 != 0) {
#line 3137
    message((unsigned short)0, 0, (char *)"client responded incorrectly to challenge");
#line 3138
    return (0);
  }
#line 3143
  message((unsigned short)3, 0, (char *)"reading challenge from client");
#line 3145
  tmp___5 = readMessage(clientFd, msg, (unsigned short)4);
#line 3145
  if (tmp___5 <= 0) {
#line 3147
    tmp___4 = __error();
#line 3147
    message((unsigned short)0, (*tmp___4), (char *)"failed to read challenge from client");
#line 3148
    return (0);
  }
#line 3150
  getMsgBuf(msg, (void *)(challenge), (unsigned short)4);
#line 3152
  message((unsigned short)3, 0, (char *)"read challenge");
#line 3156
  challengeAnswer(challenge);
#line 3158
  message((unsigned short)3, 0, (char *)"writing challenge response");
#line 3160
  setMsgBuf(msg, (void *)(challenge), (unsigned short)4);
#line 3161
  tmp___7 = writeMessage(clientFd, msg);
#line 3161
  if (tmp___7 != 4) {
#line 3163
    tmp___6 = __error();
#line 3163
    message((unsigned short)0, (*tmp___6), (char *)"failed writing challenge response to client");
#line 3164
    return (0);
  }
#line 3166
  message((unsigned short)3, 0, (char *)"wrote challenge response");
#line 3167
  memset((void *)(challenge), 0, 4UL);
#line 3169
  return (1);
}
}
#line 3184 "zebedee.c"
void freeKeyInfo(KeyInfo_t *info ) 
{ size_t tmp ;

  {
#line 3187
  if (info->key) {
#line 3189
    tmp = strlen((char const   *)info->key);
#line 3189
    memset((void *)info->key, 0, tmp);
#line 3190
    free((void *)info->key);
  }
#line 3192
  free((void *)info);
#line 3193
  return;
}
}
#line 3213 "zebedee.c"
char *findKeyByToken(KeyInfo_t *list , unsigned long token ) 
{ KeyInfo_t *ptr ;
  char *found ;
  KeyInfo_t *tmp ;
  time_t now ;
  char *result ;
  size_t tmp___0 ;
  int *tmp___2 ;
  size_t tmp___3 ;

  {
#line 3216
  ptr = (KeyInfo_t *)((void *)0);
#line 3217
  found = (char *)((void *)0);
#line 3218
  tmp = (KeyInfo_t *)((void *)0);
#line 3220
  result = (char *)((void *)0);
#line 3225
  if (SharedKey) {
#line 3227
    tmp___0 = strlen((char const   *)SharedKey);
#line 3227
    result = (char *)malloc(tmp___0 + 1UL);
#line 3227
    if ((unsigned int )result == (unsigned int )((void *)0)) {
#line 3229
      return ((char *)((void *)0));
    }
#line 3231
    strcpy(result, (char const   *)SharedKey);
#line 3232
    return (result);
  }
#line 3240
  if (SharedKeyGenCmd) {
#line 3240
    result = runKeyGenCommand(SharedKeyGenCmd);
#line 3240
    if ((unsigned int )result != (unsigned int )((void *)0)) {
#line 3242
      return (result);
    }
  }
#line 3245
  if (token == 0UL) {
#line 3245
    return ((char *)((void *)0));
  } else {
#line 3245
    if (token == 4294967295UL) {
#line 3245
      return ((char *)((void *)0));
    }
  }
#line 3247
  time(& now);
#line 3249
  mutexLock(1);
#line 3251
  ptr = list;
#line 3251
  while (ptr) {
#line 3255
    if (ptr->expiry) {
#line 3255
      if (now > ptr->expiry) {
#line 3259
        (ptr->prev)->next = ptr->next;
#line 3260
        if (ptr->next) {
#line 3262
          (ptr->next)->prev = ptr->prev;
        }
#line 3264
        tmp = ptr;
#line 3265
        ptr = ptr->prev;
#line 3266
        freeKeyInfo(tmp);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 3268
      if (! found) {
#line 3268
        if (ptr->token == token) {
#line 3272
          tmp___3 = strlen((char const   *)ptr->key);
#line 3272
          found = (char *)malloc(tmp___3 + 1UL);
#line 3272
          if ((unsigned int )found == (unsigned int )((void *)0)) {
#line 3274
            tmp___2 = __error();
#line 3274
            message((unsigned short)0, (*tmp___2), (char *)"Out of memory allocating copy of key");
          } else {
#line 3278
            strcpy(found, (char const   *)ptr->key);
          }
        }
      }
    }
#line 3251
    ptr = ptr->next;
  }
#line 3285
  mutexUnlock(1);
#line 3287
  return (found);
}
}
#line 3298 "zebedee.c"
void addKeyInfoToList(KeyInfo_t *list , unsigned long token , char *key ) 
{ KeyInfo_t *new ;
  KeyInfo_t *ptr ;
  int *tmp ;
  size_t tmp___1 ;

  {
#line 3301
  new = (KeyInfo_t *)((void *)0);
#line 3302
  ptr = (KeyInfo_t *)((void *)0);
#line 3305
  mutexLock(1);
#line 3307
  new = (KeyInfo_t *)malloc((unsigned long )sizeof(KeyInfo_t ));
#line 3307
  if ((unsigned int )new == (unsigned int )((void *)0)) {
#line 3310
    tmp = __error();
#line 3310
    message((unsigned short)0, (*tmp), (char *)"Out of memory allocating key info element");
  } else {
#line 3307
    tmp___1 = strlen((char const   *)key);
#line 3307
    new->key = (char *)malloc(tmp___1 + 1UL);
#line 3307
    if ((unsigned int )new->key == (unsigned int )((void *)0)) {
#line 3310
      tmp = __error();
#line 3310
      message((unsigned short)0, (*tmp), (char *)"Out of memory allocating key info element");
    } else {
#line 3314
      strcpy(new->key, (char const   *)key);
#line 3315
      new->token = token;
#line 3316
      new->next = (struct KeyInfo_s *)((void *)0);
#line 3317
      time(& new->expiry);
#line 3318
      new->expiry += (time_t )KeyLifetime;
#line 3320
      ptr = list;
#line 3320
      while (ptr->next) {
#line 3320
        ptr = ptr->next;
      }
#line 3322
      ptr->next = new;
#line 3323
      new->prev = ptr;
    }
  }
#line 3326
  mutexUnlock(1);
#line 3327
  return;
}
}
#line 3339 "zebedee.c"
static unsigned long nextToken  =    0UL;
#line 3336 "zebedee.c"
unsigned long generateToken(KeyInfo_t *list , unsigned long oldToken ) 
{ unsigned long token ;
  char *key ;
  unsigned long tmp ;
  time_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 3340
  token = 0UL;
#line 3341
  key = (char *)((void *)0);
#line 3344
  if ((int )KeyLifetime == 0) {
#line 3344
    return (0UL);
  }
#line 3346
  mutexLock(2);
#line 3350
  if (nextToken == 0UL) {
#line 3352
    tmp = threadPid();
#line 3352
    tmp___0 = time((time_t *)((void *)0));
#line 3352
    srand((unsigned int )((int )tmp + (int )tmp___0));
#line 3353
    tmp___1 = rand();
#line 3353
    nextToken = (unsigned long )((tmp___1 & 65535) << 16);
#line 3354
    tmp___2 = rand();
#line 3354
    nextToken |= (unsigned long )(tmp___2 & 65535);
  }
#line 3357
  while (token == 0UL) {
#line 3359
    nextToken = (nextToken + 1UL) & 4294967295UL;
#line 3363
    if (nextToken == 0UL) {
#line 3365
      continue;
    } else {
#line 3363
      if (nextToken == 4294967295UL) {
#line 3365
        continue;
      } else {
#line 3363
        if (nextToken == oldToken) {
#line 3365
          continue;
        }
      }
    }
#line 3370
    key = findKeyByToken(list, nextToken);
#line 3370
    if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 3372
      free((void *)key);
#line 3373
      continue;
    }
#line 3378
    token = nextToken;
  }
#line 3381
  mutexUnlock(2);
#line 3383
  return (token);
}
}
#line 3393 "zebedee.c"
unsigned long getCurrentToken(void) 
{ KeyInfo_t *ptr ;
  time_t now ;

  {
#line 3396
  ptr = (KeyInfo_t *)((void *)0);
#line 3399
  if (CurrentToken == 0UL) {
#line 3399
    return (CurrentToken);
  } else {
#line 3399
    if (CurrentToken == 4294967295UL) {
#line 3399
      return (CurrentToken);
    }
  }
#line 3401
  time(& now);
#line 3403
  mutexLock(1);
#line 3405
  ptr = & ClientKeyList;
#line 3405
  while (ptr) {
#line 3407
    if (ptr->token == CurrentToken) {
#line 3411
      if (ptr->expiry) {
#line 3411
        if (now > ptr->expiry - 10L) {
#line 3413
          CurrentToken = 4294967295UL;
        }
      }
#line 3415
      break;
    }
#line 3405
    ptr = ptr->next;
  }
#line 3419
  mutexUnlock(1);
#line 3421
  return (CurrentToken);
}
}
#line 3438 "zebedee.c"
int spawnCommand(unsigned short port , char *cmdFormat ) 
{ char *shell ;
  char cmdBuf[1024] ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 3467
  shell = (char *)"/bin/sh";
#line 3470
  snprintf(cmdBuf, (unsigned long )sizeof(cmdBuf), (char const   *)cmdFormat, (int )port);
#line 3472
  shell = getenv("SHELL");
#line 3472
  if ((unsigned int )shell == (unsigned int )((void *)0)) {
#line 3474
    shell = (char *)"/bin/sh";
  } else {
#line 3472
    if ((int )(*shell) == 0) {
#line 3474
      shell = (char *)"/bin/sh";
    }
  }
#line 3477
  tmp = fork();
#line 3477
  switch (tmp) {
  case -1: 
#line 3480
  tmp___0 = __error();
#line 3480
  message((unsigned short)0, (*tmp___0), (char *)"fork failed");
#line 3481
  return (0);
#line 3482
  break;
  case 0: 
#line 3485
  execl((char const   *)shell, (char const   *)shell, "-c", cmdBuf, (void *)0);
#line 3486
  tmp___1 = __error();
#line 3486
  message((unsigned short)0, (*tmp___1), (char *)"failed to exec \'%s -c \"%s\"\'",
          shell, cmdBuf);
#line 3487
  break;
  default: ;
#line 3490
  break;
  }
#line 3494
  return (1);
}
}
#line 3516 "zebedee.c"
int filterLoop(int localFd , int remoteFd , MsgBuf_t *msgBuf , struct sockaddr_in *toAddrP ,
               struct sockaddr_in *fromAddrP , int replyFd , int udpMode ) 
{ fd_set testSet ;
  int ready ;
  int maxTestFd ;
  int tmp ;
  int num ;
  int status ;
  struct timeval delay ;
  int __fd ;
  int __fd___0 ;
  struct timeval *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 3522
  ready = 0;
#line 3523
  if (localFd > remoteFd) {
#line 3523
    tmp = localFd + 1;
  } else {
#line 3523
    tmp = remoteFd + 1;
  }
#line 3523
  maxTestFd = tmp;
#line 3524
  num = 0;
#line 3525
  status = 0;
#line 3529
  while (1) {
#line 3533
    if (udpMode) {
#line 3533
      delay.tv_sec = (long )UdpTimeout;
    } else {
#line 3533
      delay.tv_sec = (long )TcpTimeout;
    }
#line 3534
    delay.tv_usec = 0;
#line 3538
    __builtin_bzero(& testSet, sizeof(testSet));
#line 3539
    if (localFd >= 0) {
#line 3541
      while (1) {
#line 3541
        __fd = localFd;
#line 3541
        testSet.fds_bits[(unsigned int )__fd / (sizeof(__int32_t ) * 8U)] |= 1 << (unsigned int )__fd % (sizeof(__int32_t ) * 8U);
#line 3541
        break;
      }
    }
#line 3543
    if (remoteFd >= 0) {
#line 3545
      while (1) {
#line 3545
        __fd___0 = remoteFd;
#line 3545
        testSet.fds_bits[(unsigned int )__fd___0 / (sizeof(__int32_t ) * 8U)] |= 1 << (unsigned int )__fd___0 % (sizeof(__int32_t ) * 8U);
#line 3545
        break;
      }
    }
#line 3550
    if (delay.tv_sec) {
#line 3550
      tmp___0 = & delay;
    } else {
#line 3550
      tmp___0 = (struct timeval *)((void *)0);
    }
#line 3550
    ready = select(maxTestFd, & testSet, (fd_set *)0, (fd_set *)0, tmp___0);
#line 3557
    if (ready == 0) {
#line 3559
      break;
    }
#line 3564
    if (ready < 0) {
#line 3564
      tmp___2 = __error();
#line 3564
      if ((*tmp___2) != 4) {
#line 3566
        tmp___1 = __error();
#line 3566
        message((unsigned short)0, (*tmp___1), (char *)"error in select");
#line 3567
        status = -1;
#line 3568
        break;
      }
    }
#line 3573
    tmp___4 = __darwin_fd_isset(localFd, & testSet);
#line 3573
    if (tmp___4) {
#line 3575
      num = (int )recv(localFd, (void *)((char *)(msgBuf->data)), (unsigned long )msgBuf->maxSize,
                       0);
#line 3575
      if (num > 0) {
#line 3577
        message((unsigned short)5, 0, (char *)"read %d bytes from local socket %d",
                num, localFd);
#line 3579
        msgBuf->size = (unsigned short )num;
#line 3580
        if (DumpData) {
#line 3580
          dumpData("<", msgBuf->data, msgBuf->size);
        }
#line 3582
        tmp___3 = writeMessage(remoteFd, msgBuf);
#line 3582
        if (tmp___3 != num) {
#line 3584
          status = 1;
#line 3585
          break;
        }
      } else {
#line 3590
        if (num == 0) {
#line 3590
          status = 0;
        } else {
#line 3590
          status = -1;
        }
#line 3591
        break;
      }
    }
#line 3597
    tmp___5 = __darwin_fd_isset(remoteFd, & testSet);
#line 3597
    if (tmp___5) {
#line 3601
      num = readMessage(remoteFd, msgBuf, (unsigned short)0);
#line 3602
      if (num > 0) {
#line 3604
        if (udpMode) {
#line 3615
          num = (int )sendto(replyFd, (void const   *)((char *)(msgBuf->data)), (unsigned long )msgBuf->size,
                             0, (struct sockaddr  const  *)((struct sockaddr *)toAddrP),
                             sizeof(struct sockaddr_in ));
        } else {
#line 3622
          num = writeData(localFd, msgBuf->data, msgBuf->size);
        }
#line 3625
        if (num != (int )msgBuf->size) {
#line 3627
          status = -1;
#line 3628
          break;
        }
#line 3630
        message((unsigned short)5, 0, (char *)"sent %d bytes to local socket %d",
                num, localFd);
#line 3631
        if (DumpData) {
#line 3631
          dumpData(">", msgBuf->data, msgBuf->size);
        }
      } else {
#line 3635
        if (num == 0) {
#line 3635
          status = 0;
        } else {
#line 3635
          status = 1;
        }
#line 3636
        break;
      }
    }
  }
#line 3642
  message((unsigned short)3, 0, (char *)"connection closed or timed out");
#line 3644
  message((unsigned short)2, 0, (char *)"read %lu bytes (%lu expanded) in %lu messages",
          msgBuf->bytesIn, msgBuf->expBytesIn, msgBuf->readCount);
#line 3646
  message((unsigned short)2, 0, (char *)"wrote %lu bytes (%lu expanded) in %lu messages",
          msgBuf->bytesOut, msgBuf->expBytesOut, msgBuf->writeCount);
#line 3649
  return (status);
}
}
#line 3659 "zebedee.c"
void hashStrings(char *hashBuf  , ...) 
{ SHA_INFO sha ;
  va_list ap ;
  char *str ;
  size_t tmp ;

  {
#line 3666
  sha_init(& sha);
#line 3667
  __builtin_va_start(ap, hashBuf);
#line 3668
  while (1) {
#line 3668
    str = __builtin_va_arg(ap, char *);
#line 3668
    if (! ((unsigned int )str != (unsigned int )((void *)0))) {
#line 3668
      break;
    }
#line 3670
    tmp = strlen((char const   *)str);
#line 3670
    sha_update(& sha, (SHA_BYTE *)str, (int )tmp);
  }
#line 3672
  sha_final(& sha);
#line 3673
  sprintf(hashBuf, "%08lx%08lx%08lx%08lx%08lx", (unsigned long )sha.digest[0], (unsigned long )sha.digest[1],
          (unsigned long )sha.digest[2], (unsigned long )sha.digest[3], (unsigned long )sha.digest[4]);
#line 3677
  return;
}
}
#line 3686 "zebedee.c"
void hashFile(char *hashBuf , char *fileName ) 
{ SHA_INFO sha ;
  FILE *fp ;
  unsigned char buf[16383] ;
  size_t num ;
  int *tmp ;
  int tmp___0 ;

  {
#line 3690
  fp = (FILE *)((void *)0);
#line 3695
  tmp___0 = strcmp((char const   *)fileName, "-");
#line 3695
  if (tmp___0 == 0) {
#line 3697
    fp = __stdinp;
  } else {
#line 3702
    fp = fopen((char const   *)fileName, "rb");
#line 3702
    if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 3704
      tmp = __error();
#line 3704
      message((unsigned short)0, (*tmp), (char *)"can\'t open \'%s\'", fileName);
#line 3705
      return;
    }
  }
#line 3708
  sha_init(& sha);
#line 3710
  while (1) {
#line 3710
    num = fread((void *)(buf), 1UL, 16383UL, fp);
#line 3710
    if (! (num > 0UL)) {
#line 3710
      break;
    }
#line 3712
    sha_update(& sha, buf, (int )num);
  }
#line 3715
  fclose(fp);
#line 3717
  sha_final(& sha);
#line 3718
  sprintf(hashBuf, "%08lx%08lx%08lx%08lx%08lx", (unsigned long )sha.digest[0], (unsigned long )sha.digest[1],
          (unsigned long )sha.digest[2], (unsigned long )sha.digest[3], (unsigned long )sha.digest[4]);
#line 3722
  return;
}
}
#line 3733 "zebedee.c"
int checkIdentity(char *idFile , char *generator , char *modulus , char *key ) 
{ FILE *fp ;
  char keySig[41] ;
  char checkSig[1024] ;
  char line[1024] ;
  int found ;
  int len ;
  int *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 3740
  found = 0;
#line 3741
  len = 0;
#line 3744
  fp = fopen((char const   *)idFile, "r");
#line 3744
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 3746
    tmp = __error();
#line 3746
    message((unsigned short)0, (*tmp), (char *)"can\'t open identity file \'%s\'",
            idFile);
#line 3747
    return (0);
  }
#line 3750
  if ((int )(*generator) == 0) {
#line 3750
    generator = (char *)"2";
  }
#line 3751
  if ((int )(*modulus) == 0) {
#line 3751
    modulus = (char *)"f488fd584e49dbcd20b49de49107366b336c380d451d0f7c88b31c7c5b2d8ef6f3c923c043f0a55b188d8ebb558cb85d38d334fd7c175743a31d186cde33212cb52aff3ce1b1294018118d7c84a70a72d686c40319c807297aca950cd9969fabd00a509b0246d3083d66a45d419f9c7cbd894b221926baaba25ec355e92f78c7";
  }
#line 3753
  hashStrings(keySig, generator, modulus, key, (void *)0);
#line 3754
  len = (int )strlen((char const   *)(keySig));
#line 3756
  message((unsigned short)3, 0, (char *)"checking key with identity hash \'%s\'",
          keySig);
#line 3758
  while (1) {
#line 3758
    tmp___3 = fgets(line, 1024, fp);
#line 3758
    if (! ((unsigned int )tmp___3 != (unsigned int )((void *)0))) {
#line 3758
      break;
    }
#line 3760
    tmp___0 = sscanf((char const   *)(line), "%s", checkSig);
#line 3760
    if (tmp___0 != 1) {
#line 3762
      continue;
    }
#line 3765
    tmp___2 = strcasecmp((char const   *)(checkSig), (char const   *)(keySig));
#line 3765
    if (tmp___2 == 0) {
#line 3767
      tmp___1 = strlen((char const   *)(line));
#line 3767
      message((unsigned short)1, 0, (char *)"key identity matched: %.*s", tmp___1 - 1UL,
              line);
#line 3768
      found = 1;
#line 3769
      break;
    }
  }
#line 3773
  fclose(fp);
#line 3775
  return (found);
}
}
#line 3791 "zebedee.c"
static char buffer[41]  ;
#line 3787 "zebedee.c"
char *generateIdentity(char *generator , char *modulus , char *exponent ) 
{ char *dhKey ;
  char *tmp ;

  {
#line 3790
  tmp = diffieHellman(generator, modulus, exponent);
#line 3790
  dhKey = tmp;
#line 3793
  if ((int )(*generator) == 0) {
#line 3793
    generator = (char *)"2";
  }
#line 3794
  if ((int )(*modulus) == 0) {
#line 3794
    modulus = (char *)"f488fd584e49dbcd20b49de49107366b336c380d451d0f7c88b31c7c5b2d8ef6f3c923c043f0a55b188d8ebb558cb85d38d334fd7c175743a31d186cde33212cb52aff3ce1b1294018118d7c84a70a72d686c40319c807297aca950cd9969fabd00a509b0246d3083d66a45d419f9c7cbd894b221926baaba25ec355e92f78c7";
  }
#line 3796
  hashStrings(buffer, generator, modulus, dhKey, (void *)0);
#line 3797
  free((void *)dhKey);
#line 3799
  return (buffer);
}
}
#line 3810 "zebedee.c"
void prepareToDetach(void) 
{ 

  {
#line 3837
  return;
}
}
#line 3850 "zebedee.c"
void makeDetached(void) 
{ int tmp ;
  int *tmp___0 ;

  {
#line 3853
  fflush(__stdinp);
#line 3854
  fflush(__stdoutp);
#line 3855
  fflush(__stderrp);
#line 3881
  tmp = fork();
#line 3881
  switch (tmp) {
  case -1: 
#line 3885
  tmp___0 = __error();
#line 3885
  message((unsigned short)0, (*tmp___0), (char *)"fork failed becoming daemon");
#line 3886
  return;
  case 0: 
#line 3890
  break;
  default: 
#line 3894
  exit(0);
#line 3895
  break;
  }
#line 3900
  setsid();
#line 3905
  fclose(__stdinp);
#line 3906
  fclose(__stdoutp);
#line 3907
  fclose(__stderrp);
#line 3911
  IsDetached = -1;
#line 3912
  return;
}
}
#line 3927 "zebedee.c"
int allowRedirect(unsigned short port , struct sockaddr_in *addrP , int udpMode ,
                  char **hostP ) 
{ PortList_t *lp1 ;
  PortList_t *lp2 ;
  struct in_addr *alp ;
  unsigned long mask ;
  char *ipName ;
  long tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 3931
  alp = (struct in_addr *)((void *)0);
#line 3932
  mask = 0UL;
#line 3933
  ipName = (char *)((void *)0);
#line 3936
  tmp = __builtin_expect((long )(! ((unsigned int )AllowedTargets != (unsigned int )((void *)0))),
                         0L);
#line 3936
  if (tmp) {
#line 3936
    __assert_rtn("allowRedirect", "zebedee.c", 3936, "AllowedTargets != NULL");
  }
#line 3941
  if ((int )port == 0) {
#line 3943
    message((unsigned short)0, 0, (char *)"request for target port 0 disallowed");
#line 3944
    return (0);
  }
#line 3952
  if (addrP->sin_addr.s_addr == 0U) {
#line 3954
    tmp___0 = getHostAddress((char const   *)TargetHost, addrP, (struct in_addr **)((void *)0),
                             (unsigned long *)((void *)0));
#line 3954
    if (! tmp___0) {
#line 3956
      message((unsigned short)0, 0, (char *)"can\'t resolve host or address \'%s\'",
              TargetHost);
#line 3957
      return (0);
    }
  }
#line 3963
  ipName = (char *)malloc(16UL);
#line 3963
  if ((unsigned int )ipName == (unsigned int )((void *)0)) {
#line 3965
    tmp___1 = __error();
#line 3965
    message((unsigned short)0, (*tmp___1), (char *)"out of memory allocating hostname");
#line 3966
    return (0);
  }
#line 3968
  (*hostP) = ipString(addrP->sin_addr, ipName);
#line 3975
  lp1 = AllowedTargets;
#line 3975
  while (lp1) {
#line 3977
    mask = lp1->mask;
#line 3979
    if (((unsigned long )addrP->sin_addr.s_addr & mask) != ((unsigned long )lp1->addr.sin_addr.s_addr & mask)) {
#line 3983
      alp = lp1->addrList;
#line 3983
      while (alp->s_addr != 4294967295U) {
#line 3985
        if (((unsigned long )addrP->sin_addr.s_addr & mask) == ((unsigned long )alp->s_addr & mask)) {
#line 3989
          break;
        }
#line 3983
        alp ++;
      }
#line 3993
      if (alp->s_addr == 4294967295U) {
        goto __Cont;
      }
    }
#line 4001
    message((unsigned short)4, 0, (char *)"checking port %hu against range %hu-%hu for host %s",
            port, lp1->lo, lp1->hi, lp1->host);
#line 4005
    if ((int )lp1->lo == 0) {
#line 4005
      if ((int )lp1->hi == 0) {
#line 4007
        if ((unsigned int )AllowedDefault == (unsigned int )((void *)0)) {
#line 4009
          message((unsigned short)4, 0, (char *)"no default port restrictions, port is allowed");
#line 4010
          return (1);
        }
#line 4013
        lp2 = AllowedDefault;
#line 4013
        while (lp2) {
#line 4015
          message((unsigned short)4, 0, (char *)"checking port %hu against default range %hu - %hu",
                  port, lp2->lo, lp2->hi);
#line 4017
          if ((int )port >= (int )lp2->lo) {
#line 4017
            if ((int )port <= (int )lp2->hi) {
#line 4019
              if (udpMode) {
#line 4019
                tmp___3 = 2;
              } else {
#line 4019
                tmp___3 = 1;
              }
#line 4019
              if ((int )lp2->type & tmp___3) {
#line 4021
                return (1);
              }
            }
          }
#line 4013
          lp2 = lp2->next;
        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 4029
      if ((int )port >= (int )lp1->lo) {
#line 4029
        if ((int )port <= (int )lp1->hi) {
#line 4031
          if (udpMode) {
#line 4031
            tmp___4 = 2;
          } else {
#line 4031
            tmp___4 = 1;
          }
#line 4031
          if ((int )lp1->type & tmp___4) {
#line 4033
            return (1);
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 3975
    lp1 = lp1->next;
  }
#line 4038
  (*hostP) = (char *)((void *)0);
#line 4039
  free((void *)ipName);
#line 4040
  return (0);
}
}
#line 4053 "zebedee.c"
int checkPeerAddress(int fd , struct sockaddr_in *addrP ) 
{ struct sockaddr_in addr ;
  int addrLen ;
  unsigned short port ;
  PortList_t *lp1 ;
  struct in_addr *alp ;
  unsigned long mask ;
  char ipBuf[16] ;
  int *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  __uint16_t tmp___2 ;

  {
#line 4057
  addrLen = (int )sizeof(struct sockaddr_in );
#line 4058
  port = (unsigned short)0;
#line 4059
  lp1 = (PortList_t *)((void *)0);
#line 4060
  alp = (struct in_addr *)((void *)0);
#line 4061
  mask = 4294967295UL;
#line 4070
  if ((unsigned int )AllowedPeers == (unsigned int )((void *)0)) {
#line 4070
    if ((unsigned int )addrP == (unsigned int )((void *)0)) {
#line 4070
      return (1);
    }
  }
#line 4072
  if ((unsigned int )addrP == (unsigned int )((void *)0)) {
#line 4072
    addrP = & addr;
  }
#line 4074
  tmp___0 = getpeername(fd, (struct sockaddr *)addrP, (socklen_t *)(& addrLen));
#line 4074
  if (tmp___0) {
#line 4076
    tmp = __error();
#line 4076
    message((unsigned short)0, (*tmp), (char *)"can\'t get peer address for socket");
#line 4077
    return (0);
  }
#line 4079
  tmp___1 = ipString(addrP->sin_addr, ipBuf);
#line 4079
  message((unsigned short)4, 0, (char *)"peer address from connection is %s", tmp___1);
#line 4083
  if ((unsigned int )AllowedPeers == (unsigned int )((void *)0)) {
#line 4083
    return (1);
  }
#line 4087
  tmp___2 = _OSSwapInt16(addrP->sin_port);
#line 4087
  port = (unsigned short )((int )tmp___2);
#line 4089
  lp1 = AllowedPeers;
#line 4089
  while (lp1) {
#line 4091
    mask = lp1->mask;
#line 4093
    if (((unsigned long )addrP->sin_addr.s_addr & mask) != ((unsigned long )lp1->addr.sin_addr.s_addr & mask)) {
#line 4097
      alp = lp1->addrList;
#line 4097
      while (alp->s_addr != 4294967295U) {
#line 4099
        if (((unsigned long )addrP->sin_addr.s_addr & mask) == ((unsigned long )alp->s_addr & mask)) {
#line 4103
          break;
        }
#line 4097
        alp ++;
      }
#line 4107
      if (alp->s_addr == 4294967295U) {
        goto __Cont;
      }
    }
#line 4115
    message((unsigned short)4, 0, (char *)"checking port %hu against range %hu-%hu for host %s",
            port, lp1->lo, lp1->hi, lp1->host);
#line 4119
    if ((int )lp1->lo == 0) {
#line 4119
      if ((int )lp1->hi == 0) {
#line 4121
        return (1);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 4126
      if ((int )port >= (int )lp1->lo) {
#line 4126
        if ((int )port <= (int )lp1->hi) {
#line 4128
          return (1);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 4089
    lp1 = lp1->next;
  }
#line 4132
  return (0);
}
}
#line 4141 "zebedee.c"
int countPorts(PortList_t *list ) 
{ int count ;

  {
#line 4144
  count = 0;
#line 4146
  while (list) {
#line 4148
    count += ((int )list->hi - (int )list->lo) + 1;
#line 4149
    list = list->next;
  }
#line 4152
  return (count);
}
}
#line 4166 "zebedee.c"
unsigned short mapPort(unsigned short localPort , char **hostP , struct sockaddr_in *addrP ) 
{ PortList_t *localPtr ;
  PortList_t *remotePtr ;
  unsigned short count ;

  {
#line 4169
  localPtr = ClientPorts;
#line 4170
  remotePtr = TargetPorts;
#line 4171
  count = (unsigned short)0;
#line 4176
  while (localPtr) {
#line 4178
    if ((int )localPort <= (int )localPtr->hi) {
#line 4178
      if ((int )localPort >= (int )localPtr->lo) {
#line 4180
        count = (unsigned short )((int )count + ((int )localPort - (int )localPtr->lo));
#line 4181
        break;
      }
    }
#line 4184
    count = (unsigned short )((int )count + (((int )localPtr->hi - (int )localPtr->lo) + 1));
#line 4185
    localPtr = localPtr->next;
  }
#line 4190
  if ((unsigned int )localPtr == (unsigned int )((void *)0)) {
#line 4192
    return ((unsigned short)0);
  }
#line 4197
  while (remotePtr) {
#line 4199
    if ((int )count <= (int )((unsigned short )((int )remotePtr->hi - (int )remotePtr->lo))) {
#line 4201
      if (addrP) {
#line 4203
        addrP->sin_addr.s_addr = remotePtr->addr.sin_addr.s_addr;
      }
#line 4205
      if (hostP) {
#line 4207
        if (remotePtr->host) {
#line 4209
          (*hostP) = remotePtr->host;
        } else {
#line 4213
          (*hostP) = ServerHost;
        }
      }
#line 4216
      return ((unsigned short )((int )remotePtr->lo + (int )count));
    }
#line 4219
    count = (unsigned short )((int )count - (((int )remotePtr->hi - (int )remotePtr->lo) + 1));
#line 4220
    remotePtr = remotePtr->next;
  }
#line 4223
  return ((unsigned short)0);
}
}
#line 4240 "zebedee.c"
unsigned long spawnHandler(void (*handler)(FnArgs_t * ) , int listenFd , int clientFd ,
                           int inLine , struct sockaddr_in *addrP , int udpMode ) 
{ FnArgs_t *argP ;
  struct sockaddr_in localAddr ;
  int addrLen ;
  int *tmp ;
  int *tmp___1 ;
  int tmp___2 ;
  __uint16_t tmp___3 ;
  pthread_t tid ;
  int *tmp___4 ;
  int tmp___5 ;
  unsigned long tmp___6 ;

  {
#line 4244
  argP = (FnArgs_t *)((void *)0);
#line 4246
  addrLen = (int )sizeof(localAddr);
#line 4249
  argP = (FnArgs_t *)malloc((unsigned long )sizeof(FnArgs_t ));
#line 4249
  if ((unsigned int )argP == (unsigned int )((void *)0)) {
#line 4251
    tmp = __error();
#line 4251
    message((unsigned short)0, (*tmp), (char *)"failed to allocate handler argument structure");
#line 4252
    return (0UL);
  }
#line 4254
  argP->fd = clientFd;
#line 4255
  if (addrP) {
#line 4257
    memcpy((void *)(& argP->addr), (void const   *)addrP, (unsigned long )sizeof(struct sockaddr_in ));
  }
#line 4265
  argP->listenFd = listenFd;
#line 4266
  if (listenFd >= 0) {
#line 4268
    addrLen = (int )sizeof(localAddr);
#line 4269
    memset((void *)(& localAddr), 0, (unsigned long )sizeof(localAddr));
#line 4270
    tmp___2 = getsockname(listenFd, (struct sockaddr *)(& localAddr), (socklen_t *)(& addrLen));
#line 4270
    if (tmp___2) {
#line 4272
      tmp___1 = __error();
#line 4272
      message((unsigned short)0, (*tmp___1), (char *)"can\'t get local port number");
#line 4273
      return (0UL);
    }
#line 4275
    tmp___3 = _OSSwapInt16(localAddr.sin_port);
#line 4275
    argP->port = (unsigned short )((int )tmp___3);
  }
#line 4278
  argP->udpMode = udpMode;
#line 4280
  argP->inLine = inLine;
#line 4281
  if (inLine) {
#line 4283
    message((unsigned short)4, 0, (char *)"running handler function in-line");
#line 4284
    ((*handler))(argP);
#line 4285
    return (0UL);
  }
#line 4292
  message((unsigned short)4, 0, (char *)"spawning handler function thread");
#line 4293
  tmp___5 = pthread_create(& tid, (pthread_attr_t const   *)(& ThreadAttr), (void *(*)(void * ))handler,
                           (void *)argP);
#line 4293
  if (tmp___5 == -1) {
#line 4298
    tmp___4 = __error();
#line 4298
    message((unsigned short)0, (*tmp___4), (char *)"failed to create handler thread");
  }
#line 4300
  message((unsigned short)4, 0, (char *)"handler thread %lu created", (unsigned long )tid);
#line 4301
  if ((unsigned long )tid) {
#line 4301
    tmp___6 = (unsigned long )tid;
  } else {
#line 4301
    tmp___6 = 4294967295UL;
  }
#line 4301
  return (tmp___6);
}
}
#line 4361 "zebedee.c"
int findHandler(struct sockaddr_in *fromAddrP , struct sockaddr_in *localAddrP ) 
{ HndInfo_t *ptr ;
  HndInfo_t *tmp ;
  int found ;
  char ipBuf[16] ;
  __uint16_t tmp___0 ;
  char *tmp___1 ;

  {
#line 4364
  ptr = (HndInfo_t *)((void *)0);
#line 4365
  tmp = (HndInfo_t *)((void *)0);
#line 4366
  found = -1;
#line 4370
  tmp___0 = _OSSwapInt16(fromAddrP->sin_port);
#line 4370
  tmp___1 = ipString(fromAddrP->sin_addr, ipBuf);
#line 4370
  message((unsigned short)5, 0, (char *)"searching for handler for address %s:%hu",
          tmp___1, (int )tmp___0);
#line 4372
  mutexLock(3);
#line 4374
  ptr = & HandlerList;
#line 4374
  while ((unsigned int )ptr != (unsigned int )((void *)0)) {
#line 4398
    if ((int )ptr->fromAddr.sin_port == (int )fromAddrP->sin_port) {
#line 4398
      if (ptr->fromAddr.sin_addr.s_addr == fromAddrP->sin_addr.s_addr) {
#line 4401
        message((unsigned short)5, 0, (char *)"found handler, id = %lu, socket = %d",
                ptr->id, ptr->fd);
#line 4402
        found = ptr->fd;
#line 4403
        memcpy((void *)localAddrP, (void const   *)(& ptr->localAddr), (unsigned long )sizeof(struct sockaddr_in ));
      }
    }
#line 4406
    tmp = ptr;
#line 4374
    ptr = ptr->next;
  }
#line 4409
  mutexUnlock(3);
#line 4411
  return (found);
}
}
#line 4424 "zebedee.c"
void addHandler(struct sockaddr_in *fromAddrP , unsigned long id , int fd , struct sockaddr_in *localAddrP ) 
{ HndInfo_t *ptr ;
  int *tmp ;

  {
#line 4427
  ptr = (HndInfo_t *)((void *)0);
#line 4430
  mutexLock(3);
#line 4432
  ptr = & HandlerList;
#line 4432
  while ((unsigned int )ptr->next != (unsigned int )((void *)0)) {
#line 4432
    ptr = ptr->next;
  }
#line 4437
  ptr->next = (struct HndInfo_s *)malloc((unsigned long )sizeof(HndInfo_t ));
#line 4437
  if ((unsigned int )ptr->next == (unsigned int )((void *)0)) {
#line 4439
    tmp = __error();
#line 4439
    message((unsigned short)0, (*tmp), (char *)"failed to allocate memory for handler list element");
  } else {
#line 4443
    (ptr->next)->id = id;
#line 4444
    (ptr->next)->fd = fd;
#line 4445
    memcpy((void *)(& (ptr->next)->fromAddr), (void const   *)fromAddrP, (unsigned long )sizeof(struct sockaddr_in ));
#line 4446
    memcpy((void *)(& (ptr->next)->localAddr), (void const   *)localAddrP, (unsigned long )sizeof(struct sockaddr_in ));
#line 4447
    (ptr->next)->prev = ptr;
#line 4448
    (ptr->next)->next = (struct HndInfo_s *)((void *)0);
  }
#line 4451
  mutexUnlock(3);
#line 4452
  return;
}
}
#line 4460 "zebedee.c"
void removeHandler(struct sockaddr_in *addrP ) 
{ HndInfo_t *ptr ;
  HndInfo_t *tmp ;

  {
#line 4463
  ptr = (HndInfo_t *)((void *)0);
#line 4464
  tmp = (HndInfo_t *)((void *)0);
#line 4466
  mutexLock(3);
#line 4468
  ptr = & HandlerList;
#line 4468
  while ((unsigned int )ptr != (unsigned int )((void *)0)) {
#line 4470
    if ((int )ptr->fromAddr.sin_port == (int )addrP->sin_port) {
#line 4470
      if (ptr->fromAddr.sin_addr.s_addr == addrP->sin_addr.s_addr) {
#line 4473
        (ptr->prev)->next = ptr->next;
#line 4474
        if (ptr->next) {
#line 4476
          (ptr->next)->prev = ptr->prev;
        }
#line 4478
        tmp = ptr;
#line 4479
        ptr = ptr->prev;
#line 4481
        free((void *)tmp);
      }
    }
#line 4468
    ptr = ptr->next;
  }
#line 4485
  mutexUnlock(3);
#line 4486
  return;
}
}
#line 4510 "zebedee.c"
void clientListener(PortList_t *ports ) 
{ int listenFd ;
  int clientFd ;
  struct sockaddr_in fromAddr ;
  struct sockaddr_in localAddr ;
  int addrLen ;
  unsigned short localPort ;
  fd_set tcpSet ;
  fd_set udpSet ;
  fd_set unionSet ;
  fd_set testSet ;
  int maxFd ;
  int ready ;
  unsigned long id ;
  char data[16383] ;
  int num ;
  char ipBuf[16] ;
  int tmp ;
  int *tmp___0 ;
  int __fd ;
  int __fd___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  __uint16_t tmp___7 ;
  int *tmp___9 ;
  ssize_t tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 4513
  listenFd = -1;
#line 4518
  localPort = (unsigned short)0;
#line 4523
  maxFd = -1;
#line 4524
  ready = 0;
#line 4525
  id = 0UL;
#line 4531
  message((unsigned short)3, 0, (char *)"client listener routine entered");
#line 4539
  __builtin_bzero(& tcpSet, sizeof(tcpSet));
#line 4540
  __builtin_bzero(& udpSet, sizeof(udpSet));
#line 4541
  if (TcpMode) {
#line 4543
    maxFd = makeClientListeners(ports, & tcpSet, 0);
  }
#line 4545
  if (UdpMode) {
#line 4547
    listenFd = makeClientListeners(ports, & udpSet, 1);
#line 4548
    if (listenFd > maxFd) {
#line 4550
      maxFd = listenFd;
    }
  }
#line 4559
  if (maxFd == -1) {
#line 4561
    message((unsigned short)0, 0, (char *)"client not listening on any ports -- check tunnel specifications");
#line 4562
    exit(1);
  }
#line 4567
  if (CommandString) {
#line 4569
    message((unsigned short)3, 0, (char *)"spawning command \'%s\'", CommandString);
#line 4571
    tmp = spawnCommand(ports->lo, CommandString);
#line 4571
    if (! tmp) {
#line 4573
      exit(1);
    }
  }
#line 4579
  if (IsDetached) {
#line 4581
    message((unsigned short)3, 0, (char *)"detaching from terminal");
#line 4582
    makeDetached();
  }
#line 4590
  if (ListenMode) {
#line 4592
    message((unsigned short)3, 0, (char *)"listening for server connection on port %hu",
            ServerPort);
#line 4594
    ListenSock = makeListener(& ServerPort, ListenIp, 0);
#line 4594
    if (ListenSock == -1) {
#line 4596
      tmp___0 = __error();
#line 4596
      message((unsigned short)0, (*tmp___0), (char *)"can\'t create listener socket for server connection");
#line 4597
      exit(1);
    }
  }
#line 4607
  if (UdpMode) {
#line 4607
    message((unsigned short)1, 0, (char *)"listening for client UDP data");
  }
#line 4611
  __builtin_bzero(& unionSet, sizeof(unionSet));
#line 4612
  listenFd = 0;
#line 4612
  while (listenFd <= maxFd) {
#line 4614
    tmp___2 = __darwin_fd_isset(listenFd, & tcpSet);
#line 4614
    if (tmp___2) {
#line 4616
      while (1) {
#line 4616
        __fd = listenFd;
#line 4616
        unionSet.fds_bits[(unsigned int )__fd / (sizeof(__int32_t ) * 8U)] |= 1 << (unsigned int )__fd % (sizeof(__int32_t ) * 8U);
#line 4616
        break;
      }
    } else {
#line 4618
      tmp___1 = __darwin_fd_isset(listenFd, & udpSet);
#line 4618
      if (tmp___1) {
#line 4620
        while (1) {
#line 4620
          __fd___0 = listenFd;
#line 4620
          unionSet.fds_bits[(unsigned int )__fd___0 / (sizeof(__int32_t ) * 8U)] |= 1 << (unsigned int )__fd___0 % (sizeof(__int32_t ) * 8U);
#line 4620
          break;
        }
      }
    }
#line 4612
    listenFd ++;
  }
#line 4624
  while (1) {
#line 4626
    memcpy((void *)(& testSet), (void const   *)(& unionSet), (unsigned long )sizeof(fd_set ));
#line 4628
    if (UdpMode) {
#line 4630
      message((unsigned short)5, 0, (char *)"waiting for client data", localPort);
    } else {
#line 4634
      message((unsigned short)1, 0, (char *)"waiting for client connection", localPort);
    }
#line 4639
    ready = select(maxFd + 1, & testSet, (fd_set *)0, (fd_set *)0, (struct timeval *)0);
#line 4641
    if (UdpMode) {
#line 4641
      tmp___3 = 5;
    } else {
#line 4641
      tmp___3 = 3;
    }
#line 4641
    message((unsigned short )tmp___3, 0, (char *)"select returned %d", ready);
#line 4645
    if (ready == 0) {
#line 4647
      break;
    }
#line 4652
    if (ready < 0) {
#line 4652
      tmp___5 = __error();
#line 4652
      if ((*tmp___5) != 4) {
#line 4654
        tmp___4 = __error();
#line 4654
        message((unsigned short)0, (*tmp___4), (char *)"error in select");
#line 4655
        break;
      }
    }
#line 4660
    listenFd = 0;
#line 4660
    while (listenFd <= maxFd) {
#line 4662
      tmp___16 = __darwin_fd_isset(listenFd, & testSet);
#line 4662
      if (tmp___16) {
#line 4664
        tmp___15 = __darwin_fd_isset(listenFd, & udpSet);
#line 4664
        if (tmp___15) {
#line 4668
          addrLen = (int )sizeof(fromAddr);
#line 4669
          num = (int )recvfrom(listenFd, (void *)(data), 16383UL, 0, (struct sockaddr *)(& fromAddr),
                               (socklen_t *)(& addrLen));
#line 4669
          if (num > 0) {
#line 4678
            clientFd = findHandler(& fromAddr, & localAddr);
#line 4678
            if (clientFd == -1) {
#line 4682
              localPort = (unsigned short)0;
#line 4683
              clientFd = makeListener(& localPort, (char *)"127.0.0.1", 1);
#line 4683
              if (clientFd == -1) {
                goto __Cont;
              }
#line 4688
              if (Debug) {
#line 4688
                tmp___6 = 1;
              } else {
#line 4688
                if (! MultiUse) {
#line 4688
                  tmp___6 = 1;
                } else {
#line 4688
                  tmp___6 = 0;
                }
              }
#line 4688
              id = spawnHandler(& client, listenFd, clientFd, tmp___6, & fromAddr,
                                1);
#line 4691
              if (id != 0UL) {
#line 4693
                memset((void *)(& localAddr), 0, (unsigned long )sizeof(localAddr));
#line 4694
                localAddr.sin_family = (unsigned char)2;
#line 4695
                tmp___7 = _OSSwapInt16(localPort);
#line 4695
                localAddr.sin_port = (unsigned short )((int )tmp___7);
#line 4696
                localAddr.sin_addr.s_addr = 16777343U;
#line 4698
                addHandler(& fromAddr, id, clientFd, & localAddr);
              }
            }
#line 4708
            if (clientFd != -1) {
#line 4710
              tmp___10 = sendto(clientFd, (void const   *)(data), (unsigned long )num,
                                0, (struct sockaddr  const  *)((struct sockaddr *)(& localAddr)),
                                sizeof(localAddr));
#line 4710
              if (tmp___10 != (ssize_t )num) {
#line 4714
                tmp___9 = __error();
#line 4714
                message((unsigned short)0, (*tmp___9), (char *)"failed to send data to loopback socket");
              }
            }
          } else {
#line 4720
            tmp___11 = __error();
#line 4720
            message((unsigned short)0, (*tmp___11), (char *)"can\'t read next message");
          }
        } else {
#line 4730
          message((unsigned short)5, 0, (char *)"connection ready on socket %d", listenFd);
#line 4732
          addrLen = (int )sizeof(struct sockaddr_in );
#line 4733
          memset((void *)(& fromAddr), 0, (unsigned long )sizeof(fromAddr));
#line 4734
          clientFd = accept(listenFd, (struct sockaddr *)(& fromAddr), (socklen_t *)(& addrLen));
#line 4734
          if (clientFd < 0) {
#line 4738
            tmp___12 = __error();
#line 4738
            message((unsigned short)0, (*tmp___12), (char *)"error on accept");
          } else {
#line 4742
            tmp___13 = ipString(fromAddr.sin_addr, ipBuf);
#line 4742
            message((unsigned short)1, 0, (char *)"accepted connection from %s", tmp___13);
#line 4746
            setNoLinger(clientFd);
#line 4750
            setKeepAlive(clientFd);
#line 4754
            if (Debug) {
#line 4754
              tmp___14 = 1;
            } else {
#line 4754
              if (! MultiUse) {
#line 4754
                tmp___14 = 1;
              } else {
#line 4754
                tmp___14 = 0;
              }
            }
#line 4754
            spawnHandler(& client, listenFd, clientFd, tmp___14, & fromAddr, 0);
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 4660
      listenFd ++;
    }
#line 4624
    if (! MultiUse) {
#line 4624
      break;
    }
  }
#line 4765
  listenFd = 0;
#line 4765
  while (listenFd <= maxFd) {
#line 4767
    tmp___17 = __darwin_fd_isset(listenFd, & unionSet);
#line 4767
    if (tmp___17) {
#line 4767
      close(listenFd);
    }
#line 4765
    listenFd ++;
  }
#line 4769
  listenFd = -1;
#line 4773
  waitForInactivity();
#line 4774
  return;
}
}
#line 4784 "zebedee.c"
int makeClientListeners(PortList_t *ports , fd_set *listenSetP , int udpMode ) 
{ int listenFd ;
  unsigned short localPort ;
  int maxFd ;
  int tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  int __fd ;

  {
#line 4787
  listenFd = -1;
#line 4788
  localPort = (unsigned short)0;
#line 4789
  maxFd = -1;
#line 4791
  while (ports) {
#line 4793
    localPort = ports->lo;
#line 4793
    while ((int )localPort <= (int )ports->hi) {
#line 4795
      if (udpMode) {
#line 4795
        tmp = 2;
      } else {
#line 4795
        tmp = 1;
      }
#line 4795
      if (((int )ports->type & tmp) == 0) {
        goto __Cont;
      }
#line 4801
      if (udpMode) {
#line 4801
        tmp___0 = "UDP";
      } else {
#line 4801
        tmp___0 = "TCP";
      }
#line 4801
      message((unsigned short)3, 0, (char *)"creating %s-mode local listener socket for port %hu",
              tmp___0, localPort);
#line 4804
      listenFd = makeListener(& localPort, ListenIp, udpMode);
#line 4804
      if (listenFd == -1) {
#line 4806
        tmp___1 = __error();
#line 4806
        message((unsigned short)0, (*tmp___1), (char *)"can\'t create listener socket");
#line 4807
        exit(1);
      }
#line 4810
      message((unsigned short)5, 0, (char *)"local port %hu has socket %d", localPort,
              listenFd);
#line 4812
      while (1) {
#line 4812
        __fd = listenFd;
#line 4812
        listenSetP->fds_bits[(unsigned int )__fd / (sizeof(__int32_t ) * 8U)] |= 1 << (unsigned int )__fd % (sizeof(__int32_t ) * 8U);
#line 4812
        break;
      }
#line 4813
      if (listenFd > maxFd) {
#line 4815
        maxFd = listenFd;
      }
#line 4818
      if (! CommandString) {
#line 4820
        message((unsigned short)1, 0, (char *)"Listening on local port %hu", localPort);
      } else {
#line 4824
        message((unsigned short)3, 0, (char *)"listening on local port %hu", localPort);
      }
#line 4829
      if ((int )ports->hi == 0) {
#line 4831
        ports->hi = localPort;
#line 4831
        ports->lo = ports->hi;
      }
      __Cont: /* CIL Label */ 
#line 4793
      localPort = (unsigned short )((int )localPort + 1);
    }
#line 4835
    ports = ports->next;
  }
#line 4838
  return (maxFd);
}
}
#line 4848 "zebedee.c"
void client(FnArgs_t *argP ) 
{ int clientFd ;
  char const   *serverHost ;
  unsigned short serverPort ;
  unsigned short redirectPort ;
  unsigned short maxSize ;
  int serverFd ;
  unsigned short response ;
  char generator[1024] ;
  char modulus[1024] ;
  char serverDhKey[1024] ;
  char *exponent ;
  char *dhKey ;
  char *secretKeyStr ;
  char *sessionKeyStr ;
  MsgBuf_t *msg ;
  unsigned short cmpInfo ;
  unsigned short keyBits ;
  unsigned short protocol ;
  unsigned long token ;
  unsigned char hdrData[26] ;
  unsigned short hdrSize ;
  unsigned char clientNonce[8] ;
  unsigned char serverNonce[8] ;
  char *targetHost ;
  struct sockaddr_in peerAddr ;
  struct sockaddr_in targetAddr ;
  int inLine ;
  int udpMode ;
  char ipBuf[16] ;
  __uint32_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __uint32_t tmp___9 ;
  __uint32_t tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  unsigned short tmp___18 ;
  unsigned short tmp___19 ;
  int *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  int tmp___23 ;
  int *tmp___24 ;
  int tmp___25 ;
  int *tmp___26 ;
  int *tmp___27 ;
  int tmp___28 ;
  int *tmp___29 ;
  size_t tmp___30 ;
  size_t tmp___31 ;
  size_t tmp___32 ;
  int tmp___33 ;
  int *tmp___34 ;
  int tmp___35 ;
  int *tmp___36 ;
  int tmp___37 ;
  int *tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  size_t tmp___41 ;
  int *tmp___42 ;
  int tmp___43 ;
  size_t tmp___44 ;
  size_t tmp___45 ;
  size_t tmp___46 ;
  int tmp___47 ;
  size_t tmp___48 ;
  size_t tmp___49 ;
  int tmp___50 ;
  int *tmp___51 ;
  int *tmp___52 ;

  {
#line 4851
  clientFd = argP->fd;
#line 4852
  serverHost = (char const   *)ServerHost;
#line 4853
  serverPort = ServerPort;
#line 4854
  redirectPort = (unsigned short)0;
#line 4855
  maxSize = MaxBufSize;
#line 4856
  serverFd = -1;
#line 4857
  response = (unsigned short)0;
#line 4861
  exponent = (char *)((void *)0);
#line 4862
  dhKey = (char *)((void *)0);
#line 4863
  secretKeyStr = (char *)((void *)0);
#line 4864
  sessionKeyStr = (char *)((void *)0);
#line 4865
  msg = (MsgBuf_t *)((void *)0);
#line 4866
  cmpInfo = CompressInfo;
#line 4867
  keyBits = KeyLength;
#line 4868
  protocol = (unsigned short)513;
#line 4869
  token = 0UL;
#line 4871
  hdrSize = (unsigned short)22;
#line 4874
  targetHost = (char *)((void *)0);
#line 4877
  inLine = argP->inLine;
#line 4878
  udpMode = argP->udpMode;
#line 4882
  incrActiveCount(1);
#line 4883
  message((unsigned short)3, 0, (char *)"client routine entered");
#line 4889
  redirectPort = mapPort(argP->port, & targetHost, & targetAddr);
#line 4890
  if (redirectPort) {
#line 4892
    message((unsigned short)3, 0, (char *)"client on local port %hu tunnels to target %s:%hu",
            argP->port, targetHost, redirectPort);
#line 4893
    tmp = _OSSwapInt32(targetAddr.sin_addr.s_addr);
#line 4893
    message((unsigned short)4, 0, (char *)"target address is %08x", tmp);
  } else {
#line 4897
    message((unsigned short)0, 0, (char *)"no matching target port for local port %hu",
            argP->port);
    goto fatal;
  }
#line 4901
  if (ListenMode) {
#line 4903
    message((unsigned short)3, 0, (char *)"waiting for connection from server");
#line 4905
    serverFd = acceptConnection(ListenSock, serverHost, 1, ConnectTimeout);
#line 4905
    if (serverFd == -1) {
#line 4908
      tmp___0 = __error();
#line 4908
      message((unsigned short)0, (*tmp___0), (char *)"failed to accept a connection from %s",
              serverHost);
      goto fatal;
    }
#line 4911
    message((unsigned short)3, 0, (char *)"accepted connection from server");
  } else {
#line 4915
    message((unsigned short)3, 0, (char *)"making connection to %s:%hu", serverHost,
            serverPort);
#line 4917
    serverFd = makeConnection(serverHost, serverPort, 0, 1, (struct sockaddr_in *)((void *)0),
                              (struct sockaddr_in *)((void *)0));
#line 4917
    if (serverFd == -1) {
#line 4919
      tmp___1 = __error();
#line 4919
      message((unsigned short)0, (*tmp___1), (char *)"can\'t connect to %s port %hu",
              serverHost, serverPort);
      goto fatal;
    }
#line 4922
    message((unsigned short)3, 0, (char *)"connected to %s:%hu", serverHost, serverPort);
  }
#line 4929
  message((unsigned short)3, 0, (char *)"validating server IP address");
#line 4931
  tmp___3 = checkPeerAddress(serverFd, & peerAddr);
#line 4931
  if (! tmp___3) {
#line 4933
    tmp___2 = ipString(peerAddr.sin_addr, ipBuf);
#line 4933
    message((unsigned short)0, 0, (char *)"connection with server %s disallowed",
            tmp___2);
    goto fatal;
  }
#line 4941
  message((unsigned short)3, 0, (char *)"requesting protocol version %#hx", protocol);
#line 4943
  tmp___5 = requestResponse(serverFd, protocol, & response);
#line 4943
  if (! tmp___5) {
#line 4945
    tmp___4 = __error();
#line 4945
    message((unsigned short)0, (*tmp___4), (char *)"failed requesting protocol version");
    goto fatal;
  }
#line 4949
  switch ((int )response) {
  case 513: 
#line 4952
  protocol = (unsigned short)513;
#line 4953
  break;
  case 512: 
#line 4956
  protocol = (unsigned short)512;
#line 4957
  break;
  case 258: 
#line 4960
  protocol = (unsigned short)258;
#line 4961
  break;
  case 257: 
#line 4964
  protocol = (unsigned short)257;
#line 4965
  break;
  case 256: 
  case 0: 
#line 4976
  protocol = (unsigned short)256;
#line 4977
  break;
  default: 
#line 4980
  message((unsigned short)0, 0, (char *)"server responded with incompatible protocol version (%#hx)",
          response);
  goto fatal;
  }
#line 4984
  message((unsigned short)3, 0, (char *)"accepted protocol version %#hx", response);
#line 4991
  if ((int )protocol >= 512) {
#line 4993
    if (udpMode) {
#line 4993
      tmp___6 = "UDP";
    } else {
#line 4993
      tmp___6 = "TCP";
    }
#line 4993
    message((unsigned short)3, 0, (char *)"requesting %s mode", tmp___6);
#line 4994
    if (udpMode) {
#line 4994
      tmp___7 = 1;
    } else {
#line 4994
      tmp___7 = 0;
    }
#line 4994
    headerSetUShort(hdrData, (unsigned short )tmp___7, 0);
#line 4996
    message((unsigned short)3, 0, (char *)"requesting buffer size %hu", maxSize);
#line 4997
    headerSetUShort(hdrData, maxSize, 2);
#line 4999
    message((unsigned short)3, 0, (char *)"requesting compression level %#hx", CompressInfo);
#line 5000
    headerSetUShort(hdrData, CompressInfo, 4);
#line 5002
    message((unsigned short)3, 0, (char *)"requesting redirection to port %hu", redirectPort);
#line 5003
    headerSetUShort(hdrData, redirectPort, 6);
#line 5005
    message((unsigned short)3, 0, (char *)"requesting key length %hu", KeyLength);
#line 5006
    headerSetUShort(hdrData, KeyLength, 8);
#line 5008
    token = getCurrentToken();
#line 5009
    message((unsigned short)3, 0, (char *)"requesting key reuse token %#lx", token);
#line 5010
    headerSetULong(hdrData, token, 10);
#line 5012
    generateNonce(clientNonce);
#line 5013
    message((unsigned short)3, 0, (char *)"sending client nonce %02x%02x...", clientNonce[0],
            clientNonce[1]);
#line 5014
    memcpy((void *)(hdrData + 14), (void const   *)(clientNonce), 8UL);
#line 5016
    if ((int )protocol > 512) {
#line 5018
      hdrSize = (unsigned short)26;
#line 5025
      tmp___8 = strcmp((char const   *)targetHost, (char const   *)ServerHost);
#line 5025
      if (tmp___8 == 0) {
#line 5027
        message((unsigned short)4, 0, (char *)"target is the same as the server");
#line 5028
        targetAddr.sin_addr.s_addr = 0U;
      }
#line 5030
      tmp___9 = _OSSwapInt32(targetAddr.sin_addr.s_addr);
#line 5030
      message((unsigned short)3, 0, (char *)"requesting target address %08x", tmp___9);
#line 5031
      tmp___10 = _OSSwapInt32(targetAddr.sin_addr.s_addr);
#line 5031
      headerSetULong(hdrData, (unsigned long )tmp___10, 22);
    }
#line 5034
    tmp___12 = writeData(serverFd, hdrData, hdrSize);
#line 5034
    if (tmp___12 != (int )hdrSize) {
#line 5036
      tmp___11 = __error();
#line 5036
      message((unsigned short)0, (*tmp___11), (char *)"failed writing protocol header to server");
      goto fatal;
    }
#line 5040
    tmp___14 = readData(serverFd, hdrData, hdrSize);
#line 5040
    if (tmp___14 != (int )hdrSize) {
#line 5042
      tmp___13 = __error();
#line 5042
      message((unsigned short)0, (*tmp___13), (char *)"failed reading protocol header response from server");
      goto fatal;
    }
#line 5046
    if (udpMode) {
#line 5046
      tmp___18 = headerGetUShort(hdrData, 0);
#line 5046
      if ((int )tmp___18 != 1) {
        goto _L;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 5046
      if (! udpMode) {
#line 5046
        tmp___19 = headerGetUShort(hdrData, 0);
#line 5046
        if ((int )tmp___19 == 1) {
          _L: /* CIL Label */ 
#line 5049
          if (udpMode) {
#line 5049
            tmp___15 = "TCP";
          } else {
#line 5049
            tmp___15 = "UDP";
          }
#line 5049
          if (udpMode) {
#line 5049
            tmp___16 = "UDP";
          } else {
#line 5049
            tmp___16 = "TCP";
          }
#line 5049
          message((unsigned short)0, 0, (char *)"client requested %s mode and server is in %s mode",
                  tmp___16, tmp___15);
          goto fatal;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 5055
        if (udpMode) {
#line 5055
          tmp___17 = "UDP";
        } else {
#line 5055
          tmp___17 = "TCP";
        }
#line 5055
        message((unsigned short)3, 0, (char *)"accepted %s mode", tmp___17);
      }
    }
#line 5058
    maxSize = headerGetUShort(hdrData, 2);
#line 5059
    if ((int )maxSize > 0) {
#line 5061
      message((unsigned short)3, 0, (char *)"accepted buffer size %hu", maxSize);
    } else {
#line 5065
      message((unsigned short)0, 0, (char *)"server responded with zero buffer size");
      goto fatal;
    }
#line 5069
    cmpInfo = headerGetUShort(hdrData, 4);
#line 5070
    if ((int )cmpInfo <= (int )CompressInfo) {
#line 5072
      message((unsigned short)3, 0, (char *)"accepted compression level %#hx", cmpInfo);
    } else {
#line 5076
      message((unsigned short)0, 0, (char *)"server responded with invalid compression level (%#hx > %#hx)",
              cmpInfo, CompressInfo);
      goto fatal;
    }
#line 5080
    response = headerGetUShort(hdrData, 6);
#line 5081
    if ((int )response == (int )redirectPort) {
#line 5083
      message((unsigned short)3, 0, (char *)"redirection request accepted");
    } else {
#line 5087
      message((unsigned short)0, 0, (char *)"server refused request for redirection to %s:%hu",
              targetHost, redirectPort);
      goto fatal;
    }
#line 5091
    keyBits = headerGetUShort(hdrData, 8);
#line 5092
    if ((int )keyBits >= (int )MinKeyLength) {
#line 5094
      message((unsigned short)3, 0, (char *)"accepted key length %hu", keyBits);
    } else {
#line 5098
      message((unsigned short)0, 0, (char *)"server key length too small (%hu < %hu)",
              keyBits, MinKeyLength);
      goto fatal;
    }
#line 5102
    token = headerGetULong(hdrData, 10);
#line 5103
    message((unsigned short)3, 0, (char *)"accepted key reuse token %#lx", token);
#line 5105
    memcpy((void *)(serverNonce), (void const   *)(hdrData + 14), 8UL);
#line 5106
    message((unsigned short)3, 0, (char *)"received server nonce %02x%02x...", serverNonce[0],
            serverNonce[1]);
  } else {
#line 5116
    if ((int )protocol >= 257) {
#line 5118
      message((unsigned short)3, 0, (char *)"requesting buffer size %hu", maxSize);
#line 5120
      tmp___21 = requestResponse(serverFd, maxSize, & response);
#line 5120
      if (! tmp___21) {
#line 5122
        tmp___20 = __error();
#line 5122
        message((unsigned short)0, (*tmp___20), (char *)"failed requesting buffer size");
        goto fatal;
      }
#line 5126
      maxSize = response;
#line 5127
      message((unsigned short)3, 0, (char *)"accepted buffer size %hu", maxSize);
    }
#line 5130
    message((unsigned short)3, 0, (char *)"requesting compression level %#hx", CompressInfo);
#line 5132
    tmp___23 = requestResponse(serverFd, CompressInfo, & response);
#line 5132
    if (! tmp___23) {
#line 5134
      tmp___22 = __error();
#line 5134
      message((unsigned short)0, (*tmp___22), (char *)"failed requesting compression level");
      goto fatal;
    }
#line 5138
    if ((int )response > (int )CompressInfo) {
#line 5140
      message((unsigned short)0, 0, (char *)"server responded with invalid compression level (%#hx > %#hx)",
              response, CompressInfo);
      goto fatal;
    }
#line 5143
    cmpInfo = response;
#line 5144
    message((unsigned short)3, 0, (char *)"accepted compression level %#hx", response);
#line 5146
    message((unsigned short)3, 0, (char *)"requesting redirection to port %hu", redirectPort);
#line 5148
    tmp___25 = requestResponse(serverFd, redirectPort, & response);
#line 5148
    if (! tmp___25) {
#line 5150
      tmp___24 = __error();
#line 5150
      message((unsigned short)0, (*tmp___24), (char *)"failed requesting redirection port");
      goto fatal;
    }
#line 5154
    if ((int )response != (int )redirectPort) {
#line 5156
      tmp___26 = __error();
#line 5156
      message((unsigned short)0, (*tmp___26), (char *)"server refused request for redirection to port %hu",
              redirectPort);
      goto fatal;
    }
#line 5159
    message((unsigned short)3, 0, (char *)"redirection request accepted");
#line 5161
    message((unsigned short)3, 0, (char *)"requesting key length %hu", KeyLength);
#line 5163
    tmp___28 = requestResponse(serverFd, KeyLength, & response);
#line 5163
    if (! tmp___28) {
#line 5165
      tmp___27 = __error();
#line 5165
      message((unsigned short)0, (*tmp___27), (char *)"failed requesting key length");
      goto fatal;
    }
#line 5168
    keyBits = response;
#line 5170
    if ((int )keyBits < (int )MinKeyLength) {
#line 5172
      message((unsigned short)0, 0, (char *)"server key length too small (%hu < %hu)",
              keyBits, MinKeyLength);
      goto fatal;
    }
#line 5175
    message((unsigned short)3, 0, (char *)"accepted key length %hu", response);
  }
#line 5181
  msg = makeMsgBuf(maxSize, cmpInfo);
#line 5181
  if ((unsigned int )msg == (unsigned int )((void *)0)) {
#line 5183
    tmp___29 = __error();
#line 5183
    message((unsigned short)0, (*tmp___29), (char *)"client failed to allocate message buffer");
    goto fatal;
  }
#line 5198
  if ((int )protocol >= 512) {
#line 5198
    secretKeyStr = findKeyByToken(& ClientKeyList, token);
#line 5198
    if ((unsigned int )secretKeyStr != (unsigned int )((void *)0)) {
#line 5201
      sessionKeyStr = generateSessionKey(secretKeyStr, clientNonce, serverNonce, keyBits);
#line 5204
      tmp___30 = strlen((char const   *)sessionKeyStr);
#line 5204
      message((unsigned short)3, 0, (char *)"session key ends \'...%s\'", (sessionKeyStr + tmp___30) - 4);
#line 5206
      msg->bfWrite = setupBlowfish(sessionKeyStr, keyBits);
#line 5207
      msg->bfRead = setupBlowfish(sessionKeyStr, keyBits);
#line 5209
      tmp___31 = strlen((char const   *)secretKeyStr);
#line 5209
      memset((void *)secretKeyStr, 0, tmp___31);
#line 5210
      free((void *)secretKeyStr);
#line 5211
      secretKeyStr = (char *)((void *)0);
#line 5212
      tmp___32 = strlen((char const   *)sessionKeyStr);
#line 5212
      memset((void *)sessionKeyStr, 0, tmp___32);
#line 5213
      free((void *)sessionKeyStr);
#line 5214
      sessionKeyStr = (char *)((void *)0);
#line 5216
      tmp___33 = clientPerformChallenge(serverFd, msg);
#line 5216
      if (! tmp___33) {
#line 5218
        message((unsigned short)0, 0, (char *)"challenge/response failed to validate shared key (session token = %#08x)",
                CurrentToken);
#line 5219
        mutexLock(2);
#line 5220
        CurrentToken = 4294967295UL;
#line 5221
        mutexUnlock(2);
        goto fatal;
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
#line 5233
    if ((int )keyBits > 0) {
      goto _L___2;
    } else {
#line 5233
      if ((int )protocol < 258) {
        _L___2: /* CIL Label */ 
#line 5238
        message((unsigned short)3, 0, (char *)"reading DH generator");
#line 5240
        tmp___35 = readMessage(serverFd, msg, (unsigned short)1024);
#line 5240
        if (tmp___35 <= 0) {
#line 5242
          tmp___34 = __error();
#line 5242
          message((unsigned short)0, (*tmp___34), (char *)"failed reading DH generator");
          goto fatal;
        }
#line 5245
        getMsgBuf(msg, (void *)(generator), (unsigned short)1024);
#line 5247
        message((unsigned short)3, 0, (char *)"accepted generator \'%s\'", generator);
#line 5252
        message((unsigned short)3, 0, (char *)"reading DH modulus");
#line 5254
        tmp___37 = readMessage(serverFd, msg, (unsigned short)1024);
#line 5254
        if (tmp___37 <= 0) {
#line 5256
          tmp___36 = __error();
#line 5256
          message((unsigned short)0, (*tmp___36), (char *)"failed reading DH modulus");
          goto fatal;
        }
#line 5259
        getMsgBuf(msg, (void *)(modulus), (unsigned short)1024);
#line 5261
        message((unsigned short)3, 0, (char *)"accepted modulus \'%s\'", modulus);
#line 5266
        message((unsigned short)3, 0, (char *)"reading server DH key");
#line 5268
        tmp___39 = readMessage(serverFd, msg, (unsigned short)1024);
#line 5268
        if (tmp___39 <= 0) {
#line 5270
          tmp___38 = __error();
#line 5270
          message((unsigned short)0, (*tmp___38), (char *)"failed reading server DH key");
          goto fatal;
        }
#line 5273
        getMsgBuf(msg, (void *)(serverDhKey), (unsigned short)1024);
#line 5275
        message((unsigned short)3, 0, (char *)"accepted server DH key \'%s\'", serverDhKey);
#line 5282
        if (IdentityFile) {
#line 5284
          message((unsigned short)3, 0, (char *)"checking key against identity file \'%s\'",
                  IdentityFile);
#line 5286
          tmp___40 = checkIdentity(IdentityFile, generator, modulus, serverDhKey);
#line 5286
          if (! tmp___40) {
#line 5288
            message((unsigned short)0, 0, (char *)"server\'s identity not found in \'%s\'",
                    IdentityFile);
            goto fatal;
          }
        }
#line 5299
        message((unsigned short)3, 0, (char *)"generating private key");
#line 5301
        exponent = generateKey();
#line 5301
        if ((unsigned int )exponent == (unsigned int )((void *)0)) {
#line 5303
          message((unsigned short)0, 0, (char *)"can\'t generate private key");
          goto fatal;
        }
#line 5306
        message((unsigned short)3, 0, (char *)"private key generated");
#line 5313
        message((unsigned short)3, 0, (char *)"generating public DH key");
#line 5315
        dhKey = diffieHellman(generator, modulus, exponent);
#line 5315
        if ((unsigned int )dhKey == (unsigned int )((void *)0)) {
#line 5317
          message((unsigned short)0, 0, (char *)"can\'t generate public DH key");
          goto fatal;
        }
#line 5320
        message((unsigned short)3, 0, (char *)"public DH key is \'%s\'", dhKey);
#line 5324
        message((unsigned short)3, 0, (char *)"sending public DH key");
#line 5326
        tmp___41 = strlen((char const   *)dhKey);
#line 5326
        setMsgBuf(msg, (void *)dhKey, (unsigned short )(tmp___41 + 1UL));
#line 5327
        tmp___43 = writeMessage(serverFd, msg);
#line 5327
        if (tmp___43 != (int )msg->size) {
#line 5329
          tmp___42 = __error();
#line 5329
          message((unsigned short)0, (*tmp___42), (char *)"failed writing DH key to server");
          goto fatal;
        }
#line 5332
        message((unsigned short)3, 0, (char *)"sent public DH key");
#line 5336
        message((unsigned short)3, 0, (char *)"generating shared secret key");
#line 5338
        secretKeyStr = diffieHellman(serverDhKey, modulus, exponent);
#line 5340
        tmp___44 = strlen((char const   *)secretKeyStr);
#line 5340
        message((unsigned short)3, 0, (char *)"shared key ends \'...%s\'", (secretKeyStr + tmp___44) - 4);
#line 5342
        if ((int )protocol >= 512) {
#line 5344
          sessionKeyStr = generateSessionKey(secretKeyStr, clientNonce, serverNonce,
                                             keyBits);
#line 5347
          tmp___45 = strlen((char const   *)sessionKeyStr);
#line 5347
          message((unsigned short)3, 0, (char *)"session key ends \'...%s\'", (sessionKeyStr + tmp___45) - 4);
        } else {
#line 5351
          sessionKeyStr = secretKeyStr;
        }
#line 5354
        message((unsigned short)3, 0, (char *)"initialising encryption state");
#line 5356
        msg->bfWrite = setupBlowfish(sessionKeyStr, keyBits);
#line 5357
        msg->bfRead = setupBlowfish(sessionKeyStr, keyBits);
#line 5361
        tmp___46 = strlen((char const   *)exponent);
#line 5361
        memset((void *)exponent, 0, tmp___46);
#line 5362
        free((void *)exponent);
#line 5363
        exponent = (char *)((void *)0);
#line 5364
        free((void *)dhKey);
#line 5365
        dhKey = (char *)((void *)0);
#line 5373
        tmp___47 = clientPerformChallenge(serverFd, msg);
#line 5373
        if (! tmp___47) {
          goto fatal;
        }
#line 5384
        if ((int )protocol >= 512) {
#line 5384
          if (token != 0UL) {
#line 5386
            message((unsigned short)3, 0, (char *)"new reusable key token established (%#lx)",
                    token);
#line 5388
            addKeyInfoToList(& ClientKeyList, token, secretKeyStr);
#line 5389
            mutexLock(2);
#line 5390
            CurrentToken = token;
#line 5391
            mutexUnlock(2);
          }
        }
#line 5394
        if ((unsigned int )sessionKeyStr != (unsigned int )secretKeyStr) {
#line 5396
          tmp___48 = strlen((char const   *)sessionKeyStr);
#line 5396
          memset((void *)sessionKeyStr, 0, tmp___48);
#line 5397
          free((void *)sessionKeyStr);
#line 5398
          sessionKeyStr = (char *)((void *)0);
        }
#line 5400
        tmp___49 = strlen((char const   *)secretKeyStr);
#line 5400
        memset((void *)secretKeyStr, 0, tmp___49);
#line 5401
        free((void *)secretKeyStr);
#line 5402
        secretKeyStr = (char *)((void *)0);
      } else {
#line 5406
        message((unsigned short)3, 0, (char *)"key length is zero, omitting key exchange");
#line 5407
        if ((unsigned int )IdentityFile != (unsigned int )((void *)0)) {
#line 5409
          message((unsigned short)1, 0, (char *)"Warning: agreed key length is zero, no identity checking performed");
        }
      }
    }
  }
#line 5413
  message((unsigned short)1, 0, (char *)"tunnel established to %s port %hu", serverHost,
          redirectPort);
#line 5414
  message((unsigned short)2, 0, (char *)"compression level %#hx, key length %hu",
          cmpInfo, keyBits);
#line 5418
  message((unsigned short)3, 0, (char *)"entering filter loop");
#line 5420
  tmp___50 = filterLoop(clientFd, serverFd, msg, & argP->addr, & peerAddr, argP->listenFd,
                        udpMode);
#line 5420
  switch (tmp___50) {
  case 1: 
#line 5423
  tmp___51 = __error();
#line 5423
  message((unsigned short)0, (*tmp___51), (char *)"failed communicating with remote server");
  goto fatal;
  case -1: 
#line 5427
  tmp___52 = __error();
#line 5427
  message((unsigned short)0, (*tmp___52), (char *)"failed communicating with local client");
  goto fatal;
  }
#line 5431
  message((unsigned short)1, 0, (char *)"connection closed");
#line 5433
  close(clientFd);
#line 5434
  close(serverFd);
#line 5435
  freeMsgBuf(msg);
#line 5436
  removeHandler(& argP->addr);
#line 5437
  free((void *)argP);
#line 5438
  incrActiveCount(-1);
#line 5442
  return;
  fatal: 
#line 5445
  if (serverFd != -1) {
#line 5445
    close(serverFd);
  }
#line 5446
  if (clientFd != -1) {
#line 5446
    close(clientFd);
  }
#line 5447
  if (exponent) {
#line 5447
    free((void *)exponent);
  }
#line 5448
  if (dhKey) {
#line 5448
    free((void *)dhKey);
  }
#line 5449
  if (sessionKeyStr) {
#line 5449
    if ((unsigned int )sessionKeyStr != (unsigned int )secretKeyStr) {
#line 5449
      free((void *)sessionKeyStr);
    }
  }
#line 5450
  if (secretKeyStr) {
#line 5450
    free((void *)secretKeyStr);
  }
#line 5451
  freeMsgBuf(msg);
#line 5452
  removeHandler(& argP->addr);
#line 5453
  free((void *)argP);
#line 5454
  incrActiveCount(-1);
#line 5458
  inLine = 0;
#line 5459
  return;
}
}
#line 5470 "zebedee.c"
void serverListener(unsigned short *portPtr ) 
{ int listenFd ;
  int clientFd ;
  struct sockaddr_in addr ;
  int addrLen ;
  char ipBuf[16] ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 5482
  listenFd = makeListener(portPtr, ListenIp, 0);
#line 5482
  if (listenFd == -1) {
#line 5484
    message((unsigned short)0, 0, (char *)"server can\'t listen on port %hu", (*portPtr));
#line 5485
    exit(1);
  }
#line 5490
  if (IsDetached) {
#line 5492
    message((unsigned short)3, 0, (char *)"detaching from terminal");
#line 5493
    makeDetached();
  }
#line 5496
  while (1) {
#line 5498
    message((unsigned short)1, 0, (char *)"waiting for connection on port %hu", (*portPtr));
#line 5500
    memset((void *)(& addr), 0, (unsigned long )sizeof(addr));
#line 5501
    addrLen = (int )sizeof(struct sockaddr_in );
#line 5502
    clientFd = accept(listenFd, (struct sockaddr *)(& addr), (socklen_t *)(& addrLen));
#line 5502
    if (clientFd < 0) {
#line 5504
      tmp = __error();
#line 5504
      message((unsigned short)0, (*tmp), (char *)"error on accept");
    } else {
#line 5508
      tmp___0 = ipString(addr.sin_addr, ipBuf);
#line 5508
      message((unsigned short)1, 0, (char *)"accepted connection from %s", tmp___0);
#line 5512
      setNoLinger(clientFd);
#line 5516
      setKeepAlive(clientFd);
#line 5520
      spawnHandler(& server, listenFd, clientFd, Debug, & addr, 0);
    }
  }
}
}
#line 5525 "zebedee.c"
void serverInitiator(char *clientHost , unsigned short port , unsigned short timeout ) 
{ int clientFd ;
  struct timeval delay ;
  fd_set testSet ;
  int ready ;
  int *tmp ;
  int __fd ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 5528
  clientFd = -1;
#line 5534
  while (1) {
#line 5536
    message((unsigned short)2, 0, (char *)"initiating connection back to client at %s:%hu",
            clientHost, port);
#line 5538
    clientFd = makeConnection((char const   *)clientHost, port, 0, 1, (struct sockaddr_in *)((void *)0),
                              (struct sockaddr_in *)((void *)0));
#line 5538
    if (clientFd == -1) {
#line 5540
      tmp = __error();
#line 5540
      message((unsigned short)0, (*tmp), (char *)"failed to connect back to client at %s:%hu",
              clientHost, port);
#line 5541
      exit(1);
    }
#line 5549
    if (IsDetached) {
#line 5549
      if (IsDetached != -1) {
#line 5551
        message((unsigned short)3, 0, (char *)"detaching from terminal");
#line 5552
        makeDetached();
      }
    }
#line 5560
    delay.tv_sec = (long )timeout;
#line 5561
    delay.tv_usec = 0;
#line 5563
    __builtin_bzero(& testSet, sizeof(testSet));
#line 5564
    while (1) {
#line 5564
      __fd = clientFd;
#line 5564
      testSet.fds_bits[(unsigned int )__fd / (sizeof(__int32_t ) * 8U)] |= 1 << (unsigned int )__fd % (sizeof(__int32_t ) * 8U);
#line 5564
      break;
    }
#line 5566
    ready = select(clientFd + 1, & testSet, (fd_set *)0, (fd_set *)0, & delay);
#line 5568
    if (ready == 0) {
#line 5570
      message((unsigned short)0, 0, (char *)"timed out waiting for accepted connection from client");
#line 5571
      break;
    }
#line 5576
    if (ready < 0) {
#line 5578
      tmp___1 = __error();
#line 5578
      if ((*tmp___1) != 4) {
#line 5580
        tmp___0 = __error();
#line 5580
        message((unsigned short)0, (*tmp___0), (char *)"error in select waiting for client to accept connection");
#line 5581
        break;
      }
    } else {
#line 5586
      spawnHandler(& server, -1, clientFd, 0, (struct sockaddr_in *)((void *)0), 0);
    }
  }
#line 5590
  close(clientFd);
#line 5594
  waitForInactivity();
#line 5595
  return;
}
}
#line 5605 "zebedee.c"
void server(FnArgs_t *argP ) 
{ int clientFd ;
  int localFd ;
  unsigned short request ;
  unsigned short response ;
  unsigned short cmpInfo ;
  unsigned short keyBits ;
  unsigned short port ;
  unsigned short protocol ;
  unsigned short maxSize ;
  char clientDhKey[1024] ;
  char *exponent ;
  char *dhKey ;
  char *secretKeyStr ;
  char *sessionKeyStr ;
  int len ;
  MsgBuf_t *msg ;
  unsigned long token ;
  unsigned char hdrData[26] ;
  unsigned short hdrSize ;
  struct sockaddr_in localAddr ;
  struct sockaddr_in peerAddr ;
  unsigned char clientNonce[8] ;
  unsigned char serverNonce[8] ;
  char *targetHost ;
  int inLine ;
  int udpMode ;
  char ipBuf[16] ;
  char *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  unsigned short tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  unsigned long tmp___18 ;
  __uint32_t tmp___19 ;
  char *tmp___20 ;
  int *tmp___21 ;
  struct sockaddr_in *tmp___22 ;
  char const   *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int *tmp___26 ;
  int tmp___27 ;
  int *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int *tmp___31 ;
  int tmp___32 ;
  int *tmp___33 ;
  int tmp___34 ;
  int *tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int *tmp___38 ;
  struct sockaddr_in *tmp___39 ;
  int *tmp___40 ;
  int tmp___41 ;
  int *tmp___42 ;
  int tmp___43 ;
  int *tmp___44 ;
  int tmp___45 ;
  int *tmp___46 ;
  size_t tmp___47 ;
  size_t tmp___48 ;
  size_t tmp___49 ;
  int tmp___50 ;
  size_t tmp___51 ;
  int tmp___52 ;
  long tmp___53 ;
  size_t tmp___54 ;
  int *tmp___55 ;
  int tmp___56 ;
  size_t tmp___57 ;
  int tmp___58 ;
  long tmp___59 ;
  size_t tmp___60 ;
  int *tmp___61 ;
  int tmp___62 ;
  int *tmp___63 ;
  int *tmp___64 ;
  size_t tmp___65 ;
  int tmp___66 ;
  long tmp___67 ;
  size_t tmp___68 ;
  int *tmp___69 ;
  int tmp___70 ;
  int *tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  size_t tmp___74 ;
  size_t tmp___75 ;
  size_t tmp___76 ;
  int tmp___77 ;
  size_t tmp___78 ;
  size_t tmp___79 ;
  int tmp___80 ;
  int *tmp___81 ;
  int *tmp___82 ;
  int *tmp___83 ;

  {
#line 5608
  clientFd = argP->fd;
#line 5609
  localFd = -1;
#line 5610
  request = (unsigned short)0;
#line 5611
  response = (unsigned short)0;
#line 5612
  cmpInfo = CompressInfo;
#line 5613
  keyBits = KeyLength;
#line 5614
  port = (unsigned short)0;
#line 5615
  protocol = (unsigned short)513;
#line 5616
  maxSize = MaxBufSize;
#line 5618
  exponent = (char *)((void *)0);
#line 5619
  dhKey = (char *)((void *)0);
#line 5620
  secretKeyStr = (char *)((void *)0);
#line 5621
  sessionKeyStr = (char *)((void *)0);
#line 5622
  len = -1;
#line 5623
  msg = (MsgBuf_t *)((void *)0);
#line 5624
  token = 0UL;
#line 5631
  targetHost = TargetHost;
#line 5632
  inLine = argP->inLine;
#line 5633
  udpMode = argP->udpMode;
#line 5637
  incrActiveCount(1);
#line 5638
  message((unsigned short)3, 0, (char *)"server routine entered");
#line 5645
  message((unsigned short)3, 0, (char *)"validating client IP address");
#line 5646
  tmp___0 = checkPeerAddress(clientFd, & peerAddr);
#line 5646
  if (! tmp___0) {
#line 5648
    tmp = ipString(peerAddr.sin_addr, ipBuf);
#line 5648
    message((unsigned short)0, 0, (char *)"client connection from %s disallowed",
            tmp);
    goto fatal;
  }
#line 5654
  message((unsigned short)3, 0, (char *)"reading protocol version ");
#line 5656
  tmp___2 = readUShort(clientFd, & request);
#line 5656
  if (tmp___2 != 2) {
#line 5658
    tmp___1 = __error();
#line 5658
    message((unsigned short)0, (*tmp___1), (char *)"failed reading protocol version");
    goto fatal;
  }
#line 5662
  message((unsigned short)3, 0, (char *)"read protocol version %#hx", request);
#line 5670
  if ((int )request == 512) {
#line 5673
    protocol = request;
  } else {
#line 5670
    if ((int )request <= 258) {
#line 5670
      if ((int )request >= 256) {
#line 5673
        protocol = request;
      } else {
#line 5678
        protocol = (unsigned short)513;
      }
    } else {
#line 5678
      protocol = (unsigned short)513;
    }
  }
#line 5681
  message((unsigned short)3, 0, (char *)"replying with protocol version %#hx", protocol);
#line 5683
  tmp___4 = writeUShort(clientFd, protocol);
#line 5683
  if (tmp___4 != 2) {
#line 5685
    tmp___3 = __error();
#line 5685
    message((unsigned short)0, (*tmp___3), (char *)"failed writing protocol version back to client");
    goto fatal;
  }
#line 5694
  if ((int )protocol >= 512) {
#line 5696
    if ((int )protocol >= 513) {
#line 5698
      hdrSize = (unsigned short)26;
    } else {
#line 5702
      hdrSize = (unsigned short)22;
    }
#line 5705
    tmp___6 = readData(clientFd, hdrData, hdrSize);
#line 5705
    if (tmp___6 != (int )hdrSize) {
#line 5707
      tmp___5 = __error();
#line 5707
      message((unsigned short)0, (*tmp___5), (char *)"failed reading protocol header from client");
      goto fatal;
    }
#line 5711
    tmp___7 = headerGetUShort(hdrData, 0);
#line 5711
    udpMode = (int )tmp___7 == 1;
#line 5712
    if (udpMode) {
#line 5712
      if (! UdpMode) {
        goto _L;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 5712
      if (! udpMode) {
#line 5712
        if (! TcpMode) {
          _L: /* CIL Label */ 
#line 5714
          if (udpMode) {
#line 5714
            tmp___8 = "TCP";
          } else {
#line 5714
            tmp___8 = "UDP";
          }
#line 5714
          if (udpMode) {
#line 5714
            tmp___9 = "UDP";
          } else {
#line 5714
            tmp___9 = "TCP";
          }
#line 5714
          message((unsigned short)0, 0, (char *)"client requested %s mode tunnel to %s mode server",
                  tmp___9, tmp___8);
#line 5716
          if (udpMode) {
#line 5716
            tmp___10 = 0;
          } else {
#line 5716
            tmp___10 = 1;
          }
#line 5716
          headerSetUShort(hdrData, (unsigned short )tmp___10, 0);
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 5720
        if (udpMode) {
#line 5720
          tmp___11 = "UDP";
        } else {
#line 5720
          tmp___11 = "TCP";
        }
#line 5720
        message((unsigned short)3, 0, (char *)"replying with %s mode", tmp___11);
#line 5721
        if (udpMode) {
#line 5721
          tmp___12 = 1;
        } else {
#line 5721
          tmp___12 = 0;
        }
#line 5721
        headerSetUShort(hdrData, (unsigned short )tmp___12, 0);
      }
    }
#line 5724
    maxSize = headerGetUShort(hdrData, 2);
#line 5725
    message((unsigned short)3, 0, (char *)"read buffer size request of %hu", maxSize);
#line 5729
    if ((int )maxSize > (int )MaxBufSize) {
#line 5731
      maxSize = MaxBufSize;
    }
#line 5734
    message((unsigned short)3, 0, (char *)"replying with buffer size %hu", maxSize);
#line 5735
    headerSetUShort(hdrData, maxSize, 2);
#line 5737
    request = headerGetUShort(hdrData, 4);
#line 5738
    message((unsigned short)3, 0, (char *)"read compression level %#hx", request);
#line 5749
    if ((int )request < (int )cmpInfo) {
#line 5751
      cmpInfo = request;
#line 5752
      response = request;
    } else {
#line 5756
      response = cmpInfo;
    }
#line 5759
    message((unsigned short)3, 0, (char *)"replying with compression level %#hx",
            response);
#line 5760
    headerSetUShort(hdrData, response, 4);
#line 5762
    request = headerGetUShort(hdrData, 6);
#line 5763
    message((unsigned short)3, 0, (char *)"read port %hu", request);
#line 5765
    memset((void *)(& localAddr), 0, (unsigned long )sizeof(localAddr));
#line 5766
    if ((int )protocol >= 513) {
#line 5768
      tmp___18 = headerGetULong(hdrData, 22);
#line 5768
      tmp___19 = _OSSwapInt32((unsigned int )(tmp___18 & 4294967295UL));
#line 5768
      localAddr.sin_addr.s_addr = tmp___19;
#line 5769
      tmp___20 = ipString(localAddr.sin_addr, ipBuf);
#line 5769
      message((unsigned short)3, 0, (char *)"read target address %s", tmp___20);
    }
#line 5784
    message((unsigned short)3, 0, (char *)"checking if redirection is allowed");
#line 5786
    tmp___25 = allowRedirect(request, & localAddr, udpMode, & targetHost);
#line 5786
    if (tmp___25) {
#line 5788
      message((unsigned short)3, 0, (char *)"allowed redirection request to %s:%hu",
              targetHost, request);
#line 5796
      message((unsigned short)3, 0, (char *)"opening connection to port %hu on %s",
              request, targetHost);
#line 5798
      memset((void *)(& localAddr), 0, (unsigned long )sizeof(localAddr));
#line 5799
      if (Transparent) {
#line 5799
        tmp___22 = & peerAddr;
      } else {
#line 5799
        tmp___22 = (struct sockaddr_in *)((void *)0);
      }
#line 5799
      localFd = makeConnection((char const   *)targetHost, request, udpMode, 0, tmp___22,
                               & localAddr);
#line 5799
      if (localFd == -1) {
#line 5803
        port = (unsigned short)0;
#line 5804
        tmp___21 = __error();
#line 5804
        message((unsigned short)0, (*tmp___21), (char *)"failed connecting to port %hu on %s",
                request, targetHost);
#line 5805
        headerSetUShort(hdrData, (unsigned short)0, 6);
      } else {
#line 5811
        port = request;
#line 5812
        message((unsigned short)3, 0, (char *)"made connection to target -- writing back %hu to client",
                port);
#line 5813
        headerSetUShort(hdrData, port, 6);
      }
    } else {
#line 5818
      if (udpMode) {
#line 5818
        tmp___23 = "udp";
      } else {
#line 5818
        tmp___23 = "tcp";
      }
#line 5818
      tmp___24 = ipString(localAddr.sin_addr, ipBuf);
#line 5818
      message((unsigned short)0, 0, (char *)"client requested redirection to a disallowed target (%s:%hu/%s)",
              tmp___24, request, tmp___23);
#line 5819
      headerSetUShort(hdrData, (unsigned short)0, 6);
    }
#line 5822
    request = headerGetUShort(hdrData, 8);
#line 5823
    message((unsigned short)3, 0, (char *)"client requested key length %hu", request);
#line 5830
    if ((int )request > (int )keyBits) {
#line 5832
      response = keyBits;
    } else {
#line 5834
      if ((int )request >= (int )MinKeyLength) {
#line 5836
        keyBits = request;
#line 5837
        response = request;
      } else {
#line 5841
        keyBits = MinKeyLength;
#line 5842
        response = MinKeyLength;
      }
    }
#line 5845
    message((unsigned short)3, 0, (char *)"replying with key length %hu", response);
#line 5846
    headerSetUShort(hdrData, response, 8);
#line 5848
    token = headerGetULong(hdrData, 10);
#line 5849
    message((unsigned short)3, 0, (char *)"client requested key reuse token %#lx",
            token);
#line 5851
    if (token != 0UL) {
#line 5858
      secretKeyStr = findKeyByToken(& ServerKeyList, token);
#line 5858
      if ((unsigned int )secretKeyStr == (unsigned int )((void *)0)) {
#line 5860
        token = generateToken(& ServerKeyList, token);
      }
    }
#line 5863
    headerSetULong(hdrData, token, 10);
#line 5864
    message((unsigned short)3, 0, (char *)"returned key reuse token %#lx", token);
#line 5866
    memcpy((void *)(clientNonce), (void const   *)(hdrData + 14), 8UL);
#line 5867
    message((unsigned short)3, 0, (char *)"received client nonce %02x%02x...", clientNonce[0],
            clientNonce[1]);
#line 5869
    generateNonce(serverNonce);
#line 5870
    message((unsigned short)3, 0, (char *)"sending server nonce %02x%02x...", serverNonce[0],
            serverNonce[1]);
#line 5871
    memcpy((void *)(hdrData + 14), (void const   *)(serverNonce), 8UL);
#line 5873
    tmp___27 = writeData(clientFd, hdrData, hdrSize);
#line 5873
    if (tmp___27 != (int )hdrSize) {
#line 5875
      tmp___26 = __error();
#line 5875
      message((unsigned short)0, (*tmp___26), (char *)"failed writing protocol header back to client");
      goto fatal;
    }
  } else {
#line 5887
    if ((int )protocol >= 257) {
#line 5889
      message((unsigned short)3, 0, (char *)"reading message buffer size");
#line 5891
      tmp___29 = readUShort(clientFd, & maxSize);
#line 5891
      if (tmp___29 != 2) {
#line 5893
        tmp___28 = __error();
#line 5893
        message((unsigned short)0, (*tmp___28), (char *)"failed reading message buffer size");
      }
#line 5896
      message((unsigned short)3, 0, (char *)"read buffer size request of %hu", maxSize);
#line 5898
      if ((int )maxSize > (int )MaxBufSize) {
#line 5900
        maxSize = MaxBufSize;
      }
#line 5903
      message((unsigned short)3, 0, (char *)"replying with buffer size %hu", maxSize);
#line 5905
      tmp___30 = writeUShort(clientFd, maxSize);
#line 5905
      if (tmp___30 != 2) {
#line 5907
        message((unsigned short)0, 0, (char *)"failed to write buffer size back to the client");
        goto fatal;
      }
    } else {
#line 5913
      message((unsigned short)3, 0, (char *)"using default buffer size (%hu)", maxSize);
#line 5914
      maxSize = (unsigned short)8192;
    }
#line 5917
    message((unsigned short)3, 0, (char *)"reading compression level");
#line 5919
    tmp___32 = readUShort(clientFd, & request);
#line 5919
    if (tmp___32 != 2) {
#line 5921
      tmp___31 = __error();
#line 5921
      message((unsigned short)0, (*tmp___31), (char *)"failed reading compression level");
      goto fatal;
    }
#line 5924
    message((unsigned short)3, 0, (char *)"read compression level %#hx", request);
#line 5926
    if ((int )request < (int )cmpInfo) {
#line 5928
      cmpInfo = request;
#line 5929
      response = request;
    } else {
#line 5933
      response = cmpInfo;
    }
#line 5936
    message((unsigned short)3, 0, (char *)"replying with compression level %#hx",
            response);
#line 5938
    tmp___34 = writeUShort(clientFd, response);
#line 5938
    if (tmp___34 != 2) {
#line 5940
      tmp___33 = __error();
#line 5940
      message((unsigned short)0, (*tmp___33), (char *)"failed writing compression level back to client");
      goto fatal;
    }
#line 5944
    message((unsigned short)3, 0, (char *)"reading redirection port");
#line 5946
    tmp___36 = readUShort(clientFd, & request);
#line 5946
    if (tmp___36 != 2) {
#line 5948
      tmp___35 = __error();
#line 5948
      message((unsigned short)0, (*tmp___35), (char *)"failed reading redirection port");
      goto fatal;
    }
#line 5951
    message((unsigned short)3, 0, (char *)"read port %hu", request);
#line 5953
    message((unsigned short)3, 0, (char *)"checking if redirection is allowed");
#line 5955
    tmp___37 = allowRedirect(request, & localAddr, udpMode, & targetHost);
#line 5955
    if (! tmp___37) {
#line 5957
      message((unsigned short)0, 0, (char *)"client requested redirection to a disallowed port (%s:%hu/%s)",
              request);
#line 5958
      writeUShort(clientFd, (unsigned short)0);
      goto fatal;
    }
#line 5962
    message((unsigned short)3, 0, (char *)"allowed redirection request to %hu", request);
#line 5964
    message((unsigned short)3, 0, (char *)"opening connection to port %hu on %s",
            request, targetHost);
#line 5966
    memset((void *)(& localAddr), 0, (unsigned long )sizeof(localAddr));
#line 5967
    if (Transparent) {
#line 5967
      tmp___39 = & peerAddr;
    } else {
#line 5967
      tmp___39 = (struct sockaddr_in *)((void *)0);
    }
#line 5967
    localFd = makeConnection((char const   *)targetHost, request, udpMode, 0, tmp___39,
                             & localAddr);
#line 5967
    if (localFd == -1) {
#line 5971
      tmp___38 = __error();
#line 5971
      message((unsigned short)0, (*tmp___38), (char *)"failed connecting to port %hu on %s",
              request, targetHost);
#line 5972
      writeUShort(clientFd, (unsigned short)0);
      goto fatal;
    }
#line 5975
    port = request;
#line 5977
    message((unsigned short)3, 0, (char *)"made local connection -- writing back %hu to client",
            request);
#line 5979
    tmp___41 = writeUShort(clientFd, request);
#line 5979
    if (tmp___41 != 2) {
#line 5981
      tmp___40 = __error();
#line 5981
      message((unsigned short)0, (*tmp___40), (char *)"failed writing redirection port back to client");
      goto fatal;
    }
#line 5985
    message((unsigned short)3, 0, (char *)"reading key length");
#line 5987
    tmp___43 = readUShort(clientFd, & request);
#line 5987
    if (tmp___43 != 2) {
#line 5989
      tmp___42 = __error();
#line 5989
      message((unsigned short)0, (*tmp___42), (char *)"failed reading key length");
      goto fatal;
    }
#line 5993
    message((unsigned short)3, 0, (char *)"read key length %hu", request);
#line 5995
    if ((int )request > (int )keyBits) {
#line 5997
      response = keyBits;
    } else {
#line 5999
      if ((int )request >= (int )MinKeyLength) {
#line 6001
        keyBits = request;
#line 6002
        response = request;
      } else {
#line 6006
        keyBits = MinKeyLength;
#line 6007
        response = MinKeyLength;
      }
    }
#line 6010
    message((unsigned short)3, 0, (char *)"replying with key length %hu", response);
#line 6012
    tmp___45 = writeUShort(clientFd, response);
#line 6012
    if (tmp___45 != 2) {
#line 6014
      tmp___44 = __error();
#line 6014
      message((unsigned short)0, (*tmp___44), (char *)"failed writing key length back to client");
      goto fatal;
    }
  }
#line 6021
  if ((int )port == 0) {
#line 6023
    message((unsigned short)0, 0, (char *)"initial protocol exchange failed");
    goto fatal;
  }
#line 6029
  msg = makeMsgBuf(maxSize, cmpInfo);
#line 6029
  if ((unsigned int )msg == (unsigned int )((void *)0)) {
#line 6031
    tmp___46 = __error();
#line 6031
    message((unsigned short)0, (*tmp___46), (char *)"client failed to allocate message buffer");
    goto fatal;
  }
#line 6042
  if ((int )protocol >= 512) {
#line 6042
    if ((unsigned int )secretKeyStr != (unsigned int )((void *)0)) {
#line 6044
      sessionKeyStr = generateSessionKey(secretKeyStr, clientNonce, serverNonce, keyBits);
#line 6047
      tmp___47 = strlen((char const   *)sessionKeyStr);
#line 6047
      message((unsigned short)3, 0, (char *)"session key ends \'...%s\'", (sessionKeyStr + tmp___47) - 4);
#line 6049
      msg->bfWrite = setupBlowfish(sessionKeyStr, keyBits);
#line 6050
      msg->bfRead = setupBlowfish(sessionKeyStr, keyBits);
#line 6052
      tmp___48 = strlen((char const   *)sessionKeyStr);
#line 6052
      memset((void *)sessionKeyStr, 0, tmp___48);
#line 6053
      free((void *)sessionKeyStr);
#line 6054
      sessionKeyStr = (char *)((void *)0);
#line 6055
      tmp___49 = strlen((char const   *)secretKeyStr);
#line 6055
      memset((void *)secretKeyStr, 0, tmp___49);
#line 6056
      free((void *)secretKeyStr);
#line 6057
      secretKeyStr = (char *)((void *)0);
#line 6059
      tmp___50 = serverPerformChallenge(clientFd, msg);
#line 6059
      if (! tmp___50) {
#line 6061
        message((unsigned short)0, 0, (char *)"challenge/response failed to validate shared key (session token = %#08x)",
                token);
        goto fatal;
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
#line 6072
    if ((int )keyBits > 0) {
      goto _L___2;
    } else {
#line 6072
      if ((int )protocol < 258) {
        _L___2: /* CIL Label */ 
#line 6084
        message((unsigned short)3, 0, (char *)"sending DH generator \'%s\'", Generator);
#line 6086
        tmp___51 = strlen((char const   *)Generator);
#line 6086
        len = (int )(tmp___51 + 1UL);
#line 6086
        if (len <= 1024) {
#line 6086
          tmp___52 = 0;
        } else {
#line 6086
          tmp___52 = 1;
        }
#line 6086
        tmp___53 = __builtin_expect((long )tmp___52, 0L);
#line 6086
        if (tmp___53) {
#line 6086
          __assert_rtn("server", "zebedee.c", 6086, "(len = strlen(Generator) + 1) <= MAX_LINE_SIZE");
        }
#line 6087
        tmp___54 = strlen((char const   *)Generator);
#line 6087
        setMsgBuf(msg, (void *)Generator, (unsigned short )(tmp___54 + 1UL));
#line 6089
        tmp___56 = writeMessage(clientFd, msg);
#line 6089
        if (tmp___56 != len) {
#line 6091
          tmp___55 = __error();
#line 6091
          message((unsigned short)0, (*tmp___55), (char *)"failed writing generator to client");
          goto fatal;
        }
#line 6095
        message((unsigned short)3, 0, (char *)"sent generator");
#line 6099
        message((unsigned short)3, 0, (char *)"sending DH modulus \'%s\'", Modulus);
#line 6101
        tmp___57 = strlen((char const   *)Modulus);
#line 6101
        len = (int )(tmp___57 + 1UL);
#line 6101
        if (len <= 1024) {
#line 6101
          tmp___58 = 0;
        } else {
#line 6101
          tmp___58 = 1;
        }
#line 6101
        tmp___59 = __builtin_expect((long )tmp___58, 0L);
#line 6101
        if (tmp___59) {
#line 6101
          __assert_rtn("server", "zebedee.c", 6101, "(len = strlen(Modulus) + 1) <= MAX_LINE_SIZE");
        }
#line 6102
        tmp___60 = strlen((char const   *)Modulus);
#line 6102
        setMsgBuf(msg, (void *)Modulus, (unsigned short )(tmp___60 + 1UL));
#line 6104
        tmp___62 = writeMessage(clientFd, msg);
#line 6104
        if (tmp___62 != len) {
#line 6106
          tmp___61 = __error();
#line 6106
          message((unsigned short)0, (*tmp___61), (char *)"failed writing modulus to client");
          goto fatal;
        }
#line 6110
        message((unsigned short)3, 0, (char *)"sent modulus", Modulus);
#line 6121
        message((unsigned short)3, 0, (char *)"generating private key");
#line 6123
        exponent = generateKey();
#line 6123
        if ((unsigned int )exponent == (unsigned int )((void *)0)) {
#line 6125
          tmp___63 = __error();
#line 6125
          message((unsigned short)0, (*tmp___63), (char *)"can\'t generate private key");
          goto fatal;
        }
#line 6129
        message((unsigned short)3, 0, (char *)"private key generated");
#line 6131
        message((unsigned short)3, 0, (char *)"generating public DH key");
#line 6133
        dhKey = diffieHellman(Generator, Modulus, exponent);
#line 6133
        if ((unsigned int )dhKey == (unsigned int )((void *)0)) {
#line 6135
          tmp___64 = __error();
#line 6135
          message((unsigned short)0, (*tmp___64), (char *)"can\'t generate public DH key");
          goto fatal;
        }
#line 6139
        message((unsigned short)3, 0, (char *)"public DH key is \'%s\'", dhKey);
#line 6143
        message((unsigned short)3, 0, (char *)"sending public DH key");
#line 6145
        tmp___65 = strlen((char const   *)dhKey);
#line 6145
        len = (int )(tmp___65 + 1UL);
#line 6145
        if (len <= 1024) {
#line 6145
          tmp___66 = 0;
        } else {
#line 6145
          tmp___66 = 1;
        }
#line 6145
        tmp___67 = __builtin_expect((long )tmp___66, 0L);
#line 6145
        if (tmp___67) {
#line 6145
          __assert_rtn("server", "zebedee.c", 6145, "(len = strlen(dhKey) + 1) <= MAX_LINE_SIZE");
        }
#line 6146
        tmp___68 = strlen((char const   *)dhKey);
#line 6146
        setMsgBuf(msg, (void *)dhKey, (unsigned short )(tmp___68 + 1UL));
#line 6148
        tmp___70 = writeMessage(clientFd, msg);
#line 6148
        if (tmp___70 != len) {
#line 6150
          tmp___69 = __error();
#line 6150
          message((unsigned short)0, (*tmp___69), (char *)"failed writing DH key to client");
          goto fatal;
        }
#line 6154
        message((unsigned short)3, 0, (char *)"sent public DH key");
#line 6159
        message((unsigned short)3, 0, (char *)"reading client DH key");
#line 6161
        tmp___72 = readMessage(clientFd, msg, (unsigned short)1024);
#line 6161
        if (tmp___72 <= 0) {
#line 6163
          tmp___71 = __error();
#line 6163
          message((unsigned short)0, (*tmp___71), (char *)"failed reading client DH key");
          goto fatal;
        }
#line 6166
        getMsgBuf(msg, (void *)(clientDhKey), (unsigned short)1024);
#line 6168
        message((unsigned short)3, 0, (char *)"accepted client DH key \'%s\'", clientDhKey);
#line 6176
        if (IdentityFile) {
#line 6178
          message((unsigned short)3, 0, (char *)"checking key against identity file \'%s\'",
                  IdentityFile);
#line 6180
          tmp___73 = checkIdentity(IdentityFile, Generator, Modulus, clientDhKey);
#line 6180
          if (! tmp___73) {
#line 6182
            message((unsigned short)0, 0, (char *)"client\'s key identity not found in \'%s\'",
                    IdentityFile);
            goto fatal;
          }
        }
#line 6190
        message((unsigned short)3, 0, (char *)"generating shared secret key");
#line 6192
        secretKeyStr = diffieHellman(clientDhKey, Modulus, exponent);
#line 6194
        tmp___74 = strlen((char const   *)secretKeyStr);
#line 6194
        message((unsigned short)3, 0, (char *)"shared key ends \'...%s\'", (secretKeyStr + tmp___74) - 4);
#line 6196
        if ((int )protocol >= 512) {
#line 6198
          sessionKeyStr = generateSessionKey(secretKeyStr, clientNonce, serverNonce,
                                             keyBits);
#line 6201
          tmp___75 = strlen((char const   *)sessionKeyStr);
#line 6201
          message((unsigned short)3, 0, (char *)"session key ends \'...%s\'", (sessionKeyStr + tmp___75) - 4);
        } else {
#line 6205
          sessionKeyStr = secretKeyStr;
        }
#line 6208
        message((unsigned short)3, 0, (char *)"initialising encryption state");
#line 6210
        msg->bfWrite = setupBlowfish(sessionKeyStr, keyBits);
#line 6211
        msg->bfRead = setupBlowfish(sessionKeyStr, keyBits);
#line 6215
        free((void *)dhKey);
#line 6216
        dhKey = (char *)((void *)0);
#line 6217
        tmp___76 = strlen((char const   *)exponent);
#line 6217
        memset((void *)exponent, 0, tmp___76);
#line 6218
        free((void *)exponent);
#line 6219
        exponent = (char *)((void *)0);
#line 6227
        tmp___77 = serverPerformChallenge(clientFd, msg);
#line 6227
        if (! tmp___77) {
          goto fatal;
        }
#line 6237
        if ((int )protocol >= 512) {
#line 6237
          if (token != 0UL) {
#line 6239
            message((unsigned short)3, 0, (char *)"new reusable key token established (%#lx)",
                    token);
#line 6240
            addKeyInfoToList(& ServerKeyList, token, secretKeyStr);
          }
        }
#line 6243
        if ((unsigned int )sessionKeyStr != (unsigned int )secretKeyStr) {
#line 6245
          tmp___78 = strlen((char const   *)sessionKeyStr);
#line 6245
          memset((void *)sessionKeyStr, 0, tmp___78);
#line 6246
          free((void *)sessionKeyStr);
#line 6247
          sessionKeyStr = (char *)((void *)0);
        }
#line 6249
        tmp___79 = strlen((char const   *)secretKeyStr);
#line 6249
        memset((void *)secretKeyStr, 0, tmp___79);
#line 6250
        free((void *)secretKeyStr);
#line 6251
        secretKeyStr = (char *)((void *)0);
      } else {
#line 6255
        message((unsigned short)3, 0, (char *)"key length is zero, omitting key exchange");
#line 6256
        if ((unsigned int )IdentityFile != (unsigned int )((void *)0)) {
#line 6258
          message((unsigned short)1, 0, (char *)"Warning: agreed key length is zero, no identity checking performed");
        }
      }
    }
  }
#line 6262
  message((unsigned short)1, 0, (char *)"tunnel established to target %s, port %hu",
          targetHost, port);
#line 6263
  message((unsigned short)2, 0, (char *)"compression level %#hx, key length %hu",
          cmpInfo, keyBits);
#line 6267
  message((unsigned short)3, 0, (char *)"entering filter loop");
#line 6269
  tmp___80 = filterLoop(localFd, clientFd, msg, & localAddr, & peerAddr, localFd,
                        udpMode);
#line 6269
  switch (tmp___80) {
  case 1: 
#line 6272
  tmp___81 = __error();
#line 6272
  message((unsigned short)0, (*tmp___81), (char *)"failed communicating with remote client");
  goto fatal;
  case -1: 
#line 6276
  tmp___82 = __error();
#line 6276
  message((unsigned short)0, (*tmp___82), (char *)"failed communicating with local server");
  goto fatal;
  }
#line 6280
  tmp___83 = __error();
#line 6280
  (*tmp___83) = 0;
#line 6281
  message((unsigned short)1, 0, (char *)"connection closed");
#line 6283
  close(clientFd);
#line 6284
  close(localFd);
#line 6285
  if ((unsigned int )targetHost != (unsigned int )((void *)0)) {
#line 6285
    if ((unsigned int )targetHost != (unsigned int )TargetHost) {
#line 6285
      free((void *)targetHost);
    }
  }
#line 6286
  freeMsgBuf(msg);
#line 6287
  free((void *)argP);
#line 6288
  incrActiveCount(-1);
#line 6292
  return;
  fatal: 
#line 6295
  if (clientFd != -1) {
#line 6295
    close(clientFd);
  }
#line 6296
  if (localFd != -1) {
#line 6296
    close(localFd);
  }
#line 6297
  if ((unsigned int )targetHost != (unsigned int )((void *)0)) {
#line 6297
    if ((unsigned int )targetHost != (unsigned int )TargetHost) {
#line 6297
      free((void *)targetHost);
    }
  }
#line 6298
  if (exponent) {
#line 6298
    free((void *)exponent);
  }
#line 6299
  if (dhKey) {
#line 6299
    free((void *)dhKey);
  }
#line 6300
  if (sessionKeyStr) {
#line 6300
    if ((unsigned int )sessionKeyStr != (unsigned int )secretKeyStr) {
#line 6300
      free((void *)sessionKeyStr);
    }
  }
#line 6301
  if (secretKeyStr) {
#line 6301
    free((void *)secretKeyStr);
  }
#line 6302
  freeMsgBuf(msg);
#line 6303
  free((void *)argP);
#line 6304
  incrActiveCount(-1);
#line 6308
  inLine = 0;
#line 6309
  return;
}
}
#line 6331 "zebedee.c"
unsigned short scanPortRange(char const   *str , unsigned short *loP , unsigned short *hiP ,
                             unsigned short *typeP ) 
{ struct servent *entry ;
  unsigned short loVal ;
  unsigned short hiVal ;
  char portName[1024] ;
  char *slash ;
  unsigned short type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char const   *tmp___4 ;
  __uint16_t tmp___5 ;

  {
#line 6334
  entry = (struct servent *)((void *)0);
#line 6335
  loVal = (unsigned short)0;
#line 6336
  hiVal = (unsigned short)0;
#line 6338
  slash = (char *)((void *)0);
#line 6339
  type = (unsigned short)3;
#line 6342
  slash = strchr(str, '/');
#line 6342
  if ((unsigned int )slash != (unsigned int )((void *)0)) {
#line 6344
    tmp___0 = strcasecmp((char const   *)slash, "/tcp");
#line 6344
    if (tmp___0) {
#line 6348
      tmp = strcasecmp((char const   *)slash, "/udp");
#line 6348
      if (tmp) {
#line 6354
        message((unsigned short)0, 0, (char *)"invalid port type (%s)", slash);
#line 6355
        return ((unsigned short)0);
      } else {
#line 6350
        type = (unsigned short)2;
      }
    } else {
#line 6346
      type = (unsigned short)1;
    }
  }
#line 6358
  if (typeP) {
#line 6358
    (*typeP) = type;
  }
#line 6360
  tmp___1 = sscanf(str, "%hu-%hu", & loVal, & hiVal);
#line 6360
  switch (tmp___1) {
  case 0: 
#line 6363
  break;
  case 1: 
#line 6366
  hiVal = loVal;
  case 2: 
#line 6371
  if ((int )hiVal < (int )loVal) {
#line 6373
    hiVal = (unsigned short )((int )hiVal ^ (int )loVal);
#line 6374
    hiVal = (unsigned short )((int )hiVal ^ (int )loVal);
#line 6375
    hiVal = (unsigned short )((int )hiVal ^ (int )loVal);
  }
#line 6378
  if ((int )hiVal != (int )loVal) {
#line 6378
    if (! hiP) {
#line 6380
      message((unsigned short)0, 0, (char *)"port range found where single value expected");
#line 6381
      return ((unsigned short)0);
    }
  }
#line 6384
  if (loP) {
#line 6384
    (*loP) = loVal;
  }
#line 6385
  if (hiP) {
#line 6385
    (*hiP) = hiVal;
  }
#line 6387
  return (loVal);
  }
#line 6390
  tmp___2 = sscanf(str, "%[^/]", portName);
#line 6390
  if (tmp___2 != 1) {
#line 6392
    message((unsigned short)0, 0, (char *)"missing port name");
#line 6393
    return ((unsigned short)0);
  }
#line 6396
  if ((int )type == 2) {
#line 6396
    tmp___4 = "udp";
  } else {
#line 6396
    tmp___4 = "tcp";
  }
#line 6396
  entry = getservbyname((char const   *)(portName), tmp___4);
#line 6396
  if ((unsigned int )entry == (unsigned int )((void *)0)) {
#line 6398
    tmp___3 = __error();
#line 6398
    message((unsigned short)0, (*tmp___3), (char *)"can\'t find port name entry for \'%s\'",
            portName);
#line 6399
    return ((unsigned short)0);
  }
#line 6402
  tmp___5 = _OSSwapInt16((unsigned short )entry->s_port);
#line 6402
  loVal = (unsigned short )((int )tmp___5);
#line 6403
  if (loP) {
#line 6403
    (*loP) = loVal;
  }
#line 6404
  if (hiP) {
#line 6404
    (*hiP) = loVal;
  }
#line 6406
  return (loVal);
}
}
#line 6416 "zebedee.c"
void setBoolean(char *value , int *resultP ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 6419
  tmp___0 = strcasecmp((char const   *)value, "true");
#line 6419
  if (tmp___0 == 0) {
#line 6421
    (*resultP) = 1;
  } else {
#line 6423
    tmp = strcasecmp((char const   *)value, "false");
#line 6423
    if (tmp == 0) {
#line 6425
      (*resultP) = 0;
    } else {
#line 6429
      message((unsigned short)0, 0, (char *)"can\'t parse boolean value \'%s\'", value);
    }
  }
#line 6431
  return;
}
}
#line 6439 "zebedee.c"
void setUShort(char *value , unsigned short *resultP ) 
{ int tmp ;

  {
#line 6442
  tmp = sscanf((char const   *)value, "%hu", resultP);
#line 6442
  if (tmp != 1) {
#line 6444
    message((unsigned short)0, 0, (char *)"can\'t parse unsigned short value \'%s\'",
            value);
  }
#line 6446
  return;
}
}
#line 6454 "zebedee.c"
void setPort(char *value , unsigned short *resultP ) 
{ unsigned short port ;

  {
#line 6460
  port = scanPortRange((char const   *)value, (unsigned short *)((void *)0), (unsigned short *)((void *)0),
                       (unsigned short *)((void *)0));
#line 6461
  if ((int )port == 0) {
#line 6463
    message((unsigned short)0, 0, (char *)"can\'t parse port value \'%s\' key", value);
  } else {
#line 6467
    (*resultP) = port;
  }
#line 6469
  return;
}
}
#line 6478 "zebedee.c"
PortList_t *newPortList(unsigned short lo , unsigned short hi , char *host , unsigned short type ) 
{ PortList_t *new ;
  struct sockaddr_in addr ;
  struct in_addr *addrList ;
  unsigned long mask ;
  int tmp ;

  {
#line 6481
  new = (PortList_t *)((void *)0);
#line 6483
  addrList = (struct in_addr *)((void *)0);
#line 6484
  mask = 4294967295UL;
#line 6487
  if (host) {
#line 6487
    tmp = getHostAddress((char const   *)host, & addr, & addrList, & mask);
#line 6487
    if (! tmp) {
#line 6489
      message((unsigned short)0, 0, (char *)"can\'t resolve host or address \'%s\'",
              host);
#line 6490
      return ((PortList_t *)((void *)0));
    }
  }
#line 6493
  if (addrList) {
#line 6495
    new = allocPortList(lo, hi, host, & addr.sin_addr, addrList, mask, type);
  } else {
#line 6499
    new = allocPortList(lo, hi, (char *)((void *)0), (struct in_addr *)((void *)0),
                        (struct in_addr *)((void *)0), 4294967295UL, type);
  }
#line 6502
  return (new);
}
}
#line 6513 "zebedee.c"
PortList_t *allocPortList(unsigned short lo , unsigned short hi , char *host , struct in_addr *addrP ,
                          struct in_addr *addrList , unsigned long mask , unsigned short type ) 
{ PortList_t *new ;
  int *tmp___0 ;
  size_t tmp___1 ;

  {
#line 6521
  new = (PortList_t *)((void *)0);
#line 6524
  new = (PortList_t *)malloc((unsigned long )sizeof(PortList_t ));
#line 6524
  if ((unsigned int )new == (unsigned int )((void *)0)) {
#line 6526
    return ((PortList_t *)((void *)0));
  }
#line 6529
  new->lo = lo;
#line 6530
  new->hi = hi;
#line 6531
  memset((void *)(& new->addr), 0, (unsigned long )sizeof(struct in_addr ));
#line 6532
  new->host = (char *)((void *)0);
#line 6533
  if (host) {
#line 6533
    if (addrP) {
#line 6535
      memcpy((void *)(& new->addr.sin_addr), (void const   *)addrP, (unsigned long )sizeof(struct in_addr ));
#line 6536
      tmp___1 = strlen((char const   *)host);
#line 6536
      new->host = (char *)malloc(tmp___1 + 1UL);
#line 6536
      if ((unsigned int )new->host == (unsigned int )((void *)0)) {
#line 6538
        tmp___0 = __error();
#line 6538
        message((unsigned short)0, (*tmp___0), (char *)"out of memory");
#line 6539
        return ((PortList_t *)((void *)0));
      }
#line 6541
      strcpy(new->host, (char const   *)host);
    }
  }
#line 6543
  new->addrList = addrList;
#line 6544
  new->mask = mask;
#line 6545
  new->type = type;
#line 6547
  new->next = (struct PortList_s *)((void *)0);
#line 6549
  return (new);
}
}
#line 6564 "zebedee.c"
void setPortList(char *value , PortList_t **listP , char *host , int zeroOk ) 
{ PortList_t *new ;
  char *token ;
  char tmpBuf[1024] ;
  char *tmpPtr ;
  unsigned short lo ;
  unsigned short hi ;
  PortList_t *last ;
  unsigned short type ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  unsigned short tmp___4 ;

  {
#line 6567
  new = (PortList_t *)((void *)0);
#line 6568
  token = (char *)((void *)0);
#line 6570
  tmpPtr = (char *)((void *)0);
#line 6571
  lo = (unsigned short)0;
#line 6572
  hi = (unsigned short)0;
#line 6573
  last = (*listP);
#line 6574
  type = (unsigned short)3;
#line 6579
  while (1) {
#line 6579
    if (last) {
#line 6579
      if (! last->next) {
#line 6579
        break;
      }
    } else {
#line 6579
      break;
    }
#line 6581
    last = last->next;
  }
#line 6584
  token = value;
#line 6585
  while ((*token)) {
#line 6589
    while (1) {
#line 6589
      if ((*token)) {
#line 6589
        tmp = isspace((int )(*token));
#line 6589
        if (! tmp) {
#line 6589
          if (! ((int )(*token) == 44)) {
#line 6589
            break;
          }
        }
      } else {
#line 6589
        break;
      }
#line 6589
      token ++;
    }
#line 6590
    if (! (*token)) {
#line 6590
      break;
    }
#line 6594
    tmpPtr = tmpBuf;
#line 6595
    while (1) {
#line 6595
      if ((*token)) {
#line 6595
        tmp___2 = isspace((int )(*token));
#line 6595
        if (tmp___2) {
#line 6595
          break;
        } else {
#line 6595
          if ((int )(*token) == 44) {
#line 6595
            break;
          }
        }
      } else {
#line 6595
        break;
      }
#line 6597
      tmp___0 = tmpPtr;
#line 6597
      tmpPtr ++;
#line 6597
      tmp___1 = token;
#line 6597
      token ++;
#line 6597
      (*tmp___0) = (*tmp___1);
    }
#line 6599
    (*tmpPtr) = (char )'\000';
#line 6601
    tmp___4 = scanPortRange((char const   *)(tmpBuf), & lo, & hi, & type);
#line 6601
    if ((int )tmp___4 != 0) {
      goto _L;
    } else {
#line 6601
      if (zeroOk) {
        _L: /* CIL Label */ 
#line 6605
        new = newPortList(lo, hi, host, type);
#line 6605
        if ((unsigned int )new == (unsigned int )((void *)0)) {
#line 6607
          tmp___3 = __error();
#line 6607
          message((unsigned short)0, (*tmp___3), (char *)"failed allocating memory for port list");
#line 6608
          exit(1);
        }
#line 6613
        if ((unsigned int )(*listP) == (unsigned int )((void *)0)) {
#line 6615
          (*listP) = new;
        } else {
#line 6619
          last->next = new;
        }
#line 6621
        last = new;
      } else {
#line 6625
        message((unsigned short)0, 0, (char *)"invalid port range \'%s\'", tmpBuf);
      }
    }
  }
#line 6628
  return;
}
}
#line 6639 "zebedee.c"
void setTarget(char *value ) 
{ char target[1024] ;
  char portList[1024] ;
  int tmp ;

  {
#line 6646
  tmp = sscanf((char const   *)value, "%[^:]:%s", target, portList);
#line 6646
  if (tmp == 2) {
#line 6648
    setPortList(portList, & AllowedTargets, target, 0);
  } else {
#line 6652
    setPortList((char *)"0", & AllowedTargets, target, 1);
  }
#line 6657
  setString(target, & TargetHost);
#line 6658
  return;
}
}
#line 6668 "zebedee.c"
void setTunnel(char *value ) 
{ char clientList[1024] ;
  char hostName[1024] ;
  char targetList[1024] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 6676
  tmp___3 = sscanf((char const   *)value, "%[^:]:%[^:]:%[^:]", clientList, hostName,
                   targetList);
#line 6676
  if (tmp___3 == 3) {
#line 6678
    setPortList(clientList, & ClientPorts, (char *)((void *)0), 0);
#line 6679
    if ((unsigned int )ServerHost == (unsigned int )((void *)0)) {
#line 6681
      setString(hostName, & ServerHost);
    }
#line 6683
    tmp = strcmp((char const   *)(hostName), "*");
#line 6683
    if (tmp == 0) {
#line 6685
      setPortList(targetList, & TargetPorts, (char *)((void *)0), 0);
    } else {
#line 6689
      setPortList(targetList, & TargetPorts, hostName, 0);
    }
  } else {
#line 6692
    tmp___2 = sscanf((char const   *)value, "%[^:]:%[^:]", hostName, targetList);
#line 6692
    if (tmp___2 == 2) {
#line 6694
      if ((unsigned int )ServerHost == (unsigned int )((void *)0)) {
#line 6696
        setString(hostName, & ServerHost);
      }
#line 6698
      tmp___0 = strcmp((char const   *)(hostName), "*");
#line 6698
      if (tmp___0 == 0) {
#line 6700
        setPortList(targetList, & TargetPorts, (char *)((void *)0), 0);
      } else {
#line 6704
        setPortList(targetList, & TargetPorts, hostName, 0);
      }
#line 6706
      tmp___1 = countPorts(TargetPorts);
#line 6706
      if (tmp___1 != 1) {
#line 6708
        message((unsigned short)0, 0, (char *)"target port list contains more than one port");
#line 6709
        exit(1);
      }
    } else {
#line 6714
      if ((unsigned int )ServerHost == (unsigned int )((void *)0)) {
#line 6716
        setString(value, & ServerHost);
      } else {
#line 6720
        message((unsigned short)0, 0, (char *)"invalid tunnel specification \'%s\'",
                value);
      }
    }
  }
#line 6723
  return;
}
}
#line 6732 "zebedee.c"
void setAllowedPeer(char *value ) 
{ char addr[1024] ;
  char portList[1024] ;
  int tmp ;

  {
#line 6739
  tmp = sscanf((char const   *)value, "%[^:]:%s", addr, portList);
#line 6739
  if (tmp == 2) {
#line 6741
    setPortList(portList, & AllowedPeers, addr, 0);
  } else {
#line 6745
    setPortList((char *)"0", & AllowedPeers, addr, 1);
  }
#line 6747
  return;
}
}
#line 6755 "zebedee.c"
void setString(char *value , char **resultP ) 
{ int *tmp ;
  size_t tmp___0 ;

  {
#line 6758
  tmp___0 = strlen((char const   *)value);
#line 6758
  (*resultP) = (char *)malloc(tmp___0 + 1UL);
#line 6758
  if ((unsigned int )(*resultP) == (unsigned int )((void *)0)) {
#line 6760
    tmp = __error();
#line 6760
    message((unsigned short)0, (*tmp), (char *)"failed allocating space for string value \'%s\'",
            value);
#line 6761
    exit(1);
  }
#line 6764
  strcpy((*resultP), (char const   *)value);
#line 6765
  return;
}
}
#line 6776 "zebedee.c"
void setLogFile(char *newFile ) 
{ int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 6779
  if ((unsigned int )LogFileP != (unsigned int )((void *)0)) {
#line 6781
    fclose(LogFileP);
  }
#line 6784
  tmp___1 = strcmp((char const   *)newFile, "NULL");
#line 6784
  if (tmp___1 == 0) {
#line 6786
    LogFileType = 0;
#line 6787
    LogFileP = (FILE *)((void *)0);
  } else {
#line 6789
    tmp___0 = strcmp((char const   *)newFile, "SYSLOG");
#line 6789
    if (tmp___0 == 0) {
#line 6791
      LogFileType = 1;
#line 6792
      LogFileP = (FILE *)((void *)0);
    } else {
#line 6796
      LogFileType = 2;
#line 6797
      LogFileP = fopen((char const   *)newFile, "a");
#line 6797
      if ((unsigned int )LogFileP == (unsigned int )((void *)0)) {
#line 6799
        tmp = __error();
#line 6799
        message((unsigned short)0, (*tmp), (char *)"can\'t open log file \'%s\'",
                newFile);
      }
    }
  }
#line 6802
  return;
}
}
#line 6810 "zebedee.c"
void setCmpInfo(char *value , unsigned short *resultP ) 
{ unsigned short level ;
  unsigned short type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 6813
  level = (unsigned short)0;
#line 6814
  type = (unsigned short)0;
#line 6816
  tmp___1 = sscanf((char const   *)value, "zlib:%hu", & level);
#line 6816
  if (tmp___1 == 1) {
#line 6818
    type = (unsigned short)0;
  } else {
#line 6820
    tmp___0 = sscanf((char const   *)value, "bzip2:%hu", & level);
#line 6820
    if (tmp___0 == 1) {
#line 6826
      type = (unsigned short)1;
#line 6830
      if ((int )level > 1) {
#line 6830
        level = (unsigned short)1;
      }
    } else {
#line 6833
      tmp = sscanf((char const   *)value, "%hu", & level);
#line 6833
      if (tmp == 1) {
#line 6835
        type = (unsigned short)0;
      } else {
#line 6839
        message((unsigned short)0, 0, (char *)"invalid compression specification \'%s\'",
                value);
#line 6840
        level = (unsigned short)6;
      }
    }
  }
#line 6843
  if ((int )level > 9) {
#line 6845
    message((unsigned short)0, 0, (char *)"compression level out of range (%s)", value);
#line 6846
    level = (unsigned short)6;
  }
#line 6849
  if ((int )level == 0) {
#line 6851
    type = (unsigned short)0;
  }
#line 6854
  (*resultP) = level;
#line 6855
  (*resultP) = (unsigned short )((int )(*resultP) | ((int )type << 8));
#line 6856
  return;
}
}
#line 6865 "zebedee.c"
void readConfigFile(char const   *fileName , int level ) 
{ FILE *fp ;
  char lineBuf[1024] ;
  char *curPtr ;
  int size ;
  int len ;
  int lineNo ;
  int *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 6868
  fp = (FILE *)((void *)0);
#line 6870
  curPtr = (char *)((void *)0);
#line 6871
  size = 0;
#line 6872
  len = 0;
#line 6873
  lineNo = 0;
#line 6876
  message((unsigned short)2, 0, (char *)"reading config file \'%s\' at level %d",
          fileName, level);
#line 6878
  if (level > 5) {
#line 6880
    message((unsigned short)0, 0, (char *)"include file nesting too deep (> %d)",
            5);
#line 6881
    return;
  }
#line 6884
  fp = fopen(fileName, "r");
#line 6884
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 6886
    tmp = __error();
#line 6886
    message((unsigned short)0, (*tmp), (char *)"can\'t open config file \'%s\'", fileName);
#line 6887
    return;
  }
#line 6890
  curPtr = lineBuf;
#line 6891
  size = 1024;
#line 6893
  while (1) {
#line 6893
    tmp___4 = fgets(curPtr, size, fp);
#line 6893
    if (! ((unsigned int )tmp___4 != (unsigned int )((void *)0))) {
#line 6893
      break;
    }
#line 6895
    lineNo ++;
#line 6897
    tmp___0 = strlen((char const   *)curPtr);
#line 6897
    len = (int )(tmp___0 - 1UL);
#line 6901
    if ((int )(*(curPtr + len)) == 10) {
#line 6903
      tmp___1 = len;
#line 6903
      len --;
#line 6903
      (*(curPtr + tmp___1)) = (char )'\000';
    } else {
#line 6905
      tmp___2 = feof(fp);
#line 6905
      if (! tmp___2) {
#line 6907
        message((unsigned short)0, 0, (char *)"line too long in config file \'%s\' at line %d",
                fileName, lineNo);
#line 6908
        break;
      }
    }
#line 6911
    message((unsigned short)4, 0, (char *)"line %d: %s", lineNo, curPtr);
#line 6915
    if ((int )(*(curPtr + len)) == 92) {
#line 6917
      (*(curPtr + len)) = (char )'\000';
#line 6918
      size -= len;
#line 6919
      curPtr += len;
#line 6923
      continue;
    }
#line 6928
    curPtr = lineBuf;
#line 6929
    size = 1024;
#line 6931
    tmp___3 = parseConfigLine((char const   *)(lineBuf), level);
#line 6931
    if (! tmp___3) {
#line 6933
      message((unsigned short)0, 0, (char *)"invalid line in config file \'%s\' at line %d",
              fileName, lineNo);
    }
  }
#line 6937
  fclose(fp);
#line 6938
  return;
}
}
#line 6949 "zebedee.c"
int parseConfigLine(char const   *lineBuf , int level ) 
{ char key[1024] ;
  char value[1024] ;
  char comment[2] ;
  char tmpBuf[1024] ;
  char const   *s ;
  char *t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int yesNo ;
  char const   *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;

  {
#line 6956
  s = (char const   *)((void *)0);
#line 6957
  t = (char *)((void *)0);
#line 6962
  if (FieldSeparator) {
#line 6964
    s = lineBuf;
#line 6964
    t = tmpBuf;
#line 6964
    while ((*s)) {
#line 6966
      if ((int const   )(*s) == (int const   )(*FieldSeparator)) {
#line 6968
        (*t) = (char )' ';
      } else {
#line 6972
        (*t) = (char )(*s);
      }
#line 6964
      s ++;
#line 6964
      t ++;
    }
#line 6975
    (*t) = (char )'\000';
#line 6976
    lineBuf = (char const   *)(tmpBuf);
  }
#line 6981
  comment[0] = (char )'#';
#line 6982
  key[0] = (char )'#';
#line 6983
  tmp = sscanf(lineBuf, "%s \"%[^\"]\" %1s", key, value, comment);
#line 6983
  if (tmp < 2) {
#line 6983
    tmp___0 = sscanf(lineBuf, "%s \'%[^\']\' %1s", key, value, comment);
#line 6983
    if (tmp___0 < 2) {
#line 6983
      tmp___1 = sscanf(lineBuf, "%s %s %1s", key, value, comment);
#line 6983
      if (tmp___1 < 2) {
#line 6993
        if ((int )key[0] != 35) {
#line 6995
          return (0);
        }
#line 6997
        return (1);
      }
    }
  }
#line 7002
  if ((int )key[0] == 35) {
#line 7004
    return (1);
  }
#line 7009
  if ((int )comment[0] != 35) {
#line 7011
    return (0);
  }
#line 7014
  message((unsigned short)4, 0, (char *)"key = \'%s\', value = \'%s\'", key, value);
#line 7018
  tmp___59 = strcasecmp((char const   *)(key), "server");
#line 7018
  if (tmp___59) {
#line 7019
    tmp___58 = strcasecmp((char const   *)(key), "detached");
#line 7019
    if (tmp___58) {
#line 7020
      tmp___57 = strcasecmp((char const   *)(key), "debug");
#line 7020
      if (tmp___57) {
#line 7021
        tmp___56 = strcasecmp((char const   *)(key), "compression");
#line 7021
        if (tmp___56) {
#line 7022
          tmp___55 = strcasecmp((char const   *)(key), "keylength");
#line 7022
          if (tmp___55) {
#line 7023
            tmp___54 = strcasecmp((char const   *)(key), "minkeylength");
#line 7023
            if (tmp___54) {
#line 7024
              tmp___53 = strcasecmp((char const   *)(key), "maxbufsize");
#line 7024
              if (tmp___53) {
#line 7025
                tmp___52 = strcasecmp((char const   *)(key), "verbosity");
#line 7025
                if (tmp___52) {
#line 7026
                  tmp___51 = strcasecmp((char const   *)(key), "serverport");
#line 7026
                  if (tmp___51) {
#line 7027
                    tmp___50 = strcasecmp((char const   *)(key), "localport");
#line 7027
                    if (tmp___50) {
#line 7028
                      tmp___49 = strcasecmp((char const   *)(key), "clientport");
#line 7028
                      if (tmp___49) {
#line 7029
                        tmp___48 = strcasecmp((char const   *)(key), "remoteport");
#line 7029
                        if (tmp___48) {
#line 7030
                          tmp___47 = strcasecmp((char const   *)(key), "targetport");
#line 7030
                          if (tmp___47) {
#line 7031
                            tmp___46 = strcasecmp((char const   *)(key), "remotehost");
#line 7031
                            if (tmp___46) {
#line 7032
                              tmp___45 = strcasecmp((char const   *)(key), "serverhost");
#line 7032
                              if (tmp___45) {
#line 7033
                                tmp___44 = strcasecmp((char const   *)(key), "command");
#line 7033
                                if (tmp___44) {
#line 7038
                                  tmp___43 = strcasecmp((char const   *)(key), "keygencommand");
#line 7038
                                  if (tmp___43) {
#line 7039
                                    tmp___42 = strcasecmp((char const   *)(key), "logfile");
#line 7039
                                    if (tmp___42) {
#line 7040
                                      tmp___41 = strcasecmp((char const   *)(key),
                                                            "timestamplog");
#line 7040
                                      if (tmp___41) {
#line 7041
                                        tmp___40 = strcasecmp((char const   *)(key),
                                                              "multiuse");
#line 7041
                                        if (tmp___40) {
#line 7042
                                          tmp___39 = strcasecmp((char const   *)(key),
                                                                "include");
#line 7042
                                          if (tmp___39) {
#line 7043
                                            tmp___38 = strcasecmp((char const   *)(key),
                                                                  "modulus");
#line 7043
                                            if (tmp___38) {
#line 7044
                                              tmp___37 = strcasecmp((char const   *)(key),
                                                                    "generator");
#line 7044
                                              if (tmp___37) {
#line 7045
                                                tmp___36 = strcasecmp((char const   *)(key),
                                                                      "privatekey");
#line 7045
                                                if (tmp___36) {
#line 7046
                                                  tmp___35 = strcasecmp((char const   *)(key),
                                                                        "checkidfile");
#line 7046
                                                  if (tmp___35) {
#line 7047
                                                    tmp___34 = strcasecmp((char const   *)(key),
                                                                          "checkaddress");
#line 7047
                                                    if (tmp___34) {
#line 7048
                                                      tmp___33 = strcasecmp((char const   *)(key),
                                                                            "redirect");
#line 7048
                                                      if (tmp___33) {
#line 7066
                                                        tmp___32 = strcasecmp((char const   *)(key),
                                                                              "message");
#line 7066
                                                        if (tmp___32) {
#line 7067
                                                          tmp___31 = strcasecmp((char const   *)(key),
                                                                                "name");
#line 7067
                                                          if (tmp___31) {
#line 7068
                                                            tmp___30 = strcasecmp((char const   *)(key),
                                                                                  "keygenlevel");
#line 7068
                                                            if (tmp___30) {
#line 7069
                                                              tmp___29 = strcasecmp((char const   *)(key),
                                                                                    "redirecthost");
#line 7069
                                                              if (tmp___29) {
#line 7070
                                                                tmp___28 = strcasecmp((char const   *)(key),
                                                                                      "targethost");
#line 7070
                                                                if (tmp___28) {
#line 7071
                                                                  tmp___27 = strcasecmp((char const   *)(key),
                                                                                        "keylifetime");
#line 7071
                                                                  if (tmp___27) {
#line 7072
                                                                    tmp___26 = strcasecmp((char const   *)(key),
                                                                                          "udpmode");
#line 7072
                                                                    if (tmp___26) {
#line 7077
                                                                      tmp___25 = strcasecmp((char const   *)(key),
                                                                                            "ipmode");
#line 7077
                                                                      if (tmp___25) {
#line 7100
                                                                        tmp___24 = strcasecmp((char const   *)(key),
                                                                                              "udptimeout");
#line 7100
                                                                        if (tmp___24) {
#line 7101
                                                                          tmp___23 = strcasecmp((char const   *)(key),
                                                                                                "tcptimeout");
#line 7101
                                                                          if (tmp___23) {
#line 7102
                                                                            tmp___22 = strcasecmp((char const   *)(key),
                                                                                                  "idletimeout");
#line 7102
                                                                            if (tmp___22) {
#line 7107
                                                                              tmp___21 = strcasecmp((char const   *)(key),
                                                                                                    "localsource");
#line 7107
                                                                              if (tmp___21) {
#line 7113
                                                                                tmp___20 = strcasecmp((char const   *)(key),
                                                                                                      "listenip");
#line 7113
                                                                                if (tmp___20) {
#line 7114
                                                                                  tmp___19 = strcasecmp((char const   *)(key),
                                                                                                        "listenmode");
#line 7114
                                                                                  if (tmp___19) {
#line 7115
                                                                                    tmp___18 = strcasecmp((char const   *)(key),
                                                                                                          "clienthost");
#line 7115
                                                                                    if (tmp___18) {
#line 7116
                                                                                      tmp___17 = strcasecmp((char const   *)(key),
                                                                                                            "connecttimeout");
#line 7116
                                                                                      if (tmp___17) {
#line 7117
                                                                                        tmp___16 = strcasecmp((char const   *)(key),
                                                                                                              "readtimeout");
#line 7117
                                                                                        if (tmp___16) {
#line 7118
                                                                                          tmp___15 = strcasecmp((char const   *)(key),
                                                                                                                "target");
#line 7118
                                                                                          if (tmp___15) {
#line 7119
                                                                                            tmp___14 = strcasecmp((char const   *)(key),
                                                                                                                  "tunnel");
#line 7119
                                                                                            if (tmp___14) {
#line 7120
                                                                                              tmp___13 = strcasecmp((char const   *)(key),
                                                                                                                    "transparent");
#line 7120
                                                                                              if (tmp___13) {
#line 7121
                                                                                                tmp___12 = strcasecmp((char const   *)(key),
                                                                                                                      "httpproxy");
#line 7121
                                                                                                if (tmp___12) {
#line 7130
                                                                                                  tmp___11 = strcasecmp((char const   *)(key),
                                                                                                                        "sharedkey");
#line 7130
                                                                                                  if (tmp___11) {
#line 7131
                                                                                                    tmp___10 = strcasecmp((char const   *)(key),
                                                                                                                          "sharedkeygencommand");
#line 7131
                                                                                                    if (tmp___10) {
#line 7132
                                                                                                      tmp___9 = strcasecmp((char const   *)(key),
                                                                                                                           "dumpdata");
#line 7132
                                                                                                      if (tmp___9) {
#line 7135
                                                                                                        return (0);
                                                                                                      } else {
#line 7132
                                                                                                        setBoolean(value,
                                                                                                                   & DumpData);
                                                                                                      }
                                                                                                    } else {
#line 7131
                                                                                                      setString(value,
                                                                                                                & SharedKeyGenCmd);
                                                                                                    }
                                                                                                  } else {
#line 7130
                                                                                                    setString(value,
                                                                                                              & SharedKey);
                                                                                                  }
                                                                                                } else {
#line 7123
                                                                                                  setString(value,
                                                                                                            & ProxyHost);
#line 7124
                                                                                                  tmp___8 = sscanf((char const   *)(value),
                                                                                                                   "%[^:]:%hu",
                                                                                                                   ProxyHost,
                                                                                                                   & ProxyPort);
#line 7124
                                                                                                  if (tmp___8 != 2) {
#line 7126
                                                                                                    message((unsigned short)0,
                                                                                                            0,
                                                                                                            (char *)"invalid httpproxy specification: %s",
                                                                                                            value);
#line 7127
                                                                                                    ProxyHost = (char *)((void *)0);
                                                                                                  }
                                                                                                }
                                                                                              } else {
#line 7120
                                                                                                setBoolean(value,
                                                                                                           & Transparent);
                                                                                              }
                                                                                            } else {
#line 7119
                                                                                              setTunnel(value);
                                                                                            }
                                                                                          } else {
#line 7118
                                                                                            setTarget(value);
                                                                                          }
                                                                                        } else {
#line 7117
                                                                                          setUShort(value,
                                                                                                    & ReadTimeout);
                                                                                        }
                                                                                      } else {
#line 7116
                                                                                        setUShort(value,
                                                                                                  & ConnectTimeout);
                                                                                      }
                                                                                    } else {
#line 7115
                                                                                      setString(value,
                                                                                                & ClientHost);
                                                                                    }
                                                                                  } else {
#line 7114
                                                                                    setBoolean(value,
                                                                                               & ListenMode);
                                                                                  }
                                                                                } else {
#line 7113
                                                                                  setString(value,
                                                                                            & ListenIp);
                                                                                }
                                                                              } else {
#line 7109
                                                                                yesNo = 0;
#line 7110
                                                                                setBoolean(value,
                                                                                           & yesNo);
#line 7111
                                                                                if (yesNo) {
#line 7111
                                                                                  tmp___7 = "127.0.0.1";
                                                                                } else {
#line 7111
                                                                                  tmp___7 = "0.0.0.0";
                                                                                }
#line 7111
                                                                                setString((char *)tmp___7,
                                                                                          & ListenIp);
                                                                              }
                                                                            } else {
#line 7104
                                                                              setUShort(value,
                                                                                        & TcpTimeout);
#line 7105
                                                                              setUShort(value,
                                                                                        & UdpTimeout);
                                                                            }
                                                                          } else {
#line 7101
                                                                            setUShort(value,
                                                                                      & TcpTimeout);
                                                                          }
                                                                        } else {
#line 7100
                                                                          setUShort(value,
                                                                                    & UdpTimeout);
                                                                        }
                                                                      } else {
#line 7079
                                                                        tmp___6 = strcasecmp((char const   *)(value),
                                                                                             "tcp");
#line 7079
                                                                        if (tmp___6) {
#line 7084
                                                                          tmp___5 = strcasecmp((char const   *)(value),
                                                                                               "udp");
#line 7084
                                                                          if (tmp___5) {
#line 7089
                                                                            tmp___3 = strcasecmp((char const   *)(value),
                                                                                                 "both");
#line 7089
                                                                            if (tmp___3) {
#line 7089
                                                                              tmp___4 = strcasecmp((char const   *)(value),
                                                                                                   "mixed");
#line 7089
                                                                              if (tmp___4) {
#line 7096
                                                                                message((unsigned short)0,
                                                                                        0,
                                                                                        (char *)"invalid value for ipmode: %s",
                                                                                        value);
#line 7097
                                                                                return (0);
                                                                              } else {
#line 7091
                                                                                TcpMode = 1;
#line 7092
                                                                                UdpMode = 1;
                                                                              }
                                                                            } else {
#line 7091
                                                                              TcpMode = 1;
#line 7092
                                                                              UdpMode = 1;
                                                                            }
                                                                          } else {
#line 7086
                                                                            TcpMode = 0;
#line 7087
                                                                            UdpMode = 1;
                                                                          }
                                                                        } else {
#line 7081
                                                                          TcpMode = 1;
#line 7082
                                                                          UdpMode = 0;
                                                                        }
                                                                      }
                                                                    } else {
#line 7074
                                                                      setBoolean(value,
                                                                                 & UdpMode);
#line 7075
                                                                      TcpMode = ! UdpMode;
                                                                    }
                                                                  } else {
#line 7071
                                                                    setUShort(value,
                                                                              & KeyLifetime);
                                                                  }
                                                                } else {
#line 7070
                                                                  setTarget(value);
                                                                }
                                                              } else {
#line 7069
                                                                setString(value, & TargetHost);
                                                              }
                                                            } else {
#line 7068
                                                              setUShort(value, & KeyGenLevel);
                                                            }
                                                          } else {
#line 7067
                                                            setString(value, & Program);
                                                          }
                                                        } else {
#line 7066
                                                          message((unsigned short)1,
                                                                  0, (char *)"%s",
                                                                  value);
                                                        }
                                                      } else {
#line 7050
                                                        tmp___2 = strcasecmp((char const   *)(value),
                                                                             "none");
#line 7050
                                                        if (tmp___2) {
#line 7063
                                                          setPortList(value, & AllowedDefault,
                                                                      (char *)((void *)0),
                                                                      0);
                                                        } else {
#line 7058
                                                          AllowedDefault = (PortList_t *)((void *)0);
#line 7059
                                                          setPortList((char *)"0-0",
                                                                      & AllowedDefault,
                                                                      (char *)((void *)0),
                                                                      1);
                                                        }
                                                      }
                                                    } else {
#line 7047
                                                      setAllowedPeer(value);
                                                    }
                                                  } else {
#line 7046
                                                    setString(value, & IdentityFile);
                                                  }
                                                } else {
#line 7045
                                                  setString(value, & PrivateKey);
                                                }
                                              } else {
#line 7044
                                                setString(value, & Generator);
                                              }
                                            } else {
#line 7043
                                              setString(value, & Modulus);
                                            }
                                          } else {
#line 7042
                                            readConfigFile((char const   *)(value),
                                                           level + 1);
                                          }
                                        } else {
#line 7041
                                          setBoolean(value, & MultiUse);
                                        }
                                      } else {
#line 7040
                                        setBoolean(value, & TimestampLog);
                                      }
                                    } else {
#line 7039
                                      setLogFile(value);
                                    }
                                  } else {
#line 7038
                                    setString(value, & KeyGenCmd);
                                  }
                                } else {
#line 7035
                                  setString(value, & CommandString);
#line 7036
                                  MultiUse = 0;
                                }
                              } else {
#line 7032
                                setString(value, & ServerHost);
                              }
                            } else {
#line 7031
                              setString(value, & ServerHost);
                            }
                          } else {
#line 7030
                            setPortList(value, & TargetPorts, (char *)((void *)0),
                                        0);
                          }
                        } else {
#line 7029
                          setPortList(value, & TargetPorts, (char *)((void *)0), 0);
                        }
                      } else {
#line 7028
                        setPortList(value, & ClientPorts, (char *)((void *)0), 0);
                      }
                    } else {
#line 7027
                      setPortList(value, & ClientPorts, (char *)((void *)0), 0);
                    }
                  } else {
#line 7026
                    setPort(value, & ServerPort);
                  }
                } else {
#line 7025
                  setUShort(value, & LogLevel);
                }
              } else {
#line 7024
                setUShort(value, & MaxBufSize);
              }
            } else {
#line 7023
              setUShort(value, & MinKeyLength);
            }
          } else {
#line 7022
            setUShort(value, & KeyLength);
          }
        } else {
#line 7021
          setCmpInfo(value, & CompressInfo);
        }
      } else {
#line 7020
        setBoolean(value, & Debug);
      }
    } else {
#line 7019
      setBoolean(value, & IsDetached);
    }
  } else {
#line 7018
    setBoolean(value, & IsServer);
  }
#line 7138
  return (1);
}
}
#line 7148 "zebedee.c"
char *cleanHexString(char *str ) 
{ char *newStr ;
  size_t tmp ;
  char *tmp___0 ;
  char *newp ;
  char *oldp ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 7151
  tmp = strlen((char const   *)str);
#line 7151
  tmp___0 = (char *)malloc(tmp + 1UL);
#line 7151
  newStr = tmp___0;
#line 7152
  newp = newStr;
#line 7153
  oldp = str;
#line 7155
  while ((*oldp)) {
#line 7157
    tmp___4 = isxdigit((int )(*oldp));
#line 7157
    if (tmp___4) {
#line 7159
      tmp___1 = newp;
#line 7159
      newp ++;
#line 7159
      tmp___2 = oldp;
#line 7159
      oldp ++;
#line 7159
      (*tmp___1) = (char )tolower((int )(*tmp___2));
    } else {
#line 7161
      tmp___3 = isspace((int )(*oldp));
#line 7161
      if (tmp___3) {
#line 7163
        oldp ++;
      } else {
#line 7167
        message((unsigned short)0, 0, (char *)"invalid character in hex string \'%s\'",
                str);
#line 7168
        break;
      }
    }
  }
#line 7171
  (*newp) = (char )'\000';
#line 7173
  return (newStr);
}
}
#line 7182 "zebedee.c"
void usage(void) 
{ 

  {
#line 7185
  fprintf(__stderrp, "Zebedee -- A Secure Tunnel Program: Release %s\n", "2.4.1A");
#line 7186
  fprintf(__stderrp, "Copyright (c) 1999, 2000, 2001, 2002 by Neil Winton. All Rights Reserved.\n");
#line 7187
  fprintf(__stderrp, "This program is free software and may be distributed under the terms of the\nGNU General Public License, Version 2.\n");
#line 7190
  fprintf(__stderrp, "Zebedee comes with ABSOLUTELY NO WARRANTY.\n\n");
#line 7191
  fprintf(__stderrp, "Client: %s [options] [[clientports:]serverhost[:targetports]]\nServer: %s [options] -s [targethost]\nKey generation:  %s -p | -P [-f file]\nHashing: %s -H string ... | -h [file ...]\n",
          Program, Program, Program, Program);
#line 7202
  fprintf(__stderrp, "Options are:\n    -b address  Bind only this address when listening for connections\n    -c host     Server initiates connection to client host\n    -D          Debug mode\n    -d          Do not detach from terminal\n    -e command  Run command connected to local port (client only)\n    -F char     Specify additional field separator character\n    -f file     Read configuration file\n    -H          Generate hash of string values\n    -h          Generate hash of file contents\n    -k keybits  Specify key length in bits\n    -l          Client listens for server connection\n    -m          Client accepts multiple connections (default)\n    -n name     Specify program name\n    -o file     Log output to specified file\n    -p          Generate private key\n    -P          Generate public key \"fingerprint\"\n    -r ports    Specify allowed port redirection list (server only)\n    -s          Run as a server\n    -t          Timestamp log entries\n    -T port     Specify the server (tunnel) port\n    -u          Run in UDP mode\n    -U          Run in TCP and UDP mode\n    -v level    Set message verbosity level (default 1)\n    -x config   Extended configuration statement\n    -z type     Set the compression type and level (default zlib:6)\n");
#line 7233
  exit(1);
}
}
#line 7243 "zebedee.c"
void sigpipeCatcher(int sig ) 
{ 

  {
#line 7247
  signal(13, & sigpipeCatcher);
#line 7249
  return;
}
}
#line 7257 "zebedee.c"
void sigchldCatcher(int sig ) 
{ pid_t tmp ;

  {
#line 7261
  while (1) {
#line 7261
    tmp = waitpid(-1, (int *)((void *)0), 1);
#line 7261
    if (! (tmp > 0)) {
#line 7261
      break;
    }
  }
#line 7263
  signal(20, & sigchldCatcher);
#line 7265
  return;
}
}
#line 7273 "zebedee.c"
void sigusr1Catcher(int sig ) 
{ 

  {
#line 7277
  _exit(0);
}
}
#line 7287 "zebedee.c"
int main(int argc , char **argv ) 
{ int ch ;
  char hostName[1024] ;
  int doHash ;
  int doPrivKey ;
  int doPubKey ;
  char hashBuf[41] ;
  char *last ;
  char *serviceArgs ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 7292
  doHash = 0;
#line 7293
  doPrivKey = 0;
#line 7294
  doPubKey = 0;
#line 7297
  serviceArgs = (char *)((void *)0);
#line 7302
  last = strrchr((char const   *)(*(argv + 0)), '/');
#line 7302
  if ((unsigned int )last != (unsigned int )((void *)0)) {
#line 7304
    Program = last + 1;
  } else {
#line 7308
    Program = (*(argv + 0));
  }
#line 7310
  last = strrchr((char const   *)Program, '.');
#line 7310
  if ((unsigned int )last != (unsigned int )((void *)0)) {
#line 7312
    (*last) = (char )'\000';
  }
#line 7317
  threadInit();
#line 7327
  while (1) {
#line 7327
    ch = getopt(argc, (char * const  *)argv, "b:c:Dde:f:F:hHk:lmn:o:pPr:sS:tT:uUv:x:z:");
#line 7327
    if (! (ch != -1)) {
#line 7327
      break;
    }
#line 7329
    switch (ch) {
    case 99: 
#line 7332
    ClientHost = optarg;
#line 7333
    break;
    case 98: 
#line 7336
    ListenIp = optarg;
#line 7337
    break;
    case 68: 
#line 7340
    Debug = 1;
#line 7341
    break;
    case 100: 
#line 7344
    IsDetached = 0;
#line 7345
    break;
    case 101: 
#line 7348
    MultiUse = 0;
#line 7349
    CommandString = optarg;
#line 7350
    break;
    case 102: 
#line 7353
    readConfigFile((char const   *)optarg, 1);
#line 7354
    break;
    case 70: 
#line 7357
    FieldSeparator = optarg;
#line 7358
    break;
    case 104: 
#line 7361
    if (doPrivKey) {
#line 7363
      message((unsigned short)0, 0, (char *)"-h and -p or -P are mutually exclusive");
#line 7364
      exit(1);
    } else {
#line 7361
      if (doPubKey) {
#line 7363
        message((unsigned short)0, 0, (char *)"-h and -p or -P are mutually exclusive");
#line 7364
        exit(1);
      }
    }
#line 7366
    doHash = 1;
#line 7367
    break;
    case 72: 
#line 7370
    if (doPrivKey) {
#line 7372
      message((unsigned short)0, 0, (char *)"-H and -p or -P are mutually exclusive");
#line 7373
      exit(1);
    } else {
#line 7370
      if (doPubKey) {
#line 7372
        message((unsigned short)0, 0, (char *)"-H and -p or -P are mutually exclusive");
#line 7373
        exit(1);
      }
    }
#line 7375
    doHash = 2;
#line 7376
    break;
    case 107: 
#line 7379
    setUShort(optarg, & KeyLength);
#line 7380
    break;
    case 108: 
#line 7383
    ListenMode ++;
#line 7384
    break;
    case 109: 
#line 7387
    MultiUse ++;
#line 7388
    break;
    case 110: 
#line 7391
    Program = optarg;
#line 7392
    break;
    case 111: 
#line 7395
    setLogFile(optarg);
#line 7396
    break;
    case 112: 
#line 7399
    if (doHash) {
#line 7401
      message((unsigned short)0, 0, (char *)"-h or -H and -p or -P are mutually exclusive");
#line 7402
      exit(1);
    }
#line 7404
    doPrivKey ++;
#line 7405
    break;
    case 80: 
#line 7408
    if (doHash) {
#line 7410
      message((unsigned short)0, 0, (char *)"-h or -H and -p or -P are mutually exclusive");
#line 7411
      exit(1);
    }
#line 7413
    doPubKey ++;
#line 7414
    break;
    case 114: 
#line 7417
    setPortList(optarg, & AllowedDefault, (char *)((void *)0), 0);
#line 7418
    break;
    case 115: 
#line 7421
    IsServer = 1;
#line 7422
    break;
    case 83: 
#line 7425
    serviceArgs = optarg;
#line 7426
    break;
    case 116: 
#line 7429
    TimestampLog = 1;
#line 7430
    break;
    case 84: 
#line 7433
    setUShort(optarg, & ServerPort);
#line 7434
    break;
    case 117: 
#line 7437
    UdpMode = 1;
#line 7438
    TcpMode = 0;
#line 7439
    break;
    case 85: 
#line 7442
    UdpMode = 1;
#line 7443
    TcpMode = 1;
#line 7444
    break;
    case 118: 
#line 7447
    LogLevel = (unsigned short )strtoul((char const   *)optarg, (char **)((void *)0),
                                        10);
#line 7448
    break;
    case 120: 
#line 7451
    tmp = parseConfigLine((char const   *)optarg, 0);
#line 7451
    if (! tmp) {
#line 7453
      message((unsigned short)0, 0, (char *)"invalid extended configuration argument \'%s\'",
              optarg);
    }
#line 7455
    break;
    case 122: 
#line 7458
    setCmpInfo(optarg, & CompressInfo);
#line 7459
    break;
    default: 
#line 7462
    usage();
#line 7463
    break;
    }
  }
#line 7472
  if (IsDetached) {
#line 7474
    prepareToDetach();
  }
#line 7482
  if ((int )KeyLifetime != 0) {
#line 7484
    CurrentToken = 4294967295UL;
  }
#line 7493
  if (CommandString) {
#line 7493
    if (MultiUse) {
#line 7495
      message((unsigned short)0, 0, (char *)"can\'t specify a command for a multi-use client");
#line 7496
      exit(1);
    }
  }
#line 7503
  if ((int )ServerPort == 0) {
#line 7505
    if (UdpMode) {
#line 7505
      if (! TcpMode) {
#line 7507
        ServerPort = (unsigned short)11230;
      } else {
#line 7511
        ServerPort = (unsigned short)11965;
      }
    } else {
#line 7511
      ServerPort = (unsigned short)11965;
    }
  }
#line 7523
  Modulus = cleanHexString(Modulus);
#line 7524
  Generator = cleanHexString(Generator);
#line 7530
  if ((int )MaxBufSize > 16383) {
#line 7532
    message((unsigned short)1, 0, (char *)"Warning: maximum buffer size must be < %hu, rounded down",
            16383);
#line 7533
    MaxBufSize = (unsigned short)16383;
  } else {
#line 7535
    if ((int )MaxBufSize == 0) {
#line 7537
      message((unsigned short)1, 0, (char *)"Warning: buffer size must be > 0, set to %hu",
              8192);
#line 7538
      MaxBufSize = (unsigned short)8192;
    }
  }
#line 7545
  if ((int )KeyLength < (int )MinKeyLength) {
#line 7547
    message((unsigned short)1, 0, (char *)"Warning: specified keylength (%hu) set to minkeylength (%hu)",
            KeyLength, MinKeyLength);
#line 7548
    KeyLength = MinKeyLength;
  }
#line 7557
  signal(13, & sigpipeCatcher);
#line 7566
  signal(20, & sigchldCatcher);
#line 7606
  if (doHash) {
#line 7610
    if (optind >= argc) {
#line 7614
      if (doHash == 1) {
#line 7616
        hashFile(hashBuf, (char *)"-");
#line 7617
        printf("%s\n", hashBuf);
      } else {
#line 7621
        message((unsigned short)0, 0, (char *)"no string argument to hash");
#line 7622
        exit(1);
      }
    } else {
#line 7629
      while (1) {
#line 7629
        if (optind < argc) {
#line 7629
          if (! (*(argv + optind))) {
#line 7629
            break;
          }
        } else {
#line 7629
          break;
        }
#line 7631
        if (doHash == 1) {
#line 7633
          hashFile(hashBuf, (*(argv + optind)));
        } else {
#line 7637
          hashStrings(hashBuf, (*(argv + optind)), (void *)0);
        }
#line 7639
        printf("%s %s\n", hashBuf, (*(argv + optind)));
#line 7640
        optind ++;
      }
    }
  } else {
#line 7644
    if (doPrivKey) {
      goto _L;
    } else {
#line 7644
      if (doPubKey) {
        _L: /* CIL Label */ 
#line 7648
        if (doPrivKey) {
#line 7650
          PrivateKey = generateKey();
#line 7651
          if ((unsigned int )PrivateKey != (unsigned int )((void *)0)) {
#line 7653
            printf("privatekey \"%s\"\n", PrivateKey);
          } else {
#line 7657
            tmp___0 = __error();
#line 7657
            message((unsigned short)0, (*tmp___0), (char *)"can\'t generate private key");
          }
        }
#line 7660
        if (doPubKey) {
#line 7662
          if ((unsigned int )PrivateKey == (unsigned int )((void *)0)) {
#line 7664
            message((unsigned short)0, 0, (char *)"can\'t generate a identity without a private key being set");
#line 7665
            exit(1);
          }
#line 7667
          gethostname(hostName, 1024UL);
#line 7668
          tmp___1 = generateIdentity(Generator, Modulus, PrivateKey);
#line 7668
          printf("%s %s\n", tmp___1, hostName);
        }
      } else {
#line 7671
        if (IsServer) {
#line 7675
          while (optind < argc) {
#line 7677
            setTarget((*(argv + optind)));
#line 7678
            optind ++;
          }
#line 7686
          tmp___2 = strchr((char const   *)TargetHost, '/');
#line 7686
          if ((unsigned int )tmp___2 != (unsigned int )((void *)0)) {
#line 7688
            message((unsigned short)0, 0, (char *)"default target host (%s) must not have an address mask",
                    TargetHost);
#line 7689
            exit(1);
          }
#line 7697
          if ((unsigned int )AllowedTargets == (unsigned int )((void *)0)) {
#line 7699
            AllowedTargets = newPortList((unsigned short)0, (unsigned short)0, (char *)"localhost",
                                         (unsigned short)3);
          }
#line 7709
          if ((unsigned int )ClientHost != (unsigned int )((void *)0)) {
#line 7711
            serverInitiator(ClientHost, ServerPort, ConnectTimeout);
          } else {
#line 7715
            serverListener(& ServerPort);
          }
        } else {
#line 7725
          while (optind < argc) {
#line 7727
            setTunnel((*(argv + optind)));
#line 7728
            optind ++;
          }
#line 7731
          if ((unsigned int )ServerHost == (unsigned int )((void *)0)) {
#line 7733
            message((unsigned short)0, 0, (char *)"no server host specified");
#line 7734
            exit(1);
          }
#line 7745
          if ((unsigned int )TargetPorts == (unsigned int )((void *)0)) {
#line 7747
            setPortList((char *)"telnet", & TargetPorts, ServerHost, 0);
          }
#line 7757
          if ((unsigned int )ClientPorts == (unsigned int )((void *)0)) {
#line 7759
            ClientPorts = newPortList((unsigned short)0, (unsigned short)0, (char *)((void *)0),
                                      (unsigned short)3);
#line 7759
            if ((unsigned int )ClientPorts == (unsigned int )((void *)0)) {
#line 7761
              tmp___3 = __error();
#line 7761
              message((unsigned short)0, (*tmp___3), (char *)"can\'t allocate space for port list");
#line 7762
              exit(1);
            }
          }
#line 7768
          tmp___4 = countPorts(ClientPorts);
#line 7768
          tmp___5 = countPorts(TargetPorts);
#line 7768
          if (tmp___4 != tmp___5) {
#line 7770
            message((unsigned short)0, 0, (char *)"the numbers of entries in the client and target port lists do not match");
#line 7771
            exit(1);
          }
#line 7780
          tmp___6 = countPorts(TargetPorts);
#line 7780
          if (tmp___6 > 1) {
#line 7782
            MultiUse ++;
#line 7783
            if (CommandString) {
#line 7785
              message((unsigned short)0, 0, (char *)"can\'t specify a command with multiple target ports");
#line 7786
              exit(1);
            }
          }
#line 7800
          clientListener(ClientPorts);
        }
      }
    }
  }
#line 7804
  exit(0);
}
}
#line 1 "sha_func.o"
#pragma merger(0,"/var/folders/3v/3vE4RtlEGkGI18-fANNMsk+++TI/-Tmp-/cil-kFjaIwCf.i","-O3")
#line 72 "sha_func.c"
static void sha_transform(SHA_INFO *sha_info ) 
{ int i ;
  SHA_LONG T ;
  SHA_LONG A ;
  SHA_LONG B ;
  SHA_LONG C ;
  SHA_LONG D ;
  SHA_LONG E ;
  SHA_LONG W[80] ;
  SHA_LONG *WP ;
  SHA_LONG *tmp ;
  SHA_LONG *tmp___0 ;
  SHA_LONG *tmp___1 ;
  SHA_LONG *tmp___2 ;
  SHA_LONG *tmp___3 ;
  SHA_LONG *tmp___4 ;
  SHA_LONG *tmp___5 ;
  SHA_LONG *tmp___6 ;
  SHA_LONG *tmp___7 ;
  SHA_LONG *tmp___8 ;
  SHA_LONG *tmp___9 ;
  SHA_LONG *tmp___10 ;
  SHA_LONG *tmp___11 ;
  SHA_LONG *tmp___12 ;
  SHA_LONG *tmp___13 ;
  SHA_LONG *tmp___14 ;
  SHA_LONG *tmp___15 ;
  SHA_LONG *tmp___16 ;
  SHA_LONG *tmp___17 ;
  SHA_LONG *tmp___18 ;
  SHA_LONG *tmp___19 ;
  SHA_LONG *tmp___20 ;
  SHA_LONG *tmp___21 ;
  SHA_LONG *tmp___22 ;
  SHA_LONG *tmp___23 ;
  SHA_LONG *tmp___24 ;
  SHA_LONG *tmp___25 ;
  SHA_LONG *tmp___26 ;
  SHA_LONG *tmp___27 ;
  SHA_LONG *tmp___28 ;
  SHA_LONG *tmp___29 ;
  SHA_LONG *tmp___30 ;
  SHA_LONG *tmp___31 ;
  SHA_LONG *tmp___32 ;
  SHA_LONG *tmp___33 ;
  SHA_LONG *tmp___34 ;
  SHA_LONG *tmp___35 ;
  SHA_LONG *tmp___36 ;
  SHA_LONG *tmp___37 ;
  SHA_LONG *tmp___38 ;
  SHA_LONG *tmp___39 ;
  SHA_LONG *tmp___40 ;
  SHA_LONG *tmp___41 ;
  SHA_LONG *tmp___42 ;
  SHA_LONG *tmp___43 ;
  SHA_LONG *tmp___44 ;
  SHA_LONG *tmp___45 ;
  SHA_LONG *tmp___46 ;
  SHA_LONG *tmp___47 ;
  SHA_LONG *tmp___48 ;
  SHA_LONG *tmp___49 ;
  SHA_LONG *tmp___50 ;
  SHA_LONG *tmp___51 ;
  SHA_LONG *tmp___52 ;
  SHA_LONG *tmp___53 ;
  SHA_LONG *tmp___54 ;
  SHA_LONG *tmp___55 ;
  SHA_LONG *tmp___56 ;
  SHA_LONG *tmp___57 ;
  SHA_LONG *tmp___58 ;
  SHA_LONG *tmp___59 ;
  SHA_LONG *tmp___60 ;
  SHA_LONG *tmp___61 ;
  SHA_LONG *tmp___62 ;
  SHA_LONG *tmp___63 ;
  SHA_LONG *tmp___64 ;
  SHA_LONG *tmp___65 ;
  SHA_LONG *tmp___66 ;
  SHA_LONG *tmp___67 ;
  SHA_LONG *tmp___68 ;
  SHA_LONG *tmp___69 ;
  SHA_LONG *tmp___70 ;
  SHA_LONG *tmp___71 ;
  SHA_LONG *tmp___72 ;
  SHA_LONG *tmp___73 ;
  SHA_LONG *tmp___74 ;
  SHA_LONG *tmp___75 ;
  SHA_LONG *tmp___76 ;
  SHA_LONG *tmp___77 ;
  SHA_LONG *tmp___78 ;

  {
#line 77
  i = 0;
#line 77
  while (i < 16) {
#line 78
    W[i] = sha_info->data[i];
#line 77
    i ++;
  }
#line 80
  i = 16;
#line 80
  while (i < 80) {
#line 81
    W[i] = ((W[i - 3] ^ W[i - 8]) ^ W[i - 14]) ^ W[i - 16];
#line 80
    i ++;
  }
#line 86
  A = sha_info->digest[0];
#line 87
  B = sha_info->digest[1];
#line 88
  C = sha_info->digest[2];
#line 89
  D = sha_info->digest[3];
#line 90
  E = sha_info->digest[4];
#line 91
  WP = W;
#line 93
  tmp = WP;
#line 93
  WP ++;
#line 93
  T = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B & C) | (~ B & D))) + E) + (*tmp)) + 1518500249UL);
#line 93
  B = (B << 30) | (B >> 2);
#line 93
  tmp___0 = WP;
#line 93
  WP ++;
#line 93
  E = (unsigned int )((unsigned long )(((((T << 5) | (T >> 27)) + ((A & B) | (~ A & C))) + D) + (*tmp___0)) + 1518500249UL);
#line 93
  A = (A << 30) | (A >> 2);
#line 93
  tmp___1 = WP;
#line 93
  WP ++;
#line 93
  D = (unsigned int )((unsigned long )(((((E << 5) | (E >> 27)) + ((T & A) | (~ T & B))) + C) + (*tmp___1)) + 1518500249UL);
#line 93
  T = (T << 30) | (T >> 2);
#line 93
  tmp___2 = WP;
#line 93
  WP ++;
#line 93
  C = (unsigned int )((unsigned long )(((((D << 5) | (D >> 27)) + ((E & T) | (~ E & A))) + B) + (*tmp___2)) + 1518500249UL);
#line 93
  E = (E << 30) | (E >> 2);
#line 93
  tmp___3 = WP;
#line 93
  WP ++;
#line 93
  B = (unsigned int )((unsigned long )(((((C << 5) | (C >> 27)) + ((D & E) | (~ D & T))) + A) + (*tmp___3)) + 1518500249UL);
#line 93
  D = (D << 30) | (D >> 2);
#line 93
  tmp___4 = WP;
#line 93
  WP ++;
#line 93
  A = (unsigned int )((unsigned long )(((((B << 5) | (B >> 27)) + ((C & D) | (~ C & E))) + T) + (*tmp___4)) + 1518500249UL);
#line 93
  C = (C << 30) | (C >> 2);
#line 93
  tmp___5 = WP;
#line 93
  WP ++;
#line 93
  T = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B & C) | (~ B & D))) + E) + (*tmp___5)) + 1518500249UL);
#line 93
  B = (B << 30) | (B >> 2);
#line 93
  tmp___6 = WP;
#line 93
  WP ++;
#line 93
  E = (unsigned int )((unsigned long )(((((T << 5) | (T >> 27)) + ((A & B) | (~ A & C))) + D) + (*tmp___6)) + 1518500249UL);
#line 93
  A = (A << 30) | (A >> 2);
#line 93
  tmp___7 = WP;
#line 93
  WP ++;
#line 93
  D = (unsigned int )((unsigned long )(((((E << 5) | (E >> 27)) + ((T & A) | (~ T & B))) + C) + (*tmp___7)) + 1518500249UL);
#line 93
  T = (T << 30) | (T >> 2);
#line 93
  tmp___8 = WP;
#line 93
  WP ++;
#line 93
  C = (unsigned int )((unsigned long )(((((D << 5) | (D >> 27)) + ((E & T) | (~ E & A))) + B) + (*tmp___8)) + 1518500249UL);
#line 93
  E = (E << 30) | (E >> 2);
#line 94
  tmp___9 = WP;
#line 94
  WP ++;
#line 94
  B = (unsigned int )((unsigned long )(((((C << 5) | (C >> 27)) + ((D & E) | (~ D & T))) + A) + (*tmp___9)) + 1518500249UL);
#line 94
  D = (D << 30) | (D >> 2);
#line 94
  tmp___10 = WP;
#line 94
  WP ++;
#line 94
  A = (unsigned int )((unsigned long )(((((B << 5) | (B >> 27)) + ((C & D) | (~ C & E))) + T) + (*tmp___10)) + 1518500249UL);
#line 94
  C = (C << 30) | (C >> 2);
#line 94
  tmp___11 = WP;
#line 94
  WP ++;
#line 94
  T = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B & C) | (~ B & D))) + E) + (*tmp___11)) + 1518500249UL);
#line 94
  B = (B << 30) | (B >> 2);
#line 94
  tmp___12 = WP;
#line 94
  WP ++;
#line 94
  E = (unsigned int )((unsigned long )(((((T << 5) | (T >> 27)) + ((A & B) | (~ A & C))) + D) + (*tmp___12)) + 1518500249UL);
#line 94
  A = (A << 30) | (A >> 2);
#line 94
  tmp___13 = WP;
#line 94
  WP ++;
#line 94
  D = (unsigned int )((unsigned long )(((((E << 5) | (E >> 27)) + ((T & A) | (~ T & B))) + C) + (*tmp___13)) + 1518500249UL);
#line 94
  T = (T << 30) | (T >> 2);
#line 94
  tmp___14 = WP;
#line 94
  WP ++;
#line 94
  C = (unsigned int )((unsigned long )(((((D << 5) | (D >> 27)) + ((E & T) | (~ E & A))) + B) + (*tmp___14)) + 1518500249UL);
#line 94
  E = (E << 30) | (E >> 2);
#line 94
  tmp___15 = WP;
#line 94
  WP ++;
#line 94
  B = (unsigned int )((unsigned long )(((((C << 5) | (C >> 27)) + ((D & E) | (~ D & T))) + A) + (*tmp___15)) + 1518500249UL);
#line 94
  D = (D << 30) | (D >> 2);
#line 94
  tmp___16 = WP;
#line 94
  WP ++;
#line 94
  A = (unsigned int )((unsigned long )(((((B << 5) | (B >> 27)) + ((C & D) | (~ C & E))) + T) + (*tmp___16)) + 1518500249UL);
#line 94
  C = (C << 30) | (C >> 2);
#line 94
  tmp___17 = WP;
#line 94
  WP ++;
#line 94
  T = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B & C) | (~ B & D))) + E) + (*tmp___17)) + 1518500249UL);
#line 94
  B = (B << 30) | (B >> 2);
#line 94
  tmp___18 = WP;
#line 94
  WP ++;
#line 94
  E = (unsigned int )((unsigned long )(((((T << 5) | (T >> 27)) + ((A & B) | (~ A & C))) + D) + (*tmp___18)) + 1518500249UL);
#line 94
  A = (A << 30) | (A >> 2);
#line 95
  tmp___19 = WP;
#line 95
  WP ++;
#line 95
  D = (unsigned int )((unsigned long )(((((E << 5) | (E >> 27)) + ((T ^ A) ^ B)) + C) + (*tmp___19)) + 1859775393UL);
#line 95
  T = (T << 30) | (T >> 2);
#line 95
  tmp___20 = WP;
#line 95
  WP ++;
#line 95
  C = (unsigned int )((unsigned long )(((((D << 5) | (D >> 27)) + ((E ^ T) ^ A)) + B) + (*tmp___20)) + 1859775393UL);
#line 95
  E = (E << 30) | (E >> 2);
#line 95
  tmp___21 = WP;
#line 95
  WP ++;
#line 95
  B = (unsigned int )((unsigned long )(((((C << 5) | (C >> 27)) + ((D ^ E) ^ T)) + A) + (*tmp___21)) + 1859775393UL);
#line 95
  D = (D << 30) | (D >> 2);
#line 95
  tmp___22 = WP;
#line 95
  WP ++;
#line 95
  A = (unsigned int )((unsigned long )(((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + T) + (*tmp___22)) + 1859775393UL);
#line 95
  C = (C << 30) | (C >> 2);
#line 95
  tmp___23 = WP;
#line 95
  WP ++;
#line 95
  T = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + E) + (*tmp___23)) + 1859775393UL);
#line 95
  B = (B << 30) | (B >> 2);
#line 95
  tmp___24 = WP;
#line 95
  WP ++;
#line 95
  E = (unsigned int )((unsigned long )(((((T << 5) | (T >> 27)) + ((A ^ B) ^ C)) + D) + (*tmp___24)) + 1859775393UL);
#line 95
  A = (A << 30) | (A >> 2);
#line 95
  tmp___25 = WP;
#line 95
  WP ++;
#line 95
  D = (unsigned int )((unsigned long )(((((E << 5) | (E >> 27)) + ((T ^ A) ^ B)) + C) + (*tmp___25)) + 1859775393UL);
#line 95
  T = (T << 30) | (T >> 2);
#line 95
  tmp___26 = WP;
#line 95
  WP ++;
#line 95
  C = (unsigned int )((unsigned long )(((((D << 5) | (D >> 27)) + ((E ^ T) ^ A)) + B) + (*tmp___26)) + 1859775393UL);
#line 95
  E = (E << 30) | (E >> 2);
#line 95
  tmp___27 = WP;
#line 95
  WP ++;
#line 95
  B = (unsigned int )((unsigned long )(((((C << 5) | (C >> 27)) + ((D ^ E) ^ T)) + A) + (*tmp___27)) + 1859775393UL);
#line 95
  D = (D << 30) | (D >> 2);
#line 95
  tmp___28 = WP;
#line 95
  WP ++;
#line 95
  A = (unsigned int )((unsigned long )(((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + T) + (*tmp___28)) + 1859775393UL);
#line 95
  C = (C << 30) | (C >> 2);
#line 96
  tmp___29 = WP;
#line 96
  WP ++;
#line 96
  T = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + E) + (*tmp___29)) + 1859775393UL);
#line 96
  B = (B << 30) | (B >> 2);
#line 96
  tmp___30 = WP;
#line 96
  WP ++;
#line 96
  E = (unsigned int )((unsigned long )(((((T << 5) | (T >> 27)) + ((A ^ B) ^ C)) + D) + (*tmp___30)) + 1859775393UL);
#line 96
  A = (A << 30) | (A >> 2);
#line 96
  tmp___31 = WP;
#line 96
  WP ++;
#line 96
  D = (unsigned int )((unsigned long )(((((E << 5) | (E >> 27)) + ((T ^ A) ^ B)) + C) + (*tmp___31)) + 1859775393UL);
#line 96
  T = (T << 30) | (T >> 2);
#line 96
  tmp___32 = WP;
#line 96
  WP ++;
#line 96
  C = (unsigned int )((unsigned long )(((((D << 5) | (D >> 27)) + ((E ^ T) ^ A)) + B) + (*tmp___32)) + 1859775393UL);
#line 96
  E = (E << 30) | (E >> 2);
#line 96
  tmp___33 = WP;
#line 96
  WP ++;
#line 96
  B = (unsigned int )((unsigned long )(((((C << 5) | (C >> 27)) + ((D ^ E) ^ T)) + A) + (*tmp___33)) + 1859775393UL);
#line 96
  D = (D << 30) | (D >> 2);
#line 96
  tmp___34 = WP;
#line 96
  WP ++;
#line 96
  A = (unsigned int )((unsigned long )(((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + T) + (*tmp___34)) + 1859775393UL);
#line 96
  C = (C << 30) | (C >> 2);
#line 96
  tmp___35 = WP;
#line 96
  WP ++;
#line 96
  T = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + E) + (*tmp___35)) + 1859775393UL);
#line 96
  B = (B << 30) | (B >> 2);
#line 96
  tmp___36 = WP;
#line 96
  WP ++;
#line 96
  E = (unsigned int )((unsigned long )(((((T << 5) | (T >> 27)) + ((A ^ B) ^ C)) + D) + (*tmp___36)) + 1859775393UL);
#line 96
  A = (A << 30) | (A >> 2);
#line 96
  tmp___37 = WP;
#line 96
  WP ++;
#line 96
  D = (unsigned int )((unsigned long )(((((E << 5) | (E >> 27)) + ((T ^ A) ^ B)) + C) + (*tmp___37)) + 1859775393UL);
#line 96
  T = (T << 30) | (T >> 2);
#line 96
  tmp___38 = WP;
#line 96
  WP ++;
#line 96
  C = (unsigned int )((unsigned long )(((((D << 5) | (D >> 27)) + ((E ^ T) ^ A)) + B) + (*tmp___38)) + 1859775393UL);
#line 96
  E = (E << 30) | (E >> 2);
#line 97
  tmp___39 = WP;
#line 97
  WP ++;
#line 97
  B = (unsigned int )((unsigned long )(((((C << 5) | (C >> 27)) + (((D & E) | (D & T)) | (E & T))) + A) + (*tmp___39)) + 2400959708UL);
#line 97
  D = (D << 30) | (D >> 2);
#line 97
  tmp___40 = WP;
#line 97
  WP ++;
#line 97
  A = (unsigned int )((unsigned long )(((((B << 5) | (B >> 27)) + (((C & D) | (C & E)) | (D & E))) + T) + (*tmp___40)) + 2400959708UL);
#line 97
  C = (C << 30) | (C >> 2);
#line 97
  tmp___41 = WP;
#line 97
  WP ++;
#line 97
  T = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + (((B & C) | (B & D)) | (C & D))) + E) + (*tmp___41)) + 2400959708UL);
#line 97
  B = (B << 30) | (B >> 2);
#line 97
  tmp___42 = WP;
#line 97
  WP ++;
#line 97
  E = (unsigned int )((unsigned long )(((((T << 5) | (T >> 27)) + (((A & B) | (A & C)) | (B & C))) + D) + (*tmp___42)) + 2400959708UL);
#line 97
  A = (A << 30) | (A >> 2);
#line 97
  tmp___43 = WP;
#line 97
  WP ++;
#line 97
  D = (unsigned int )((unsigned long )(((((E << 5) | (E >> 27)) + (((T & A) | (T & B)) | (A & B))) + C) + (*tmp___43)) + 2400959708UL);
#line 97
  T = (T << 30) | (T >> 2);
#line 97
  tmp___44 = WP;
#line 97
  WP ++;
#line 97
  C = (unsigned int )((unsigned long )(((((D << 5) | (D >> 27)) + (((E & T) | (E & A)) | (T & A))) + B) + (*tmp___44)) + 2400959708UL);
#line 97
  E = (E << 30) | (E >> 2);
#line 97
  tmp___45 = WP;
#line 97
  WP ++;
#line 97
  B = (unsigned int )((unsigned long )(((((C << 5) | (C >> 27)) + (((D & E) | (D & T)) | (E & T))) + A) + (*tmp___45)) + 2400959708UL);
#line 97
  D = (D << 30) | (D >> 2);
#line 97
  tmp___46 = WP;
#line 97
  WP ++;
#line 97
  A = (unsigned int )((unsigned long )(((((B << 5) | (B >> 27)) + (((C & D) | (C & E)) | (D & E))) + T) + (*tmp___46)) + 2400959708UL);
#line 97
  C = (C << 30) | (C >> 2);
#line 97
  tmp___47 = WP;
#line 97
  WP ++;
#line 97
  T = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + (((B & C) | (B & D)) | (C & D))) + E) + (*tmp___47)) + 2400959708UL);
#line 97
  B = (B << 30) | (B >> 2);
#line 97
  tmp___48 = WP;
#line 97
  WP ++;
#line 97
  E = (unsigned int )((unsigned long )(((((T << 5) | (T >> 27)) + (((A & B) | (A & C)) | (B & C))) + D) + (*tmp___48)) + 2400959708UL);
#line 97
  A = (A << 30) | (A >> 2);
#line 98
  tmp___49 = WP;
#line 98
  WP ++;
#line 98
  D = (unsigned int )((unsigned long )(((((E << 5) | (E >> 27)) + (((T & A) | (T & B)) | (A & B))) + C) + (*tmp___49)) + 2400959708UL);
#line 98
  T = (T << 30) | (T >> 2);
#line 98
  tmp___50 = WP;
#line 98
  WP ++;
#line 98
  C = (unsigned int )((unsigned long )(((((D << 5) | (D >> 27)) + (((E & T) | (E & A)) | (T & A))) + B) + (*tmp___50)) + 2400959708UL);
#line 98
  E = (E << 30) | (E >> 2);
#line 98
  tmp___51 = WP;
#line 98
  WP ++;
#line 98
  B = (unsigned int )((unsigned long )(((((C << 5) | (C >> 27)) + (((D & E) | (D & T)) | (E & T))) + A) + (*tmp___51)) + 2400959708UL);
#line 98
  D = (D << 30) | (D >> 2);
#line 98
  tmp___52 = WP;
#line 98
  WP ++;
#line 98
  A = (unsigned int )((unsigned long )(((((B << 5) | (B >> 27)) + (((C & D) | (C & E)) | (D & E))) + T) + (*tmp___52)) + 2400959708UL);
#line 98
  C = (C << 30) | (C >> 2);
#line 98
  tmp___53 = WP;
#line 98
  WP ++;
#line 98
  T = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + (((B & C) | (B & D)) | (C & D))) + E) + (*tmp___53)) + 2400959708UL);
#line 98
  B = (B << 30) | (B >> 2);
#line 98
  tmp___54 = WP;
#line 98
  WP ++;
#line 98
  E = (unsigned int )((unsigned long )(((((T << 5) | (T >> 27)) + (((A & B) | (A & C)) | (B & C))) + D) + (*tmp___54)) + 2400959708UL);
#line 98
  A = (A << 30) | (A >> 2);
#line 98
  tmp___55 = WP;
#line 98
  WP ++;
#line 98
  D = (unsigned int )((unsigned long )(((((E << 5) | (E >> 27)) + (((T & A) | (T & B)) | (A & B))) + C) + (*tmp___55)) + 2400959708UL);
#line 98
  T = (T << 30) | (T >> 2);
#line 98
  tmp___56 = WP;
#line 98
  WP ++;
#line 98
  C = (unsigned int )((unsigned long )(((((D << 5) | (D >> 27)) + (((E & T) | (E & A)) | (T & A))) + B) + (*tmp___56)) + 2400959708UL);
#line 98
  E = (E << 30) | (E >> 2);
#line 98
  tmp___57 = WP;
#line 98
  WP ++;
#line 98
  B = (unsigned int )((unsigned long )(((((C << 5) | (C >> 27)) + (((D & E) | (D & T)) | (E & T))) + A) + (*tmp___57)) + 2400959708UL);
#line 98
  D = (D << 30) | (D >> 2);
#line 98
  tmp___58 = WP;
#line 98
  WP ++;
#line 98
  A = (unsigned int )((unsigned long )(((((B << 5) | (B >> 27)) + (((C & D) | (C & E)) | (D & E))) + T) + (*tmp___58)) + 2400959708UL);
#line 98
  C = (C << 30) | (C >> 2);
#line 99
  tmp___59 = WP;
#line 99
  WP ++;
#line 99
  T = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + E) + (*tmp___59)) + 3395469782UL);
#line 99
  B = (B << 30) | (B >> 2);
#line 99
  tmp___60 = WP;
#line 99
  WP ++;
#line 99
  E = (unsigned int )((unsigned long )(((((T << 5) | (T >> 27)) + ((A ^ B) ^ C)) + D) + (*tmp___60)) + 3395469782UL);
#line 99
  A = (A << 30) | (A >> 2);
#line 99
  tmp___61 = WP;
#line 99
  WP ++;
#line 99
  D = (unsigned int )((unsigned long )(((((E << 5) | (E >> 27)) + ((T ^ A) ^ B)) + C) + (*tmp___61)) + 3395469782UL);
#line 99
  T = (T << 30) | (T >> 2);
#line 99
  tmp___62 = WP;
#line 99
  WP ++;
#line 99
  C = (unsigned int )((unsigned long )(((((D << 5) | (D >> 27)) + ((E ^ T) ^ A)) + B) + (*tmp___62)) + 3395469782UL);
#line 99
  E = (E << 30) | (E >> 2);
#line 99
  tmp___63 = WP;
#line 99
  WP ++;
#line 99
  B = (unsigned int )((unsigned long )(((((C << 5) | (C >> 27)) + ((D ^ E) ^ T)) + A) + (*tmp___63)) + 3395469782UL);
#line 99
  D = (D << 30) | (D >> 2);
#line 99
  tmp___64 = WP;
#line 99
  WP ++;
#line 99
  A = (unsigned int )((unsigned long )(((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + T) + (*tmp___64)) + 3395469782UL);
#line 99
  C = (C << 30) | (C >> 2);
#line 99
  tmp___65 = WP;
#line 99
  WP ++;
#line 99
  T = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + E) + (*tmp___65)) + 3395469782UL);
#line 99
  B = (B << 30) | (B >> 2);
#line 99
  tmp___66 = WP;
#line 99
  WP ++;
#line 99
  E = (unsigned int )((unsigned long )(((((T << 5) | (T >> 27)) + ((A ^ B) ^ C)) + D) + (*tmp___66)) + 3395469782UL);
#line 99
  A = (A << 30) | (A >> 2);
#line 99
  tmp___67 = WP;
#line 99
  WP ++;
#line 99
  D = (unsigned int )((unsigned long )(((((E << 5) | (E >> 27)) + ((T ^ A) ^ B)) + C) + (*tmp___67)) + 3395469782UL);
#line 99
  T = (T << 30) | (T >> 2);
#line 99
  tmp___68 = WP;
#line 99
  WP ++;
#line 99
  C = (unsigned int )((unsigned long )(((((D << 5) | (D >> 27)) + ((E ^ T) ^ A)) + B) + (*tmp___68)) + 3395469782UL);
#line 99
  E = (E << 30) | (E >> 2);
#line 100
  tmp___69 = WP;
#line 100
  WP ++;
#line 100
  B = (unsigned int )((unsigned long )(((((C << 5) | (C >> 27)) + ((D ^ E) ^ T)) + A) + (*tmp___69)) + 3395469782UL);
#line 100
  D = (D << 30) | (D >> 2);
#line 100
  tmp___70 = WP;
#line 100
  WP ++;
#line 100
  A = (unsigned int )((unsigned long )(((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + T) + (*tmp___70)) + 3395469782UL);
#line 100
  C = (C << 30) | (C >> 2);
#line 100
  tmp___71 = WP;
#line 100
  WP ++;
#line 100
  T = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + E) + (*tmp___71)) + 3395469782UL);
#line 100
  B = (B << 30) | (B >> 2);
#line 100
  tmp___72 = WP;
#line 100
  WP ++;
#line 100
  E = (unsigned int )((unsigned long )(((((T << 5) | (T >> 27)) + ((A ^ B) ^ C)) + D) + (*tmp___72)) + 3395469782UL);
#line 100
  A = (A << 30) | (A >> 2);
#line 100
  tmp___73 = WP;
#line 100
  WP ++;
#line 100
  D = (unsigned int )((unsigned long )(((((E << 5) | (E >> 27)) + ((T ^ A) ^ B)) + C) + (*tmp___73)) + 3395469782UL);
#line 100
  T = (T << 30) | (T >> 2);
#line 100
  tmp___74 = WP;
#line 100
  WP ++;
#line 100
  C = (unsigned int )((unsigned long )(((((D << 5) | (D >> 27)) + ((E ^ T) ^ A)) + B) + (*tmp___74)) + 3395469782UL);
#line 100
  E = (E << 30) | (E >> 2);
#line 100
  tmp___75 = WP;
#line 100
  WP ++;
#line 100
  B = (unsigned int )((unsigned long )(((((C << 5) | (C >> 27)) + ((D ^ E) ^ T)) + A) + (*tmp___75)) + 3395469782UL);
#line 100
  D = (D << 30) | (D >> 2);
#line 100
  tmp___76 = WP;
#line 100
  WP ++;
#line 100
  A = (unsigned int )((unsigned long )(((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + T) + (*tmp___76)) + 3395469782UL);
#line 100
  C = (C << 30) | (C >> 2);
#line 100
  tmp___77 = WP;
#line 100
  WP ++;
#line 100
  T = (unsigned int )((unsigned long )(((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + E) + (*tmp___77)) + 3395469782UL);
#line 100
  B = (B << 30) | (B >> 2);
#line 100
  tmp___78 = WP;
#line 100
  WP ++;
#line 100
  E = (unsigned int )((unsigned long )(((((T << 5) | (T >> 27)) + ((A ^ B) ^ C)) + D) + (*tmp___78)) + 3395469782UL);
#line 100
  A = (A << 30) | (A >> 2);
#line 101
  sha_info->digest[0] += E;
#line 102
  sha_info->digest[1] += T;
#line 103
  sha_info->digest[2] += A;
#line 104
  sha_info->digest[3] += B;
#line 105
  sha_info->digest[4] += C;
#line 128
  return;
}
}
#line 134
static void maybe_byte_reverse(SHA_LONG *buffer___0 , int count ) ;
#line 134 "sha_func.c"
static int initialized  =    0;
#line 135 "sha_func.c"
static int is_little_endian  =    0;
#line 132 "sha_func.c"
static void maybe_byte_reverse(SHA_LONG *buffer___0 , int count ) 
{ int i ;
  SHA_LONG in ;
  union __anonunion_u_3 u ;
  SHA_LONG *tmp ;

  {
#line 139
  if (! initialized) {
#line 155
    initialized ++;
#line 157
    u.integer = 305419896U;
#line 159
    is_little_endian = (int )u.bytes[0] == 120;
  }
#line 162
  if (is_little_endian) {
#line 163
    count = (int )((unsigned int )count / sizeof(SHA_LONG ));
#line 164
    i = 0;
#line 164
    while (i < count) {
#line 165
      in = (*buffer___0);
#line 166
      tmp = buffer___0;
#line 166
      buffer___0 ++;
#line 166
      (*tmp) = ((((in << 24) & 4278190080U) | ((in << 8) & 16711680U)) | ((in >> 8) & 65280U)) | ((in >> 24) & 255U);
#line 164
      i ++;
    }
  }
#line 170
  return;
}
}
#line 174 "sha_func.c"
void sha_init(SHA_INFO *sha_info ) 
{ 

  {
#line 176
  sha_info->digest[0] = 1732584193U;
#line 177
  sha_info->digest[1] = 4023233417U;
#line 178
  sha_info->digest[2] = 2562383102U;
#line 179
  sha_info->digest[3] = 271733878U;
#line 180
  sha_info->digest[4] = 3285377520U;
#line 181
  sha_info->count_lo = 0U;
#line 182
  sha_info->count_hi = 0U;
#line 183
  sha_info->local = 0;
#line 184
  return;
}
}
#line 188 "sha_func.c"
void sha_update(SHA_INFO *sha_info , SHA_BYTE *buffer___0 , int count ) 
{ int i ;

  {
#line 192
  if (sha_info->count_lo + ((unsigned int )count << 3) < sha_info->count_lo) {
#line 193
    sha_info->count_hi ++;
  }
#line 195
  sha_info->count_lo += (unsigned int )count << 3;
#line 196
  sha_info->count_hi += (unsigned int )count >> 29;
#line 197
  if (sha_info->local) {
#line 198
    i = 64 - sha_info->local;
#line 199
    if (i > count) {
#line 200
      i = count;
    }
#line 202
    memcpy((void *)((SHA_BYTE *)(sha_info->data) + sha_info->local), (void const   *)buffer___0,
           (unsigned long )i);
#line 203
    count -= i;
#line 204
    buffer___0 += i;
#line 205
    sha_info->local += i;
#line 206
    if (sha_info->local == 64) {
#line 207
      maybe_byte_reverse(sha_info->data, 64);
#line 208
      sha_transform(sha_info);
    } else {
#line 210
      return;
    }
  }
#line 213
  while (count >= 64) {
#line 214
    memcpy((void *)(sha_info->data), (void const   *)buffer___0, 64UL);
#line 215
    buffer___0 += 64;
#line 216
    count -= 64;
#line 217
    maybe_byte_reverse(sha_info->data, 64);
#line 218
    sha_transform(sha_info);
  }
#line 220
  memcpy((void *)(sha_info->data), (void const   *)buffer___0, (unsigned long )count);
#line 221
  sha_info->local = count;
#line 222
  return;
}
}
#line 226 "sha_func.c"
void sha_final(SHA_INFO *sha_info ) 
{ int count ;
  SHA_LONG lo_bit_count ;
  SHA_LONG hi_bit_count ;
  int tmp ;

  {
#line 231
  lo_bit_count = sha_info->count_lo;
#line 232
  hi_bit_count = sha_info->count_hi;
#line 233
  count = (int )((lo_bit_count >> 3) & 63U);
#line 234
  tmp = count;
#line 234
  count ++;
#line 234
  (*((SHA_BYTE *)(sha_info->data) + tmp)) = (unsigned char)128;
#line 235
  if (count > 56) {
#line 236
    memset((void *)((SHA_BYTE *)(sha_info->data) + count), 0, (unsigned long )(64 - count));
#line 237
    maybe_byte_reverse(sha_info->data, 64);
#line 238
    sha_transform(sha_info);
#line 239
    memset((void *)((SHA_BYTE *)(sha_info->data)), 0, 56UL);
  } else {
#line 241
    memset((void *)((SHA_BYTE *)(sha_info->data) + count), 0, (unsigned long )(56 - count));
  }
#line 244
  maybe_byte_reverse(sha_info->data, 64);
#line 245
  sha_info->data[14] = hi_bit_count;
#line 246
  sha_info->data[15] = lo_bit_count;
#line 247
  sha_transform(sha_info);
#line 248
  return;
}
}
#line 1 "huge.o"
#pragma merger(0,"/var/folders/3v/3vE4RtlEGkGI18-fANNMsk+++TI/-Tmp-/cil-4HENP83g.i","-O3")
#line 145 "/usr/include/stdlib.h"
extern  __attribute__((__noreturn__)) void abort(void) ;
#line 69 "huge.h"
Huge *huge_new(int size ) ;
#line 70
void huge_copy(Huge *a , Huge *b ) ;
#line 71
Huge *huge_dup(Huge *a ) ;
#line 76
Huge *huge_from_long(long ival ) ;
#line 77
Huge *huge_from_unsigned_long(unsigned long ival ) ;
#line 78
long huge_as_long(Huge *v ) ;
#line 79
unsigned long huge_as_unsigned_long(Huge *v ) ;
#line 82
Huge *huge_set_bit(Huge *v , int i ) ;
#line 83
void huge_clear_bit(Huge *v , int i ) ;
#line 86
Huge *huge_from_binary(unsigned char *s , int n ) ;
#line 87
char *huge_as_binary(Huge *a , int *l ) ;
#line 91
char *huge_oct(Huge *v ) ;
#line 92
char *huge_hex(Huge *v ) ;
#line 93
char *huge_dec(Huge *v ) ;
#line 96
int huge_compare(Huge *a , Huge *b ) ;
#line 97
int huge_nonzero(Huge *v ) ;
#line 100
Huge *huge_add(Huge *a , Huge *b ) ;
#line 101
Huge *huge_sub(Huge *a , Huge *b ) ;
#line 102
Huge *huge_mul(Huge *a , Huge *b ) ;
#line 103
Huge *huge_div(Huge *v , Huge *w ) ;
#line 104
Huge *huge_mod(Huge *v , Huge *w ) ;
#line 105
Huge *huge_divmod(Huge *v , Huge *w , Huge **remainder ) ;
#line 106
Huge *huge_invert(Huge *v ) ;
#line 109
Huge *huge_pow(Huge *a , Huge *b ) ;
#line 113
Huge *huge_neg(Huge *v ) ;
#line 114
Huge *huge_abs(Huge *v ) ;
#line 117
Huge *huge_rshift(Huge *a , int shiftby ) ;
#line 118
Huge *huge_lshift(Huge *a , int shiftby ) ;
#line 121
Huge *huge_and(Huge *a , Huge *b ) ;
#line 122
Huge *huge_xor(Huge *a , Huge *b ) ;
#line 123
Huge *huge_or(Huge *a , Huge *b ) ;
#line 128
void xhuge_log(Huge *h , char *msg , char *file , int line ) ;
#line 90 "huge.c"
static Huge *huge_normalize(Huge *v ) ;
#line 91
static Huge *mul1(Huge *a , wdigit n ) ;
#line 92
static Huge *muladd1(Huge *a , wdigit n , wdigit extra ) ;
#line 93
static Huge *divrem1(Huge *a , wdigit n , digit *prem ) ;
#line 94
static Huge *x_divrem(Huge *v1 , Huge *w1 , Huge **prem ) ;
#line 102 "huge.c"
static Huge *huge_normalize(Huge *v ) 
{ int j ;
  long tmp ;
  int i ;

  {
#line 104
  if (v->size >= 0L) {
#line 104
    tmp = v->size;
  } else {
#line 104
    tmp = - v->size;
  }
#line 104
  j = (int )tmp;
#line 105
  i = j;
#line 107
  while (1) {
#line 107
    if (i > 0) {
#line 107
      if (! ((*(v->d + (i - 1))) == 0U)) {
#line 107
        break;
      }
    } else {
#line 107
      break;
    }
#line 108
    i --;
  }
#line 109
  if (i != j) {
#line 110
    if (v->size < 0L) {
#line 110
      v->size = (long )(- i);
    } else {
#line 110
      v->size = (long )i;
    }
  }
#line 111
  return (v);
}
}
#line 114 "huge.c"
Huge *huge_new(int size ) 
{ Huge *h ;
  char *x ;

  {
#line 118
  h = (Huge *)malloc((unsigned long )(sizeof(Huge ) + (unsigned int )size * sizeof(digit )));
#line 119
  x = (char *)h;
#line 120
  x += sizeof(Huge );
#line 121
  h->d = (digit *)x;
#line 122
  h->size = (long )size;
#line 123
  memset((void *)h->d, 0, (unsigned long )((unsigned int )size * sizeof(digit )));
#line 124
  return (h);
}
}
#line 127 "huge.c"
void huge_copy(Huge *a , Huge *b ) 
{ int i ;
  long tmp ;

  {
#line 130
  i = 0;
#line 130
  while (1) {
#line 130
    if (b->size >= 0L) {
#line 130
      tmp = b->size;
    } else {
#line 130
      tmp = - b->size;
    }
#line 130
    if (! ((long )i < tmp)) {
#line 130
      break;
    }
#line 131
    (*(a->d + i)) = (*(b->d + i));
#line 130
    i ++;
  }
#line 132
  a->size = b->size;
#line 133
  return;
}
}
#line 135 "huge.c"
Huge *huge_dup(Huge *a ) 
{ Huge *b ;
  long tmp ;

  {
#line 138
  if (! a) {
#line 139
    return ((Huge *)0);
  }
#line 140
  if (a->size >= 0L) {
#line 140
    tmp = a->size;
  } else {
#line 140
    tmp = - a->size;
  }
#line 140
  b = huge_new((int )tmp);
#line 141
  huge_copy(b, a);
#line 142
  return (b);
}
}
#line 147 "huge.c"
Huge *huge_from_long(long ival ) 
{ Huge *v ;
  Huge *tmp ;
  unsigned long t ;
  int i ;
  Huge *tmp___0 ;

  {
#line 151
  tmp = huge_new(5);
#line 151
  v = tmp;
#line 152
  t = (unsigned long )ival;
#line 154
  if (ival < 0L) {
#line 155
    t = (unsigned long )(- ival);
#line 156
    v->size = - v->size;
  }
#line 158
  i = 0;
#line 158
  while (i < 5) {
#line 159
    (*(v->d + i)) = (unsigned int )(t & 2147483647UL);
#line 160
    t >>= 31;
#line 158
    i ++;
  }
#line 162
  tmp___0 = huge_normalize(v);
#line 162
  return (tmp___0);
}
}
#line 165 "huge.c"
Huge *huge_set_bit(Huge *v , int i ) 
{ Huge *w ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 168
  if (v->size >= 0L) {
#line 168
    tmp___2 = v->size;
  } else {
#line 168
    tmp___2 = - v->size;
  }
#line 168
  if (tmp___2 < (long )(i / 31 + 1)) {
#line 168
    tmp___1 = (long )(i / 31 + 1);
  } else {
#line 168
    if (v->size >= 0L) {
#line 168
      tmp___1 = v->size;
    } else {
#line 168
      tmp___1 = - v->size;
    }
  }
#line 168
  w = huge_new((int )tmp___1);
#line 169
  huge_copy(w, v);
#line 170
  (*(w->d + i / 31)) |= (unsigned int )(1 << i % 31);
#line 171
  return (w);
}
}
#line 174 "huge.c"
void huge_clear_bit(Huge *v , int i ) 
{ long tmp ;

  {
#line 176
  if (v->size >= 0L) {
#line 176
    tmp = v->size;
  } else {
#line 176
    tmp = - v->size;
  }
#line 176
  if ((long )(i / 31) < tmp) {
#line 177
    (*(v->d + i / 31)) &= (unsigned int )(~ (1 << i % 31));
  }
#line 178
  huge_normalize(v);
#line 179
  return;
}
}
#line 181 "huge.c"
__inline static unsigned char _huge_get_char(Huge *a , int j ) 
{ twodigits r ;
  int i ;

  {
#line 183
  r = (twodigits )0;
#line 185
  i = (j * 8) / 31;
#line 186
  if ((long )i < a->size) {
#line 187
    r = (unsigned long long )(*(a->d + i));
#line 188
    i ++;
#line 188
    if ((long )i < a->size) {
#line 189
      r |= (unsigned long long )(*(a->d + i)) << 31;
    }
  }
#line 191
  r >>= (j * 8) % 31;
#line 192
  return ((unsigned char )(r & 255ULL));
}
}
#line 196 "huge.c"
char *huge_as_binary(Huge *a , int *l ) 
{ char *s ;
  int i ;

  {
#line 200
  (*l) = (int )((a->size * 31L) / 8L + 1L);
#line 201
  s = (char *)malloc((unsigned long )((*l) + 1));
#line 202
  i = 0;
#line 202
  while (i < (*l)) {
#line 203
    (*(s + i)) = (char )_huge_get_char(a, i);
#line 202
    i ++;
  }
#line 204
  while (1) {
#line 204
    if ((*l) > 0) {
#line 204
      if (! (! (*(s + ((*l) - 1))))) {
#line 204
        break;
      }
    } else {
#line 204
      break;
    }
#line 205
    (*l) --;
  }
#line 206
  return (s);
}
}
#line 210 "huge.c"
Huge *huge_from_binary(unsigned char *s , int n ) 
{ Huge *z ;
  int i ;
  int size ;
  digit *d ;
  int j ;
  twodigits t ;
  int r ;
  digit *tmp ;
  Huge *tmp___0 ;

  {
#line 215
  size = (n * 8) / 31;
#line 216
  z = huge_new(size + 1);
#line 217
  d = z->d;
#line 218
  i = 0;
#line 218
  while (i < size + 1) {
#line 220
    t = (twodigits )0;
#line 222
    r = (i * 31) / 8;
#line 223
    j = 0;
#line 223
    while (1) {
#line 223
      if (j < 6) {
#line 223
        if (! (r < n)) {
#line 223
          break;
        }
      } else {
#line 223
        break;
      }
#line 224
      t |= (unsigned long long )(*(s + r)) << j * 8;
#line 223
      j ++;
#line 223
      r ++;
    }
#line 225
    t >>= (i * 31) % 8;
#line 226
    tmp = d;
#line 226
    d ++;
#line 226
    (*tmp) = (unsigned int )t & 2147483647U;
#line 218
    i ++;
  }
#line 228
  tmp___0 = huge_normalize(z);
#line 228
  return (tmp___0);
}
}
#line 233 "huge.c"
Huge *huge_from_unsigned_long(unsigned long ival ) 
{ unsigned long t ;
  int i ;
  Huge *v ;
  Huge *tmp ;
  Huge *tmp___0 ;

  {
#line 235
  t = ival;
#line 239
  tmp = huge_new(5);
#line 239
  v = tmp;
#line 240
  i = 0;
#line 240
  while (i < 5) {
#line 241
    (*(v->d + i)) = (unsigned int )(t & 2147483647UL);
#line 242
    t >>= 31;
#line 240
    i ++;
  }
#line 244
  tmp___0 = huge_normalize(v);
#line 244
  return (tmp___0);
}
}
#line 250 "huge.c"
long huge_as_long(Huge *v ) 
{ long x ;
  long prev ;
  int i ;
  int sign ;

  {
#line 255
  i = (int )v->size;
#line 256
  sign = 1;
#line 257
  x = 0L;
#line 258
  if (i < 0) {
#line 259
    sign = -1;
#line 260
    i = - i;
  }
#line 262
  while (1) {
#line 262
    i --;
#line 262
    if (! (i >= 0)) {
#line 262
      break;
    }
#line 263
    prev = x;
#line 264
    x = (long )((unsigned long )(x << 31) + (unsigned long )(*(v->d + i)));
#line 265
    if (x >> 31 != prev) {
#line 266
      fprintf(__stderrp, "huge_%s\n", "as_long(): long int too long to convert");
#line 267
      return (-1L);
    }
  }
#line 270
  return (x * (long )sign);
}
}
#line 276 "huge.c"
unsigned long huge_as_unsigned_long(Huge *v ) 
{ unsigned long x ;
  unsigned long prev ;
  int i ;

  {
#line 281
  i = (int )v->size;
#line 282
  x = 0UL;
#line 283
  if (i < 0) {
#line 284
    fprintf(__stderrp, "huge_%s\n", "as_unsigned_long(): can\'t convert negative value to unsigned long");
#line 285
    return (4294967295UL);
  }
#line 287
  while (1) {
#line 287
    i --;
#line 287
    if (! (i >= 0)) {
#line 287
      break;
    }
#line 288
    prev = x;
#line 289
    x = (x << 31) + (unsigned long )(*(v->d + i));
#line 290
    if (x >> 31 != prev) {
#line 291
      fprintf(__stderrp, "huge_%s\n", "as_unsigned_long(): long int too long to convert");
#line 292
      return (4294967295UL);
    }
  }
#line 295
  return (x);
}
}
#line 303 "huge.c"
static Huge *mul1(Huge *a , wdigit n ) 
{ Huge *tmp ;

  {
#line 305
  tmp = muladd1(a, n, 0U);
#line 305
  return (tmp);
}
}
#line 333 "huge.c"
static Huge *muladd1(Huge *a , wdigit n , wdigit extra ) 
{ int size_a ;
  long tmp ;
  Huge *z ;
  Huge *tmp___0 ;
  twodigits carry ;
  int i ;
  Huge *tmp___1 ;

  {
#line 335
  if (a->size >= 0L) {
#line 335
    tmp = a->size;
  } else {
#line 335
    tmp = - a->size;
  }
#line 335
  size_a = (int )tmp;
#line 336
  tmp___0 = huge_new(size_a + 1);
#line 336
  z = tmp___0;
#line 337
  carry = (twodigits )extra;
#line 339
  i = 0;
#line 339
  while (i < size_a) {
#line 340
    carry += (unsigned long long )(*(a->d + i)) * (unsigned long long )n;
#line 341
    (*(z->d + i)) = (unsigned int )(carry & 2147483647ULL);
#line 342
    carry >>= 31;
#line 339
    i ++;
  }
#line 344
  (*(z->d + i)) = (unsigned int )carry;
#line 345
  tmp___1 = huge_normalize(z);
#line 345
  return (tmp___1);
}
}
#line 352 "huge.c"
static Huge *divrem1(Huge *a , wdigit n , digit *prem ) 
{ int size ;
  long tmp ;
  Huge *z ;
  int i ;
  twodigits rem ;
  Huge *tmp___0 ;

  {
#line 354
  if (a->size >= 0L) {
#line 354
    tmp = a->size;
  } else {
#line 354
    tmp = - a->size;
  }
#line 354
  size = (int )tmp;
#line 357
  rem = (twodigits )0;
#line 359
  if (n > 0U) {
#line 359
    if (! (n <= 2147483647U)) {
#line 359
      fprintf(__stderrp, "huge: assertion failed, %s:%d\n", "huge.c", 359);
#line 359
      abort();
    }
  } else {
#line 359
    fprintf(__stderrp, "huge: assertion failed, %s:%d\n", "huge.c", 359);
#line 359
    abort();
  }
#line 360
  z = huge_new(size);
#line 361
  i = size;
#line 361
  while (1) {
#line 361
    i --;
#line 361
    if (! (i >= 0)) {
#line 361
      break;
    }
#line 362
    rem = (rem << 31) + (twodigits )(*(a->d + i));
#line 363
    (*(z->d + i)) = (unsigned int )(rem / (twodigits )n);
#line 364
    rem %= (unsigned long long )n;
  }
#line 366
  (*prem) = (unsigned int )rem;
#line 367
  tmp___0 = huge_normalize(z);
#line 367
  return (tmp___0);
}
}
#line 377 "huge.c"
char *huge_format(Huge *a , int base ) 
{ char *str ;
  int i ;
  int size_a ;
  long tmp ;
  char *p ;
  int bits ;
  char sign ;
  digit rem ;
  Huge *temp ;
  Huge *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  char *q ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 381
  if (a->size >= 0L) {
#line 381
    tmp = a->size;
  } else {
#line 381
    tmp = - a->size;
  }
#line 381
  size_a = (int )tmp;
#line 384
  sign = (char )'\000';
#line 386
  a = huge_dup(a);
#line 387
  if (base >= 2) {
#line 387
    if (! (base <= 36)) {
#line 387
      fprintf(__stderrp, "huge: assertion failed, %s:%d\n", "huge.c", 387);
#line 387
      abort();
    }
  } else {
#line 387
    fprintf(__stderrp, "huge: assertion failed, %s:%d\n", "huge.c", 387);
#line 387
    abort();
  }
#line 390
  i = base;
#line 391
  bits = 0;
#line 392
  while (i > 1) {
#line 393
    bits ++;
#line 394
    i >>= 1;
  }
#line 396
  i = 6 + ((size_a * 31 + bits) - 1) / bits;
#line 397
  str = (char *)malloc((unsigned long )(i + 1));
#line 398
  p = str + i;
#line 399
  (*p) = (char )'\000';
#line 403
  if (a->size < 0L) {
#line 404
    sign = (char )'-';
#line 405
    if (a->size >= 0L) {
#line 405
      a->size = a->size;
    } else {
#line 405
      a->size = - a->size;
    }
  }
#line 408
  while (1) {
#line 410
    tmp___0 = divrem1(a, (unsigned int )base, & rem);
#line 410
    temp = tmp___0;
#line 411
    if ((unsigned int )temp == (unsigned int )((Huge *)0)) {
#line 412
      if (a) {
#line 412
        if (a->size >= 0L) {
#line 412
          tmp___1 = a->size;
        } else {
#line 412
          tmp___1 = - a->size;
        }
#line 412
        memset((void *)a, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___1);
#line 412
        free((void *)a);
      }
#line 412
      a = (Huge *)0;
#line 413
      free((void *)str);
#line 414
      return ((char *)0);
    }
#line 416
    if (rem < 10U) {
#line 417
      rem += 48U;
    } else {
#line 419
      rem += 87U;
    }
#line 420
    if (! ((unsigned int )p > (unsigned int )str)) {
#line 420
      fprintf(__stderrp, "huge: assertion failed, %s:%d\n", "huge.c", 420);
#line 420
      abort();
    }
#line 421
    p --;
#line 421
    (*p) = (char )rem;
#line 422
    if (a) {
#line 422
      if (a->size >= 0L) {
#line 422
        tmp___2 = a->size;
      } else {
#line 422
        tmp___2 = - a->size;
      }
#line 422
      memset((void *)a, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___2);
#line 422
      free((void *)a);
    }
#line 422
    a = (Huge *)0;
#line 423
    a = temp;
#line 408
    if (a->size >= 0L) {
#line 408
      tmp___3 = a->size;
    } else {
#line 408
      tmp___3 = - a->size;
    }
#line 408
    if (! (tmp___3 != 0L)) {
#line 408
      break;
    }
  }
#line 425
  if (a) {
#line 425
    if (a->size >= 0L) {
#line 425
      tmp___4 = a->size;
    } else {
#line 425
      tmp___4 = - a->size;
    }
#line 425
    memset((void *)a, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___4);
#line 425
    free((void *)a);
  }
#line 425
  a = (Huge *)0;
#line 441
  if (sign) {
#line 442
    p --;
#line 442
    (*p) = sign;
  }
#line 443
  if ((unsigned int )p != (unsigned int )str) {
#line 444
    q = str;
#line 445
    if (! ((unsigned int )p > (unsigned int )q)) {
#line 445
      fprintf(__stderrp, "huge: assertion failed, %s:%d\n", "huge.c", 445);
#line 445
      abort();
    }
#line 446
    while (1) {
#line 446
      tmp___5 = q;
#line 446
      q ++;
#line 446
      tmp___6 = p;
#line 446
      p ++;
#line 446
      (*tmp___5) = (*tmp___6);
#line 446
      if (! ((int )(*tmp___5) != 0)) {
#line 446
        break;
      }
    }
#line 448
    q --;
  }
#line 450
  return (str);
}
}
#line 453 "huge.c"
Huge *huge_from_string(char *str , char **pend , int base ) 
{ int sign ;
  Huge *z ;
  char *tmp ;
  char *tmp___0 ;
  int k ;
  Huge *temp ;
  long tmp___1 ;
  Huge *tmp___2 ;

  {
#line 455
  sign = 1;
#line 458
  while (1) {
#line 458
    if ((int )(*str) != 0) {
#line 458
      tmp = strchr("\t\n ", (int )(*str));
#line 458
      if (! tmp) {
#line 458
        break;
      }
    } else {
#line 458
      break;
    }
#line 459
    str ++;
  }
#line 460
  if ((int )(*str) == 43) {
#line 461
    str ++;
  } else {
#line 462
    if ((int )(*str) == 45) {
#line 463
      str ++;
#line 464
      sign = -1;
    }
  }
#line 466
  while (1) {
#line 466
    if ((int )(*str) != 0) {
#line 466
      tmp___0 = strchr("\t\n ", (int )(*str));
#line 466
      if (! tmp___0) {
#line 466
        break;
      }
    } else {
#line 466
      break;
    }
#line 467
    str ++;
  }
#line 468
  if (base == 0) {
#line 469
    if ((int )(*(str + 0)) != 48) {
#line 470
      base = 10;
    } else {
#line 471
      if ((int )(*(str + 1)) == 120) {
#line 472
        base = 16;
      } else {
#line 471
        if ((int )(*(str + 1)) == 88) {
#line 472
          base = 16;
        } else {
#line 474
          base = 8;
        }
      }
    }
  }
#line 476
  if (base == 16) {
#line 476
    if ((int )(*(str + 0)) == 48) {
#line 476
      if ((int )(*(str + 1)) == 120) {
#line 477
        str += 2;
      } else {
#line 476
        if ((int )(*(str + 1)) == 88) {
#line 477
          str += 2;
        }
      }
    }
  }
#line 478
  z = huge_new(0);
#line 479
  while ((unsigned int )z != (unsigned int )((Huge *)0)) {
#line 480
    k = -1;
#line 483
    if ((int )(*str) <= 57) {
#line 484
      k = (int )(*str) - 48;
    } else {
#line 485
      if ((int )(*str) >= 97) {
#line 486
        k = ((int )(*str) - 97) + 10;
      } else {
#line 487
        if ((int )(*str) >= 65) {
#line 488
          k = ((int )(*str) - 65) + 10;
        }
      }
    }
#line 489
    if (k < 0) {
#line 490
      break;
    } else {
#line 489
      if (k >= base) {
#line 490
        break;
      }
    }
#line 491
    temp = muladd1(z, (unsigned int )base, (unsigned int )k);
#line 492
    if (z) {
#line 492
      if (z->size >= 0L) {
#line 492
        tmp___1 = z->size;
      } else {
#line 492
        tmp___1 = - z->size;
      }
#line 492
      memset((void *)z, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___1);
#line 492
      free((void *)z);
    }
#line 492
    z = (Huge *)0;
#line 493
    z = temp;
#line 479
    str ++;
  }
#line 495
  if (sign < 0) {
#line 495
    if ((unsigned int )z != (unsigned int )((Huge *)0)) {
#line 495
      if (z->size != 0L) {
#line 496
        z->size = - z->size;
      }
    }
  }
#line 497
  if (pend) {
#line 498
    (*pend) = str;
  }
#line 499
  tmp___2 = huge_normalize(z);
#line 499
  return (tmp___2);
}
}
#line 504 "huge.c"
static int _huge_divrem(Huge *a , Huge *b , Huge **pdiv , Huge **prem ) 
{ int size_a ;
  long tmp ;
  int size_b ;
  long tmp___0 ;
  Huge *z ;
  digit rem ;

  {
#line 506
  if (a->size >= 0L) {
#line 506
    tmp = a->size;
  } else {
#line 506
    tmp = - a->size;
  }
#line 506
  size_a = (int )tmp;
#line 506
  if (b->size >= 0L) {
#line 506
    tmp___0 = b->size;
  } else {
#line 506
    tmp___0 = - b->size;
  }
#line 506
  size_b = (int )tmp___0;
#line 509
  if (! size_b) {
#line 510
    fprintf(__stderrp, "huge_%s\n", "divrem(): divide by zero");
  }
#line 511
  if (size_a < size_b) {
#line 515
    (*pdiv) = huge_new(0);
#line 516
    (*prem) = huge_dup(a);
#line 517
    return (0);
  } else {
#line 511
    if (size_a == size_b) {
#line 511
      if ((*(a->d + (size_a - 1))) < (*(b->d + (size_b - 1)))) {
#line 515
        (*pdiv) = huge_new(0);
#line 516
        (*prem) = huge_dup(a);
#line 517
        return (0);
      }
    }
  }
#line 519
  if (size_b == 1) {
#line 520
    rem = (digit )0;
#line 521
    z = divrem1(a, (*(b->d + 0)), & rem);
#line 522
    if ((unsigned int )z == (unsigned int )((Huge *)0)) {
#line 523
      return (-1);
    }
#line 524
    (*prem) = huge_from_long((long )rem);
  } else {
#line 526
    z = x_divrem(a, b, prem);
#line 527
    if ((unsigned int )z == (unsigned int )((Huge *)0)) {
#line 528
      return (-1);
    }
  }
#line 534
  if ((a->size < 0L) != (b->size < 0L)) {
#line 535
    z->size = - z->size;
  }
#line 536
  if (a->size < 0L) {
#line 536
    if (((*prem))->size != 0L) {
#line 537
      ((*prem))->size = - ((*prem))->size;
    }
  }
#line 538
  (*pdiv) = z;
#line 539
  return (0);
}
}
#line 544 "huge.c"
static Huge *x_divrem(Huge *v1 , Huge *w1 , Huge **prem ) 
{ int size_v ;
  long tmp ;
  int size_w ;
  long tmp___0 ;
  digit d ;
  Huge *v ;
  Huge *tmp___1 ;
  Huge *w ;
  Huge *tmp___2 ;
  Huge *a ;
  int j ;
  int k ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  digit vj ;
  digit tmp___6 ;
  twodigits q ;
  stwodigits carry ;
  int i ;
  twodigits z ;
  digit zz ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;

  {
#line 546
  if (v1->size >= 0L) {
#line 546
    tmp = v1->size;
  } else {
#line 546
    tmp = - v1->size;
  }
#line 546
  size_v = (int )tmp;
#line 546
  if (w1->size >= 0L) {
#line 546
    tmp___0 = w1->size;
  } else {
#line 546
    tmp___0 = - w1->size;
  }
#line 546
  size_w = (int )tmp___0;
#line 547
  d = (unsigned int )(2147483648ULL / (unsigned long long )((*(w1->d + (size_w - 1))) + 1U));
#line 548
  tmp___1 = mul1(v1, d);
#line 548
  v = tmp___1;
#line 549
  tmp___2 = mul1(w1, d);
#line 549
  w = tmp___2;
#line 553
  if ((unsigned int )v == (unsigned int )((Huge *)0)) {
    goto _L;
  } else {
#line 553
    if ((unsigned int )w == (unsigned int )((Huge *)0)) {
      _L: /* CIL Label */ 
#line 554
      if (v) {
#line 554
        if (v->size >= 0L) {
#line 554
          tmp___3 = v->size;
        } else {
#line 554
          tmp___3 = - v->size;
        }
#line 554
        memset((void *)v, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___3);
#line 554
        free((void *)v);
      }
#line 554
      v = (Huge *)0;
#line 555
      if (w) {
#line 555
        if (w->size >= 0L) {
#line 555
          tmp___4 = w->size;
        } else {
#line 555
          tmp___4 = - w->size;
        }
#line 555
        memset((void *)w, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___4);
#line 555
        free((void *)w);
      }
#line 555
      w = (Huge *)0;
#line 556
      return ((Huge *)0);
    }
  }
#line 558
  if (size_v >= size_w) {
#line 558
    if (! (size_w > 1)) {
#line 558
      fprintf(__stderrp, "huge: assertion failed, %s:%d\n", "huge.c", 558);
#line 558
      abort();
    }
  } else {
#line 558
    fprintf(__stderrp, "huge: assertion failed, %s:%d\n", "huge.c", 558);
#line 558
    abort();
  }
#line 559
  if (w->size >= 0L) {
#line 559
    tmp___5 = w->size;
  } else {
#line 559
    tmp___5 = - w->size;
  }
#line 559
  if (! ((long )size_w == tmp___5)) {
#line 559
    fprintf(__stderrp, "huge: assertion failed, %s:%d\n", "huge.c", 559);
#line 559
    abort();
  }
#line 561
  if (v->size >= 0L) {
#line 561
    size_v = (int )v->size;
  } else {
#line 561
    size_v = (int )(- v->size);
  }
#line 562
  a = huge_new((size_v - size_w) + 1);
#line 564
  j = size_v;
#line 564
  k = (int )(a->size - 1L);
#line 564
  while (1) {
#line 564
    if ((unsigned int )a != (unsigned int )((Huge *)0)) {
#line 564
      if (! (k >= 0)) {
#line 564
        break;
      }
    } else {
#line 564
      break;
    }
#line 565
    if (j >= size_v) {
#line 565
      tmp___6 = 0U;
    } else {
#line 565
      tmp___6 = (*(v->d + j));
    }
#line 565
    vj = tmp___6;
#line 567
    carry = (stwodigits )0;
#line 570
    if (vj == (*(w->d + (size_w - 1)))) {
#line 571
      q = 2147483647ULL;
    } else {
#line 573
      q = (((unsigned long long )vj << 31) + (unsigned long long )(*(v->d + (j - 1)))) / (unsigned long long )(*(w->d + (size_w - 1)));
    }
#line 576
    while ((twodigits )(*(w->d + (size_w - 2))) * q > (((((unsigned long long )vj << 31) + (unsigned long long )(*(v->d + (j - 1)))) - q * (twodigits )(*(w->d + (size_w - 1)))) << 31) + (unsigned long long )(*(v->d + (j - 2)))) {
#line 583
      q --;
    }
#line 585
    i = 0;
#line 585
    while (1) {
#line 585
      if (i < size_w) {
#line 585
        if (! (i + k < size_v)) {
#line 585
          break;
        }
      } else {
#line 585
        break;
      }
#line 586
      z = (twodigits )(*(w->d + i)) * q;
#line 587
      zz = (unsigned int )(z >> 31);
#line 588
      carry = (long long )((twodigits )carry + (((twodigits )(*(v->d + (i + k))) - z) + ((unsigned long long )zz << 31)));
#line 590
      (*(v->d + (i + k))) = (unsigned int )(carry & 2147483647LL);
#line 591
      carry = (carry >> 31) - (stwodigits )zz;
#line 585
      i ++;
    }
#line 594
    if (i + k < size_v) {
#line 595
      carry += (stwodigits )(*(v->d + (i + k)));
#line 596
      (*(v->d + (i + k))) = 0U;
    }
#line 598
    if (carry == 0LL) {
#line 599
      (*(a->d + k)) = (unsigned int )q;
    } else {
#line 601
      if (! (carry == -1LL)) {
#line 601
        fprintf(__stderrp, "huge: assertion failed, %s:%d\n", "huge.c", 601);
#line 601
        abort();
      }
#line 602
      (*(a->d + k)) = (unsigned int )q - 1U;
#line 603
      carry = 0LL;
#line 604
      i = 0;
#line 604
      while (1) {
#line 604
        if (i < size_w) {
#line 604
          if (! (i + k < size_v)) {
#line 604
            break;
          }
        } else {
#line 604
          break;
        }
#line 605
        carry += (stwodigits )((*(v->d + (i + k))) + (*(w->d + i)));
#line 606
        (*(v->d + (i + k))) = (unsigned int )(carry & 2147483647LL);
#line 607
        carry >>= 31;
#line 604
        i ++;
      }
    }
#line 564
    j --;
#line 564
    k --;
  }
#line 612
  if ((unsigned int )a == (unsigned int )((Huge *)0)) {
#line 613
    (*prem) = (Huge *)0;
  } else {
#line 615
    a = huge_normalize(a);
#line 616
    (*prem) = divrem1(v, d, & d);
#line 618
    if ((unsigned int )(*prem) == (unsigned int )((Huge *)0)) {
#line 619
      if (a) {
#line 619
        if (a->size >= 0L) {
#line 619
          tmp___7 = a->size;
        } else {
#line 619
          tmp___7 = - a->size;
        }
#line 619
        memset((void *)a, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___7);
#line 619
        free((void *)a);
      }
#line 619
      a = (Huge *)0;
#line 620
      a = (Huge *)0;
    }
  }
#line 623
  if (v) {
#line 623
    if (v->size >= 0L) {
#line 623
      tmp___8 = v->size;
    } else {
#line 623
      tmp___8 = - v->size;
    }
#line 623
    memset((void *)v, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___8);
#line 623
    free((void *)v);
  }
#line 623
  v = (Huge *)0;
#line 624
  if (w) {
#line 624
    if (w->size >= 0L) {
#line 624
      tmp___9 = w->size;
    } else {
#line 624
      tmp___9 = - w->size;
    }
#line 624
    memset((void *)w, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___9);
#line 624
    free((void *)w);
  }
#line 624
  w = (Huge *)0;
#line 625
  return (a);
}
}
#line 628 "huge.c"
int huge_compare(Huge *a , Huge *b ) 
{ int sign ;
  long tmp ;
  long tmp___0 ;
  int i ;
  long tmp___1 ;
  int tmp___3 ;

  {
#line 632
  if (a->size != b->size) {
#line 633
    if (a->size >= 0L) {
#line 633
      tmp = a->size;
    } else {
#line 633
      tmp = - a->size;
    }
#line 633
    if (tmp == 0L) {
#line 633
      if (b->size >= 0L) {
#line 633
        tmp___0 = b->size;
      } else {
#line 633
        tmp___0 = - b->size;
      }
#line 633
      if (tmp___0 == 0L) {
#line 634
        sign = 0;
      } else {
#line 636
        sign = (int )(a->size - b->size);
      }
    } else {
#line 636
      sign = (int )(a->size - b->size);
    }
  } else {
#line 638
    if (a->size >= 0L) {
#line 638
      tmp___1 = a->size;
    } else {
#line 638
      tmp___1 = - a->size;
    }
#line 638
    i = (int )tmp___1;
#line 639
    while (1) {
#line 639
      i --;
#line 639
      if (i >= 0) {
#line 639
        if (! ((*(a->d + i)) == (*(b->d + i)))) {
#line 639
          break;
        }
      } else {
#line 639
        break;
      }
    }
#line 640
    if (i < 0) {
#line 641
      sign = 0;
    } else {
#line 643
      sign = (int )(*(a->d + i)) - (int )(*(b->d + i));
#line 644
      if (a->size < 0L) {
#line 645
        sign = - sign;
      }
    }
  }
#line 648
  if (sign < 0) {
#line 648
    tmp___3 = -1;
  } else {
#line 648
    if (sign > 0) {
#line 648
      tmp___3 = 1;
    } else {
#line 648
      tmp___3 = 0;
    }
  }
#line 648
  return (tmp___3);
}
}
#line 653 "huge.c"
static Huge *x_add(Huge *a , Huge *b ) 
{ int size_a ;
  long tmp ;
  int size_b ;
  long tmp___0 ;
  Huge *z ;
  int i ;
  digit carry ;
  Huge *temp ;
  int size_temp ;
  Huge *tmp___1 ;

  {
#line 655
  if (a->size >= 0L) {
#line 655
    tmp = a->size;
  } else {
#line 655
    tmp = - a->size;
  }
#line 655
  size_a = (int )tmp;
#line 655
  if (b->size >= 0L) {
#line 655
    tmp___0 = b->size;
  } else {
#line 655
    tmp___0 = - b->size;
  }
#line 655
  size_b = (int )tmp___0;
#line 658
  carry = (digit )0;
#line 661
  if (size_a < size_b) {
#line 663
    temp = a;
#line 664
    a = b;
#line 665
    b = temp;
#line 668
    size_temp = size_a;
#line 669
    size_a = size_b;
#line 670
    size_b = size_temp;
  }
#line 673
  z = huge_new(size_a + 1);
#line 674
  i = 0;
#line 674
  while (i < size_b) {
#line 675
    carry += (*(a->d + i)) + (*(b->d + i));
#line 676
    (*(z->d + i)) = carry & 2147483647U;
#line 679
    carry >>= 31;
#line 674
    i ++;
  }
#line 681
  while (i < size_a) {
#line 682
    carry += (*(a->d + i));
#line 683
    (*(z->d + i)) = carry & 2147483647U;
#line 684
    carry >>= 31;
#line 681
    i ++;
  }
#line 686
  (*(z->d + i)) = carry;
#line 687
  tmp___1 = huge_normalize(z);
#line 687
  return (tmp___1);
}
}
#line 692 "huge.c"
static Huge *x_sub(Huge *a , Huge *b ) 
{ int size_a ;
  long tmp ;
  int size_b ;
  long tmp___0 ;
  Huge *z ;
  int i ;
  int sign ;
  digit borrow ;
  Huge *temp ;
  int size_temp ;
  Huge *tmp___1 ;
  Huge *temp___0 ;
  Huge *tmp___2 ;

  {
#line 694
  if (a->size >= 0L) {
#line 694
    tmp = a->size;
  } else {
#line 694
    tmp = - a->size;
  }
#line 694
  size_a = (int )tmp;
#line 694
  if (b->size >= 0L) {
#line 694
    tmp___0 = b->size;
  } else {
#line 694
    tmp___0 = - b->size;
  }
#line 694
  size_b = (int )tmp___0;
#line 697
  sign = 1;
#line 698
  borrow = (digit )0;
#line 701
  if (size_a < size_b) {
#line 702
    sign = -1;
#line 704
    temp = a;
#line 705
    a = b;
#line 706
    b = temp;
#line 709
    size_temp = size_a;
#line 710
    size_a = size_b;
#line 711
    size_b = size_temp;
  } else {
#line 713
    if (size_a == size_b) {
#line 715
      i = size_a;
#line 716
      while (1) {
#line 716
        i --;
#line 716
        if (i >= 0) {
#line 716
          if (! ((*(a->d + i)) == (*(b->d + i)))) {
#line 716
            break;
          }
        } else {
#line 716
          break;
        }
      }
#line 717
      if (i < 0) {
#line 718
        tmp___1 = huge_new(0);
#line 718
        return (tmp___1);
      }
#line 719
      if ((*(a->d + i)) < (*(b->d + i))) {
#line 720
        sign = -1;
#line 722
        temp___0 = a;
#line 723
        a = b;
#line 724
        b = temp___0;
      }
#line 727
      size_b = i + 1;
#line 727
      size_a = size_b;
    }
  }
#line 729
  z = huge_new(size_a);
#line 730
  i = 0;
#line 730
  while (i < size_b) {
#line 733
    borrow = ((*(a->d + i)) - (*(b->d + i))) - borrow;
#line 734
    (*(z->d + i)) = borrow & 2147483647U;
#line 735
    borrow >>= 31;
#line 736
    borrow &= 1U;
#line 730
    i ++;
  }
#line 738
  while (i < size_a) {
#line 739
    borrow = (*(a->d + i)) - borrow;
#line 740
    (*(z->d + i)) = borrow & 2147483647U;
#line 741
    borrow >>= 31;
#line 738
    i ++;
  }
#line 743
  if (! (borrow == 0U)) {
#line 743
    fprintf(__stderrp, "huge: assertion failed, %s:%d\n", "huge.c", 743);
#line 743
    abort();
  }
#line 744
  if (sign < 0) {
#line 745
    z->size = - z->size;
  }
#line 746
  tmp___2 = huge_normalize(z);
#line 746
  return (tmp___2);
}
}
#line 749 "huge.c"
Huge *huge_add(Huge *a , Huge *b ) 
{ Huge *z ;

  {
#line 753
  if (a->size < 0L) {
#line 754
    if (b->size < 0L) {
#line 755
      z = x_add(a, b);
#line 756
      if ((unsigned int )z != (unsigned int )((Huge *)0)) {
#line 756
        if (z->size != 0L) {
#line 757
          z->size = - z->size;
        }
      }
    } else {
#line 759
      z = x_sub(b, a);
    }
  } else {
#line 761
    if (b->size < 0L) {
#line 762
      z = x_sub(a, b);
    } else {
#line 764
      z = x_add(a, b);
    }
  }
#line 766
  return (z);
}
}
#line 769 "huge.c"
Huge *huge_sub(Huge *a , Huge *b ) 
{ Huge *z ;

  {
#line 773
  if (a->size < 0L) {
#line 774
    if (b->size < 0L) {
#line 775
      z = x_sub(a, b);
    } else {
#line 777
      z = x_add(a, b);
    }
#line 778
    if ((unsigned int )z != (unsigned int )((Huge *)0)) {
#line 778
      if (z->size != 0L) {
#line 779
        z->size = - z->size;
      }
    }
  } else {
#line 781
    if (b->size < 0L) {
#line 782
      z = x_add(a, b);
    } else {
#line 784
      z = x_sub(a, b);
    }
  }
#line 786
  return (z);
}
}
#line 789 "huge.c"
Huge *huge_mul(Huge *a , Huge *b ) 
{ int size_a ;
  int size_b ;
  Huge *z ;
  int i ;
  twodigits carry ;
  twodigits f___0 ;
  int j ;
  Huge *tmp ;

  {
#line 796
  if (a->size >= 0L) {
#line 796
    size_a = (int )a->size;
  } else {
#line 796
    size_a = (int )(- a->size);
  }
#line 797
  if (b->size >= 0L) {
#line 797
    size_b = (int )b->size;
  } else {
#line 797
    size_b = (int )(- b->size);
  }
#line 798
  z = huge_new(size_a + size_b);
#line 799
  i = 0;
#line 799
  while ((long )i < z->size) {
#line 800
    (*(z->d + i)) = 0U;
#line 799
    i ++;
  }
#line 801
  i = 0;
#line 801
  while (i < size_a) {
#line 802
    carry = (twodigits )0;
#line 803
    f___0 = (twodigits )(*(a->d + i));
#line 805
    j = 0;
#line 805
    while (j < size_b) {
#line 806
      carry += (twodigits )(*(z->d + (i + j))) + (twodigits )(*(b->d + j)) * f___0;
#line 807
      (*(z->d + (i + j))) = (unsigned int )(carry & 2147483647ULL);
#line 808
      carry >>= 31;
#line 805
      j ++;
    }
#line 810
    while (carry != 0ULL) {
#line 811
      if (! ((long )(i + j) < z->size)) {
#line 811
        fprintf(__stderrp, "huge: assertion failed, %s:%d\n", "huge.c", 811);
#line 811
        abort();
      }
#line 812
      carry += (twodigits )(*(z->d + (i + j)));
#line 813
      (*(z->d + (i + j))) = (unsigned int )(carry & 2147483647ULL);
#line 814
      carry >>= 31;
#line 810
      j ++;
    }
#line 801
    i ++;
  }
#line 817
  if (a->size < 0L) {
#line 818
    z->size = - z->size;
  }
#line 819
  if (b->size < 0L) {
#line 820
    z->size = - z->size;
  }
#line 821
  tmp = huge_normalize(z);
#line 821
  return (tmp);
}
}
#line 839 "huge.c"
static int l_divmod(Huge *v , Huge *w , Huge **pdiv , Huge **pmod ) 
{ Huge *divisor ;
  Huge *mod ;
  int tmp ;
  Huge *temp ;
  Huge *one ;
  Huge *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  Huge *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;

  {
#line 843
  tmp = _huge_divrem(v, w, & divisor, & mod);
#line 843
  if (tmp < 0) {
#line 844
    return (-1);
  }
#line 845
  if (mod->size < 0L) {
#line 845
    if (w->size > 0L) {
      goto _L;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 845
    if (mod->size > 0L) {
#line 845
      if (w->size < 0L) {
        _L: /* CIL Label */ 
#line 849
        tmp___0 = huge_add(mod, w);
#line 849
        temp = tmp___0;
#line 850
        if (mod) {
#line 850
          if (mod->size >= 0L) {
#line 850
            tmp___1 = mod->size;
          } else {
#line 850
            tmp___1 = - mod->size;
          }
#line 850
          memset((void *)mod, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___1);
#line 850
          free((void *)mod);
        }
#line 850
        mod = (Huge *)0;
#line 851
        mod = temp;
#line 852
        if ((unsigned int )mod == (unsigned int )((Huge *)0)) {
#line 853
          if (divisor) {
#line 853
            if (divisor->size >= 0L) {
#line 853
              tmp___2 = divisor->size;
            } else {
#line 853
              tmp___2 = - divisor->size;
            }
#line 853
            memset((void *)divisor, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___2);
#line 853
            free((void *)divisor);
          }
#line 853
          divisor = (Huge *)0;
#line 854
          return (-1);
        }
#line 856
        one = huge_from_long(1L);
#line 857
        tmp___6 = huge_sub(divisor, one);
#line 857
        temp = tmp___6;
#line 857
        if ((unsigned int )temp == (unsigned int )((Huge *)0)) {
#line 858
          if (mod) {
#line 858
            if (mod->size >= 0L) {
#line 858
              tmp___3 = mod->size;
            } else {
#line 858
              tmp___3 = - mod->size;
            }
#line 858
            memset((void *)mod, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___3);
#line 858
            free((void *)mod);
          }
#line 858
          mod = (Huge *)0;
#line 859
          if (divisor) {
#line 859
            if (divisor->size >= 0L) {
#line 859
              tmp___4 = divisor->size;
            } else {
#line 859
              tmp___4 = - divisor->size;
            }
#line 859
            memset((void *)divisor, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___4);
#line 859
            free((void *)divisor);
          }
#line 859
          divisor = (Huge *)0;
#line 860
          if (one) {
#line 860
            if (one->size >= 0L) {
#line 860
              tmp___5 = one->size;
            } else {
#line 860
              tmp___5 = - one->size;
            }
#line 860
            memset((void *)one, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___5);
#line 860
            free((void *)one);
          }
#line 860
          one = (Huge *)0;
#line 861
          return (-1);
        }
#line 863
        if (one) {
#line 863
          if (one->size >= 0L) {
#line 863
            tmp___7 = one->size;
          } else {
#line 863
            tmp___7 = - one->size;
          }
#line 863
          memset((void *)one, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___7);
#line 863
          free((void *)one);
        }
#line 863
        one = (Huge *)0;
#line 864
        if (divisor) {
#line 864
          if (divisor->size >= 0L) {
#line 864
            tmp___8 = divisor->size;
          } else {
#line 864
            tmp___8 = - divisor->size;
          }
#line 864
          memset((void *)divisor, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___8);
#line 864
          free((void *)divisor);
        }
#line 864
        divisor = (Huge *)0;
#line 865
        divisor = temp;
      }
    }
  }
#line 867
  (*pdiv) = divisor;
#line 868
  (*pmod) = mod;
#line 869
  return (0);
}
}
#line 872 "huge.c"
Huge *huge_div(Huge *v , Huge *w ) 
{ Huge *divisor ;
  Huge *mod ;
  int tmp ;
  long tmp___0 ;

  {
#line 875
  tmp = l_divmod(v, w, & divisor, & mod);
#line 875
  if (tmp < 0) {
#line 876
    return ((Huge *)0);
  }
#line 877
  if (mod) {
#line 877
    if (mod->size >= 0L) {
#line 877
      tmp___0 = mod->size;
    } else {
#line 877
      tmp___0 = - mod->size;
    }
#line 877
    memset((void *)mod, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___0);
#line 877
    free((void *)mod);
  }
#line 877
  mod = (Huge *)0;
#line 878
  return (divisor);
}
}
#line 881 "huge.c"
Huge *huge_mod(Huge *v , Huge *w ) 
{ Huge *divisor ;
  Huge *mod ;
  int tmp ;
  long tmp___0 ;

  {
#line 884
  tmp = l_divmod(v, w, & divisor, & mod);
#line 884
  if (tmp < 0) {
#line 885
    return ((Huge *)0);
  }
#line 886
  if (divisor) {
#line 886
    if (divisor->size >= 0L) {
#line 886
      tmp___0 = divisor->size;
    } else {
#line 886
      tmp___0 = - divisor->size;
    }
#line 886
    memset((void *)divisor, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___0);
#line 886
    free((void *)divisor);
  }
#line 886
  divisor = (Huge *)0;
#line 887
  return (mod);
}
}
#line 890 "huge.c"
Huge *huge_divmod(Huge *v , Huge *w , Huge **remainder ) 
{ Huge *divisor ;
  Huge *mod ;
  int tmp ;

  {
#line 893
  tmp = l_divmod(v, w, & divisor, & mod);
#line 893
  if (tmp < 0) {
#line 894
    return ((Huge *)0);
  }
#line 895
  if (remainder) {
#line 896
    (*remainder) = mod;
  }
#line 897
  return (divisor);
}
}
#line 900 "huge.c"
Huge *huge_powmod(Huge *a , Huge *b , Huge *c ) 
{ Huge *z ;
  Huge *divisor ;
  Huge *mod ;
  int size_b ;
  int i ;
  Huge *tmp ;
  digit bi ;
  int j ;
  Huge *temp ;
  Huge *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  Huge *tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;

  {
#line 902
  z = (Huge *)0;
#line 902
  divisor = (Huge *)0;
#line 902
  mod = (Huge *)0;
#line 905
  a = huge_dup(a);
#line 906
  size_b = (int )b->size;
#line 907
  if (size_b < 0) {
#line 908
    fprintf(__stderrp, "huge_%s\n", "pow(): long integer to the negative power");
#line 909
    return ((Huge *)0);
  }
#line 911
  tmp = huge_from_long(1L);
#line 911
  z = tmp;
#line 912
  i = 0;
#line 912
  while (i < size_b) {
#line 913
    bi = (*(b->d + i));
#line 916
    j = 0;
#line 916
    while (j < 31) {
#line 917
      temp = (Huge *)0;
#line 919
      if (bi & 1U) {
#line 920
        tmp___0 = huge_mul(z, a);
#line 920
        temp = tmp___0;
#line 921
        if (z) {
#line 921
          if (z->size >= 0L) {
#line 921
            tmp___1 = z->size;
          } else {
#line 921
            tmp___1 = - z->size;
          }
#line 921
          memset((void *)z, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___1);
#line 921
          free((void *)z);
        }
#line 921
        z = (Huge *)0;
#line 922
        if ((unsigned int )c != (unsigned int )((Huge *)0)) {
#line 922
          if ((unsigned int )temp != (unsigned int )((Huge *)0)) {
#line 923
            l_divmod(temp, c, & divisor, & mod);
#line 924
            if (divisor) {
#line 924
              if (divisor->size >= 0L) {
#line 924
                tmp___2 = divisor->size;
              } else {
#line 924
                tmp___2 = - divisor->size;
              }
#line 924
              memset((void *)divisor, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___2);
#line 924
              free((void *)divisor);
            }
#line 924
            divisor = (Huge *)0;
#line 925
            if (temp) {
#line 925
              if (temp->size >= 0L) {
#line 925
                tmp___3 = temp->size;
              } else {
#line 925
                tmp___3 = - temp->size;
              }
#line 925
              memset((void *)temp, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___3);
#line 925
              free((void *)temp);
            }
#line 925
            temp = (Huge *)0;
#line 926
            temp = mod;
          }
        }
#line 928
        z = temp;
#line 929
        if ((unsigned int )z == (unsigned int )((Huge *)0)) {
#line 930
          break;
        }
      }
#line 932
      bi >>= 1;
#line 933
      if (bi == 0U) {
#line 933
        if (i + 1 == size_b) {
#line 934
          break;
        }
      }
#line 935
      tmp___4 = huge_mul(a, a);
#line 935
      temp = tmp___4;
#line 936
      if (a) {
#line 936
        if (a->size >= 0L) {
#line 936
          tmp___5 = a->size;
        } else {
#line 936
          tmp___5 = - a->size;
        }
#line 936
        memset((void *)a, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___5);
#line 936
        free((void *)a);
      }
#line 936
      a = (Huge *)0;
#line 937
      if ((unsigned int )c != (unsigned int )((Huge *)0)) {
#line 937
        if ((unsigned int )temp != (unsigned int )((Huge *)0)) {
#line 938
          l_divmod(temp, c, & divisor, & mod);
#line 939
          if (divisor) {
#line 939
            if (divisor->size >= 0L) {
#line 939
              tmp___6 = divisor->size;
            } else {
#line 939
              tmp___6 = - divisor->size;
            }
#line 939
            memset((void *)divisor, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___6);
#line 939
            free((void *)divisor);
          }
#line 939
          divisor = (Huge *)0;
#line 940
          if (temp) {
#line 940
            if (temp->size >= 0L) {
#line 940
              tmp___7 = temp->size;
            } else {
#line 940
              tmp___7 = - temp->size;
            }
#line 940
            memset((void *)temp, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___7);
#line 940
            free((void *)temp);
          }
#line 940
          temp = (Huge *)0;
#line 941
          temp = mod;
        }
      }
#line 943
      a = temp;
#line 944
      if ((unsigned int )a == (unsigned int )((Huge *)0)) {
#line 945
        if (z) {
#line 945
          if (z->size >= 0L) {
#line 945
            tmp___8 = z->size;
          } else {
#line 945
            tmp___8 = - z->size;
          }
#line 945
          memset((void *)z, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___8);
#line 945
          free((void *)z);
        }
#line 945
        z = (Huge *)0;
#line 946
        z = (Huge *)0;
#line 947
        break;
      }
#line 916
      j ++;
    }
#line 950
    if ((unsigned int )a == (unsigned int )((Huge *)0)) {
#line 951
      break;
    } else {
#line 950
      if ((unsigned int )z == (unsigned int )((Huge *)0)) {
#line 951
        break;
      }
    }
#line 912
    i ++;
  }
#line 953
  if (a) {
#line 953
    if (a->size >= 0L) {
#line 953
      tmp___9 = a->size;
    } else {
#line 953
      tmp___9 = - a->size;
    }
#line 953
    memset((void *)a, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___9);
#line 953
    free((void *)a);
  }
#line 953
  a = (Huge *)0;
#line 954
  if ((unsigned int )c != (unsigned int )((Huge *)0)) {
#line 954
    if ((unsigned int )z != (unsigned int )((Huge *)0)) {
#line 955
      l_divmod(z, c, & divisor, & mod);
#line 956
      if (divisor) {
#line 956
        if (divisor->size >= 0L) {
#line 956
          tmp___10 = divisor->size;
        } else {
#line 956
          tmp___10 = - divisor->size;
        }
#line 956
        memset((void *)divisor, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___10);
#line 956
        free((void *)divisor);
      }
#line 956
      divisor = (Huge *)0;
#line 957
      if (z) {
#line 957
        if (z->size >= 0L) {
#line 957
          tmp___11 = z->size;
        } else {
#line 957
          tmp___11 = - z->size;
        }
#line 957
        memset((void *)z, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___11);
#line 957
        free((void *)z);
      }
#line 957
      z = (Huge *)0;
#line 958
      z = mod;
    }
  }
#line 960
  return (z);
}
}
#line 963 "huge.c"
Huge *huge_pow(Huge *a , Huge *b ) 
{ Huge *tmp ;

  {
#line 965
  tmp = huge_powmod(a, b, (Huge *)0);
#line 965
  return (tmp);
}
}
#line 968 "huge.c"
Huge *huge_invert(Huge *v ) 
{ Huge *x ;
  Huge *w ;
  Huge *tmp ;
  Huge *tmp___0 ;
  long tmp___1 ;

  {
#line 973
  tmp = huge_from_long(1L);
#line 973
  w = tmp;
#line 974
  if ((unsigned int )w == (unsigned int )((Huge *)0)) {
#line 975
    return ((Huge *)0);
  }
#line 976
  tmp___0 = huge_add(v, w);
#line 976
  x = tmp___0;
#line 977
  if (w) {
#line 977
    if (w->size >= 0L) {
#line 977
      tmp___1 = w->size;
    } else {
#line 977
      tmp___1 = - w->size;
    }
#line 977
    memset((void *)w, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___1);
#line 977
    free((void *)w);
  }
#line 977
  w = (Huge *)0;
#line 978
  if ((unsigned int )x == (unsigned int )((Huge *)0)) {
#line 979
    return ((Huge *)0);
  }
#line 980
  if (x->size != 0L) {
#line 981
    x->size = - x->size;
  }
#line 982
  return (x);
}
}
#line 985 "huge.c"
Huge *huge_neg(Huge *v ) 
{ Huge *z ;
  int i ;
  int n ;
  Huge *tmp ;

  {
#line 989
  if (v->size >= 0L) {
#line 989
    n = (int )v->size;
  } else {
#line 989
    n = (int )(- v->size);
  }
#line 991
  if (! n) {
#line 992
    tmp = huge_dup(v);
#line 992
    return (tmp);
  }
#line 993
  z = huge_new(n);
#line 994
  i = 0;
#line 994
  while (i < n) {
#line 995
    (*(z->d + i)) = (*(v->d + i));
#line 994
    i ++;
  }
#line 996
  z->size = - v->size;
#line 997
  return (z);
}
}
#line 1000 "huge.c"
Huge *huge_abs(Huge *v ) 
{ Huge *tmp ;
  Huge *tmp___0 ;

  {
#line 1002
  if (v->size < 0L) {
#line 1003
    tmp = huge_neg(v);
#line 1003
    return (tmp);
  } else {
#line 1005
    tmp___0 = huge_dup(v);
#line 1005
    return (tmp___0);
  }
}
}
#line 1008 "huge.c"
int huge_nonzero(Huge *v ) 
{ 

  {
#line 1010
  if (! v) {
#line 1011
    return (0);
  }
#line 1012
  return (v->size != 0L);
}
}
#line 1015 "huge.c"
Huge *huge_rshift(Huge *a , int shiftby ) 
{ Huge *z ;
  int newsize ;
  int wordshift ;
  int loshift ;
  int hishift ;
  int i ;
  int j ;
  digit lomask ;
  digit himask ;
  Huge *a1 ;
  Huge *a2 ;
  Huge *a3 ;
  Huge *tmp ;
  Huge *tmp___0 ;
  long tmp___1 ;
  Huge *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  Huge *tmp___5 ;

  {
#line 1021
  if (a->size < 0L) {
#line 1024
    tmp = huge_invert(a);
#line 1024
    a1 = tmp;
#line 1025
    if ((unsigned int )a1 == (unsigned int )((Huge *)0)) {
#line 1026
      return ((Huge *)0);
    }
#line 1027
    tmp___0 = huge_rshift(a1, shiftby);
#line 1027
    a2 = tmp___0;
#line 1028
    if (a1) {
#line 1028
      if (a1->size >= 0L) {
#line 1028
        tmp___1 = a1->size;
      } else {
#line 1028
        tmp___1 = - a1->size;
      }
#line 1028
      memset((void *)a1, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___1);
#line 1028
      free((void *)a1);
    }
#line 1028
    a1 = (Huge *)0;
#line 1029
    if ((unsigned int )a2 == (unsigned int )((Huge *)0)) {
#line 1030
      return ((Huge *)0);
    }
#line 1031
    tmp___2 = huge_invert(a2);
#line 1031
    a3 = tmp___2;
#line 1032
    if (a2) {
#line 1032
      if (a2->size >= 0L) {
#line 1032
        tmp___3 = a2->size;
      } else {
#line 1032
        tmp___3 = - a2->size;
      }
#line 1032
      memset((void *)a2, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___3);
#line 1032
      free((void *)a2);
    }
#line 1032
    a2 = (Huge *)0;
#line 1033
    return (a3);
  }
#line 1035
  if (shiftby < 0) {
#line 1036
    fprintf(__stderrp, "huge_%s\n", "rshift(): negative shift count");
#line 1037
    return ((Huge *)0);
  }
#line 1039
  wordshift = shiftby / 31;
#line 1040
  if (a->size >= 0L) {
#line 1040
    tmp___4 = a->size;
  } else {
#line 1040
    tmp___4 = - a->size;
  }
#line 1040
  newsize = (int )(tmp___4 - (long )wordshift);
#line 1041
  if (newsize <= 0) {
#line 1042
    z = huge_new(0);
#line 1043
    return (z);
  }
#line 1045
  loshift = shiftby % 31;
#line 1046
  hishift = 31 - loshift;
#line 1047
  lomask = (1U << hishift) - 1U;
#line 1048
  himask = 2147483647U ^ lomask;
#line 1049
  z = huge_new(newsize);
#line 1050
  if (a->size < 0L) {
#line 1051
    z->size = - z->size;
  }
#line 1052
  i = 0;
#line 1052
  j = wordshift;
#line 1052
  while (i < newsize) {
#line 1053
    (*(z->d + i)) = ((*(a->d + j)) >> loshift) & lomask;
#line 1054
    if (i + 1 < newsize) {
#line 1055
      (*(z->d + i)) |= ((*(a->d + (j + 1))) << hishift) & himask;
    }
#line 1052
    i ++;
#line 1052
    j ++;
  }
#line 1058
  tmp___5 = huge_normalize(z);
#line 1058
  return (tmp___5);
}
}
#line 1061 "huge.c"
Huge *huge_lshift(Huge *a , int shiftby ) 
{ Huge *z ;
  int oldsize ;
  int newsize ;
  int wordshift ;
  int remshift ;
  int i ;
  int j ;
  twodigits accum ;
  Huge *tmp ;

  {
#line 1068
  if (shiftby < 0) {
#line 1069
    fprintf(__stderrp, "huge_%s\n", "lshift(): negative shift count");
#line 1070
    return ((Huge *)0);
  }
#line 1073
  wordshift = shiftby / 31;
#line 1074
  remshift = shiftby - wordshift * 31;
#line 1076
  if (a->size >= 0L) {
#line 1076
    oldsize = (int )a->size;
  } else {
#line 1076
    oldsize = (int )(- a->size);
  }
#line 1077
  newsize = oldsize + wordshift;
#line 1078
  if (remshift) {
#line 1079
    newsize ++;
  }
#line 1080
  z = huge_new(newsize);
#line 1081
  if (a->size < 0L) {
#line 1082
    z->size = - z->size;
  }
#line 1083
  i = 0;
#line 1083
  while (i < wordshift) {
#line 1084
    (*(z->d + i)) = 0U;
#line 1083
    i ++;
  }
#line 1085
  accum = 0ULL;
#line 1086
  i = wordshift;
#line 1086
  j = 0;
#line 1086
  while (j < oldsize) {
#line 1087
    accum |= (unsigned long long )((*(a->d + j)) << remshift);
#line 1088
    (*(z->d + i)) = (unsigned int )(accum & 2147483647ULL);
#line 1089
    accum >>= 31;
#line 1086
    i ++;
#line 1086
    j ++;
  }
#line 1091
  if (remshift) {
#line 1092
    (*(z->d + (newsize - 1))) = (unsigned int )accum;
  } else {
#line 1094
    if (! (! accum)) {
#line 1094
      fprintf(__stderrp, "huge: assertion failed, %s:%d\n", "huge.c", 1094);
#line 1094
      abort();
    }
  }
#line 1095
  tmp = huge_normalize(z);
#line 1095
  return (tmp);
}
}
#line 1102 "huge.c"
static Huge *huge_bitwise(Huge *a , int op , Huge *b ) 
{ digit maska ;
  digit maskb ;
  int negz ;
  int size_a ;
  int size_b ;
  int size_z ;
  Huge *z ;
  int i ;
  digit diga ;
  digit digb ;
  Huge *v ;
  Huge *tmp ;
  Huge *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  digit tmp___4 ;
  digit tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;

  {
#line 1112
  if (a->size < 0L) {
#line 1113
    tmp = huge_invert(a);
#line 1113
    a = tmp;
#line 1114
    maska = 2147483647U;
  } else {
#line 1116
    a = huge_dup(a);
#line 1117
    maska = 0U;
  }
#line 1119
  if (b->size < 0L) {
#line 1120
    tmp___0 = huge_invert(b);
#line 1120
    b = tmp___0;
#line 1121
    maskb = 2147483647U;
  } else {
#line 1123
    b = huge_dup(b);
#line 1124
    maskb = 0U;
  }
#line 1127
  size_a = (int )a->size;
#line 1128
  size_b = (int )b->size;
#line 1129
  if (size_a < size_b) {
#line 1129
    size_z = size_b;
  } else {
#line 1129
    size_z = size_a;
  }
#line 1130
  z = huge_new(size_z);
#line 1131
  if ((unsigned int )a == (unsigned int )((Huge *)0)) {
    goto _L;
  } else {
#line 1131
    if ((unsigned int )b == (unsigned int )((Huge *)0)) {
      _L: /* CIL Label */ 
#line 1132
      if (a) {
#line 1132
        if (a->size >= 0L) {
#line 1132
          tmp___1 = a->size;
        } else {
#line 1132
          tmp___1 = - a->size;
        }
#line 1132
        memset((void *)a, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___1);
#line 1132
        free((void *)a);
      }
#line 1132
      a = (Huge *)0;
#line 1133
      if (b) {
#line 1133
        if (b->size >= 0L) {
#line 1133
          tmp___2 = b->size;
        } else {
#line 1133
          tmp___2 = - b->size;
        }
#line 1133
        memset((void *)b, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___2);
#line 1133
        free((void *)b);
      }
#line 1133
      b = (Huge *)0;
#line 1134
      if (z) {
#line 1134
        if (z->size >= 0L) {
#line 1134
          tmp___3 = z->size;
        } else {
#line 1134
          tmp___3 = - z->size;
        }
#line 1134
        memset((void *)z, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___3);
#line 1134
        free((void *)z);
      }
#line 1134
      z = (Huge *)0;
#line 1135
      return ((Huge *)0);
    }
  }
#line 1137
  negz = 0;
#line 1138
  switch (op) {
  case 94: 
#line 1140
  if (maska != maskb) {
#line 1141
    maska ^= 2147483647U;
#line 1142
    negz = -1;
  }
#line 1144
  break;
  case 38: 
#line 1146
  if (maska) {
#line 1146
    if (maskb) {
#line 1147
      op = '|';
#line 1148
      maska ^= 2147483647U;
#line 1149
      maskb ^= 2147483647U;
#line 1150
      negz = -1;
    }
  }
#line 1152
  break;
  case 124: 
#line 1154
  if (maska) {
#line 1155
    op = '&';
#line 1156
    maska ^= 2147483647U;
#line 1157
    maskb ^= 2147483647U;
#line 1158
    negz = -1;
  } else {
#line 1154
    if (maskb) {
#line 1155
      op = '&';
#line 1156
      maska ^= 2147483647U;
#line 1157
      maskb ^= 2147483647U;
#line 1158
      negz = -1;
    }
  }
#line 1160
  break;
  }
#line 1163
  i = 0;
#line 1163
  while (i < size_z) {
#line 1164
    if (i < size_a) {
#line 1164
      tmp___4 = (*(a->d + i));
    } else {
#line 1164
      tmp___4 = 0U;
    }
#line 1164
    diga = tmp___4 ^ maska;
#line 1165
    if (i < size_b) {
#line 1165
      tmp___5 = (*(b->d + i));
    } else {
#line 1165
      tmp___5 = 0U;
    }
#line 1165
    digb = tmp___5 ^ maskb;
#line 1166
    switch (op) {
    case 38: 
#line 1168
    (*(z->d + i)) = diga & digb;
#line 1169
    break;
    case 124: 
#line 1171
    (*(z->d + i)) = diga | digb;
#line 1172
    break;
    case 94: 
#line 1174
    (*(z->d + i)) = diga ^ digb;
#line 1175
    break;
    }
#line 1163
    i ++;
  }
#line 1179
  if (a) {
#line 1179
    if (a->size >= 0L) {
#line 1179
      tmp___6 = a->size;
    } else {
#line 1179
      tmp___6 = - a->size;
    }
#line 1179
    memset((void *)a, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___6);
#line 1179
    free((void *)a);
  }
#line 1179
  a = (Huge *)0;
#line 1180
  if (b) {
#line 1180
    if (b->size >= 0L) {
#line 1180
      tmp___7 = b->size;
    } else {
#line 1180
      tmp___7 = - b->size;
    }
#line 1180
    memset((void *)b, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___7);
#line 1180
    free((void *)b);
  }
#line 1180
  b = (Huge *)0;
#line 1181
  z = huge_normalize(z);
#line 1182
  if (negz == 0) {
#line 1183
    return (z);
  }
#line 1184
  v = huge_invert(z);
#line 1185
  if (z) {
#line 1185
    if (z->size >= 0L) {
#line 1185
      tmp___8 = z->size;
    } else {
#line 1185
      tmp___8 = - z->size;
    }
#line 1185
    memset((void *)z, 0, (unsigned long )sizeof(Huge ) + (unsigned long )sizeof(digit ) * (unsigned long )tmp___8);
#line 1185
    free((void *)z);
  }
#line 1185
  z = (Huge *)0;
#line 1186
  return (v);
}
}
#line 1189 "huge.c"
Huge *huge_and(Huge *a , Huge *b ) 
{ Huge *tmp ;

  {
#line 1191
  tmp = huge_bitwise(a, '&', b);
#line 1191
  return (tmp);
}
}
#line 1194 "huge.c"
Huge *huge_xor(Huge *a , Huge *b ) 
{ Huge *tmp ;

  {
#line 1196
  tmp = huge_bitwise(a, '^', b);
#line 1196
  return (tmp);
}
}
#line 1199 "huge.c"
Huge *huge_or(Huge *a , Huge *b ) 
{ Huge *tmp ;

  {
#line 1201
  tmp = huge_bitwise(a, '|', b);
#line 1201
  return (tmp);
}
}
#line 1204 "huge.c"
char *huge_oct(Huge *v ) 
{ char *tmp ;

  {
#line 1206
  tmp = huge_format(v, 8);
#line 1206
  return (tmp);
}
}
#line 1209 "huge.c"
char *huge_hex(Huge *v ) 
{ char *tmp ;

  {
#line 1211
  tmp = huge_format(v, 16);
#line 1211
  return (tmp);
}
}
#line 1214 "huge.c"
char *huge_dec(Huge *v ) 
{ char *tmp ;

  {
#line 1216
  tmp = huge_format(v, 10);
#line 1216
  return (tmp);
}
}
#line 1221 "huge.c"
static FILE *f  =    (FILE *)0;
#line 1219 "huge.c"
void xhuge_log(Huge *h , char *msg , char *file , int line ) 
{ char *p ;

  {
#line 1222
  p = (char *)0;
#line 1223
  if (! f) {
#line 1224
    f = fopen("huge.log", "w");
  }
#line 1225
  p = huge_hex(h);
#line 1225
  fprintf(f, "%s: %d:\n%s: %s\n", file, line, msg, p);
#line 1226
  fflush(f);
#line 1227
  if (p) {
#line 1228
    free((void *)p);
  }
#line 1229
  return;
}
}
