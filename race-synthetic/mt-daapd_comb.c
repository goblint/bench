/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i486-linux-gnu/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 137 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 146 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 28 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024U / (8U * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 39 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_attr_t_4 {
   char __size[36] ;
   long __align ;
};
#line 39 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_attr_t_4 pthread_attr_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 75 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 176 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 182 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 267 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 63 "/usr/include/sys/wait.h"
union wait;
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_61 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_62 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_61 __wait_terminated ;
   struct __anonstruct___wait_stopped_62 __wait_stopped ;
};
#line 37 "daapd.h"
struct tag_stats {
   time_t start_time ;
   int songs_served ;
   unsigned int gb_served ;
   unsigned int bytes_served ;
};
#line 37 "daapd.h"
typedef struct tag_stats STATS;
#line 46 "daapd.h"
struct tag_config {
   int use_mdns ;
   int stop ;
   int reload ;
   char *configfile ;
   char *iface ;
   char *web_root ;
   int port ;
   int rescan_interval ;
   int always_scan ;
   int process_m3u ;
   int scan_type ;
   int compress ;
   int pid ;
   char *adminpassword ;
   char *readpassword ;
   char *mp3dir ;
   char *servername ;
   char *playlist ;
   char *runas ;
   char *dbdir ;
   char *extensions ;
   char *artfilename ;
   char *logfile ;
   STATS stats ;
};
#line 46 "daapd.h"
typedef struct tag_config CONFIG;
#line 37 "webserver.h"
typedef void *WSHANDLE;
#line 39 "webserver.h"
struct tag_wsconfig {
   char *web_root ;
   char *id ;
   unsigned short port ;
};
#line 39 "webserver.h"
typedef struct tag_wsconfig WSCONFIG;
#line 45 "webserver.h"
struct tag_arglist {
   char *key ;
   char *value ;
   struct tag_arglist *next ;
};
#line 45 "webserver.h"
typedef struct tag_arglist ARGLIST;
#line 51 "webserver.h"
struct tag_ws_conninfo {
   WSHANDLE pwsp ;
   int threadno ;
   int error ;
   int fd ;
   int request_type ;
   char *uri ;
   char *hostname ;
   int close ;
   ARGLIST request_headers ;
   ARGLIST response_headers ;
   ARGLIST request_vars ;
};
#line 51 "webserver.h"
typedef struct tag_ws_conninfo WS_CONNINFO;
#line 27 "mp3-scanner.h"
struct tag_mp3file {
   char *path ;
   char *fname ;
   char *title ;
   char *artist ;
   char *album ;
   char *genre ;
   char *comment ;
   char *type ;
   char *composer ;
   char *orchestra ;
   char *conductor ;
   char *grouping ;
   char *url ;
   int bitrate ;
   int samplerate ;
   int song_length ;
   int file_size ;
   int year ;
   int track ;
   int total_tracks ;
   int disc ;
   int total_discs ;
   int time_added ;
   int time_modified ;
   int time_played ;
   int db_timestamp ;
   int bpm ;
   int got_id3 ;
   unsigned long id ;
   char *description ;
   int item_kind ;
   int data_kind ;
   char compilation ;
};
#line 27 "mp3-scanner.h"
typedef struct tag_mp3file MP3FILE;
#line 32 "daap-proto.h"
struct gzip_stream_tag {
   int bytes_in ;
   int bytes_out ;
   int in_size ;
   char *in ;
   char *out ;
};
#line 32 "daap-proto.h"
typedef struct gzip_stream_tag GZIP_STREAM;
#line 45 "daap-proto.h"
struct daap_block_tag {
   char tag[4] ;
   int reported_size ;
   int size ;
   int free ;
   char *value ;
   char svalue[4] ;
   struct daap_block_tag *parent ;
   struct daap_block_tag *children ;
   struct daap_block_tag *last_child ;
   struct daap_block_tag *next ;
};
#line 45 "daap-proto.h"
typedef struct daap_block_tag DAAP_BLOCK;
#line 148 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 154 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 195 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_4 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_5 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_6 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_7 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_8 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_9 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_3 {
   int _pad[128U / sizeof(int ) - 3U] ;
   struct __anonstruct__kill_4 _kill ;
   struct __anonstruct__timer_5 _timer ;
   struct __anonstruct__rt_6 _rt ;
   struct __anonstruct__sigchld_7 _sigchld ;
   struct __anonstruct__sigfault_8 _sigfault ;
   struct __anonstruct__sigpoll_9 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_3 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_21 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_21 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 243 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_38 {
   __fd_mask __fds_bits[1024U / (8U * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_38 fd_set;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 96 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 40 "uici.h"
typedef unsigned short u_port_t;
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 46 "/usr/include/bits/pthreadtypes.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 46 "/usr/include/bits/pthreadtypes.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 54 "/usr/include/bits/pthreadtypes.h"
union __anonunion____missing_field_name_7 {
   int __spins ;
   __pthread_slist_t __list ;
};
#line 54 "/usr/include/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   int __kind ;
   unsigned int __nusers ;
   union __anonunion____missing_field_name_7 __annonCompField1 ;
};
#line 54 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_6 {
   struct __pthread_mutex_s __data ;
   char __size[24] ;
   long __align ;
};
#line 54 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_6 pthread_mutex_t;
#line 75 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_8 {
   char __size[4] ;
   long __align ;
};
#line 75 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_8 pthread_mutexattr_t;
#line 84 "/usr/include/bits/pthreadtypes.h"
struct __anonstruct___data_10 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
#line 84 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_9 {
   struct __anonstruct___data_10 __data ;
   char __size[48] ;
   long long __align ;
};
#line 84 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_9 pthread_cond_t;
#line 101 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_condattr_t_11 {
   char __size[4] ;
   long __align ;
};
#line 101 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_condattr_t_11 pthread_condattr_t;
#line 134 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 44 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 343 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 407 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 410 "/usr/include/regex.h"
typedef int regoff_t;
#line 434 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_29 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 434 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_29 regmatch_t;
#line 43 "/usr/lib/gcc/i486-linux-gnu/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i486-linux-gnu/4.1.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 58 "webserver.c"
struct tag_ws_handler {
   regex_t regex ;
   void (*req_handler)(WS_CONNINFO * ) ;
   int (*auth_handler)(char * , char * ) ;
   int addheaders ;
   struct tag_ws_handler *next ;
};
#line 58 "webserver.c"
typedef struct tag_ws_handler WS_HANDLER;
#line 66 "webserver.c"
struct tag_ws_connlist {
   WS_CONNINFO *pwsc ;
   char *status ;
   struct tag_ws_connlist *next ;
};
#line 66 "webserver.c"
typedef struct tag_ws_connlist WS_CONNLIST;
#line 72 "webserver.c"
struct tag_ws_private {
   WSCONFIG wsconfig ;
   WS_HANDLER handlers ;
   WS_CONNLIST connlist ;
   int server_fd ;
   int stop ;
   int running ;
   int threadno ;
   int dispatch_threads ;
   pthread_t server_tid ;
   pthread_cond_t exit_cond ;
   pthread_mutex_t exit_mutex ;
};
#line 72 "webserver.c"
typedef struct tag_ws_private WS_PRIVATE;
#line 89 "configfile.c"
struct tag_configelement {
   int config_element ;
   int required ;
   int changed ;
   int type ;
   char *name ;
   void *var ;
   void (*emit)(WS_CONNINFO * , void * , char * ) ;
};
#line 89 "configfile.c"
typedef struct tag_configelement CONFIGELEMENT;
#line 139 "configfile.c"
struct tag_scan_status {
   int session ;
   int thread ;
   char *what ;
   char *host ;
   struct tag_scan_status *next ;
};
#line 139 "configfile.c"
typedef struct tag_scan_status SCAN_STATUS;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 261 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 263 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 264 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 270 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 279 "/usr/include/zconf.h"
typedef void *voidpf;
#line 80 "/usr/include/zlib.h"
struct internal_state;
#line 82 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 82 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 103 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1350 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 27 "db-memory.h"
typedef void *ENUMHANDLE;
#line 4 "query.h"
enum __anonenum_query_type_t_29 {
    qot_empty = 0,
    qot_and = 1,
    qot_or = 2,
    qot_not = 3,
    qot_eq = 4,
    qot_ne = 5,
    qot_le = 6,
    qot_lt = 7,
    qot_ge = 8,
    qot_gt = 9,
    qot_is = 10,
    qot_begins = 11,
    qot_ends = 12,
    qot_contains = 13,
    qot_const = 14,
    qft_i32 = 15,
    qft_i64 = 16,
    qft_string = 17
} ;
#line 4 "query.h"
typedef enum __anonenum_query_type_t_29 query_type_t;
#line 40
struct query_field_;
#line 40 "query.h"
typedef struct query_field_ query_field_t;
#line 41 "query.h"
struct query_field_ {
   query_type_t type ;
   char const   *name ;
   int offset ;
};
#line 48
struct query_node_;
#line 48 "query.h"
typedef struct query_node_ query_node_t;
#line 49 "query.h"
union __anonunion_left_30 {
   query_node_t *node ;
   query_field_t const   *field ;
   int constant ;
};
#line 49 "query.h"
union __anonunion_right_31 {
   query_node_t *node ;
   int i32 ;
   long long i64 ;
   char *str ;
};
#line 49 "query.h"
struct query_node_ {
   query_type_t type ;
   union __anonunion_left_30 left ;
   union __anonunion_right_31 right ;
};
#line 45 "daap.c"
struct tag_daap_items {
   int type ;
   char *tag ;
   char *description ;
};
#line 45 "daap.c"
typedef struct tag_daap_items DAAP_ITEMS;
#line 262
enum __anonenum_MetaFieldName_t_32 {
    metaItemId = 0,
    metaItemName = 1,
    metaItemKind = 2,
    metaPersistentId = 3,
    metaContainerItemId = 4,
    metaParentContainerId = 5,
    firstTypeSpecificMetaId = 6,
    metaSongAlbum = 6,
    metaSongArtist = 7,
    metaSongBPM = 8,
    metaSongBitRate = 9,
    metaSongComment = 10,
    metaSongCompilation = 11,
    metaSongComposer = 12,
    metaSongDataKind = 13,
    metaSongDataURL = 14,
    metaSongDateAdded = 15,
    metaSongDateModified = 16,
    metaSongDescription = 17,
    metaSongDisabled = 18,
    metaSongDiscCount = 19,
    metaSongDiscNumber = 20,
    metaSongEqPreset = 21,
    metaSongFormat = 22,
    metaSongGenre = 23,
    metaSongGrouping = 24,
    metaSongRelativeVolume = 25,
    metaSongSampleRate = 26,
    metaSongSize = 27,
    metaSongStartTime = 28,
    metaSongStopTime = 29,
    metaSongTime = 30,
    metaSongTrackCount = 31,
    metaSongTrackNumber = 32,
    metaSongUserRating = 33,
    metaSongYear = 34
} ;
#line 262 "daap.c"
typedef enum __anonenum_MetaFieldName_t_32 MetaFieldName_t;
#line 306 "daap.c"
struct __anonstruct_MetaDataMap_33 {
   char const   *tag ;
   MetaFieldName_t bit ;
};
#line 306 "daap.c"
typedef struct __anonstruct_MetaDataMap_33 MetaDataMap;
#line 357 "daap.c"
typedef unsigned long long MetaField_t;
#line 1088
struct _browse_item;
#line 1088 "daap.c"
typedef struct _browse_item browse_item;
#line 1089 "daap.c"
struct _browse_item {
   char *name ;
   browse_item *next ;
};
#line 56 "/usr/include/gdbm.h"
struct __anonstruct_datum_1 {
   char *dptr ;
   int dsize ;
};
#line 56 "/usr/include/gdbm.h"
typedef struct __anonstruct_datum_1 datum;
#line 63 "/usr/include/gdbm.h"
struct __anonstruct_GDBM_FILE_2 {
   int dummy[10] ;
};
#line 63 "/usr/include/gdbm.h"
typedef struct __anonstruct_GDBM_FILE_2 *GDBM_FILE;
#line 113 "/usr/include/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 119 "/usr/include/bits/pthreadtypes.h"
struct __anonstruct___data_14 {
   int __lock ;
   unsigned int __nr_readers ;
   unsigned int __readers_wakeup ;
   unsigned int __writer_wakeup ;
   unsigned int __nr_readers_queued ;
   unsigned int __nr_writers_queued ;
   unsigned int __flags ;
   int __writer ;
};
#line 119 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_rwlock_t_13 {
   struct __anonstruct___data_14 __data ;
   char __size[32] ;
   long __align ;
};
#line 119 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlock_t_13 pthread_rwlock_t;
#line 138 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_rwlockattr_t_15 {
   char __size[8] ;
   long __align ;
};
#line 138 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlockattr_t_15 pthread_rwlockattr_t;
#line 74 "redblack.h"
struct rbnode;
#line 81 "redblack.h"
struct rbtree {
   int (*rb_cmp)(void const   * , void const   * , void const   * ) ;
   void const   *rb_config ;
   struct rbnode *rb_root ;
};
#line 66 "db-gdbm.c"
struct tag_mp3record;
#line 66 "db-gdbm.c"
typedef struct tag_mp3record MP3RECORD;
#line 67 "db-gdbm.c"
struct tag_mp3record {
   MP3FILE mp3file ;
   MP3RECORD *next ;
};
#line 72 "db-gdbm.c"
struct tag_playlistentry {
   unsigned long id ;
   struct tag_playlistentry *next ;
};
#line 72 "db-gdbm.c"
typedef struct tag_playlistentry DB_PLAYLISTENTRY;
#line 77 "db-gdbm.c"
struct tag_playlist {
   unsigned long id ;
   int songs ;
   int is_smart ;
   int found ;
   char *name ;
   int file_time ;
   struct tag_playlistentry *nodes ;
   struct tag_playlistentry *last_node ;
   struct tag_playlist *next ;
};
#line 77 "db-gdbm.c"
typedef struct tag_playlist DB_PLAYLIST;
#line 89 "db-gdbm.c"
struct tag_mp3packed {
   int version ;
   int struct_size ;
   int bitrate ;
   int samplerate ;
   int song_length ;
   int file_size ;
   int year ;
   int track ;
   int total_tracks ;
   int disc ;
   int total_discs ;
   int time_added ;
   int time_modified ;
   int time_played ;
   int db_timestamp ;
   int bpm ;
   char compilation ;
   unsigned long id ;
   int path_len ;
   int fname_len ;
   int title_len ;
   int artist_len ;
   int album_len ;
   int genre_len ;
   int comment_len ;
   int type_len ;
   int composer_len ;
   int orchestra_len ;
   int conductor_len ;
   int grouping_len ;
   int url_len ;
   char data[1] ;
};
#line 89 "db-gdbm.c"
typedef struct tag_mp3packed MP3PACKED;
#line 36 "/usr/include/id3tag.h"
typedef unsigned char id3_byte_t;
#line 37 "/usr/include/id3tag.h"
typedef unsigned long id3_length_t;
#line 39 "/usr/include/id3tag.h"
typedef unsigned long id3_ucs4_t;
#line 41 "/usr/include/id3tag.h"
typedef unsigned char id3_latin1_t;
#line 43 "/usr/include/id3tag.h"
typedef signed char id3_utf8_t;
#line 45
struct id3_frame;
#line 45 "/usr/include/id3tag.h"
struct id3_tag {
   unsigned int refcount ;
   unsigned int version ;
   int flags ;
   int extendedflags ;
   int restrictions ;
   int options ;
   unsigned int nframes ;
   struct id3_frame **frames ;
   id3_length_t paddedsize ;
};
#line 145
union id3_field;
#line 145 "/usr/include/id3tag.h"
struct id3_frame {
   char id[5] ;
   char const   *description ;
   unsigned int refcount ;
   int flags ;
   int group_id ;
   int encryption_method ;
   id3_byte_t *encoded ;
   id3_length_t encoded_length ;
   id3_length_t decoded_length ;
   unsigned int nfields ;
   union id3_field *fields ;
};
#line 179
enum id3_field_type {
    ID3_FIELD_TYPE_TEXTENCODING = 0,
    ID3_FIELD_TYPE_LATIN1 = 1,
    ID3_FIELD_TYPE_LATIN1FULL = 2,
    ID3_FIELD_TYPE_LATIN1LIST = 3,
    ID3_FIELD_TYPE_STRING = 4,
    ID3_FIELD_TYPE_STRINGFULL = 5,
    ID3_FIELD_TYPE_STRINGLIST = 6,
    ID3_FIELD_TYPE_LANGUAGE = 7,
    ID3_FIELD_TYPE_FRAMEID = 8,
    ID3_FIELD_TYPE_DATE = 9,
    ID3_FIELD_TYPE_INT8 = 10,
    ID3_FIELD_TYPE_INT16 = 11,
    ID3_FIELD_TYPE_INT24 = 12,
    ID3_FIELD_TYPE_INT32 = 13,
    ID3_FIELD_TYPE_INT32PLUS = 14,
    ID3_FIELD_TYPE_BINARYDATA = 15
} ;
#line 205 "/usr/include/id3tag.h"
struct __anonstruct_number_26 {
   enum id3_field_type type ;
   long value ;
};
#line 205 "/usr/include/id3tag.h"
struct __anonstruct_latin1_27 {
   enum id3_field_type type ;
   id3_latin1_t *ptr ;
};
#line 205 "/usr/include/id3tag.h"
struct __anonstruct_latin1list_28 {
   enum id3_field_type type ;
   unsigned int nstrings ;
   id3_latin1_t **strings ;
};
#line 205 "/usr/include/id3tag.h"
struct __anonstruct_string_29 {
   enum id3_field_type type ;
   id3_ucs4_t *ptr ;
};
#line 205 "/usr/include/id3tag.h"
struct __anonstruct_stringlist_30 {
   enum id3_field_type type ;
   unsigned int nstrings ;
   id3_ucs4_t **strings ;
};
#line 205 "/usr/include/id3tag.h"
struct __anonstruct_immediate_31 {
   enum id3_field_type type ;
   char value[9] ;
};
#line 205 "/usr/include/id3tag.h"
struct __anonstruct_binary_32 {
   enum id3_field_type type ;
   id3_byte_t *data ;
   id3_length_t length ;
};
#line 205 "/usr/include/id3tag.h"
union id3_field {
   enum id3_field_type type ;
   struct __anonstruct_number_26 number ;
   struct __anonstruct_latin1_27 latin1 ;
   struct __anonstruct_latin1list_28 latin1list ;
   struct __anonstruct_string_29 string ;
   struct __anonstruct_stringlist_30 stringlist ;
   struct __anonstruct_immediate_31 immediate ;
   struct __anonstruct_binary_32 binary ;
};
#line 242
enum id3_file_mode {
    ID3_FILE_MODE_READONLY = 0,
    ID3_FILE_MODE_READWRITE = 1
} ;
#line 247
struct id3_file;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 66 "mp3-scanner.c"
struct tag_scan_frameinfo {
   int layer ;
   int bitrate ;
   int samplerate ;
   int stereo ;
   int frame_length ;
   int crc_protected ;
   int samples_per_frame ;
   int padding ;
   int xing_offset ;
   int number_of_frames ;
   int frame_offset ;
   double version ;
   int is_valid ;
};
#line 66 "mp3-scanner.c"
typedef struct tag_scan_frameinfo SCAN_FRAMEINFO;
#line 87 "mp3-scanner.c"
struct tag_scan_id3header {
   unsigned char id[3] ;
   unsigned char version[2] ;
   unsigned char flags ;
   unsigned char size[4] ;
} __attribute__((__packed__)) ;
#line 87 "mp3-scanner.c"
typedef struct tag_scan_id3header SCAN_ID3HEADER;
#line 301 "mp3-scanner.c"
struct __anonstruct_taghandler_55 {
   char *suffix ;
   int (*tags)(char *file , MP3FILE *pmp3 ) ;
   int (*files)(char *file , MP3FILE *pmp3 ) ;
};
#line 301 "mp3-scanner.c"
typedef struct __anonstruct_taghandler_55 taghandler;
#line 31 "playlist.h"
union __anonunion_arg1_24 {
   int ival ;
   struct tag_pl_node *plval ;
};
#line 31 "playlist.h"
union __anonunion_arg2_25 {
   char *cval ;
   int ival ;
   struct tag_pl_node *plval ;
};
#line 31 "playlist.h"
struct tag_pl_node {
   int op ;
   int type ;
   union __anonunion_arg1_24 arg1 ;
   union __anonunion_arg2_25 arg2 ;
};
#line 31 "playlist.h"
typedef struct tag_pl_node PL_NODE;
#line 45 "playlist.h"
struct tag_smart_playlist {
   char *name ;
   unsigned int id ;
   PL_NODE *root ;
   struct tag_smart_playlist *next ;
};
#line 45 "playlist.h"
typedef struct tag_smart_playlist SMART_PLAYLIST;
#line 337 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 99 "lexer.c"
struct yy_buffer_state;
#line 99 "lexer.c"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 141 "lexer.c"
typedef unsigned int yy_size_t;
#line 144 "lexer.c"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 266 "lexer.c"
typedef unsigned char YY_CHAR;
#line 268 "lexer.c"
typedef int yy_state_type;
#line 112 "parser.h"
union YYSTYPE {
   unsigned int ival ;
   char *cval ;
   PL_NODE *plval ;
};
#line 112 "parser.h"
typedef union YYSTYPE YYSTYPE;
#line 237 "parser.c"
typedef unsigned char yytype_uint8;
#line 244 "parser.c"
typedef signed char yytype_int8;
#line 258 "parser.c"
typedef short yytype_int16;
#line 389 "parser.c"
union yyalloc {
   yytype_int16 yyss ;
   YYSTYPE yyvs ;
};
#line 65 "redblack.h"
enum __anonenum_VISIT_21 {
    preorder = 0,
    postorder = 1,
    endorder = 2,
    leaf = 3
} ;
#line 65 "redblack.h"
typedef enum __anonenum_VISIT_21 VISIT;
#line 74 "redblack.h"
struct rblists {
   struct rbnode  const  *rootp ;
   struct rbnode  const  *nextp ;
};
#line 40 "redblack.c"
enum nodecolour {
    BLACK = 0,
    RED = 1
} ;
#line 42 "redblack.c"
struct rbnode {
   struct rbnode *left ;
   struct rbnode *right ;
   struct rbnode *up ;
   enum nodecolour colour ;
   void const   *key ;
};
#line 527 "mDNSClientAPI.h"
typedef int mDNSBool;
#line 529 "mDNSClientAPI.h"
typedef unsigned char mDNSu8;
#line 531 "mDNSClientAPI.h"
typedef unsigned short mDNSu16;
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 203 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 533 "mDNSClientAPI.h"
typedef int32_t mDNSs32;
#line 534 "mDNSClientAPI.h"
typedef u_int32_t mDNSu32;
#line 539 "mDNSClientAPI.h"
struct mDNSInterfaceID_dummystruct {
   void *dummy ;
};
#line 539 "mDNSClientAPI.h"
typedef struct mDNSInterfaceID_dummystruct *mDNSInterfaceID;
#line 548 "mDNSClientAPI.h"
union __anonunion_mDNSOpaque16_18 {
   mDNSu8 b[2] ;
   mDNSu16 NotAnInteger ;
} __attribute__((__packed__)) ;
#line 548 "mDNSClientAPI.h"
typedef union __anonunion_mDNSOpaque16_18 mDNSOpaque16;
#line 549 "mDNSClientAPI.h"
union __anonunion_mDNSOpaque32_19 {
   mDNSu8 b[4] ;
   mDNSu32 NotAnInteger ;
} __attribute__((__packed__)) ;
#line 549 "mDNSClientAPI.h"
typedef union __anonunion_mDNSOpaque32_19 mDNSOpaque32;
#line 550 "mDNSClientAPI.h"
union __anonunion_mDNSOpaque128_20 {
   mDNSu8 b[16] ;
   mDNSu16 w[8] ;
   mDNSu32 l[4] ;
} __attribute__((__packed__)) ;
#line 550 "mDNSClientAPI.h"
typedef union __anonunion_mDNSOpaque128_20 mDNSOpaque128;
#line 552 "mDNSClientAPI.h"
typedef mDNSOpaque16 mDNSIPPort;
#line 553 "mDNSClientAPI.h"
typedef mDNSOpaque32 mDNSv4Addr;
#line 554 "mDNSClientAPI.h"
typedef mDNSOpaque128 mDNSv6Addr;
#line 564 "mDNSClientAPI.h"
union __anonunion_ip_23 {
   mDNSv6Addr v6 ;
   mDNSv4Addr v4 ;
};
#line 564 "mDNSClientAPI.h"
struct __anonstruct_mDNSAddr_22 {
   mDNSs32 type ;
   union __anonunion_ip_23 ip ;
};
#line 564 "mDNSClientAPI.h"
typedef struct __anonstruct_mDNSAddr_22 mDNSAddr;
#line 609 "mDNSClientAPI.h"
typedef mDNSs32 mStatus;
#line 613 "mDNSClientAPI.h"
struct __anonstruct_domainlabel_26 {
   mDNSu8 c[64] ;
};
#line 613 "mDNSClientAPI.h"
typedef struct __anonstruct_domainlabel_26 domainlabel;
#line 617 "mDNSClientAPI.h"
struct __anonstruct_domainname_27 {
   mDNSu8 c[256] ;
};
#line 617 "mDNSClientAPI.h"
typedef struct __anonstruct_domainname_27 domainname;
#line 619 "mDNSClientAPI.h"
struct __anonstruct_UTF8str255_28 {
   mDNSu8 c[256] ;
};
#line 619 "mDNSClientAPI.h"
typedef struct __anonstruct_UTF8str255_28 UTF8str255;
#line 718 "mDNSClientAPI.h"
struct __anonstruct_rdataSRV_30 {
   mDNSu16 priority ;
   mDNSu16 weight ;
   mDNSIPPort port ;
   domainname target ;
} __attribute__((__packed__)) ;
#line 718 "mDNSClientAPI.h"
typedef struct __anonstruct_rdataSRV_30 rdataSRV;
#line 719 "mDNSClientAPI.h"
struct __anonstruct_rdataMX_31 {
   mDNSu16 preference ;
   domainname exchange ;
} __attribute__((__packed__)) ;
#line 719 "mDNSClientAPI.h"
typedef struct __anonstruct_rdataMX_31 rdataMX;
#line 738 "mDNSClientAPI.h"
union __anonunion_RDataBody_32 {
   mDNSu8 data[264] ;
   mDNSv4Addr ip ;
   mDNSv6Addr ipv6 ;
   domainname name ;
   UTF8str255 txt ;
   rdataSRV srv ;
   rdataMX mx ;
};
#line 738 "mDNSClientAPI.h"
typedef union __anonunion_RDataBody_32 RDataBody;
#line 749 "mDNSClientAPI.h"
struct __anonstruct_RData_33 {
   mDNSu16 MaxRDLength ;
   RDataBody u ;
};
#line 749 "mDNSClientAPI.h"
typedef struct __anonstruct_RData_33 RData;
#line 756
struct AuthRecord_struct;
#line 756 "mDNSClientAPI.h"
typedef struct AuthRecord_struct AuthRecord;
#line 757
struct CacheRecord_struct;
#line 757 "mDNSClientAPI.h"
typedef struct CacheRecord_struct CacheRecord;
#line 758
struct ResourceRecord_struct;
#line 758 "mDNSClientAPI.h"
typedef struct ResourceRecord_struct ResourceRecord;
#line 759
struct DNSQuestion_struct;
#line 759 "mDNSClientAPI.h"
typedef struct DNSQuestion_struct DNSQuestion;
#line 760
struct mDNS_struct;
#line 760 "mDNSClientAPI.h"
typedef struct mDNS_struct mDNS;
#line 761
struct mDNS_PlatformSupport_struct;
#line 761 "mDNSClientAPI.h"
typedef struct mDNS_PlatformSupport_struct mDNS_PlatformSupport;
#line 764 "mDNSClientAPI.h"
typedef void mDNSRecordCallback(mDNS *m , AuthRecord *rr , mStatus result );
#line 770 "mDNSClientAPI.h"
typedef void mDNSRecordUpdateCallback(mDNS *m , AuthRecord *rr , RData *OldRData );
#line 772 "mDNSClientAPI.h"
struct ResourceRecord_struct {
   mDNSu8 RecordType ;
   mDNSInterfaceID InterfaceID ;
   domainname name ;
   mDNSu16 rrtype ;
   mDNSu16 rrclass ;
   mDNSu32 rroriginalttl ;
   mDNSu16 rdlength ;
   mDNSu16 rdestimate ;
   mDNSu32 namehash ;
   mDNSu32 rdatahash ;
   mDNSu32 rdnamehash ;
   RData *rdata ;
};
#line 791 "mDNSClientAPI.h"
struct AuthRecord_struct {
   AuthRecord *next ;
   ResourceRecord resrec ;
   AuthRecord *Additional1 ;
   AuthRecord *Additional2 ;
   AuthRecord *DependentOn ;
   AuthRecord *RRSet ;
   mDNSRecordCallback *RecordCallback ;
   void *RecordContext ;
   mDNSu8 HostTarget ;
   mDNSu8 Acknowledged ;
   mDNSu8 ProbeCount ;
   mDNSu8 AnnounceCount ;
   mDNSu8 IncludeInProbe ;
   mDNSInterfaceID ImmedAnswer ;
   mDNSInterfaceID ImmedAdditional ;
   mDNSInterfaceID SendRNow ;
   mDNSv4Addr v4Requester ;
   mDNSv6Addr v6Requester ;
   AuthRecord *NextResponse ;
   mDNSu8 const   *NR_AnswerTo ;
   AuthRecord *NR_AdditionalTo ;
   mDNSs32 ThisAPInterval ;
   mDNSs32 AnnounceUntil ;
   mDNSs32 LastAPTime ;
   mDNSs32 LastMCTime ;
   mDNSInterfaceID LastMCInterface ;
   RData *NewRData ;
   mDNSu16 newrdlength ;
   mDNSRecordUpdateCallback *UpdateCallback ;
   mDNSu32 UpdateCredits ;
   mDNSs32 NextUpdateCredit ;
   mDNSs32 UpdateBlocked ;
   RData rdatastorage ;
};
#line 841 "mDNSClientAPI.h"
struct __anonstruct_rdatastorage_34 {
   mDNSu16 MaxRDLength ;
   mDNSu8 data[64] ;
};
#line 841 "mDNSClientAPI.h"
struct CacheRecord_struct {
   CacheRecord *next ;
   ResourceRecord resrec ;
   CacheRecord *NextInKAList ;
   mDNSs32 TimeRcvd ;
   mDNSs32 NextRequiredQuery ;
   mDNSs32 LastUsed ;
   mDNSu32 UseCount ;
   DNSQuestion *CRActiveQuestion ;
   mDNSu32 UnansweredQueries ;
   mDNSs32 LastUnansweredTime ;
   mDNSu32 MPUnansweredQ ;
   mDNSs32 MPLastUnansweredQT ;
   mDNSu32 MPUnansweredKA ;
   mDNSBool MPExpectingKA ;
   CacheRecord *NextInCFList ;
   struct __anonstruct_rdatastorage_34 rdatastorage ;
};
#line 864 "mDNSClientAPI.h"
struct __anonstruct_LargeCacheRecord_35 {
   CacheRecord r ;
   mDNSu8 _extradata[8128] ;
};
#line 864 "mDNSClientAPI.h"
typedef struct __anonstruct_LargeCacheRecord_35 LargeCacheRecord;
#line 870
struct NetworkInterfaceInfo_struct;
#line 870 "mDNSClientAPI.h"
typedef struct NetworkInterfaceInfo_struct NetworkInterfaceInfo;
#line 872 "mDNSClientAPI.h"
struct NetworkInterfaceInfo_struct {
   NetworkInterfaceInfo *next ;
   mDNSBool InterfaceActive ;
   mDNSBool IPv4Available ;
   mDNSBool IPv6Available ;
   AuthRecord RR_A ;
   AuthRecord RR_PTR ;
   AuthRecord RR_HINFO ;
   mDNSInterfaceID InterfaceID ;
   mDNSAddr ip ;
   mDNSBool Advertise ;
   mDNSBool TxAndRx ;
};
#line 897
struct ExtraResourceRecord_struct;
#line 897 "mDNSClientAPI.h"
typedef struct ExtraResourceRecord_struct ExtraResourceRecord;
#line 898 "mDNSClientAPI.h"
struct ExtraResourceRecord_struct {
   ExtraResourceRecord *next ;
   AuthRecord r ;
};
#line 908
struct ServiceRecordSet_struct;
#line 908 "mDNSClientAPI.h"
typedef struct ServiceRecordSet_struct ServiceRecordSet;
#line 909 "mDNSClientAPI.h"
typedef void mDNSServiceCallback(mDNS *m , ServiceRecordSet *sr , mStatus result );
#line 910 "mDNSClientAPI.h"
struct ServiceRecordSet_struct {
   mDNSServiceCallback *ServiceCallback ;
   void *ServiceContext ;
   ExtraResourceRecord *Extras ;
   mDNSu32 NumSubTypes ;
   AuthRecord *SubTypes ;
   mDNSBool Conflict ;
   domainname Host ;
   AuthRecord RR_ADV ;
   AuthRecord RR_PTR ;
   AuthRecord RR_SRV ;
   AuthRecord RR_TXT ;
};
#line 941 "mDNSClientAPI.h"
struct __anonstruct_DupSuppressInfo_36 {
   mDNSs32 Time ;
   mDNSInterfaceID InterfaceID ;
   mDNSs32 Type ;
};
#line 941 "mDNSClientAPI.h"
typedef struct __anonstruct_DupSuppressInfo_36 DupSuppressInfo;
#line 949 "mDNSClientAPI.h"
typedef void mDNSQuestionCallback(mDNS *m , DNSQuestion *question , ResourceRecord const   *answer ,
                                  mDNSBool AddRecord );
#line 950 "mDNSClientAPI.h"
struct DNSQuestion_struct {
   DNSQuestion *next ;
   mDNSu32 qnamehash ;
   mDNSs32 LastQTime ;
   mDNSs32 ThisQInterval ;
   mDNSu32 RecentAnswers ;
   mDNSu32 CurrentAnswers ;
   mDNSu32 LargeAnswers ;
   mDNSu32 UniqueAnswers ;
   DNSQuestion *DuplicateOf ;
   DNSQuestion *NextInDQList ;
   DupSuppressInfo DupSuppress[8] ;
   mDNSInterfaceID SendQNow ;
   mDNSBool SendOnAll ;
   mDNSs32 LastQTxTime ;
   mDNSInterfaceID InterfaceID ;
   domainname qname ;
   mDNSu16 qtype ;
   mDNSu16 qclass ;
   mDNSQuestionCallback *QuestionCallback ;
   void *QuestionContext ;
};
#line 980 "mDNSClientAPI.h"
struct __anonstruct_ServiceInfo_37 {
   domainname name ;
   mDNSInterfaceID InterfaceID ;
   mDNSAddr ip ;
   mDNSIPPort port ;
   mDNSu16 TXTlen ;
   mDNSu8 TXTinfo[2048] ;
};
#line 980 "mDNSClientAPI.h"
typedef struct __anonstruct_ServiceInfo_37 ServiceInfo;
#line 993
struct ServiceInfoQuery_struct;
#line 993 "mDNSClientAPI.h"
typedef struct ServiceInfoQuery_struct ServiceInfoQuery;
#line 994 "mDNSClientAPI.h"
typedef void mDNSServiceInfoQueryCallback(mDNS *m , ServiceInfoQuery *query );
#line 995 "mDNSClientAPI.h"
struct ServiceInfoQuery_struct {
   DNSQuestion qSRV ;
   DNSQuestion qTXT ;
   DNSQuestion qAv4 ;
   DNSQuestion qAv6 ;
   mDNSu8 GotSRV ;
   mDNSu8 GotTXT ;
   mDNSu8 GotADD ;
   mDNSu32 Answers ;
   ServiceInfo *info ;
   mDNSServiceInfoQueryCallback *ServiceInfoQueryCallback ;
   void *ServiceInfoQueryContext ;
};
#line 1021 "mDNSClientAPI.h"
typedef void mDNSCallback(mDNS *m , mStatus result );
#line 1030 "mDNSClientAPI.h"
struct mDNS_struct {
   mDNS_PlatformSupport *p ;
   mDNSu32 KnownBugs ;
   mDNSBool AdvertiseLocalAddresses ;
   mStatus mDNSPlatformStatus ;
   mDNSCallback *MainCallback ;
   void *MainContext ;
   mDNSu32 mDNS_busy ;
   mDNSu32 mDNS_reentrancy ;
   mDNSu8 mDNS_shutdown ;
   mDNSu8 lock_rrcache ;
   mDNSu8 lock_Questions ;
   mDNSu8 lock_Records ;
   char MsgBuffer[80] ;
   mDNSs32 timenow ;
   mDNSs32 timenow_last ;
   mDNSs32 timenow_adjust ;
   mDNSs32 NextScheduledEvent ;
   mDNSs32 SuppressSending ;
   mDNSs32 NextCacheCheck ;
   mDNSs32 NextScheduledQuery ;
   mDNSs32 NextScheduledProbe ;
   mDNSs32 NextScheduledResponse ;
   mDNSs32 ExpectUnicastResponse ;
   mDNSs32 RandomQueryDelay ;
   mDNSBool SendDeregistrations ;
   mDNSBool SendImmediateAnswers ;
   mDNSBool SleepState ;
   DNSQuestion *Questions ;
   DNSQuestion *NewQuestions ;
   DNSQuestion *CurrentQuestion ;
   DNSQuestion *LocalOnlyQuestions ;
   DNSQuestion *NewLocalOnlyQuestions ;
   mDNSu32 rrcache_size ;
   mDNSu32 rrcache_totalused ;
   mDNSu32 rrcache_active ;
   mDNSu32 rrcache_report ;
   CacheRecord *rrcache_free ;
   CacheRecord *rrcache_hash[499] ;
   CacheRecord **rrcache_tail[499] ;
   mDNSu32 rrcache_used[499] ;
   domainlabel nicelabel ;
   domainlabel hostlabel ;
   domainname hostname ;
   UTF8str255 HIHardware ;
   UTF8str255 HISoftware ;
   AuthRecord *ResourceRecords ;
   AuthRecord *DuplicateRecords ;
   AuthRecord *LocalOnlyRecords ;
   AuthRecord *NewLocalOnlyRecords ;
   mDNSBool DiscardLocalOnlyRecords ;
   AuthRecord *CurrentRecord ;
   NetworkInterfaceInfo *HostInterfaces ;
   mDNSs32 ProbeFailTime ;
   mDNSs32 NumFailedProbes ;
   mDNSs32 SuppressProbes ;
};
#line 1245
enum __anonenum_mDNS_DomainType_39 {
    mDNS_DomainTypeBrowse = 0,
    mDNS_DomainTypeBrowseDefault = 1,
    mDNS_DomainTypeRegistration = 2,
    mDNS_DomainTypeRegistrationDefault = 3
} ;
#line 1245 "mDNSClientAPI.h"
typedef enum __anonenum_mDNS_DomainType_39 mDNS_DomainType;
#line 1356 "mDNSClientAPI.h"
struct __anonstruct_DNSMessageHeader_40 {
   mDNSOpaque16 id ;
   mDNSOpaque16 flags ;
   mDNSu16 numQuestions ;
   mDNSu16 numAnswers ;
   mDNSu16 numAuthorities ;
   mDNSu16 numAdditionals ;
} __attribute__((__packed__)) ;
#line 1356 "mDNSClientAPI.h"
typedef struct __anonstruct_DNSMessageHeader_40 DNSMessageHeader;
#line 1371 "mDNSClientAPI.h"
struct __anonstruct_DNSMessage_41 {
   DNSMessageHeader h ;
   mDNSu8 data[8940] ;
} __attribute__((__packed__)) ;
#line 1371 "mDNSClientAPI.h"
typedef struct __anonstruct_DNSMessage_41 DNSMessage;
#line 1134 "mDNS.c"
struct mDNSprintf_format {
   unsigned int leftJustify : 1 ;
   unsigned int forceSign : 1 ;
   unsigned int zeroPad : 1 ;
   unsigned int havePrecision : 1 ;
   unsigned int hSize : 1 ;
   unsigned int lSize : 1 ;
   char altForm ;
   char sign ;
   unsigned int fieldWidth ;
   unsigned int precision ;
};
#line 2583
enum __anonenum_mDNS_Dereg_type_43 {
    mDNS_Dereg_normal = 0,
    mDNS_Dereg_conflict = 1,
    mDNS_Dereg_repeat = 2
} ;
#line 2583 "mDNS.c"
typedef enum __anonenum_mDNS_Dereg_type_43 mDNS_Dereg_type;
#line 34 "/usr/include/bits/types.h"
typedef unsigned char __u_char;
#line 35 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 35 "/usr/include/sys/types.h"
typedef __u_char u_char;
#line 36 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 76 "mDNSPosix.h"
struct mDNS_PlatformSupport_struct {
   long dummy[1] ;
};
#line 244 "/usr/include/netinet/in.h"
struct ip_mreq {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_interface ;
};
#line 95 "mDNSUNP.h"
struct my_in_pktinfo {
   struct sockaddr ipi_addr ;
   int ipi_ifindex ;
   char ipi_ifname[16] ;
};
#line 104 "mDNSUNP.h"
struct ifi_info {
   char ifi_name[16] ;
   u_char ifi_haddr[8] ;
   u_short ifi_hlen ;
   short ifi_flags ;
   short ifi_myflags ;
   int ifi_index ;
   struct sockaddr *ifi_addr ;
   struct sockaddr *ifi_brdaddr ;
   struct sockaddr *ifi_dstaddr ;
   struct ifi_info *ifi_next ;
};
#line 155 "mDNSPosix.c"
struct PosixNetworkInterface;
#line 155 "mDNSPosix.c"
typedef struct PosixNetworkInterface PosixNetworkInterface;
#line 157 "mDNSPosix.c"
struct PosixNetworkInterface {
   NetworkInterfaceInfo coreIntf ;
   char const   *intfName ;
   PosixNetworkInterface *aliasIntf ;
   int index ;
   int multicastSocket ;
   int multicastSocketv6 ;
};
#line 189 "/usr/include/bits/types.h"
typedef char *__caddr_t;
#line 44 "/usr/include/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 215 "/usr/include/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 233 "/usr/include/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 112 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 127 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_21 {
   char ifrn_name[16] ;
};
#line 127 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_22 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 127 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_21 ifr_ifrn ;
   union __anonunion_ifr_ifru_22 ifr_ifru ;
};
#line 177 "/usr/include/net/if.h"
union __anonunion_ifc_ifcu_23 {
   __caddr_t ifcu_buf ;
   struct ifreq *ifcu_req ;
};
#line 177 "/usr/include/net/if.h"
struct ifconf {
   int ifc_len ;
   union __anonunion_ifc_ifcu_23 ifc_ifcu ;
};
#line 97 "/usr/include/bits/in.h"
struct in_pktinfo {
   int ipi_ifindex ;
   struct in_addr ipi_spec_dst ;
   struct in_addr ipi_addr ;
};
#line 328 "mDNSUNP.c"
union __anonunion_control_un_40 {
   struct cmsghdr cm ;
   char control[1024] ;
};
#line 27 "rend-unix.h"
struct tag_rend_message {
   int cmd ;
   int port ;
   char name[256] ;
   char type[256] ;
};
#line 27 "rend-unix.h"
typedef struct tag_rend_message REND_MESSAGE;
#line 249 "rend-posix.c"
struct PosixService;
#line 249 "rend-posix.c"
typedef struct PosixService PosixService;
#line 251 "rend-posix.c"
struct PosixService {
   ServiceRecordSet coreServ ;
   PosixService *next ;
   int serviceID ;
};
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
#line 1 "main.o"
#pragma merger(0,"/tmp/cil-AUU5z2F4.i","-g,-g,-O2")
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 85 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
#line 199 "/usr/include/grp.h"
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 187 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 221 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t * __restrict  __newthread ,
                                                        pthread_attr_t const   * __restrict  __attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void * __restrict  __arg )  __attribute__((__nonnull__(1,3))) ;
#line 238
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 299 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 318
extern int close(int __fd ) ;
#line 403
extern unsigned int sleep(unsigned int __seconds ) ;
#line 455
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 491
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 571
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 615
extern  __attribute__((__nothrow__)) int setpgrp(void) ;
#line 640
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 665
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 682
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 721
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 152
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 45 "./restart.h"
int copyfile(int fromfd , int tofd ) ;
#line 46
int r_close(int fildes ) ;
#line 48
int r_open2(char const   *path , int oflag ) ;
#line 92 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 216
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 222
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 249
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 271
extern int sigwait(sigset_t const   * __restrict  __set , int * __restrict  __sig )  __attribute__((__nonnull__(1,2))) ;
#line 36 "/usr/include/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int pthread_kill(pthread_t __threadid , int __signo ) ;
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 211
extern int fclose(FILE *__stream ) ;
#line 278
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 325
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 331
extern int printf(char const   * __restrict  __format  , ...) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 151
__inline static  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 158
__inline static  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 210
__inline static  __attribute__((__nothrow__)) long long strtoll(char const   * __restrict  __nptr ,
                                                                char ** __restrict  __endptr ,
                                                                int __base )  __attribute__((__nonnull__(1))) ;
#line 290
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 306
extern  __attribute__((__nothrow__)) long long __strtoll_internal(char const   * __restrict  __nptr ,
                                                                  char ** __restrict  __endptr ,
                                                                  int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 332
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 332 "/usr/include/stdlib.h"
__inline static long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) 
{ long tmp ;

  {
#line 336
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
#line 336
  return (tmp);
}
}
#line 380
__inline static  __attribute__((__nothrow__)) long long strtoll(char const   * __restrict  __nptr ,
                                                                char ** __restrict  __endptr ,
                                                                int __base )  __attribute__((__nonnull__(1))) ;
#line 380 "/usr/include/stdlib.h"
__inline static long long strtoll(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                  int __base ) 
{ long long tmp ;

  {
#line 384
  tmp = __strtoll_internal(__nptr, __endptr, __base, 0);
#line 384
  return (tmp);
}
}
#line 401
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 401 "/usr/include/stdlib.h"
__inline static int atoi(char const   *__nptr ) 
{ long tmp ;

  {
#line 404
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 404
  return ((int )tmp);
}
}
#line 406
__inline static  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 406 "/usr/include/stdlib.h"
__inline static long atol(char const   *__nptr ) 
{ long tmp ;

  {
#line 409
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 409
  return (tmp);
}
}
#line 415
__inline static  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 415 "/usr/include/stdlib.h"
__inline static long long atoll(char const   *__nptr ) 
{ long long tmp ;

  {
#line 418
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
#line 418
  return (tmp);
}
}
#line 603
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 646
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 102 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 242
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 256
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 325
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 329
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 1304 "/usr/include/bits/string2.h"
extern  __attribute__((__nothrow__)) char *__strdup(char const   *__string )  __attribute__((__malloc__)) ;
#line 212 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 307
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 380
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
#line 447
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 447 "/usr/include/sys/stat.h"
__inline static int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 450
  tmp = __fxstat(3, __fd, __statbuf);
#line 450
  return (tmp);
}
}
#line 116 "/usr/include/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 73 "daapd.h"
CONFIG config  ;
#line 76
int drop_privs(char *user ) ;
#line 72 "webserver.h"
WSHANDLE ws_start(WSCONFIG *config___0 ) ;
#line 74
int ws_registerhandler(WSHANDLE ws , char *regex , void (*handler)(WS_CONNINFO * ) ,
                       int (*auth)(char * , char * ) , int addheaders ) ;
#line 81
int ws_returnerror(WS_CONNINFO *pwsc , int error , char *description ) ;
#line 82
int ws_addresponseheader(WS_CONNINFO *pwsc , char *header , char *fmt  , ...) ;
#line 83
int ws_writefd(WS_CONNINFO *pwsc , char *fmt  , ...) ;
#line 84
char *ws_getvar(WS_CONNINFO *pwsc , char *var ) ;
#line 85
char *ws_getrequestheader(WS_CONNINFO *pwsc , char *header ) ;
#line 86
int ws_testrequestheader(WS_CONNINFO *pwsc , char *header , char *value ) ;
#line 87
void ws_emitheaders(WS_CONNINFO *pwsc ) ;
#line 28 "configfile.h"
int config_read(char *file ) ;
#line 30
int config_auth(char *user , char *password ) ;
#line 31
void config_handler(WS_CONNINFO *pwsc ) ;
#line 32
void config_set_status(WS_CONNINFO *pwsc , int session , char *fmt  , ...) ;
#line 33
int config_get_session_count(void) ;
#line 35
void config_close(void) ;
#line 72 "mp3-scanner.h"
int scan_init(char *path ) ;
#line 32 "db-memory.h"
int db_open(char *parameters , int reload ) ;
#line 33
int db_init(void) ;
#line 34
int db_deinit(void) ;
#line 35
int db_version(void) ;
#line 45
MP3FILE *db_find(unsigned long id ) ;
#line 46
void db_dispose(MP3FILE *pmp3 ) ;
#line 48
int db_get_song_count(void) ;
#line 40 "daap-proto.h"
GZIP_STREAM *gzip_alloc(void) ;
#line 42
int gzip_compress(GZIP_STREAM *gz ) ;
#line 43
int gzip_close(GZIP_STREAM *gz , int fd ) ;
#line 65
int daap_serialize(DAAP_BLOCK *root , int fd , GZIP_STREAM *gz ) ;
#line 66
void daap_free(DAAP_BLOCK *root ) ;
#line 26 "daap.h"
DAAP_BLOCK *daap_response_server_info(char *name , char *client_version ) ;
#line 27
DAAP_BLOCK *daap_response_content_codes(void) ;
#line 28
DAAP_BLOCK *daap_response_login(char *hostname ) ;
#line 29
DAAP_BLOCK *daap_response_update(int fd , int clientver ) ;
#line 30
DAAP_BLOCK *daap_response_songlist(char *metaStr , char *query ) ;
#line 31
DAAP_BLOCK *daap_response_playlists(char *name ) ;
#line 32
DAAP_BLOCK *daap_response_dbinfo(char *name ) ;
#line 33
DAAP_BLOCK *daap_response_playlist_items(unsigned int playlist , char *metaStr , char *query ) ;
#line 34
void daap_handle_index(DAAP_BLOCK *block , char const   *index___0 ) ;
#line 36
DAAP_BLOCK *daap_response_browse(char const   *name , char const   *filter ) ;
#line 60 "err.h"
int err_debuglevel ;
#line 62
void err_log(int level , unsigned int cat , char *fmt  , ...) ;
#line 63
void err_setdest(char *app , int destination ) ;
#line 64
extern int err_setdebugmask(char *list ) ;
#line 53 "playlist.h"
int pl_error ;
#line 55
void pl_dump(void) ;
#line 56
int pl_load(char *file ) ;
#line 25 "dynamic-art.h"
int da_get_image_fd(char *filename ) ;
#line 26
int da_attach_image(int img_fd , int out_fd , int mp3_fd , int offset ) ;
#line 27
off_t da_aac_attach_image(int img_fd , int out_fd , int aac_fd , int offset ) ;
#line 25 "rend.h"
int rend_init(char *user ) ;
#line 27
int rend_stop(void) ;
#line 28
int rend_register(char *name , char *type , int port ) ;
#line 124 "main.c"
static int daemon_start(void) ;
#line 126
static void usage(char *program ) ;
#line 127
static void *signal_handler(void *arg ) ;
#line 128
static int start_signal_handler(pthread_t *handler_tid ) ;
#line 129
static void daap_handler(WS_CONNINFO *pwsc ) ;
#line 130
static int daap_auth(char *username , char *password ) ;
#line 147 "main.c"
static int daap_auth(char *username , char *password ) 
{ size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 148
  if ((unsigned int )password == (unsigned int )((void *)0)) {
#line 148
    if ((unsigned int )config.readpassword == (unsigned int )((void *)0)) {
#line 150
      return (1);
    } else {
#line 148
      tmp = strlen((char const   *)config.readpassword);
#line 148
      if (tmp == 0U) {
#line 150
        return (1);
      }
    }
  }
#line 152
  if ((unsigned int )password == (unsigned int )((void *)0)) {
#line 153
    return (0);
  }
#line 155
  tmp___0 = strcasecmp((char const   *)password, (char const   *)config.readpassword);
#line 155
  if (tmp___0) {
#line 155
    tmp___1 = 0;
  } else {
#line 155
    tmp___1 = 1;
  }
#line 155
  return (tmp___1);
}
}
#line 167 "main.c"
static void daap_handler(WS_CONNINFO *pwsc ) 
{ int close___0 ;
  DAAP_BLOCK *root ;
  int clientrev ;
  char *uri ;
  unsigned long db_index ;
  unsigned long playlist_index ;
  unsigned long item ;
  char *first ;
  char *last ;
  char *index___0 ;
  int streaming ;
  int compress___0 ;
  int start_time ;
  int end_time ;
  int bytes_written ;
  MP3FILE *pmp3 ;
  int file_fd ;
  int session_id ;
  int img_fd ;
  struct stat sb ;
  long img_size ;
  off_t offset ;
  off_t real_len ;
  off_t file_len ;
  int bytes_copied ;
  GZIP_STREAM *gz ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___11 ;
  long long tmp___12 ;
  long long tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  long long tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___28 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___39 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  time_t tmp___51 ;
  int tmp___52 ;
  time_t tmp___53 ;
  char *tmp___54 ;
  long tmp___55 ;
  char *tmp___56 ;
  int *tmp___57 ;
  int *tmp___58 ;
  char *tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int *tmp___64 ;
  char *tmp___65 ;

  {
#line 176
  item = 0UL;
#line 178
  index___0 = (char *)0;
#line 179
  streaming = 0;
#line 180
  compress___0 = 0;
#line 187
  session_id = 0;
#line 193
  offset = (off_t )0;
#line 197
  bytes_copied = 0;
#line 201
  close___0 = pwsc->close;
#line 202
  pwsc->close = 1;
#line 203
  root = (DAAP_BLOCK *)((void *)0);
#line 205
  ws_addresponseheader(pwsc, (char *)"Accept-Ranges", (char *)"bytes");
#line 206
  ws_addresponseheader(pwsc, (char *)"DAAP-Server", (char *)"mt-daapd/%s", "0.2.4.1");
#line 207
  ws_addresponseheader(pwsc, (char *)"Content-Type", (char *)"application/x-dmap-tagged");
#line 209
  tmp___0 = ws_getvar(pwsc, (char *)"session-id");
#line 209
  if (tmp___0) {
#line 210
    tmp = ws_getvar(pwsc, (char *)"session-id");
#line 210
    session_id = atoi((char const   *)tmp);
  }
#line 213
  tmp___49 = strcasecmp((char const   *)pwsc->uri, "/server-info");
#line 213
  if (tmp___49) {
#line 217
    tmp___48 = strcasecmp((char const   *)pwsc->uri, "/content-codes");
#line 217
    if (tmp___48) {
#line 220
      tmp___47 = strcasecmp((char const   *)pwsc->uri, "/login");
#line 220
      if (tmp___47) {
#line 223
        tmp___46 = strcasecmp((char const   *)pwsc->uri, "/update");
#line 223
        if (tmp___46) {
#line 238
          tmp___45 = strcasecmp((char const   *)pwsc->uri, "/logout");
#line 238
          if (tmp___45) {
#line 242
            if (0) {
#line 242
              __s1_len___0 = strlen((char const   *)pwsc->uri);
#line 242
              __s2_len___0 = strlen("/databases");
#line 242
              if (! ((unsigned int )((void const   *)(pwsc->uri + 1)) - (unsigned int )((void const   *)pwsc->uri) == 1U)) {
                goto _L___2;
              } else {
#line 242
                if (__s1_len___0 >= 4U) {
                  _L___2: /* CIL Label */ 
#line 242
                  if (! ((unsigned int )((void const   *)("/databases" + 1)) - (unsigned int )((void const   *)"/databases") == 1U)) {
#line 242
                    tmp___44 = 1;
                  } else {
#line 242
                    if (__s2_len___0 >= 4U) {
#line 242
                      tmp___44 = 1;
                    } else {
#line 242
                      tmp___44 = 0;
                    }
                  }
                } else {
#line 242
                  tmp___44 = 0;
                }
              }
#line 242
              if (tmp___44) {
#line 242
                tmp___39 = __builtin_strcmp((char const   *)pwsc->uri, "/databases");
#line 242
                tmp___43 = tmp___39;
              } else {
#line 242
                tmp___42 = __builtin_strcmp((char const   *)pwsc->uri, "/databases");
#line 242
                tmp___43 = tmp___42;
              }
            } else {
#line 242
              tmp___42 = __builtin_strcmp((char const   *)pwsc->uri, "/databases");
#line 242
              tmp___43 = tmp___42;
            }
#line 242
            if (tmp___43 == 0) {
#line 243
              config_set_status(pwsc, session_id, (char *)"Sending database info");
#line 244
              root = daap_response_dbinfo(config.servername);
#line 245
              index___0 = ws_getvar(pwsc, (char *)"index");
#line 245
              if ((unsigned int )((char *)0) != (unsigned int )index___0) {
#line 246
                daap_handle_index(root, (char const   *)index___0);
              }
            } else {
#line 247
              if (0) {
#line 247
                if (0) {
#line 247
                  __s1_len = strlen((char const   *)pwsc->uri);
#line 247
                  __s2_len = strlen("/databases/");
#line 247
                  if (! ((unsigned int )((void const   *)(pwsc->uri + 1)) - (unsigned int )((void const   *)pwsc->uri) == 1U)) {
                    goto _L___0;
                  } else {
#line 247
                    if (__s1_len >= 4U) {
                      _L___0: /* CIL Label */ 
#line 247
                      if (! ((unsigned int )((void const   *)("/databases/" + 1)) - (unsigned int )((void const   *)"/databases/") == 1U)) {
#line 247
                        tmp___33 = 1;
                      } else {
#line 247
                        if (__s2_len >= 4U) {
#line 247
                          tmp___33 = 1;
                        } else {
#line 247
                          tmp___33 = 0;
                        }
                      }
                    } else {
#line 247
                      tmp___33 = 0;
                    }
                  }
#line 247
                  if (tmp___33) {
#line 247
                    tmp___28 = __builtin_strcmp((char const   *)pwsc->uri, "/databases/");
#line 247
                    tmp___32 = tmp___28;
                  } else {
#line 247
                    tmp___31 = __builtin_strcmp((char const   *)pwsc->uri, "/databases/");
#line 247
                    tmp___32 = tmp___31;
                  }
                } else {
#line 247
                  tmp___31 = __builtin_strcmp((char const   *)pwsc->uri, "/databases/");
#line 247
                  tmp___32 = tmp___31;
                }
#line 247
                tmp___35 = tmp___32;
              } else {
#line 247
                tmp___34 = strncmp((char const   *)pwsc->uri, "/databases/", 11U);
#line 247
                tmp___35 = tmp___34;
              }
#line 247
              if (tmp___35 == 0) {
#line 258
                tmp___11 = __strdup((char const   *)pwsc->uri);
#line 258
                uri = tmp___11;
#line 259
                first = uri + 11;
#line 260
                last = first;
#line 261
                while (1) {
#line 261
                  if (*last) {
#line 261
                    if (! ((int )*last != 47)) {
#line 261
                      break;
                    }
                  } else {
#line 261
                    break;
                  }
#line 262
                  last ++;
                }
#line 265
                if (*last) {
#line 266
                  *last = (char )'\000';
#line 267
                  tmp___12 = atoll((char const   *)first);
#line 267
                  db_index = (unsigned long )tmp___12;
#line 269
                  last ++;
#line 271
                  tmp___24 = strncasecmp((char const   *)last, "items/", 6U);
#line 271
                  if (tmp___24 == 0) {
#line 273
                    first = last + 6;
#line 274
                    while (1) {
#line 274
                      if (*last) {
#line 274
                        if (! ((int )*last != 46)) {
#line 274
                          break;
                        }
                      } else {
#line 274
                        break;
                      }
#line 275
                      last ++;
                    }
#line 277
                    if ((int )*last == 46) {
#line 278
                      *last = (char )'\000';
#line 279
                      tmp___13 = atoll((char const   *)first);
#line 279
                      item = (unsigned long )tmp___13;
#line 280
                      streaming = 1;
#line 281
                      err_log(9, 514U, (char *)"Streaming request for id %lu\n", item);
                    }
#line 283
                    free((void *)uri);
                  } else {
#line 284
                    tmp___23 = strncasecmp((char const   *)last, "items", 5U);
#line 284
                    if (tmp___23 == 0) {
#line 286
                      free((void *)uri);
#line 289
                      tmp___14 = ws_getvar(pwsc, (char *)"query");
#line 289
                      tmp___15 = ws_getvar(pwsc, (char *)"meta");
#line 289
                      root = daap_response_songlist(tmp___15, tmp___14);
#line 291
                      config_set_status(pwsc, session_id, (char *)"Sending songlist");
                    } else {
#line 292
                      tmp___22 = strncasecmp((char const   *)last, "containers/",
                                             11U);
#line 292
                      if (tmp___22 == 0) {
#line 294
                        first = last + 11;
#line 295
                        last = first;
#line 296
                        while (1) {
#line 296
                          if (*last) {
#line 296
                            if (! ((int )*last != 47)) {
#line 296
                              break;
                            }
                          } else {
#line 296
                            break;
                          }
#line 297
                          last ++;
                        }
#line 300
                        if (*last) {
#line 301
                          *last = (char )'\000';
#line 302
                          tmp___16 = atoll((char const   *)first);
#line 302
                          playlist_index = (unsigned long )tmp___16;
#line 304
                          tmp___17 = ws_getvar(pwsc, (char *)"query");
#line 304
                          tmp___18 = ws_getvar(pwsc, (char *)"meta");
#line 304
                          root = daap_response_playlist_items((unsigned int )playlist_index,
                                                              tmp___18, tmp___17);
                        }
#line 308
                        free((void *)uri);
#line 309
                        config_set_status(pwsc, session_id, (char *)"Sending playlist info");
                      } else {
#line 310
                        tmp___21 = strncasecmp((char const   *)last, "containers",
                                               10U);
#line 310
                        if (tmp___21 == 0) {
#line 312
                          free((void *)uri);
#line 313
                          root = daap_response_playlists(config.servername);
#line 314
                          config_set_status(pwsc, session_id, (char *)"Sending playlist info");
                        } else {
#line 315
                          tmp___20 = strncasecmp((char const   *)last, "browse/",
                                                 7U);
#line 315
                          if (tmp___20 == 0) {
#line 316
                            config_set_status(pwsc, session_id, (char *)"Compiling browse info");
#line 317
                            tmp___19 = ws_getvar(pwsc, (char *)"filter");
#line 317
                            root = daap_response_browse((char const   *)(last + 7),
                                                        (char const   *)tmp___19);
#line 319
                            config_set_status(pwsc, session_id, (char *)"Sending browse info");
#line 320
                            free((void *)uri);
                          }
                        }
                      }
                    }
                  }
                }
#line 325
                index___0 = ws_getvar(pwsc, (char *)"index");
#line 325
                if ((unsigned int )((char *)0) != (unsigned int )index___0) {
#line 326
                  daap_handle_index(root, (char const   *)index___0);
                }
              }
            }
          } else {
#line 239
            config_set_status(pwsc, session_id, (char *)((void *)0));
#line 240
            ws_returnerror(pwsc, 204, (char *)"Logout Successful");
#line 241
            return;
          }
        } else {
#line 224
          tmp___4 = ws_getvar(pwsc, (char *)"delta");
#line 224
          if (tmp___4) {
#line 228
            tmp___3 = ws_getvar(pwsc, (char *)"delta");
#line 228
            clientrev = atoi((char const   *)tmp___3);
#line 229
            config_set_status(pwsc, session_id, (char *)"Waiting for DB updates");
          } else {
#line 225
            tmp___2 = db_version();
#line 225
            clientrev = tmp___2 - 1;
#line 226
            config_set_status(pwsc, session_id, (char *)"Sending database");
          }
#line 231
          root = daap_response_update(pwsc->fd, clientrev);
#line 232
          tmp___5 = ws_getvar(pwsc, (char *)"delta");
#line 232
          if (tmp___5) {
#line 232
            if ((unsigned int )root == (unsigned int )((void *)0)) {
#line 233
              err_log(1, 2U, (char *)"Client %s disconnected\n", pwsc->hostname);
#line 234
              config_set_status(pwsc, session_id, (char *)((void *)0));
#line 235
              pwsc->close = 1;
#line 236
              return;
            }
          }
        }
      } else {
#line 221
        config_set_status(pwsc, session_id, (char *)"Logging in");
#line 222
        root = daap_response_login(pwsc->hostname);
      }
    } else {
#line 218
      config_set_status(pwsc, session_id, (char *)"Sending content codes");
#line 219
      root = daap_response_content_codes();
    }
  } else {
#line 214
    config_set_status(pwsc, session_id, (char *)"Sending server info");
#line 215
    tmp___1 = ws_getrequestheader(pwsc, (char *)"Client-DAAP-Version");
#line 215
    root = daap_response_server_info(config.servername, tmp___1);
  }
#line 329
  if (! root) {
#line 329
    if (! streaming) {
#line 330
      err_log(9, 514U, (char *)"Bad request -- root=%x, streaming=%d\n", root, streaming);
#line 331
      ws_returnerror(pwsc, 400, (char *)"Invalid Request");
#line 332
      config_set_status(pwsc, session_id, (char *)((void *)0));
#line 333
      return;
    }
  }
#line 336
  pwsc->close = close___0;
#line 338
  if (! streaming) {
#line 339
    err_log(9, 2U, (char *)"Satisfying request\n");
#line 341
    if (config.compress) {
#line 341
      tmp___50 = ws_testrequestheader(pwsc, (char *)"Accept-Encoding", (char *)"gzip");
#line 341
      if (tmp___50) {
#line 341
        if (root->reported_size >= 1000) {
#line 342
          compress___0 = 1;
        }
      }
    }
#line 345
    err_log(9, 514U, (char *)"Serializing\n");
#line 346
    tmp___51 = time((time_t *)((void *)0));
#line 346
    start_time = (int )tmp___51;
#line 347
    if (compress___0) {
#line 348
      err_log(9, 514U, (char *)"Using compression: %s\n", pwsc->uri);
#line 349
      gz = gzip_alloc();
#line 350
      daap_serialize(root, pwsc->fd, gz);
#line 351
      gzip_compress(gz);
#line 352
      bytes_written = gz->bytes_out;
#line 353
      ws_writefd(pwsc, (char *)"HTTP/1.1 200 OK\r\n");
#line 354
      ws_addresponseheader(pwsc, (char *)"Content-Length", (char *)"%d", bytes_written);
#line 355
      ws_addresponseheader(pwsc, (char *)"Content-Encoding", (char *)"gzip");
#line 356
      err_log(9, 2U, (char *)"Emitting headers\n");
#line 357
      ws_emitheaders(pwsc);
#line 358
      tmp___52 = gzip_close(gz, pwsc->fd);
#line 358
      if (tmp___52 != bytes_written) {
#line 359
        err_log(1, 514U, (char *)"Error compressing data\n");
      }
#line 361
      err_log(9, 514U, (char *)"Compression ratio: %f\n", (double )bytes_written / (8.0 + (double )root->reported_size));
    } else {
#line 364
      bytes_written = root->reported_size + 8;
#line 365
      ws_addresponseheader(pwsc, (char *)"Content-Length", (char *)"%d", bytes_written);
#line 366
      ws_writefd(pwsc, (char *)"HTTP/1.1 200 OK\r\n");
#line 367
      err_log(9, 2U, (char *)"Emitting headers\n");
#line 368
      ws_emitheaders(pwsc);
#line 369
      daap_serialize(root, pwsc->fd, (GZIP_STREAM *)((void *)0));
    }
#line 371
    tmp___53 = time((time_t *)((void *)0));
#line 371
    end_time = (int )tmp___53;
#line 372
    err_log(9, 514U, (char *)"Sent %d bytes in %d seconds\n", bytes_written, end_time - start_time);
#line 373
    err_log(9, 514U, (char *)"Done, freeing\n");
#line 374
    daap_free(root);
  } else {
#line 377
    pwsc->close = 1;
#line 379
    tmp___56 = ws_getrequestheader(pwsc, (char *)"range");
#line 379
    if (tmp___56) {
#line 380
      tmp___54 = ws_getrequestheader(pwsc, (char *)"range");
#line 380
      tmp___55 = atol((char const   *)(tmp___54 + 6));
#line 380
      offset = tmp___55;
    }
#line 383
    pmp3 = db_find(item);
#line 384
    if (! pmp3) {
#line 385
      err_log(1, 518U, (char *)"Could not find requested item %lu\n", item);
#line 386
      ws_returnerror(pwsc, 404, (char *)"File Not Found");
    } else {
#line 389
      file_fd = r_open2((char const   *)pmp3->path, 0);
#line 390
      if (file_fd == -1) {
#line 391
        tmp___57 = __errno_location();
#line 391
        pwsc->error = *tmp___57;
#line 392
        tmp___58 = __errno_location();
#line 392
        tmp___59 = strerror(*tmp___58);
#line 392
        err_log(2, 2U, (char *)"Thread %d: Error opening %s: %s\n", pwsc->threadno,
                pmp3->path, tmp___59);
#line 394
        ws_returnerror(pwsc, 404, (char *)"Not found");
#line 395
        config_set_status(pwsc, session_id, (char *)((void *)0));
#line 396
        db_dispose(pmp3);
#line 397
        free((void *)pmp3);
      } else {
#line 399
        real_len = lseek(file_fd, 0L, 2);
#line 400
        lseek(file_fd, 0L, 0);
#line 403
        if (config.artfilename) {
#line 403
          img_fd = da_get_image_fd(pmp3->path);
#line 403
          if (img_fd != -1) {
#line 405
            fstat(img_fd, & sb);
#line 406
            img_size = sb.st_size;
#line 408
            tmp___61 = strncasecmp((char const   *)pmp3->type, "mp3", 4U);
#line 408
            if (! (tmp___61 == 0)) {
#line 410
              tmp___60 = strncasecmp((char const   *)pmp3->type, "m4a", 4U);
#line 410
              if (tmp___60 == 0) {
#line 411
                real_len += img_size + 24L;
#line 413
                if (offset > img_size + 24L) {
#line 414
                  offset -= img_size + 24L;
                }
              }
            }
          }
        }
#line 419
        file_len = real_len - offset;
#line 421
        err_log(9, 2U, (char *)"Thread %d: Length of file (remaining) is %ld\n", pwsc->threadno,
                file_len);
#line 427
        if (pmp3->type) {
#line 428
          ws_addresponseheader(pwsc, (char *)"Content-Type", (char *)"audio/%s", pmp3->type);
        }
#line 430
        ws_addresponseheader(pwsc, (char *)"Content-Length", (char *)"%ld", file_len);
#line 431
        ws_addresponseheader(pwsc, (char *)"Connection", (char *)"Close");
#line 434
        if (! offset) {
#line 435
          ws_writefd(pwsc, (char *)"HTTP/1.1 200 OK\r\n");
        } else {
#line 437
          ws_addresponseheader(pwsc, (char *)"Content-Range", (char *)"bytes %ld-%ld/%ld",
                               offset, real_len, real_len + 1L);
#line 440
          ws_writefd(pwsc, (char *)"HTTP/1.1 206 Partial Content\r\n");
        }
#line 443
        ws_emitheaders(pwsc);
#line 445
        config_set_status(pwsc, session_id, (char *)"Streaming file \'%s\'", pmp3->fname);
#line 446
        err_log(1, 2U, (char *)"Session %d: Streaming file \'%s\' to %s (offset %d)\n",
                session_id, pmp3->fname, pwsc->hostname, offset);
#line 449
        if (! offset) {
#line 450
          (config.stats.songs_served) ++;
        }
#line 452
        if (config.artfilename) {
#line 452
          if (! offset) {
#line 452
            img_fd = da_get_image_fd(pmp3->path);
#line 452
            if (img_fd != -1) {
#line 455
              tmp___63 = strncasecmp((char const   *)pmp3->type, "mp3", 4U);
#line 455
              if (tmp___63 == 0) {
#line 456
                err_log(5, 258U, (char *)"Dynamic add artwork to %s (fd %d)\n", pmp3->fname,
                        img_fd);
#line 458
                da_attach_image(img_fd, pwsc->fd, file_fd, (int )offset);
              } else {
#line 459
                tmp___62 = strncasecmp((char const   *)pmp3->type, "m4a", 4U);
#line 459
                if (tmp___62 == 0) {
#line 460
                  err_log(5, 258U, (char *)"Dynamic add artwork to %s (fd %d)\n",
                          pmp3->fname, img_fd);
#line 462
                  da_aac_attach_image(img_fd, pwsc->fd, file_fd, (int )offset);
                }
              }
            } else {
              goto _L___4;
            }
          } else {
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
#line 464
          if (offset) {
#line 465
            err_log(5, 2U, (char *)"Seeking to offset %ld\n", offset);
#line 466
            lseek(file_fd, offset, 0);
          }
        }
#line 469
        bytes_copied = copyfile(file_fd, pwsc->fd);
#line 469
        if (bytes_copied == -1) {
#line 470
          tmp___64 = __errno_location();
#line 470
          tmp___65 = strerror(*tmp___64);
#line 470
          err_log(5, 2U, (char *)"Error copying file to remote... %s\n", tmp___65);
        } else {
#line 473
          err_log(5, 2U, (char *)"Finished streaming file to remote: %d bytes\n",
                  bytes_copied);
        }
#line 477
        config_set_status(pwsc, session_id, (char *)((void *)0));
#line 478
        r_close(file_fd);
#line 479
        db_dispose(pmp3);
#line 480
        free((void *)pmp3);
      }
    }
  }
#line 485
  err_log(9, 514U, (char *)"Finished serving DAAP response\n");
#line 487
  return;
}
}
#line 493 "main.c"
static int daemon_start(void) 
{ int childpid ;
  int fd ;
  int *tmp ;

  {
#line 496
  signal(22, (void (*)(int  ))1);
#line 497
  signal(21, (void (*)(int  ))1);
#line 498
  signal(20, (void (*)(int  ))1);
#line 501
  childpid = fork();
#line 501
  if (childpid < 0) {
#line 502
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Can\'t fork!\n");
#line 503
    return (-1);
  } else {
#line 504
    if (childpid > 0) {
#line 505
      exit(0);
    }
  }
#line 508
  setpgrp();
#line 520
  fd = open("/dev/null", 2, 0);
#line 520
  if (fd != -1) {
#line 521
    dup2(fd, 0);
#line 522
    dup2(fd, 1);
#line 523
    dup2(fd, 2);
#line 524
    if (fd > 2) {
#line 525
      close(fd);
    }
  }
#line 533
  tmp = __errno_location();
#line 533
  *tmp = 0;
#line 535
  chdir("/");
#line 536
  umask(0U);
#line 538
  return (0);
}
}
#line 546 "main.c"
static void usage(char *program ) 
{ 

  {
#line 547
  printf((char const   * __restrict  )"Usage: %s [options]\n\n", program);
#line 548
  printf((char const   * __restrict  )"Options:\n");
#line 549
  printf((char const   * __restrict  )"  -d <number>    Debuglevel (0-9)\n");
#line 550
  printf((char const   * __restrict  )"  -D <mod,mod..> Debug modules\n");
#line 551
  printf((char const   * __restrict  )"  -m             Disable mDNS\n");
#line 552
  printf((char const   * __restrict  )"  -c <file>      Use configfile specified\n");
#line 553
  printf((char const   * __restrict  )"  -p             Parse playlist file\n");
#line 554
  printf((char const   * __restrict  )"  -f             Run in foreground\n");
#line 555
  printf((char const   * __restrict  )"  -y             Yes, go ahead and run as non-root user\n");
#line 556
  printf((char const   * __restrict  )"\n\n");
#line 557
  printf((char const   * __restrict  )"Valid debug modules:\n");
#line 558
  printf((char const   * __restrict  )" config,webserver,database,scan,query,index,browse\n");
#line 559
  printf((char const   * __restrict  )" playlist,art,daap,main,rend,misc\n");
#line 560
  printf((char const   * __restrict  )"\n\n");
#line 561
  return;
}
}
#line 571 "main.c"
int drop_privs(char *user ) 
{ int err ;
  struct passwd *pw ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  __uid_t tmp___8 ;

  {
#line 573
  pw = (struct passwd *)((void *)0);
#line 576
  tmp___8 = getuid();
#line 576
  if (tmp___8 == 0U) {
#line 577
    tmp___0 = atoi((char const   *)user);
#line 577
    if (tmp___0) {
#line 578
      tmp = atoi((char const   *)user);
#line 578
      pw = getpwuid((unsigned int )tmp);
    } else {
#line 580
      pw = getpwnam((char const   *)config.runas);
    }
#line 583
    if (pw) {
#line 584
      tmp___3 = initgroups((char const   *)user, pw->pw_gid);
#line 584
      if (tmp___3 != 0) {
        goto _L;
      } else {
#line 584
        tmp___4 = setgid(pw->pw_gid);
#line 584
        if (tmp___4 != 0) {
          goto _L;
        } else {
#line 584
          tmp___5 = setuid(pw->pw_uid);
#line 584
          if (tmp___5 != 0) {
            _L: /* CIL Label */ 
#line 587
            tmp___1 = __errno_location();
#line 587
            err = *tmp___1;
#line 588
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Couldn\'t change to %s, gid=%d, uid=%d\n",
                    user, pw->pw_gid, pw->pw_uid);
#line 590
            tmp___2 = __errno_location();
#line 590
            *tmp___2 = err;
#line 591
            return (-1);
          }
        }
      }
    } else {
#line 594
      tmp___6 = __errno_location();
#line 594
      err = *tmp___6;
#line 595
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Couldn\'t lookup user %s\n",
              user);
#line 596
      tmp___7 = __errno_location();
#line 596
      *tmp___7 = err;
#line 597
      return (-1);
    }
  }
#line 601
  return (0);
}
}
#line 614 "main.c"
static void *signal_handler(void *arg ) 
{ sigset_t intmask ;
  int sig ;
  int status ;
  __pid_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 619
  config.stop = 0;
#line 620
  config.reload = 0;
#line 621
  config.pid = getpid();
#line 623
  err_log(2, 1024U, (char *)"Signal handler started\n");
#line 625
  while (! config.stop) {
#line 626
    tmp___0 = sigemptyset(& intmask);
#line 626
    if (tmp___0 == -1) {
#line 631
      err_log(0, 1024U, (char *)"Error waiting for signals.  Aborting\n");
    } else {
#line 626
      tmp___1 = sigaddset(& intmask, 17);
#line 626
      if (tmp___1 == -1) {
#line 631
        err_log(0, 1024U, (char *)"Error waiting for signals.  Aborting\n");
      } else {
#line 626
        tmp___2 = sigaddset(& intmask, 2);
#line 626
        if (tmp___2 == -1) {
#line 631
          err_log(0, 1024U, (char *)"Error waiting for signals.  Aborting\n");
        } else {
#line 626
          tmp___3 = sigaddset(& intmask, 1);
#line 626
          if (tmp___3 == -1) {
#line 631
            err_log(0, 1024U, (char *)"Error waiting for signals.  Aborting\n");
          } else {
#line 626
            tmp___4 = sigwait((sigset_t const   * __restrict  )(& intmask), (int * __restrict  )(& sig));
#line 626
            if (tmp___4 == -1) {
#line 631
              err_log(0, 1024U, (char *)"Error waiting for signals.  Aborting\n");
            } else {
#line 634
              switch (sig) {
              case 17: 
#line 636
              err_log(1, 1024U, (char *)"Got CLD signal.  Reaping\n");
#line 637
              while (1) {
#line 637
                tmp = wait((union wait *)(& status));
#line 637
                if (! tmp) {
#line 637
                  break;
                }
              }
#line 639
              break;
              case 2: 
#line 641
              err_log(1, 1024U, (char *)"Got INT signal. Notifying daap server.\n");
#line 642
              config.stop = 1;
#line 643
              return ((void *)0);
#line 644
              break;
              case 1: 
#line 646
              err_log(1, 1024U, (char *)"Got HUP signal. Notifying daap server.\n");
#line 647
              config.reload = 1;
#line 648
              break;
              default: 
#line 650
              err_log(1, 1024U, (char *)"What am I doing here?\n");
#line 651
              break;
              }
            }
          }
        }
      }
    }
  }
#line 656
  return ((void *)0);
}
}
#line 666 "main.c"
static int start_signal_handler(pthread_t *handler_tid ) 
{ int error ;
  sigset_t set ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
#line 670
  tmp = sigemptyset(& set);
#line 670
  if (tmp == -1) {
#line 675
    err_log(1, 1024U, (char *)"Error setting signal set\n");
#line 676
    return (-1);
  } else {
#line 670
    tmp___0 = sigaddset(& set, 2);
#line 670
    if (tmp___0 == -1) {
#line 675
      err_log(1, 1024U, (char *)"Error setting signal set\n");
#line 676
      return (-1);
    } else {
#line 670
      tmp___1 = sigaddset(& set, 1);
#line 670
      if (tmp___1 == -1) {
#line 675
        err_log(1, 1024U, (char *)"Error setting signal set\n");
#line 676
        return (-1);
      } else {
#line 670
        tmp___2 = sigaddset(& set, 17);
#line 670
        if (tmp___2 == -1) {
#line 675
          err_log(1, 1024U, (char *)"Error setting signal set\n");
#line 676
          return (-1);
        } else {
#line 670
          tmp___3 = sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )((void *)0));
#line 670
          if (tmp___3 == -1) {
#line 675
            err_log(1, 1024U, (char *)"Error setting signal set\n");
#line 676
            return (-1);
          }
        }
      }
    }
  }
#line 679
  error = pthread_create((pthread_t * __restrict  )handler_tid, (pthread_attr_t const   * __restrict  )((void *)0),
                         & signal_handler, (void * __restrict  )((void *)0));
#line 679
  if (error) {
#line 680
    tmp___4 = __errno_location();
#line 680
    *tmp___4 = error;
#line 681
    err_log(1, 1024U, (char *)"Error creating signal_handler thread\n");
#line 682
    return (-1);
  }
#line 687
  return (0);
}
}
#line 708 "main.c"
int main(int argc , char **argv ) 
{ int option ;
  char *configfile ;
  WSCONFIG ws_config ;
  WSHANDLE server ;
  int parseonly ;
  int foreground ;
  int reload ;
  int start_time ;
  int end_time ;
  int rescan_counter ;
  int old_song_count ;
  int force_non_root ;
  pthread_t signal_tid ;
  int pid_fd ;
  FILE *pid_fp ;
  int tmp ;
  __uid_t tmp___0 ;
  time_t tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  time_t tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  time_t tmp___30 ;
  int tmp___31 ;
  time_t tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 710
  configfile = (char *)"/etc/mt-daapd.conf";
#line 713
  parseonly = 0;
#line 714
  foreground = 0;
#line 715
  reload = 0;
#line 718
  rescan_counter = 0;
#line 720
  force_non_root = 0;
#line 724
  pid_fp = (FILE *)((void *)0);
#line 726
  config.use_mdns = 1;
#line 727
  err_debuglevel = 1;
#line 729
  while (1) {
#line 729
    option = getopt(argc, (char * const  *)argv, "D:d:c:mpfry");
#line 729
    if (! (option != -1)) {
#line 729
      break;
    }
#line 730
    switch (option) {
    case 100: 
#line 732
    err_debuglevel = atoi((char const   *)optarg);
#line 733
    break;
    case 68: 
#line 735
    tmp = err_setdebugmask(optarg);
#line 735
    if (tmp) {
#line 736
      usage(*(argv + 0));
#line 737
      exit(1);
    }
#line 739
    break;
    case 102: 
#line 741
    foreground = 1;
#line 742
    break;
    case 99: 
#line 745
    configfile = optarg;
#line 746
    break;
    case 109: 
#line 749
    config.use_mdns = 0;
#line 750
    break;
    case 112: 
#line 753
    parseonly = 1;
#line 754
    foreground = 1;
#line 755
    break;
    case 114: 
#line 758
    reload = 1;
#line 759
    break;
    case 121: 
#line 762
    force_non_root = 1;
#line 763
    break;
    default: 
#line 766
    usage(*(argv + 0));
#line 767
    exit(1);
#line 768
    break;
    }
  }
#line 772
  tmp___0 = getuid();
#line 772
  if (tmp___0) {
#line 772
    if (! force_non_root) {
#line 773
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"You are not root.  This is almost certainly wrong.  If you are\nsure you want to do this, use the -y command-line switch\n");
#line 775
      exit(1);
    }
  }
#line 780
  tmp___1 = time((time_t *)((void *)0));
#line 780
  start_time = (int )tmp___1;
#line 780
  config.stats.start_time = (long )start_time;
#line 782
  tmp___2 = config_read(configfile);
#line 782
  if (tmp___2) {
#line 783
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error reading config file (%s)\n",
            configfile);
#line 784
    exit(1);
  }
#line 787
  if (! foreground) {
#line 788
    if (config.logfile) {
#line 789
      err_setdest(config.logfile, 2);
    } else {
#line 791
      err_setdest((char *)"mt-daapd", 1);
    }
  }
#line 796
  if (config.use_mdns) {
#line 796
    if (! parseonly) {
#line 797
      err_log(1, 1024U, (char *)"Starting rendezvous daemon\n");
#line 798
      tmp___5 = rend_init(config.runas);
#line 798
      if (tmp___5) {
#line 799
        tmp___3 = __errno_location();
#line 799
        tmp___4 = strerror(*tmp___3);
#line 799
        err_log(0, 3072U, (char *)"Error in rend_init: %s\n", tmp___4);
      }
    }
  }
#line 805
  if (! foreground) {
#line 805
    if (! force_non_root) {
#line 806
      pid_fd = open("/var/run/mt-daapd.pid", 577, 420);
#line 806
      if (-1 == pid_fd) {
#line 807
        tmp___6 = __errno_location();
#line 807
        tmp___7 = strerror(*tmp___6);
#line 807
        err_log(0, 1024U, (char *)"Error opening pidfile (%s): %s\n", "/var/run/mt-daapd.pid",
                tmp___7);
      }
#line 809
      pid_fp = fdopen(pid_fd, "w");
#line 809
      if ((unsigned int )((FILE *)0) == (unsigned int )pid_fp) {
#line 810
        tmp___8 = __errno_location();
#line 810
        tmp___9 = strerror(*tmp___8);
#line 810
        err_log(0, 1024U, (char *)"fdopen: %s\n", tmp___9);
      }
#line 812
      daemon_start();
#line 815
      config.pid = 0;
    }
  }
#line 819
  tmp___12 = db_open(config.dbdir, reload);
#line 819
  if (tmp___12) {
#line 820
    tmp___10 = __errno_location();
#line 820
    tmp___11 = strerror(*tmp___10);
#line 820
    err_log(0, 1028U, (char *)"Error in db_open: %s\n", tmp___11);
  }
#line 824
  tmp___15 = drop_privs(config.runas);
#line 824
  if (tmp___15) {
#line 825
    tmp___13 = __errno_location();
#line 825
    tmp___14 = strerror(*tmp___13);
#line 825
    err_log(0, 1024U, (char *)"Error in drop_privs: %s\n", tmp___14);
  }
#line 829
  err_log(1, 1024U, (char *)"Starting signal handler\n");
#line 830
  tmp___18 = start_signal_handler(& signal_tid);
#line 830
  if (tmp___18) {
#line 831
    tmp___16 = __errno_location();
#line 831
    tmp___17 = strerror(*tmp___16);
#line 831
    err_log(0, 1024U, (char *)"Error starting signal handler %s\n", tmp___17);
  }
#line 835
  if (pid_fp) {
#line 837
    while (! config.pid) {
#line 838
      sleep(1U);
    }
#line 841
    fprintf((FILE * __restrict  )pid_fp, (char const   * __restrict  )"%d\n", config.pid);
#line 842
    fclose(pid_fp);
  }
#line 845
  err_log(1, 1152U, (char *)"Loading playlists\n");
#line 847
  if (config.playlist) {
#line 848
    pl_load(config.playlist);
  }
#line 850
  if (parseonly) {
#line 851
    if (! pl_error) {
#line 852
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Parsed successfully.\n");
#line 853
      pl_dump();
    }
#line 855
    exit(0);
  }
#line 859
  err_log(1, 1028U, (char *)"Initializing database\n");
#line 860
  tmp___21 = db_init();
#line 860
  if (tmp___21) {
#line 861
    tmp___19 = __errno_location();
#line 861
    tmp___20 = strerror(*tmp___19);
#line 861
    err_log(0, 1028U, (char *)"Error in db_init: %s\n", tmp___20);
  }
#line 864
  err_log(1, 1032U, (char *)"Starting mp3 scan\n");
#line 865
  tmp___24 = scan_init(config.mp3dir);
#line 865
  if (tmp___24) {
#line 866
    tmp___22 = __errno_location();
#line 866
    tmp___23 = strerror(*tmp___22);
#line 866
    err_log(0, 1032U, (char *)"Error scanning MP3 files: %s\n", tmp___23);
  }
#line 870
  ws_config.web_root = config.web_root;
#line 871
  ws_config.port = (unsigned short )config.port;
#line 873
  err_log(1, 1026U, (char *)"Starting web server from %s on port %d\n", config.web_root,
          config.port);
#line 876
  server = ws_start(& ws_config);
#line 877
  if (! server) {
#line 878
    tmp___25 = __errno_location();
#line 878
    tmp___26 = strerror(*tmp___25);
#line 878
    err_log(0, 1026U, (char *)"Error staring web server: %s\n", tmp___26);
  }
#line 881
  ws_registerhandler(server, (char *)"^.*$", & config_handler, & config_auth, 1);
#line 882
  ws_registerhandler(server, (char *)"^/server-info$", & daap_handler, (int (*)(char * ,
                                                                                char * ))((void *)0),
                     0);
#line 883
  ws_registerhandler(server, (char *)"^/content-codes$", & daap_handler, (int (*)(char * ,
                                                                                  char * ))((void *)0),
                     0);
#line 884
  ws_registerhandler(server, (char *)"^/login$", & daap_handler, & daap_auth, 0);
#line 885
  ws_registerhandler(server, (char *)"^/update$", & daap_handler, & daap_auth, 0);
#line 886
  ws_registerhandler(server, (char *)"^/databases$", & daap_handler, & daap_auth,
                     0);
#line 887
  ws_registerhandler(server, (char *)"^/logout$", & daap_handler, (int (*)(char * ,
                                                                           char * ))((void *)0),
                     0);
#line 888
  ws_registerhandler(server, (char *)"^/databases/.*", & daap_handler, (int (*)(char * ,
                                                                                char * ))((void *)0),
                     0);
#line 891
  if (config.use_mdns) {
#line 892
    err_log(1, 3072U, (char *)"Registering rendezvous names\n");
#line 893
    rend_register(config.servername, (char *)"_daap._tcp", config.port);
#line 894
    rend_register(config.servername, (char *)"_http._tcp", config.port);
  }
#line 898
  tmp___27 = time((time_t *)((void *)0));
#line 898
  end_time = (int )tmp___27;
#line 900
  tmp___28 = db_get_song_count();
#line 900
  err_log(1, 1024U, (char *)"Scanned %d songs in  %d seconds\n", tmp___28, end_time - start_time);
#line 903
  config.stop = 0;
#line 905
  while (! config.stop) {
#line 906
    if (config.rescan_interval) {
#line 906
      if (rescan_counter > config.rescan_interval) {
#line 907
        if (config.always_scan) {
#line 908
          config.reload = 1;
        } else {
#line 907
          tmp___29 = config_get_session_count();
#line 907
          if (tmp___29) {
#line 908
            config.reload = 1;
          } else {
#line 910
            err_log(9, 1036U, (char *)"Skipped bground scan... no users\n");
          }
        }
#line 912
        rescan_counter = 0;
      }
    }
#line 915
    if (config.reload) {
#line 916
      old_song_count = db_get_song_count();
#line 917
      tmp___30 = time((time_t *)((void *)0));
#line 917
      start_time = (int )tmp___30;
#line 919
      err_log(1, 1036U, (char *)"Rescanning database\n");
#line 920
      tmp___31 = scan_init(config.mp3dir);
#line 920
      if (tmp___31) {
#line 921
        err_log(1, 1036U, (char *)"Error rescanning... exiting\n");
#line 922
        config.stop = 1;
      }
#line 924
      config.reload = 0;
#line 925
      tmp___32 = time((time_t *)((void *)0));
#line 925
      tmp___33 = db_get_song_count();
#line 925
      err_log(5, 1036U, (char *)"Scanned %d songs (was %d) in %d seconds\n", tmp___33,
              old_song_count, tmp___32 - (time_t )start_time);
    }
#line 929
    sleep(2U);
#line 930
    rescan_counter += 2;
  }
#line 933
  err_log(1, 1024U, (char *)"Stopping gracefully\n");
#line 936
  if (config.use_mdns) {
#line 937
    err_log(1, 3072U, (char *)"Stopping rendezvous daemon\n");
#line 938
    rend_stop();
  }
#line 942
  err_log(1, 1024U, (char *)"Stopping signal handler\n");
#line 943
  tmp___34 = pthread_kill(signal_tid, 2);
#line 943
  if (! tmp___34) {
#line 944
    pthread_join(signal_tid, (void **)((void *)0));
  }
#line 955
  config_close();
#line 957
  err_log(1, 1028U, (char *)"Closing database\n");
#line 958
  db_deinit();
#line 965
  err_log(1, 1024U, (char *)"Done!\n");
#line 967
  err_setdest((char *)((void *)0), 0);
#line 969
  return (0);
}
}
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned int  ) ;  */
#line 1 "uici.o"
#pragma merger(0,"/tmp/cil-WSDkbveA.i","-g,-g,-O2")
#line 260 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 110
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 192
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 199
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 209
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 35 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t inet_addr(char const   *__cp ) ;
#line 54
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 138 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 41 "uici.h"
int u_open(u_port_t port ) ;
#line 42
int u_accept(int fd , char *hostn , int hostnsize ) ;
#line 43
int u_connect(u_port_t port , char *hostn ) ;
#line 63 "uici.c"
static int u_ignore_sigpipe(void) 
{ struct sigaction act ;
  int tmp ;
  int tmp___0 ;

  {
#line 66
  tmp = sigaction(13, (struct sigaction  const  * __restrict  )((struct sigaction *)((void *)0)),
                  (struct sigaction * __restrict  )(& act));
#line 66
  if (tmp == -1) {
#line 67
    return (-1);
  }
#line 68
  if ((unsigned int )act.__sigaction_handler.sa_handler == (unsigned int )((void (*)(int  ))0)) {
#line 69
    act.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 70
    tmp___0 = sigaction(13, (struct sigaction  const  * __restrict  )(& act), (struct sigaction * __restrict  )((struct sigaction *)((void *)0)));
#line 70
    if (tmp___0 == -1) {
#line 71
      return (-1);
    }
  }
#line 73
  return (0);
}
}
#line 85 "uici.c"
int u_open(u_port_t port ) 
{ int error ;
  struct sockaddr_in server ;
  int sock ;
  int true ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  register unsigned int __v ;
  register unsigned int __x ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 89
  true = 1;
#line 91
  tmp = u_ignore_sigpipe();
#line 91
  if (tmp == -1) {
#line 93
    return (-1);
  } else {
#line 91
    sock = socket(2, 1, 0);
#line 91
    if (sock == -1) {
#line 93
      return (-1);
    }
  }
#line 95
  tmp___4 = setsockopt(sock, 1, 2, (void const   *)((char *)(& true)), sizeof(true));
#line 95
  if (tmp___4 == -1) {
#line 97
    tmp___0 = __errno_location();
#line 97
    error = *tmp___0;
#line 98
    while (1) {
#line 98
      tmp___1 = close(sock);
#line 98
      if (tmp___1 == -1) {
#line 98
        tmp___2 = __errno_location();
#line 98
        if (! (*tmp___2 == 4)) {
#line 98
          break;
        }
      } else {
#line 98
        break;
      }
    }
#line 99
    tmp___3 = __errno_location();
#line 99
    *tmp___3 = error;
#line 100
    return (-1);
  }
#line 103
  server.sin_family = (unsigned short)2;
#line 104
  __x = 0U;
#line 104
  __asm__  ("bswap %0": "=r" (__v): "0" (__x));
#line 104
  server.sin_addr.s_addr = __v;
#line 105
  __x___0 = (unsigned short )((short )port);
#line 105
  __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 105
  server.sin_port = __v___0;
#line 106
  tmp___9 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& server)),
                 sizeof(server));
#line 106
  if (tmp___9 == -1) {
    goto _L;
  } else {
#line 106
    tmp___10 = listen(sock, 50);
#line 106
    if (tmp___10 == -1) {
      _L: /* CIL Label */ 
#line 108
      tmp___5 = __errno_location();
#line 108
      error = *tmp___5;
#line 109
      while (1) {
#line 109
        tmp___6 = close(sock);
#line 109
        if (tmp___6 == -1) {
#line 109
          tmp___7 = __errno_location();
#line 109
          if (! (*tmp___7 == 4)) {
#line 109
            break;
          }
        } else {
#line 109
          break;
        }
      }
#line 110
      tmp___8 = __errno_location();
#line 110
      *tmp___8 = error;
#line 111
      return (-1);
    }
  }
#line 113
  return (sock);
}
}
#line 137 "uici.c"
int u_accept(int fd , char *hostn , int hostnsize ) 
{ int len ;
  struct sockaddr_in netclient ;
  int retval ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 138
  len = (int )sizeof(struct sockaddr );
#line 142
  while (1) {
#line 142
    retval = accept(fd, (struct sockaddr * __restrict  )((struct sockaddr *)(& netclient)),
                    (socklen_t * __restrict  )(& len));
#line 142
    if (retval == -1) {
#line 142
      tmp = __errno_location();
#line 142
      if (! (*tmp == 4)) {
#line 142
        break;
      }
    } else {
#line 142
      break;
    }
  }
#line 146
  if (retval == -1) {
#line 147
    return (retval);
  } else {
#line 146
    if ((unsigned int )hostn == (unsigned int )((void *)0)) {
#line 147
      return (retval);
    } else {
#line 146
      if (hostnsize <= 0) {
#line 147
        return (retval);
      }
    }
  }
#line 149
  tmp___0 = inet_ntoa(netclient.sin_addr);
#line 149
  __builtin_strncpy(hostn, (char const   *)tmp___0, (unsigned int )hostnsize);
#line 150
  return (retval);
}
}
#line 163 "uici.c"
int u_connect(u_port_t port , char *hostn ) 
{ int error ;
  int retval ;
  struct sockaddr_in server ;
  int sock ;
  fd_set sockset ;
  struct hostent *phe ;
  int *tmp ;
  in_addr_t tmp___0 ;
  register unsigned short __v ;
  register unsigned short __x ;
  int tmp___1 ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;

  {
#line 175
  tmp___0 = inet_addr((char const   *)hostn);
#line 175
  if (tmp___0 == 4294967295U) {
#line 176
    phe = gethostbyname((char const   *)hostn);
#line 177
    if ((unsigned int )phe == (unsigned int )((void *)0)) {
#line 178
      tmp = __errno_location();
#line 178
      *tmp = 22;
#line 179
      return (-1);
    }
#line 182
    memcpy((void * __restrict  )((char *)(& server.sin_addr)), (void const   * __restrict  )*(phe->h_addr_list + 0),
           sizeof(struct in_addr ));
  } else {
#line 185
    server.sin_addr.s_addr = inet_addr((char const   *)hostn);
  }
#line 188
  __x = (unsigned short )((short )port);
#line 188
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 188
  server.sin_port = __v;
#line 189
  server.sin_family = (unsigned short)2;
#line 191
  tmp___1 = u_ignore_sigpipe();
#line 191
  if (tmp___1 == -1) {
#line 193
    return (-1);
  } else {
#line 191
    sock = socket(2, 1, 0);
#line 191
    if (sock == -1) {
#line 193
      return (-1);
    }
  }
#line 195
  retval = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& server)),
                   sizeof(server));
#line 195
  if (retval == -1) {
#line 195
    tmp___3 = __errno_location();
#line 195
    if (*tmp___3 == 4) {
      goto _L;
    } else {
#line 195
      tmp___4 = __errno_location();
#line 195
      if (*tmp___4 == 114) {
        _L: /* CIL Label */ 
#line 198
        while (1) {
#line 198
          __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0),
                               "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& sockset.__fds_bits[0]): "memory");
#line 198
          break;
        }
#line 199
        __asm__  volatile   ("btsl %1,%0": "=m" (sockset.__fds_bits[(unsigned int )sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )sock % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
#line 200
        while (1) {
#line 200
          retval = select(sock + 1, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )(& sockset),
                          (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 200
          if (retval == -1) {
#line 200
            tmp___2 = __errno_location();
#line 200
            if (! (*tmp___2 == 4)) {
#line 200
              break;
            }
          } else {
#line 200
            break;
          }
#line 202
          while (1) {
#line 202
            __asm__  volatile   ("cld; rep; stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0),
                                 "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& sockset.__fds_bits[0]): "memory");
#line 202
            break;
          }
#line 203
          __asm__  volatile   ("btsl %1,%0": "=m" (sockset.__fds_bits[(unsigned int )sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )sock % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
      }
    }
  }
#line 206
  if (retval == -1) {
#line 207
    tmp___5 = __errno_location();
#line 207
    error = *tmp___5;
#line 208
    while (1) {
#line 208
      tmp___6 = close(sock);
#line 208
      if (tmp___6 == -1) {
#line 208
        tmp___7 = __errno_location();
#line 208
        if (! (*tmp___7 == 4)) {
#line 208
          break;
        }
      } else {
#line 208
        break;
      }
    }
#line 209
    tmp___8 = __errno_location();
#line 209
    *tmp___8 = error;
#line 210
    return (-1);
  }
#line 212
  return (sock);
}
}
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "webserver.o"
#pragma merger(0,"/tmp/cil-566DCBal.i","-g,-g,-O2")
#line 83 "/usr/include/ctype.h"
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 116
__inline static  __attribute__((__nothrow__)) int tolower___0(int __c ) ;
#line 190
__inline static  __attribute__((__nothrow__)) int tolower___0(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline static int tolower___0(int __c ) 
{ __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
#line 193
      tmp = __ctype_tolower_loc();
#line 193
      tmp___0 = *(*tmp + __c);
    } else {
#line 193
      tmp___0 = (int const   )__c;
    }
  } else {
#line 193
    tmp___0 = (int const   )__c;
  }
#line 193
  return ((int )tmp___0);
}
}
#line 242 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t const   * __restrict  __timer ,
                                                         struct tm * __restrict  __tp ) ;
#line 230 "/usr/include/pthread.h"
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
#line 259
extern  __attribute__((__nothrow__)) int pthread_detach(pthread_t __th ) ;
#line 715
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t const   *__mutexattr )  __attribute__((__nonnull__(1))) ;
#line 728
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
#line 739
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
#line 922
extern  __attribute__((__nothrow__)) int pthread_cond_init(pthread_cond_t * __restrict  __cond ,
                                                           pthread_condattr_t const   * __restrict  __cond_attr )  __attribute__((__nonnull__(1))) ;
#line 931
extern  __attribute__((__nothrow__)) int pthread_cond_signal(pthread_cond_t *__cond )  __attribute__((__nonnull__(1))) ;
#line 943
extern int pthread_cond_wait(pthread_cond_t * __restrict  __cond , pthread_mutex_t * __restrict  __mutex )  __attribute__((__nonnull__(1,2))) ;
#line 537 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 541
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 549
extern void regfree(regex_t *__preg ) ;
#line 53 "./restart.h"
ssize_t r_write(int fd , void *buf , size_t size ) ;
#line 55
int readline(int fd , char *buf , int nbytes ) ;
#line 56
int readlinetimed(int fd , char *buf , int nbytes , double seconds ) ;
#line 57
ssize_t readtimed(int fd , void *buf , size_t nbyte , double seconds ) ;
#line 355 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 359
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 589
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 757
extern  __attribute__((__nothrow__)) char *realpath(char const   * __restrict  __name ,
                                                    char * __restrict  __resolved ) ;
#line 59 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 194
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 1205 "/usr/include/bits/string2.h"
extern char *__strsep_g(char **__stringp , char const   *__delim ) ;
#line 218 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 73 "webserver.h"
extern int ws_stop(WSHANDLE ws ) ;
#line 80
void ws_close(WS_CONNINFO *pwsc ) ;
#line 90 "webserver.c"
void *ws_mainthread(void *arg ) ;
#line 91
void *ws_dispatcher(void *arg ) ;
#line 92
int ws_lock_unsafe(void) ;
#line 93
int ws_unlock_unsafe(void) ;
#line 94
void ws_defaulthandler(WS_PRIVATE *pwsp , WS_CONNINFO *pwsc ) ;
#line 95
int ws_addarg(ARGLIST *root , char *key , char *fmt  , ...) ;
#line 96
void ws_freearglist(ARGLIST *root ) ;
#line 97
char *ws_urldecode(char *string , int space_as_plus ) ;
#line 98
int ws_getheaders(WS_CONNINFO *pwsc ) ;
#line 99
int ws_getpostvars(WS_CONNINFO *pwsc ) ;
#line 100
int ws_getgetvars(WS_CONNINFO *pwsc , char *string ) ;
#line 101
char *ws_getarg(ARGLIST *root , char *key ) ;
#line 102
int ws_testarg(ARGLIST *root , char *key , char *value ) ;
#line 103
int ws_findhandler(WS_PRIVATE *pwsp , WS_CONNINFO *pwsc , void (**preq)(WS_CONNINFO * ) ,
                   int (**pauth)(char * , char * ) , int *addheaders ) ;
#line 111
int ws_decodepassword(char *header , char **username , char **password ) ;
#line 114
static void ws_add_dispatch_thread(WS_PRIVATE *pwsp , WS_CONNINFO *pwsc ) ;
#line 115
static void ws_remove_dispatch_thread(WS_PRIVATE *pwsp , WS_CONNINFO *pwsc ) ;
#line 116
static int ws_encoding_hack(WS_CONNINFO *pwsc ) ;
#line 121 "webserver.c"
pthread_mutex_t ws_unsafe  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 123 "webserver.c"
char *ws_dow[7]  = {      (char *)"Sun",      (char *)"Mon",      (char *)"Tue",      (char *)"Wed", 
        (char *)"Thu",      (char *)"Fri",      (char *)"Sat"};
#line 124 "webserver.c"
char *ws_moy[12]  = 
#line 124
  {      (char *)"Jan",      (char *)"Feb",      (char *)"Mar",      (char *)"Apr", 
        (char *)"May",      (char *)"Jun",      (char *)"Jul",      (char *)"Aug", 
        (char *)"Sep",      (char *)"Oct",      (char *)"Nov",      (char *)"Dec"};
#line 135 "webserver.c"
int ws_lock_unsafe(void) 
{ int err ;
  int retval ;
  int *tmp ;

  {
#line 137
  retval = 0;
#line 139
  err_log(10, 2U, (char *)"Entering ws_lock_unsafe\n");
#line 141
  err = pthread_mutex_lock(& ws_unsafe);
#line 141
  if (err) {
#line 142
    tmp = __errno_location();
#line 142
    *tmp = err;
#line 143
    retval = -1;
  }
#line 146
  err_log(10, 2U, (char *)"Exiting ws_lock_unsafe with retval of %d\n", retval);
#line 147
  return (retval);
}
}
#line 158 "webserver.c"
int ws_unlock_unsafe(void) 
{ int err ;
  int retval ;
  int *tmp ;

  {
#line 160
  retval = 0;
#line 162
  err_log(10, 2U, (char *)"Entering ws_unlock_unsafe\n");
#line 164
  err = pthread_mutex_unlock(& ws_unsafe);
#line 164
  if (err) {
#line 165
    tmp = __errno_location();
#line 165
    *tmp = err;
#line 166
    retval = -1;
  }
#line 169
  err_log(10, 2U, (char *)"Exiting ws_unlock_unsafe with a retval of %d\n", retval);
#line 170
  return (retval);
}
}
#line 186 "webserver.c"
WSHANDLE ws_start(WSCONFIG *config___0 ) 
{ int err ;
  WS_PRIVATE *pwsp ;
  int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;

  {
#line 190
  err_log(10, 2U, (char *)"Entering ws_start\n");
#line 192
  tmp___1 = malloc(sizeof(WS_PRIVATE ));
#line 192
  pwsp = (WS_PRIVATE *)tmp___1;
#line 192
  if ((unsigned int )pwsp == (unsigned int )((void *)0)) {
#line 193
    tmp = __errno_location();
#line 193
    tmp___0 = strerror(*tmp);
#line 193
    err_log(10, 2U, (char *)"Malloc error: %s\n", tmp___0);
#line 194
    return ((void *)0);
  }
#line 197
  memcpy((void * __restrict  )(& pwsp->wsconfig), (void const   * __restrict  )config___0,
         sizeof(WS_PRIVATE ));
#line 198
  pwsp->connlist.next = (struct tag_ws_connlist *)((void *)0);
#line 199
  pwsp->running = 0;
#line 200
  pwsp->threadno = 0;
#line 201
  pwsp->stop = 0;
#line 202
  pwsp->dispatch_threads = 0;
#line 203
  pwsp->handlers.next = (struct tag_ws_handler *)((void *)0);
#line 205
  err = pthread_cond_init((pthread_cond_t * __restrict  )(& pwsp->exit_cond), (pthread_condattr_t const   * __restrict  )((void *)0));
#line 205
  if (err) {
#line 206
    tmp___2 = __errno_location();
#line 206
    *tmp___2 = err;
#line 207
    tmp___3 = __errno_location();
#line 207
    tmp___4 = strerror(*tmp___3);
#line 207
    err_log(1, 2U, (char *)"Error in pthread_cond_init: %s\n", tmp___4);
#line 208
    return ((void *)0);
  }
#line 211
  err = pthread_mutex_init(& pwsp->exit_mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 211
  if (err) {
#line 212
    tmp___5 = __errno_location();
#line 212
    *tmp___5 = err;
#line 213
    tmp___6 = __errno_location();
#line 213
    tmp___7 = strerror(*tmp___6);
#line 213
    err_log(1, 2U, (char *)"Error in pthread_mutex_init: %s\n", tmp___7);
#line 214
    return ((void *)0);
  }
#line 217
  err_log(5, 2U, (char *)"Preparing to listen on port %d\n", pwsp->wsconfig.port);
#line 219
  tmp___12 = u_open(pwsp->wsconfig.port);
#line 219
  pwsp->server_fd = tmp___12;
#line 219
  if (tmp___12 == -1) {
#line 220
    tmp___8 = __errno_location();
#line 220
    err = *tmp___8;
#line 221
    tmp___9 = __errno_location();
#line 221
    tmp___10 = strerror(*tmp___9);
#line 221
    err_log(1, 2U, (char *)"Could not open port: %s\n", tmp___10);
#line 222
    tmp___11 = __errno_location();
#line 222
    *tmp___11 = err;
#line 223
    return ((void *)0);
  }
#line 226
  err_log(5, 2U, (char *)"Starting server thread\n");
#line 227
  err = pthread_create((pthread_t * __restrict  )(& pwsp->server_tid), (pthread_attr_t const   * __restrict  )((void *)0),
                       & ws_mainthread, (void * __restrict  )((void *)pwsp));
#line 227
  if (err) {
#line 228
    tmp___13 = strerror(err);
#line 228
    err_log(1, 2U, (char *)"Could not spawn thread: %s\n", tmp___13);
#line 229
    r_close(pwsp->server_fd);
#line 230
    tmp___14 = __errno_location();
#line 230
    *tmp___14 = err;
#line 231
    return ((void *)0);
  }
#line 235
  pwsp->running = 1;
#line 237
  err_log(10, 2U, (char *)"Exiting ws_start\n");
#line 238
  return ((void *)pwsp);
}
}
#line 247 "webserver.c"
static void ws_remove_dispatch_thread(WS_PRIVATE *pwsp , WS_CONNINFO *pwsc ) 
{ WS_CONNLIST *pHead ;
  WS_CONNLIST *pTail ;
  int tmp ;

  {
#line 250
  err_log(10, 2U, (char *)"Entering ws_remove_dispatch_thread\n");
#line 252
  tmp = pthread_mutex_lock(& pwsp->exit_mutex);
#line 252
  if (tmp) {
#line 253
    err_log(0, 2U, (char *)"Cannot lock condition mutex\n");
  }
#line 255
  pTail = & pwsp->connlist;
#line 256
  pHead = pwsp->connlist.next;
#line 258
  while (1) {
#line 258
    if (pHead) {
#line 258
      if (! ((unsigned int )pHead->pwsc != (unsigned int )pwsc)) {
#line 258
        break;
      }
    } else {
#line 258
      break;
    }
#line 259
    pTail = pHead;
#line 260
    pHead = pHead->next;
  }
#line 263
  if (pHead) {
#line 264
    (pwsp->dispatch_threads) --;
#line 265
    err_log(9, 2U, (char *)"With thread %d exiting, %d are still running\n", pwsc->threadno,
            pwsp->dispatch_threads);
#line 268
    pTail->next = pHead->next;
#line 270
    if (pHead->status) {
#line 271
      free((void *)pHead->status);
    }
#line 272
    free((void *)pHead);
#line 275
    pthread_cond_signal(& pwsp->exit_cond);
  }
#line 278
  pthread_mutex_unlock(& pwsp->exit_mutex);
#line 279
  err_log(10, 2U, (char *)"Exiting ws_remote_dispatch_thread\n");
#line 280
  return;
}
}
#line 288 "webserver.c"
static void ws_add_dispatch_thread(WS_PRIVATE *pwsp , WS_CONNINFO *pwsc ) 
{ WS_CONNLIST *pNew ;
  void *tmp ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
#line 291
  err_log(10, 2U, (char *)"Entering ws_add_dispatch_thread\n");
#line 293
  tmp = malloc(sizeof(WS_CONNLIST ));
#line 293
  pNew = (WS_CONNLIST *)tmp;
#line 294
  pNew->next = (struct tag_ws_connlist *)((void *)0);
#line 295
  pNew->pwsc = pwsc;
#line 296
  tmp___5 = __strdup("Initializing");
#line 296
  pNew->status = tmp___5;
#line 298
  if (! pNew) {
#line 299
    tmp___6 = __errno_location();
#line 299
    tmp___7 = strerror(*tmp___6);
#line 299
    err_log(0, 2U, (char *)"Malloc: %s\n", tmp___7);
  }
#line 301
  tmp___8 = pthread_mutex_lock(& pwsp->exit_mutex);
#line 301
  if (tmp___8) {
#line 302
    err_log(0, 2U, (char *)"Cannot lock condition mutex\n");
  }
#line 305
  (pwsp->dispatch_threads) ++;
#line 306
  pNew->next = pwsp->connlist.next;
#line 307
  pwsp->connlist.next = pNew;
#line 309
  pthread_mutex_unlock(& pwsp->exit_mutex);
#line 310
  err_log(10, 2U, (char *)"Exiting ws_add_dispatch_thread\n");
#line 311
  return;
}
}
#line 318 "webserver.c"
extern int ws_stop(WSHANDLE ws ) 
{ WS_PRIVATE *pwsp ;
  WS_HANDLER *current ;
  WS_CONNLIST *pcl ;
  void *result ;
  int tmp ;

  {
#line 319
  pwsp = (WS_PRIVATE *)ws;
#line 324
  err_log(9, 2U, (char *)"Entering ws_stop: %d threads\n", pwsp->dispatch_threads);
#line 327
  while (pwsp->handlers.next) {
#line 328
    current = pwsp->handlers.next;
#line 329
    pwsp->handlers.next = current->next;
#line 330
    regfree(& current->regex);
#line 331
    free((void *)current);
  }
#line 334
  pwsp->stop = 1;
#line 335
  pwsp->running = 0;
#line 337
  err_log(9, 2U, (char *)"ws_stop: closing the server fd\n");
#line 338
  shutdown(pwsp->server_fd, 2);
#line 339
  r_close(pwsp->server_fd);
#line 342
  pthread_join(pwsp->server_tid, & result);
#line 345
  tmp = pthread_mutex_lock(& pwsp->exit_mutex);
#line 345
  if (tmp) {
#line 346
    err_log(0, 2U, (char *)"Cannot lock condition mutex\n");
  }
#line 348
  pcl = pwsp->connlist.next;
#line 353
  while (pcl) {
#line 354
    if ((pcl->pwsc)->fd) {
#line 355
      shutdown((pcl->pwsc)->fd, 2);
#line 356
      r_close((pcl->pwsc)->fd);
    }
#line 358
    pcl = pcl->next;
  }
#line 362
  while (pwsp->dispatch_threads) {
#line 363
    err_log(9, 2U, (char *)"ws_stop: I still see %d threads\n", pwsp->dispatch_threads);
#line 364
    pthread_cond_wait((pthread_cond_t * __restrict  )(& pwsp->exit_cond), (pthread_mutex_t * __restrict  )(& pwsp->exit_mutex));
  }
#line 367
  pthread_mutex_unlock(& pwsp->exit_mutex);
#line 369
  free((void *)pwsp);
#line 371
  err_log(10, 2U, (char *)"Exiting ws_stop\n");
#line 372
  return (0);
}
}
#line 387 "webserver.c"
void *ws_mainthread(void *arg ) 
{ int fd ;
  int err ;
  WS_PRIVATE *pwsp ;
  WS_CONNINFO *pwsc ;
  pthread_t tid ;
  char hostname[256] ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 390
  pwsp = (WS_PRIVATE *)arg;
#line 395
  err_log(10, 2U, (char *)"Entering ws_mainthread\n");
#line 397
  while (1) {
#line 398
    tmp = malloc(sizeof(WS_CONNINFO ));
#line 398
    pwsc = (WS_CONNINFO *)tmp;
#line 399
    if (! pwsc) {
#line 401
      tmp___0 = __errno_location();
#line 401
      tmp___1 = strerror(*tmp___0);
#line 401
      err_log(0, 2U, (char *)"Error: %s\n", tmp___1);
#line 402
      pwsp->running = 0;
#line 403
      return ((void *)0);
    }
#line 406
    memset((void *)pwsc, 0, sizeof(WS_CONNINFO ));
#line 408
    fd = u_accept(pwsp->server_fd, hostname, 256);
#line 408
    if (fd == -1) {
#line 409
      tmp___2 = __errno_location();
#line 409
      tmp___3 = strerror(*tmp___2);
#line 409
      err_log(1, 2U, (char *)"Dispatcher: accept failed: %s\n", tmp___3);
#line 410
      shutdown(pwsp->server_fd, 2);
#line 411
      r_close(pwsp->server_fd);
#line 412
      pwsp->running = 0;
#line 413
      free((void *)pwsc);
#line 415
      err_log(0, 2U, (char *)"Dispatcher: Aborting\n");
#line 416
      return ((void *)0);
    }
#line 419
    tmp___9 = __strdup((char const   *)(hostname));
#line 419
    pwsc->hostname = tmp___9;
#line 420
    pwsc->fd = fd;
#line 421
    pwsc->pwsp = (void *)pwsp;
#line 428
    ws_lock_unsafe();
#line 429
    pwsc->threadno = pwsp->threadno;
#line 430
    (pwsp->threadno) ++;
#line 431
    ws_unlock_unsafe();
#line 434
    err = pthread_create((pthread_t * __restrict  )(& tid), (pthread_attr_t const   * __restrict  )((void *)0),
                         & ws_dispatcher, (void * __restrict  )((void *)pwsc));
#line 434
    if (err) {
#line 435
      pwsc->error = err;
#line 436
      tmp___10 = strerror(err);
#line 436
      err_log(0, 2U, (char *)"Could not spawn thread: %s\n", tmp___10);
#line 437
      ws_close(pwsc);
    } else {
#line 439
      ws_add_dispatch_thread(pwsp, pwsc);
#line 440
      pthread_detach(tid);
    }
  }
#line 444
  err_log(10, 2U, (char *)"Exiting ws_mainthred\n");
}
}
#line 459 "webserver.c"
void ws_close(WS_CONNINFO *pwsc ) 
{ WS_PRIVATE *pwsp ;

  {
#line 460
  pwsp = (WS_PRIVATE *)pwsc->pwsp;
#line 463
  err_log(10, 2U, (char *)"Entering ws_close\n");
#line 467
  config_set_status(pwsc, 0, (void *)0);
#line 469
  err_log(9, 2U, (char *)"Thread %d: Terminating\n", pwsc->threadno);
#line 470
  err_log(9, 2U, (char *)"Thread %d: Freeing request headers\n", pwsc->threadno);
#line 471
  ws_freearglist(& pwsc->request_headers);
#line 472
  err_log(9, 2U, (char *)"Thread %d: Freeing response headers\n", pwsc->threadno);
#line 473
  ws_freearglist(& pwsc->response_headers);
#line 474
  err_log(9, 2U, (char *)"Thread %d: Freeing request vars\n", pwsc->threadno);
#line 475
  ws_freearglist(& pwsc->request_vars);
#line 476
  if (pwsc->uri) {
#line 477
    free((void *)pwsc->uri);
#line 478
    pwsc->uri = (char *)((void *)0);
  }
#line 481
  if (pwsc->close) {
    goto _L;
  } else {
#line 481
    if (pwsc->error) {
      _L: /* CIL Label */ 
#line 482
      err_log(9, 2U, (char *)"Thread %d: Closing fd\n", pwsc->threadno);
#line 483
      shutdown(pwsc->fd, 2);
#line 484
      r_close(pwsc->fd);
#line 485
      free((void *)pwsc->hostname);
#line 488
      ws_remove_dispatch_thread(pwsp, pwsc);
#line 490
      free((void *)pwsc);
#line 491
      err_log(10, 2U, (char *)"Exiting ws_close (thread terminating)\n");
#line 492
      pthread_exit((void *)0);
    }
  }
#line 494
  err_log(10, 2U, (char *)"Exiting ws_close (thread continuing)\n");
#line 495
  return;
}
}
#line 502 "webserver.c"
void ws_freearglist(ARGLIST *root ) 
{ ARGLIST *current ;

  {
#line 505
  err_log(10, 2U, (char *)"Entering ws_freearglist\n");
#line 507
  while (root->next) {
#line 508
    free((void *)(root->next)->key);
#line 509
    free((void *)(root->next)->value);
#line 510
    current = root->next;
#line 511
    root->next = current->next;
#line 512
    free((void *)current);
  }
#line 515
  err_log(10, 2U, (char *)"Exiting ws_freearglist\n");
#line 516
  return;
}
}
#line 519 "webserver.c"
void ws_emitheaders(WS_CONNINFO *pwsc ) 
{ ARGLIST *pcurrent ;

  {
#line 520
  pcurrent = pwsc->response_headers.next;
#line 522
  err_log(10, 2U, (char *)"Entering ws_emitheaders\n");
#line 523
  while (pcurrent) {
#line 524
    err_log(9, 2U, (char *)"Emitting reponse header %s: %s\n", pcurrent->key, pcurrent->value);
#line 526
    ws_writefd(pwsc, (char *)"%s: %s\r\n", pcurrent->key, pcurrent->value);
#line 527
    pcurrent = pcurrent->next;
  }
#line 530
  ws_writefd(pwsc, (char *)"\r\n");
#line 531
  err_log(10, 2U, (char *)"Exitin ws_emitheaders\n");
#line 532
  return;
}
}
#line 541 "webserver.c"
int ws_getpostvars(WS_CONNINFO *pwsc ) 
{ char *content_length ;
  int length ;
  char *buffer___0 ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 546
  err_log(10, 2U, (char *)"Entering ws_getpostvars\n");
#line 548
  content_length = ws_getarg(& pwsc->request_headers, (char *)"Content-Length");
#line 549
  if (! content_length) {
#line 550
    pwsc->error = 22;
#line 551
    return (-1);
  }
#line 554
  length = atoi((char const   *)content_length);
#line 555
  err_log(9, 2U, (char *)"Thread %d: Post var length: %d\n", pwsc->threadno, length);
#line 558
  tmp = malloc((unsigned int )(length + 1));
#line 558
  buffer___0 = (char *)tmp;
#line 560
  if (! buffer___0) {
#line 561
    tmp___0 = __errno_location();
#line 561
    pwsc->error = *tmp___0;
#line 562
    err_log(5, 2U, (char *)"Thread %d: Could not malloc %d bytes\n", pwsc->threadno,
            length);
#line 564
    return (-1);
  }
#line 569
  tmp___2 = readtimed(pwsc->fd, (void *)buffer___0, (unsigned int )length, 1800.0);
#line 569
  if (tmp___2 == -1) {
#line 570
    err_log(5, 2U, (char *)"Thread %d: Timeout reading post vars\n", pwsc->threadno);
#line 572
    tmp___1 = __errno_location();
#line 572
    pwsc->error = *tmp___1;
#line 573
    return (-1);
  }
#line 576
  err_log(9, 2U, (char *)"Thread %d: Read post vars: %s\n", pwsc->threadno, buffer___0);
#line 578
  pwsc->error = ws_getgetvars(pwsc, buffer___0);
#line 580
  free((void *)buffer___0);
#line 582
  err_log(10, 2U, (char *)"Exiting ws_getpostvars\n");
#line 583
  return (pwsc->error);
}
}
#line 593 "webserver.c"
int ws_getheaders(WS_CONNINFO *pwsc ) 
{ char *first ;
  char *last ;
  int done ;
  char buffer___0[4096] ;
  int *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;

  {
#line 598
  err_log(10, 2U, (char *)"Entering ws_getheaders\n");
#line 601
  done = 0;
#line 602
  while (! done) {
#line 603
    tmp___0 = readline(pwsc->fd, buffer___0, (int )sizeof(buffer___0));
#line 603
    if (tmp___0 == -1) {
#line 604
      tmp = __errno_location();
#line 604
      pwsc->error = *tmp;
#line 605
      err_log(5, 2U, (char *)"Thread %d: Unexpected close\n", pwsc->threadno);
#line 606
      return (-1);
    }
#line 609
    err_log(9, 2U, (char *)"Thread %d: Read: %s", pwsc->threadno, buffer___0);
#line 611
    first = buffer___0;
#line 612
    if ((int )buffer___0[0] == 13) {
#line 613
      first = & buffer___0[1];
    }
#line 616
    tmp___2 = strlen((char const   *)first);
#line 616
    if ((int )*(first + (tmp___2 - 1U)) == 10) {
#line 617
      tmp___1 = strlen((char const   *)first);
#line 617
      *(first + (tmp___1 - 1U)) = (char )'\000';
    }
#line 619
    tmp___6 = strlen((char const   *)first);
#line 619
    if (tmp___6 == 0U) {
#line 620
      err_log(9, 2U, (char *)"Thread %d: Headers parsed!\n", pwsc->threadno);
#line 621
      done = 1;
    } else {
#line 624
      last = first;
#line 625
      __strsep_g(& last, ":");
#line 627
      if (! last) {
#line 628
        err_log(2, 2U, (char *)"Thread %d: Invalid header: %s\n", pwsc->threadno,
                first);
      } else {
#line 631
        while ((int )*last == 32) {
#line 632
          last ++;
        }
#line 634
        while (1) {
#line 634
          tmp___4 = strlen((char const   *)last);
#line 634
          if (! ((int )*(last + (tmp___4 - 1U)) == 13)) {
#line 634
            break;
          }
#line 635
          tmp___3 = strlen((char const   *)last);
#line 635
          *(last + (tmp___3 - 1U)) = (char )'\000';
        }
#line 637
        err_log(9, 2U, (char *)"Thread %d: Adding header *%s=%s*\n", pwsc->threadno,
                first, last);
#line 640
        tmp___5 = ws_addarg(& pwsc->request_headers, first, (char *)"%s", last);
#line 640
        if (tmp___5) {
#line 641
          err_log(0, 2U, (char *)"Thread %d: Out of memory\n", pwsc->threadno);
#line 643
          pwsc->error = 12;
#line 644
          return (-1);
        }
      }
    }
  }
#line 650
  err_log(10, 2U, (char *)"Exiting ws_getheaders\n");
#line 651
  return (0);
}
}
#line 658 "webserver.c"
static int ws_encoding_hack(WS_CONNINFO *pwsc ) 
{ char *user_agent ;
  int space_as_plus ;
  int tmp ;
  int tmp___0 ;

  {
#line 660
  space_as_plus = 1;
#line 662
  user_agent = ws_getrequestheader(pwsc, (char *)"user-agent");
#line 663
  if (user_agent) {
#line 664
    tmp = strncasecmp((char const   *)user_agent, "Roku", 4U);
#line 664
    if (tmp == 0) {
#line 665
      space_as_plus = 0;
    }
#line 666
    tmp___0 = strncasecmp((char const   *)user_agent, "iTunes", 6U);
#line 666
    if (tmp___0 == 0) {
#line 667
      space_as_plus = 0;
    }
  }
#line 669
  return (space_as_plus);
}
}
#line 679 "webserver.c"
int ws_getgetvars(WS_CONNINFO *pwsc , char *string ) 
{ char *first ;
  char *last ;
  char *middle ;
  char *key ;
  char *value ;
  int done ;
  int space_as_plus ;

  {
#line 687
  err_log(9, 2U, (char *)"Thread %d: Entering ws_getgetvars (%s)\n", pwsc->threadno,
          string);
#line 690
  space_as_plus = ws_encoding_hack(pwsc);
#line 692
  done = 0;
#line 694
  first = string;
#line 696
  while (1) {
#line 696
    if (! done) {
#line 696
      if (! first) {
#line 696
        break;
      }
    } else {
#line 696
      break;
    }
#line 697
    middle = first;
#line 697
    last = middle;
#line 698
    __strsep_g(& last, "&");
#line 699
    __strsep_g(& middle, "=");
#line 701
    if (! middle) {
#line 702
      err_log(2, 2U, (char *)"Thread %d: Bad arg: %s\n", pwsc->threadno, first);
    } else {
#line 705
      key = ws_urldecode(first, space_as_plus);
#line 706
      value = ws_urldecode(middle, space_as_plus);
#line 708
      err_log(9, 2U, (char *)"Thread %d: Adding arg %s = %s\n", pwsc->threadno, key,
              value);
#line 710
      ws_addarg(& pwsc->request_vars, key, (char *)"%s", value);
#line 712
      free((void *)key);
#line 713
      free((void *)value);
    }
#line 716
    if (! last) {
#line 717
      err_log(9, 2U, (char *)"Thread %d: Done parsing GET/POST args!\n", pwsc->threadno);
#line 719
      done = 1;
    } else {
#line 721
      first = last;
    }
  }
#line 725
  err_log(10, 2U, (char *)"Exiting ws_getgetvars\n");
#line 726
  return (0);
}
}
#line 737 "webserver.c"
void *ws_dispatcher(void *arg ) 
{ WS_CONNINFO *pwsc ;
  WS_PRIVATE *pwsp ;
  char buffer___0[4096] ;
  char *first ;
  char *last ;
  int connection_done ;
  int can_dispatch ;
  char *auth ;
  char *username ;
  char *password ;
  int hdrs ;
  int handler ;
  time_t now ;
  struct tm now_tm ;
  void (*req_handler)(WS_CONNINFO * ) ;
  int (*auth_handler)(char * , char * ) ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  int tmp___16 ;
  char *tmp___18 ;
  char *tmp___24 ;
  char const   *tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;

  {
#line 738
  pwsc = (WS_CONNINFO *)arg;
#line 739
  pwsp = (WS_PRIVATE *)pwsc->pwsp;
#line 742
  connection_done = 0;
#line 751
  err_log(9, 2U, (char *)"Thread %d: Entering ws_dispatcher (Connection from %s)\n",
          pwsc->threadno, pwsc->hostname);
#line 754
  while (! connection_done) {
#line 761
    tmp___2 = readlinetimed(pwsc->fd, buffer___0, (int )sizeof(buffer___0), 1800.0);
#line 761
    if (tmp___2 < 1) {
#line 762
      tmp = __errno_location();
#line 762
      pwsc->error = *tmp;
#line 763
      pwsc->close = 1;
#line 764
      tmp___0 = __errno_location();
#line 764
      tmp___1 = strerror(*tmp___0);
#line 764
      err_log(2, 2U, (char *)"Thread %d:  could not read: %s\n", pwsc->threadno, tmp___1);
#line 766
      ws_close(pwsc);
#line 767
      return ((void *)0);
    }
#line 770
    err_log(9, 2U, (char *)"Thread %d: got request\n", pwsc->threadno);
#line 771
    err_log(8, 2U, (char *)"Request: %s", buffer___0);
#line 773
    last = buffer___0;
#line 773
    first = last;
#line 774
    __strsep_g(& last, " ");
#line 775
    if (! last) {
#line 776
      pwsc->close = 1;
#line 777
      ws_returnerror(pwsc, 400, (char *)"Bad request\n");
#line 778
      ws_close(pwsc);
#line 779
      err_log(10, 2U, (char *)"Error: bad request.  Exiting ws_dispatcher\n");
#line 780
      return ((void *)0);
    }
#line 783
    tmp___4 = strcasecmp((char const   *)first, "get");
#line 783
    if (tmp___4) {
#line 785
      tmp___3 = strcasecmp((char const   *)first, "post");
#line 785
      if (tmp___3) {
#line 789
        pwsc->error = 22;
#line 790
        pwsc->close = 1;
#line 791
        ws_returnerror(pwsc, 501, (char *)"Not implemented");
#line 792
        ws_close(pwsc);
#line 793
        err_log(10, 2U, (char *)"Error: not get or post.  Exiting ws_dispatcher\n");
#line 794
        return ((void *)0);
      } else {
#line 786
        pwsc->request_type = 1;
      }
    } else {
#line 784
      pwsc->request_type = 0;
    }
#line 797
    first = last;
#line 798
    __strsep_g(& last, " ");
#line 799
    tmp___10 = __strdup((char const   *)first);
#line 799
    pwsc->uri = tmp___10;
#line 802
    tmp___11 = ws_getheaders(pwsc);
#line 802
    if (tmp___11) {
#line 804
      err_log(1, 2U, (char *)"Thread %d: Couldn\'t parse headers - aborting\n", pwsc->threadno);
#line 806
      pwsc->close = 1;
#line 807
      ws_close(pwsc);
#line 808
      return ((void *)0);
    } else {
#line 802
      if (! last) {
#line 804
        err_log(1, 2U, (char *)"Thread %d: Couldn\'t parse headers - aborting\n",
                pwsc->threadno);
#line 806
        pwsc->close = 1;
#line 807
        ws_close(pwsc);
#line 808
        return ((void *)0);
      }
    }
#line 815
    tmp___14 = strncasecmp((char const   *)last, "HTTP/1.0", 8U);
#line 815
    if (tmp___14 == 0) {
#line 816
      tmp___12 = ws_testarg(& pwsc->request_headers, (char *)"connection", (char *)"keep-alive");
#line 816
      if (tmp___12) {
#line 816
        tmp___13 = 0;
      } else {
#line 816
        tmp___13 = 1;
      }
#line 816
      pwsc->close = tmp___13;
    } else {
#line 818
      pwsc->close = ws_testarg(& pwsc->request_headers, (char *)"connection", (char *)"close");
    }
#line 821
    if (pwsc->close) {
#line 821
      tmp___15 = "non-persist";
    } else {
#line 821
      tmp___15 = "persist";
    }
#line 821
    err_log(9, 2U, (char *)"Thread %d: Connection type %s: Connection: %s\n", pwsc->threadno,
            last, tmp___15);
#line 824
    if (! pwsc->uri) {
#line 825
      pwsc->error = 12;
#line 826
      pwsc->close = 1;
#line 827
      err_log(1, 2U, (char *)"Thread %d: Error allocation URI\n", pwsc->threadno);
#line 829
      ws_returnerror(pwsc, 500, (char *)"Internal server error");
#line 830
      ws_close(pwsc);
#line 831
      return ((void *)0);
    }
#line 835
    first = pwsc->uri;
#line 836
    __strsep_g(& first, "?");
#line 838
    if (first) {
#line 839
      err_log(9, 2U, (char *)"Thread %d: parsing GET args\n", pwsc->threadno);
#line 840
      ws_getgetvars(pwsc, first);
    }
#line 845
    err_log(9, 2U, (char *)"Thread %d: Original URI: %s\n", pwsc->threadno, pwsc->uri);
#line 848
    tmp___16 = ws_encoding_hack(pwsc);
#line 848
    first = ws_urldecode(pwsc->uri, tmp___16);
#line 849
    free((void *)pwsc->uri);
#line 850
    pwsc->uri = first;
#line 853
    first = strstr((char const   *)pwsc->uri, "://");
#line 854
    if (first) {
#line 855
      first += 3;
#line 856
      tmp___18 = __builtin_strchr(first, '/');
#line 856
      first = tmp___18;
#line 857
      if (first) {
#line 858
        tmp___24 = __strdup((char const   *)first);
#line 858
        first = tmp___24;
#line 859
        free((void *)pwsc->uri);
#line 860
        pwsc->uri = first;
      }
    }
#line 865
    err_log(9, 2U, (char *)"Thread %d: Translated URI: %s\n", pwsc->threadno, pwsc->uri);
#line 869
    if (pwsc->request_type == 1) {
#line 870
      ws_getpostvars(pwsc);
    }
#line 872
    hdrs = 1;
#line 874
    handler = ws_findhandler(pwsp, pwsc, & req_handler, & auth_handler, & hdrs);
#line 876
    time(& now);
#line 877
    err_log(9, 2U, (char *)"Thread %d: Time is %d seconds after epoch\n", pwsc->threadno,
            now);
#line 879
    gmtime_r((time_t const   * __restrict  )(& now), (struct tm * __restrict  )(& now_tm));
#line 880
    err_log(9, 2U, (char *)"Thread %d: Setting time header\n", pwsc->threadno);
#line 881
    ws_addarg(& pwsc->response_headers, (char *)"Date", (char *)"%s, %d %s %d %02d:%02d:%02d GMT",
              ws_dow[now_tm.tm_wday], now_tm.tm_mday, ws_moy[now_tm.tm_mon], now_tm.tm_year + 1900,
              now_tm.tm_hour, now_tm.tm_min, now_tm.tm_sec);
#line 887
    if (hdrs) {
#line 888
      if (pwsc->close) {
#line 888
        tmp___25 = "close";
      } else {
#line 888
        tmp___25 = "keep-alive";
      }
#line 888
      ws_addarg(& pwsc->response_headers, (char *)"Connection", (char *)tmp___25);
#line 891
      ws_addarg(& pwsc->response_headers, (char *)"Server", (char *)"mt-daapd/0.2.4.1");
#line 894
      ws_addarg(& pwsc->response_headers, (char *)"Content-Type", (char *)"text/html");
#line 895
      ws_addarg(& pwsc->response_headers, (char *)"Content-Language", (char *)"en_us");
    }
#line 899
    if (handler == -1) {
#line 900
      err_log(9, 2U, (char *)"Thread %d: Using default handler.\n", pwsc->threadno);
#line 902
      ws_defaulthandler(pwsp, pwsc);
    } else {
#line 904
      err_log(9, 2U, (char *)"Thread %d: Using non-default handler\n", pwsc->threadno);
#line 907
      can_dispatch = 0;
#line 912
      if (auth_handler) {
#line 912
        tmp___28 = (*auth_handler)((char *)((void *)0), (char *)((void *)0));
#line 912
        if (tmp___28 == 0) {
#line 914
          auth = ws_getarg(& pwsc->request_headers, (char *)"Authorization");
#line 915
          if (auth) {
#line 915
            tmp___27 = ws_decodepassword(auth, & username, & password);
#line 915
            if (tmp___27 != -1) {
#line 916
              tmp___26 = (*auth_handler)(username, password);
#line 916
              if (tmp___26) {
#line 917
                can_dispatch = 1;
              }
#line 918
              ws_addarg(& pwsc->request_vars, (char *)"HTTP_USER", (char *)"%s", username);
#line 919
              ws_addarg(& pwsc->request_vars, (char *)"HTTP_PASSWD", (char *)"%s",
                        password);
#line 920
              free((void *)username);
            }
          }
#line 923
          if (! can_dispatch) {
#line 925
            ws_addarg(& pwsc->response_headers, (char *)"WWW-Authenticate", (char *)"Basic realm=\"webserver\"");
#line 927
            ws_returnerror(pwsc, 401, (char *)"Unauthorized");
#line 928
            pwsc->error = 0;
          }
        } else {
#line 931
          can_dispatch = 1;
        }
      } else {
#line 931
        can_dispatch = 1;
      }
#line 934
      if (can_dispatch) {
#line 935
        if (req_handler) {
#line 936
          (*req_handler)(pwsc);
        } else {
#line 938
          ws_defaulthandler(pwsp, pwsc);
        }
      }
    }
#line 942
    if (pwsc->close) {
#line 943
      pwsc->close = 1;
#line 944
      connection_done = 1;
    } else {
#line 942
      if (pwsc->error) {
#line 943
        pwsc->close = 1;
#line 944
        connection_done = 1;
      } else {
#line 942
        if (pwsp->stop) {
#line 943
          pwsc->close = 1;
#line 944
          connection_done = 1;
        }
      }
    }
#line 946
    ws_close(pwsc);
  }
#line 948
  err_log(10, 2U, (char *)"Exiting ws_dispatcher\n");
#line 949
  return ((void *)0);
}
}
#line 958 "webserver.c"
int ws_writefd(WS_CONNINFO *pwsc , char *fmt  , ...) 
{ char buffer___0[1024] ;
  va_list ap ;
  size_t tmp ;
  ssize_t tmp___0 ;

  {
#line 962
  err_log(10, 2U, (char *)"Entering ws_writefd\n");
#line 964
  __builtin_va_start(ap, fmt);
#line 965
  vsnprintf((char * __restrict  )(buffer___0), 1024U, (char const   * __restrict  )fmt,
            ap);
#line 966
  __builtin_va_end(ap);
#line 968
  err_log(10, 2U, (char *)"Exiting ws_writefd\n");
#line 969
  tmp = strlen((char const   *)(buffer___0));
#line 969
  tmp___0 = r_write(pwsc->fd, (void *)(buffer___0), tmp);
#line 969
  return (tmp___0);
}
}
#line 982 "webserver.c"
int ws_returnerror(WS_CONNINFO *pwsc , int error , char *description ) 
{ char *useragent ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___2 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;

  {
#line 985
  err_log(2, 2U, (char *)"Thread %d: Entering ws_returnerror (%d: %s)\n", pwsc->threadno,
          error, description);
#line 987
  ws_writefd(pwsc, (char *)"HTTP/1.1 %d %s\r\n", error, description);
#line 991
  useragent = ws_getarg(& pwsc->request_headers, (char *)"User-Agent");
#line 992
  if (useragent) {
#line 992
    if (0) {
#line 992
      if (0) {
#line 992
        __s1_len = strlen((char const   *)useragent);
#line 992
        __s2_len = strlen("iTunes");
#line 992
        if (! ((unsigned int )((void const   *)(useragent + 1)) - (unsigned int )((void const   *)useragent) == 1U)) {
          goto _L___0;
        } else {
#line 992
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 992
            if (! ((unsigned int )((void const   *)("iTunes" + 1)) - (unsigned int )((void const   *)"iTunes") == 1U)) {
#line 992
              tmp___7 = 1;
            } else {
#line 992
              if (__s2_len >= 4U) {
#line 992
                tmp___7 = 1;
              } else {
#line 992
                tmp___7 = 0;
              }
            }
          } else {
#line 992
            tmp___7 = 0;
          }
        }
#line 992
        if (tmp___7) {
#line 992
          tmp___2 = __builtin_strcmp((char const   *)useragent, "iTunes");
#line 992
          tmp___6 = tmp___2;
        } else {
#line 992
          tmp___5 = __builtin_strcmp((char const   *)useragent, "iTunes");
#line 992
          tmp___6 = tmp___5;
        }
      } else {
#line 992
        tmp___5 = __builtin_strcmp((char const   *)useragent, "iTunes");
#line 992
        tmp___6 = tmp___5;
      }
#line 992
      tmp___9 = tmp___6;
    } else {
#line 992
      tmp___8 = strncmp((char const   *)useragent, "iTunes", 6U);
#line 992
      tmp___9 = tmp___8;
    }
#line 992
    if (tmp___9) {
#line 993
      pwsc->close = 1;
#line 994
      ws_addarg(& pwsc->response_headers, (char *)"Connection", (char *)"close");
    }
  }
#line 997
  ws_emitheaders(pwsc);
#line 999
  ws_writefd(pwsc, (char *)"<HTML>\r\n<TITLE>");
#line 1000
  ws_writefd(pwsc, (char *)"%d %s</TITLE>\r\n<BODY>", error, description);
#line 1001
  ws_writefd(pwsc, (char *)"\r\n<H1>%s</H1>\r\n", description);
#line 1002
  ws_writefd(pwsc, (char *)"Error %d\r\n<hr>\r\n", error);
#line 1003
  ws_writefd(pwsc, (char *)"<i>mt-daapd: %s\r\n<br>", "0.2.4.1");
#line 1004
  tmp___14 = __errno_location();
#line 1004
  if (*tmp___14) {
#line 1005
    tmp___12 = __errno_location();
#line 1005
    tmp___13 = strerror(*tmp___12);
#line 1005
    ws_writefd(pwsc, (char *)"Error: %s\r\n", tmp___13);
  }
#line 1007
  ws_writefd(pwsc, (char *)"</i></BODY>\r\n</HTML>\r\n");
#line 1009
  err_log(10, 2U, (char *)"Exiting ws_returnerror\n");
#line 1010
  return (0);
}
}
#line 1019 "webserver.c"
void ws_defaulthandler(WS_PRIVATE *pwsp , WS_CONNINFO *pwsc ) 
{ char path[4096] ;
  char resolved_path[4096] ;
  int file_fd ;
  off_t len ;
  int *tmp ;
  char *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int *tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;

  {
#line 1025
  err_log(10, 2U, (char *)"Entering ws_defaulthandler\n");
#line 1027
  snprintf((char * __restrict  )(path), 4096U, (char const   * __restrict  )"%s/%s",
           pwsp->wsconfig.web_root, pwsc->uri);
#line 1028
  tmp___0 = realpath((char const   * __restrict  )(path), (char * __restrict  )(resolved_path));
#line 1028
  if (! tmp___0) {
#line 1029
    tmp = __errno_location();
#line 1029
    pwsc->error = *tmp;
#line 1030
    err_log(2, 2U, (char *)"Exiting ws_defaulthandler: Cannot resolve %s\n", path);
#line 1031
    ws_returnerror(pwsc, 404, (char *)"Not found");
#line 1032
    ws_close(pwsc);
#line 1033
    return;
  }
#line 1036
  err_log(9, 2U, (char *)"Thread %d: Preparing to serve %s\n", pwsc->threadno, resolved_path);
#line 1039
  if (0) {
#line 1039
    if (0) {
#line 1039
      __s1_len = strlen((char const   *)(resolved_path));
#line 1039
      __s2_len = strlen((char const   *)pwsp->wsconfig.web_root);
#line 1039
      if (! ((unsigned int )((void const   *)(resolved_path + 1)) - (unsigned int )((void const   *)(resolved_path)) == 1U)) {
        goto _L___0;
      } else {
#line 1039
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 1039
          if (! ((unsigned int )((void const   *)(pwsp->wsconfig.web_root + 1)) - (unsigned int )((void const   *)pwsp->wsconfig.web_root) == 1U)) {
#line 1039
            tmp___12 = 1;
          } else {
#line 1039
            if (__s2_len >= 4U) {
#line 1039
              tmp___12 = 1;
            } else {
#line 1039
              tmp___12 = 0;
            }
          }
        } else {
#line 1039
          tmp___12 = 0;
        }
      }
#line 1039
      if (tmp___12) {
#line 1039
        tmp___7 = __builtin_strcmp((char const   *)(resolved_path), (char const   *)pwsp->wsconfig.web_root);
#line 1039
        tmp___11 = tmp___7;
      } else {
#line 1039
        tmp___10 = __builtin_strcmp((char const   *)(resolved_path), (char const   *)pwsp->wsconfig.web_root);
#line 1039
        tmp___11 = tmp___10;
      }
    } else {
#line 1039
      tmp___10 = __builtin_strcmp((char const   *)(resolved_path), (char const   *)pwsp->wsconfig.web_root);
#line 1039
      tmp___11 = tmp___10;
    }
#line 1039
    tmp___15 = tmp___11;
  } else {
#line 1039
    tmp___13 = strlen((char const   *)pwsp->wsconfig.web_root);
#line 1039
    tmp___14 = strncmp((char const   *)(resolved_path), (char const   *)pwsp->wsconfig.web_root,
                       tmp___13);
#line 1039
    tmp___15 = tmp___14;
  }
#line 1039
  if (tmp___15) {
#line 1041
    pwsc->error = 22;
#line 1042
    err_log(2, 2U, (char *)"Exiting ws_defaulthandler: Thread %d: Requested file %s out of root\n",
            pwsc->threadno, resolved_path);
#line 1045
    ws_returnerror(pwsc, 403, (char *)"Forbidden");
#line 1046
    ws_close(pwsc);
#line 1047
    return;
  }
#line 1050
  file_fd = open((char const   *)(resolved_path), 0);
#line 1051
  if (file_fd == -1) {
#line 1052
    tmp___21 = __errno_location();
#line 1052
    pwsc->error = *tmp___21;
#line 1053
    tmp___22 = __errno_location();
#line 1053
    tmp___23 = strerror(*tmp___22);
#line 1053
    err_log(2, 2U, (char *)"Exiting ws_defaulthandler: Thread %d: Error opening %s: %s\n",
            pwsc->threadno, resolved_path, tmp___23);
#line 1056
    ws_returnerror(pwsc, 404, (char *)"Not found");
#line 1057
    ws_close(pwsc);
#line 1058
    return;
  }
#line 1062
  len = lseek(file_fd, 0L, 2);
#line 1065
  if (len != -1L) {
#line 1067
    err_log(9, 2U, (char *)"Length of file is %ld\n", len);
#line 1068
    ws_addarg(& pwsc->response_headers, (char *)"Content-Length", (char *)"%ld", len);
#line 1069
    lseek(file_fd, 0L, 0);
  }
#line 1073
  ws_writefd(pwsc, (char *)"HTTP/1.1 200 OK\r\n");
#line 1074
  ws_emitheaders(pwsc);
#line 1077
  copyfile(file_fd, pwsc->fd);
#line 1079
  r_close(file_fd);
#line 1080
  err_log(9, 2U, (char *)"Exiting ws_defaulthandler: Thread %d: Served successfully\n",
          pwsc->threadno);
#line 1083
  return;
}
}
#line 1095 "webserver.c"
int ws_testrequestheader(WS_CONNINFO *pwsc , char *header , char *value ) 
{ int tmp ;

  {
#line 1096
  tmp = ws_testarg(& pwsc->request_headers, header, value);
#line 1096
  return (tmp);
}
}
#line 1109 "webserver.c"
int ws_testarg(ARGLIST *root , char *key , char *value ) 
{ char *retval ;
  int tmp ;
  int tmp___0 ;

  {
#line 1112
  err_log(9, 2U, (char *)"Checking to see if %s matches %s\n", key, value);
#line 1114
  retval = ws_getarg(root, key);
#line 1115
  if (! retval) {
#line 1116
    return (0);
  }
#line 1118
  tmp = strcasecmp((char const   *)value, (char const   *)retval);
#line 1118
  if (tmp) {
#line 1118
    tmp___0 = 0;
  } else {
#line 1118
    tmp___0 = 1;
  }
#line 1118
  return (tmp___0);
}
}
#line 1134 "webserver.c"
char *ws_getarg(ARGLIST *root , char *key ) 
{ ARGLIST *pcurrent ;
  int tmp ;

  {
#line 1135
  pcurrent = root->next;
#line 1137
  while (1) {
#line 1137
    if (pcurrent) {
#line 1137
      tmp = strcasecmp((char const   *)pcurrent->key, (char const   *)key);
#line 1137
      if (! tmp) {
#line 1137
        break;
      }
    } else {
#line 1137
      break;
    }
#line 1138
    pcurrent = pcurrent->next;
  }
#line 1140
  if (pcurrent) {
#line 1141
    return (pcurrent->value);
  }
#line 1143
  return ((char *)((void *)0));
}
}
#line 1161 "webserver.c"
int ws_addarg(ARGLIST *root , char *key , char *fmt  , ...) 
{ char *newkey ;
  char *newvalue ;
  ARGLIST *pnew ;
  ARGLIST *current ;
  va_list ap ;
  char value[4096] ;
  char *tmp___4 ;
  char *tmp___10 ;
  void *tmp___11 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___13 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 1169
  __builtin_va_start(ap, fmt);
#line 1170
  vsnprintf((char * __restrict  )(value), sizeof(value), (char const   * __restrict  )fmt,
            ap);
#line 1171
  __builtin_va_end(ap);
#line 1173
  tmp___4 = __strdup((char const   *)key);
#line 1173
  newkey = tmp___4;
#line 1174
  tmp___10 = __strdup((char const   *)(value));
#line 1174
  newvalue = tmp___10;
#line 1175
  tmp___11 = malloc(sizeof(ARGLIST ));
#line 1175
  pnew = (ARGLIST *)tmp___11;
#line 1177
  if (! pnew) {
#line 1178
    return (-1);
  } else {
#line 1177
    if (! newkey) {
#line 1178
      return (-1);
    } else {
#line 1177
      if (! newvalue) {
#line 1178
        return (-1);
      }
    }
  }
#line 1180
  pnew->key = newkey;
#line 1181
  pnew->value = newvalue;
#line 1187
  current = root->next;
#line 1188
  while (current) {
#line 1189
    if (0) {
#line 1189
      __s1_len = strlen((char const   *)current->key);
#line 1189
      __s2_len = strlen((char const   *)key);
#line 1189
      if (! ((unsigned int )((void const   *)(current->key + 1)) - (unsigned int )((void const   *)current->key) == 1U)) {
        goto _L___0;
      } else {
#line 1189
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 1189
          if (! ((unsigned int )((void const   *)(key + 1)) - (unsigned int )((void const   *)key) == 1U)) {
#line 1189
            tmp___18 = 1;
          } else {
#line 1189
            if (__s2_len >= 4U) {
#line 1189
              tmp___18 = 1;
            } else {
#line 1189
              tmp___18 = 0;
            }
          }
        } else {
#line 1189
          tmp___18 = 0;
        }
      }
#line 1189
      if (tmp___18) {
#line 1189
        tmp___13 = __builtin_strcmp((char const   *)current->key, (char const   *)key);
#line 1189
        tmp___17 = tmp___13;
      } else {
#line 1189
        tmp___16 = __builtin_strcmp((char const   *)current->key, (char const   *)key);
#line 1189
        tmp___17 = tmp___16;
      }
    } else {
#line 1189
      tmp___16 = __builtin_strcmp((char const   *)current->key, (char const   *)key);
#line 1189
      tmp___17 = tmp___16;
    }
#line 1189
    if (! tmp___17) {
#line 1191
      err_log(9, 2U, (char *)"Updating %s from %s to %s\n", key, current->value, value);
#line 1193
      free((void *)current->value);
#line 1194
      current->value = newvalue;
#line 1195
      free((void *)newkey);
#line 1196
      free((void *)pnew);
#line 1197
      return (0);
    }
#line 1199
    current = current->next;
  }
#line 1203
  pnew->next = root->next;
#line 1204
  err_log(9, 2U, (char *)"Added *%s=%s*\n", newkey, newvalue);
#line 1205
  root->next = pnew;
#line 1207
  return (0);
}
}
#line 1220 "webserver.c"
char *ws_urldecode(char *string , int space_as_plus ) 
{ char *pnew ;
  char *src ;
  char *dst ;
  int val ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int __res ;
  __int32_t const   **tmp___4 ;
  int __res___0 ;
  __int32_t const   **tmp___6 ;
  int __res___1 ;
  __int32_t const   **tmp___8 ;
  int __res___2 ;
  __int32_t const   **tmp___10 ;
  int __res___3 ;
  __int32_t const   **tmp___12 ;
  int __res___4 ;
  __int32_t const   **tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;

  {
#line 1223
  val = 0;
#line 1225
  tmp = strlen((char const   *)string);
#line 1225
  tmp___0 = malloc(tmp + 1U);
#line 1225
  pnew = (char *)tmp___0;
#line 1226
  if (! pnew) {
#line 1227
    return ((char *)((void *)0));
  }
#line 1229
  src = string;
#line 1230
  dst = pnew;
#line 1232
  while (*src) {
#line 1233
    switch ((int )*src) {
    case 43: 
#line 1239
    if (space_as_plus) {
#line 1240
      tmp___1 = dst;
#line 1240
      dst ++;
#line 1240
      *tmp___1 = (char )' ';
    } else {
#line 1242
      tmp___2 = dst;
#line 1242
      dst ++;
#line 1242
      *tmp___2 = *src;
    }
#line 1244
    src ++;
#line 1245
    break;
    case 37: 
#line 1248
    src ++;
#line 1249
    if (*src) {
#line 1250
      if ((int )*src <= 57) {
#line 1250
        if ((int )*src >= 48) {
#line 1251
          val = (int )*src - 48;
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1252
        if (sizeof(*src) > 1U) {
#line 1252
          __res___0 = tolower___0((int )*src);
        } else {
#line 1252
          tmp___6 = __ctype_tolower_loc();
#line 1252
          __res___0 = (int )*(*tmp___6 + (int )*src);
        }
#line 1252
        if (__res___0 <= 102) {
#line 1252
          if (sizeof(*src) > 1U) {
#line 1252
            __res___1 = tolower___0((int )*src);
          } else {
#line 1252
            tmp___8 = __ctype_tolower_loc();
#line 1252
            __res___1 = (int )*(*tmp___8 + (int )*src);
          }
#line 1252
          if (__res___1 >= 97) {
#line 1253
            if (sizeof(*src) > 1U) {
#line 1253
              __res = tolower___0((int )*src);
            } else {
#line 1253
              tmp___4 = __ctype_tolower_loc();
#line 1253
              __res = (int )*(*tmp___4 + (int )*src);
            }
#line 1253
            val = 10 + (__res - 97);
          }
        }
      }
#line 1254
      src ++;
    }
#line 1256
    if (*src) {
#line 1257
      val *= 16;
#line 1258
      if ((int )*src <= 57) {
#line 1258
        if ((int )*src >= 48) {
#line 1259
          val += (int )*src - 48;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 1260
        if (sizeof(*src) > 1U) {
#line 1260
          __res___3 = tolower___0((int )*src);
        } else {
#line 1260
          tmp___12 = __ctype_tolower_loc();
#line 1260
          __res___3 = (int )*(*tmp___12 + (int )*src);
        }
#line 1260
        if (__res___3 <= 102) {
#line 1260
          if (sizeof(*src) > 1U) {
#line 1260
            __res___4 = tolower___0((int )*src);
          } else {
#line 1260
            tmp___14 = __ctype_tolower_loc();
#line 1260
            __res___4 = (int )*(*tmp___14 + (int )*src);
          }
#line 1260
          if (__res___4 >= 97) {
#line 1261
            if (sizeof(*src) > 1U) {
#line 1261
              __res___2 = tolower___0((int )*src);
            } else {
#line 1261
              tmp___10 = __ctype_tolower_loc();
#line 1261
              __res___2 = (int )*(*tmp___10 + (int )*src);
            }
#line 1261
            val += 10 + (__res___2 - 97);
          }
        }
      }
#line 1262
      src ++;
    }
#line 1264
    tmp___15 = dst;
#line 1264
    dst ++;
#line 1264
    *tmp___15 = (char )val;
#line 1265
    break;
    default: 
#line 1267
    tmp___16 = dst;
#line 1267
    dst ++;
#line 1267
    tmp___17 = src;
#line 1267
    src ++;
#line 1267
    *tmp___16 = *tmp___17;
#line 1268
    break;
    }
  }
#line 1272
  *dst = (char )'\000';
#line 1273
  return (pnew);
}
}
#line 1288 "webserver.c"
int ws_registerhandler(WSHANDLE ws , char *regex , void (*handler)(WS_CONNINFO * ) ,
                       int (*auth)(char * , char * ) , int addheaders ) 
{ WS_HANDLER *phandler ;
  WS_PRIVATE *pwsp ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 1293
  pwsp = (WS_PRIVATE *)ws;
#line 1295
  tmp = malloc(sizeof(WS_HANDLER ));
#line 1295
  phandler = (WS_HANDLER *)tmp;
#line 1296
  if (! phandler) {
#line 1297
    return (-1);
  }
#line 1299
  tmp___1 = regcomp((regex_t * __restrict  )(& phandler->regex), (char const   * __restrict  )regex,
                    1 | (((1 << 1) << 1) << 1));
#line 1299
  if (tmp___1) {
#line 1300
    free((void *)phandler);
#line 1301
    tmp___0 = __errno_location();
#line 1301
    *tmp___0 = 22;
#line 1302
    return (-1);
  }
#line 1305
  phandler->req_handler = handler;
#line 1306
  phandler->auth_handler = auth;
#line 1307
  phandler->addheaders = addheaders;
#line 1309
  ws_lock_unsafe();
#line 1310
  phandler->next = pwsp->handlers.next;
#line 1311
  pwsp->handlers.next = phandler;
#line 1312
  ws_unlock_unsafe();
#line 1314
  return (0);
}
}
#line 1325 "webserver.c"
int ws_findhandler(WS_PRIVATE *pwsp , WS_CONNINFO *pwsc , void (**preq)(WS_CONNINFO * ) ,
                   int (**pauth)(char * , char * ) , int *addheaders ) 
{ WS_HANDLER *phandler ;
  int tmp ;

  {
#line 1329
  phandler = pwsp->handlers.next;
#line 1331
  ws_lock_unsafe();
#line 1333
  *preq = (void (*)(WS_CONNINFO * ))((void *)0);
#line 1335
  err_log(9, 2U, (char *)"Thread %d: Preparing to find handler\n", pwsc->threadno);
#line 1338
  while (phandler) {
#line 1339
    tmp = regexec((regex_t const   * __restrict  )(& phandler->regex), (char const   * __restrict  )pwsc->uri,
                  0U, (regmatch_t * __restrict  )((void *)0), 0);
#line 1339
    if (! tmp) {
#line 1341
      err_log(9, 2U, (char *)"Thread %d: URI Match!\n", pwsc->threadno);
#line 1342
      *preq = phandler->req_handler;
#line 1343
      *pauth = phandler->auth_handler;
#line 1344
      *addheaders = phandler->addheaders;
#line 1345
      ws_unlock_unsafe();
#line 1346
      return (0);
    }
#line 1348
    phandler = phandler->next;
  }
#line 1351
  ws_unlock_unsafe();
#line 1352
  return (-1);
}
}
#line 1362 "webserver.c"
static char ws_xlat[256]  ;
#line 1363 "webserver.c"
static int ws_xlat_init  =    0;
#line 1361 "webserver.c"
int ws_decodepassword(char *header , char **username , char **password ) 
{ int index___0 ;
  int len ;
  int rack ;
  int pads ;
  unsigned char *decodebuffer ;
  unsigned char *pin ;
  unsigned char *pout ;
  char *type ;
  char *base64 ;
  int lookup ;
  int tmp ;
  int tmp___0 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;

  {
#line 1366
  rack = 0;
#line 1367
  pads = 0;
#line 1373
  *username = (char *)((void *)0);
#line 1374
  *password = (char *)((void *)0);
#line 1376
  tmp = ws_lock_unsafe();
#line 1376
  if (tmp == -1) {
#line 1377
    return (-1);
  }
#line 1379
  if (! ws_xlat_init) {
#line 1380
    ws_xlat_init = 1;
#line 1382
    memset((void *)((char *)(& ws_xlat)), 255, sizeof(ws_xlat));
#line 1383
    index___0 = 0;
#line 1383
    while (index___0 < 26) {
#line 1384
      ws_xlat[65 + index___0] = (char )index___0;
#line 1385
      ws_xlat[97 + index___0] = (char )(index___0 + 26);
#line 1383
      index___0 ++;
    }
#line 1388
    index___0 = 0;
#line 1388
    while (index___0 < 10) {
#line 1389
      ws_xlat[48 + index___0] = (char )(index___0 + 52);
#line 1388
      index___0 ++;
    }
#line 1392
    ws_xlat['+'] = (char)62;
#line 1393
    ws_xlat['/'] = (char)63;
  }
#line 1395
  tmp___0 = ws_unlock_unsafe();
#line 1395
  if (tmp___0 == -1) {
#line 1396
    return (-1);
  }
#line 1401
  while (1) {
#line 1401
    if (*header) {
#line 1401
      if (! ((int )*header != 32)) {
#line 1401
        break;
      }
    } else {
#line 1401
      break;
    }
#line 1402
    header ++;
  }
#line 1405
  type = header;
#line 1406
  tmp___2 = __builtin_strchr(header, ' ');
#line 1406
  base64 = tmp___2;
#line 1407
  if (! base64) {
#line 1409
    err_log(9, 2U, (char *)"Bad authentication header: %s\n", header);
#line 1410
    return (-1);
  }
#line 1413
  *base64 = (char )'\000';
#line 1414
  base64 ++;
#line 1416
  tmp___3 = strlen((char const   *)base64);
#line 1416
  tmp___4 = malloc(tmp___3);
#line 1416
  decodebuffer = (unsigned char *)tmp___4;
#line 1417
  if (! decodebuffer) {
#line 1418
    return (-1);
  }
#line 1420
  err_log(9, 2U, (char *)"Preparing to decode %s\n", base64);
#line 1422
  tmp___5 = strlen((char const   *)base64);
#line 1422
  memset((void *)decodebuffer, 0, tmp___5);
#line 1423
  len = 0;
#line 1424
  pout = decodebuffer;
#line 1425
  pin = (unsigned char *)base64;
#line 1428
  while (*(pin + rack)) {
#line 1429
    if ((int )*(pin + rack) != 61) {
#line 1430
      lookup = (int )ws_xlat[*(pin + rack)];
#line 1431
      if (lookup == 255) {
#line 1432
        err_log(2, 2U, (char *)"Got garbage Authenticate header\n");
#line 1433
        return (-1);
      }
#line 1437
      switch (rack) {
      case 0: 
#line 1439
      *(pout + 0) = (unsigned char )(lookup << 2);
#line 1440
      break;
      case 1: 
#line 1442
      *(pout + 0) = (unsigned char )((int )*(pout + 0) | (lookup >> 4));
#line 1443
      *(pout + 1) = (unsigned char )(lookup << 4);
#line 1444
      break;
      case 2: 
#line 1446
      *(pout + 1) = (unsigned char )((int )*(pout + 1) | (lookup >> 2));
#line 1447
      *(pout + 2) = (unsigned char )(lookup << 6);
#line 1448
      break;
      case 3: 
#line 1450
      *(pout + 2) = (unsigned char )((int )*(pout + 2) | lookup);
#line 1451
      break;
      }
#line 1453
      rack ++;
    } else {
#line 1456
      pads ++;
#line 1457
      rack ++;
    }
#line 1460
    if (rack == 4) {
#line 1461
      pin += 4;
#line 1462
      pout += 3;
#line 1464
      len += 3 - pads;
#line 1465
      rack = 0;
    }
  }
#line 1470
  err_log(9, 2U, (char *)"Decoded %s\n", decodebuffer);
#line 1472
  *username = (char *)decodebuffer;
#line 1473
  *password = *username;
#line 1475
  __strsep_g(password, ":");
#line 1477
  err_log(9, 2U, (char *)"Decoded user=%s, pw=%s\n", *username, *password);
#line 1478
  return (0);
}
}
#line 1486 "webserver.c"
int ws_addresponseheader(WS_CONNINFO *pwsc , char *header , char *fmt  , ...) 
{ va_list ap ;
  char value[4096] ;
  int tmp ;

  {
#line 1490
  __builtin_va_start(ap, fmt);
#line 1491
  vsnprintf((char * __restrict  )(value), sizeof(value), (char const   * __restrict  )fmt,
            ap);
#line 1492
  __builtin_va_end(ap);
#line 1494
  tmp = ws_addarg(& pwsc->response_headers, header, value);
#line 1494
  return (tmp);
}
}
#line 1502 "webserver.c"
char *ws_getvar(WS_CONNINFO *pwsc , char *var ) 
{ char *tmp ;

  {
#line 1503
  tmp = ws_getarg(& pwsc->request_vars, var);
#line 1503
  return (tmp);
}
}
#line 1506 "webserver.c"
char *ws_getrequestheader(WS_CONNINFO *pwsc , char *header ) 
{ char *tmp ;

  {
#line 1507
  tmp = ws_getarg(& pwsc->request_headers, header);
#line 1507
  return (tmp);
}
}
#line 1 "configfile.o"
#pragma merger(0,"/tmp/cil-zoygEZZF.i","-g,-g,-O2")
#line 269 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *ctime_r(time_t const   * __restrict  __timer ,
                                                   char * __restrict  __buf ) ;
#line 50 "./restart.h"
ssize_t r_read(int fd , void *buf , size_t size ) ;
#line 246 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 333
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 530
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 92 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strcat(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 316
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 382
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 433
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 433 "/usr/include/sys/stat.h"
__inline static int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 436
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 436
  return (tmp);
}
}
#line 29 "configfile.h"
int config_write(WS_CONNINFO *pwsc ) ;
#line 34
int config_get_next_session(void) ;
#line 26 "rend.h"
int rend_running(void) ;
#line 61 "configfile.c"
static void config_emit_string(WS_CONNINFO *pwsc , void *value , char *arg ) ;
#line 62
static void config_emit_literal(WS_CONNINFO *pwsc , void *value , char *arg ) ;
#line 63
static void config_emit_int(WS_CONNINFO *pwsc , void *value , char *arg ) ;
#line 64
static void config_emit_include(WS_CONNINFO *pwsc , void *value , char *arg ) ;
#line 65
static void config_emit_threadstatus(WS_CONNINFO *pwsc , void *value , char *arg ) ;
#line 66
static void config_emit_ispage(WS_CONNINFO *pwsc , void *value , char *arg ) ;
#line 67
static void config_emit_session_count(WS_CONNINFO *pwsc , void *value , char *arg ) ;
#line 68
static void config_emit_service_status(WS_CONNINFO *pwsc , void *value , char *arg ) ;
#line 69
static void config_emit_user(WS_CONNINFO *pwsc , void *value , char *arg ) ;
#line 70
static void config_emit_readonly(WS_CONNINFO *pwsc , void *value , char *arg ) ;
#line 71
static void config_emit_version(WS_CONNINFO *pwsc , void *value , char *arg ) ;
#line 72
static void config_emit_system(WS_CONNINFO *pwsc , void *value , char *arg ) ;
#line 73
static void config_emit_flags(WS_CONNINFO *pwsc , void *value , char *arg ) ;
#line 74
static void config_subst_stream(WS_CONNINFO *pwsc , int fd_src ) ;
#line 75
static int config_file_is_readonly(void) ;
#line 76
static int config_mutex_lock(void) ;
#line 77
static int config_mutex_unlock(void) ;
#line 78
static int config_existdir(char *path ) ;
#line 79
static int config_makedir(char *path ) ;
#line 100 "configfile.c"
CONFIGELEMENT config_elements[31]  = 
#line 100
  {      {1, 1, 0, 1, (char *)"runas", (void *)(& config.runas), & config_emit_string}, 
        {1,
      1, 0, 1, (char *)"web_root", (void *)(& config.web_root), & config_emit_string}, 
        {1,
      1, 0, 0, (char *)"port", (void *)(& config.port), & config_emit_int}, 
        {1, 1, 0, 1, (char *)"admin_pw", (void *)(& config.adminpassword), & config_emit_string}, 
        {1,
      1, 0, 1, (char *)"mp3_dir", (void *)(& config.mp3dir), & config_emit_string}, 
        {1,
      0, 0, 1, (char *)"db_dir", (void *)(& config.dbdir), & config_emit_string}, 
        {1, 1, 0, 1, (char *)"servername", (void *)(& config.servername), & config_emit_string}, 
        {1,
      0, 0, 0, (char *)"rescan_interval", (void *)(& config.rescan_interval), & config_emit_int}, 
        {1,
      0, 0, 0, (char *)"always_scan", (void *)(& config.always_scan), & config_emit_int}, 
        {1,
      0, 0, 0, (char *)"process_m3u", (void *)(& config.process_m3u), & config_emit_int}, 
        {1,
      0, 0, 0, (char *)"scan_type", (void *)(& config.scan_type), & config_emit_int}, 
        {1,
      0, 0, 0, (char *)"compress", (void *)(& config.compress), & config_emit_int}, 
        {1,
      0, 0, 1, (char *)"playlist", (void *)(& config.playlist), & config_emit_string}, 
        {1,
      0, 0, 1, (char *)"extensions", (void *)(& config.extensions), & config_emit_string}, 
        {1,
      0, 0, 1, (char *)"interface", (void *)(& config.iface), & config_emit_string}, 
        {1,
      0, 0, 1, (char *)"password", (void *)(& config.readpassword), & config_emit_string}, 
        {1,
      0, 0, 1, (char *)"logfile", (void *)(& config.logfile), & config_emit_string}, 
        {0,
      0, 0, 4, (char *)"release", (void *)"0.2.4.1", & config_emit_literal}, 
        {0, 0, 0, 4, (char *)"package", (void *)"mt-daapd", & config_emit_literal}, 
        {0, 0, 0, 4, (char *)"include", (void *)0, & config_emit_include}, 
        {0, 0, 0, 4, (char *)"threadstat", (void *)0, & config_emit_threadstatus}, 
        {0, 0, 0, 4, (char *)"ispage", (void *)0, & config_emit_ispage}, 
        {0, 0, 0, 4, (char *)"session-count", (void *)0, & config_emit_session_count}, 
        {0,
      0, 0, 4, (char *)"service-status", (void *)0, & config_emit_service_status}, 
        {0,
      0, 0, 4, (char *)"user", (void *)0, & config_emit_user}, 
        {0, 0, 0, 4, (char *)"readonly", (void *)0, & config_emit_readonly}, 
        {0, 0, 0, 4, (char *)"version", (void *)0, & config_emit_version}, 
        {0, 0, 0, 4, (char *)"system", (void *)0, & config_emit_system}, 
        {1, 0, 0, 1, (char *)"art_filename", (void *)(& config.artfilename), & config_emit_string}, 
        {0,
      0, 0, 4, (char *)"flags", (void *)0, & config_emit_flags}, 
        {-1, 1, 0, 1, (char *)((void *)0), (void *)0, (void (*)(WS_CONNINFO * , void * ,
                                                             char * ))((void *)0)}};
#line 147 "configfile.c"
SCAN_STATUS scan_status  =    {0, 0, (char *)((void *)0), (char *)((void *)0), (struct tag_scan_status *)0};
#line 148 "configfile.c"
pthread_mutex_t scan_mutex  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 149 "configfile.c"
int config_session  =    0;
#line 161 "configfile.c"
static int config_makedir(char *path ) 
{ char *token ;
  char *next_token ;
  char *pathdup ;
  char path_buffer[4096] ;
  int err ;
  char *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  char *tmp___19 ;

  {
#line 167
  err_log(9, 1U, (char *)"Creating %s\n", path);
#line 169
  tmp___4 = __strdup((char const   *)path);
#line 169
  pathdup = tmp___4;
#line 170
  if (! pathdup) {
#line 171
    return (-1);
  }
#line 174
  next_token = pathdup + 1;
#line 175
  memset((void *)(path_buffer), 0, sizeof(path_buffer));
#line 177
  while (1) {
#line 177
    tmp___19 = __strsep_g(& next_token, "/");
#line 177
    token = tmp___19;
#line 177
    if (! token) {
#line 177
      break;
    }
#line 178
    tmp___10 = strlen((char const   *)(path_buffer));
#line 178
    tmp___11 = strlen((char const   *)token);
#line 178
    if (tmp___10 + tmp___11 < 4096U) {
#line 179
      strcat((char * __restrict  )(path_buffer), (char const   * __restrict  )"/");
#line 180
      strcat((char * __restrict  )(path_buffer), (char const   * __restrict  )token);
#line 181
      err_log(9, 1U, (char *)"Making %s\n", path_buffer);
#line 182
      tmp___7 = mkdir((char const   *)(path_buffer), 448U);
#line 182
      if (tmp___7) {
#line 182
        tmp___8 = __errno_location();
#line 182
        if (*tmp___8 != 17) {
#line 183
          tmp___5 = __errno_location();
#line 183
          err = *tmp___5;
#line 184
          free((void *)pathdup);
#line 185
          tmp___6 = __errno_location();
#line 185
          *tmp___6 = err;
#line 186
          return (-1);
        }
      }
    } else {
#line 189
      tmp___9 = __errno_location();
#line 189
      *tmp___9 = 36;
#line 190
      return (-1);
    }
  }
#line 194
  free((void *)pathdup);
#line 195
  return (0);
}
}
#line 203 "configfile.c"
static int config_existdir(char *path ) 
{ struct stat sb ;
  int tmp ;
  int *tmp___0 ;

  {
#line 206
  err_log(9, 1U, (char *)"Checking existence of %s\n", path);
#line 208
  tmp = stat((char const   * __restrict  )path, (struct stat * __restrict  )(& sb));
#line 208
  if (tmp) {
#line 209
    return (0);
  }
#line 212
  if (sb.st_mode & 16384U) {
#line 213
    return (1);
  }
#line 215
  tmp___0 = __errno_location();
#line 215
  *tmp___0 = 20;
#line 216
  return (0);
}
}
#line 227 "configfile.c"
int config_read(char *file ) 
{ FILE *fin ;
  char *buffer___0 ;
  int err ;
  char *value ;
  char *comment ;
  char path_buffer[4096] ;
  CONFIGELEMENT *pce ;
  int handled ;
  char *term ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___7 ;
  char *tmp___13 ;
  char *tmp___19 ;
  char *tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___28 ;
  char *tmp___29 ;
  size_t tmp___30 ;
  char *tmp___32 ;
  char *tmp___38 ;
  int tmp___39 ;
  size_t tmp___40 ;
  char *tmp___41 ;
  char *tmp___47 ;
  char *tmp___53 ;
  char *tmp___59 ;
  int tmp___60 ;
  int *tmp___61 ;
  char *tmp___62 ;
  int tmp___63 ;
  int *tmp___64 ;
  char *tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___71 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___84 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___97 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;

  {
#line 230
  err = 0;
#line 238
  tmp = malloc(1025U);
#line 238
  buffer___0 = (char *)tmp;
#line 239
  if (! buffer___0) {
#line 240
    return (-1);
  }
#line 242
  fin = fopen((char const   * __restrict  )file, (char const   * __restrict  )"r");
#line 242
  if ((unsigned int )fin == (unsigned int )((void *)0)) {
#line 243
    tmp___0 = __errno_location();
#line 243
    err = *tmp___0;
#line 244
    free((void *)buffer___0);
#line 246
    if (2 == err) {
#line 247
      err_log(1, 1U, (char *)"Whoops!  Can\'t find the config file!  If you are running this for the first\n");
#line 248
      err_log(1, 1U, (char *)"time, then perhaps you\'ve forgotten to copy the sample config in the \n");
#line 249
      err_log(1, 1U, (char *)"contrib directory into /etc/mt-daapd.conf.  Just a suggestion...\n\n");
    }
#line 252
    tmp___1 = __errno_location();
#line 252
    *tmp___1 = err;
#line 253
    return (-1);
  }
#line 259
  config.always_scan = 1;
#line 262
  tmp___7 = __strdup((char const   *)file);
#line 262
  config.configfile = tmp___7;
#line 263
  config.web_root = (char *)((void *)0);
#line 264
  config.adminpassword = (char *)((void *)0);
#line 265
  config.readpassword = (char *)((void *)0);
#line 266
  config.iface = (char *)((void *)0);
#line 267
  config.mp3dir = (char *)((void *)0);
#line 268
  config.playlist = (char *)((void *)0);
#line 269
  config.runas = (char *)((void *)0);
#line 270
  config.artfilename = (char *)((void *)0);
#line 271
  config.logfile = (char *)((void *)0);
#line 272
  config.rescan_interval = 0;
#line 273
  config.process_m3u = 0;
#line 274
  config.scan_type = 0;
#line 275
  config.compress = 0;
#line 278
  tmp___13 = __strdup(".mp3");
#line 278
  config.extensions = tmp___13;
#line 281
  tmp___19 = __strdup("mt-daapd 0.2.4.1");
#line 281
  config.servername = tmp___19;
#line 283
  while (1) {
#line 283
    tmp___41 = fgets((char * __restrict  )buffer___0, 1024, (FILE * __restrict  )fin);
#line 283
    if (! tmp___41) {
#line 283
      break;
    }
#line 284
    *(buffer___0 + 1024) = (char )'\000';
#line 286
    tmp___21 = __builtin_strchr(buffer___0, '#');
#line 286
    comment = tmp___21;
#line 287
    if (comment) {
#line 288
      *comment = (char )'\000';
    }
#line 290
    while (1) {
#line 290
      tmp___23 = strlen((char const   *)buffer___0);
#line 290
      if (tmp___23) {
#line 290
        tmp___28 = strlen((char const   *)buffer___0);
#line 290
        tmp___29 = __builtin_strchr((char *)"\n\r ", (int )*(buffer___0 + (tmp___28 - 1U)));
#line 290
        if (! tmp___29) {
#line 290
          break;
        }
      } else {
#line 290
        break;
      }
#line 291
      tmp___22 = strlen((char const   *)buffer___0);
#line 291
      *(buffer___0 + (tmp___22 - 1U)) = (char )'\000';
    }
#line 293
    term = buffer___0;
#line 295
    while (1) {
#line 295
      if (! ((int )*term == 9)) {
#line 295
        if (! ((int )*term == 32)) {
#line 295
          break;
        }
      }
#line 296
      term ++;
    }
#line 298
    value = term;
#line 300
    __strsep_g(& value, "\t ");
#line 301
    if (value) {
#line 301
      if (term) {
#line 301
        tmp___40 = strlen((char const   *)term);
#line 301
        if (tmp___40) {
#line 302
          while (1) {
#line 302
            tmp___30 = strlen((char const   *)value);
#line 302
            if (tmp___30) {
#line 302
              tmp___32 = __builtin_strchr((char *)"\t ", (int )*value);
#line 302
              if (! tmp___32) {
#line 302
                break;
              }
            } else {
#line 302
              break;
            }
#line 303
            value ++;
          }
#line 305
          pce = config_elements;
#line 306
          handled = 0;
#line 307
          while (1) {
#line 307
            if (! handled) {
#line 307
              if (! (pce->config_element != -1)) {
#line 307
                break;
              }
            } else {
#line 307
              break;
            }
#line 308
            tmp___39 = strcasecmp((char const   *)term, (char const   *)pce->name);
#line 308
            if (tmp___39 == 0) {
#line 308
              if (pce->config_element) {
#line 310
                handled = 1;
#line 311
                pce->changed = 1;
#line 313
                err_log(9, 1U, (char *)"Read %s: %s\n", pce->name, value);
#line 315
                switch (pce->type) {
                case 1: 
#line 318
                if (*((char **)pce->var)) {
#line 319
                  free((void *)*((char **)pce->var));
                }
#line 320
                tmp___38 = __strdup((char const   *)value);
#line 320
                *((char **)pce->var) = (char *)((void *)tmp___38);
#line 321
                break;
                case 0: 
#line 323
                *((int *)pce->var) = atoi((char const   *)value);
#line 324
                break;
                }
              }
            }
#line 327
            pce ++;
          }
#line 330
          if (! handled) {
#line 331
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid config directive: %s\n",
                    buffer___0);
#line 332
            fclose(fin);
#line 333
            return (-1);
          }
        }
      }
    }
  }
#line 338
  fclose(fin);
#line 339
  free((void *)buffer___0);
#line 342
  realpath((char const   * __restrict  )config.web_root, (char * __restrict  )(path_buffer));
#line 343
  free((void *)config.web_root);
#line 344
  tmp___47 = __strdup((char const   *)(path_buffer));
#line 344
  config.web_root = tmp___47;
#line 346
  realpath((char const   * __restrict  )config.mp3dir, (char * __restrict  )(path_buffer));
#line 347
  free((void *)config.mp3dir);
#line 348
  tmp___53 = __strdup((char const   *)(path_buffer));
#line 348
  config.mp3dir = tmp___53;
#line 350
  realpath((char const   * __restrict  )config.dbdir, (char * __restrict  )(path_buffer));
#line 351
  free((void *)config.dbdir);
#line 352
  tmp___59 = __strdup((char const   *)(path_buffer));
#line 352
  config.dbdir = tmp___59;
#line 355
  pce = config_elements;
#line 356
  err = 0;
#line 357
  while (pce->config_element != -1) {
#line 358
    if (pce->required) {
#line 358
      if (pce->config_element) {
#line 358
        if (! pce->changed) {
#line 359
          err_log(1, 1U, (char *)"Required config entry \'%s\' not specified\n", pce->name);
#line 360
          err = -1;
        }
      }
    }
#line 376
    pce->changed = 0;
#line 377
    pce ++;
  }
#line 382
  sprintf((char * __restrict  )(path_buffer), (char const   * __restrict  )"%s/index.html",
          config.web_root);
#line 383
  fin = fopen((char const   * __restrict  )(path_buffer), (char const   * __restrict  )"r");
#line 383
  if ((unsigned int )fin == (unsigned int )((void *)0)) {
#line 384
    err = -1;
#line 385
    err_log(1, 1U, (char *)"Invalid web_root\n");
#line 388
    tmp___60 = strcasecmp((char const   *)config.web_root, "/usr/share/mt-daapd/admin-root");
#line 388
    if (tmp___60 == 0) {
#line 390
      fin = fopen((char const   * __restrict  )"/usr/local/share/mt-daapd/admin-root",
                  (char const   * __restrict  )"r");
#line 390
      if ((unsigned int )fin != (unsigned int )((void *)0)) {
#line 391
        fclose(fin);
#line 392
        err_log(1, 1U, (char *)"Should it be /usr/local/share/mt-daapd/admin-root?");
      }
    }
  } else {
#line 396
    fclose(fin);
  }
#line 400
  tmp___63 = config_existdir(config.mp3dir);
#line 400
  if (! tmp___63) {
#line 401
    tmp___61 = __errno_location();
#line 401
    tmp___62 = strerror(*tmp___61);
#line 401
    err_log(1, 1U, (char *)"Bad mp3 directory (%s): %s\n", config.mp3dir, tmp___62);
#line 402
    return (-1);
  }
#line 405
  tmp___67 = config_existdir(config.dbdir);
#line 405
  if (! tmp___67) {
#line 407
    tmp___66 = config_makedir(config.dbdir);
#line 407
    if (tmp___66) {
#line 408
      tmp___64 = __errno_location();
#line 408
      tmp___65 = strerror(*tmp___64);
#line 408
      err_log(1, 1U, (char *)"Database dir %s does not exist, cannot create: %s\n",
              config.dbdir, tmp___65);
#line 410
      return (-1);
    }
  }
#line 415
  if (0) {
#line 415
    if (0) {
#line 415
      __s1_len = strlen("1.2.3");
#line 415
      __s2_len = strlen("0.");
#line 415
      if (! ((unsigned int )((void const   *)("1.2.3" + 1)) - (unsigned int )((void const   *)"1.2.3") == 1U)) {
        goto _L___0;
      } else {
#line 415
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 415
          if (! ((unsigned int )((void const   *)("0." + 1)) - (unsigned int )((void const   *)"0.") == 1U)) {
#line 415
            tmp___76 = 1;
          } else {
#line 415
            if (__s2_len >= 4U) {
#line 415
              tmp___76 = 1;
            } else {
#line 415
              tmp___76 = 0;
            }
          }
        } else {
#line 415
          tmp___76 = 0;
        }
      }
#line 415
      if (tmp___76) {
#line 415
        tmp___71 = __builtin_strcmp("1.2.3", "0.");
#line 415
        tmp___75 = tmp___71;
      } else {
#line 415
        tmp___74 = __builtin_strcmp("1.2.3", "0.");
#line 415
        tmp___75 = tmp___74;
      }
    } else {
#line 415
      tmp___74 = __builtin_strcmp("1.2.3", "0.");
#line 415
      tmp___75 = tmp___74;
    }
#line 415
    tmp___78 = tmp___75;
  } else {
#line 415
    tmp___77 = strncmp("1.2.3", "0.", 2U);
#line 415
    tmp___78 = tmp___77;
  }
#line 417
  if (tmp___78) {
#line 416
    if (0) {
#line 416
      if (0) {
#line 416
        __s1_len___0 = strlen("1.2.3");
#line 416
        __s2_len___0 = strlen("1.0");
#line 416
        if (! ((unsigned int )((void const   *)("1.2.3" + 1)) - (unsigned int )((void const   *)"1.2.3") == 1U)) {
          goto _L___2;
        } else {
#line 416
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 416
            if (! ((unsigned int )((void const   *)("1.0" + 1)) - (unsigned int )((void const   *)"1.0") == 1U)) {
#line 416
              tmp___89 = 1;
            } else {
#line 416
              if (__s2_len___0 >= 4U) {
#line 416
                tmp___89 = 1;
              } else {
#line 416
                tmp___89 = 0;
              }
            }
          } else {
#line 416
            tmp___89 = 0;
          }
        }
#line 416
        if (tmp___89) {
#line 416
          tmp___84 = __builtin_strcmp("1.2.3", "1.0");
#line 416
          tmp___88 = tmp___84;
        } else {
#line 416
          tmp___87 = __builtin_strcmp("1.2.3", "1.0");
#line 416
          tmp___88 = tmp___87;
        }
      } else {
#line 416
        tmp___87 = __builtin_strcmp("1.2.3", "1.0");
#line 416
        tmp___88 = tmp___87;
      }
#line 416
      tmp___91 = tmp___88;
    } else {
#line 416
      tmp___90 = strncmp("1.2.3", "1.0", 3U);
#line 416
      tmp___91 = tmp___90;
    }
#line 417
    if (tmp___91) {
#line 417
      if (0) {
#line 417
        if (0) {
#line 417
          __s1_len___1 = strlen("1.2.3");
#line 417
          __s2_len___1 = strlen("1.1");
#line 417
          if (! ((unsigned int )((void const   *)("1.2.3" + 1)) - (unsigned int )((void const   *)"1.2.3") == 1U)) {
            goto _L___4;
          } else {
#line 417
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 417
              if (! ((unsigned int )((void const   *)("1.1" + 1)) - (unsigned int )((void const   *)"1.1") == 1U)) {
#line 417
                tmp___102 = 1;
              } else {
#line 417
                if (__s2_len___1 >= 4U) {
#line 417
                  tmp___102 = 1;
                } else {
#line 417
                  tmp___102 = 0;
                }
              }
            } else {
#line 417
              tmp___102 = 0;
            }
          }
#line 417
          if (tmp___102) {
#line 417
            tmp___97 = __builtin_strcmp("1.2.3", "1.1");
#line 417
            tmp___101 = tmp___97;
          } else {
#line 417
            tmp___100 = __builtin_strcmp("1.2.3", "1.1");
#line 417
            tmp___101 = tmp___100;
          }
        } else {
#line 417
          tmp___100 = __builtin_strcmp("1.2.3", "1.1");
#line 417
          tmp___101 = tmp___100;
        }
#line 417
        tmp___104 = tmp___101;
      } else {
#line 417
        tmp___103 = strncmp("1.2.3", "1.1", 3U);
#line 417
        tmp___104 = tmp___103;
      }
#line 417
      if (! tmp___104) {
        _L___5: /* CIL Label */ 
#line 418
        if (config.compress) {
#line 419
          config.compress = 0;
#line 420
          err_log(1, 1U, (char *)"Must have zlib > 1.2.0 to use gzip content encoding.  You have %s.  Disabling.\n",
                  "1.2.3");
        }
      }
    } else {
      goto _L___5;
    }
  } else {
    goto _L___5;
  }
#line 424
  return (err);
}
}
#line 431 "configfile.c"
void config_close(void) 
{ CONFIGELEMENT *pce ;
  int err ;

  {
#line 436
  free((void *)config.configfile);
#line 437
  pce = config_elements;
#line 438
  err = 0;
#line 439
  while (pce->config_element != -1) {
#line 440
    if (pce->config_element) {
#line 440
      if (pce->type == 1) {
#line 440
        if (*((char **)pce->var)) {
#line 443
          err_log(9, 1U, (char *)"Freeing %s\n", pce->name);
#line 444
          free((void *)*((char **)pce->var));
        }
      }
    }
#line 446
    pce ++;
  }
#line 448
  return;
}
}
#line 457 "configfile.c"
int config_write(WS_CONNINFO *pwsc ) 
{ FILE *configfile ;
  char ctime_buf[27] ;
  time_t now ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  size_t tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  size_t tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  size_t tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;

  {
#line 462
  configfile = fopen((char const   * __restrict  )config.configfile, (char const   * __restrict  )"w");
#line 463
  if (! configfile) {
#line 464
    return (-1);
  }
#line 466
  now = time((time_t *)((void *)0));
#line 467
  ctime_r((time_t const   * __restrict  )(& now), (char * __restrict  )(ctime_buf));
#line 468
  fprintf((FILE * __restrict  )configfile, (char const   * __restrict  )"#\n# mt-daapd.conf\n#\n");
#line 469
  fprintf((FILE * __restrict  )configfile, (char const   * __restrict  )"# Edited: %s",
          ctime_buf);
#line 470
  tmp = ws_getvar(pwsc, (char *)"HTTP_USER");
#line 470
  fprintf((FILE * __restrict  )configfile, (char const   * __restrict  )"# By:     %s\n",
          tmp);
#line 471
  fprintf((FILE * __restrict  )configfile, (char const   * __restrict  )"#\n");
#line 473
  tmp___0 = ws_getvar(pwsc, (char *)"web_root");
#line 473
  fprintf((FILE * __restrict  )configfile, (char const   * __restrict  )"web_root\t%s\n",
          tmp___0);
#line 474
  tmp___1 = ws_getvar(pwsc, (char *)"port");
#line 474
  fprintf((FILE * __restrict  )configfile, (char const   * __restrict  )"port\t\t%s\n",
          tmp___1);
#line 475
  tmp___2 = ws_getvar(pwsc, (char *)"admin_pw");
#line 475
  fprintf((FILE * __restrict  )configfile, (char const   * __restrict  )"admin_pw\t%s\n",
          tmp___2);
#line 476
  tmp___3 = ws_getvar(pwsc, (char *)"mp3_dir");
#line 476
  fprintf((FILE * __restrict  )configfile, (char const   * __restrict  )"mp3_dir\t\t%s\n",
          tmp___3);
#line 477
  tmp___4 = ws_getvar(pwsc, (char *)"servername");
#line 477
  fprintf((FILE * __restrict  )configfile, (char const   * __restrict  )"servername\t%s\n",
          tmp___4);
#line 478
  tmp___5 = ws_getvar(pwsc, (char *)"runas");
#line 478
  fprintf((FILE * __restrict  )configfile, (char const   * __restrict  )"runas\t\t%s\n",
          tmp___5);
#line 479
  tmp___6 = ws_getvar(pwsc, (char *)"playlist");
#line 479
  fprintf((FILE * __restrict  )configfile, (char const   * __restrict  )"playlist\t%s\n",
          tmp___6);
#line 480
  tmp___8 = ws_getvar(pwsc, (char *)"password");
#line 480
  if (tmp___8) {
#line 480
    tmp___9 = ws_getvar(pwsc, (char *)"password");
#line 480
    tmp___10 = strlen((char const   *)tmp___9);
#line 480
    if (tmp___10) {
#line 481
      tmp___7 = ws_getvar(pwsc, (char *)"password");
#line 481
      fprintf((FILE * __restrict  )configfile, (char const   * __restrict  )"password\t%s\n",
              tmp___7);
    }
  }
#line 482
  tmp___11 = ws_getvar(pwsc, (char *)"extensions");
#line 482
  fprintf((FILE * __restrict  )configfile, (char const   * __restrict  )"extensions\t%s\n",
          tmp___11);
#line 483
  tmp___12 = ws_getvar(pwsc, (char *)"db_dir");
#line 483
  fprintf((FILE * __restrict  )configfile, (char const   * __restrict  )"db_dir\t\t%s\n",
          tmp___12);
#line 484
  tmp___13 = ws_getvar(pwsc, (char *)"rescan_interval");
#line 484
  fprintf((FILE * __restrict  )configfile, (char const   * __restrict  )"rescan_interval\t%s\n",
          tmp___13);
#line 485
  tmp___14 = ws_getvar(pwsc, (char *)"scan_type");
#line 485
  fprintf((FILE * __restrict  )configfile, (char const   * __restrict  )"scan_type\t%s\n",
          tmp___14);
#line 486
  tmp___16 = ws_getvar(pwsc, (char *)"always_scan");
#line 486
  if (tmp___16) {
#line 486
    tmp___17 = ws_getvar(pwsc, (char *)"always_scan");
#line 486
    tmp___18 = strlen((char const   *)tmp___17);
#line 486
    if (tmp___18) {
#line 487
      tmp___15 = ws_getvar(pwsc, (char *)"always_scan");
#line 487
      fprintf((FILE * __restrict  )configfile, (char const   * __restrict  )"always_scan\t%s\n",
              tmp___15);
    }
  }
#line 488
  tmp___20 = ws_getvar(pwsc, (char *)"art_filename");
#line 488
  if (tmp___20) {
#line 488
    tmp___21 = ws_getvar(pwsc, (char *)"art_filename");
#line 488
    tmp___22 = strlen((char const   *)tmp___21);
#line 488
    if (tmp___22) {
#line 489
      tmp___19 = ws_getvar(pwsc, (char *)"art_filename");
#line 489
      fprintf((FILE * __restrict  )configfile, (char const   * __restrict  )"art_filename\t%s\n",
              tmp___19);
    }
  }
#line 490
  tmp___24 = ws_getvar(pwsc, (char *)"logfile");
#line 490
  if (tmp___24) {
#line 490
    tmp___25 = ws_getvar(pwsc, (char *)"logfile");
#line 490
    tmp___26 = strlen((char const   *)tmp___25);
#line 490
    if (tmp___26) {
#line 491
      tmp___23 = ws_getvar(pwsc, (char *)"logfile");
#line 491
      fprintf((FILE * __restrict  )configfile, (char const   * __restrict  )"logfile\t\t%s\n",
              tmp___23);
    }
  }
#line 492
  tmp___27 = ws_getvar(pwsc, (char *)"process_m3u");
#line 492
  fprintf((FILE * __restrict  )configfile, (char const   * __restrict  )"process_m3u\t%s\n",
          tmp___27);
#line 493
  tmp___28 = ws_getvar(pwsc, (char *)"compress");
#line 493
  fprintf((FILE * __restrict  )configfile, (char const   * __restrict  )"compress\t%s\n",
          tmp___28);
#line 495
  fclose(configfile);
#line 496
  return (0);
}
}
#line 508 "configfile.c"
static void config_subst_stream(WS_CONNINFO *pwsc , int fd_src ) 
{ int in_arg ;
  char *argptr ;
  char argbuffer[80] ;
  char next ;
  CONFIGELEMENT *pce ;
  char *first ;
  char *last ;
  ssize_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 517
  in_arg = 0;
#line 518
  argptr = argbuffer;
#line 520
  while (1) {
#line 521
    tmp = r_read(fd_src, (void *)(& next), 1U);
#line 521
    if (tmp <= 0) {
#line 522
      break;
    }
#line 524
    if (in_arg) {
#line 525
      if ((int )next == 64) {
#line 525
        tmp___2 = strlen((char const   *)(argbuffer));
#line 525
        if (tmp___2 > 0U) {
#line 526
          in_arg = 0;
#line 528
          err_log(9, 1U, (char *)"Got directive %s\n", argbuffer);
#line 531
          last = argbuffer;
#line 531
          first = last;
#line 532
          __strsep_g(& last, " ");
#line 534
          pce = config_elements;
#line 535
          while (pce->config_element != -1) {
#line 536
            tmp___0 = strcasecmp((char const   *)first, (char const   *)pce->name);
#line 536
            if (tmp___0 == 0) {
#line 537
              (*(pce->emit))(pwsc, pce->var, last);
#line 538
              break;
            }
#line 540
            pce ++;
          }
#line 543
          if (pce->config_element == -1) {
#line 544
            ws_writefd(pwsc, (char *)"@%s@", argbuffer);
          }
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 546
        if ((int )next == 64) {
#line 547
          ws_writefd(pwsc, (char *)"@");
#line 548
          in_arg = 0;
        } else {
#line 550
          if ((unsigned int )(argptr - argbuffer) < sizeof(argbuffer) - 1U) {
#line 551
            tmp___1 = argptr;
#line 551
            argptr ++;
#line 551
            *tmp___1 = next;
          }
        }
      }
    } else {
#line 554
      if ((int )next == 64) {
#line 555
        argptr = argbuffer;
#line 556
        memset((void *)(argbuffer), 0, sizeof(argbuffer));
#line 557
        in_arg = 1;
      } else {
#line 559
        tmp___3 = r_write(pwsc->fd, (void *)(& next), 1U);
#line 559
        if (tmp___3 == -1) {
#line 560
          break;
        }
      }
    }
  }
#line 564
  return;
}
}
#line 572 "configfile.c"
void config_handler(WS_CONNINFO *pwsc ) 
{ char path[4096] ;
  char resolved_path[4096] ;
  int file_fd ;
  struct stat sb ;
  char *pw ;
  int *tmp ;
  char *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int *tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___31 ;
  char *tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t tmp___40 ;
  int tmp___41 ;

  {
#line 579
  err_log(9, 3U, (char *)"Entering config_handler\n");
#line 581
  config_set_status(pwsc, 0, (char *)"Serving admin pages");
#line 583
  pwsc->close = 1;
#line 584
  ws_addresponseheader(pwsc, (char *)"Connection", (char *)"close");
#line 586
  snprintf((char * __restrict  )(path), 4096U, (char const   * __restrict  )"%s/%s",
           config.web_root, pwsc->uri);
#line 587
  tmp___0 = realpath((char const   * __restrict  )(path), (char * __restrict  )(resolved_path));
#line 587
  if (! tmp___0) {
#line 588
    tmp = __errno_location();
#line 588
    pwsc->error = *tmp;
#line 589
    err_log(2, 3U, (char *)"Cannot resolve %s\n", path);
#line 590
    ws_returnerror(pwsc, 404, (char *)"Not found");
#line 591
    config_set_status(pwsc, 0, (char *)((void *)0));
#line 592
    return;
  }
#line 596
  stat((char const   * __restrict  )(resolved_path), (struct stat * __restrict  )(& sb));
#line 597
  if (sb.st_mode & 16384U) {
#line 598
    strcat((char * __restrict  )(resolved_path), (char const   * __restrict  )"/index.html");
  }
#line 600
  err_log(9, 3U, (char *)"Thread %d: Preparing to serve %s\n", pwsc->threadno, resolved_path);
#line 603
  if (0) {
#line 603
    if (0) {
#line 603
      __s1_len = strlen((char const   *)(resolved_path));
#line 603
      __s2_len = strlen((char const   *)config.web_root);
#line 603
      if (! ((unsigned int )((void const   *)(resolved_path + 1)) - (unsigned int )((void const   *)(resolved_path)) == 1U)) {
        goto _L___0;
      } else {
#line 603
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 603
          if (! ((unsigned int )((void const   *)(config.web_root + 1)) - (unsigned int )((void const   *)config.web_root) == 1U)) {
#line 603
            tmp___12 = 1;
          } else {
#line 603
            if (__s2_len >= 4U) {
#line 603
              tmp___12 = 1;
            } else {
#line 603
              tmp___12 = 0;
            }
          }
        } else {
#line 603
          tmp___12 = 0;
        }
      }
#line 603
      if (tmp___12) {
#line 603
        tmp___7 = __builtin_strcmp((char const   *)(resolved_path), (char const   *)config.web_root);
#line 603
        tmp___11 = tmp___7;
      } else {
#line 603
        tmp___10 = __builtin_strcmp((char const   *)(resolved_path), (char const   *)config.web_root);
#line 603
        tmp___11 = tmp___10;
      }
    } else {
#line 603
      tmp___10 = __builtin_strcmp((char const   *)(resolved_path), (char const   *)config.web_root);
#line 603
      tmp___11 = tmp___10;
    }
#line 603
    tmp___15 = tmp___11;
  } else {
#line 603
    tmp___13 = strlen((char const   *)config.web_root);
#line 603
    tmp___14 = strncmp((char const   *)(resolved_path), (char const   *)config.web_root,
                       tmp___13);
#line 603
    tmp___15 = tmp___14;
  }
#line 603
  if (tmp___15) {
#line 605
    pwsc->error = 22;
#line 606
    err_log(2, 3U, (char *)"Thread %d: Requested file %s out of root\n", pwsc->threadno,
            resolved_path);
#line 608
    ws_returnerror(pwsc, 403, (char *)"Forbidden");
#line 609
    config_set_status(pwsc, 0, (char *)((void *)0));
#line 610
    return;
  }
#line 613
  file_fd = r_open2((char const   *)(resolved_path), 0);
#line 614
  if (file_fd == -1) {
#line 615
    tmp___21 = __errno_location();
#line 615
    pwsc->error = *tmp___21;
#line 616
    tmp___22 = __errno_location();
#line 616
    tmp___23 = strerror(*tmp___22);
#line 616
    err_log(2, 3U, (char *)"Thread %d: Error opening %s: %s\n", pwsc->threadno, resolved_path,
            tmp___23);
#line 618
    ws_returnerror(pwsc, 404, (char *)"Not found");
#line 619
    config_set_status(pwsc, 0, (char *)((void *)0));
#line 620
    return;
  }
#line 623
  tmp___39 = strcasecmp((char const   *)pwsc->uri, "/config-update.html");
#line 623
  if (tmp___39 == 0) {
#line 627
    pw = ws_getvar(pwsc, (char *)"action");
#line 628
    if (pw) {
#line 630
      tmp___24 = strcasecmp((char const   *)pw, "stopdaap");
#line 630
      if (tmp___24 == 0) {
#line 631
        config.stop = 1;
      }
#line 633
      tmp___25 = strcasecmp((char const   *)pw, "rescan");
#line 633
      if (tmp___25 == 0) {
#line 634
        config.reload = 1;
      }
    } else {
#line 638
      pw = ws_getvar(pwsc, (char *)"admin_pw");
#line 639
      if (pw) {
#line 640
        if (config.adminpassword) {
#line 641
          free((void *)config.adminpassword);
        }
#line 642
        tmp___31 = __strdup((char const   *)pw);
#line 642
        config.adminpassword = tmp___31;
      }
#line 645
      pw = ws_getvar(pwsc, (char *)"password");
#line 646
      if (pw) {
#line 647
        if (config.readpassword) {
#line 648
          free((void *)config.readpassword);
        }
#line 649
        tmp___37 = __strdup((char const   *)pw);
#line 649
        config.readpassword = tmp___37;
      }
#line 652
      pw = ws_getvar(pwsc, (char *)"rescan_interval");
#line 653
      if (pw) {
#line 654
        config.rescan_interval = atoi((char const   *)pw);
      }
#line 657
      tmp___38 = config_file_is_readonly();
#line 657
      if (! tmp___38) {
#line 658
        err_log(5, 3U, (char *)"Updating config file\n");
#line 659
        config_write(pwsc);
      }
    }
  }
#line 664
  ws_writefd(pwsc, (char *)"HTTP/1.1 200 OK\r\n");
#line 665
  ws_emitheaders(pwsc);
#line 667
  tmp___40 = strlen((char const   *)(resolved_path));
#line 667
  tmp___41 = strcasecmp((char const   *)(& resolved_path[tmp___40 - 5U]), ".html");
#line 667
  if (tmp___41 == 0) {
#line 668
    config_subst_stream(pwsc, file_fd);
  } else {
#line 670
    copyfile(file_fd, pwsc->fd);
  }
#line 673
  r_close(file_fd);
#line 674
  err_log(9, 3U, (char *)"Thread %d: Served successfully\n", pwsc->threadno);
#line 675
  config_set_status(pwsc, 0, (char *)((void *)0));
#line 676
  return;
}
}
#line 685 "configfile.c"
int config_auth(char *user , char *password ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 686
  if (! password) {
#line 687
    return (0);
  } else {
#line 686
    if (! config.adminpassword) {
#line 687
      return (0);
    }
  }
#line 688
  if (0) {
#line 688
    __s1_len = strlen((char const   *)password);
#line 688
    __s2_len = strlen((char const   *)config.adminpassword);
#line 688
    if (! ((unsigned int )((void const   *)(password + 1)) - (unsigned int )((void const   *)password) == 1U)) {
      goto _L___0;
    } else {
#line 688
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 688
        if (! ((unsigned int )((void const   *)(config.adminpassword + 1)) - (unsigned int )((void const   *)config.adminpassword) == 1U)) {
#line 688
          tmp___5 = 1;
        } else {
#line 688
          if (__s2_len >= 4U) {
#line 688
            tmp___5 = 1;
          } else {
#line 688
            tmp___5 = 0;
          }
        }
      } else {
#line 688
        tmp___5 = 0;
      }
    }
#line 688
    if (tmp___5) {
#line 688
      tmp___0 = __builtin_strcmp((char const   *)password, (char const   *)config.adminpassword);
#line 688
      tmp___4 = tmp___0;
    } else {
#line 688
      tmp___3 = __builtin_strcmp((char const   *)password, (char const   *)config.adminpassword);
#line 688
      tmp___4 = tmp___3;
    }
  } else {
#line 688
    tmp___3 = __builtin_strcmp((char const   *)password, (char const   *)config.adminpassword);
#line 688
    tmp___4 = tmp___3;
  }
#line 688
  if (tmp___4) {
#line 688
    tmp___6 = 0;
  } else {
#line 688
    tmp___6 = 1;
  }
#line 688
  return (tmp___6);
}
}
#line 699 "configfile.c"
static void config_emit_string(WS_CONNINFO *pwsc , void *value , char *arg ) 
{ 

  {
#line 700
  if (*((char **)value)) {
#line 701
    ws_writefd(pwsc, (char *)"%s", *((char **)value));
  }
#line 702
  return;
}
}
#line 712 "configfile.c"
static void config_emit_literal(WS_CONNINFO *pwsc , void *value , char *arg ) 
{ 

  {
#line 713
  ws_writefd(pwsc, (char *)"%s", (char *)value);
#line 714
  return;
}
}
#line 724 "configfile.c"
static void config_emit_int(WS_CONNINFO *pwsc , void *value , char *arg ) 
{ 

  {
#line 725
  ws_writefd(pwsc, (char *)"%d", *((int *)value));
#line 726
  return;
}
}
#line 738 "configfile.c"
static void config_emit_service_status(WS_CONNINFO *pwsc , void *value , char *arg ) 
{ int mdns_running ;
  char *html ;
  char buf[256] ;
  int r_days ;
  int r_hours ;
  int r_mins ;
  int r_secs ;
  int scanning ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  time_t tmp___4 ;
  char const   *tmp___5 ;
  size_t tmp___6 ;
  char const   *tmp___7 ;
  size_t tmp___8 ;
  char const   *tmp___9 ;
  size_t tmp___10 ;
  char const   *tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 745
  ws_writefd(pwsc, (char *)"<TABLE><TR><TH ALIGN=LEFT>Service</TH>");
#line 746
  ws_writefd(pwsc, (char *)"<TH ALIGN=LEFT>Status</TH><TH ALIGN=LEFT>Control</TH></TR>\n");
#line 748
  ws_writefd(pwsc, (char *)"<TR><TD>Rendezvous</TD>");
#line 750
  if (config.use_mdns) {
#line 751
    tmp = rend_running();
#line 751
    if (tmp) {
#line 751
      tmp___0 = 0;
    } else {
#line 751
      tmp___0 = 1;
    }
#line 751
    mdns_running = tmp___0;
#line 753
    if (mdns_running) {
#line 754
      html = (char *)"<a href=\"config-update.html?action=stopmdns\">Stop MDNS Server</a>";
    } else {
#line 756
      html = (char *)"<a href=\"config-update.html?action=startmdns\">Start MDNS Server</a>";
    }
#line 759
    if (mdns_running) {
#line 759
      tmp___1 = "Running";
    } else {
#line 759
      tmp___1 = "Stopped";
    }
#line 759
    ws_writefd(pwsc, (char *)"<TD>%s</TD><TD>%s</TD></TR>\n", tmp___1, html);
  } else {
#line 762
    ws_writefd(pwsc, (char *)"<TD>Not configured</TD><TD>&nbsp;</TD></TR>\n");
  }
#line 768
  if (config.stop) {
#line 768
    tmp___2 = "Stopping";
  } else {
#line 768
    tmp___2 = "Running";
  }
#line 768
  ws_writefd(pwsc, (char *)"<TR><TD>DAAP Server</TD><TD>%s</TD>", tmp___2);
#line 769
  if (config.stop) {
#line 770
    ws_writefd(pwsc, (char *)"<TD>Wait...</TD></TR>\n");
  } else {
#line 772
    ws_writefd(pwsc, (char *)"<TD><a href=\"config-update.html?action=stopdaap\">Stop DAAP Server</a></TD></TR>");
  }
#line 775
  scanning = config.reload;
#line 776
  if (scanning) {
#line 776
    tmp___3 = "Running";
  } else {
#line 776
    tmp___3 = "Idle";
  }
#line 776
  ws_writefd(pwsc, (char *)"<TR><TD>Background scanner</TD><TD>%s</TD>", tmp___3);
#line 777
  if (scanning) {
#line 778
    ws_writefd(pwsc, (char *)"<TD>Wait...</TD></TR>");
  } else {
#line 780
    ws_writefd(pwsc, (char *)"<TD><A HREF=\"config-update.html?action=rescan\">Start Scan</A></TD></TR>");
  }
#line 783
  ws_writefd(pwsc, (char *)"</TABLE>\n");
#line 785
  ws_writefd(pwsc, (char *)"<TABLE>\n");
#line 786
  ws_writefd(pwsc, (char *)"<TR>\n");
#line 787
  ws_writefd(pwsc, (char *)" <TH>Uptime</TH>\n");
#line 789
  tmp___4 = time((time_t *)((void *)0));
#line 789
  r_secs = (int )(tmp___4 - config.stats.start_time);
#line 791
  r_days = r_secs / 86400;
#line 792
  r_secs -= 86400 * r_days;
#line 794
  r_hours = r_secs / 3600;
#line 795
  r_secs -= 3600 * r_hours;
#line 797
  r_mins = r_secs / 60;
#line 798
  r_secs -= 60 * r_mins;
#line 800
  memset((void *)(buf), 0, sizeof(buf));
#line 801
  if (r_days) {
#line 802
    if (r_days == 1) {
#line 802
      tmp___5 = "";
    } else {
#line 802
      tmp___5 = "s";
    }
#line 802
    tmp___6 = strlen((char const   *)(buf));
#line 802
    sprintf((char * __restrict  )(& buf[tmp___6]), (char const   * __restrict  )"%d day%s, ",
            r_days, tmp___5);
  }
#line 805
  if (r_days) {
    goto _L;
  } else {
#line 805
    if (r_hours) {
      _L: /* CIL Label */ 
#line 806
      if (r_hours == 1) {
#line 806
        tmp___7 = "";
      } else {
#line 806
        tmp___7 = "s";
      }
#line 806
      tmp___8 = strlen((char const   *)(buf));
#line 806
      sprintf((char * __restrict  )(& buf[tmp___8]), (char const   * __restrict  )"%d hour%s, ",
              r_hours, tmp___7);
    }
  }
#line 809
  if (r_days) {
    goto _L___0;
  } else {
#line 809
    if (r_hours) {
      goto _L___0;
    } else {
#line 809
      if (r_mins) {
        _L___0: /* CIL Label */ 
#line 810
        if (r_mins == 1) {
#line 810
          tmp___9 = "";
        } else {
#line 810
          tmp___9 = "s";
        }
#line 810
        tmp___10 = strlen((char const   *)(buf));
#line 810
        sprintf((char * __restrict  )(& buf[tmp___10]), (char const   * __restrict  )"%d minute%s, ",
                r_mins, tmp___9);
      }
    }
  }
#line 813
  if (r_secs == 1) {
#line 813
    tmp___11 = "";
  } else {
#line 813
    tmp___11 = "s";
  }
#line 813
  tmp___12 = strlen((char const   *)(buf));
#line 813
  sprintf((char * __restrict  )(& buf[tmp___12]), (char const   * __restrict  )"%d second%s ",
          r_secs, tmp___11);
#line 816
  ws_writefd(pwsc, (char *)" <TD>%s</TD>\n", buf);
#line 817
  ws_writefd(pwsc, (char *)"</TR>\n");
#line 819
  ws_writefd(pwsc, (char *)"<TR>\n");
#line 820
  ws_writefd(pwsc, (char *)" <TH>Songs</TH>\n");
#line 821
  tmp___13 = db_get_song_count();
#line 821
  ws_writefd(pwsc, (char *)" <TD>%d</TD>\n", tmp___13);
#line 822
  ws_writefd(pwsc, (char *)"</TR>\n");
#line 824
  ws_writefd(pwsc, (char *)"<TR>\n");
#line 825
  ws_writefd(pwsc, (char *)" <TH>Songs Served</TH>\n");
#line 826
  ws_writefd(pwsc, (char *)" <TD>%d</TD>\n", config.stats.songs_served);
#line 827
  ws_writefd(pwsc, (char *)"</TR>\n");
#line 829
  if (! scanning) {
#line 830
    ws_writefd(pwsc, (char *)"<TR>\n");
#line 831
    ws_writefd(pwsc, (char *)" <TH>DB Version</TH>\n");
#line 832
    tmp___14 = db_version();
#line 832
    ws_writefd(pwsc, (char *)" <TD>%d</TD>\n", tmp___14);
#line 833
    ws_writefd(pwsc, (char *)"</TR>\n");
  }
#line 843
  ws_writefd(pwsc, (char *)"</TABLE>\n");
#line 844
  return;
}
}
#line 855 "configfile.c"
int config_get_session_count(void) 
{ SCAN_STATUS *pcurrent ;
  SCAN_STATUS *pcheck ;
  int count ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 857
  count = 0;
#line 859
  tmp = config_mutex_lock();
#line 859
  if (tmp) {
#line 860
    return (0);
  }
#line 863
  pcurrent = scan_status.next;
#line 865
  while (pcurrent) {
#line 866
    pcheck = scan_status.next;
#line 867
    while ((unsigned int )pcheck != (unsigned int )pcurrent) {
#line 868
      if (0) {
#line 868
        __s1_len = strlen((char const   *)pcheck->host);
#line 868
        __s2_len = strlen((char const   *)pcurrent->host);
#line 868
        if (! ((unsigned int )((void const   *)(pcheck->host + 1)) - (unsigned int )((void const   *)pcheck->host) == 1U)) {
          goto _L___0;
        } else {
#line 868
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 868
            if (! ((unsigned int )((void const   *)(pcurrent->host + 1)) - (unsigned int )((void const   *)pcurrent->host) == 1U)) {
#line 868
              tmp___6 = 1;
            } else {
#line 868
              if (__s2_len >= 4U) {
#line 868
                tmp___6 = 1;
              } else {
#line 868
                tmp___6 = 0;
              }
            }
          } else {
#line 868
            tmp___6 = 0;
          }
        }
#line 868
        if (tmp___6) {
#line 868
          tmp___1 = __builtin_strcmp((char const   *)pcheck->host, (char const   *)pcurrent->host);
#line 868
          tmp___5 = tmp___1;
        } else {
#line 868
          tmp___4 = __builtin_strcmp((char const   *)pcheck->host, (char const   *)pcurrent->host);
#line 868
          tmp___5 = tmp___4;
        }
      } else {
#line 868
        tmp___4 = __builtin_strcmp((char const   *)pcheck->host, (char const   *)pcurrent->host);
#line 868
        tmp___5 = tmp___4;
      }
#line 868
      if (tmp___5 == 0) {
#line 869
        break;
      }
#line 870
      pcheck = pcheck->next;
    }
#line 873
    if ((unsigned int )pcheck == (unsigned int )pcurrent) {
#line 874
      count ++;
    }
#line 876
    pcurrent = pcurrent->next;
  }
#line 879
  config_mutex_unlock();
#line 880
  return (count);
}
}
#line 892 "configfile.c"
static void config_emit_session_count(WS_CONNINFO *pwsc , void *value , char *arg ) 
{ int tmp ;

  {
#line 893
  tmp = config_get_session_count();
#line 893
  ws_writefd(pwsc, (char *)"%d", tmp);
#line 894
  return;
}
}
#line 904 "configfile.c"
static void config_emit_threadstatus(WS_CONNINFO *pwsc , void *value , char *arg ) 
{ SCAN_STATUS *pss ;
  int tmp ;

  {
#line 907
  tmp = config_mutex_lock();
#line 907
  if (tmp) {
#line 908
    return;
  }
#line 910
  ws_writefd(pwsc, (char *)"<TABLE><TR><TH ALIGN=LEFT>Thread</TH>");
#line 911
  ws_writefd(pwsc, (char *)"<TH ALIGN=LEFT>Session</TH><TH ALIGN=LEFT>Host</TH>");
#line 912
  ws_writefd(pwsc, (char *)"<TH ALIGN=LEFT>Action</TH></TR>\n");
#line 915
  pss = scan_status.next;
#line 916
  while (pss) {
#line 917
    ws_writefd(pwsc, (char *)"<TR><TD>%d</TD><TD>%d</TD><TD>%s</TD><TD>%s</TD></TR>\n",
               pss->thread, pss->session, pss->host, pss->what);
#line 919
    pss = pss->next;
  }
#line 922
  ws_writefd(pwsc, (char *)"</TABLE>\n");
#line 923
  config_mutex_unlock();
#line 924
  return;
}
}
#line 937 "configfile.c"
static void config_emit_ispage(WS_CONNINFO *pwsc , void *value , char *arg ) 
{ char *first ;
  char *last ;
  char *page ;
  char *true ;
  char *false ;
  char *tmp___4 ;
  char *tmp___10 ;
  char *tmp___16 ;
  char *tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  int tmp___27 ;

  {
#line 943
  err_log(9, 3U, (char *)"Splitting arg %s\n", arg);
#line 945
  last = arg;
#line 945
  first = last;
#line 946
  __strsep_g(& last, ":");
#line 948
  if (last) {
#line 949
    tmp___4 = __strdup((char const   *)first);
#line 949
    page = tmp___4;
#line 950
    if (! page) {
#line 951
      return;
    }
#line 952
    first = last;
#line 953
    __strsep_g(& last, ":");
#line 954
    if (last) {
#line 955
      tmp___10 = __strdup((char const   *)first);
#line 955
      true = tmp___10;
#line 956
      tmp___16 = __strdup((char const   *)last);
#line 956
      false = tmp___16;
#line 957
      if (! true) {
#line 958
        return;
      } else {
#line 957
        if (! false) {
#line 958
          return;
        }
      }
    } else {
#line 960
      tmp___22 = __strdup((char const   *)first);
#line 960
      true = tmp___22;
#line 961
      if (! true) {
#line 962
        return;
      }
#line 963
      false = (char *)((void *)0);
    }
  } else {
#line 966
    return;
  }
#line 970
  err_log(9, 3U, (char *)"page: %s, uri: %s\n", page, pwsc->uri);
#line 972
  tmp___23 = strlen((char const   *)page);
#line 972
  tmp___24 = strlen((char const   *)pwsc->uri);
#line 972
  if (tmp___23 > tmp___24) {
#line 974
    ws_writefd(pwsc, (char *)"%s", false);
  } else {
#line 972
    tmp___25 = strlen((char const   *)pwsc->uri);
#line 972
    tmp___26 = strlen((char const   *)page);
#line 972
    tmp___27 = strcasecmp((char const   *)page, (char const   *)(pwsc->uri + (tmp___25 - tmp___26)));
#line 972
    if (tmp___27 != 0) {
#line 974
      ws_writefd(pwsc, (char *)"%s", false);
    } else {
#line 976
      ws_writefd(pwsc, (char *)"%s", true);
    }
  }
#line 980
  if (page) {
#line 981
    free((void *)page);
  }
#line 983
  if (true) {
#line 984
    free((void *)true);
  }
#line 986
  if (false) {
#line 987
    free((void *)false);
  }
#line 988
  return;
}
}
#line 997 "configfile.c"
static void config_emit_user(WS_CONNINFO *pwsc , void *value , char *arg ) 
{ char *tmp ;
  char *tmp___0 ;

  {
#line 998
  tmp___0 = ws_getvar(pwsc, (char *)"HTTP_USER");
#line 998
  if (tmp___0) {
#line 999
    tmp = ws_getvar(pwsc, (char *)"HTTP_USER");
#line 999
    ws_writefd(pwsc, (char *)"%s", tmp);
  }
#line 1001
  return;
}
}
#line 1009 "configfile.c"
static int config_file_is_readonly(void) 
{ FILE *fin ;

  {
#line 1012
  fin = fopen((char const   * __restrict  )config.configfile, (char const   * __restrict  )"r+");
#line 1013
  if (! fin) {
#line 1014
    return (1);
  }
#line 1017
  fclose(fin);
#line 1018
  return (0);
}
}
#line 1030 "configfile.c"
static void config_emit_readonly(WS_CONNINFO *pwsc , void *value , char *arg ) 
{ int tmp ;

  {
#line 1031
  tmp = config_file_is_readonly();
#line 1031
  if (tmp) {
#line 1032
    ws_writefd(pwsc, (char *)"READONLY");
  }
#line 1034
  return;
}
}
#line 1044 "configfile.c"
static void config_emit_include(WS_CONNINFO *pwsc , void *value , char *arg ) 
{ char resolved_path[4096] ;
  char path[4096] ;
  int file_fd ;
  struct stat sb ;
  int *tmp ;
  char *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int *tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;

  {
#line 1050
  err_log(9, 3U, (char *)"Preparing to include %s\n", arg);
#line 1052
  snprintf((char * __restrict  )(path), 4096U, (char const   * __restrict  )"%s/%s",
           config.web_root, arg);
#line 1053
  tmp___0 = realpath((char const   * __restrict  )(path), (char * __restrict  )(resolved_path));
#line 1053
  if (! tmp___0) {
#line 1054
    tmp = __errno_location();
#line 1054
    pwsc->error = *tmp;
#line 1055
    err_log(2, 3U, (char *)"Cannot resolve %s\n", path);
#line 1056
    ws_writefd(pwsc, (char *)"<hr><i>error: cannot find %s</i><hr>", arg);
#line 1057
    return;
  }
#line 1061
  stat((char const   * __restrict  )(resolved_path), (struct stat * __restrict  )(& sb));
#line 1062
  if (sb.st_mode & 16384U) {
#line 1063
    ws_writefd(pwsc, (char *)"<hr><i>error: cannot include director %s</i><hr>", arg);
#line 1064
    return;
  }
#line 1068
  err_log(9, 3U, (char *)"Thread %d: Preparing to serve %s\n", pwsc->threadno, resolved_path);
#line 1071
  if (0) {
#line 1071
    if (0) {
#line 1071
      __s1_len = strlen((char const   *)(resolved_path));
#line 1071
      __s2_len = strlen((char const   *)config.web_root);
#line 1071
      if (! ((unsigned int )((void const   *)(resolved_path + 1)) - (unsigned int )((void const   *)(resolved_path)) == 1U)) {
        goto _L___0;
      } else {
#line 1071
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 1071
          if (! ((unsigned int )((void const   *)(config.web_root + 1)) - (unsigned int )((void const   *)config.web_root) == 1U)) {
#line 1071
            tmp___12 = 1;
          } else {
#line 1071
            if (__s2_len >= 4U) {
#line 1071
              tmp___12 = 1;
            } else {
#line 1071
              tmp___12 = 0;
            }
          }
        } else {
#line 1071
          tmp___12 = 0;
        }
      }
#line 1071
      if (tmp___12) {
#line 1071
        tmp___7 = __builtin_strcmp((char const   *)(resolved_path), (char const   *)config.web_root);
#line 1071
        tmp___11 = tmp___7;
      } else {
#line 1071
        tmp___10 = __builtin_strcmp((char const   *)(resolved_path), (char const   *)config.web_root);
#line 1071
        tmp___11 = tmp___10;
      }
    } else {
#line 1071
      tmp___10 = __builtin_strcmp((char const   *)(resolved_path), (char const   *)config.web_root);
#line 1071
      tmp___11 = tmp___10;
    }
#line 1071
    tmp___15 = tmp___11;
  } else {
#line 1071
    tmp___13 = strlen((char const   *)config.web_root);
#line 1071
    tmp___14 = strncmp((char const   *)(resolved_path), (char const   *)config.web_root,
                       tmp___13);
#line 1071
    tmp___15 = tmp___14;
  }
#line 1071
  if (tmp___15) {
#line 1073
    pwsc->error = 22;
#line 1074
    err_log(1, 3U, (char *)"Thread %d: Requested file %s out of root\n", pwsc->threadno,
            resolved_path);
#line 1076
    ws_writefd(pwsc, (char *)"<hr><i>error: %s out of web root</i><hr>", arg);
#line 1077
    return;
  }
#line 1080
  file_fd = r_open2((char const   *)(resolved_path), 0);
#line 1081
  if (file_fd == -1) {
#line 1082
    tmp___21 = __errno_location();
#line 1082
    pwsc->error = *tmp___21;
#line 1083
    tmp___22 = __errno_location();
#line 1083
    tmp___23 = strerror(*tmp___22);
#line 1083
    err_log(1, 3U, (char *)"Thread %d: Error opening %s: %s\n", pwsc->threadno, resolved_path,
            tmp___23);
#line 1085
    tmp___24 = __errno_location();
#line 1085
    tmp___25 = strerror(*tmp___24);
#line 1085
    ws_writefd(pwsc, (char *)"<hr><i>error: cannot open %s: %s</i><hr>", arg, tmp___25);
#line 1086
    return;
  }
#line 1089
  config_subst_stream(pwsc, file_fd);
#line 1091
  r_close(file_fd);
#line 1092
  err_log(9, 3U, (char *)"Thread %d: included successfully\n", pwsc->threadno);
#line 1093
  return;
}
}
#line 1107 "configfile.c"
void config_set_status(WS_CONNINFO *pwsc , int session , char *fmt  , ...) 
{ char buffer___0[1024] ;
  va_list ap ;
  SCAN_STATUS *pfirst ;
  SCAN_STATUS *plast ;
  int tmp ;
  char *tmp___5 ;
  void *tmp___6 ;
  char *tmp___12 ;
  char *tmp___18 ;

  {
#line 1112
  err_log(9, 1U, (char *)"Entering config_set_status\n");
#line 1114
  tmp = config_mutex_lock();
#line 1114
  if (tmp) {
#line 1116
    err_log(0, 1U, (char *)"Error acquiring config mutex\n");
  }
#line 1119
  plast = scan_status.next;
#line 1119
  pfirst = plast;
#line 1120
  while (1) {
#line 1120
    if (pfirst) {
#line 1120
      if (! (pfirst->thread != pwsc->threadno)) {
#line 1120
        break;
      }
    } else {
#line 1120
      break;
    }
#line 1121
    plast = pfirst;
#line 1122
    pfirst = pfirst->next;
  }
#line 1125
  if (fmt) {
#line 1126
    __builtin_va_start(ap, fmt);
#line 1127
    vsnprintf((char * __restrict  )(buffer___0), 1024U, (char const   * __restrict  )fmt,
              ap);
#line 1128
    __builtin_va_end(ap);
#line 1130
    if (pfirst) {
#line 1131
      free((void *)pfirst->what);
#line 1132
      tmp___5 = __strdup((char const   *)(buffer___0));
#line 1132
      pfirst->what = tmp___5;
#line 1133
      pfirst->session = session;
    } else {
#line 1135
      tmp___6 = malloc(sizeof(SCAN_STATUS ));
#line 1135
      pfirst = (SCAN_STATUS *)tmp___6;
#line 1136
      if (pfirst) {
#line 1137
        tmp___12 = __strdup((char const   *)(buffer___0));
#line 1137
        pfirst->what = tmp___12;
#line 1138
        pfirst->session = session;
#line 1139
        pfirst->thread = pwsc->threadno;
#line 1140
        pfirst->next = scan_status.next;
#line 1141
        tmp___18 = __strdup((char const   *)pwsc->hostname);
#line 1141
        pfirst->host = tmp___18;
#line 1142
        scan_status.next = pfirst;
      }
    }
  } else {
#line 1146
    if (! pfirst) {
#line 1147
      config_mutex_unlock();
#line 1148
      err_log(9, 1U, (char *)"Exiting config_set_status\n");
#line 1149
      return;
    }
#line 1152
    if ((unsigned int )pfirst == (unsigned int )plast) {
#line 1153
      scan_status.next = pfirst->next;
#line 1154
      free((void *)pfirst->what);
#line 1155
      free((void *)pfirst->host);
#line 1156
      free((void *)pfirst);
    } else {
#line 1158
      plast->next = pfirst->next;
#line 1159
      free((void *)pfirst->what);
#line 1160
      free((void *)pfirst->host);
#line 1161
      free((void *)pfirst);
    }
  }
#line 1165
  config_mutex_unlock();
#line 1166
  err_log(9, 1U, (char *)"Exiting config_set_status\n");
#line 1167
  return;
}
}
#line 1173 "configfile.c"
static int config_mutex_lock(void) 
{ int err ;
  int *tmp ;

  {
#line 1176
  err = pthread_mutex_lock(& scan_mutex);
#line 1176
  if (err) {
#line 1177
    tmp = __errno_location();
#line 1177
    *tmp = err;
#line 1178
    return (-1);
  }
#line 1181
  return (0);
}
}
#line 1188 "configfile.c"
static int config_mutex_unlock(void) 
{ int err ;
  int *tmp ;

  {
#line 1191
  err = pthread_mutex_unlock(& scan_mutex);
#line 1191
  if (err) {
#line 1192
    tmp = __errno_location();
#line 1192
    *tmp = err;
#line 1193
    return (-1);
  }
#line 1196
  return (0);
}
}
#line 1204 "configfile.c"
int config_get_next_session(void) 
{ int session ;

  {
#line 1206
  config_mutex_lock();
#line 1208
  config_session ++;
#line 1208
  session = config_session;
#line 1209
  config_mutex_unlock();
#line 1211
  return (session);
}
}
#line 1221 "configfile.c"
static void config_emit_version(WS_CONNINFO *pwsc , void *value , char *arg ) 
{ 

  {
#line 1222
  ws_writefd(pwsc, (char *)"%s", "0.2.4.1");
#line 1223
  return;
}
}
#line 1233 "configfile.c"
static void config_emit_system(WS_CONNINFO *pwsc , void *value , char *arg ) 
{ 

  {
#line 1234
  ws_writefd(pwsc, (char *)"%s", "i686-pc-linux-gnu");
#line 1235
  return;
}
}
#line 1245 "configfile.c"
static void config_emit_flags(WS_CONNINFO *pwsc , void *value , char *arg ) 
{ 

  {
#line 1261
  return;
}
}
#line 1 "err.o"
#pragma merger(0,"/tmp/cil-Y785Sq7P.i","-g,-g,-O2")
#line 216 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 200 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
#line 247
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t const   * __restrict  __timer ,
                                                            struct tm * __restrict  __tp ) ;
#line 205 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *__strtok_r(char * __restrict  __s , char const   * __restrict  __delim ,
                                                      char ** __restrict  __save_ptr )  __attribute__((__nonnull__(2,3))) ;
#line 175 "/usr/include/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 53 "err.c"
int err_debuglevel  =    0;
#line 54 "err.c"
static int err_logdestination  =    0;
#line 55 "err.c"
static FILE *err_file  =    (FILE *)((void *)0);
#line 56 "err.c"
static pthread_mutex_t err_mutex  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 57 "err.c"
static unsigned int err_debugmask  =    4294967295U;
#line 60 "err.c"
static char *err_categorylist[13]  = 
#line 60
  {      (char *)"config",      (char *)"webserver",      (char *)"database",      (char *)"scan", 
        (char *)"query",      (char *)"index",      (char *)"browse",      (char *)"playlist", 
        (char *)"art",      (char *)"daap",      (char *)"main",      (char *)"rend", 
        (char *)((void *)0)};
#line 86
static int err_lock_mutex(void) ;
#line 87
static int err_unlock_mutex(void) ;
#line 99 "err.c"
void err_log(int level , unsigned int cat , char *fmt  , ...) 
{ va_list ap ;
  char timebuf[256] ;
  char errbuf[1024] ;
  struct tm tm_now ;
  time_t tt_now ;

  {
#line 107
  if (level) {
#line 108
    if (level > err_debuglevel) {
#line 109
      return;
    }
#line 111
    if (! (cat & err_debugmask)) {
#line 112
      return;
    }
  }
#line 115
  __builtin_va_start(ap, fmt);
#line 116
  vsnprintf((char * __restrict  )(errbuf), sizeof(errbuf), (char const   * __restrict  )fmt,
            ap);
#line 117
  __builtin_va_end(ap);
#line 119
  err_lock_mutex();
#line 121
  if (! level) {
#line 121
    if (err_logdestination != 0) {
#line 121
      if (! (cat & 2048U)) {
#line 122
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", errbuf);
#line 123
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Aborting\n");
#line 124
        fflush(stderr);
      }
    }
  }
#line 127
  switch (err_logdestination) {
  case 2: 
#line 129
  tt_now = time((time_t *)((void *)0));
#line 130
  localtime_r((time_t const   * __restrict  )(& tt_now), (struct tm * __restrict  )(& tm_now));
#line 131
  strftime((char * __restrict  )(timebuf), sizeof(timebuf), (char const   * __restrict  )"%Y-%m-%d %T",
           (struct tm  const  * __restrict  )(& tm_now));
#line 132
  fprintf((FILE * __restrict  )err_file, (char const   * __restrict  )"%s: %s", timebuf,
          errbuf);
#line 133
  if (! level) {
#line 133
    fprintf((FILE * __restrict  )err_file, (char const   * __restrict  )"%s: Aborting\n",
            timebuf);
  }
#line 134
  fflush(err_file);
#line 135
  break;
  case 0: 
#line 137
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", errbuf);
#line 138
  if (! level) {
#line 138
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Aborting\n");
  }
#line 139
  break;
  case 1: 
#line 141
  syslog(5, "%s", errbuf);
#line 142
  if (! level) {
#line 142
    syslog(6, "Aborting\n");
  }
#line 143
  break;
  }
#line 146
  err_unlock_mutex();
#line 148
  if (! level) {
#line 149
    exit(1);
  }
#line 151
  return;
}
}
#line 159 "err.c"
void err_setdest(char *app , int destination ) 
{ int *tmp ;
  char *tmp___0 ;

  {
#line 160
  if (err_logdestination == destination) {
#line 161
    return;
  }
#line 163
  switch (err_logdestination) {
  case 1: 
#line 165
  closelog();
#line 166
  break;
  case 2: 
#line 168
  fclose(err_file);
#line 169
  break;
  }
#line 172
  switch (destination) {
  case 2: 
#line 174
  err_file = fopen((char const   * __restrict  )app, (char const   * __restrict  )"a");
#line 175
  if ((unsigned int )err_file == (unsigned int )((void *)0)) {
#line 176
    tmp = __errno_location();
#line 176
    tmp___0 = strerror(*tmp);
#line 176
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error opening %s: %s\n",
            app, tmp___0);
#line 177
    exit(1);
  }
#line 179
  break;
  case 1: 
#line 181
  openlog((char const   *)app, 1, 3 << 3);
#line 182
  break;
  }
#line 185
  err_logdestination = destination;
#line 186
  return;
}
}
#line 194 "err.c"
extern int err_setdebugmask(char *list ) 
{ unsigned int rack ;
  char *token ;
  char *str ;
  char *last ;
  int index___0 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 199
  err_debugmask = 2147483648U;
#line 200
  str = list;
#line 202
  while (1) {
#line 203
    tmp___2 = __strtok_r((char * __restrict  )str, (char const   * __restrict  )",",
                         (char ** __restrict  )(& last));
#line 203
    token = tmp___2;
#line 204
    str = (char *)((void *)0);
#line 206
    if (token) {
#line 207
      rack = 1U;
#line 208
      index___0 = 0;
#line 209
      while (1) {
#line 209
        if (err_categorylist[index___0]) {
#line 209
          tmp___3 = strcasecmp((char const   *)err_categorylist[index___0], (char const   *)token);
#line 209
          if (! tmp___3) {
#line 209
            break;
          }
        } else {
#line 209
          break;
        }
#line 211
        rack <<= 1;
#line 212
        index___0 ++;
      }
#line 215
      if (! err_categorylist[index___0]) {
#line 216
        err_log(1, 2147483648U, (char *)"Unknown module: %s\n", token);
#line 217
        return (1);
      } else {
#line 219
        err_log(9, 2147483648U, (char *)"Adding module %s to debug list (0x%08x)\n",
                token, rack);
#line 220
        err_debugmask |= rack;
      }
    } else {
#line 222
      break;
    }
  }
#line 225
  err_log(5, 2147483648U, (char *)"Debug mask is 0x%08x\n", err_debugmask);
#line 227
  return (0);
}
}
#line 237 "err.c"
static int err_lock_mutex(void) 
{ int err ;
  int *tmp ;

  {
#line 240
  err = pthread_mutex_lock(& err_mutex);
#line 240
  if (err) {
#line 241
    tmp = __errno_location();
#line 241
    *tmp = err;
#line 242
    return (-1);
  }
#line 245
  return (0);
}
}
#line 253 "err.c"
static int err_unlock_mutex(void) 
{ int err ;
  int *tmp ;

  {
#line 256
  err = pthread_mutex_unlock(& err_mutex);
#line 256
  if (err) {
#line 257
    tmp = __errno_location();
#line 257
    *tmp = err;
#line 258
    return (-1);
  }
#line 261
  return (0);
}
}
#line 1 "restart.o"
#pragma merger(0,"/tmp/cil-qWC9ARp9.i","-g,-g,-O2")
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz )  __attribute__((__nonnull__(1))) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 325 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 331
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 44 "restart.h"
struct timeval add2currenttime(double seconds ) ;
#line 47
int r_dup2(int fildes , int fildes2 ) ;
#line 49
int r_open3(char const   *path , int oflag , mode_t mode ) ;
#line 51
pid_t r_wait(int *stat_loc ) ;
#line 52
pid_t r_waitpid(pid_t pid , int *stat_loc , int options ) ;
#line 54
ssize_t readblock(int fd , void *buf , size_t size ) ;
#line 58
int readwrite(int fromfd , int tofd ) ;
#line 59
int readwriteblock(int fromfd , int tofd , char *buf , int size ) ;
#line 60
int waitfdtimed(int fd , struct timeval end ) ;
#line 50 "restart.c"
static int gettimeout(struct timeval end , struct timeval *timeoutp ) 
{ int *tmp ;

  {
#line 52
  gettimeofday((struct timeval * __restrict  )timeoutp, (struct timezone * __restrict  )((void *)0));
#line 53
  timeoutp->tv_sec = end.tv_sec - timeoutp->tv_sec;
#line 54
  timeoutp->tv_usec = end.tv_usec - timeoutp->tv_usec;
#line 55
  if (timeoutp->tv_usec >= 1000000L) {
#line 56
    (timeoutp->tv_sec) ++;
#line 57
    timeoutp->tv_usec -= 1000000L;
  }
#line 59
  if (timeoutp->tv_usec < 0L) {
#line 60
    (timeoutp->tv_sec) --;
#line 61
    timeoutp->tv_usec += 1000000L;
  }
#line 63
  if (timeoutp->tv_sec < 0L) {
#line 65
    tmp = __errno_location();
#line 65
    *tmp = 62;
#line 66
    return (-1);
  } else {
#line 63
    if (timeoutp->tv_sec == 0L) {
#line 63
      if (timeoutp->tv_usec == 0L) {
#line 65
        tmp = __errno_location();
#line 65
        *tmp = 62;
#line 66
        return (-1);
      }
    }
  }
#line 68
  return (0);
}
}
#line 73 "restart.c"
int r_close(int fildes ) 
{ int retval ;
  int *tmp ;
  int tmp___0 ;

  {
#line 75
  while (1) {
#line 75
    retval = close(fildes);
#line 75
    if (retval == -1) {
#line 75
      tmp = __errno_location();
#line 75
      if (*tmp == 4) {
#line 75
        tmp___0 = 1;
      } else {
#line 75
        tmp___0 = 0;
      }
    } else {
#line 75
      tmp___0 = 0;
    }
#line 75
    if (! tmp___0) {
#line 75
      break;
    }
  }
#line 76
  return (retval);
}
}
#line 79 "restart.c"
int r_dup2(int fildes , int fildes2 ) 
{ int retval ;
  int *tmp ;
  int tmp___0 ;

  {
#line 81
  while (1) {
#line 81
    retval = dup2(fildes, fildes2);
#line 81
    if (retval == -1) {
#line 81
      tmp = __errno_location();
#line 81
      if (*tmp == 4) {
#line 81
        tmp___0 = 1;
      } else {
#line 81
        tmp___0 = 0;
      }
    } else {
#line 81
      tmp___0 = 0;
    }
#line 81
    if (! tmp___0) {
#line 81
      break;
    }
  }
#line 82
  return (retval);
}
}
#line 86 "restart.c"
int r_open2(char const   *path , int oflag ) 
{ int retval ;
  int *tmp ;
  int tmp___0 ;

  {
#line 88
  while (1) {
#line 88
    retval = open(path, oflag);
#line 88
    if (retval == -1) {
#line 88
      tmp = __errno_location();
#line 88
      if (*tmp == 4) {
#line 88
        tmp___0 = 1;
      } else {
#line 88
        tmp___0 = 0;
      }
    } else {
#line 88
      tmp___0 = 0;
    }
#line 88
    if (! tmp___0) {
#line 88
      break;
    }
  }
#line 89
  return (retval);
}
}
#line 92 "restart.c"
int r_open3(char const   *path , int oflag , mode_t mode ) 
{ int retval ;
  int *tmp ;
  int tmp___0 ;

  {
#line 94
  while (1) {
#line 94
    retval = open(path, oflag, mode);
#line 94
    if (retval == -1) {
#line 94
      tmp = __errno_location();
#line 94
      if (*tmp == 4) {
#line 94
        tmp___0 = 1;
      } else {
#line 94
        tmp___0 = 0;
      }
    } else {
#line 94
      tmp___0 = 0;
    }
#line 94
    if (! tmp___0) {
#line 94
      break;
    }
  }
#line 95
  return (retval);
}
}
#line 98 "restart.c"
ssize_t r_read(int fd , void *buf , size_t size ) 
{ ssize_t retval ;
  int *tmp ;

  {
#line 100
  while (1) {
#line 100
    retval = read(fd, buf, size);
#line 100
    if (retval == -1) {
#line 100
      tmp = __errno_location();
#line 100
      if (! (*tmp == 4)) {
#line 100
        break;
      }
    } else {
#line 100
      break;
    }
  }
#line 101
  return (retval);
}
}
#line 104 "restart.c"
pid_t r_wait(int *stat_loc ) 
{ pid_t retval ;
  int *tmp ;

  {
#line 106
  while (1) {
#line 106
    retval = wait((union wait *)stat_loc);
#line 106
    if (retval == -1) {
#line 106
      tmp = __errno_location();
#line 106
      if (! (*tmp == 4)) {
#line 106
        break;
      }
    } else {
#line 106
      break;
    }
  }
#line 107
  return (retval);
}
}
#line 110 "restart.c"
pid_t r_waitpid(pid_t pid , int *stat_loc , int options ) 
{ pid_t retval ;
  int *tmp ;

  {
#line 112
  while (1) {
#line 112
    retval = waitpid(pid, stat_loc, options);
#line 112
    if (retval == -1) {
#line 112
      tmp = __errno_location();
#line 112
      if (! (*tmp == 4)) {
#line 112
        break;
      }
    } else {
#line 112
      break;
    }
  }
#line 114
  return (retval);
}
}
#line 117 "restart.c"
ssize_t r_write(int fd , void *buf , size_t size ) 
{ char *bufp ;
  size_t bytestowrite ;
  ssize_t byteswritten ;
  size_t totalbytes ;
  int *tmp ;

  {
#line 123
  bufp = (char *)buf;
#line 123
  bytestowrite = size;
#line 123
  totalbytes = 0U;
#line 123
  while (bytestowrite > 0U) {
#line 126
    byteswritten = write(fd, (void const   *)bufp, bytestowrite);
#line 127
    if (byteswritten == -1) {
#line 127
      tmp = __errno_location();
#line 127
      if (*tmp != 4) {
#line 128
        return (-1);
      }
    }
#line 129
    if (byteswritten == -1) {
#line 130
      byteswritten = 0;
    }
#line 131
    totalbytes += (size_t )byteswritten;
#line 123
    bufp += byteswritten;
#line 123
    bytestowrite -= (size_t )byteswritten;
  }
#line 133
  return ((int )totalbytes);
}
}
#line 138 "restart.c"
struct timeval add2currenttime(double seconds ) 
{ struct timeval newtime ;

  {
#line 141
  gettimeofday((struct timeval * __restrict  )(& newtime), (struct timezone * __restrict  )((void *)0));
#line 142
  newtime.tv_sec += (__time_t )((int )seconds);
#line 143
  newtime.tv_usec += (__suseconds_t )((int )((seconds - (double )((int )seconds)) * 1000000.0 + 0.5));
#line 144
  if (newtime.tv_usec >= 1000000L) {
#line 145
    (newtime.tv_sec) ++;
#line 146
    newtime.tv_usec -= 1000000L;
  }
#line 148
  return (newtime);
}
}
#line 151 "restart.c"
int copyfile(int fromfd , int tofd ) 
{ int bytesread ;
  int totalbytes ;

  {
#line 153
  totalbytes = 0;
#line 155
  while (1) {
#line 155
    bytesread = readwrite(fromfd, tofd);
#line 155
    if (! (bytesread > 0)) {
#line 155
      break;
    }
#line 156
    totalbytes += bytesread;
  }
#line 157
  return (totalbytes);
}
}
#line 160 "restart.c"
ssize_t readblock(int fd , void *buf , size_t size ) 
{ char *bufp ;
  ssize_t bytesread ;
  size_t bytestoread ;
  size_t totalbytes ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 166
  bufp = (char *)buf;
#line 166
  bytestoread = size;
#line 166
  totalbytes = 0U;
#line 166
  while (bytestoread > 0U) {
#line 169
    bytesread = read(fd, (void *)bufp, bytestoread);
#line 170
    if (bytesread == 0) {
#line 170
      if (totalbytes == 0U) {
#line 171
        return (0);
      }
    }
#line 172
    if (bytesread == 0) {
#line 173
      tmp = __errno_location();
#line 173
      *tmp = 22;
#line 174
      return (-1);
    }
#line 176
    if (bytesread == -1) {
#line 176
      tmp___0 = __errno_location();
#line 176
      if (*tmp___0 != 4) {
#line 177
        return (-1);
      }
    }
#line 178
    if (bytesread == -1) {
#line 179
      bytesread = 0;
    }
#line 180
    totalbytes += (size_t )bytesread;
#line 166
    bufp += bytesread;
#line 166
    bytestoread -= (size_t )bytesread;
  }
#line 182
  return ((int )totalbytes);
}
}
#line 185 "restart.c"
int readline(int fd , char *buf , int nbytes ) 
{ int numread ;
  int returnval ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 186
  numread = 0;
#line 189
  while (numread < nbytes - 1) {
#line 190
    returnval = read(fd, (void *)(buf + numread), 1U);
#line 191
    if (returnval == -1) {
#line 191
      tmp = __errno_location();
#line 191
      if (*tmp == 4) {
#line 192
        continue;
      }
    }
#line 193
    if (returnval == 0) {
#line 193
      if (numread == 0) {
#line 194
        return (0);
      }
    }
#line 195
    if (returnval == 0) {
#line 196
      break;
    }
#line 197
    if (returnval == -1) {
#line 198
      return (-1);
    }
#line 199
    numread ++;
#line 200
    if ((int )*(buf + (numread - 1)) == 10) {
#line 201
      *(buf + numread) = (char )'\000';
#line 202
      return (numread);
    }
  }
#line 205
  tmp___0 = __errno_location();
#line 205
  *tmp___0 = 22;
#line 206
  return (-1);
}
}
#line 209 "restart.c"
int readlinetimed(int fd , char *buf , int nbytes , double seconds ) 
{ int numread ;
  int returnval ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 210
  numread = 0;
#line 213
  while (numread < nbytes - 1) {
#line 214
    tmp = readtimed(fd, (void *)(buf + numread), 1U, seconds);
#line 214
    returnval = tmp;
#line 215
    if (returnval == -1) {
#line 215
      tmp___0 = __errno_location();
#line 215
      if (*tmp___0 == 4) {
#line 216
        continue;
      }
    }
#line 217
    if (returnval == 0) {
#line 217
      if (numread == 0) {
#line 218
        return (0);
      }
    }
#line 219
    if (returnval == 0) {
#line 220
      break;
    }
#line 221
    if (returnval == -1) {
#line 222
      return (-1);
    }
#line 223
    numread ++;
#line 224
    if ((int )*(buf + (numread - 1)) == 10) {
#line 225
      *(buf + numread) = (char )'\000';
#line 226
      return (numread);
    }
  }
#line 229
  tmp___1 = __errno_location();
#line 229
  *tmp___1 = 22;
#line 230
  return (-1);
}
}
#line 233 "restart.c"
ssize_t readtimed(int fd , void *buf , size_t nbyte , double seconds ) 
{ struct timeval timedone ;
  int tmp ;
  ssize_t tmp___0 ;

  {
#line 236
  timedone = add2currenttime(seconds);
#line 237
  tmp = waitfdtimed(fd, timedone);
#line 237
  if (tmp == -1) {
#line 238
    return (-1);
  }
#line 239
  tmp___0 = r_read(fd, buf, nbyte);
#line 239
  return (tmp___0);
}
}
#line 242 "restart.c"
int readwrite(int fromfd , int tofd ) 
{ char buf[4096] ;
  int bytesread ;
  ssize_t tmp ;

  {
#line 246
  bytesread = r_read(fromfd, (void *)(buf), 4096U);
#line 246
  if (bytesread < 0) {
#line 247
    return (-1);
  }
#line 248
  if (bytesread == 0) {
#line 249
    return (0);
  }
#line 250
  tmp = r_write(tofd, (void *)(buf), (unsigned int )bytesread);
#line 250
  if (tmp < 0) {
#line 251
    return (-1);
  }
#line 252
  return (bytesread);
}
}
#line 255 "restart.c"
int readwriteblock(int fromfd , int tofd , char *buf , int size ) 
{ int bytesread ;
  ssize_t tmp ;

  {
#line 258
  bytesread = readblock(fromfd, (void *)buf, (unsigned int )size);
#line 259
  if (bytesread != size) {
#line 260
    return (bytesread);
  }
#line 261
  tmp = r_write(tofd, (void *)buf, (unsigned int )size);
#line 261
  return (tmp);
}
}
#line 264 "restart.c"
int waitfdtimed(int fd , struct timeval end ) 
{ fd_set readset ;
  int retval ;
  struct timeval timeout ;
  int *tmp ;
  int __d0 ;
  int __d1 ;
  int tmp___0 ;
  int tmp___1 ;
  int __d0___0 ;
  int __d1___0 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 269
  if (fd < 0) {
#line 270
    tmp = __errno_location();
#line 270
    *tmp = 22;
#line 271
    return (-1);
  } else {
#line 269
    if (fd >= 1024) {
#line 270
      tmp = __errno_location();
#line 270
      *tmp = 22;
#line 271
      return (-1);
    }
  }
#line 273
  while (1) {
#line 273
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readset.__fds_bits[0]): "memory");
#line 273
    break;
  }
#line 274
  __asm__  volatile   ("btsl %1,%0": "=m" (readset.__fds_bits[(unsigned int )fd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fd % (8U * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 275
  tmp___0 = gettimeout(end, & timeout);
#line 275
  if (tmp___0 == -1) {
#line 276
    return (-1);
  }
#line 277
  while (1) {
#line 277
    retval = select(fd + 1, (fd_set * __restrict  )(& readset), (fd_set * __restrict  )((void *)0),
                    (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(& timeout));
#line 277
    if (retval == -1) {
#line 277
      tmp___2 = __errno_location();
#line 277
      if (! (*tmp___2 == 4)) {
#line 277
        break;
      }
    } else {
#line 277
      break;
    }
#line 279
    tmp___1 = gettimeout(end, & timeout);
#line 279
    if (tmp___1 == -1) {
#line 280
      return (-1);
    }
#line 281
    while (1) {
#line 281
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0),
                           "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& readset.__fds_bits[0]): "memory");
#line 281
      break;
    }
#line 282
    __asm__  volatile   ("btsl %1,%0": "=m" (readset.__fds_bits[(unsigned int )fd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fd % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 284
  if (retval == 0) {
#line 285
    tmp___3 = __errno_location();
#line 285
    *tmp___3 = 62;
#line 286
    return (-1);
  }
#line 288
  if (retval == -1) {
#line 289
    return (-1);
  }
#line 290
  return (0);
}
}
#line 1 "daap-proto.o"
#pragma merger(0,"/tmp/cil-H2JPAfFV.i","-g,-g,-O2")
#line 70 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 242 "/usr/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 328
extern int deflateEnd(z_streamp strm ) ;
#line 1325
extern int deflateInit2_(z_streamp strm , int level , int method , int windowBits ,
                         int memLevel , int strategy , char const   *version , int stream_size ) ;
#line 41 "daap-proto.h"
ssize_t gzip_write(GZIP_STREAM *gz , void *buf , size_t size ) ;
#line 58
DAAP_BLOCK *daap_add_int(DAAP_BLOCK *parent , char *tag , int value ) ;
#line 59
DAAP_BLOCK *daap_add_data(DAAP_BLOCK *parent , char *tag , int len , void *value ) ;
#line 60
DAAP_BLOCK *daap_add_string(DAAP_BLOCK *parent , char *tag , char *value ) ;
#line 61
DAAP_BLOCK *daap_add_empty(DAAP_BLOCK *parent , char *tag ) ;
#line 62
DAAP_BLOCK *daap_add_char(DAAP_BLOCK *parent , char *tag , char value ) ;
#line 63
DAAP_BLOCK *daap_add_short(DAAP_BLOCK *parent , char *tag , short value ) ;
#line 64
DAAP_BLOCK *daap_add_long(DAAP_BLOCK *parent , char *tag , int v1 , int v2 ) ;
#line 69
void daap_remove(DAAP_BLOCK *node ) ;
#line 72
DAAP_BLOCK *daap_find(DAAP_BLOCK *parent , char *tag ) ;
#line 75
int daap_set_int(DAAP_BLOCK *parent , char *tag , int value ) ;
#line 37 "daap-proto.c"
DAAP_BLOCK *daap_get_new(void) ;
#line 38
DAAP_BLOCK *daap_add_formatted(DAAP_BLOCK *parent , char *tag , int size , char *value ) ;
#line 42 "daap-proto.c"
GZIP_STREAM *gzip_alloc(void) 
{ GZIP_STREAM *gz ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 43
  tmp = malloc(sizeof(GZIP_STREAM ));
#line 43
  gz = (GZIP_STREAM *)tmp;
#line 45
  if (gz) {
#line 46
    memset((void *)gz, 0, sizeof(GZIP_STREAM ));
#line 48
    gz->in_size = 16384;
#line 49
    tmp___0 = malloc((unsigned int )gz->in_size);
#line 49
    gz->in = (char *)tmp___0;
#line 50
    gz->bytes_in = 0;
#line 51
    gz->out = (char *)((void *)0);
#line 52
    gz->bytes_out = 0;
  }
#line 54
  return (gz);
}
}
#line 57 "daap-proto.c"
ssize_t gzip_write(GZIP_STREAM *gz , void *buf , size_t size ) 
{ char *in2 ;
  int new_size ;
  void *tmp ;
  int tmp___0 ;

  {
#line 62
  if ((unsigned int )gz->in == (unsigned int )((void *)0)) {
#line 63
    return (-1);
  }
#line 66
  while ((size_t )gz->in_size <= (size_t )gz->bytes_in + size) {
#line 67
    new_size = 2 * gz->in_size;
#line 68
    tmp = malloc((unsigned int )new_size);
#line 68
    in2 = (char *)tmp;
#line 69
    if ((unsigned int )in2 == (unsigned int )((void *)0)) {
#line 70
      err_log(1, 514U, (char *)"out of memory for input buffer\n");
#line 71
      free((void *)gz->in);
#line 72
      gz->in = (char *)((void *)0);
#line 73
      tmp___0 = 0;
#line 73
      gz->in_size = tmp___0;
#line 73
      gz->bytes_in = tmp___0;
#line 74
      return (-1);
    }
#line 76
    memcpy((void * __restrict  )in2, (void const   * __restrict  )gz->in, (unsigned int )gz->in_size);
#line 77
    free((void *)gz->in);
#line 78
    gz->in = in2;
#line 79
    gz->in_size = new_size;
  }
#line 81
  memcpy((void * __restrict  )(gz->in + gz->bytes_in), (void const   * __restrict  )buf,
         size);
#line 82
  gz->bytes_in = (int )((size_t )gz->bytes_in + size);
#line 83
  return ((int )size);
}
}
#line 86 "daap-proto.c"
int gzip_compress(GZIP_STREAM *gz ) 
{ int out_size ;
  int status ;
  z_stream strm ;
  void *tmp ;

  {
#line 91
  if ((unsigned int )gz->in == (unsigned int )((void *)0)) {
#line 92
    return (-1);
  }
#line 94
  out_size = (int )(1.05 * (double )gz->in_size) + 40;
#line 95
  tmp = malloc((unsigned int )out_size);
#line 95
  gz->out = (char *)tmp;
#line 96
  if ((unsigned int )gz->out == (unsigned int )((void *)0)) {
#line 97
    err_log(5, 514U, (char *)"out of memory for output buffer\n");
#line 98
    gz->bytes_out = 0;
#line 99
    return (-1);
  }
#line 102
  memset((void *)(& strm), 0, sizeof(strm));
#line 104
  strm.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
#line 105
  strm.zfree = (void (*)(voidpf opaque , voidpf address ))0;
#line 106
  strm.opaque = (void *)0;
#line 107
  strm.next_in = (Bytef *)gz->in;
#line 108
  strm.avail_in = (unsigned int )gz->bytes_in;
#line 109
  strm.next_out = (Bytef *)gz->out;
#line 110
  strm.avail_out = (unsigned int )out_size;
#line 111
  deflateInit2_(& strm, -1, 8, 24, 8, 0, "1.2.3", (int )sizeof(z_stream ));
#line 112
  while (1) {
#line 112
    status = deflate(& strm, 4);
#line 112
    if (! (status == 0)) {
#line 112
      break;
    }
  }
#line 114
  if (status != 1) {
#line 115
    err_log(1, 514U, (char *)"unable to compress data: %s (%d)\n", strm.msg, status);
#line 116
    gz->bytes_out = 0;
#line 117
    return (-1);
  }
#line 119
  gz->bytes_out = (int )strm.total_out;
#line 120
  deflateEnd(& strm);
#line 122
  return (gz->bytes_out);
}
}
#line 125 "daap-proto.c"
int gzip_close(GZIP_STREAM *gz , int fd ) 
{ int bytes_written ;
  ssize_t tmp ;

  {
#line 126
  bytes_written = gz->bytes_out;
#line 127
  tmp = r_write(fd, (void *)gz->out, (unsigned int )gz->bytes_out);
#line 127
  if (tmp != gz->bytes_out) {
#line 128
    err_log(1, 514U, (char *)"unable to write gzipped data\n");
#line 129
    return (-1);
  }
#line 131
  if ((unsigned int )gz->in != (unsigned int )((void *)0)) {
#line 132
    free((void *)gz->in);
  }
#line 133
  if ((unsigned int )gz->out != (unsigned int )((void *)0)) {
#line 134
    free((void *)gz->out);
  }
#line 135
  free((void *)gz);
#line 136
  return (bytes_written);
}
}
#line 149 "daap-proto.c"
DAAP_BLOCK *daap_get_new(void) 
{ DAAP_BLOCK *pnew ;
  void *tmp ;

  {
#line 152
  tmp = malloc(sizeof(DAAP_BLOCK ));
#line 152
  pnew = (DAAP_BLOCK *)tmp;
#line 153
  if (! pnew) {
#line 154
    err_log(2, 512U, (char *)"Error mallocing a daap block\n");
#line 155
    return ((DAAP_BLOCK *)((void *)0));
  }
#line 158
  pnew->free = 0;
#line 159
  pnew->value = (char *)((void *)0);
#line 160
  pnew->parent = (struct daap_block_tag *)((void *)0);
#line 161
  pnew->children = (struct daap_block_tag *)((void *)0);
#line 162
  pnew->last_child = (struct daap_block_tag *)((void *)0);
#line 163
  pnew->next = (struct daap_block_tag *)((void *)0);
#line 165
  return (pnew);
}
}
#line 176 "daap-proto.c"
DAAP_BLOCK *daap_add_formatted(DAAP_BLOCK *parent , char *tag , int size , char *value ) 
{ DAAP_BLOCK *current ;
  DAAP_BLOCK *last ;
  DAAP_BLOCK *pnew ;

  {
#line 181
  err_log(10, 512U, (char *)"Adding daap tag %s\n", tag);
#line 182
  pnew = daap_get_new();
#line 183
  if (! pnew) {
#line 184
    return ((DAAP_BLOCK *)((void *)0));
  }
#line 186
  pnew->reported_size = size;
#line 187
  pnew->parent = parent;
#line 188
  pnew->size = size;
#line 189
  memcpy((void * __restrict  )(pnew->tag), (void const   * __restrict  )tag, 4U);
#line 191
  if (size <= 4) {
#line 191
    if (size >= 0) {
#line 192
      memcpy((void * __restrict  )(pnew->svalue), (void const   * __restrict  )value,
             (unsigned int )size);
#line 193
      pnew->free = 0;
    } else {
#line 195
      pnew->value = value;
#line 196
      pnew->free = 1;
    }
  } else {
#line 195
    pnew->value = value;
#line 196
    pnew->free = 1;
  }
#line 198
  pnew->next = (struct daap_block_tag *)((void *)0);
#line 201
  if (parent) {
#line 202
    last = parent->last_child;
#line 203
    if (last) {
#line 204
      last->next = pnew;
    } else {
#line 206
      parent->children = pnew;
    }
#line 208
    parent->last_child = pnew;
  }
#line 212
  current = pnew->parent;
#line 213
  while (current) {
#line 214
    current->reported_size += 8 + pnew->reported_size;
#line 215
    current = current->parent;
  }
#line 218
  return (pnew);
}
}
#line 226 "daap-proto.c"
DAAP_BLOCK *daap_add_long(DAAP_BLOCK *parent , char *tag , int v1 , int v2 ) 
{ char *ivalue ;
  void *tmp ;
  DAAP_BLOCK *tmp___0 ;

  {
#line 228
  tmp = malloc(8U);
#line 228
  ivalue = (char *)tmp;
#line 229
  if (! ivalue) {
#line 230
    return ((DAAP_BLOCK *)((void *)0));
  }
#line 232
  *(ivalue + 0) = (char )((v1 >> 24) & 255);
#line 233
  *(ivalue + 1) = (char )((v1 >> 16) & 255);
#line 234
  *(ivalue + 2) = (char )((v1 >> 8) & 255);
#line 235
  *(ivalue + 3) = (char )(v1 & 255);
#line 237
  *(ivalue + 4) = (char )((v2 >> 24) & 255);
#line 238
  *(ivalue + 5) = (char )((v2 >> 16) & 255);
#line 239
  *(ivalue + 6) = (char )((v2 >> 8) & 255);
#line 240
  *(ivalue + 7) = (char )(v2 & 255);
#line 242
  tmp___0 = daap_add_formatted(parent, tag, 8, ivalue);
#line 242
  return (tmp___0);
}
}
#line 250 "daap-proto.c"
DAAP_BLOCK *daap_add_int(DAAP_BLOCK *parent , char *tag , int value ) 
{ char ivalue[4] ;
  DAAP_BLOCK *tmp ;

  {
#line 253
  ivalue[0] = (char )((value >> 24) & 255);
#line 254
  ivalue[1] = (char )((value >> 16) & 255);
#line 255
  ivalue[2] = (char )((value >> 8) & 255);
#line 256
  ivalue[3] = (char )(value & 255);
#line 258
  tmp = daap_add_formatted(parent, tag, 4, ivalue);
#line 258
  return (tmp);
}
}
#line 266 "daap-proto.c"
DAAP_BLOCK *daap_add_short(DAAP_BLOCK *parent , char *tag , short value ) 
{ char ivalue[2] ;
  DAAP_BLOCK *tmp ;

  {
#line 269
  ivalue[0] = (char )(((int )value >> 8) & 255);
#line 270
  ivalue[1] = (char )((int )value & 255);
#line 272
  tmp = daap_add_formatted(parent, tag, 2, ivalue);
#line 272
  return (tmp);
}
}
#line 280 "daap-proto.c"
DAAP_BLOCK *daap_add_char(DAAP_BLOCK *parent , char *tag , char value ) 
{ DAAP_BLOCK *tmp ;

  {
#line 281
  tmp = daap_add_formatted(parent, tag, 1, & value);
#line 281
  return (tmp);
}
}
#line 289 "daap-proto.c"
DAAP_BLOCK *daap_add_data(DAAP_BLOCK *parent , char *tag , int len , void *value ) 
{ void *pvalue ;
  void *tmp ;
  DAAP_BLOCK *tmp___0 ;
  DAAP_BLOCK *tmp___1 ;

  {
#line 293
  if (len > 4) {
#line 294
    tmp = malloc((unsigned int )len);
#line 294
    pvalue = tmp;
#line 295
    if (! pvalue) {
#line 296
      return ((DAAP_BLOCK *)((void *)0));
    }
#line 298
    memcpy((void * __restrict  )pvalue, (void const   * __restrict  )value, (unsigned int )len);
#line 300
    tmp___0 = daap_add_formatted(parent, tag, len, (char *)pvalue);
#line 300
    return (tmp___0);
  }
#line 302
  tmp___1 = daap_add_formatted(parent, tag, len, (char *)value);
#line 302
  return (tmp___1);
}
}
#line 310 "daap-proto.c"
DAAP_BLOCK *daap_add_string(DAAP_BLOCK *parent , char *tag , char *value ) 
{ char *newvalue ;
  char *tmp___4 ;
  size_t tmp___5 ;
  DAAP_BLOCK *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  DAAP_BLOCK *tmp___9 ;
  DAAP_BLOCK *tmp___10 ;

  {
#line 313
  if (value) {
#line 314
    tmp___7 = strlen((char const   *)value);
#line 314
    if (tmp___7 > 4U) {
#line 315
      tmp___4 = __strdup((char const   *)value);
#line 315
      newvalue = tmp___4;
#line 317
      if (! newvalue) {
#line 318
        return ((DAAP_BLOCK *)((void *)0));
      }
#line 320
      tmp___5 = strlen((char const   *)newvalue);
#line 320
      tmp___6 = daap_add_formatted(parent, tag, (int )tmp___5, newvalue);
#line 320
      return (tmp___6);
    }
#line 322
    tmp___8 = strlen((char const   *)value);
#line 322
    tmp___9 = daap_add_formatted(parent, tag, (int )tmp___8, value);
#line 322
    return (tmp___9);
  }
#line 324
  tmp___10 = daap_add_formatted(parent, tag, 0, (char *)"");
#line 324
  return (tmp___10);
}
}
#line 332 "daap-proto.c"
DAAP_BLOCK *daap_add_empty(DAAP_BLOCK *parent , char *tag ) 
{ DAAP_BLOCK *tmp ;

  {
#line 333
  tmp = daap_add_formatted(parent, tag, 0, (char *)((void *)0));
#line 333
  return (tmp);
}
}
#line 341 "daap-proto.c"
int daap_serialize(DAAP_BLOCK *root , int fd , GZIP_STREAM *gz ) 
{ char size[4] ;
  int tmp ;

  {
#line 344
  while (root) {
#line 345
    if ((unsigned int )gz == (unsigned int )((void *)0)) {
#line 346
      r_write(fd, (void *)(root->tag), 4U);
    } else {
#line 348
      gzip_write(gz, (void *)(root->tag), 4U);
    }
#line 350
    size[0] = (char )((root->reported_size >> 24) & 255);
#line 351
    size[1] = (char )((root->reported_size >> 16) & 255);
#line 352
    size[2] = (char )((root->reported_size >> 8) & 255);
#line 353
    size[3] = (char )(root->reported_size & 255);
#line 355
    if ((unsigned int )gz == (unsigned int )((void *)0)) {
#line 356
      r_write(fd, (void *)(& size), 4U);
    } else {
#line 358
      gzip_write(gz, (void *)(& size), 4U);
    }
#line 360
    if (root->size) {
#line 361
      if (root->free) {
#line 362
        if ((unsigned int )gz == (unsigned int )((void *)0)) {
#line 363
          r_write(fd, (void *)root->value, (unsigned int )root->size);
        } else {
#line 366
          gzip_write(gz, (void *)root->value, (unsigned int )root->size);
        }
      } else {
#line 370
        if ((unsigned int )gz == (unsigned int )((void *)0)) {
#line 371
          r_write(fd, (void *)(root->svalue), (unsigned int )root->size);
        } else {
#line 374
          gzip_write(gz, (void *)(root->svalue), (unsigned int )root->size);
        }
      }
    }
#line 379
    if (root->children) {
#line 380
      tmp = daap_serialize(root->children, fd, gz);
#line 380
      if (tmp) {
#line 381
        return (-1);
      }
    }
#line 384
    root = root->next;
  }
#line 387
  return (0);
}
}
#line 395 "daap-proto.c"
void daap_remove(DAAP_BLOCK *node ) 
{ DAAP_BLOCK *parent ;
  DAAP_BLOCK **ptr ;

  {
#line 397
  parent = node->parent;
#line 399
  if ((unsigned int )((DAAP_BLOCK *)0) != (unsigned int )parent) {
#line 401
    ptr = & parent->children;
#line 403
    while (1) {
#line 403
      if (*ptr) {
#line 403
        if (! ((unsigned int )*ptr != (unsigned int )node)) {
#line 403
          break;
        }
      } else {
#line 403
        break;
      }
#line 404
      ptr = & (*ptr)->next;
    }
#line 406
    if (! ((unsigned int )((DAAP_BLOCK *)0) != (unsigned int )*ptr)) {
#line 406
      __assert_fail("0 != *ptr", "daap-proto.c", 406U, "daap_remove");
    }
#line 409
    *ptr = node->next;
#line 412
    parent = node->parent;
#line 412
    while (parent) {
#line 413
      parent->reported_size -= 8 + node->reported_size;
#line 412
      parent = parent->parent;
    }
#line 416
    node->parent = (struct daap_block_tag *)0;
#line 417
    node->next = (struct daap_block_tag *)0;
  }
#line 420
  daap_free(node);
#line 421
  return;
}
}
#line 426 "daap-proto.c"
DAAP_BLOCK *daap_find(DAAP_BLOCK *parent , char *tag ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___2 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 428
  parent = parent->children;
#line 428
  while (parent) {
#line 429
    if (0) {
#line 429
      if (0) {
#line 429
        __s1_len = strlen((char const   *)(parent->tag));
#line 429
        __s2_len = strlen((char const   *)tag);
#line 429
        if (! ((unsigned int )((void const   *)(parent->tag + 1)) - (unsigned int )((void const   *)(parent->tag)) == 1U)) {
          goto _L___0;
        } else {
#line 429
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 429
            if (! ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)tag) == 1U)) {
#line 429
              tmp___7 = 1;
            } else {
#line 429
              if (__s2_len >= 4U) {
#line 429
                tmp___7 = 1;
              } else {
#line 429
                tmp___7 = 0;
              }
            }
          } else {
#line 429
            tmp___7 = 0;
          }
        }
#line 429
        if (tmp___7) {
#line 429
          tmp___2 = __builtin_strcmp((char const   *)(parent->tag), (char const   *)tag);
#line 429
          tmp___6 = tmp___2;
        } else {
#line 429
          tmp___5 = __builtin_strcmp((char const   *)(parent->tag), (char const   *)tag);
#line 429
          tmp___6 = tmp___5;
        }
      } else {
#line 429
        tmp___5 = __builtin_strcmp((char const   *)(parent->tag), (char const   *)tag);
#line 429
        tmp___6 = tmp___5;
      }
#line 429
      tmp___9 = tmp___6;
    } else {
#line 429
      tmp___8 = strncmp((char const   *)(parent->tag), (char const   *)tag, 4U);
#line 429
      tmp___9 = tmp___8;
    }
#line 429
    if (! tmp___9) {
#line 430
      break;
    }
#line 428
    parent = parent->next;
  }
#line 432
  return (parent);
}
}
#line 440 "daap-proto.c"
void daap_free(DAAP_BLOCK *root ) 
{ DAAP_BLOCK *pnext ;

  {
#line 443
  while (root) {
#line 444
    err_log(10, 512U, (char *)"Freeing %c%c%c%c\n", root->tag[0], root->tag[1], root->tag[2],
            root->tag[3]);
#line 447
    if (root->size) {
#line 447
      if (root->free) {
#line 448
        free((void *)root->value);
      }
    }
#line 450
    daap_free(root->children);
#line 452
    pnext = root->next;
#line 453
    free((void *)root);
#line 454
    root = pnext;
  }
#line 456
  return;
}
}
#line 460 "daap-proto.c"
int daap_set_int(DAAP_BLOCK *parent , char *tag , int value ) 
{ DAAP_BLOCK *child ;
  DAAP_BLOCK *tmp ;

  {
#line 462
  tmp = daap_find(parent, tag);
#line 462
  child = tmp;
#line 464
  if ((unsigned int )((DAAP_BLOCK *)0) == (unsigned int )child) {
#line 465
    return (0);
  } else {
#line 464
    if ((unsigned int )child->size != sizeof(int )) {
#line 465
      return (0);
    }
  }
#line 467
  child->svalue[0] = (char )((value >> 24) & 255);
#line 468
  child->svalue[1] = (char )((value >> 16) & 255);
#line 469
  child->svalue[2] = (char )((value >> 8) & 255);
#line 470
  child->svalue[3] = (char )(value & 255);
#line 472
  return (1);
}
}
#line 1 "daap.o"
#pragma merger(0,"/tmp/cil-pHjPBKp9.i","-g,-g,-O2")
#line 184 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 591
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 42 "db-memory.h"
ENUMHANDLE db_enum_begin(void) ;
#line 43
MP3FILE *db_enum(ENUMHANDLE *current ) ;
#line 44
int db_enum_end(ENUMHANDLE handle ) ;
#line 49
int db_get_playlist_count(void) ;
#line 50
int db_get_playlist_entry_count(unsigned long playlistid ) ;
#line 51
int db_get_playlist_is_smart(unsigned long playlistid ) ;
#line 53
ENUMHANDLE db_playlist_enum_begin(void) ;
#line 54
int db_playlist_enum(ENUMHANDLE *handle ) ;
#line 55
int db_playlist_enum_end(ENUMHANDLE handle ) ;
#line 57
ENUMHANDLE db_playlist_items_enum_begin(unsigned long playlistid ) ;
#line 58
int db_playlist_items_enum(ENUMHANDLE *handle ) ;
#line 59
int db_playlist_items_enum_end(ENUMHANDLE handle ) ;
#line 61
char *db_get_playlist_name(unsigned long playlistid ) ;
#line 35 "daap.h"
DAAP_BLOCK *daap_add_song_entry(DAAP_BLOCK *mlcl , MP3FILE *song , unsigned long long meta ) ;
#line 65 "query.h"
query_node_t *query_build(char const   *query , query_field_t const   *fields ) ;
#line 67
int query_test(query_node_t *query , void *target ) ;
#line 68
void query_free(query_node_t *query ) ;
#line 69
void query_dump(FILE *fp , query_node_t *query , int depth ) ;
#line 51 "daap.c"
DAAP_ITEMS taglist[85]  = 
#line 51 "daap.c"
  {      {5, (char *)"miid", (char *)"dmap.itemid"}, 
        {9, (char *)"minm", (char *)"dmap.itemname"}, 
        {1, (char *)"mikd", (char *)"dmap.itemkind"}, 
        {7, (char *)"mper", (char *)"dmap.persistentid"}, 
        {12, (char *)"mcon", (char *)"dmap.container"}, 
        {5, (char *)"mcti", (char *)"dmap.containeritemid"}, 
        {5, (char *)"mpco", (char *)"dmap.parentcontainerid"}, 
        {5, (char *)"mstt", (char *)"dmap.status"}, 
        {9, (char *)"msts", (char *)"dmap.statusstring"}, 
        {5, (char *)"mimc", (char *)"dmap.itemcount"}, 
        {5, (char *)"mctc", (char *)"dmap.containercount"}, 
        {5, (char *)"mrco", (char *)"dmap.returnedcount"}, 
        {5, (char *)"mtco", (char *)"dmap.specifiedtotalcount"}, 
        {12, (char *)"mlcl", (char *)"dmap.listing"}, 
        {12, (char *)"mlit", (char *)"dmap.listingitem"}, 
        {12, (char *)"mbcl", (char *)"dmap.bag"}, 
        {12, (char *)"mdcl", (char *)"dmap.dictionary"}, 
        {12, (char *)"msrv", (char *)"dmap.serverinforesponse"}, 
        {1, (char *)"msau", (char *)"dmap.authenticationmethod"}, 
        {1, (char *)"mslr", (char *)"dmap.loginrequired"}, 
        {11, (char *)"mpro", (char *)"dmap.protocolversion"}, 
        {1, (char *)"msal", (char *)"dmap.supportsautologout"}, 
        {1, (char *)"msup", (char *)"dmap.supportsupdate"}, 
        {1, (char *)"mspi", (char *)"dmap.supportspersistentids"}, 
        {1, (char *)"msex", (char *)"dmap.supportsextensions"}, 
        {1, (char *)"msbr", (char *)"dmap.supportsbrowse"}, 
        {1, (char *)"msqy", (char *)"dmap.supportsquery"}, 
        {1, (char *)"msix", (char *)"dmap.supportsindex"}, 
        {1, (char *)"msrs", (char *)"dmap.supportsresolve"}, 
        {5, (char *)"mstm", (char *)"dmap.timeoutinterval"}, 
        {5, (char *)"msdc", (char *)"dmap.databasescount"}, 
        {12, (char *)"mlog", (char *)"dmap.loginresponse"}, 
        {5, (char *)"mlid", (char *)"dmap.sessionid"}, 
        {12, (char *)"mupd", (char *)"dmap.updateresponse"}, 
        {5, (char *)"musr", (char *)"dmap.serverrevision"}, 
        {1, (char *)"muty", (char *)"dmap.updatetype"}, 
        {12, (char *)"mudl", (char *)"dmap.deletedidlisting"}, 
        {12, (char *)"mccr", (char *)"dmap.contentcodesresponse"}, 
        {5, (char *)"mcnm", (char *)"dmap.contentcodesnumber"}, 
        {9, (char *)"mcna", (char *)"dmap.contentcodesname"}, 
        {3, (char *)"mcty", (char *)"dmap.contentcodestype"}, 
        {11, (char *)"apro", (char *)"daap.protocolversion"}, 
        {12, (char *)"avdb", (char *)"daap.serverdatabases"}, 
        {12, (char *)"abro", (char *)"daap.databasebrowse"}, 
        {12, (char *)"abal", (char *)"daap.browsealbumlisting"}, 
        {12, (char *)"abar", (char *)"daap.browseartistlisting"}, 
        {12, (char *)"abcp", (char *)"daap.browsecomposerlisting"}, 
        {12, (char *)"abgn", (char *)"daap.browsegenrelisting"}, 
        {12, (char *)"adbs", (char *)"daap.databasesongs"}, 
        {9, (char *)"asal", (char *)"daap.songalbum"}, 
        {9, (char *)"asar", (char *)"daap.songartist"}, 
        {3, (char *)"asbt", (char *)"daap.songbeatsperminute"}, 
        {3, (char *)"asbr", (char *)"daap.songbitrate"}, 
        {9, (char *)"ascm", (char *)"daap.songcomment"}, 
        {1, (char *)"asco", (char *)"daap.songcompilation"}, 
        {9, (char *)"ascp", (char *)"daap.songcomposer"}, 
        {10, (char *)"asda", (char *)"daap.songdateadded"}, 
        {10, (char *)"asdm", (char *)"daap.songdatemodified"}, 
        {3, (char *)"asdc", (char *)"daap.songdisccount"}, 
        {3, (char *)"asdn", (char *)"daap.songdiscnumber"}, 
        {1, (char *)"asdb", (char *)"daap.songdisabled"}, 
        {9, (char *)"aseq", (char *)"daap.songeqpreset"}, 
        {9, (char *)"asfm", (char *)"daap.songformat"}, 
        {9, (char *)"asgn", (char *)"daap.songgenre"}, 
        {9, (char *)"asdt", (char *)"daap.songdescription"}, 
        {2, (char *)"asrv", (char *)"daap.songrelativevolume"}, 
        {5, (char *)"assr", (char *)"daap.songsamplerate"}, 
        {5, (char *)"assz", (char *)"daap.songsize"}, 
        {5, (char *)"asst", (char *)"daap.songstarttime"}, 
        {5, (char *)"assp", (char *)"daap.songstoptime"}, 
        {5, (char *)"astm", (char *)"daap.songtime"}, 
        {3, (char *)"astc", (char *)"daap.songtrackcount"}, 
        {3, (char *)"astn", (char *)"daap.songtracknumber"}, 
        {1, (char *)"asur", (char *)"daap.songuserrating"}, 
        {3, (char *)"asyr", (char *)"daap.songyear"}, 
        {1, (char *)"asdk", (char *)"daap.songdatakind"}, 
        {9, (char *)"asul", (char *)"daap.songdataurl"}, 
        {12, (char *)"aply", (char *)"daap.databaseplaylists"}, 
        {1, (char *)"abpl", (char *)"daap.baseplaylist"}, 
        {12, (char *)"apso", (char *)"daap.playlistsongs"}, 
        {12, (char *)"arsv", (char *)"daap.resolve"}, 
        {12, (char *)"arif", (char *)"daap.resolveinfo"}, 
        {5, (char *)"aeNV", (char *)"com.apple.itunes.norm-volume"}, 
        {1, (char *)"aeSP", (char *)"com.apple.itunes.smart-playlist"}, 
        {0, (char *)((void *)0), (char *)((void *)0)}};
#line 141 "daap.c"
static query_field_t song_fields[25]  = 
#line 141
  {      {17, "dmap.itemname", (int )((unsigned int )(& ((MP3FILE *)0)->title))}, 
        {15, "dmap.itemid", (int )((unsigned int )(& ((MP3FILE *)0)->id))}, 
        {17, "daap.songalbum", (int )((unsigned int )(& ((MP3FILE *)0)->album))}, 
        {17, "daap.songartist", (int )((unsigned int )(& ((MP3FILE *)0)->artist))}, 
        {15, "daap.songbitrate", (int )((unsigned int )(& ((MP3FILE *)0)->bitrate))}, 
        {17,
      "daap.songcomment", (int )((unsigned int )(& ((MP3FILE *)0)->comment))}, 
        {15, "daap.songcompilation", (int )((unsigned int )(& ((MP3FILE *)0)->compilation))}, 
        {17,
      "daap.songcomposer", (int )((unsigned int )(& ((MP3FILE *)0)->composer))}, 
        {15, "daap.songdatakind", (int )((unsigned int )(& ((MP3FILE *)0)->data_kind))}, 
        {17,
      "daap.songdataurl", (int )((unsigned int )(& ((MP3FILE *)0)->url))}, 
        {15, "daap.songdateadded", (int )((unsigned int )(& ((MP3FILE *)0)->time_added))}, 
        {15,
      "daap.songdatemodified", (int )((unsigned int )(& ((MP3FILE *)0)->time_modified))}, 
        {17,
      "daap.songdescription", (int )((unsigned int )(& ((MP3FILE *)0)->description))}, 
        {15,
      "daap.songdisccount", (int )((unsigned int )(& ((MP3FILE *)0)->total_discs))}, 
        {15,
      "daap.songdiscnumber", (int )((unsigned int )(& ((MP3FILE *)0)->disc))}, 
        {17, "daap.songformat", (int )((unsigned int )(& ((MP3FILE *)0)->type))}, 
        {17, "daap.songgenre", (int )((unsigned int )(& ((MP3FILE *)0)->genre))}, 
        {15, "daap.songsamplerate", (int )((unsigned int )(& ((MP3FILE *)0)->samplerate))}, 
        {15,
      "daap.songsize", (int )((unsigned int )(& ((MP3FILE *)0)->file_size))}, 
        {15, "daap.songstoptime", (int )((unsigned int )(& ((MP3FILE *)0)->song_length))}, 
        {15,
      "daap.songtime", (int )((unsigned int )(& ((MP3FILE *)0)->song_length))}, 
        {15, "daap.songtrackcount", (int )((unsigned int )(& ((MP3FILE *)0)->total_tracks))}, 
        {15,
      "daap.songtracknumber", (int )((unsigned int )(& ((MP3FILE *)0)->track))}, 
        {15, "daap.songyear", (int )((unsigned int )(& ((MP3FILE *)0)->year))}, 
        {(query_type_t )0, (char const   *)0, 0}};
#line 172 "daap.c"
int daap_add_mdcl(DAAP_BLOCK *root , char *tag , char *name , short number ) 
{ DAAP_BLOCK *mdcl ;
  int g ;
  DAAP_BLOCK *tmp ;
  DAAP_BLOCK *tmp___0 ;
  int tmp___1 ;
  DAAP_BLOCK *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 174
  g = 1;
#line 176
  mdcl = daap_add_empty(root, (char *)"mdcl");
#line 177
  if (mdcl) {
#line 178
    tmp = daap_add_string(mdcl, (char *)"mcnm", tag);
#line 178
    g = (int )tmp;
#line 179
    if (g) {
#line 179
      tmp___0 = daap_add_string(mdcl, (char *)"mcna", name);
#line 179
      if (tmp___0) {
#line 179
        tmp___1 = 1;
      } else {
#line 179
        tmp___1 = 0;
      }
    } else {
#line 179
      tmp___1 = 0;
    }
#line 179
    g = tmp___1;
#line 180
    if (g) {
#line 180
      tmp___2 = daap_add_short(mdcl, (char *)"mcty", number);
#line 180
      if (tmp___2) {
#line 180
        tmp___3 = 1;
      } else {
#line 180
        tmp___3 = 0;
      }
    } else {
#line 180
      tmp___3 = 0;
    }
#line 180
    g = tmp___3;
  }
#line 183
  if (mdcl) {
#line 183
    tmp___4 = g;
  } else {
#line 183
    tmp___4 = 0;
  }
#line 183
  return (tmp___4);
}
}
#line 196 "daap.c"
DAAP_BLOCK *daap_response_content_codes(void) 
{ DAAP_BLOCK *root ;
  DAAP_ITEMS *current ;
  int g ;
  DAAP_BLOCK *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 198
  current = taglist;
#line 199
  g = 1;
#line 201
  err_log(9, 512U, (char *)"Preparing to get content codes\n");
#line 203
  root = daap_add_empty((DAAP_BLOCK *)((void *)0), (char *)"mccr");
#line 204
  if (root) {
#line 205
    tmp = daap_add_int(root, (char *)"mstt", 200);
#line 205
    g = (int )tmp;
#line 207
    while (current->type) {
#line 208
      if (g) {
#line 208
        tmp___0 = daap_add_mdcl(root, current->tag, current->description, (short )current->type);
#line 208
        if (tmp___0) {
#line 208
          tmp___1 = 1;
        } else {
#line 208
          tmp___1 = 0;
        }
      } else {
#line 208
        tmp___1 = 0;
      }
#line 208
      g = tmp___1;
#line 210
      current ++;
    }
  }
#line 214
  if (! g) {
#line 215
    daap_free(root);
#line 216
    return ((DAAP_BLOCK *)((void *)0));
  }
#line 219
  return (root);
}
}
#line 229 "daap.c"
DAAP_BLOCK *daap_response_login(char *hostname ) 
{ DAAP_BLOCK *root ;
  int g ;
  int session ;
  DAAP_BLOCK *tmp ;
  DAAP_BLOCK *tmp___0 ;
  int tmp___1 ;

  {
#line 231
  g = 1;
#line 232
  session = 0;
#line 234
  err_log(9, 512U, (char *)"Preparing to send login response\n");
#line 236
  root = daap_add_empty((DAAP_BLOCK *)((void *)0), (char *)"mlog");
#line 237
  if (root) {
#line 238
    tmp = daap_add_int(root, (char *)"mstt", 200);
#line 238
    g = (int )tmp;
#line 239
    session = config_get_next_session();
#line 240
    if (g) {
#line 240
      tmp___0 = daap_add_int(root, (char *)"mlid", session);
#line 240
      if (tmp___0) {
#line 240
        tmp___1 = 1;
      } else {
#line 240
        tmp___1 = 0;
      }
    } else {
#line 240
      tmp___1 = 0;
    }
#line 240
    g = tmp___1;
  }
#line 243
  if (! g) {
#line 244
    daap_free(root);
#line 245
    return ((DAAP_BLOCK *)((void *)0));
  }
#line 248
  err_log(1, 512U, (char *)"%s logging in as session %d\n", hostname, session);
#line 250
  return (root);
}
}
#line 323 "daap.c"
static MetaDataMap gSongMetaDataMap[36]  = 
#line 323
  {      {"dmap.itemid", 0}, 
        {"dmap.itemname", 1}, 
        {"dmap.itemkind", 2}, 
        {"dmap.persistentid", 3}, 
        {"dmap.containeritemid", 4}, 
        {"dmap.parentcontainerid", 5}, 
        {"daap.songalbum", 6}, 
        {"daap.songartist", 7}, 
        {"daap.songbitrate", 9}, 
        {"daap.songbeatsperminute", 8}, 
        {"daap.songcomment", 10}, 
        {"daap.songcompilation", 11}, 
        {"daap.songcomposer", 12}, 
        {"daap.songdatakind", 13}, 
        {"daap.songdataurl", 14}, 
        {"daap.songdateadded", 15}, 
        {"daap.songdatemodified", 16}, 
        {"daap.songdescription", 17}, 
        {"daap.songdisabled", 18}, 
        {"daap.songdisccount", 19}, 
        {"daap.songdiscnumber", 20}, 
        {"daap.songeqpreset", 21}, 
        {"daap.songformat", 22}, 
        {"daap.songgenre", 23}, 
        {"daap.songgrouping", 24}, 
        {"daap.songrelativevolume", 25}, 
        {"daap.songsamplerate", 26}, 
        {"daap.songsize", 27}, 
        {"daap.songstarttime", 28}, 
        {"daap.songstoptime", 29}, 
        {"daap.songtime", 30}, 
        {"daap.songtrackcount", 31}, 
        {"daap.songtracknumber", 32}, 
        {"daap.songuserrating", 33}, 
        {"daap.songyear", 34}, 
        {(char const   *)0, (MetaFieldName_t )0}};
#line 362 "daap.c"
MetaField_t encodeMetaRequest(char *meta , MetaDataMap *map ) 
{ MetaField_t bits ;
  char *start ;
  char *end ;
  MetaDataMap *m ;
  int len ;
  size_t tmp ;
  char *tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 364
  bits = (MetaField_t )0;
#line 369
  start = meta;
#line 369
  while (*start) {
#line 373
    tmp___1 = __builtin_strchr(start, ',');
#line 373
    end = tmp___1;
#line 373
    if ((unsigned int )((char *)0) == (unsigned int )end) {
#line 374
      tmp = strlen((char const   *)start);
#line 374
      end = start + tmp;
    }
#line 376
    len = end - start;
#line 378
    if ((int )*end != 0) {
#line 379
      end ++;
    }
#line 381
    m = map;
#line 381
    while (m->tag) {
#line 382
      if (0) {
#line 382
        if (0) {
#line 382
          __s1_len = strlen(m->tag);
#line 382
          __s2_len = strlen((char const   *)start);
#line 382
          if (! ((unsigned int )((void const   *)(m->tag + 1)) - (unsigned int )((void const   *)m->tag) == 1U)) {
            goto _L___0;
          } else {
#line 382
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 382
              if (! ((unsigned int )((void const   *)(start + 1)) - (unsigned int )((void const   *)start) == 1U)) {
#line 382
                tmp___10 = 1;
              } else {
#line 382
                if (__s2_len >= 4U) {
#line 382
                  tmp___10 = 1;
                } else {
#line 382
                  tmp___10 = 0;
                }
              }
            } else {
#line 382
              tmp___10 = 0;
            }
          }
#line 382
          if (tmp___10) {
#line 382
            tmp___5 = __builtin_strcmp(m->tag, (char const   *)start);
#line 382
            tmp___9 = tmp___5;
          } else {
#line 382
            tmp___8 = __builtin_strcmp(m->tag, (char const   *)start);
#line 382
            tmp___9 = tmp___8;
          }
        } else {
#line 382
          tmp___8 = __builtin_strcmp(m->tag, (char const   *)start);
#line 382
          tmp___9 = tmp___8;
        }
#line 382
        tmp___12 = tmp___9;
      } else {
#line 382
        tmp___11 = strncmp(m->tag, (char const   *)start, (unsigned int )len);
#line 382
        tmp___12 = tmp___11;
      }
#line 382
      if (! tmp___12) {
#line 383
        break;
      }
#line 381
      m ++;
    }
#line 385
    if (m->tag) {
#line 386
      bits |= 1ULL << (int )m->bit;
    } else {
#line 388
      err_log(2, 512U, (char *)"Unknown meta code: %.*s\n", len, start);
    }
#line 369
    start = end;
  }
#line 391
  err_log(9, 512U, (char *)"meta codes: %llu\n", bits);
#line 393
  return (bits);
}
}
#line 396 "daap.c"
int wantsMeta(MetaField_t meta , MetaFieldName_t fieldNo ) 
{ 

  {
#line 398
  return (0ULL != (meta & (1ULL << (int )fieldNo)));
}
}
#line 401 "daap.c"
DAAP_BLOCK *daap_response_songlist(char *metaStr , char *query ) 
{ DAAP_BLOCK *root ;
  int g ;
  DAAP_BLOCK *mlcl ;
  ENUMHANDLE henum ;
  MP3FILE *current ;
  MetaField_t meta ;
  query_node_t *filter ;
  int songs ;
  int tmp ;
  DAAP_BLOCK *tmp___0 ;
  DAAP_BLOCK *tmp___1 ;
  int tmp___2 ;
  DAAP_BLOCK *tmp___3 ;
  int tmp___4 ;
  DAAP_BLOCK *tmp___5 ;
  int tmp___6 ;
  DAAP_BLOCK *tmp___7 ;
  int tmp___8 ;

  {
#line 403
  g = 1;
#line 410
  filter = (query_node_t *)0;
#line 411
  songs = 0;
#line 413
  err_log(9, 512U, (char *)"enter daap_response_songlist\n");
#line 418
  if ((unsigned int )((char *)0) == (unsigned int )metaStr) {
#line 419
    meta = 0xffffffffffffffffULL;
  } else {
#line 421
    meta = encodeMetaRequest(metaStr, gSongMetaDataMap);
  }
#line 423
  if ((unsigned int )((char *)0) != (unsigned int )query) {
#line 424
    filter = query_build((char const   *)query, (query_field_t const   *)(song_fields));
#line 425
    err_log(5, 528U, (char *)"query: %s\n", query);
#line 426
    if (err_debuglevel >= 5) {
#line 427
      query_dump(stderr, filter, 0);
    }
  }
#line 430
  err_log(9, 516U, (char *)"Preparing to send db items\n");
#line 432
  henum = db_enum_begin();
#line 433
  if (! henum) {
#line 433
    tmp = db_get_song_count();
#line 433
    if (tmp) {
#line 434
      err_log(9, 516U, (char *)"Can\'t get enum handle - exiting daap_response_songlist\n");
#line 435
      return ((DAAP_BLOCK *)((void *)0));
    }
  }
#line 438
  root = daap_add_empty((DAAP_BLOCK *)((void *)0), (char *)"adbs");
#line 439
  if (root) {
#line 440
    tmp___0 = daap_add_int(root, (char *)"mstt", 200);
#line 440
    g = (int )tmp___0;
#line 441
    if (g) {
#line 441
      tmp___1 = daap_add_char(root, (char *)"muty", (char)0);
#line 441
      if (tmp___1) {
#line 441
        tmp___2 = 1;
      } else {
#line 441
        tmp___2 = 0;
      }
    } else {
#line 441
      tmp___2 = 0;
    }
#line 441
    g = tmp___2;
#line 442
    if (g) {
#line 442
      tmp___3 = daap_add_int(root, (char *)"mtco", 0);
#line 442
      if (tmp___3) {
#line 442
        tmp___4 = 1;
      } else {
#line 442
        tmp___4 = 0;
      }
    } else {
#line 442
      tmp___4 = 0;
    }
#line 442
    g = tmp___4;
#line 443
    if (g) {
#line 443
      tmp___5 = daap_add_int(root, (char *)"mrco", 0);
#line 443
      if (tmp___5) {
#line 443
        tmp___6 = 1;
      } else {
#line 443
        tmp___6 = 0;
      }
    } else {
#line 443
      tmp___6 = 0;
    }
#line 443
    g = tmp___6;
#line 445
    mlcl = daap_add_empty(root, (char *)"mlcl");
#line 447
    if (mlcl) {
#line 448
      while (1) {
#line 448
        if (g) {
#line 448
          current = db_enum(& henum);
#line 448
          if (! current) {
#line 448
            break;
          }
        } else {
#line 448
          break;
        }
#line 449
        if ((unsigned int )filter == (unsigned int )((query_node_t *)0)) {
#line 451
          err_log(9, 516U, (char *)"Got entry for %s\n", current->fname);
#line 454
          tmp___7 = daap_add_song_entry(mlcl, current, meta);
#line 454
          g = (unsigned int )((DAAP_BLOCK *)0) != (unsigned int )tmp___7;
#line 455
          songs ++;
        } else {
#line 449
          tmp___8 = query_test(filter, (void *)current);
#line 449
          if (tmp___8) {
#line 451
            err_log(9, 516U, (char *)"Got entry for %s\n", current->fname);
#line 454
            tmp___7 = daap_add_song_entry(mlcl, current, meta);
#line 454
            g = (unsigned int )((DAAP_BLOCK *)0) != (unsigned int )tmp___7;
#line 455
            songs ++;
          }
        }
      }
    } else {
#line 458
      g = 0;
    }
  }
#line 461
  db_enum_end(henum);
#line 463
  if ((unsigned int )filter != (unsigned int )((query_node_t *)0)) {
#line 464
    query_free(filter);
  }
#line 466
  if (! g) {
#line 467
    err_log(9, 516U, (char *)"Error enumerating db - exiting daap_response_songlist\n");
#line 468
    daap_free(root);
#line 469
    return ((DAAP_BLOCK *)((void *)0));
  }
#line 472
  err_log(9, 516U, (char *)"Successfully enumerated database - %d items\n", songs);
#line 474
  daap_set_int(root, (char *)"mtco", songs);
#line 475
  daap_set_int(root, (char *)"mrco", songs);
#line 477
  err_log(9, 512U, (char *)"Exiting daap_response_songlist\n");
#line 478
  return (root);
}
}
#line 486 "daap.c"
DAAP_BLOCK *daap_add_song_entry(DAAP_BLOCK *mlcl , MP3FILE *song , unsigned long long meta ) 
{ DAAP_BLOCK *mlit ;
  int g ;
  DAAP_BLOCK *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  DAAP_BLOCK *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  DAAP_BLOCK *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  DAAP_BLOCK *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  DAAP_BLOCK *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  DAAP_BLOCK *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  DAAP_BLOCK *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  DAAP_BLOCK *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  DAAP_BLOCK *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  DAAP_BLOCK *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  DAAP_BLOCK *tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  DAAP_BLOCK *tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  DAAP_BLOCK *tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  DAAP_BLOCK *tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  DAAP_BLOCK *tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  DAAP_BLOCK *tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  DAAP_BLOCK *tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  DAAP_BLOCK *tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  DAAP_BLOCK *tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  DAAP_BLOCK *tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  DAAP_BLOCK *tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  DAAP_BLOCK *tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  DAAP_BLOCK *tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  DAAP_BLOCK *tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  DAAP_BLOCK *tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  DAAP_BLOCK *tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  DAAP_BLOCK *tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  DAAP_BLOCK *tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  DAAP_BLOCK *tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;

  {
#line 489
  g = 1;
#line 491
  mlit = daap_add_empty(mlcl, (char *)"mlit");
#line 492
  if (mlit) {
#line 493
    tmp___1 = wantsMeta(meta, 2);
#line 493
    if (tmp___1) {
#line 494
      if (g) {
#line 494
        tmp = daap_add_char(mlit, (char *)"mikd", (char )song->item_kind);
#line 494
        if (tmp) {
#line 494
          tmp___0 = 1;
        } else {
#line 494
          tmp___0 = 0;
        }
      } else {
#line 494
        tmp___0 = 0;
      }
#line 494
      g = tmp___0;
    }
#line 496
    tmp___4 = wantsMeta(meta, 13);
#line 496
    if (tmp___4) {
#line 497
      if (g) {
#line 497
        tmp___2 = daap_add_char(mlit, (char *)"asdk", (char )song->data_kind);
#line 497
        if (tmp___2) {
#line 497
          tmp___3 = 1;
        } else {
#line 497
          tmp___3 = 0;
        }
      } else {
#line 497
        tmp___3 = 0;
      }
#line 497
      g = tmp___3;
    }
#line 499
    tmp___7 = wantsMeta(meta, 14);
#line 499
    if (tmp___7) {
#line 500
      if (g) {
#line 500
        tmp___5 = daap_add_string(mlit, (char *)"asul", song->url);
#line 500
        if (tmp___5) {
#line 500
          tmp___6 = 1;
        } else {
#line 500
          tmp___6 = 0;
        }
      } else {
#line 500
        tmp___6 = 0;
      }
#line 500
      g = tmp___6;
    }
#line 502
    if (song->album) {
#line 502
      tmp___10 = wantsMeta(meta, 6);
#line 502
      if (tmp___10) {
#line 503
        if (g) {
#line 503
          tmp___8 = daap_add_string(mlit, (char *)"asal", song->album);
#line 503
          if (tmp___8) {
#line 503
            tmp___9 = 1;
          } else {
#line 503
            tmp___9 = 0;
          }
        } else {
#line 503
          tmp___9 = 0;
        }
#line 503
        g = tmp___9;
      }
    }
#line 505
    if (song->artist) {
#line 505
      tmp___13 = wantsMeta(meta, 7);
#line 505
      if (tmp___13) {
#line 506
        if (g) {
#line 506
          tmp___11 = daap_add_string(mlit, (char *)"asar", song->artist);
#line 506
          if (tmp___11) {
#line 506
            tmp___12 = 1;
          } else {
#line 506
            tmp___12 = 0;
          }
        } else {
#line 506
          tmp___12 = 0;
        }
#line 506
        g = tmp___12;
      }
    }
#line 508
    if (song->bpm) {
#line 508
      tmp___16 = wantsMeta(meta, 8);
#line 508
      if (tmp___16) {
#line 509
        if (g) {
#line 509
          tmp___14 = daap_add_short(mlit, (char *)"asbt", (short )song->bpm);
#line 509
          if (tmp___14) {
#line 509
            tmp___15 = 1;
          } else {
#line 509
            tmp___15 = 0;
          }
        } else {
#line 509
          tmp___15 = 0;
        }
#line 509
        g = tmp___15;
      }
    }
#line 511
    if (song->bitrate) {
#line 511
      tmp___19 = wantsMeta(meta, 9);
#line 511
      if (tmp___19) {
#line 512
        if (g) {
#line 512
          tmp___17 = daap_add_short(mlit, (char *)"asbr", (short )song->bitrate);
#line 512
          if (tmp___17) {
#line 512
            tmp___18 = 1;
          } else {
#line 512
            tmp___18 = 0;
          }
        } else {
#line 512
          tmp___18 = 0;
        }
#line 512
        g = tmp___18;
      }
    }
#line 514
    if (song->comment) {
#line 514
      tmp___22 = wantsMeta(meta, 10);
#line 514
      if (tmp___22) {
#line 515
        if (g) {
#line 515
          tmp___20 = daap_add_string(mlit, (char *)"ascm", song->comment);
#line 515
          if (tmp___20) {
#line 515
            tmp___21 = 1;
          } else {
#line 515
            tmp___21 = 0;
          }
        } else {
#line 515
          tmp___21 = 0;
        }
#line 515
        g = tmp___21;
      }
    }
#line 517
    if (song->compilation) {
#line 517
      tmp___25 = wantsMeta(meta, 11);
#line 517
      if (tmp___25) {
#line 518
        if (g) {
#line 518
          tmp___23 = daap_add_char(mlit, (char *)"asco", song->compilation);
#line 518
          if (tmp___23) {
#line 518
            tmp___24 = 1;
          } else {
#line 518
            tmp___24 = 0;
          }
        } else {
#line 518
          tmp___24 = 0;
        }
#line 518
        g = tmp___24;
      }
    }
#line 520
    if (song->composer) {
#line 520
      tmp___28 = wantsMeta(meta, 12);
#line 520
      if (tmp___28) {
#line 521
        if (g) {
#line 521
          tmp___26 = daap_add_string(mlit, (char *)"ascp", song->composer);
#line 521
          if (tmp___26) {
#line 521
            tmp___27 = 1;
          } else {
#line 521
            tmp___27 = 0;
          }
        } else {
#line 521
          tmp___27 = 0;
        }
#line 521
        g = tmp___27;
      }
    }
#line 523
    if (song->grouping) {
#line 523
      tmp___31 = wantsMeta(meta, 24);
#line 523
      if (tmp___31) {
#line 524
        if (g) {
#line 524
          tmp___29 = daap_add_string(mlit, (char *)"agrp", song->grouping);
#line 524
          if (tmp___29) {
#line 524
            tmp___30 = 1;
          } else {
#line 524
            tmp___30 = 0;
          }
        } else {
#line 524
          tmp___30 = 0;
        }
#line 524
        g = tmp___30;
      }
    }
#line 526
    if (song->time_added) {
#line 526
      tmp___34 = wantsMeta(meta, 15);
#line 526
      if (tmp___34) {
#line 527
        if (g) {
#line 527
          tmp___32 = daap_add_int(mlit, (char *)"asda", song->time_added);
#line 527
          if (tmp___32) {
#line 527
            tmp___33 = 1;
          } else {
#line 527
            tmp___33 = 0;
          }
        } else {
#line 527
          tmp___33 = 0;
        }
#line 527
        g = tmp___33;
      }
    }
#line 529
    if (song->time_modified) {
#line 529
      tmp___37 = wantsMeta(meta, 16);
#line 529
      if (tmp___37) {
#line 530
        if (g) {
#line 530
          tmp___35 = daap_add_int(mlit, (char *)"asdm", song->time_modified);
#line 530
          if (tmp___35) {
#line 530
            tmp___36 = 1;
          } else {
#line 530
            tmp___36 = 0;
          }
        } else {
#line 530
          tmp___36 = 0;
        }
#line 530
        g = tmp___36;
      }
    }
#line 532
    if (song->total_discs) {
#line 532
      tmp___40 = wantsMeta(meta, 19);
#line 532
      if (tmp___40) {
#line 534
        if (g) {
#line 534
          tmp___38 = daap_add_short(mlit, (char *)"asdc", (short )song->total_discs);
#line 534
          if (tmp___38) {
#line 534
            tmp___39 = 1;
          } else {
#line 534
            tmp___39 = 0;
          }
        } else {
#line 534
          tmp___39 = 0;
        }
#line 534
        g = tmp___39;
      }
    }
#line 536
    if (song->disc) {
#line 536
      tmp___43 = wantsMeta(meta, 20);
#line 536
      if (tmp___43) {
#line 538
        if (g) {
#line 538
          tmp___41 = daap_add_short(mlit, (char *)"asdn", (short )song->disc);
#line 538
          if (tmp___41) {
#line 538
            tmp___42 = 1;
          } else {
#line 538
            tmp___42 = 0;
          }
        } else {
#line 538
          tmp___42 = 0;
        }
#line 538
        g = tmp___42;
      }
    }
#line 544
    if (song->genre) {
#line 544
      tmp___46 = wantsMeta(meta, 23);
#line 544
      if (tmp___46) {
#line 545
        if (g) {
#line 545
          tmp___44 = daap_add_string(mlit, (char *)"asgn", song->genre);
#line 545
          if (tmp___44) {
#line 545
            tmp___45 = 1;
          } else {
#line 545
            tmp___45 = 0;
          }
        } else {
#line 545
          tmp___45 = 0;
        }
#line 545
        g = tmp___45;
      }
    }
#line 547
    tmp___49 = wantsMeta(meta, 0);
#line 547
    if (tmp___49) {
#line 548
      if (g) {
#line 548
        tmp___47 = daap_add_int(mlit, (char *)"miid", (int )song->id);
#line 548
        if (tmp___47) {
#line 548
          tmp___48 = 1;
        } else {
#line 548
          tmp___48 = 0;
        }
      } else {
#line 548
        tmp___48 = 0;
      }
#line 548
      g = tmp___48;
    }
#line 550
    tmp___52 = wantsMeta(meta, 3);
#line 550
    if (tmp___52) {
#line 551
      if (g) {
#line 551
        tmp___50 = daap_add_long(mlit, (char *)"mper", 0, (int )song->id);
#line 551
        if (tmp___50) {
#line 551
          tmp___51 = 1;
        } else {
#line 551
          tmp___51 = 0;
        }
      } else {
#line 551
        tmp___51 = 0;
      }
#line 551
      g = tmp___51;
    }
#line 554
    tmp___55 = wantsMeta(meta, 22);
#line 554
    if (tmp___55) {
#line 555
      if (g) {
#line 555
        tmp___53 = daap_add_string(mlit, (char *)"asfm", song->type);
#line 555
        if (tmp___53) {
#line 555
          tmp___54 = 1;
        } else {
#line 555
          tmp___54 = 0;
        }
      } else {
#line 555
        tmp___54 = 0;
      }
#line 555
      g = tmp___54;
    }
#line 557
    tmp___58 = wantsMeta(meta, 17);
#line 557
    if (tmp___58) {
#line 558
      if (g) {
#line 558
        tmp___56 = daap_add_string(mlit, (char *)"asdt", song->description);
#line 558
        if (tmp___56) {
#line 558
          tmp___57 = 1;
        } else {
#line 558
          tmp___57 = 0;
        }
      } else {
#line 558
        tmp___57 = 0;
      }
#line 558
      g = tmp___57;
    }
#line 560
    tmp___61 = wantsMeta(meta, 1);
#line 560
    if (tmp___61) {
#line 561
      if (g) {
#line 561
        tmp___59 = daap_add_string(mlit, (char *)"minm", song->title);
#line 561
        if (tmp___59) {
#line 561
          tmp___60 = 1;
        } else {
#line 561
          tmp___60 = 0;
        }
      } else {
#line 561
        tmp___60 = 0;
      }
#line 561
      g = tmp___60;
    }
#line 566
    if (song->samplerate) {
#line 566
      tmp___64 = wantsMeta(meta, 26);
#line 566
      if (tmp___64) {
#line 567
        if (g) {
#line 567
          tmp___62 = daap_add_int(mlit, (char *)"assr", song->samplerate);
#line 567
          if (tmp___62) {
#line 567
            tmp___63 = 1;
          } else {
#line 567
            tmp___63 = 0;
          }
        } else {
#line 567
          tmp___63 = 0;
        }
#line 567
        g = tmp___63;
      }
    }
#line 569
    if (song->file_size) {
#line 569
      tmp___67 = wantsMeta(meta, 27);
#line 569
      if (tmp___67) {
#line 570
        if (g) {
#line 570
          tmp___65 = daap_add_int(mlit, (char *)"assz", song->file_size);
#line 570
          if (tmp___65) {
#line 570
            tmp___66 = 1;
          } else {
#line 570
            tmp___66 = 0;
          }
        } else {
#line 570
          tmp___66 = 0;
        }
#line 570
        g = tmp___66;
      }
    }
#line 572
    tmp___70 = wantsMeta(meta, 28);
#line 572
    if (tmp___70) {
#line 573
      if (g) {
#line 573
        tmp___68 = daap_add_int(mlit, (char *)"asst", 0);
#line 573
        if (tmp___68) {
#line 573
          tmp___69 = 1;
        } else {
#line 573
          tmp___69 = 0;
        }
      } else {
#line 573
        tmp___69 = 0;
      }
#line 573
      g = tmp___69;
    }
#line 574
    tmp___73 = wantsMeta(meta, 29);
#line 574
    if (tmp___73) {
#line 575
      if (g) {
#line 575
        tmp___71 = daap_add_int(mlit, (char *)"assp", 0);
#line 575
        if (tmp___71) {
#line 575
          tmp___72 = 1;
        } else {
#line 575
          tmp___72 = 0;
        }
      } else {
#line 575
        tmp___72 = 0;
      }
#line 575
      g = tmp___72;
    }
#line 577
    if (song->song_length) {
#line 577
      tmp___76 = wantsMeta(meta, 30);
#line 577
      if (tmp___76) {
#line 578
        if (g) {
#line 578
          tmp___74 = daap_add_int(mlit, (char *)"astm", song->song_length);
#line 578
          if (tmp___74) {
#line 578
            tmp___75 = 1;
          } else {
#line 578
            tmp___75 = 0;
          }
        } else {
#line 578
          tmp___75 = 0;
        }
#line 578
        g = tmp___75;
      }
    }
#line 580
    if (song->total_tracks) {
#line 580
      tmp___79 = wantsMeta(meta, 31);
#line 580
      if (tmp___79) {
#line 581
        if (g) {
#line 581
          tmp___77 = daap_add_short(mlit, (char *)"astc", (short )song->total_tracks);
#line 581
          if (tmp___77) {
#line 581
            tmp___78 = 1;
          } else {
#line 581
            tmp___78 = 0;
          }
        } else {
#line 581
          tmp___78 = 0;
        }
#line 581
        g = tmp___78;
      }
    }
#line 583
    if (song->track) {
#line 583
      tmp___82 = wantsMeta(meta, 32);
#line 583
      if (tmp___82) {
#line 584
        if (g) {
#line 584
          tmp___80 = daap_add_short(mlit, (char *)"astn", (short )song->track);
#line 584
          if (tmp___80) {
#line 584
            tmp___81 = 1;
          } else {
#line 584
            tmp___81 = 0;
          }
        } else {
#line 584
          tmp___81 = 0;
        }
#line 584
        g = tmp___81;
      }
    }
#line 587
    if (song->year) {
#line 587
      tmp___85 = wantsMeta(meta, 34);
#line 587
      if (tmp___85) {
#line 588
        if (g) {
#line 588
          tmp___83 = daap_add_short(mlit, (char *)"asyr", (short )song->year);
#line 588
          if (tmp___83) {
#line 588
            tmp___84 = 1;
          } else {
#line 588
            tmp___84 = 0;
          }
        } else {
#line 588
          tmp___84 = 0;
        }
#line 588
        g = tmp___84;
      }
    }
  }
#line 591
  if (g == 0) {
#line 593
    daap_free(mlit);
#line 594
    mlit = (DAAP_BLOCK *)0;
  }
#line 597
  return (mlit);
}
}
#line 606 "daap.c"
DAAP_BLOCK *daap_response_update(int fd , int clientver ) 
{ DAAP_BLOCK *root ;
  int g ;
  fd_set rset ;
  struct timeval tv ;
  int result ;
  int __d0 ;
  int __d1 ;
  register char __result ;
  int tmp ;
  DAAP_BLOCK *tmp___0 ;
  int tmp___1 ;
  DAAP_BLOCK *tmp___2 ;
  int tmp___3 ;

  {
#line 608
  g = 1;
#line 613
  err_log(9, 512U, (char *)"Preparing to send update response\n");
#line 615
  while (1) {
#line 615
    tmp = db_version();
#line 615
    if (! (clientver == tmp)) {
#line 615
      break;
    }
#line 616
    while (1) {
#line 616
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rset.__fds_bits[0]): "memory");
#line 616
      break;
    }
#line 617
    __asm__  volatile   ("btsl %1,%0": "=m" (rset.__fds_bits[(unsigned int )fd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fd % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 619
    tv.tv_sec = 30L;
#line 620
    tv.tv_usec = 0L;
#line 622
    result = select(fd + 1, (fd_set * __restrict  )(& rset), (fd_set * __restrict  )((void *)0),
                    (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(& tv));
#line 623
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )fd % (8U * sizeof(__fd_mask ))),
                         "m" (rset.__fds_bits[(unsigned int )fd / (8U * sizeof(__fd_mask ))]): "cc");
#line 623
    if (__result) {
#line 625
      err_log(9, 512U, (char *)"Socket closed?\n");
#line 627
      return ((DAAP_BLOCK *)((void *)0));
    }
  }
#line 631
  root = daap_add_empty((DAAP_BLOCK *)((void *)0), (char *)"mupd");
#line 632
  if (root) {
#line 633
    tmp___0 = daap_add_int(root, (char *)"mstt", 200);
#line 633
    g = (int )tmp___0;
#line 635
    if (g) {
#line 635
      tmp___1 = db_version();
#line 635
      tmp___2 = daap_add_int(root, (char *)"musr", tmp___1);
#line 635
      if (tmp___2) {
#line 635
        tmp___3 = 1;
      } else {
#line 635
        tmp___3 = 0;
      }
    } else {
#line 635
      tmp___3 = 0;
    }
#line 635
    g = tmp___3;
  }
#line 638
  if (! g) {
#line 639
    daap_free(root);
#line 640
    return ((DAAP_BLOCK *)((void *)0));
  }
#line 643
  return (root);
}
}
#line 652 "daap.c"
DAAP_BLOCK *daap_response_playlists(char *name ) 
{ DAAP_BLOCK *root ;
  DAAP_BLOCK *mlcl ;
  DAAP_BLOCK *mlit ;
  int g ;
  int playlistid ;
  ENUMHANDLE henum ;
  DAAP_BLOCK *tmp ;
  DAAP_BLOCK *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  DAAP_BLOCK *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  DAAP_BLOCK *tmp___6 ;
  int tmp___7 ;
  DAAP_BLOCK *tmp___8 ;
  int tmp___9 ;
  DAAP_BLOCK *tmp___10 ;
  int tmp___11 ;
  DAAP_BLOCK *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  DAAP_BLOCK *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char const   *tmp___20 ;
  int tmp___21 ;
  DAAP_BLOCK *tmp___22 ;
  int tmp___23 ;
  DAAP_BLOCK *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  DAAP_BLOCK *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  DAAP_BLOCK *tmp___30 ;
  int tmp___31 ;
  DAAP_BLOCK *tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;

  {
#line 653
  root = (DAAP_BLOCK *)((void *)0);
#line 654
  mlcl = (DAAP_BLOCK *)((void *)0);
#line 655
  mlit = (DAAP_BLOCK *)((void *)0);
#line 656
  g = 1;
#line 660
  err_log(9, 512U, (char *)"Preparing to send playlists\n");
#line 662
  root = daap_add_empty((DAAP_BLOCK *)((void *)0), (char *)"aply");
#line 663
  if (root) {
#line 664
    tmp = daap_add_int(root, (char *)"mstt", 200);
#line 664
    g = (int )tmp;
#line 665
    if (g) {
#line 665
      tmp___0 = daap_add_char(root, (char *)"muty", (char)0);
#line 665
      if (tmp___0) {
#line 665
        tmp___1 = 1;
      } else {
#line 665
        tmp___1 = 0;
      }
    } else {
#line 665
      tmp___1 = 0;
    }
#line 665
    g = tmp___1;
#line 666
    if (g) {
#line 666
      tmp___2 = db_get_playlist_count();
#line 666
      tmp___3 = daap_add_int(root, (char *)"mtco", 1 + tmp___2);
#line 666
      if (tmp___3) {
#line 666
        tmp___4 = 1;
      } else {
#line 666
        tmp___4 = 0;
      }
    } else {
#line 666
      tmp___4 = 0;
    }
#line 666
    g = tmp___4;
#line 667
    if (g) {
#line 667
      tmp___5 = db_get_playlist_count();
#line 667
      tmp___6 = daap_add_int(root, (char *)"mrco", 1 + tmp___5);
#line 667
      if (tmp___6) {
#line 667
        tmp___7 = 1;
      } else {
#line 667
        tmp___7 = 0;
      }
    } else {
#line 667
      tmp___7 = 0;
    }
#line 667
    g = tmp___7;
#line 668
    mlcl = daap_add_empty(root, (char *)"mlcl");
#line 669
    if (mlcl) {
#line 670
      mlit = daap_add_empty(mlcl, (char *)"mlit");
#line 671
      if (mlit) {
#line 672
        if (g) {
#line 672
          tmp___8 = daap_add_int(mlit, (char *)"miid", 1);
#line 672
          if (tmp___8) {
#line 672
            tmp___9 = 1;
          } else {
#line 672
            tmp___9 = 0;
          }
        } else {
#line 672
          tmp___9 = 0;
        }
#line 672
        g = tmp___9;
#line 673
        if (g) {
#line 673
          tmp___10 = daap_add_long(mlit, (char *)"mper", 0, 1);
#line 673
          if (tmp___10) {
#line 673
            tmp___11 = 1;
          } else {
#line 673
            tmp___11 = 0;
          }
        } else {
#line 673
          tmp___11 = 0;
        }
#line 673
        g = tmp___11;
#line 674
        if (g) {
#line 674
          tmp___12 = daap_add_string(mlit, (char *)"minm", name);
#line 674
          if (tmp___12) {
#line 674
            tmp___13 = 1;
          } else {
#line 674
            tmp___13 = 0;
          }
        } else {
#line 674
          tmp___13 = 0;
        }
#line 674
        g = tmp___13;
#line 675
        if (g) {
#line 675
          tmp___14 = db_get_song_count();
#line 675
          tmp___15 = daap_add_int(mlit, (char *)"mimc", tmp___14);
#line 675
          if (tmp___15) {
#line 675
            tmp___16 = 1;
          } else {
#line 675
            tmp___16 = 0;
          }
        } else {
#line 675
          tmp___16 = 0;
        }
#line 675
        g = tmp___16;
      }
#line 678
      if (g) {
#line 678
        if (mlit) {
#line 678
          tmp___17 = 1;
        } else {
#line 678
          tmp___17 = 0;
        }
      } else {
#line 678
        tmp___17 = 0;
      }
#line 678
      g = tmp___17;
#line 681
      henum = db_playlist_enum_begin();
#line 682
      while (henum) {
#line 683
        playlistid = db_playlist_enum(& henum);
#line 684
        err_log(9, 640U, (char *)"Returning playlist %d\n", playlistid);
#line 685
        tmp___18 = db_get_playlist_entry_count((unsigned long )playlistid);
#line 685
        err_log(9, 640U, (char *)"  -- Songs: %d\n", tmp___18);
#line 687
        tmp___21 = db_get_playlist_is_smart((unsigned long )playlistid);
#line 687
        if (tmp___21) {
#line 687
          tmp___20 = "Yes";
        } else {
#line 687
          tmp___20 = "No";
        }
#line 687
        err_log(9, 640U, (char *)"  -- Smart: %s\n", tmp___20);
#line 690
        mlit = daap_add_empty(mlcl, (char *)"mlit");
#line 691
        if (mlit) {
#line 692
          if (g) {
#line 692
            tmp___22 = daap_add_int(mlit, (char *)"miid", playlistid);
#line 692
            if (tmp___22) {
#line 692
              tmp___23 = 1;
            } else {
#line 692
              tmp___23 = 0;
            }
          } else {
#line 692
            tmp___23 = 0;
          }
#line 692
          g = tmp___23;
#line 693
          if (g) {
#line 693
            tmp___24 = daap_add_long(mlit, (char *)"mper", 0, playlistid);
#line 693
            if (tmp___24) {
#line 693
              tmp___25 = 1;
            } else {
#line 693
              tmp___25 = 0;
            }
          } else {
#line 693
            tmp___25 = 0;
          }
#line 693
          g = tmp___25;
#line 694
          if (g) {
#line 694
            tmp___26 = db_get_playlist_name((unsigned long )playlistid);
#line 694
            tmp___27 = daap_add_string(mlit, (char *)"minm", tmp___26);
#line 694
            if (tmp___27) {
#line 694
              tmp___28 = 1;
            } else {
#line 694
              tmp___28 = 0;
            }
          } else {
#line 694
            tmp___28 = 0;
          }
#line 694
          g = tmp___28;
#line 695
          if (g) {
#line 695
            tmp___29 = db_get_playlist_entry_count((unsigned long )playlistid);
#line 695
            tmp___30 = daap_add_int(mlit, (char *)"mimc", tmp___29);
#line 695
            if (tmp___30) {
#line 695
              tmp___31 = 1;
            } else {
#line 695
              tmp___31 = 0;
            }
          } else {
#line 695
            tmp___31 = 0;
          }
#line 695
          g = tmp___31;
#line 696
          tmp___34 = db_get_playlist_is_smart((unsigned long )playlistid);
#line 696
          if (tmp___34) {
#line 697
            if (g) {
#line 697
              tmp___32 = daap_add_char(mlit, (char *)"aeSP", (char)1);
#line 697
              if (tmp___32) {
#line 697
                tmp___33 = 1;
              } else {
#line 697
                tmp___33 = 0;
              }
            } else {
#line 697
              tmp___33 = 0;
            }
#line 697
            g = tmp___33;
          }
        }
#line 700
        if (g) {
#line 700
          if (mlit) {
#line 700
            tmp___35 = 1;
          } else {
#line 700
            tmp___35 = 0;
          }
        } else {
#line 700
          tmp___35 = 0;
        }
#line 700
        g = tmp___35;
      }
#line 702
      db_playlist_enum_end(henum);
    }
  }
#line 707
  if (g) {
#line 707
    if (mlcl) {
#line 707
      tmp___36 = 1;
    } else {
#line 707
      tmp___36 = 0;
    }
  } else {
#line 707
    tmp___36 = 0;
  }
#line 707
  g = tmp___36;
#line 709
  if (! g) {
#line 710
    err_log(5, 512U, (char *)"Memory problem.  Bailing\n");
#line 711
    daap_free(root);
#line 712
    return ((DAAP_BLOCK *)((void *)0));
  }
#line 715
  return (root);
}
}
#line 724 "daap.c"
DAAP_BLOCK *daap_response_dbinfo(char *name ) 
{ DAAP_BLOCK *root ;
  DAAP_BLOCK *mlcl ;
  DAAP_BLOCK *mlit ;
  int g ;
  DAAP_BLOCK *tmp ;
  DAAP_BLOCK *tmp___0 ;
  int tmp___1 ;
  DAAP_BLOCK *tmp___2 ;
  int tmp___3 ;
  DAAP_BLOCK *tmp___4 ;
  int tmp___5 ;
  DAAP_BLOCK *tmp___6 ;
  int tmp___7 ;
  DAAP_BLOCK *tmp___8 ;
  int tmp___9 ;
  DAAP_BLOCK *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  DAAP_BLOCK *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  DAAP_BLOCK *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
#line 725
  root = (DAAP_BLOCK *)((void *)0);
#line 726
  mlcl = (DAAP_BLOCK *)((void *)0);
#line 727
  mlit = (DAAP_BLOCK *)((void *)0);
#line 728
  g = 1;
#line 730
  err_log(9, 516U, (char *)"Preparing to send db info\n");
#line 732
  root = daap_add_empty((DAAP_BLOCK *)((void *)0), (char *)"avdb");
#line 733
  if (root) {
#line 734
    tmp = daap_add_int(root, (char *)"mstt", 200);
#line 734
    g = (int )tmp;
#line 735
    if (g) {
#line 735
      tmp___0 = daap_add_char(root, (char *)"muty", (char)0);
#line 735
      if (tmp___0) {
#line 735
        tmp___1 = 1;
      } else {
#line 735
        tmp___1 = 0;
      }
    } else {
#line 735
      tmp___1 = 0;
    }
#line 735
    g = tmp___1;
#line 736
    if (g) {
#line 736
      tmp___2 = daap_add_int(root, (char *)"mtco", 1);
#line 736
      if (tmp___2) {
#line 736
        tmp___3 = 1;
      } else {
#line 736
        tmp___3 = 0;
      }
    } else {
#line 736
      tmp___3 = 0;
    }
#line 736
    g = tmp___3;
#line 737
    if (g) {
#line 737
      tmp___4 = daap_add_int(root, (char *)"mrco", 1);
#line 737
      if (tmp___4) {
#line 737
        tmp___5 = 1;
      } else {
#line 737
        tmp___5 = 0;
      }
    } else {
#line 737
      tmp___5 = 0;
    }
#line 737
    g = tmp___5;
#line 738
    mlcl = daap_add_empty(root, (char *)"mlcl");
#line 739
    if (mlcl) {
#line 740
      mlit = daap_add_empty(mlcl, (char *)"mlit");
#line 741
      if (mlit) {
#line 742
        if (g) {
#line 742
          tmp___6 = daap_add_int(mlit, (char *)"miid", 1);
#line 742
          if (tmp___6) {
#line 742
            tmp___7 = 1;
          } else {
#line 742
            tmp___7 = 0;
          }
        } else {
#line 742
          tmp___7 = 0;
        }
#line 742
        g = tmp___7;
#line 743
        if (g) {
#line 743
          tmp___8 = daap_add_long(mlit, (char *)"mper", 0, 1);
#line 743
          if (tmp___8) {
#line 743
            tmp___9 = 1;
          } else {
#line 743
            tmp___9 = 0;
          }
        } else {
#line 743
          tmp___9 = 0;
        }
#line 743
        g = tmp___9;
#line 744
        if (g) {
#line 744
          tmp___10 = daap_add_string(mlit, (char *)"minm", name);
#line 744
          if (tmp___10) {
#line 744
            tmp___11 = 1;
          } else {
#line 744
            tmp___11 = 0;
          }
        } else {
#line 744
          tmp___11 = 0;
        }
#line 744
        g = tmp___11;
#line 745
        if (g) {
#line 745
          tmp___12 = db_get_song_count();
#line 745
          tmp___13 = daap_add_int(mlit, (char *)"mimc", tmp___12);
#line 745
          if (tmp___13) {
#line 745
            tmp___14 = 1;
          } else {
#line 745
            tmp___14 = 0;
          }
        } else {
#line 745
          tmp___14 = 0;
        }
#line 745
        g = tmp___14;
#line 746
        if (g) {
#line 746
          tmp___15 = db_get_playlist_count();
#line 746
          tmp___16 = daap_add_int(mlit, (char *)"mctc", 1 + tmp___15);
#line 746
          if (tmp___16) {
#line 746
            tmp___17 = 1;
          } else {
#line 746
            tmp___17 = 0;
          }
        } else {
#line 746
          tmp___17 = 0;
        }
#line 746
        g = tmp___17;
      }
    }
  }
#line 751
  if (g) {
#line 751
    if (mlcl) {
#line 751
      if (mlit) {
#line 751
        tmp___18 = 1;
      } else {
#line 751
        tmp___18 = 0;
      }
    } else {
#line 751
      tmp___18 = 0;
    }
  } else {
#line 751
    tmp___18 = 0;
  }
#line 751
  g = tmp___18;
#line 753
  if (! g) {
#line 754
    err_log(5, 512U, (char *)"Memory problem.  Bailing\n");
#line 755
    daap_free(root);
#line 756
    return ((DAAP_BLOCK *)((void *)0));
  }
#line 759
  tmp___19 = db_get_playlist_count();
#line 759
  tmp___20 = db_get_song_count();
#line 759
  err_log(9, 516U, (char *)"Sent db info... %d songs, %d playlists\n", tmp___20, tmp___19);
#line 762
  return (root);
}
}
#line 770 "daap.c"
DAAP_BLOCK *daap_response_server_info(char *name , char *client_version ) 
{ DAAP_BLOCK *root ;
  int g ;
  int mpro ;
  int apro ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  DAAP_BLOCK *tmp___13 ;
  DAAP_BLOCK *tmp___14 ;
  int tmp___15 ;
  DAAP_BLOCK *tmp___16 ;
  int tmp___17 ;
  DAAP_BLOCK *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  DAAP_BLOCK *tmp___21 ;
  int tmp___22 ;
  DAAP_BLOCK *tmp___23 ;
  int tmp___24 ;
  DAAP_BLOCK *tmp___25 ;
  int tmp___26 ;
  DAAP_BLOCK *tmp___27 ;
  int tmp___28 ;
  DAAP_BLOCK *tmp___29 ;
  int tmp___30 ;
  DAAP_BLOCK *tmp___31 ;
  int tmp___32 ;
  DAAP_BLOCK *tmp___33 ;
  int tmp___34 ;
  DAAP_BLOCK *tmp___35 ;
  int tmp___36 ;

  {
#line 772
  g = 1;
#line 773
  mpro = 2 << 16;
#line 774
  apro = 3 << 16;
#line 776
  err_log(9, 512U, (char *)"Preparing to send server-info for client ver %s\n", client_version);
#line 778
  root = daap_add_empty((DAAP_BLOCK *)((void *)0), (char *)"msrv");
#line 780
  if (root) {
#line 781
    if (client_version) {
#line 781
      if (0) {
#line 781
        __s1_len = strlen((char const   *)client_version);
#line 781
        __s2_len = strlen("1.0");
#line 781
        if (! ((unsigned int )((void const   *)(client_version + 1)) - (unsigned int )((void const   *)client_version) == 1U)) {
          goto _L___0;
        } else {
#line 781
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 781
            if (! ((unsigned int )((void const   *)("1.0" + 1)) - (unsigned int )((void const   *)"1.0") == 1U)) {
#line 781
              tmp___5 = 1;
            } else {
#line 781
              if (__s2_len >= 4U) {
#line 781
                tmp___5 = 1;
              } else {
#line 781
                tmp___5 = 0;
              }
            }
          } else {
#line 781
            tmp___5 = 0;
          }
        }
#line 781
        if (tmp___5) {
#line 781
          tmp___0 = __builtin_strcmp((char const   *)client_version, "1.0");
#line 781
          tmp___4 = tmp___0;
        } else {
#line 781
          tmp___3 = __builtin_strcmp((char const   *)client_version, "1.0");
#line 781
          tmp___4 = tmp___3;
        }
      } else {
#line 781
        tmp___3 = __builtin_strcmp((char const   *)client_version, "1.0");
#line 781
        tmp___4 = tmp___3;
      }
#line 781
      if (! tmp___4) {
#line 782
        mpro = 1 << 16;
#line 783
        apro = 1 << 16;
      }
    }
#line 786
    if (client_version) {
#line 786
      if (0) {
#line 786
        __s1_len___0 = strlen((char const   *)client_version);
#line 786
        __s2_len___0 = strlen("2.0");
#line 786
        if (! ((unsigned int )((void const   *)(client_version + 1)) - (unsigned int )((void const   *)client_version) == 1U)) {
          goto _L___2;
        } else {
#line 786
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 786
            if (! ((unsigned int )((void const   *)("2.0" + 1)) - (unsigned int )((void const   *)"2.0") == 1U)) {
#line 786
              tmp___12 = 1;
            } else {
#line 786
              if (__s2_len___0 >= 4U) {
#line 786
                tmp___12 = 1;
              } else {
#line 786
                tmp___12 = 0;
              }
            }
          } else {
#line 786
            tmp___12 = 0;
          }
        }
#line 786
        if (tmp___12) {
#line 786
          tmp___7 = __builtin_strcmp((char const   *)client_version, "2.0");
#line 786
          tmp___11 = tmp___7;
        } else {
#line 786
          tmp___10 = __builtin_strcmp((char const   *)client_version, "2.0");
#line 786
          tmp___11 = tmp___10;
        }
      } else {
#line 786
        tmp___10 = __builtin_strcmp((char const   *)client_version, "2.0");
#line 786
        tmp___11 = tmp___10;
      }
#line 786
      if (! tmp___11) {
#line 787
        mpro = 1 << 16;
#line 788
        apro = 2 << 16;
      }
    }
#line 791
    tmp___13 = daap_add_int(root, (char *)"mstt", 200);
#line 791
    g = (int )tmp___13;
#line 792
    if (g) {
#line 792
      tmp___14 = daap_add_int(root, (char *)"mpro", mpro);
#line 792
      if (tmp___14) {
#line 792
        tmp___15 = 1;
      } else {
#line 792
        tmp___15 = 0;
      }
    } else {
#line 792
      tmp___15 = 0;
    }
#line 792
    g = tmp___15;
#line 793
    if (g) {
#line 793
      tmp___16 = daap_add_int(root, (char *)"apro", apro);
#line 793
      if (tmp___16) {
#line 793
        tmp___17 = 1;
      } else {
#line 793
        tmp___17 = 0;
      }
    } else {
#line 793
      tmp___17 = 0;
    }
#line 793
    g = tmp___17;
#line 795
    if (g) {
#line 795
      tmp___18 = daap_add_string(root, (char *)"minm", name);
#line 795
      if (tmp___18) {
#line 795
        tmp___19 = 1;
      } else {
#line 795
        tmp___19 = 0;
      }
    } else {
#line 795
      tmp___19 = 0;
    }
#line 795
    g = tmp___19;
#line 806
    if (g) {
#line 806
      if ((unsigned int )config.readpassword != (unsigned int )((void *)0)) {
#line 806
        tmp___20 = 2;
      } else {
#line 806
        tmp___20 = 0;
      }
#line 806
      tmp___21 = daap_add_char(root, (char *)"msau", (char )tmp___20);
#line 806
      if (tmp___21) {
#line 806
        tmp___22 = 1;
      } else {
#line 806
        tmp___22 = 0;
      }
    } else {
#line 806
      tmp___22 = 0;
    }
#line 806
    g = tmp___22;
#line 809
    if (g) {
#line 809
      tmp___23 = daap_add_int(root, (char *)"mstm", 1800);
#line 809
      if (tmp___23) {
#line 809
        tmp___24 = 1;
      } else {
#line 809
        tmp___24 = 0;
      }
    } else {
#line 809
      tmp___24 = 0;
    }
#line 809
    g = tmp___24;
#line 815
    if (g) {
#line 815
      tmp___25 = daap_add_char(root, (char *)"msex", (char)0);
#line 815
      if (tmp___25) {
#line 815
        tmp___26 = 1;
      } else {
#line 815
        tmp___26 = 0;
      }
    } else {
#line 815
      tmp___26 = 0;
    }
#line 815
    g = tmp___26;
#line 816
    if (g) {
#line 816
      tmp___27 = daap_add_char(root, (char *)"msix", (char)0);
#line 816
      if (tmp___27) {
#line 816
        tmp___28 = 1;
      } else {
#line 816
        tmp___28 = 0;
      }
    } else {
#line 816
      tmp___28 = 0;
    }
#line 816
    g = tmp___28;
#line 818
    if (g) {
#line 818
      tmp___29 = daap_add_char(root, (char *)"msbr", (char)0);
#line 818
      if (tmp___29) {
#line 818
        tmp___30 = 1;
      } else {
#line 818
        tmp___30 = 0;
      }
    } else {
#line 818
      tmp___30 = 0;
    }
#line 818
    g = tmp___30;
#line 819
    if (g) {
#line 819
      tmp___31 = daap_add_char(root, (char *)"msqy", (char)0);
#line 819
      if (tmp___31) {
#line 819
        tmp___32 = 1;
      } else {
#line 819
        tmp___32 = 0;
      }
    } else {
#line 819
      tmp___32 = 0;
    }
#line 819
    g = tmp___32;
#line 821
    if (g) {
#line 821
      tmp___33 = daap_add_char(root, (char *)"msup", (char)0);
#line 821
      if (tmp___33) {
#line 821
        tmp___34 = 1;
      } else {
#line 821
        tmp___34 = 0;
      }
    } else {
#line 821
      tmp___34 = 0;
    }
#line 821
    g = tmp___34;
#line 828
    if (g) {
#line 828
      tmp___35 = daap_add_int(root, (char *)"msdc", 1);
#line 828
      if (tmp___35) {
#line 828
        tmp___36 = 1;
      } else {
#line 828
        tmp___36 = 0;
      }
    } else {
#line 828
      tmp___36 = 0;
    }
#line 828
    g = tmp___36;
  }
#line 831
  if (! g) {
#line 832
    daap_free(root);
#line 833
    return ((DAAP_BLOCK *)((void *)0));
  }
#line 836
  return (root);
}
}
#line 845 "daap.c"
DAAP_BLOCK *daap_response_playlist_items(unsigned int playlist , char *metaStr , char *query ) 
{ DAAP_BLOCK *root ;
  DAAP_BLOCK *mlcl ;
  DAAP_BLOCK *mlit ;
  ENUMHANDLE henum ;
  MP3FILE *current ;
  unsigned long itemid ;
  int g ;
  unsigned long long meta ;
  query_node_t *filter ;
  int songs ;
  DAAP_BLOCK *tmp ;
  DAAP_BLOCK *tmp___0 ;
  int tmp___1 ;
  DAAP_BLOCK *tmp___2 ;
  int tmp___3 ;
  DAAP_BLOCK *tmp___4 ;
  int tmp___5 ;
  DAAP_BLOCK *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  DAAP_BLOCK *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 852
  g = 1;
#line 854
  filter = (query_node_t *)0;
#line 855
  songs = 0;
#line 861
  if ((unsigned int )((char *)0) == (unsigned int )metaStr) {
#line 862
    meta = (unsigned long long )((((1LL | (1LL << 1)) | (1LL << 2)) | (1LL << 4)) | (1LL << 5));
  } else {
#line 868
    meta = encodeMetaRequest(metaStr, gSongMetaDataMap);
  }
#line 870
  if ((unsigned int )((char *)0) != (unsigned int )query) {
#line 871
    filter = query_build((char const   *)query, (query_field_t const   *)(song_fields));
#line 872
    err_log(5, 528U, (char *)"query: %s\n", query);
#line 873
    if (err_debuglevel >= 5) {
#line 874
      query_dump(stderr, filter, 0);
    }
  }
#line 877
  err_log(9, 640U, (char *)"Preparing to send playlist items for pl #%d\n", playlist);
#line 879
  if (playlist == 1U) {
#line 880
    henum = db_enum_begin();
  } else {
#line 882
    henum = db_playlist_items_enum_begin((unsigned long )playlist);
  }
#line 890
  root = daap_add_empty((DAAP_BLOCK *)((void *)0), (char *)"apso");
#line 891
  if (root) {
#line 892
    tmp = daap_add_int(root, (char *)"mstt", 200);
#line 892
    g = (int )tmp;
#line 893
    if (g) {
#line 893
      tmp___0 = daap_add_char(root, (char *)"muty", (char)0);
#line 893
      if (tmp___0) {
#line 893
        tmp___1 = 1;
      } else {
#line 893
        tmp___1 = 0;
      }
    } else {
#line 893
      tmp___1 = 0;
    }
#line 893
    g = tmp___1;
#line 894
    if (g) {
#line 894
      tmp___2 = daap_add_int(root, (char *)"mtco", 0);
#line 894
      if (tmp___2) {
#line 894
        tmp___3 = 1;
      } else {
#line 894
        tmp___3 = 0;
      }
    } else {
#line 894
      tmp___3 = 0;
    }
#line 894
    g = tmp___3;
#line 895
    if (g) {
#line 895
      tmp___4 = daap_add_int(root, (char *)"mrco", 0);
#line 895
      if (tmp___4) {
#line 895
        tmp___5 = 1;
      } else {
#line 895
        tmp___5 = 0;
      }
    } else {
#line 895
      tmp___5 = 0;
    }
#line 895
    g = tmp___5;
#line 897
    mlcl = daap_add_empty(root, (char *)"mlcl");
#line 899
    if (mlcl) {
#line 900
      if (playlist == 1U) {
#line 901
        while (1) {
#line 901
          current = db_enum(& henum);
#line 901
          if (! current) {
#line 901
            break;
          }
#line 902
          if ((unsigned int )((query_node_t *)0) == (unsigned int )filter) {
            goto _L;
          } else {
#line 902
            tmp___9 = query_test(filter, (void *)current);
#line 902
            if (tmp___9) {
              _L: /* CIL Label */ 
#line 904
              songs ++;
#line 905
              mlit = daap_add_song_entry(mlcl, current, meta);
#line 906
              if ((unsigned int )((DAAP_BLOCK *)0) != (unsigned int )mlit) {
#line 907
                tmp___8 = wantsMeta(meta, 4);
#line 907
                if (tmp___8) {
#line 908
                  if (g) {
#line 908
                    tmp___6 = daap_add_int(mlit, (char *)"mcti", (int )current->id);
#line 908
                    if (tmp___6) {
#line 908
                      tmp___7 = 1;
                    } else {
#line 908
                      tmp___7 = 0;
                    }
                  } else {
#line 908
                    tmp___7 = 0;
                  }
#line 908
                  g = tmp___7;
                }
              } else {
#line 909
                g = 0;
              }
            }
          }
        }
      } else {
#line 913
        while (1) {
#line 913
          tmp___14 = db_playlist_items_enum(& henum);
#line 913
          itemid = (unsigned long )tmp___14;
#line 913
          if (! (itemid != 4294967295UL)) {
#line 913
            break;
          }
#line 914
          current = db_find(itemid);
#line 915
          if ((unsigned int )((MP3FILE *)0) != (unsigned int )current) {
#line 916
            if ((unsigned int )((query_node_t *)0) == (unsigned int )filter) {
              goto _L___0;
            } else {
#line 916
              tmp___13 = query_test(filter, (void *)current);
#line 916
              if (tmp___13) {
                _L___0: /* CIL Label */ 
#line 918
                songs ++;
#line 919
                err_log(9, 640U, (char *)"Adding itemid %lu\n", itemid);
#line 920
                mlit = daap_add_song_entry(mlcl, current, meta);
#line 921
                if ((unsigned int )((DAAP_BLOCK *)0) != (unsigned int )mlit) {
#line 922
                  tmp___12 = wantsMeta(meta, 4);
#line 922
                  if (tmp___12) {
#line 924
                    if (g) {
#line 924
                      tmp___10 = daap_add_int(mlit, (char *)"mcti", (int )current->id);
#line 924
                      if (tmp___10) {
#line 924
                        tmp___11 = 1;
                      } else {
#line 924
                        tmp___11 = 0;
                      }
                    } else {
#line 924
                      tmp___11 = 0;
                    }
#line 924
                    g = tmp___11;
                  }
                } else {
#line 925
                  g = 0;
                }
              }
            }
#line 927
            db_dispose(current);
#line 928
            free((void *)current);
          } else {
#line 929
            g = 0;
          }
        }
      }
    } else {
#line 932
      g = 0;
    }
  }
#line 935
  if (playlist == 1U) {
#line 936
    db_enum_end(henum);
  } else {
#line 938
    db_playlist_items_enum_end(henum);
  }
#line 940
  if ((unsigned int )((query_node_t *)0) != (unsigned int )filter) {
#line 941
    query_free(filter);
  }
#line 943
  if (! g) {
#line 944
    daap_free(root);
#line 945
    return ((DAAP_BLOCK *)((void *)0));
  }
#line 948
  err_log(9, 640U, (char *)"Sucessfully enumerated %d items\n", songs);
#line 950
  daap_set_int(root, (char *)"mtco", songs);
#line 951
  daap_set_int(root, (char *)"mrco", songs);
#line 953
  return (root);
}
}
#line 966 "daap.c"
void daap_handle_index(DAAP_BLOCK *block , char const   *index___0 ) 
{ int first ;
  int count ;
  int size ;
  char *ptr ;
  DAAP_BLOCK *list ;
  DAAP_BLOCK *item ;
  DAAP_BLOCK **back ;
  int n ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___2 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___12 ;
  long tmp___13 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___30 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___43 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;

  {
#line 978
  list = daap_find(block, (char *)"mlcl");
#line 978
  if ((unsigned int )((DAAP_BLOCK *)0) == (unsigned int )list) {
#line 979
    return;
  }
#line 982
  size = 0;
#line 982
  item = list->children;
#line 982
  while (item) {
#line 983
    if (0) {
#line 983
      if (0) {
#line 983
        __s1_len = strlen((char const   *)(item->tag));
#line 983
        __s2_len = strlen("mlit");
#line 983
        if (! ((unsigned int )((void const   *)(item->tag + 1)) - (unsigned int )((void const   *)(item->tag)) == 1U)) {
          goto _L___0;
        } else {
#line 983
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 983
            if (! ((unsigned int )((void const   *)("mlit" + 1)) - (unsigned int )((void const   *)"mlit") == 1U)) {
#line 983
              tmp___7 = 1;
            } else {
#line 983
              if (__s2_len >= 4U) {
#line 983
                tmp___7 = 1;
              } else {
#line 983
                tmp___7 = 0;
              }
            }
          } else {
#line 983
            tmp___7 = 0;
          }
        }
#line 983
        if (tmp___7) {
#line 983
          tmp___2 = __builtin_strcmp((char const   *)(item->tag), "mlit");
#line 983
          tmp___6 = tmp___2;
        } else {
#line 983
          tmp___5 = __builtin_strcmp((char const   *)(item->tag), "mlit");
#line 983
          tmp___6 = tmp___5;
        }
      } else {
#line 983
        tmp___5 = __builtin_strcmp((char const   *)(item->tag), "mlit");
#line 983
        tmp___6 = tmp___5;
      }
#line 983
      tmp___9 = tmp___6;
    } else {
#line 983
      tmp___8 = strncmp((char const   *)(item->tag), "mlit", 4U);
#line 983
      tmp___9 = tmp___8;
    }
#line 983
    if (! tmp___9) {
#line 984
      size ++;
    }
#line 982
    item = item->next;
  }
#line 987
  tmp___12 = strtol((char const   * __restrict  )index___0, (char ** __restrict  )(& ptr),
                    10);
#line 987
  n = (int )tmp___12;
#line 990
  if (n < 0) {
#line 992
    n *= -1;
#line 995
    if (n < size) {
#line 997
      first = size - n;
#line 998
      count = n;
    } else {
#line 1004
      first = 0;
#line 1005
      count = size;
    }
  } else {
#line 1010
    if (0 == (int )*ptr) {
#line 1013
      if (n < size) {
#line 1015
        first = n;
#line 1016
        count = 1;
      } else {
#line 1022
        first = 0;
#line 1023
        count = 0;
      }
    } else {
#line 1028
      if (45 == (int )*ptr) {
#line 1031
        first = n;
#line 1034
        ptr ++;
#line 1034
        if ((int )*ptr == 0) {
#line 1035
          n = size;
        } else {
#line 1040
          tmp___13 = strtol((char const   * __restrict  )ptr, (char ** __restrict  )(& ptr),
                            10);
#line 1040
          n = (int )(tmp___13 + 1L);
#line 1043
          if (n > size) {
#line 1044
            n = size;
          }
        }
#line 1047
        count = n - first;
      }
    }
  }
#line 1052
  daap_set_int(block, (char *)"mrco", count);
#line 1054
  err_log(5, 544U, (char *)"index:%s first:%d count:%d\n", index___0, first, count);
#line 1057
  back = & list->children;
#line 1057
  while (1) {
#line 1057
    if (*back) {
#line 1057
      if (! first) {
#line 1057
        break;
      }
    } else {
#line 1057
      break;
    }
#line 1058
    if (0) {
#line 1058
      if (0) {
#line 1058
        __s1_len___0 = strlen((char const   *)((*back)->tag));
#line 1058
        __s2_len___0 = strlen("mlit");
#line 1058
        if (! ((unsigned int )((void const   *)((*back)->tag + 1)) - (unsigned int )((void const   *)((*back)->tag)) == 1U)) {
          goto _L___2;
        } else {
#line 1058
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 1058
            if (! ((unsigned int )((void const   *)("mlit" + 1)) - (unsigned int )((void const   *)"mlit") == 1U)) {
#line 1058
              tmp___22 = 1;
            } else {
#line 1058
              if (__s2_len___0 >= 4U) {
#line 1058
                tmp___22 = 1;
              } else {
#line 1058
                tmp___22 = 0;
              }
            }
          } else {
#line 1058
            tmp___22 = 0;
          }
        }
#line 1058
        if (tmp___22) {
#line 1058
          tmp___17 = __builtin_strcmp((char const   *)((*back)->tag), "mlit");
#line 1058
          tmp___21 = tmp___17;
        } else {
#line 1058
          tmp___20 = __builtin_strcmp((char const   *)((*back)->tag), "mlit");
#line 1058
          tmp___21 = tmp___20;
        }
      } else {
#line 1058
        tmp___20 = __builtin_strcmp((char const   *)((*back)->tag), "mlit");
#line 1058
        tmp___21 = tmp___20;
      }
#line 1058
      tmp___24 = tmp___21;
    } else {
#line 1058
      tmp___23 = strncmp((char const   *)((*back)->tag), "mlit", 4U);
#line 1058
      tmp___24 = tmp___23;
    }
#line 1058
    if (tmp___24) {
#line 1065
      back = & (*back)->next;
    } else {
#line 1060
      err_log(9, 544U, (char *)"first:%d removing\n", first);
#line 1061
      daap_remove(*back);
#line 1062
      first --;
    }
  }
#line 1068
  while (1) {
#line 1068
    if (*back) {
#line 1068
      if (! count) {
#line 1068
        break;
      }
    } else {
#line 1068
      break;
    }
#line 1069
    if (0) {
#line 1069
      if (0) {
#line 1069
        __s1_len___1 = strlen((char const   *)((*back)->tag));
#line 1069
        __s2_len___1 = strlen("mlit");
#line 1069
        if (! ((unsigned int )((void const   *)((*back)->tag + 1)) - (unsigned int )((void const   *)((*back)->tag)) == 1U)) {
          goto _L___4;
        } else {
#line 1069
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 1069
            if (! ((unsigned int )((void const   *)("mlit" + 1)) - (unsigned int )((void const   *)"mlit") == 1U)) {
#line 1069
              tmp___35 = 1;
            } else {
#line 1069
              if (__s2_len___1 >= 4U) {
#line 1069
                tmp___35 = 1;
              } else {
#line 1069
                tmp___35 = 0;
              }
            }
          } else {
#line 1069
            tmp___35 = 0;
          }
        }
#line 1069
        if (tmp___35) {
#line 1069
          tmp___30 = __builtin_strcmp((char const   *)((*back)->tag), "mlit");
#line 1069
          tmp___34 = tmp___30;
        } else {
#line 1069
          tmp___33 = __builtin_strcmp((char const   *)((*back)->tag), "mlit");
#line 1069
          tmp___34 = tmp___33;
        }
      } else {
#line 1069
        tmp___33 = __builtin_strcmp((char const   *)((*back)->tag), "mlit");
#line 1069
        tmp___34 = tmp___33;
      }
#line 1069
      tmp___37 = tmp___34;
    } else {
#line 1069
      tmp___36 = strncmp((char const   *)((*back)->tag), "mlit", 4U);
#line 1069
      tmp___37 = tmp___36;
    }
#line 1069
    if (! tmp___37) {
#line 1071
      err_log(9, 544U, (char *)"count:%d keeping\n", count);
#line 1072
      count --;
    }
#line 1068
    back = & (*back)->next;
  }
#line 1076
  while (*back) {
#line 1078
    if (0) {
#line 1078
      if (0) {
#line 1078
        __s1_len___2 = strlen((char const   *)((*back)->tag));
#line 1078
        __s2_len___2 = strlen("mlit");
#line 1078
        if (! ((unsigned int )((void const   *)((*back)->tag + 1)) - (unsigned int )((void const   *)((*back)->tag)) == 1U)) {
          goto _L___6;
        } else {
#line 1078
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 1078
            if (! ((unsigned int )((void const   *)("mlit" + 1)) - (unsigned int )((void const   *)"mlit") == 1U)) {
#line 1078
              tmp___48 = 1;
            } else {
#line 1078
              if (__s2_len___2 >= 4U) {
#line 1078
                tmp___48 = 1;
              } else {
#line 1078
                tmp___48 = 0;
              }
            }
          } else {
#line 1078
            tmp___48 = 0;
          }
        }
#line 1078
        if (tmp___48) {
#line 1078
          tmp___43 = __builtin_strcmp((char const   *)((*back)->tag), "mlit");
#line 1078
          tmp___47 = tmp___43;
        } else {
#line 1078
          tmp___46 = __builtin_strcmp((char const   *)((*back)->tag), "mlit");
#line 1078
          tmp___47 = tmp___46;
        }
      } else {
#line 1078
        tmp___46 = __builtin_strcmp((char const   *)((*back)->tag), "mlit");
#line 1078
        tmp___47 = tmp___46;
      }
#line 1078
      tmp___50 = tmp___47;
    } else {
#line 1078
      tmp___49 = strncmp((char const   *)((*back)->tag), "mlit", 4U);
#line 1078
      tmp___50 = tmp___49;
    }
#line 1078
    if (tmp___50) {
#line 1084
      back = & (*back)->next;
    } else {
#line 1080
      err_log(9, 544U, (char *)"removing spare\n");
#line 1081
      daap_remove(*back);
    }
  }
#line 1086
  return;
}
}
#line 1095 "daap.c"
static void add_browse_item(browse_item **root , char *name ) 
{ browse_item *item ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *tmp___7 ;

  {
#line 1099
  while (1) {
#line 1099
    item = *root;
#line 1099
    if ((unsigned int )((browse_item *)0) != (unsigned int )item) {
#line 1099
      tmp = strcasecmp((char const   *)item->name, (char const   *)name);
#line 1099
      if (! (tmp < 0)) {
#line 1099
        break;
      }
    } else {
#line 1099
      break;
    }
#line 1100
    root = & item->next;
  }
#line 1102
  if (item) {
#line 1102
    tmp___0 = strcasecmp((char const   *)item->name, (char const   *)name);
#line 1102
    if (tmp___0 == 0) {
#line 1103
      return;
    }
  }
#line 1105
  tmp___1 = calloc(1U, sizeof(browse_item ));
#line 1105
  item = (browse_item *)tmp___1;
#line 1106
  tmp___7 = __strdup((char const   *)name);
#line 1106
  item->name = tmp___7;
#line 1107
  item->next = *root;
#line 1108
  *root = item;
#line 1109
  return;
}
}
#line 1111 "daap.c"
static void free_browse_items(browse_item *root ) 
{ browse_item *next ;

  {
#line 1113
  while ((unsigned int )((browse_item *)0) != (unsigned int )root) {
#line 1115
    next = root->next;
#line 1117
    free((void *)root->name);
#line 1118
    free((void *)root);
#line 1120
    root = next;
  }
#line 1122
  return;
}
}
#line 1124 "daap.c"
static int count_browse_items(browse_item *root ) 
{ int count ;

  {
#line 1126
  count = 0;
#line 1128
  while ((unsigned int )((browse_item *)0) != (unsigned int )root) {
#line 1130
    root = root->next;
#line 1131
    count ++;
  }
#line 1134
  return (count);
}
}
#line 1140 "daap.c"
static query_field_t browse_fields[5]  = {      {17, "daap.songartist", (int )((unsigned int )(& ((MP3FILE *)0)->artist))}, 
        {17, "daap.songalbum", (int )((unsigned int )(& ((MP3FILE *)0)->album))}, 
        {17, "daap.songgenre", (int )((unsigned int )(& ((MP3FILE *)0)->genre))}, 
        {17, "daap.songcomposer", (int )((unsigned int )(& ((MP3FILE *)0)->composer))}, 
        {(query_type_t )0,
      (char const   *)0, 0}};
#line 1148 "daap.c"
DAAP_BLOCK *daap_response_browse(char const   *name , char const   *filter ) 
{ MP3FILE *current ;
  ENUMHANDLE henum ;
  size_t field ;
  char *l_type ;
  browse_item *items ;
  browse_item *item ;
  DAAP_BLOCK *root ;
  query_node_t *query ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char *name___0 ;
  int tmp___27 ;
  int count ;
  int tmp___28 ;
  DAAP_BLOCK *mlcl ;
  DAAP_BLOCK *tmp___29 ;
  DAAP_BLOCK *tmp___30 ;
  DAAP_BLOCK *tmp___31 ;
  DAAP_BLOCK *tmp___32 ;

  {
#line 1154
  items = (browse_item *)0;
#line 1156
  root = (DAAP_BLOCK *)0;
#line 1157
  query = (query_node_t *)0;
#line 1159
  if (0) {
#line 1159
    __s1_len___2 = strlen(name);
#line 1159
    __s2_len___2 = strlen("artists");
#line 1159
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___6;
    } else {
#line 1159
      if (__s1_len___2 >= 4U) {
        _L___6: /* CIL Label */ 
#line 1159
        if (! ((unsigned int )((void const   *)("artists" + 1)) - (unsigned int )((void const   *)"artists") == 1U)) {
#line 1159
          tmp___26 = 1;
        } else {
#line 1159
          if (__s2_len___2 >= 4U) {
#line 1159
            tmp___26 = 1;
          } else {
#line 1159
            tmp___26 = 0;
          }
        }
      } else {
#line 1159
        tmp___26 = 0;
      }
    }
#line 1159
    if (tmp___26) {
#line 1159
      tmp___21 = __builtin_strcmp(name, "artists");
#line 1159
      tmp___25 = tmp___21;
    } else {
#line 1159
      tmp___24 = __builtin_strcmp(name, "artists");
#line 1159
      tmp___25 = tmp___24;
    }
  } else {
#line 1159
    tmp___24 = __builtin_strcmp(name, "artists");
#line 1159
    tmp___25 = tmp___24;
  }
#line 1159
  if (tmp___25) {
#line 1164
    if (0) {
#line 1164
      __s1_len___1 = strlen(name);
#line 1164
      __s2_len___1 = strlen("genres");
#line 1164
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___4;
      } else {
#line 1164
        if (__s1_len___1 >= 4U) {
          _L___4: /* CIL Label */ 
#line 1164
          if (! ((unsigned int )((void const   *)("genres" + 1)) - (unsigned int )((void const   *)"genres") == 1U)) {
#line 1164
            tmp___19 = 1;
          } else {
#line 1164
            if (__s2_len___1 >= 4U) {
#line 1164
              tmp___19 = 1;
            } else {
#line 1164
              tmp___19 = 0;
            }
          }
        } else {
#line 1164
          tmp___19 = 0;
        }
      }
#line 1164
      if (tmp___19) {
#line 1164
        tmp___14 = __builtin_strcmp(name, "genres");
#line 1164
        tmp___18 = tmp___14;
      } else {
#line 1164
        tmp___17 = __builtin_strcmp(name, "genres");
#line 1164
        tmp___18 = tmp___17;
      }
    } else {
#line 1164
      tmp___17 = __builtin_strcmp(name, "genres");
#line 1164
      tmp___18 = tmp___17;
    }
#line 1164
    if (tmp___18) {
#line 1169
      if (0) {
#line 1169
        __s1_len___0 = strlen(name);
#line 1169
        __s2_len___0 = strlen("albums");
#line 1169
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___2;
        } else {
#line 1169
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 1169
            if (! ((unsigned int )((void const   *)("albums" + 1)) - (unsigned int )((void const   *)"albums") == 1U)) {
#line 1169
              tmp___12 = 1;
            } else {
#line 1169
              if (__s2_len___0 >= 4U) {
#line 1169
                tmp___12 = 1;
              } else {
#line 1169
                tmp___12 = 0;
              }
            }
          } else {
#line 1169
            tmp___12 = 0;
          }
        }
#line 1169
        if (tmp___12) {
#line 1169
          tmp___7 = __builtin_strcmp(name, "albums");
#line 1169
          tmp___11 = tmp___7;
        } else {
#line 1169
          tmp___10 = __builtin_strcmp(name, "albums");
#line 1169
          tmp___11 = tmp___10;
        }
      } else {
#line 1169
        tmp___10 = __builtin_strcmp(name, "albums");
#line 1169
        tmp___11 = tmp___10;
      }
#line 1169
      if (tmp___11) {
#line 1174
        if (0) {
#line 1174
          __s1_len = strlen(name);
#line 1174
          __s2_len = strlen("composers");
#line 1174
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
            goto _L___0;
          } else {
#line 1174
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 1174
              if (! ((unsigned int )((void const   *)("composers" + 1)) - (unsigned int )((void const   *)"composers") == 1U)) {
#line 1174
                tmp___5 = 1;
              } else {
#line 1174
                if (__s2_len >= 4U) {
#line 1174
                  tmp___5 = 1;
                } else {
#line 1174
                  tmp___5 = 0;
                }
              }
            } else {
#line 1174
              tmp___5 = 0;
            }
          }
#line 1174
          if (tmp___5) {
#line 1174
            tmp___0 = __builtin_strcmp(name, "composers");
#line 1174
            tmp___4 = tmp___0;
          } else {
#line 1174
            tmp___3 = __builtin_strcmp(name, "composers");
#line 1174
            tmp___4 = tmp___3;
          }
        } else {
#line 1174
          tmp___3 = __builtin_strcmp(name, "composers");
#line 1174
          tmp___4 = tmp___3;
        }
#line 1174
        if (tmp___4) {
#line 1181
          err_log(2, 576U, (char *)"Invalid browse request: %s\n", name);
#line 1182
          return ((DAAP_BLOCK *)((void *)0));
        } else {
#line 1176
          field = (unsigned int )(& ((MP3FILE *)0)->composer);
#line 1177
          l_type = (char *)"abcp";
        }
      } else {
#line 1171
        field = (unsigned int )(& ((MP3FILE *)0)->album);
#line 1172
        l_type = (char *)"abal";
      }
    } else {
#line 1166
      field = (unsigned int )(& ((MP3FILE *)0)->genre);
#line 1167
      l_type = (char *)"abgn";
    }
  } else {
#line 1161
    field = (unsigned int )(& ((MP3FILE *)0)->artist);
#line 1162
    l_type = (char *)"abar";
  }
#line 1185
  if ((unsigned int )((char const   *)0) != (unsigned int )filter) {
#line 1185
    query = query_build(filter, (query_field_t const   *)(browse_fields));
#line 1185
    if ((unsigned int )((query_node_t *)0) == (unsigned int )query) {
#line 1187
      return ((DAAP_BLOCK *)((void *)0));
    }
  }
#line 1189
  if (query) {
#line 1190
    err_log(5, 592U, (char *)"query: %s\n", filter);
#line 1191
    if (err_debuglevel >= 5) {
#line 1192
      query_dump(stderr, query, 0);
    }
  }
#line 1195
  henum = db_enum_begin();
#line 1195
  if ((unsigned int )((ENUMHANDLE )0) == (unsigned int )henum) {
#line 1196
    return ((DAAP_BLOCK *)((void *)0));
  }
#line 1198
  while (1) {
#line 1198
    current = db_enum(& henum);
#line 1198
    if (! current) {
#line 1198
      break;
    }
#line 1200
    if ((unsigned int )((query_node_t *)0) == (unsigned int )query) {
      goto _L___7;
    } else {
#line 1200
      tmp___27 = query_test(query, (void *)current);
#line 1200
      if (tmp___27) {
        _L___7: /* CIL Label */ 
#line 1202
        name___0 = *((char **)((unsigned int )current + field));
#line 1204
        if ((unsigned int )((char *)0) != (unsigned int )name___0) {
#line 1205
          add_browse_item(& items, name___0);
        }
      }
    }
  }
#line 1209
  db_enum_end(henum);
#line 1211
  root = daap_add_empty((DAAP_BLOCK *)0, (char *)"abro");
#line 1211
  if ((unsigned int )((DAAP_BLOCK *)0) != (unsigned int )root) {
#line 1213
    tmp___28 = count_browse_items(items);
#line 1213
    count = tmp___28;
#line 1216
    tmp___29 = daap_add_int(root, (char *)"mstt", 200);
#line 1216
    if (tmp___29) {
#line 1216
      tmp___30 = daap_add_int(root, (char *)"mtco", count);
#line 1216
      if (tmp___30) {
#line 1216
        tmp___31 = daap_add_int(root, (char *)"mrco", count);
#line 1216
        if (tmp___31) {
#line 1216
          mlcl = daap_add_empty(root, l_type);
#line 1216
          if ((unsigned int )((DAAP_BLOCK *)0) == (unsigned int )mlcl) {
            goto error;
          }
        } else {
          goto error;
        }
      } else {
        goto error;
      }
    } else {
      goto error;
    }
#line 1222
    item = items;
#line 1222
    while (item) {
#line 1224
      tmp___32 = daap_add_string(mlcl, (char *)"mlit", item->name);
#line 1224
      if (! tmp___32) {
        goto error;
      }
#line 1222
      item = item->next;
    }
  }
#line 1229
  free_browse_items(items);
#line 1231
  if ((unsigned int )((query_node_t *)0) != (unsigned int )query) {
#line 1232
    query_free(query);
  }
#line 1234
  return (root);
  error: 
#line 1237
  free_browse_items(items);
#line 1239
  if ((unsigned int )((query_node_t *)0) != (unsigned int )query) {
#line 1240
    query_free(query);
  }
#line 1242
  if ((unsigned int )root != (unsigned int )((DAAP_BLOCK *)0)) {
#line 1243
    daap_free(root);
  }
#line 1245
  return ((DAAP_BLOCK *)((void *)0));
}
}
#line 1 "db-gdbm.o"
#pragma merger(0,"/tmp/cil-MUFagRtG.i","-g,-g,-O2")
#line 85 "/usr/include/gdbm.h"
extern GDBM_FILE gdbm_open(char * , int  , int  , int  , void (*)() ) ;
#line 86
extern void gdbm_close(GDBM_FILE  ) ;
#line 87
extern int gdbm_store(GDBM_FILE  , datum  , datum  , int  ) ;
#line 88
extern datum gdbm_fetch(GDBM_FILE  , datum  ) ;
#line 89
extern int gdbm_delete(GDBM_FILE  , datum  ) ;
#line 90
extern datum gdbm_firstkey(GDBM_FILE  ) ;
#line 91
extern datum gdbm_nextkey(GDBM_FILE  , datum  ) ;
#line 92
extern int gdbm_reorganize(GDBM_FILE  ) ;
#line 93
extern void gdbm_sync(GDBM_FILE  ) ;
#line 94
extern int gdbm_exists(GDBM_FILE  , datum  ) ;
#line 462 "/usr/include/pthread.h"
extern int pthread_once(pthread_once_t *__once_control , void (*__init_routine)(void) )  __attribute__((__nonnull__(1,2))) ;
#line 842
extern  __attribute__((__nothrow__)) int pthread_rwlock_init(pthread_rwlock_t * __restrict  __rwlock ,
                                                             pthread_rwlockattr_t const   * __restrict  __attr )  __attribute__((__nonnull__(1))) ;
#line 851
extern  __attribute__((__nothrow__)) int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock )  __attribute__((__nonnull__(1))) ;
#line 866
extern  __attribute__((__nothrow__)) int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock )  __attribute__((__nonnull__(1))) ;
#line 881
extern  __attribute__((__nothrow__)) int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock )  __attribute__((__nonnull__(1))) ;
#line 130 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s )  __attribute__((__nonnull__(1),
__malloc__)) ;
#line 73 "mp3-scanner.h"
void make_composite_tags(MP3FILE *song ) ;
#line 57 "playlist.h"
void pl_eval(MP3FILE *pmp3 ) ;
#line 58
void pl_register(void) ;
#line 93 "redblack.h"
struct rbtree *rbinit(int (*cmp)(void const   * , void const   * , void const   * ) ,
                      void const   *config___0 ) ;
#line 100
void const   *rbdelete(void const   *key , struct rbtree *rbinfo ) ;
#line 108
void const   *rblookup(int mode , void const   *key , struct rbtree *rbinfo ) ;
#line 112
void const   *rbsearch(void const   *key , struct rbtree *rbinfo ) ;
#line 116
void rbdestroy(struct rbtree *rbinfo ) ;
#line 29 "db-memory.h"
int db_start_initial_update(void) ;
#line 30
int db_end_initial_update(void) ;
#line 31
int db_is_empty(void) ;
#line 36
int db_add(MP3FILE *pmp3 ) ;
#line 37
int db_delete(unsigned long id ) ;
#line 38
int db_add_playlist(unsigned long playlistid , char *name , int file_time , int is_smart ) ;
#line 39
int db_add_playlist_song(unsigned long playlistid , unsigned long itemid ) ;
#line 40
int db_delete_playlist(unsigned long playlistid ) ;
#line 62
int db_playlist_last_modified(unsigned long playlistid ) ;
#line 63
int db_scanning(void) ;
#line 66
int db_exists(unsigned long id ) ;
#line 67
int db_last_modified(unsigned long id ) ;
#line 140 "db-gdbm.c"
static int db_version_no  ;
#line 141 "db-gdbm.c"
static int db_update_mode  =    0;
#line 142 "db-gdbm.c"
static int db_song_count  ;
#line 143 "db-gdbm.c"
static int db_playlist_count  =    0;
#line 145 "db-gdbm.c"
static DB_PLAYLIST db_playlists  ;
#line 146 "db-gdbm.c"
static pthread_rwlock_t db_rwlock  ;
#line 147 "db-gdbm.c"
static pthread_once_t db_initlock  =    0;
#line 148 "db-gdbm.c"
static GDBM_FILE db_songs  ;
#line 149 "db-gdbm.c"
static struct rbtree *db_removed  ;
#line 150 "db-gdbm.c"
static MP3FILE gdbm_mp3  ;
#line 151 "db-gdbm.c"
static int gdbm_mp3_mustfree  =    0;
#line 152 "db-gdbm.c"
static pthread_mutex_t db_gdbm_mutex  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 157
static void db_writelock(void) ;
#line 158
static void db_readlock(void) ;
#line 159
static int db_unlock(void) ;
#line 160
static void db_gdbmlock(void) ;
#line 161
static int db_gdbmunlock(void) ;
#line 163
static DB_PLAYLIST *db_playlist_find(unsigned long playlistid ) ;
#line 177
int db_unpackrecord(datum *pdatum , MP3FILE *pmp3 ) ;
#line 179
datum *db_packrecord(MP3FILE *pmp3 ) ;
#line 190
int db_compare_rb_nodes(void const   *pa , void const   *pb , void const   *cfg ) ;
#line 199 "db-gdbm.c"
static void db_readlock(void) 
{ int err ;
  char *tmp ;

  {
#line 202
  err = pthread_rwlock_rdlock(& db_rwlock);
#line 202
  if (err) {
#line 203
    tmp = strerror(err);
#line 203
    err_log(0, 4U, (char *)"cannot lock rdlock: %s\n", tmp);
  }
#line 205
  return;
}
}
#line 212 "db-gdbm.c"
static void db_writelock(void) 
{ int err ;
  char *tmp ;

  {
#line 215
  err = pthread_rwlock_wrlock(& db_rwlock);
#line 215
  if (err) {
#line 216
    tmp = strerror(err);
#line 216
    err_log(0, 4U, (char *)"cannot lock rwlock: %s\n", tmp);
  }
#line 218
  return;
}
}
#line 225 "db-gdbm.c"
static int db_unlock(void) 
{ int tmp ;

  {
#line 226
  tmp = pthread_rwlock_unlock(& db_rwlock);
#line 226
  return (tmp);
}
}
#line 235 "db-gdbm.c"
static void db_gdbmlock(void) 
{ int err ;
  char *tmp ;

  {
#line 238
  err = pthread_mutex_lock(& db_gdbm_mutex);
#line 238
  if (err) {
#line 239
    tmp = strerror(err);
#line 239
    err_log(0, 4U, (char *)"cannot lock gdbmlock: %s\n", tmp);
  }
#line 241
  return;
}
}
#line 248 "db-gdbm.c"
static int db_gdbmunlock(void) 
{ int tmp ;

  {
#line 249
  tmp = pthread_mutex_unlock(& db_gdbm_mutex);
#line 249
  return (tmp);
}
}
#line 258 "db-gdbm.c"
int db_compare_rb_nodes(void const   *pa , void const   *pb , void const   *cfg ) 
{ 

  {
#line 259
  if (*((unsigned long *)pa) < *((unsigned long *)pb)) {
#line 259
    return (-1);
  }
#line 260
  if (*((unsigned long *)pb) < *((unsigned long *)pa)) {
#line 260
    return (1);
  }
#line 261
  return (0);
}
}
#line 271 "db-gdbm.c"
void db_init_once(void) 
{ 

  {
#line 272
  pthread_rwlock_init((pthread_rwlock_t * __restrict  )(& db_rwlock), (pthread_rwlockattr_t const   * __restrict  )((void *)0));
#line 273
  return;
}
}
#line 280 "db-gdbm.c"
int db_open(char *parameters , int reload ) 
{ char db_path[4097] ;
  datum tmp_key ;
  datum tmp_value ;
  int current_db_version ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 285
  tmp = pthread_once(& db_initlock, & db_init_once);
#line 285
  if (tmp) {
#line 286
    return (-1);
  }
#line 288
  snprintf((char * __restrict  )(db_path), sizeof(db_path), (char const   * __restrict  )"%s/%s",
           parameters, "songs.gdb");
#line 290
  if (reload) {
#line 290
    reload = 3;
  } else {
#line 290
    reload = 2;
  }
#line 292
  db_gdbmlock();
#line 293
  db_songs = gdbm_open(db_path, 0, (reload | 32) | 64, 384, (void (*)())((void *)0));
#line 296
  if (reload == 2) {
#line 296
    if (db_songs) {
#line 298
      tmp_key = gdbm_firstkey(db_songs);
#line 299
      if (tmp_key.dptr) {
#line 300
        tmp_value = gdbm_fetch(db_songs, tmp_key);
#line 301
        if (tmp_value.dptr) {
#line 302
          current_db_version = *((int *)tmp_value.dptr);
#line 303
          if (current_db_version != 8) {
#line 304
            err_log(1, 4U, (char *)"Database version changed... updating database\n");
#line 305
            gdbm_close(db_songs);
#line 306
            db_songs = gdbm_open(db_path, 0, 99, 384, (void (*)())((void *)0));
          } else {
#line 308
            err_log(1, 4U, (char *)"Current database version: %d\n", 8);
          }
#line 310
          free((void *)tmp_value.dptr);
        }
#line 312
        free((void *)tmp_key.dptr);
      }
    }
  }
#line 316
  db_gdbmunlock();
#line 318
  if (! db_songs) {
#line 319
    tmp___0 = __errno_location();
#line 319
    tmp___1 = strerror(*tmp___0);
#line 319
    err_log(0, 4U, (char *)"Could not open songs database (%s): %s\n", db_path, tmp___1);
#line 321
    return (-1);
  }
#line 324
  return (0);
}
}
#line 334 "db-gdbm.c"
int db_init(void) 
{ MP3FILE mp3file ;
  datum tmp_key ;
  datum tmp_nextkey ;
  datum song_data ;
  int tmp ;

  {
#line 338
  pl_register();
#line 340
  db_version_no = 1;
#line 341
  db_song_count = 0;
#line 343
  err_log(9, 132U, (char *)"Building playlists\n");
#line 346
  db_gdbmlock();
#line 347
  tmp_key = gdbm_firstkey(db_songs);
#line 348
  db_gdbmunlock();
#line 352
  while (tmp_key.dptr) {
#line 354
    db_gdbmlock();
#line 355
    song_data = gdbm_fetch(db_songs, tmp_key);
#line 356
    db_gdbmunlock();
#line 359
    if (song_data.dptr) {
#line 360
      tmp = db_unpackrecord(& song_data, & mp3file);
#line 360
      if (! tmp) {
#line 362
        pl_eval(& mp3file);
#line 363
        db_dispose(& mp3file);
      }
#line 365
      free((void *)song_data.dptr);
    }
#line 368
    db_gdbmlock();
#line 369
    tmp_nextkey = gdbm_nextkey(db_songs, tmp_key);
#line 370
    db_gdbmunlock();
#line 373
    free((void *)tmp_key.dptr);
#line 374
    tmp_key = tmp_nextkey;
#line 375
    db_song_count ++;
  }
#line 378
  err_log(9, 4U, (char *)"Loaded database... found %d songs\n", db_song_count);
#line 381
  return (0);
}
}
#line 389 "db-gdbm.c"
int db_deinit(void) 
{ DB_PLAYLIST *plist ;
  DB_PLAYLISTENTRY *pentry ;

  {
#line 393
  db_gdbmlock();
#line 394
  gdbm_close(db_songs);
#line 395
  db_gdbmunlock();
#line 397
  while (db_playlists.next) {
#line 398
    plist = db_playlists.next;
#line 399
    db_playlists.next = plist->next;
#line 400
    free((void *)plist->name);
#line 402
    while (plist->nodes) {
#line 403
      pentry = plist->nodes;
#line 404
      plist->nodes = pentry->next;
#line 405
      free((void *)pentry);
    }
#line 407
    free((void *)plist);
  }
#line 410
  return (0);
}
}
#line 418 "db-gdbm.c"
int db_scanning(void) 
{ 

  {
#line 419
  return (db_update_mode);
}
}
#line 427 "db-gdbm.c"
int db_version(void) 
{ int version ;

  {
#line 430
  db_readlock();
#line 431
  version = db_version_no;
#line 432
  db_unlock();
#line 434
  return (version);
}
}
#line 442 "db-gdbm.c"
int db_start_initial_update(void) 
{ datum tmp_key ;
  datum tmp_nextkey ;
  DB_PLAYLIST *current ;
  int *tmp ;
  int *tmp___0 ;
  void const   *tmp___1 ;

  {
#line 448
  db_writelock();
#line 450
  db_removed = rbinit(& db_compare_rb_nodes, (void const   *)((void *)0));
#line 450
  if ((unsigned int )db_removed == (unsigned int )((void *)0)) {
#line 451
    tmp = __errno_location();
#line 451
    *tmp = 12;
#line 452
    db_unlock();
#line 453
    return (-1);
  }
#line 458
  db_gdbmlock();
#line 459
  tmp_key = gdbm_firstkey(db_songs);
#line 460
  db_gdbmunlock();
#line 464
  while (tmp_key.dptr) {
#line 466
    tmp___1 = rbsearch((void const   *)((void *)tmp_key.dptr), db_removed);
#line 466
    if (! tmp___1) {
#line 467
      tmp___0 = __errno_location();
#line 467
      *tmp___0 = 12;
#line 468
      db_unlock();
#line 469
      return (-1);
    }
#line 472
    db_gdbmlock();
#line 473
    tmp_nextkey = gdbm_nextkey(db_songs, tmp_key);
#line 474
    db_gdbmunlock();
#line 478
    tmp_key = tmp_nextkey;
  }
#line 483
  current = db_playlists.next;
#line 484
  while (current) {
#line 485
    current->found = 0;
#line 486
    current = current->next;
  }
#line 489
  db_update_mode = 1;
#line 490
  db_unlock();
#line 492
  return (0);
}
}
#line 500 "db-gdbm.c"
int db_end_initial_update(void) 
{ void const   *val ;
  unsigned long oldval ;
  unsigned long *oldptr ;
  DB_PLAYLIST *current ;
  DB_PLAYLIST *last ;
  DB_PLAYLISTENTRY *pple ;
  void const   *tmp ;

  {
#line 508
  err_log(9, 12U, (char *)"Initial update over.  Removing stale items\n");
#line 509
  val = rblookup(7, (void const   *)((void *)0), db_removed);
#line 511
  while (val) {
#line 512
    oldval = (unsigned long )*((int *)val);
#line 513
    tmp = rbdelete((void const   *)((void *)(& oldval)), db_removed);
#line 513
    oldptr = (unsigned long *)tmp;
#line 514
    if (oldptr) {
#line 515
      free((void *)oldptr);
    }
#line 516
    db_delete(oldval);
#line 518
    val = rblookup(7, (void const   *)((void *)0), db_removed);
  }
#line 521
  err_log(9, 12U, (char *)"Done removing stale items\n");
#line 523
  rbdestroy(db_removed);
#line 525
  err_log(9, 4U, (char *)"Reorganizing db\n");
#line 527
  db_writelock();
#line 528
  db_gdbmlock();
#line 529
  gdbm_reorganize(db_songs);
#line 530
  gdbm_sync(db_songs);
#line 531
  err_log(9, 4U, (char *)"Reorganize done\n");
#line 534
  err_log(9, 132U, (char *)"Finding deleted static playlists\n");
#line 536
  current = db_playlists.next;
#line 537
  last = & db_playlists;
#line 539
  while (current) {
#line 540
    if (! current->found) {
#line 540
      if (! current->is_smart) {
#line 541
        err_log(9, 132U, (char *)"Deleting playlist %s\n", current->name);
#line 542
        last->next = current->next;
#line 543
        if (current->nodes) {
#line 544
          db_playlist_count --;
        }
#line 545
        db_version_no ++;
#line 547
        while (current->nodes) {
#line 548
          pple = current->nodes;
#line 549
          current->nodes = pple->next;
#line 550
          free((void *)pple);
        }
#line 553
        if (current->name) {
#line 554
          free((void *)current->name);
        }
#line 555
        free((void *)current);
#line 557
        current = last;
      }
    }
#line 559
    current = current->next;
  }
#line 562
  db_update_mode = 0;
#line 563
  db_gdbmunlock();
#line 564
  db_unlock();
#line 566
  return (0);
}
}
#line 576 "db-gdbm.c"
int db_is_empty(void) 
{ 

  {
#line 577
  return (! db_song_count);
}
}
#line 588 "db-gdbm.c"
static DB_PLAYLIST *db_playlist_find(unsigned long playlistid ) 
{ DB_PLAYLIST *current ;

  {
#line 591
  current = db_playlists.next;
#line 592
  while (1) {
#line 592
    if (current) {
#line 592
      if (! (current->id != playlistid)) {
#line 592
        break;
      }
    } else {
#line 592
      break;
    }
#line 593
    current = current->next;
  }
#line 595
  if (! current) {
#line 596
    return ((DB_PLAYLIST *)((void *)0));
  }
#line 599
  return (current);
}
}
#line 607 "db-gdbm.c"
int db_delete_playlist(unsigned long playlistid ) 
{ DB_PLAYLISTENTRY *pple ;
  DB_PLAYLIST *last ;
  DB_PLAYLIST *current ;

  {
#line 612
  err_log(9, 128U, (char *)"Deleting playlist %ld\n", playlistid);
#line 614
  db_writelock();
#line 616
  current = db_playlists.next;
#line 617
  last = & db_playlists;
#line 619
  while (1) {
#line 619
    if (current) {
#line 619
      if (! (current->id != playlistid)) {
#line 619
        break;
      }
    } else {
#line 619
      break;
    }
#line 620
    last = current;
#line 621
    current = current->next;
  }
#line 624
  if (! current) {
#line 625
    db_unlock();
#line 626
    return (-1);
  }
#line 629
  last->next = current->next;
#line 631
  if (current->nodes) {
#line 632
    db_playlist_count --;
  }
#line 634
  db_version_no ++;
#line 636
  db_unlock();
#line 638
  while (current->nodes) {
#line 639
    pple = current->nodes;
#line 640
    current->nodes = pple->next;
#line 641
    free((void *)pple);
  }
#line 644
  if (current->name) {
#line 645
    free((void *)current->name);
  }
#line 647
  free((void *)current);
#line 648
  return (0);
}
}
#line 657 "db-gdbm.c"
int db_playlist_last_modified(unsigned long playlistid ) 
{ DB_PLAYLIST *plist ;
  int file_time ;

  {
#line 661
  db_readlock();
#line 662
  plist = db_playlist_find(playlistid);
#line 663
  if (! plist) {
#line 664
    db_unlock();
#line 665
    return (0);
  }
#line 668
  file_time = plist->file_time;
#line 671
  plist->found = 1;
#line 672
  db_unlock();
#line 673
  return (file_time);
}
}
#line 681 "db-gdbm.c"
int db_add_playlist(unsigned long playlistid , char *name , int file_time , int is_smart ) 
{ DB_PLAYLIST *pnew ;
  void *tmp ;

  {
#line 685
  tmp = malloc(sizeof(DB_PLAYLIST ));
#line 685
  pnew = (DB_PLAYLIST *)tmp;
#line 686
  if (! pnew) {
#line 687
    return (-1);
  }
#line 689
  pnew->name = strdup((char const   *)name);
#line 690
  pnew->id = playlistid;
#line 691
  pnew->nodes = (struct tag_playlistentry *)((void *)0);
#line 692
  pnew->last_node = (struct tag_playlistentry *)((void *)0);
#line 693
  pnew->songs = 0;
#line 694
  pnew->found = 1;
#line 695
  pnew->file_time = file_time;
#line 696
  pnew->is_smart = is_smart;
#line 698
  if (! pnew->name) {
#line 699
    free((void *)pnew);
#line 700
    return (-1);
  }
#line 703
  err_log(9, 132U, (char *)"Adding new playlist %s\n", name);
#line 705
  db_writelock();
#line 707
  pnew->next = db_playlists.next;
#line 708
  db_playlists.next = pnew;
#line 710
  db_version_no ++;
#line 712
  err_log(9, 132U, (char *)"Added playlist\n");
#line 713
  db_unlock();
#line 714
  return (0);
}
}
#line 725 "db-gdbm.c"
int db_add_playlist_song(unsigned long playlistid , unsigned long itemid ) 
{ DB_PLAYLIST *current ;
  DB_PLAYLISTENTRY *pnew ;
  void *tmp ;

  {
#line 730
  tmp = malloc(sizeof(DB_PLAYLISTENTRY ));
#line 730
  pnew = (DB_PLAYLISTENTRY *)tmp;
#line 731
  if (! pnew) {
#line 732
    return (-1);
  }
#line 734
  pnew->id = itemid;
#line 735
  pnew->next = (struct tag_playlistentry *)((void *)0);
#line 737
  err_log(9, 132U, (char *)"Adding item %ld to %ld\n", itemid, playlistid);
#line 739
  db_writelock();
#line 741
  current = db_playlists.next;
#line 742
  while (1) {
#line 742
    if (current) {
#line 742
      if (! (current->id != playlistid)) {
#line 742
        break;
      }
    } else {
#line 742
      break;
    }
#line 743
    current = current->next;
  }
#line 745
  if (! current) {
#line 746
    err_log(2, 132U, (char *)"Could not find playlist attempting to add to\n");
#line 747
    db_unlock();
#line 748
    free((void *)pnew);
#line 749
    return (-1);
  }
#line 752
  if (! current->songs) {
#line 753
    db_playlist_count ++;
  }
#line 755
  (current->songs) ++;
#line 756
  err_log(9, 132U, (char *)"Playlist now has %d entries\n", current->songs);
#line 758
  if (current->last_node) {
#line 759
    (current->last_node)->next = pnew;
  } else {
#line 761
    current->nodes = pnew;
  }
#line 763
  current->last_node = pnew;
#line 765
  db_version_no ++;
#line 767
  err_log(9, 132U, (char *)"Added playlist item\n");
#line 769
  db_unlock();
#line 770
  return (0);
}
}
#line 778 "db-gdbm.c"
datum *db_packrecord(MP3FILE *pmp3 ) 
{ int len ;
  datum *result ;
  MP3PACKED *ppacked ;
  int offset ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;
  size_t tmp___31 ;
  size_t tmp___32 ;
  size_t tmp___33 ;
  size_t tmp___34 ;
  size_t tmp___35 ;
  size_t tmp___36 ;
  size_t tmp___37 ;
  size_t tmp___38 ;
  size_t tmp___39 ;

  {
#line 784
  len = (int )sizeof(MP3PACKED );
#line 785
  if (pmp3->path) {
#line 785
    tmp = strlen((char const   *)pmp3->path);
#line 785
    tmp___0 = tmp + 1U;
  } else {
#line 785
    tmp___0 = 1U;
  }
#line 785
  len = (int )((size_t )len + tmp___0);
#line 786
  if (pmp3->fname) {
#line 786
    tmp___1 = strlen((char const   *)pmp3->fname);
#line 786
    tmp___2 = tmp___1 + 1U;
  } else {
#line 786
    tmp___2 = 1U;
  }
#line 786
  len = (int )((size_t )len + tmp___2);
#line 787
  if (pmp3->title) {
#line 787
    tmp___3 = strlen((char const   *)pmp3->title);
#line 787
    tmp___4 = tmp___3 + 1U;
  } else {
#line 787
    tmp___4 = 1U;
  }
#line 787
  len = (int )((size_t )len + tmp___4);
#line 788
  if (pmp3->artist) {
#line 788
    tmp___5 = strlen((char const   *)pmp3->artist);
#line 788
    tmp___6 = tmp___5 + 1U;
  } else {
#line 788
    tmp___6 = 1U;
  }
#line 788
  len = (int )((size_t )len + tmp___6);
#line 789
  if (pmp3->album) {
#line 789
    tmp___7 = strlen((char const   *)pmp3->album);
#line 789
    tmp___8 = tmp___7 + 1U;
  } else {
#line 789
    tmp___8 = 1U;
  }
#line 789
  len = (int )((size_t )len + tmp___8);
#line 790
  if (pmp3->genre) {
#line 790
    tmp___9 = strlen((char const   *)pmp3->genre);
#line 790
    tmp___10 = tmp___9 + 1U;
  } else {
#line 790
    tmp___10 = 1U;
  }
#line 790
  len = (int )((size_t )len + tmp___10);
#line 791
  if (pmp3->comment) {
#line 791
    tmp___11 = strlen((char const   *)pmp3->comment);
#line 791
    tmp___12 = tmp___11 + 1U;
  } else {
#line 791
    tmp___12 = 1U;
  }
#line 791
  len = (int )((size_t )len + tmp___12);
#line 792
  if (pmp3->type) {
#line 792
    tmp___13 = strlen((char const   *)pmp3->type);
#line 792
    tmp___14 = tmp___13 + 1U;
  } else {
#line 792
    tmp___14 = 1U;
  }
#line 792
  len = (int )((size_t )len + tmp___14);
#line 793
  if (pmp3->composer) {
#line 793
    tmp___15 = strlen((char const   *)pmp3->composer);
#line 793
    tmp___16 = tmp___15 + 1U;
  } else {
#line 793
    tmp___16 = 1U;
  }
#line 793
  len = (int )((size_t )len + tmp___16);
#line 794
  if (pmp3->orchestra) {
#line 794
    tmp___17 = strlen((char const   *)pmp3->orchestra);
#line 794
    tmp___18 = tmp___17 + 1U;
  } else {
#line 794
    tmp___18 = 1U;
  }
#line 794
  len = (int )((size_t )len + tmp___18);
#line 795
  if (pmp3->conductor) {
#line 795
    tmp___19 = strlen((char const   *)pmp3->conductor);
#line 795
    tmp___20 = tmp___19 + 1U;
  } else {
#line 795
    tmp___20 = 1U;
  }
#line 795
  len = (int )((size_t )len + tmp___20);
#line 796
  if (pmp3->grouping) {
#line 796
    tmp___21 = strlen((char const   *)pmp3->grouping);
#line 796
    tmp___22 = tmp___21 + 1U;
  } else {
#line 796
    tmp___22 = 1U;
  }
#line 796
  len = (int )((size_t )len + tmp___22);
#line 797
  if (pmp3->url) {
#line 797
    tmp___23 = strlen((char const   *)pmp3->url);
#line 797
    tmp___24 = tmp___23 + 1U;
  } else {
#line 797
    tmp___24 = 1U;
  }
#line 797
  len = (int )((size_t )len + tmp___24);
#line 799
  tmp___25 = malloc(sizeof(datum ));
#line 799
  result = (datum *)tmp___25;
#line 800
  if (! result) {
#line 801
    return ((datum *)((void *)0));
  }
#line 803
  tmp___26 = malloc((unsigned int )len);
#line 803
  result->dptr = (char *)tmp___26;
#line 804
  result->dsize = len;
#line 806
  if (! result->dptr) {
#line 807
    free((void *)result);
#line 808
    return ((datum *)((void *)0));
  }
#line 811
  memset((void *)result->dptr, 0, (unsigned int )len);
#line 814
  ppacked = (MP3PACKED *)result->dptr;
#line 816
  ppacked->version = 8;
#line 817
  ppacked->struct_size = (int )sizeof(MP3PACKED );
#line 819
  ppacked->bitrate = pmp3->bitrate;
#line 820
  ppacked->samplerate = pmp3->samplerate;
#line 821
  ppacked->song_length = pmp3->song_length;
#line 822
  ppacked->file_size = pmp3->file_size;
#line 823
  ppacked->year = pmp3->year;
#line 824
  ppacked->track = pmp3->track;
#line 825
  ppacked->total_tracks = pmp3->total_tracks;
#line 826
  ppacked->disc = pmp3->disc;
#line 827
  ppacked->total_discs = pmp3->total_discs;
#line 828
  ppacked->time_added = pmp3->time_added;
#line 829
  ppacked->time_modified = pmp3->time_modified;
#line 830
  ppacked->time_played = pmp3->time_played;
#line 831
  ppacked->db_timestamp = pmp3->db_timestamp;
#line 832
  ppacked->bpm = pmp3->bpm;
#line 833
  ppacked->compilation = pmp3->compilation;
#line 834
  ppacked->id = pmp3->id;
#line 836
  if (pmp3->path) {
#line 836
    tmp___27 = strlen((char const   *)pmp3->path);
#line 836
    ppacked->path_len = (int )(tmp___27 + 1U);
  } else {
#line 836
    ppacked->path_len = 1;
  }
#line 837
  if (pmp3->fname) {
#line 837
    tmp___28 = strlen((char const   *)pmp3->fname);
#line 837
    ppacked->fname_len = (int )(tmp___28 + 1U);
  } else {
#line 837
    ppacked->fname_len = 1;
  }
#line 838
  if (pmp3->title) {
#line 838
    tmp___29 = strlen((char const   *)pmp3->title);
#line 838
    ppacked->title_len = (int )(tmp___29 + 1U);
  } else {
#line 838
    ppacked->title_len = 1;
  }
#line 839
  if (pmp3->artist) {
#line 839
    tmp___30 = strlen((char const   *)pmp3->artist);
#line 839
    ppacked->artist_len = (int )(tmp___30 + 1U);
  } else {
#line 839
    ppacked->artist_len = 1;
  }
#line 840
  if (pmp3->album) {
#line 840
    tmp___31 = strlen((char const   *)pmp3->album);
#line 840
    ppacked->album_len = (int )(tmp___31 + 1U);
  } else {
#line 840
    ppacked->album_len = 1;
  }
#line 841
  if (pmp3->genre) {
#line 841
    tmp___32 = strlen((char const   *)pmp3->genre);
#line 841
    ppacked->genre_len = (int )(tmp___32 + 1U);
  } else {
#line 841
    ppacked->genre_len = 1;
  }
#line 842
  if (pmp3->comment) {
#line 842
    tmp___33 = strlen((char const   *)pmp3->comment);
#line 842
    ppacked->comment_len = (int )(tmp___33 + 1U);
  } else {
#line 842
    ppacked->comment_len = 1;
  }
#line 843
  if (pmp3->type) {
#line 843
    tmp___34 = strlen((char const   *)pmp3->type);
#line 843
    ppacked->type_len = (int )(tmp___34 + 1U);
  } else {
#line 843
    ppacked->type_len = 1;
  }
#line 844
  if (pmp3->composer) {
#line 844
    tmp___35 = strlen((char const   *)pmp3->composer);
#line 844
    ppacked->composer_len = (int )(tmp___35 + 1U);
  } else {
#line 844
    ppacked->composer_len = 1;
  }
#line 845
  if (pmp3->orchestra) {
#line 845
    tmp___36 = strlen((char const   *)pmp3->orchestra);
#line 845
    ppacked->orchestra_len = (int )(tmp___36 + 1U);
  } else {
#line 845
    ppacked->orchestra_len = 1;
  }
#line 846
  if (pmp3->conductor) {
#line 846
    tmp___37 = strlen((char const   *)pmp3->conductor);
#line 846
    ppacked->conductor_len = (int )(tmp___37 + 1U);
  } else {
#line 846
    ppacked->conductor_len = 1;
  }
#line 847
  if (pmp3->grouping) {
#line 847
    tmp___38 = strlen((char const   *)pmp3->grouping);
#line 847
    ppacked->grouping_len = (int )(tmp___38 + 1U);
  } else {
#line 847
    ppacked->grouping_len = 1;
  }
#line 848
  if (pmp3->url) {
#line 848
    tmp___39 = strlen((char const   *)pmp3->url);
#line 848
    ppacked->url_len = (int )(tmp___39 + 1U);
  } else {
#line 848
    ppacked->url_len = 1;
  }
#line 850
  offset = 0;
#line 851
  if (pmp3->path) {
#line 852
    memcpy((void * __restrict  )(& ppacked->data[offset]), (void const   * __restrict  )pmp3->path,
           (unsigned int )ppacked->path_len);
  }
#line 853
  offset += ppacked->path_len;
#line 855
  if (pmp3->fname) {
#line 856
    memcpy((void * __restrict  )(& ppacked->data[offset]), (void const   * __restrict  )pmp3->fname,
           (unsigned int )ppacked->fname_len);
  }
#line 857
  offset += ppacked->fname_len;
#line 859
  if (pmp3->title) {
#line 860
    memcpy((void * __restrict  )(& ppacked->data[offset]), (void const   * __restrict  )pmp3->title,
           (unsigned int )ppacked->title_len);
  }
#line 861
  offset += ppacked->title_len;
#line 863
  if (pmp3->artist) {
#line 864
    memcpy((void * __restrict  )(& ppacked->data[offset]), (void const   * __restrict  )pmp3->artist,
           (unsigned int )ppacked->artist_len);
  }
#line 865
  offset += ppacked->artist_len;
#line 867
  if (pmp3->album) {
#line 868
    memcpy((void * __restrict  )(& ppacked->data[offset]), (void const   * __restrict  )pmp3->album,
           (unsigned int )ppacked->album_len);
  }
#line 869
  offset += ppacked->album_len;
#line 871
  if (pmp3->genre) {
#line 872
    memcpy((void * __restrict  )(& ppacked->data[offset]), (void const   * __restrict  )pmp3->genre,
           (unsigned int )ppacked->genre_len);
  }
#line 873
  offset += ppacked->genre_len;
#line 875
  if (pmp3->comment) {
#line 876
    memcpy((void * __restrict  )(& ppacked->data[offset]), (void const   * __restrict  )pmp3->comment,
           (unsigned int )ppacked->comment_len);
  }
#line 877
  offset += ppacked->comment_len;
#line 879
  if (pmp3->type) {
#line 880
    memcpy((void * __restrict  )(& ppacked->data[offset]), (void const   * __restrict  )pmp3->type,
           (unsigned int )ppacked->type_len);
  }
#line 881
  offset += ppacked->type_len;
#line 883
  if (pmp3->composer) {
#line 884
    memcpy((void * __restrict  )(& ppacked->data[offset]), (void const   * __restrict  )pmp3->composer,
           (unsigned int )ppacked->composer_len);
  }
#line 885
  offset += ppacked->composer_len;
#line 887
  if (pmp3->orchestra) {
#line 888
    memcpy((void * __restrict  )(& ppacked->data[offset]), (void const   * __restrict  )pmp3->orchestra,
           (unsigned int )ppacked->orchestra_len);
  }
#line 889
  offset += ppacked->orchestra_len;
#line 891
  if (pmp3->conductor) {
#line 892
    memcpy((void * __restrict  )(& ppacked->data[offset]), (void const   * __restrict  )pmp3->conductor,
           (unsigned int )ppacked->conductor_len);
  }
#line 893
  offset += ppacked->conductor_len;
#line 895
  if (pmp3->grouping) {
#line 896
    memcpy((void * __restrict  )(& ppacked->data[offset]), (void const   * __restrict  )pmp3->grouping,
           (unsigned int )ppacked->grouping_len);
  }
#line 897
  offset += ppacked->grouping_len;
#line 899
  if (pmp3->url) {
#line 900
    memcpy((void * __restrict  )(& ppacked->data[offset]), (void const   * __restrict  )pmp3->url,
           (unsigned int )ppacked->url_len);
  }
#line 901
  offset += ppacked->url_len;
#line 905
  return (result);
}
}
#line 914 "db-gdbm.c"
int db_unpackrecord(datum *pdatum , MP3FILE *pmp3 ) 
{ MP3PACKED *ppacked ;
  int offset ;

  {
#line 920
  memset((void *)pmp3, 0, sizeof(MP3FILE ));
#line 923
  ppacked = (MP3PACKED *)pdatum->dptr;
#line 925
  if (ppacked->version != 8) {
#line 926
    err_log(0, 4U, (char *)"ON-DISK DATABASE VERSION HAS CHANGED\nDelete your songs.gdb and restart.\n");
  }
#line 929
  pmp3->bitrate = ppacked->bitrate;
#line 930
  pmp3->samplerate = ppacked->samplerate;
#line 931
  pmp3->song_length = ppacked->song_length;
#line 932
  pmp3->file_size = ppacked->file_size;
#line 933
  pmp3->year = ppacked->year;
#line 934
  pmp3->track = ppacked->track;
#line 935
  pmp3->total_tracks = ppacked->total_tracks;
#line 936
  pmp3->disc = ppacked->disc;
#line 937
  pmp3->total_discs = ppacked->total_discs;
#line 938
  pmp3->time_added = ppacked->time_added;
#line 939
  pmp3->time_modified = ppacked->time_modified;
#line 940
  pmp3->db_timestamp = ppacked->db_timestamp;
#line 941
  pmp3->time_played = ppacked->time_played;
#line 942
  pmp3->bpm = ppacked->bpm;
#line 943
  pmp3->compilation = ppacked->compilation;
#line 944
  pmp3->id = ppacked->id;
#line 946
  offset = 0;
#line 947
  if (ppacked->path_len > 1) {
#line 948
    pmp3->path = strdup((char const   *)(& ppacked->data[offset]));
  }
#line 949
  offset += ppacked->path_len;
#line 951
  if (ppacked->fname_len > 1) {
#line 952
    pmp3->fname = strdup((char const   *)(& ppacked->data[offset]));
  }
#line 953
  offset += ppacked->fname_len;
#line 955
  if (ppacked->title_len > 1) {
#line 956
    pmp3->title = strdup((char const   *)(& ppacked->data[offset]));
  }
#line 957
  offset += ppacked->title_len;
#line 959
  if (ppacked->artist_len > 1) {
#line 960
    pmp3->artist = strdup((char const   *)(& ppacked->data[offset]));
  }
#line 961
  offset += ppacked->artist_len;
#line 963
  if (ppacked->album_len > 1) {
#line 964
    pmp3->album = strdup((char const   *)(& ppacked->data[offset]));
  }
#line 965
  offset += ppacked->album_len;
#line 967
  if (ppacked->genre_len > 1) {
#line 968
    pmp3->genre = strdup((char const   *)(& ppacked->data[offset]));
  }
#line 969
  offset += ppacked->genre_len;
#line 971
  if (ppacked->comment_len > 1) {
#line 972
    pmp3->comment = strdup((char const   *)(& ppacked->data[offset]));
  }
#line 973
  offset += ppacked->comment_len;
#line 975
  if (ppacked->type_len > 1) {
#line 976
    pmp3->type = strdup((char const   *)(& ppacked->data[offset]));
  }
#line 977
  offset += ppacked->type_len;
#line 979
  if (ppacked->composer_len > 1) {
#line 980
    pmp3->composer = strdup((char const   *)(& ppacked->data[offset]));
  }
#line 981
  offset += ppacked->composer_len;
#line 983
  if (ppacked->orchestra_len > 1) {
#line 984
    pmp3->orchestra = strdup((char const   *)(& ppacked->data[offset]));
  }
#line 985
  offset += ppacked->orchestra_len;
#line 987
  if (ppacked->conductor_len > 1) {
#line 988
    pmp3->conductor = strdup((char const   *)(& ppacked->data[offset]));
  }
#line 989
  offset += ppacked->conductor_len;
#line 991
  if (ppacked->grouping_len > 1) {
#line 992
    pmp3->grouping = strdup((char const   *)(& ppacked->data[offset]));
  }
#line 993
  offset += ppacked->grouping_len;
#line 995
  if (ppacked->url_len > 1) {
#line 996
    pmp3->url = strdup((char const   *)(& ppacked->data[offset]));
  }
#line 997
  offset += ppacked->url_len;
#line 1000
  make_composite_tags(pmp3);
#line 1002
  return (0);
}
}
#line 1015 "db-gdbm.c"
int db_add(MP3FILE *pmp3 ) 
{ datum *pnew ;
  datum dkey ;
  MP3PACKED *ppacked ;
  int new ;
  int *tmp ;
  int tmp___0 ;
  time_t tmp___1 ;
  time_t tmp___2 ;
  time_t tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;

  {
#line 1021
  new = 1;
#line 1023
  err_log(9, 4U, (char *)"Adding %s\n", pmp3->path);
#line 1025
  pnew = db_packrecord(pmp3);
#line 1025
  if (! pnew) {
#line 1026
    tmp = __errno_location();
#line 1026
    *tmp = 12;
#line 1027
    return (-1);
  }
#line 1031
  dkey.dptr = (char *)((void *)(& pmp3->id));
#line 1032
  dkey.dsize = (int )sizeof(unsigned long );
#line 1034
  db_gdbmlock();
#line 1035
  tmp___0 = gdbm_exists(db_songs, dkey);
#line 1035
  if (tmp___0) {
#line 1036
    new = 0;
#line 1037
    err_log(9, 4U, (char *)"this is an update, not an add\n");
  }
#line 1039
  db_gdbmunlock();
#line 1042
  ppacked = (MP3PACKED *)pnew->dptr;
#line 1043
  if (! ppacked->time_added) {
#line 1044
    tmp___1 = time((time_t *)((void *)0));
#line 1044
    ppacked->time_added = (int )tmp___1;
  }
#line 1045
  if (! ppacked->time_modified) {
#line 1046
    tmp___2 = time((time_t *)((void *)0));
#line 1046
    ppacked->time_modified = (int )tmp___2;
  }
#line 1047
  tmp___3 = time((time_t *)((void *)0));
#line 1047
  ppacked->db_timestamp = (int )tmp___3;
#line 1048
  ppacked->time_played = 0;
#line 1050
  db_writelock();
#line 1052
  db_gdbmlock();
#line 1053
  tmp___4 = gdbm_store(db_songs, dkey, *pnew, 1);
#line 1053
  if (tmp___4) {
#line 1054
    db_gdbmunlock();
#line 1055
    err_log(0, 4U, (char *)"Error inserting file %s in database\n", pmp3->fname);
  }
#line 1057
  db_gdbmunlock();
#line 1059
  free((void *)pnew->dptr);
#line 1060
  free((void *)pnew);
#line 1062
  db_version_no ++;
#line 1064
  if (new) {
#line 1065
    db_song_count ++;
  }
#line 1067
  if (new) {
#line 1067
    tmp___5 = "Added";
  } else {
#line 1067
    tmp___5 = "Updated";
  }
#line 1067
  err_log(9, 4U, (char *)"%s file\n", tmp___5);
#line 1069
  db_unlock();
#line 1070
  return (0);
}
}
#line 1078 "db-gdbm.c"
void db_dispose(MP3FILE *pmp3 ) 
{ 

  {
#line 1079
  if (pmp3->path) {
#line 1079
    free((void *)pmp3->path);
  }
#line 1080
  if (pmp3->fname) {
#line 1080
    free((void *)pmp3->fname);
  }
#line 1081
  if (pmp3->title) {
#line 1081
    free((void *)pmp3->title);
  }
#line 1082
  if (pmp3->artist) {
#line 1082
    free((void *)pmp3->artist);
  }
#line 1083
  if (pmp3->album) {
#line 1083
    free((void *)pmp3->album);
  }
#line 1084
  if (pmp3->genre) {
#line 1084
    free((void *)pmp3->genre);
  }
#line 1085
  if (pmp3->comment) {
#line 1085
    free((void *)pmp3->comment);
  }
#line 1086
  if (pmp3->type) {
#line 1086
    free((void *)pmp3->type);
  }
#line 1087
  if (pmp3->composer) {
#line 1087
    free((void *)pmp3->composer);
  }
#line 1088
  if (pmp3->orchestra) {
#line 1088
    free((void *)pmp3->orchestra);
  }
#line 1089
  if (pmp3->conductor) {
#line 1089
    free((void *)pmp3->conductor);
  }
#line 1090
  if (pmp3->grouping) {
#line 1090
    free((void *)pmp3->grouping);
  }
#line 1091
  if (pmp3->description) {
#line 1091
    free((void *)pmp3->description);
  }
#line 1092
  if (pmp3->url) {
#line 1092
    free((void *)pmp3->url);
  }
#line 1093
  return;
}
}
#line 1095 "db-gdbm.c"
static int nullstrcmp(char const   *a , char const   *b ) 
{ int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1097
  if ((unsigned int )a == (unsigned int )((char const   *)0)) {
#line 1098
    if ((unsigned int )b == (unsigned int )((char const   *)0)) {
#line 1098
      tmp = 1;
    } else {
#line 1098
      tmp = 0;
    }
#line 1098
    return (tmp);
  }
#line 1099
  if ((unsigned int )b == (unsigned int )((char const   *)0)) {
#line 1100
    return (-1);
  }
#line 1102
  if (0) {
#line 1102
    __s1_len = strlen(a);
#line 1102
    __s2_len = strlen(b);
#line 1102
    if (! ((unsigned int )((void const   *)(a + 1)) - (unsigned int )((void const   *)a) == 1U)) {
      goto _L___0;
    } else {
#line 1102
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1102
        if (! ((unsigned int )((void const   *)(b + 1)) - (unsigned int )((void const   *)b) == 1U)) {
#line 1102
          tmp___6 = 1;
        } else {
#line 1102
          if (__s2_len >= 4U) {
#line 1102
            tmp___6 = 1;
          } else {
#line 1102
            tmp___6 = 0;
          }
        }
      } else {
#line 1102
        tmp___6 = 0;
      }
    }
#line 1102
    if (tmp___6) {
#line 1102
      tmp___1 = __builtin_strcmp(a, b);
#line 1102
      tmp___5 = tmp___1;
    } else {
#line 1102
      tmp___4 = __builtin_strcmp(a, b);
#line 1102
      tmp___5 = tmp___4;
    }
  } else {
#line 1102
    tmp___4 = __builtin_strcmp(a, b);
#line 1102
    tmp___5 = tmp___4;
  }
#line 1102
  return (tmp___5);
}
}
#line 1105 "db-gdbm.c"
int compare(MP3RECORD *a , MP3RECORD *b ) 
{ int comp ;

  {
#line 1109
  comp = nullstrcmp((char const   *)a->mp3file.album, (char const   *)b->mp3file.album);
#line 1109
  if (comp != 0) {
#line 1110
    return (comp);
  }
#line 1112
  comp = a->mp3file.disc - b->mp3file.disc;
#line 1112
  if (comp != 0) {
#line 1113
    return (comp);
  }
#line 1115
  comp = a->mp3file.track - b->mp3file.track;
#line 1115
  if (comp != 0) {
#line 1116
    return (comp);
  }
#line 1118
  return ((int )(a->mp3file.id - b->mp3file.id));
}
}
#line 1236 "db-gdbm.c"
ENUMHANDLE db_enum_begin(void) 
{ datum *pkey ;
  void *tmp ;

  {
#line 1240
  tmp = malloc(sizeof(datum ));
#line 1240
  pkey = (datum *)tmp;
#line 1241
  if (! pkey) {
#line 1242
    return ((void *)0);
  }
#line 1244
  db_writelock();
#line 1246
  if (gdbm_mp3_mustfree) {
#line 1247
    db_dispose(& gdbm_mp3);
  }
#line 1249
  gdbm_mp3_mustfree = 0;
#line 1251
  db_gdbmlock();
#line 1252
  *pkey = gdbm_firstkey(db_songs);
#line 1253
  db_gdbmunlock();
#line 1254
  return ((void *)pkey);
}
}
#line 1257 "db-gdbm.c"
MP3FILE *db_enum(ENUMHANDLE *current ) 
{ datum *pkey ;
  datum next ;
  datum data ;
  int tmp ;

  {
#line 1258
  pkey = (datum *)*current;
#line 1262
  if (gdbm_mp3_mustfree) {
#line 1263
    db_dispose(& gdbm_mp3);
  }
#line 1265
  gdbm_mp3_mustfree = 0;
#line 1267
  if (pkey->dptr) {
#line 1268
    db_gdbmlock();
#line 1269
    data = gdbm_fetch(db_songs, *pkey);
#line 1270
    db_gdbmunlock();
#line 1272
    if (! data.dptr) {
#line 1273
      err_log(0, 4U, (char *)"Cannot find item.... corrupt database?\n");
    }
#line 1275
    tmp = db_unpackrecord(& data, & gdbm_mp3);
#line 1275
    if (tmp) {
#line 1276
      err_log(0, 4U, (char *)"Cannot unpack item... corrupt database?\n");
    }
#line 1277
    gdbm_mp3_mustfree = 1;
#line 1279
    free((void *)data.dptr);
#line 1281
    db_gdbmlock();
#line 1282
    next = gdbm_nextkey(db_songs, *pkey);
#line 1283
    db_gdbmunlock();
#line 1285
    free((void *)pkey->dptr);
#line 1286
    *pkey = next;
#line 1288
    return (& gdbm_mp3);
  }
#line 1291
  return ((MP3FILE *)((void *)0));
}
}
#line 1294 "db-gdbm.c"
int db_enum_end(ENUMHANDLE handle ) 
{ datum *pkey ;

  {
#line 1295
  pkey = (datum *)handle;
#line 1297
  if (gdbm_mp3_mustfree) {
#line 1298
    db_dispose(& gdbm_mp3);
  }
#line 1300
  gdbm_mp3_mustfree = 0;
#line 1302
  if (pkey->dptr) {
#line 1303
    free((void *)pkey->dptr);
  }
#line 1305
  db_unlock();
#line 1306
  free((void *)pkey);
#line 1308
  return (0);
}
}
#line 1318 "db-gdbm.c"
ENUMHANDLE db_playlist_enum_begin(void) 
{ DB_PLAYLIST *current ;

  {
#line 1322
  db_readlock();
#line 1325
  current = db_playlists.next;
#line 1326
  while (1) {
#line 1326
    if (current) {
#line 1326
      if (! (! current->songs)) {
#line 1326
        break;
      }
    } else {
#line 1326
      break;
    }
#line 1327
    current = current->next;
  }
#line 1329
  return ((void *)current);
}
}
#line 1337 "db-gdbm.c"
ENUMHANDLE db_playlist_items_enum_begin(unsigned long playlistid ) 
{ DB_PLAYLIST *current ;

  {
#line 1341
  db_readlock();
#line 1343
  current = db_playlists.next;
#line 1344
  while (1) {
#line 1344
    if (current) {
#line 1344
      if (! (current->id != playlistid)) {
#line 1344
        break;
      }
    } else {
#line 1344
      break;
    }
#line 1345
    current = current->next;
  }
#line 1347
  if (! current) {
#line 1348
    return ((void *)0);
  }
#line 1350
  return ((void *)current->nodes);
}
}
#line 1358 "db-gdbm.c"
int db_playlist_enum(ENUMHANDLE *handle ) 
{ DB_PLAYLIST **current ;
  int retval ;
  DB_PLAYLIST *p ;

  {
#line 1359
  current = (DB_PLAYLIST **)handle;
#line 1363
  if (*current) {
#line 1364
    retval = (int )(*current)->id;
#line 1365
    p = *current;
#line 1366
    p = p->next;
#line 1367
    while (1) {
#line 1367
      if (p) {
#line 1367
        if (! (! p->songs)) {
#line 1367
          break;
        }
      } else {
#line 1367
        break;
      }
#line 1368
      p = p->next;
    }
#line 1370
    *current = p;
#line 1371
    return (retval);
  }
#line 1373
  return (-1);
}
}
#line 1381 "db-gdbm.c"
int db_playlist_items_enum(ENUMHANDLE *handle ) 
{ DB_PLAYLISTENTRY **current ;
  int retval ;

  {
#line 1385
  if (! handle) {
#line 1386
    return (-1);
  }
#line 1388
  current = (DB_PLAYLISTENTRY **)handle;
#line 1390
  if (*current) {
#line 1391
    retval = (int )(*current)->id;
#line 1392
    *current = (*current)->next;
#line 1393
    return (retval);
  }
#line 1396
  return (-1);
}
}
#line 1405 "db-gdbm.c"
int db_playlist_enum_end(ENUMHANDLE handle ) 
{ int tmp ;

  {
#line 1406
  tmp = db_unlock();
#line 1406
  return (tmp);
}
}
#line 1414 "db-gdbm.c"
int db_playlist_items_enum_end(ENUMHANDLE handle ) 
{ int tmp ;

  {
#line 1415
  tmp = db_unlock();
#line 1415
  return (tmp);
}
}
#line 1424 "db-gdbm.c"
MP3FILE *db_find(unsigned long id ) 
{ MP3FILE *pmp3 ;
  datum key ;
  datum content ;
  void *tmp ;

  {
#line 1425
  pmp3 = (MP3FILE *)((void *)0);
#line 1428
  key.dptr = (char *)((void *)(& id));
#line 1429
  key.dsize = (int )sizeof(unsigned long );
#line 1431
  db_readlock();
#line 1433
  db_gdbmlock();
#line 1434
  content = gdbm_fetch(db_songs, key);
#line 1435
  db_gdbmunlock();
#line 1438
  if (! content.dptr) {
#line 1439
    err_log(9, 4U, (char *)"Could not find id %ld\n", id);
#line 1440
    db_unlock();
#line 1441
    return ((MP3FILE *)((void *)0));
  }
#line 1444
  tmp = malloc(sizeof(MP3FILE ));
#line 1444
  pmp3 = (MP3FILE *)tmp;
#line 1445
  if (! pmp3) {
#line 1446
    err_log(1, 2147483648U, (char *)"Malloc failed in db_find\n");
#line 1447
    db_unlock();
#line 1448
    return ((MP3FILE *)((void *)0));
  }
#line 1451
  db_unlock();
#line 1452
  db_unpackrecord(& content, pmp3);
#line 1453
  free((void *)content.dptr);
#line 1454
  return (pmp3);
}
}
#line 1462 "db-gdbm.c"
int db_get_playlist_count(void) 
{ int retval ;

  {
#line 1465
  db_readlock();
#line 1466
  retval = db_playlist_count;
#line 1467
  db_unlock();
#line 1468
  return (retval);
}
}
#line 1477 "db-gdbm.c"
int db_get_song_count(void) 
{ int retval ;

  {
#line 1480
  db_readlock();
#line 1481
  retval = db_song_count;
#line 1482
  db_unlock();
#line 1484
  return (retval);
}
}
#line 1493 "db-gdbm.c"
int db_get_playlist_is_smart(unsigned long playlistid ) 
{ DB_PLAYLIST *current ;
  int result ;

  {
#line 1498
  db_readlock();
#line 1500
  current = db_playlists.next;
#line 1501
  while (1) {
#line 1501
    if (current) {
#line 1501
      if (! (current->id != playlistid)) {
#line 1501
        break;
      }
    } else {
#line 1501
      break;
    }
#line 1502
    current = current->next;
  }
#line 1504
  if (! current) {
#line 1505
    result = 0;
  } else {
#line 1507
    result = current->is_smart;
  }
#line 1510
  db_unlock();
#line 1511
  return (result);
}
}
#line 1519 "db-gdbm.c"
int db_get_playlist_entry_count(unsigned long playlistid ) 
{ int count ;
  DB_PLAYLIST *current ;

  {
#line 1524
  db_readlock();
#line 1526
  current = db_playlists.next;
#line 1527
  while (1) {
#line 1527
    if (current) {
#line 1527
      if (! (current->id != playlistid)) {
#line 1527
        break;
      }
    } else {
#line 1527
      break;
    }
#line 1528
    current = current->next;
  }
#line 1530
  if (! current) {
#line 1531
    count = -1;
  } else {
#line 1533
    count = current->songs;
  }
#line 1536
  db_unlock();
#line 1537
  return (count);
}
}
#line 1545 "db-gdbm.c"
char *db_get_playlist_name(unsigned long playlistid ) 
{ char *name ;
  DB_PLAYLIST *current ;

  {
#line 1550
  db_readlock();
#line 1552
  current = db_playlists.next;
#line 1553
  while (1) {
#line 1553
    if (current) {
#line 1553
      if (! (current->id != playlistid)) {
#line 1553
        break;
      }
    } else {
#line 1553
      break;
    }
#line 1554
    current = current->next;
  }
#line 1556
  if (! current) {
#line 1557
    name = (char *)((void *)0);
  } else {
#line 1559
    name = current->name;
  }
#line 1562
  db_unlock();
#line 1563
  return (name);
}
}
#line 1572 "db-gdbm.c"
int db_exists(unsigned long id ) 
{ unsigned long *node ;
  datum key ;
  datum content ;
  void const   *tmp ;

  {
#line 1578
  err_log(9, 4U, (char *)"Checking if node %lu in db\n", id);
#line 1579
  key.dptr = (char *)((void *)(& id));
#line 1580
  key.dsize = (int )sizeof(unsigned long );
#line 1582
  db_readlock();
#line 1584
  db_gdbmlock();
#line 1585
  content = gdbm_fetch(db_songs, key);
#line 1586
  db_gdbmunlock();
#line 1589
  if (! content.dptr) {
#line 1590
    err_log(9, 4U, (char *)"Nope!  Not in DB\n");
#line 1591
    db_unlock();
#line 1592
    return (0);
  }
#line 1595
  if (db_update_mode) {
#line 1597
    tmp = rbdelete((void const   *)((void *)(& id)), db_removed);
#line 1597
    node = (unsigned long *)tmp;
#line 1598
    if (node) {
#line 1599
      err_log(9, 4U, (char *)"Knocked node %lu from the list\n", *node);
#line 1600
      free((void *)node);
    }
  }
#line 1604
  db_unlock();
#line 1606
  free((void *)content.dptr);
#line 1607
  err_log(9, 4U, (char *)"Yup, in database\n");
#line 1608
  return (1);
}
}
#line 1617 "db-gdbm.c"
int db_last_modified(unsigned long id ) 
{ int retval ;
  MP3FILE *pmp3 ;

  {
#line 1623
  pmp3 = db_find(id);
#line 1624
  if (! pmp3) {
#line 1625
    retval = 0;
  } else {
#line 1627
    retval = pmp3->db_timestamp;
  }
#line 1630
  if (pmp3) {
#line 1631
    db_dispose(pmp3);
#line 1632
    free((void *)pmp3);
  }
#line 1635
  return (retval);
}
}
#line 1644 "db-gdbm.c"
int db_delete(unsigned long id ) 
{ datum key ;
  DB_PLAYLIST *pcurrent ;
  DB_PLAYLISTENTRY *phead ;
  DB_PLAYLISTENTRY *ptail ;
  int tmp ;

  {
#line 1650
  err_log(9, 4U, (char *)"Removing item %lu\n", id);
#line 1652
  tmp = db_exists(id);
#line 1652
  if (tmp) {
#line 1653
    db_writelock();
#line 1654
    key.dptr = (char *)((void *)(& id));
#line 1655
    key.dsize = (int )sizeof(unsigned long );
#line 1656
    db_gdbmlock();
#line 1657
    gdbm_delete(db_songs, key);
#line 1658
    db_gdbmunlock();
#line 1660
    db_song_count --;
#line 1661
    db_version_no ++;
#line 1664
    pcurrent = db_playlists.next;
#line 1665
    while (pcurrent) {
#line 1666
      ptail = pcurrent->nodes;
#line 1666
      phead = ptail;
#line 1667
      while (1) {
#line 1667
        if (phead) {
#line 1667
          if (! (phead->id != id)) {
#line 1667
            break;
          }
        } else {
#line 1667
          break;
        }
#line 1668
        ptail = phead;
#line 1669
        phead = phead->next;
      }
#line 1672
      if (phead) {
#line 1673
        err_log(9, 132U, (char *)"Removing from playlist %lu\n", pcurrent->id);
#line 1675
        if ((unsigned int )phead == (unsigned int )pcurrent->nodes) {
#line 1676
          pcurrent->nodes = phead->next;
        } else {
#line 1678
          ptail->next = phead->next;
        }
#line 1681
        if ((unsigned int )pcurrent->last_node == (unsigned int )phead) {
#line 1682
          pcurrent->last_node = ptail;
        }
#line 1684
        free((void *)phead);
#line 1686
        if ((unsigned int )pcurrent->nodes == (unsigned int )((void *)0)) {
#line 1687
          pcurrent->last_node = (struct tag_playlistentry *)((void *)0);
#line 1688
          err_log(9, 132U, (char *)"Empty Playlist!\n");
#line 1689
          db_playlist_count --;
        }
      }
#line 1692
      pcurrent = pcurrent->next;
    }
#line 1694
    db_version_no ++;
#line 1695
    db_unlock();
  }
#line 1699
  return (0);
}
}
#line 1 "mp3-scanner.o"
#pragma merger(0,"/tmp/cil-lIV2cK3f.i","-g,-g,-O2")
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 247 "/usr/include/id3tag.h"
extern struct id3_file *id3_file_open(char const   * , enum id3_file_mode  ) ;
#line 249
extern int id3_file_close(struct id3_file * ) ;
#line 251
extern struct id3_tag *id3_file_tag(struct id3_file  const  * ) ;
#line 270
extern struct id3_frame *id3_tag_findframe(struct id3_tag  const  * , char const   * ,
                                           unsigned int  ) ;
#line 306
extern id3_ucs4_t const   *id3_field_getstring(union id3_field  const  * ) ;
#line 307
extern id3_ucs4_t const   *id3_field_getfullstring(union id3_field  const  * ) ;
#line 308
extern unsigned int id3_field_getnstrings(union id3_field  const  * ) ;
#line 309
extern id3_ucs4_t const   *id3_field_getstrings(union id3_field  const  * , unsigned int  ) ;
#line 325
extern id3_utf8_t *id3_ucs4_utf8duplicate(id3_ucs4_t const   * ) ;
#line 608 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 648
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 653
extern long ftell(FILE *__stream ) ;
#line 658
extern void rewind(FILE *__stream ) ;
#line 729
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 84
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 135 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 150
extern int closedir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 184
extern int readdir_r(DIR * __restrict  __dirp , struct dirent * __restrict  __entry ,
                     struct dirent ** __restrict  __result )  __attribute__((__nonnull__(1,2,3))) ;
#line 76 "mp3-scanner.h"
off_t aac_drilltoatom(FILE *aac_fp , char *atom_path , unsigned int *atom_length ) ;
#line 99 "mp3-scanner.c"
int scan_br_table[5][16]  = { {        0,        32,        64,        96, 
            128,        160,        192,        224, 
            256,        288,        320,        352, 
            384,        416,        448,        0}, 
   {        0,        32,        48,        56, 
            64,        80,        96,        112, 
            128,        160,        192,        224, 
            256,        320,        384,        0}, 
   {        0,        32,        40,        48, 
            56,        64,        80,        96, 
            112,        128,        160,        192, 
            224,        256,        320,        0}, 
   {        0,        32,        48,        56, 
            64,        80,        96,        112, 
            128,        144,        160,        176, 
            192,        224,        256,        0}, 
   {        0,        8,        16,        24, 
            32,        40,        48,        56, 
            64,        80,        96,        112, 
            128,        144,        160,        0}};
#line 107 "mp3-scanner.c"
int scan_sample_table[3][4]  = { {        44100,        48000,        32000,        0}, 
   {        22050,        24000,        16000,        0}, 
   {        11025,        12000,        8000,        0}};
#line 115 "mp3-scanner.c"
int scan_mode_foreground  =    1;
#line 117 "mp3-scanner.c"
char *scan_winamp_genre[149]  = 
#line 117
  {      (char *)"Blues",      (char *)"Classic Rock",      (char *)"Country",      (char *)"Dance", 
        (char *)"Disco",      (char *)"Funk",      (char *)"Grunge",      (char *)"Hip-Hop", 
        (char *)"Jazz",      (char *)"Metal",      (char *)"New Age",      (char *)"Oldies", 
        (char *)"Other",      (char *)"Pop",      (char *)"R&B",      (char *)"Rap", 
        (char *)"Reggae",      (char *)"Rock",      (char *)"Techno",      (char *)"Industrial", 
        (char *)"Alternative",      (char *)"Ska",      (char *)"Death Metal",      (char *)"Pranks", 
        (char *)"Soundtrack",      (char *)"Euro-Techno",      (char *)"Ambient",      (char *)"Trip-Hop", 
        (char *)"Vocal",      (char *)"Jazz+Funk",      (char *)"Fusion",      (char *)"Trance", 
        (char *)"Classical",      (char *)"Instrumental",      (char *)"Acid",      (char *)"House", 
        (char *)"Game",      (char *)"Sound Clip",      (char *)"Gospel",      (char *)"Noise", 
        (char *)"AlternRock",      (char *)"Bass",      (char *)"Soul",      (char *)"Punk", 
        (char *)"Space",      (char *)"Meditative",      (char *)"Instrumental Pop",      (char *)"Instrumental Rock", 
        (char *)"Ethnic",      (char *)"Gothic",      (char *)"Darkwave",      (char *)"Techno-Industrial", 
        (char *)"Electronic",      (char *)"Pop-Folk",      (char *)"Eurodance",      (char *)"Dream", 
        (char *)"Southern Rock",      (char *)"Comedy",      (char *)"Cult",      (char *)"Gangsta", 
        (char *)"Top 40",      (char *)"Christian Rap",      (char *)"Pop/Funk",      (char *)"Jungle", 
        (char *)"Native American",      (char *)"Cabaret",      (char *)"New Wave",      (char *)"Psychadelic", 
        (char *)"Rave",      (char *)"Showtunes",      (char *)"Trailer",      (char *)"Lo-Fi", 
        (char *)"Tribal",      (char *)"Acid Punk",      (char *)"Acid Jazz",      (char *)"Polka", 
        (char *)"Retro",      (char *)"Musical",      (char *)"Rock & Roll",      (char *)"Hard Rock", 
        (char *)"Folk",      (char *)"Folk/Rock",      (char *)"National folk",      (char *)"Swing", 
        (char *)"Fast-fusion",      (char *)"Bebob",      (char *)"Latin",      (char *)"Revival", 
        (char *)"Celtic",      (char *)"Bluegrass",      (char *)"Avantgarde",      (char *)"Gothic Rock", 
        (char *)"Progressive Rock",      (char *)"Psychedelic Rock",      (char *)"Symphonic Rock",      (char *)"Slow Rock", 
        (char *)"Big Band",      (char *)"Chorus",      (char *)"Easy Listening",      (char *)"Acoustic", 
        (char *)"Humour",      (char *)"Speech",      (char *)"Chanson",      (char *)"Opera", 
        (char *)"Chamber Music",      (char *)"Sonata",      (char *)"Symphony",      (char *)"Booty Bass", 
        (char *)"Primus",      (char *)"Porn Groove",      (char *)"Satire",      (char *)"Slow Jam", 
        (char *)"Club",      (char *)"Tango",      (char *)"Samba",      (char *)"Folklore", 
        (char *)"Ballad",      (char *)"Powder Ballad",      (char *)"Rhythmic Soul",      (char *)"Freestyle", 
        (char *)"Duet",      (char *)"Punk Rock",      (char *)"Drum Solo",      (char *)"A Capella", 
        (char *)"Euro-House",      (char *)"Dance Hall",      (char *)"Goa",      (char *)"Drum & Bass", 
        (char *)"Club House",      (char *)"Hardcore",      (char *)"Terror",      (char *)"Indie", 
        (char *)"BritPop",      (char *)"NegerPunk",      (char *)"Polsk Punk",      (char *)"Beat", 
        (char *)"Christian Gangsta",      (char *)"Heavy Metal",      (char *)"Black Metal",      (char *)"Crossover", 
        (char *)"Contemporary C",      (char *)"Christian Rock",      (char *)"Merengue",      (char *)"Salsa", 
        (char *)"Thrash Metal",      (char *)"Anime",      (char *)"JPop",      (char *)"SynthPop", 
        (char *)"Unknown"};
#line 275
static int scan_path(char *path ) ;
#line 276
static int scan_gettags(char *file , MP3FILE *pmp3 ) ;
#line 277
static int scan_get_mp3tags(char *file , MP3FILE *pmp3 ) ;
#line 278
static int scan_get_aactags(char *file , MP3FILE *pmp3 ) ;
#line 279 "mp3-scanner.c"
static int scan_get_nultags(char *file , MP3FILE *pmp3 ) 
{ 

  {
#line 279
  return (0);
}
}
#line 280
static int scan_get_fileinfo(char *file , MP3FILE *pmp3 ) ;
#line 281
static int scan_get_mp3fileinfo(char *file , MP3FILE *pmp3 ) ;
#line 282
static int scan_get_aacfileinfo(char *file , MP3FILE *pmp3 ) ;
#line 284
static int scan_get_urlfileinfo(char *file , MP3FILE *pmp3 ) ;
#line 286
static int scan_freetags(MP3FILE *pmp3 ) ;
#line 287
static void scan_static_playlist(char *path , struct dirent *pde , struct stat *psb ) ;
#line 288
static void scan_music_file(char *path , struct dirent *pde , struct stat *psb ) ;
#line 290
static int scan_decode_mp3_frame(unsigned char *frame , SCAN_FRAMEINFO *pfi ) ;
#line 291
static time_t mac_to_unix_time(int t ) ;
#line 307 "mp3-scanner.c"
static taghandler taghandlers[7]  = {      {(char *)"aac", & scan_get_aactags, & scan_get_aacfileinfo}, 
        {(char *)"mp4", & scan_get_aactags, & scan_get_aacfileinfo}, 
        {(char *)"m4a", & scan_get_aactags, & scan_get_aacfileinfo}, 
        {(char *)"m4p", & scan_get_aactags, & scan_get_aacfileinfo}, 
        {(char *)"mp3", & scan_get_mp3tags, & scan_get_mp3fileinfo}, 
        {(char *)"url", & scan_get_nultags, & scan_get_urlfileinfo}, 
        {(char *)((void *)0), (int (*)(char *file , MP3FILE *pmp3 ))0, (int (*)(char *file ,
                                                                             MP3FILE *pmp3 ))0}};
#line 326 "mp3-scanner.c"
static time_t mac_to_unix_time(int t ) 
{ struct timeval tv ;
  struct timezone tz ;

  {
#line 330
  gettimeofday((struct timeval * __restrict  )(& tv), (struct timezone * __restrict  )(& tz));
#line 332
  return (((long )t - 2082844800L) + (long )(tz.tz_minuteswest * 60));
}
}
#line 349 "mp3-scanner.c"
int scan_init(char *path ) 
{ int err ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 352
  scan_mode_foreground = 0;
#line 353
  tmp = db_is_empty();
#line 353
  if (tmp) {
#line 354
    scan_mode_foreground = 1;
  }
#line 357
  tmp___0 = db_start_initial_update();
#line 357
  if (tmp___0) {
#line 358
    return (-1);
  }
#line 360
  if (scan_mode_foreground) {
#line 360
    tmp___1 = "Foreground";
  } else {
#line 360
    tmp___1 = "Background";
  }
#line 360
  err_log(9, 8U, (char *)"%s scanning for MP3s in %s\n", tmp___1, path);
#line 364
  err = scan_path(path);
#line 366
  tmp___2 = db_end_initial_update();
#line 366
  if (tmp___2) {
#line 367
    return (-1);
  }
#line 369
  scan_mode_foreground = 0;
#line 371
  return (err);
}
}
#line 431
extern int ( /* missing proto */  strcasestr)() ;
#line 379 "mp3-scanner.c"
static int scan_path(char *path ) 
{ DIR *current_dir ;
  char de[(sizeof(struct dirent ) + 255U) + 1U] ;
  struct dirent *pde ;
  int err ;
  char mp3_path[4096] ;
  struct stat sb ;
  int modified_time ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;

  {
#line 388
  current_dir = opendir((char const   *)path);
#line 388
  if ((unsigned int )current_dir == (unsigned int )((void *)0)) {
#line 389
    return (-1);
  }
#line 392
  while (1) {
#line 393
    if (config.stop) {
#line 394
      err_log(2, 8U, (char *)"Stop detected.  Aborting scan of %s.\n", path);
#line 395
      closedir(current_dir);
#line 396
      return (0);
    }
#line 399
    pde = (struct dirent *)(& de);
#line 401
    err = readdir_r((DIR * __restrict  )current_dir, (struct dirent * __restrict  )((struct dirent *)(de)),
                    (struct dirent ** __restrict  )(& pde));
#line 402
    if (err == -1) {
#line 403
      tmp = __errno_location();
#line 403
      tmp___0 = strerror(*tmp);
#line 403
      err_log(9, 8U, (char *)"Error on readdir_r: %s\n", tmp___0);
#line 404
      tmp___1 = __errno_location();
#line 404
      err = *tmp___1;
#line 405
      closedir(current_dir);
#line 406
      tmp___2 = __errno_location();
#line 406
      *tmp___2 = err;
#line 407
      return (-1);
    }
#line 410
    if (! pde) {
#line 411
      break;
    }
#line 413
    if ((int )pde->d_name[0] == 46) {
#line 414
      continue;
    }
#line 416
    snprintf((char * __restrict  )(mp3_path), 4096U, (char const   * __restrict  )"%s/%s",
             path, pde->d_name);
#line 417
    err_log(9, 8U, (char *)"Found %s\n", mp3_path);
#line 418
    tmp___13 = stat((char const   * __restrict  )(mp3_path), (struct stat * __restrict  )(& sb));
#line 418
    if (tmp___13) {
#line 419
      tmp___3 = __errno_location();
#line 419
      tmp___4 = strerror(*tmp___3);
#line 419
      err_log(2, 8U, (char *)"Error statting: %s\n", tmp___4);
    } else {
#line 421
      if (sb.st_mode & 16384U) {
#line 422
        err_log(9, 8U, (char *)"Found dir %s... recursing\n", pde->d_name);
#line 423
        scan_path(mp3_path);
      } else {
#line 426
        tmp___12 = strlen((char const   *)(pde->d_name));
#line 426
        if (tmp___12 > 4U) {
#line 427
          tmp___10 = strlen((char const   *)(pde->d_name));
#line 427
          tmp___11 = strcasecmp(".m3u", (char const   *)(& pde->d_name[tmp___10 - 4U]));
#line 427
          if (tmp___11 == 0) {
#line 427
            if (config.process_m3u) {
#line 430
              scan_static_playlist(path, pde, & sb);
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 431
            tmp___8 = strlen((char const   *)(pde->d_name));
#line 431
            tmp___9 = strcasestr(config.extensions, & pde->d_name[tmp___8 - 4U]);
#line 431
            if (tmp___9) {
#line 435
              modified_time = (int )sb.st_mtim.tv_sec;
#line 436
              err_log(9, 8U, (char *)"FS Mod time: %d\n", modified_time);
#line 437
              tmp___5 = db_last_modified(sb.st_ino);
#line 437
              err_log(9, 8U, (char *)"DB Mod time: %d\n", tmp___5);
#line 438
              if (scan_mode_foreground) {
#line 441
                scan_music_file(path, pde, & sb);
              } else {
#line 438
                tmp___6 = db_exists(sb.st_ino);
#line 438
                if (tmp___6) {
#line 438
                  tmp___7 = db_last_modified(sb.st_ino);
#line 438
                  if (tmp___7 < modified_time) {
#line 441
                    scan_music_file(path, pde, & sb);
                  } else {
#line 443
                    err_log(9, 8U, (char *)"Skipping file... not modified\n");
                  }
                } else {
#line 441
                  scan_music_file(path, pde, & sb);
                }
              }
            }
          }
        }
      }
    }
  }
#line 451
  closedir(current_dir);
#line 452
  return (0);
}
}
#line 460 "mp3-scanner.c"
static void scan_static_playlist(char *path , struct dirent *pde , struct stat *psb ) 
{ char playlist_path[4096] ;
  char m3u_path[4096] ;
  char linebuffer[4096] ;
  int fd ;
  int playlistid ;
  struct stat sb ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 468
  err_log(2, 136U, (char *)"Processing static playlist: %s\n", pde->d_name);
#line 471
  tmp = db_playlist_last_modified(psb->st_ino);
#line 471
  if ((__time_t )tmp == psb->st_mtim.tv_sec) {
#line 472
    return;
  }
#line 474
  db_delete_playlist(psb->st_ino);
#line 476
  strcpy((char * __restrict  )(m3u_path), (char const   * __restrict  )(pde->d_name));
#line 477
  snprintf((char * __restrict  )(playlist_path), sizeof(playlist_path), (char const   * __restrict  )"%s/%s",
           path, pde->d_name);
#line 478
  tmp___0 = strlen((char const   *)(pde->d_name));
#line 478
  m3u_path[tmp___0 - 4U] = (char )'\000';
#line 479
  playlistid = (int )psb->st_ino;
#line 480
  fd = open((char const   *)(playlist_path), 0);
#line 481
  if (fd != -1) {
#line 482
    db_add_playlist((unsigned long )playlistid, m3u_path, (int )psb->st_mtim.tv_sec,
                    0);
#line 483
    err_log(5, 136U, (char *)"Added playlist as id %d\n", playlistid);
#line 485
    memset((void *)(linebuffer), 0, sizeof(linebuffer));
#line 486
    while (1) {
#line 486
      tmp___7 = readline(fd, linebuffer, (int )sizeof(linebuffer));
#line 486
      if (! (tmp___7 > 0)) {
#line 486
        break;
      }
#line 487
      while (1) {
#line 487
        tmp___2 = strlen((char const   *)(linebuffer));
#line 487
        if (! ((int )linebuffer[tmp___2 - 1U] == 10)) {
#line 487
          tmp___3 = strlen((char const   *)(linebuffer));
#line 487
          if (! ((int )linebuffer[tmp___3 - 1U] == 13)) {
#line 487
            break;
          }
        }
#line 489
        tmp___1 = strlen((char const   *)(linebuffer));
#line 489
        linebuffer[tmp___1 - 1U] = (char )'\000';
      }
#line 491
      if ((int )linebuffer[0] == 59) {
#line 492
        continue;
      } else {
#line 491
        if ((int )linebuffer[0] == 35) {
#line 492
          continue;
        }
      }
#line 497
      if ((int )linebuffer[0] == 47) {
#line 498
        strcpy((char * __restrict  )(m3u_path), (char const   * __restrict  )(linebuffer));
      } else {
#line 500
        snprintf((char * __restrict  )(m3u_path), sizeof(m3u_path), (char const   * __restrict  )"%s/%s",
                 path, linebuffer);
      }
#line 503
      err_log(9, 136U, (char *)"Checking %s\n", m3u_path);
#line 506
      tmp___6 = stat((char const   * __restrict  )(m3u_path), (struct stat * __restrict  )(& sb));
#line 506
      if (tmp___6) {
#line 510
        tmp___4 = __errno_location();
#line 510
        tmp___5 = strerror(*tmp___4);
#line 510
        err_log(2, 136U, (char *)"Playlist entry %s bad: %s\n", m3u_path, tmp___5);
      } else {
#line 508
        db_add_playlist_song((unsigned long )playlistid, sb.st_ino);
      }
    }
#line 514
    close(fd);
  }
#line 517
  err_log(2, 136U, (char *)"Done processing playlist\n");
#line 518
  return;
}
}
#line 525 "mp3-scanner.c"
static void scan_music_file(char *path , struct dirent *pde , struct stat *psb ) 
{ MP3FILE mp3file ;
  char mp3_path[4096] ;
  char *tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 529
  snprintf((char * __restrict  )(mp3_path), sizeof(mp3_path), (char const   * __restrict  )"%s/%s",
           path, pde->d_name);
#line 532
  err_log(5, 8U, (char *)"Found music file: %s\n", pde->d_name);
#line 534
  memset((void *)(& mp3file), 0, sizeof(mp3file));
#line 535
  mp3file.path = mp3_path;
#line 536
  mp3file.fname = pde->d_name;
#line 537
  tmp___13 = strlen((char const   *)(pde->d_name));
#line 537
  if (tmp___13 > 4U) {
#line 538
    tmp___11 = strrchr((char const   *)(pde->d_name), '.');
#line 538
    tmp___12 = __strdup((char const   *)(tmp___11 + 1));
#line 538
    mp3file.type = tmp___12;
  }
#line 544
  mp3file.id = psb->st_ino;
#line 547
  tmp___14 = scan_gettags(mp3file.path, & mp3file);
#line 547
  if (tmp___14) {
#line 564
    err_log(2, 8U, (char *)"Skipping %s - scan_gettags failed\n", pde->d_name);
  } else {
#line 547
    tmp___15 = scan_get_fileinfo(mp3file.path, & mp3file);
#line 547
    if (tmp___15) {
#line 564
      err_log(2, 8U, (char *)"Skipping %s - scan_gettags failed\n", pde->d_name);
    } else {
#line 549
      make_composite_tags(& mp3file);
#line 554
      mp3file.time_added = (int )psb->st_mtim.tv_sec;
#line 555
      if (psb->st_ctim.tv_sec < (__time_t )mp3file.time_added) {
#line 556
        mp3file.time_added = (int )psb->st_ctim.tv_sec;
      }
#line 557
      mp3file.time_modified = (int )psb->st_mtim.tv_sec;
#line 559
      err_log(9, 8U, (char *)" Date Added: %d\n", mp3file.time_added);
#line 561
      db_add(& mp3file);
#line 562
      pl_eval(& mp3file);
    }
  }
#line 567
  scan_freetags(& mp3file);
#line 568
  return;
}
}
#line 575 "mp3-scanner.c"
long scan_aac_findatom(FILE *fin , long max_offset , char *which_atom , int *atom_size ) 
{ long current_offset ;
  int size ;
  char atom[4] ;
  size_t tmp ;
  register unsigned int __v ;
  register unsigned int __x ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 576
  current_offset = 0L;
#line 580
  while (current_offset < max_offset) {
#line 581
    tmp = fread((void * __restrict  )((void *)(& size)), 1U, sizeof(int ), (FILE * __restrict  )fin);
#line 581
    if (tmp != sizeof(int )) {
#line 582
      return (-1L);
    }
#line 584
    __x = (unsigned int )size;
#line 584
    __asm__  ("bswap %0": "=r" (__v): "0" (__x));
#line 584
    size = (int )__v;
#line 586
    if (size <= 7) {
#line 587
      return (-1L);
    }
#line 589
    tmp___0 = fread((void * __restrict  )(atom), 1U, 4U, (FILE * __restrict  )fin);
#line 589
    if (tmp___0 != 4U) {
#line 590
      return (-1L);
    }
#line 592
    tmp___1 = strncasecmp((char const   *)(atom), (char const   *)which_atom, 4U);
#line 592
    if (tmp___1 == 0) {
#line 593
      *atom_size = size;
#line 594
      return (current_offset);
    }
#line 597
    fseek(fin, (long )(size - 8), 1);
#line 598
    current_offset += (long )size;
  }
#line 601
  return (-1L);
}
}
#line 609 "mp3-scanner.c"
static int scan_get_aactags(char *file , MP3FILE *pmp3 ) 
{ FILE *fin ;
  long atom_offset ;
  int atom_length ;
  long current_offset ;
  int current_size ;
  char current_atom[4] ;
  char *current_data ;
  unsigned short us_data ;
  int genre ;
  int len ;
  size_t tmp ;
  register unsigned int __v ;
  register unsigned int __x ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___8 ;
  char *tmp___14 ;
  char *tmp___20 ;
  char *tmp___26 ;
  char *tmp___32 ;
  char *tmp___38 ;
  char *tmp___44 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  register unsigned short __v___1 ;
  register unsigned short __x___1 ;
  register unsigned short __v___2 ;
  register unsigned short __x___2 ;
  register unsigned short __v___3 ;
  register unsigned short __x___3 ;
  register unsigned short __v___4 ;
  register unsigned short __x___4 ;
  char *tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;

  {
#line 614
  current_offset = 0L;
#line 622
  fin = fopen((char const   * __restrict  )file, (char const   * __restrict  )"rb");
#line 622
  if (! fin) {
#line 623
    err_log(5, 8U, (char *)"Cannot open file %s for reading\n", file);
#line 624
    return (-1);
  }
#line 627
  fseek(fin, 0L, 0);
#line 629
  atom_offset = aac_drilltoatom(fin, (char *)"moov:udta:meta:ilst", (unsigned int *)(& atom_length));
#line 630
  if (atom_offset != -1L) {
#line 633
    while (current_offset < (long )atom_length) {
#line 634
      tmp = fread((void * __restrict  )((void *)(& current_size)), 1U, sizeof(int ),
                  (FILE * __restrict  )fin);
#line 634
      if (tmp != sizeof(int )) {
#line 635
        break;
      }
#line 637
      __x = (unsigned int )current_size;
#line 637
      __asm__  ("bswap %0": "=r" (__v): "0" (__x));
#line 637
      current_size = (int )__v;
#line 639
      if (current_size <= 7) {
#line 640
        break;
      }
#line 642
      tmp___0 = fread((void * __restrict  )(current_atom), 1U, 4U, (FILE * __restrict  )fin);
#line 642
      if (tmp___0 != 4U) {
#line 643
        break;
      }
#line 645
      len = current_size - 7;
#line 646
      if (len < 22) {
#line 647
        len = 22;
      }
#line 649
      tmp___1 = malloc((unsigned int )len);
#line 649
      current_data = (char *)tmp___1;
#line 650
      memset((void *)current_data, 0, (unsigned int )len);
#line 652
      tmp___2 = fread((void * __restrict  )current_data, 1U, (unsigned int )(current_size - 8),
                      (FILE * __restrict  )fin);
#line 652
      if (tmp___2 != (size_t )(current_size - 8)) {
#line 653
        break;
      }
#line 655
      tmp___63 = memcmp((void const   *)(current_atom), (void const   *)"\251nam",
                        4U);
#line 655
      if (tmp___63) {
#line 657
        tmp___62 = memcmp((void const   *)(current_atom), (void const   *)"\251ART",
                          4U);
#line 657
        if (tmp___62) {
#line 659
          tmp___61 = memcmp((void const   *)(current_atom), (void const   *)"\251alb",
                            4U);
#line 659
          if (tmp___61) {
#line 661
            tmp___60 = memcmp((void const   *)(current_atom), (void const   *)"\251cmt",
                              4U);
#line 661
            if (tmp___60) {
#line 663
              tmp___59 = memcmp((void const   *)(current_atom), (void const   *)"\251wrt",
                                4U);
#line 663
              if (tmp___59) {
#line 665
                tmp___58 = memcmp((void const   *)(current_atom), (void const   *)"\251grp",
                                  4U);
#line 665
                if (tmp___58) {
#line 667
                  tmp___57 = memcmp((void const   *)(current_atom), (void const   *)"\251gen",
                                    4U);
#line 667
                  if (tmp___57) {
#line 670
                    tmp___56 = memcmp((void const   *)(current_atom), (void const   *)"tmpo",
                                      4U);
#line 670
                    if (tmp___56) {
#line 674
                      tmp___55 = memcmp((void const   *)(current_atom), (void const   *)"trkn",
                                        4U);
#line 674
                      if (tmp___55) {
#line 684
                        tmp___54 = memcmp((void const   *)(current_atom), (void const   *)"disk",
                                          4U);
#line 684
                        if (tmp___54) {
#line 694
                          tmp___53 = memcmp((void const   *)(current_atom), (void const   *)"\251day",
                                            4U);
#line 694
                          if (tmp___53) {
#line 696
                            tmp___52 = memcmp((void const   *)(current_atom), (void const   *)"gnre",
                                              4U);
#line 696
                            if (tmp___52) {
#line 704
                              tmp___51 = memcmp((void const   *)(current_atom), (void const   *)"cpil",
                                                4U);
#line 704
                              if (! tmp___51) {
#line 705
                                pmp3->compilation = *(current_data + 16);
                              }
                            } else {
#line 697
                              genre = (int )*(current_data + 17);
#line 698
                              genre --;
#line 700
                              if (genre < 0) {
#line 701
                                genre = 148;
                              } else {
#line 700
                                if (genre > 148) {
#line 701
                                  genre = 148;
                                }
                              }
#line 703
                              tmp___50 = __strdup((char const   *)scan_winamp_genre[genre]);
#line 703
                              pmp3->genre = tmp___50;
                            }
                          } else {
#line 695
                            pmp3->year = atoi((char const   *)(current_data + 16));
                          }
                        } else {
#line 685
                          us_data = *((unsigned short *)(current_data + 18));
#line 686
                          __x___3 = us_data;
#line 686
                          __asm__  ("rorw $8, %w0": "=r" (__v___3): "0" (__x___3): "cc");
#line 686
                          us_data = __v___3;
#line 688
                          pmp3->disc = (int )us_data;
#line 690
                          us_data = *((unsigned short *)(current_data + 20));
#line 691
                          __x___4 = us_data;
#line 691
                          __asm__  ("rorw $8, %w0": "=r" (__v___4): "0" (__x___4): "cc");
#line 691
                          us_data = __v___4;
#line 693
                          pmp3->total_discs = (int )us_data;
                        }
                      } else {
#line 675
                        us_data = *((unsigned short *)(current_data + 18));
#line 676
                        __x___1 = us_data;
#line 676
                        __asm__  ("rorw $8, %w0": "=r" (__v___1): "0" (__x___1): "cc");
#line 676
                        us_data = __v___1;
#line 678
                        pmp3->track = (int )us_data;
#line 680
                        us_data = *((unsigned short *)(current_data + 20));
#line 681
                        __x___2 = us_data;
#line 681
                        __asm__  ("rorw $8, %w0": "=r" (__v___2): "0" (__x___2): "cc");
#line 681
                        us_data = __v___2;
#line 683
                        pmp3->total_tracks = (int )us_data;
                      }
                    } else {
#line 671
                      us_data = *((unsigned short *)(current_data + 16));
#line 672
                      __x___0 = us_data;
#line 672
                      __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 672
                      us_data = __v___0;
#line 673
                      pmp3->bpm = (int )us_data;
                    }
                  } else {
#line 669
                    tmp___44 = __strdup((char const   *)(current_data + 16));
#line 669
                    pmp3->genre = tmp___44;
                  }
                } else {
#line 666
                  tmp___38 = __strdup((char const   *)(current_data + 16));
#line 666
                  pmp3->grouping = tmp___38;
                }
              } else {
#line 664
                tmp___32 = __strdup((char const   *)(current_data + 16));
#line 664
                pmp3->composer = tmp___32;
              }
            } else {
#line 662
              tmp___26 = __strdup((char const   *)(current_data + 16));
#line 662
              pmp3->comment = tmp___26;
            }
          } else {
#line 660
            tmp___20 = __strdup((char const   *)(current_data + 16));
#line 660
            pmp3->album = tmp___20;
          }
        } else {
#line 658
          tmp___14 = __strdup((char const   *)(current_data + 16));
#line 658
          pmp3->artist = tmp___14;
        }
      } else {
#line 656
        tmp___8 = __strdup((char const   *)(current_data + 16));
#line 656
        pmp3->title = tmp___8;
      }
#line 708
      free((void *)current_data);
#line 709
      current_offset += (long )current_size;
    }
  }
#line 713
  fclose(fin);
#line 714
  return (0);
}
}
#line 723 "mp3-scanner.c"
static int scan_gettags(char *file , MP3FILE *pmp3 ) 
{ taghandler *hdl ;
  int tmp ;
  int tmp___0 ;

  {
#line 727
  hdl = taghandlers;
#line 727
  while (hdl->suffix) {
#line 728
    tmp = strcasecmp((char const   *)hdl->suffix, (char const   *)pmp3->type);
#line 728
    if (! tmp) {
#line 729
      break;
    }
#line 727
    hdl ++;
  }
#line 731
  if (hdl->tags) {
#line 732
    tmp___0 = (*(hdl->tags))(file, pmp3);
#line 732
    return (tmp___0);
  }
#line 739
  return (0);
}
}
#line 743 "mp3-scanner.c"
static int scan_get_mp3tags(char *file , MP3FILE *pmp3 ) 
{ struct id3_file *pid3file ;
  struct id3_tag *pid3tag ;
  struct id3_frame *pid3frame ;
  int err ;
  int index___0 ;
  int used ;
  unsigned char *utf8_text ;
  int genre ;
  int have_utf8 ;
  int have_text ;
  id3_ucs4_t const   *native_text ;
  char *tmp ;
  int got_numeric_genre ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___11 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned int tmp___17 ;
  id3_utf8_t *tmp___18 ;
  unsigned short const   **tmp___19 ;
  unsigned short const   **tmp___20 ;
  size_t tmp___21 ;
  char *tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___30 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___37 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___51 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___58 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___65 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___72 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___79 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  size_t __s1_len___9 ;
  size_t __s2_len___9 ;
  int tmp___86 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___93 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  size_t __s1_len___11 ;
  size_t __s2_len___11 ;
  int tmp___100 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___107 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;
  size_t __s1_len___13 ;
  size_t __s2_len___13 ;
  int tmp___114 ;
  int tmp___117 ;
  int tmp___118 ;
  int tmp___119 ;
  size_t __s1_len___14 ;
  size_t __s2_len___14 ;
  int tmp___121 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  size_t __s1_len___15 ;
  size_t __s2_len___15 ;
  int tmp___128 ;
  int tmp___131 ;
  int tmp___132 ;
  int tmp___133 ;
  id3_utf8_t *tmp___134 ;
  id3_utf8_t *tmp___135 ;
  int tmp___136 ;
  size_t __s1_len___16 ;
  size_t __s2_len___16 ;
  int tmp___138 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;

  {
#line 751
  genre = 148;
#line 758
  tmp___0 = strcasecmp((char const   *)pmp3->type, "mp3");
#line 758
  if (tmp___0) {
#line 759
    return (0);
  }
#line 761
  pid3file = id3_file_open((char const   *)file, 0);
#line 762
  if (! pid3file) {
#line 763
    err_log(2, 8U, (char *)"Cannot open %s\n", file);
#line 764
    return (-1);
  }
#line 767
  pid3tag = id3_file_tag((struct id3_file  const  *)pid3file);
#line 769
  if (! pid3tag) {
#line 770
    tmp___1 = __errno_location();
#line 770
    err = *tmp___1;
#line 771
    id3_file_close(pid3file);
#line 772
    tmp___2 = __errno_location();
#line 772
    *tmp___2 = err;
#line 773
    err_log(2, 8U, (char *)"Cannot get ID3 tag for %s\n", file);
#line 774
    return (-1);
  }
#line 777
  index___0 = 0;
#line 778
  while (1) {
#line 778
    pid3frame = id3_tag_findframe((struct id3_tag  const  *)pid3tag, "", (unsigned int )index___0);
#line 778
    if (! pid3frame) {
#line 778
      break;
    }
#line 779
    used = 0;
#line 780
    utf8_text = (unsigned char *)((void *)0);
#line 781
    native_text = (id3_ucs4_t const   *)((void *)0);
#line 782
    have_utf8 = 0;
#line 783
    have_text = 0;
#line 785
    if (0) {
#line 785
      __s1_len = strlen((char const   *)(pid3frame->id));
#line 785
      __s2_len = strlen("YTCP");
#line 785
      if (! ((unsigned int )((void const   *)(pid3frame->id + 1)) - (unsigned int )((void const   *)(pid3frame->id)) == 1U)) {
        goto _L___0;
      } else {
#line 785
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 785
          if (! ((unsigned int )((void const   *)("YTCP" + 1)) - (unsigned int )((void const   *)"YTCP") == 1U)) {
#line 785
            tmp___9 = 1;
          } else {
#line 785
            if (__s2_len >= 4U) {
#line 785
              tmp___9 = 1;
            } else {
#line 785
              tmp___9 = 0;
            }
          }
        } else {
#line 785
          tmp___9 = 0;
        }
      }
#line 785
      if (tmp___9) {
#line 785
        tmp___4 = __builtin_strcmp((char const   *)(pid3frame->id), "YTCP");
#line 785
        tmp___8 = tmp___4;
      } else {
#line 785
        tmp___7 = __builtin_strcmp((char const   *)(pid3frame->id), "YTCP");
#line 785
        tmp___8 = tmp___7;
      }
    } else {
#line 785
      tmp___7 = __builtin_strcmp((char const   *)(pid3frame->id), "YTCP");
#line 785
      tmp___8 = tmp___7;
    }
#line 785
    if (! tmp___8) {
#line 786
      pmp3->compilation = (char)1;
#line 787
      err_log(9, 8U, (char *)"Compilation: %d\n", pmp3->compilation);
    }
#line 790
    if ((int )pid3frame->id[0] == 84) {
      goto _L___3;
    } else {
#line 790
      if (0) {
#line 790
        __s1_len___0 = strlen((char const   *)(pid3frame->id));
#line 790
        __s2_len___0 = strlen("COMM");
#line 790
        if (! ((unsigned int )((void const   *)(pid3frame->id + 1)) - (unsigned int )((void const   *)(pid3frame->id)) == 1U)) {
          goto _L___2;
        } else {
#line 790
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 790
            if (! ((unsigned int )((void const   *)("COMM" + 1)) - (unsigned int )((void const   *)"COMM") == 1U)) {
#line 790
              tmp___16 = 1;
            } else {
#line 790
              if (__s2_len___0 >= 4U) {
#line 790
                tmp___16 = 1;
              } else {
#line 790
                tmp___16 = 0;
              }
            }
          } else {
#line 790
            tmp___16 = 0;
          }
        }
#line 790
        if (tmp___16) {
#line 790
          tmp___11 = __builtin_strcmp((char const   *)(pid3frame->id), "COMM");
#line 790
          tmp___15 = tmp___11;
        } else {
#line 790
          tmp___14 = __builtin_strcmp((char const   *)(pid3frame->id), "COMM");
#line 790
          tmp___15 = tmp___14;
        }
      } else {
#line 790
        tmp___14 = __builtin_strcmp((char const   *)(pid3frame->id), "COMM");
#line 790
        tmp___15 = tmp___14;
      }
#line 790
      if (tmp___15 == 0) {
        _L___3: /* CIL Label */ 
#line 790
        tmp___17 = id3_field_getnstrings((union id3_field  const  *)(pid3frame->fields + 1));
#line 790
        if (tmp___17) {
#line 792
          have_text = 1;
        }
      }
    }
#line 794
    if (have_text) {
#line 795
      native_text = id3_field_getstrings((union id3_field  const  *)(pid3frame->fields + 1),
                                         0U);
#line 797
      if (native_text) {
#line 798
        have_utf8 = 1;
#line 799
        tmp___18 = id3_ucs4_utf8duplicate(native_text);
#line 799
        utf8_text = (unsigned char *)tmp___18;
#line 802
        if (0) {
#line 802
          __s1_len___15 = strlen((char const   *)(pid3frame->id));
#line 802
          __s2_len___15 = strlen("TIT2");
#line 802
          if (! ((unsigned int )((void const   *)(pid3frame->id + 1)) - (unsigned int )((void const   *)(pid3frame->id)) == 1U)) {
            goto _L___33;
          } else {
#line 802
            if (__s1_len___15 >= 4U) {
              _L___33: /* CIL Label */ 
#line 802
              if (! ((unsigned int )((void const   *)("TIT2" + 1)) - (unsigned int )((void const   *)"TIT2") == 1U)) {
#line 802
                tmp___133 = 1;
              } else {
#line 802
                if (__s2_len___15 >= 4U) {
#line 802
                  tmp___133 = 1;
                } else {
#line 802
                  tmp___133 = 0;
                }
              }
            } else {
#line 802
              tmp___133 = 0;
            }
          }
#line 802
          if (tmp___133) {
#line 802
            tmp___128 = __builtin_strcmp((char const   *)(pid3frame->id), "TIT2");
#line 802
            tmp___132 = tmp___128;
          } else {
#line 802
            tmp___131 = __builtin_strcmp((char const   *)(pid3frame->id), "TIT2");
#line 802
            tmp___132 = tmp___131;
          }
        } else {
#line 802
          tmp___131 = __builtin_strcmp((char const   *)(pid3frame->id), "TIT2");
#line 802
          tmp___132 = tmp___131;
        }
#line 802
        if (tmp___132) {
#line 806
          if (0) {
#line 806
            __s1_len___14 = strlen((char const   *)(pid3frame->id));
#line 806
            __s2_len___14 = strlen("TPE1");
#line 806
            if (! ((unsigned int )((void const   *)(pid3frame->id + 1)) - (unsigned int )((void const   *)(pid3frame->id)) == 1U)) {
              goto _L___31;
            } else {
#line 806
              if (__s1_len___14 >= 4U) {
                _L___31: /* CIL Label */ 
#line 806
                if (! ((unsigned int )((void const   *)("TPE1" + 1)) - (unsigned int )((void const   *)"TPE1") == 1U)) {
#line 806
                  tmp___126 = 1;
                } else {
#line 806
                  if (__s2_len___14 >= 4U) {
#line 806
                    tmp___126 = 1;
                  } else {
#line 806
                    tmp___126 = 0;
                  }
                }
              } else {
#line 806
                tmp___126 = 0;
              }
            }
#line 806
            if (tmp___126) {
#line 806
              tmp___121 = __builtin_strcmp((char const   *)(pid3frame->id), "TPE1");
#line 806
              tmp___125 = tmp___121;
            } else {
#line 806
              tmp___124 = __builtin_strcmp((char const   *)(pid3frame->id), "TPE1");
#line 806
              tmp___125 = tmp___124;
            }
          } else {
#line 806
            tmp___124 = __builtin_strcmp((char const   *)(pid3frame->id), "TPE1");
#line 806
            tmp___125 = tmp___124;
          }
#line 806
          if (tmp___125) {
#line 810
            if (0) {
#line 810
              __s1_len___13 = strlen((char const   *)(pid3frame->id));
#line 810
              __s2_len___13 = strlen("TALB");
#line 810
              if (! ((unsigned int )((void const   *)(pid3frame->id + 1)) - (unsigned int )((void const   *)(pid3frame->id)) == 1U)) {
                goto _L___29;
              } else {
#line 810
                if (__s1_len___13 >= 4U) {
                  _L___29: /* CIL Label */ 
#line 810
                  if (! ((unsigned int )((void const   *)("TALB" + 1)) - (unsigned int )((void const   *)"TALB") == 1U)) {
#line 810
                    tmp___119 = 1;
                  } else {
#line 810
                    if (__s2_len___13 >= 4U) {
#line 810
                      tmp___119 = 1;
                    } else {
#line 810
                      tmp___119 = 0;
                    }
                  }
                } else {
#line 810
                  tmp___119 = 0;
                }
              }
#line 810
              if (tmp___119) {
#line 810
                tmp___114 = __builtin_strcmp((char const   *)(pid3frame->id), "TALB");
#line 810
                tmp___118 = tmp___114;
              } else {
#line 810
                tmp___117 = __builtin_strcmp((char const   *)(pid3frame->id), "TALB");
#line 810
                tmp___118 = tmp___117;
              }
            } else {
#line 810
              tmp___117 = __builtin_strcmp((char const   *)(pid3frame->id), "TALB");
#line 810
              tmp___118 = tmp___117;
            }
#line 810
            if (tmp___118) {
#line 814
              if (0) {
#line 814
                __s1_len___12 = strlen((char const   *)(pid3frame->id));
#line 814
                __s2_len___12 = strlen("TCOM");
#line 814
                if (! ((unsigned int )((void const   *)(pid3frame->id + 1)) - (unsigned int )((void const   *)(pid3frame->id)) == 1U)) {
                  goto _L___27;
                } else {
#line 814
                  if (__s1_len___12 >= 4U) {
                    _L___27: /* CIL Label */ 
#line 814
                    if (! ((unsigned int )((void const   *)("TCOM" + 1)) - (unsigned int )((void const   *)"TCOM") == 1U)) {
#line 814
                      tmp___112 = 1;
                    } else {
#line 814
                      if (__s2_len___12 >= 4U) {
#line 814
                        tmp___112 = 1;
                      } else {
#line 814
                        tmp___112 = 0;
                      }
                    }
                  } else {
#line 814
                    tmp___112 = 0;
                  }
                }
#line 814
                if (tmp___112) {
#line 814
                  tmp___107 = __builtin_strcmp((char const   *)(pid3frame->id), "TCOM");
#line 814
                  tmp___111 = tmp___107;
                } else {
#line 814
                  tmp___110 = __builtin_strcmp((char const   *)(pid3frame->id), "TCOM");
#line 814
                  tmp___111 = tmp___110;
                }
              } else {
#line 814
                tmp___110 = __builtin_strcmp((char const   *)(pid3frame->id), "TCOM");
#line 814
                tmp___111 = tmp___110;
              }
#line 814
              if (tmp___111) {
#line 818
                if (0) {
#line 818
                  __s1_len___11 = strlen((char const   *)(pid3frame->id));
#line 818
                  __s2_len___11 = strlen("TIT1");
#line 818
                  if (! ((unsigned int )((void const   *)(pid3frame->id + 1)) - (unsigned int )((void const   *)(pid3frame->id)) == 1U)) {
                    goto _L___25;
                  } else {
#line 818
                    if (__s1_len___11 >= 4U) {
                      _L___25: /* CIL Label */ 
#line 818
                      if (! ((unsigned int )((void const   *)("TIT1" + 1)) - (unsigned int )((void const   *)"TIT1") == 1U)) {
#line 818
                        tmp___105 = 1;
                      } else {
#line 818
                        if (__s2_len___11 >= 4U) {
#line 818
                          tmp___105 = 1;
                        } else {
#line 818
                          tmp___105 = 0;
                        }
                      }
                    } else {
#line 818
                      tmp___105 = 0;
                    }
                  }
#line 818
                  if (tmp___105) {
#line 818
                    tmp___100 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                 "TIT1");
#line 818
                    tmp___104 = tmp___100;
                  } else {
#line 818
                    tmp___103 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                 "TIT1");
#line 818
                    tmp___104 = tmp___103;
                  }
                } else {
#line 818
                  tmp___103 = __builtin_strcmp((char const   *)(pid3frame->id), "TIT1");
#line 818
                  tmp___104 = tmp___103;
                }
#line 818
                if (tmp___104) {
#line 822
                  if (0) {
#line 822
                    __s1_len___10 = strlen((char const   *)(pid3frame->id));
#line 822
                    __s2_len___10 = strlen("TPE2");
#line 822
                    if (! ((unsigned int )((void const   *)(pid3frame->id + 1)) - (unsigned int )((void const   *)(pid3frame->id)) == 1U)) {
                      goto _L___23;
                    } else {
#line 822
                      if (__s1_len___10 >= 4U) {
                        _L___23: /* CIL Label */ 
#line 822
                        if (! ((unsigned int )((void const   *)("TPE2" + 1)) - (unsigned int )((void const   *)"TPE2") == 1U)) {
#line 822
                          tmp___98 = 1;
                        } else {
#line 822
                          if (__s2_len___10 >= 4U) {
#line 822
                            tmp___98 = 1;
                          } else {
#line 822
                            tmp___98 = 0;
                          }
                        }
                      } else {
#line 822
                        tmp___98 = 0;
                      }
                    }
#line 822
                    if (tmp___98) {
#line 822
                      tmp___93 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                  "TPE2");
#line 822
                      tmp___97 = tmp___93;
                    } else {
#line 822
                      tmp___96 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                  "TPE2");
#line 822
                      tmp___97 = tmp___96;
                    }
                  } else {
#line 822
                    tmp___96 = __builtin_strcmp((char const   *)(pid3frame->id), "TPE2");
#line 822
                    tmp___97 = tmp___96;
                  }
#line 822
                  if (tmp___97) {
#line 826
                    if (0) {
#line 826
                      __s1_len___9 = strlen((char const   *)(pid3frame->id));
#line 826
                      __s2_len___9 = strlen("TPE3");
#line 826
                      if (! ((unsigned int )((void const   *)(pid3frame->id + 1)) - (unsigned int )((void const   *)(pid3frame->id)) == 1U)) {
                        goto _L___21;
                      } else {
#line 826
                        if (__s1_len___9 >= 4U) {
                          _L___21: /* CIL Label */ 
#line 826
                          if (! ((unsigned int )((void const   *)("TPE3" + 1)) - (unsigned int )((void const   *)"TPE3") == 1U)) {
#line 826
                            tmp___91 = 1;
                          } else {
#line 826
                            if (__s2_len___9 >= 4U) {
#line 826
                              tmp___91 = 1;
                            } else {
#line 826
                              tmp___91 = 0;
                            }
                          }
                        } else {
#line 826
                          tmp___91 = 0;
                        }
                      }
#line 826
                      if (tmp___91) {
#line 826
                        tmp___86 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                    "TPE3");
#line 826
                        tmp___90 = tmp___86;
                      } else {
#line 826
                        tmp___89 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                    "TPE3");
#line 826
                        tmp___90 = tmp___89;
                      }
                    } else {
#line 826
                      tmp___89 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                  "TPE3");
#line 826
                      tmp___90 = tmp___89;
                    }
#line 826
                    if (tmp___90) {
#line 830
                      if (0) {
#line 830
                        __s1_len___8 = strlen((char const   *)(pid3frame->id));
#line 830
                        __s2_len___8 = strlen("TCON");
#line 830
                        if (! ((unsigned int )((void const   *)(pid3frame->id + 1)) - (unsigned int )((void const   *)(pid3frame->id)) == 1U)) {
                          goto _L___19;
                        } else {
#line 830
                          if (__s1_len___8 >= 4U) {
                            _L___19: /* CIL Label */ 
#line 830
                            if (! ((unsigned int )((void const   *)("TCON" + 1)) - (unsigned int )((void const   *)"TCON") == 1U)) {
#line 830
                              tmp___84 = 1;
                            } else {
#line 830
                              if (__s2_len___8 >= 4U) {
#line 830
                                tmp___84 = 1;
                              } else {
#line 830
                                tmp___84 = 0;
                              }
                            }
                          } else {
#line 830
                            tmp___84 = 0;
                          }
                        }
#line 830
                        if (tmp___84) {
#line 830
                          tmp___79 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                      "TCON");
#line 830
                          tmp___83 = tmp___79;
                        } else {
#line 830
                          tmp___82 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                      "TCON");
#line 830
                          tmp___83 = tmp___82;
                        }
                      } else {
#line 830
                        tmp___82 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                    "TCON");
#line 830
                        tmp___83 = tmp___82;
                      }
#line 830
                      if (tmp___83) {
#line 854
                        if (0) {
#line 854
                          __s1_len___7 = strlen((char const   *)(pid3frame->id));
#line 854
                          __s2_len___7 = strlen("COMM");
#line 854
                          if (! ((unsigned int )((void const   *)(pid3frame->id + 1)) - (unsigned int )((void const   *)(pid3frame->id)) == 1U)) {
                            goto _L___17;
                          } else {
#line 854
                            if (__s1_len___7 >= 4U) {
                              _L___17: /* CIL Label */ 
#line 854
                              if (! ((unsigned int )((void const   *)("COMM" + 1)) - (unsigned int )((void const   *)"COMM") == 1U)) {
#line 854
                                tmp___77 = 1;
                              } else {
#line 854
                                if (__s2_len___7 >= 4U) {
#line 854
                                  tmp___77 = 1;
                                } else {
#line 854
                                  tmp___77 = 0;
                                }
                              }
                            } else {
#line 854
                              tmp___77 = 0;
                            }
                          }
#line 854
                          if (tmp___77) {
#line 854
                            tmp___72 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                        "COMM");
#line 854
                            tmp___76 = tmp___72;
                          } else {
#line 854
                            tmp___75 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                        "COMM");
#line 854
                            tmp___76 = tmp___75;
                          }
                        } else {
#line 854
                          tmp___75 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                      "COMM");
#line 854
                          tmp___76 = tmp___75;
                        }
#line 854
                        if (tmp___76) {
#line 858
                          if (0) {
#line 858
                            __s1_len___6 = strlen((char const   *)(pid3frame->id));
#line 858
                            __s2_len___6 = strlen("TPOS");
#line 858
                            if (! ((unsigned int )((void const   *)(pid3frame->id + 1)) - (unsigned int )((void const   *)(pid3frame->id)) == 1U)) {
                              goto _L___15;
                            } else {
#line 858
                              if (__s1_len___6 >= 4U) {
                                _L___15: /* CIL Label */ 
#line 858
                                if (! ((unsigned int )((void const   *)("TPOS" + 1)) - (unsigned int )((void const   *)"TPOS") == 1U)) {
#line 858
                                  tmp___70 = 1;
                                } else {
#line 858
                                  if (__s2_len___6 >= 4U) {
#line 858
                                    tmp___70 = 1;
                                  } else {
#line 858
                                    tmp___70 = 0;
                                  }
                                }
                              } else {
#line 858
                                tmp___70 = 0;
                              }
                            }
#line 858
                            if (tmp___70) {
#line 858
                              tmp___65 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                          "TPOS");
#line 858
                              tmp___69 = tmp___65;
                            } else {
#line 858
                              tmp___68 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                          "TPOS");
#line 858
                              tmp___69 = tmp___68;
                            }
                          } else {
#line 858
                            tmp___68 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                        "TPOS");
#line 858
                            tmp___69 = tmp___68;
                          }
#line 858
                          if (tmp___69) {
#line 866
                            if (0) {
#line 866
                              __s1_len___5 = strlen((char const   *)(pid3frame->id));
#line 866
                              __s2_len___5 = strlen("TRCK");
#line 866
                              if (! ((unsigned int )((void const   *)(pid3frame->id + 1)) - (unsigned int )((void const   *)(pid3frame->id)) == 1U)) {
                                goto _L___13;
                              } else {
#line 866
                                if (__s1_len___5 >= 4U) {
                                  _L___13: /* CIL Label */ 
#line 866
                                  if (! ((unsigned int )((void const   *)("TRCK" + 1)) - (unsigned int )((void const   *)"TRCK") == 1U)) {
#line 866
                                    tmp___63 = 1;
                                  } else {
#line 866
                                    if (__s2_len___5 >= 4U) {
#line 866
                                      tmp___63 = 1;
                                    } else {
#line 866
                                      tmp___63 = 0;
                                    }
                                  }
                                } else {
#line 866
                                  tmp___63 = 0;
                                }
                              }
#line 866
                              if (tmp___63) {
#line 866
                                tmp___58 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                            "TRCK");
#line 866
                                tmp___62 = tmp___58;
                              } else {
#line 866
                                tmp___61 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                            "TRCK");
#line 866
                                tmp___62 = tmp___61;
                              }
                            } else {
#line 866
                              tmp___61 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                          "TRCK");
#line 866
                              tmp___62 = tmp___61;
                            }
#line 866
                            if (tmp___62) {
#line 874
                              if (0) {
#line 874
                                __s1_len___4 = strlen((char const   *)(pid3frame->id));
#line 874
                                __s2_len___4 = strlen("TDRC");
#line 874
                                if (! ((unsigned int )((void const   *)(pid3frame->id + 1)) - (unsigned int )((void const   *)(pid3frame->id)) == 1U)) {
                                  goto _L___11;
                                } else {
#line 874
                                  if (__s1_len___4 >= 4U) {
                                    _L___11: /* CIL Label */ 
#line 874
                                    if (! ((unsigned int )((void const   *)("TDRC" + 1)) - (unsigned int )((void const   *)"TDRC") == 1U)) {
#line 874
                                      tmp___56 = 1;
                                    } else {
#line 874
                                      if (__s2_len___4 >= 4U) {
#line 874
                                        tmp___56 = 1;
                                      } else {
#line 874
                                        tmp___56 = 0;
                                      }
                                    }
                                  } else {
#line 874
                                    tmp___56 = 0;
                                  }
                                }
#line 874
                                if (tmp___56) {
#line 874
                                  tmp___51 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                              "TDRC");
#line 874
                                  tmp___55 = tmp___51;
                                } else {
#line 874
                                  tmp___54 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                              "TDRC");
#line 874
                                  tmp___55 = tmp___54;
                                }
                              } else {
#line 874
                                tmp___54 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                            "TDRC");
#line 874
                                tmp___55 = tmp___54;
                              }
#line 874
                              if (tmp___55) {
#line 877
                                if (0) {
#line 877
                                  __s1_len___3 = strlen((char const   *)(pid3frame->id));
#line 877
                                  __s2_len___3 = strlen("TLEN");
#line 877
                                  if (! ((unsigned int )((void const   *)(pid3frame->id + 1)) - (unsigned int )((void const   *)(pid3frame->id)) == 1U)) {
                                    goto _L___9;
                                  } else {
#line 877
                                    if (__s1_len___3 >= 4U) {
                                      _L___9: /* CIL Label */ 
#line 877
                                      if (! ((unsigned int )((void const   *)("TLEN" + 1)) - (unsigned int )((void const   *)"TLEN") == 1U)) {
#line 877
                                        tmp___49 = 1;
                                      } else {
#line 877
                                        if (__s2_len___3 >= 4U) {
#line 877
                                          tmp___49 = 1;
                                        } else {
#line 877
                                          tmp___49 = 0;
                                        }
                                      }
                                    } else {
#line 877
                                      tmp___49 = 0;
                                    }
                                  }
#line 877
                                  if (tmp___49) {
#line 877
                                    tmp___44 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                                "TLEN");
#line 877
                                    tmp___48 = tmp___44;
                                  } else {
#line 877
                                    tmp___47 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                                "TLEN");
#line 877
                                    tmp___48 = tmp___47;
                                  }
                                } else {
#line 877
                                  tmp___47 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                              "TLEN");
#line 877
                                  tmp___48 = tmp___47;
                                }
#line 877
                                if (tmp___48) {
#line 880
                                  if (0) {
#line 880
                                    __s1_len___2 = strlen((char const   *)(pid3frame->id));
#line 880
                                    __s2_len___2 = strlen("TBPM");
#line 880
                                    if (! ((unsigned int )((void const   *)(pid3frame->id + 1)) - (unsigned int )((void const   *)(pid3frame->id)) == 1U)) {
                                      goto _L___7;
                                    } else {
#line 880
                                      if (__s1_len___2 >= 4U) {
                                        _L___7: /* CIL Label */ 
#line 880
                                        if (! ((unsigned int )((void const   *)("TBPM" + 1)) - (unsigned int )((void const   *)"TBPM") == 1U)) {
#line 880
                                          tmp___42 = 1;
                                        } else {
#line 880
                                          if (__s2_len___2 >= 4U) {
#line 880
                                            tmp___42 = 1;
                                          } else {
#line 880
                                            tmp___42 = 0;
                                          }
                                        }
                                      } else {
#line 880
                                        tmp___42 = 0;
                                      }
                                    }
#line 880
                                    if (tmp___42) {
#line 880
                                      tmp___37 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                                  "TBPM");
#line 880
                                      tmp___41 = tmp___37;
                                    } else {
#line 880
                                      tmp___40 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                                  "TBPM");
#line 880
                                      tmp___41 = tmp___40;
                                    }
                                  } else {
#line 880
                                    tmp___40 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                                "TBPM");
#line 880
                                    tmp___41 = tmp___40;
                                  }
#line 880
                                  if (tmp___41) {
#line 883
                                    if (0) {
#line 883
                                      __s1_len___1 = strlen((char const   *)(pid3frame->id));
#line 883
                                      __s2_len___1 = strlen("TCMP");
#line 883
                                      if (! ((unsigned int )((void const   *)(pid3frame->id + 1)) - (unsigned int )((void const   *)(pid3frame->id)) == 1U)) {
                                        goto _L___5;
                                      } else {
#line 883
                                        if (__s1_len___1 >= 4U) {
                                          _L___5: /* CIL Label */ 
#line 883
                                          if (! ((unsigned int )((void const   *)("TCMP" + 1)) - (unsigned int )((void const   *)"TCMP") == 1U)) {
#line 883
                                            tmp___35 = 1;
                                          } else {
#line 883
                                            if (__s2_len___1 >= 4U) {
#line 883
                                              tmp___35 = 1;
                                            } else {
#line 883
                                              tmp___35 = 0;
                                            }
                                          }
                                        } else {
#line 883
                                          tmp___35 = 0;
                                        }
                                      }
#line 883
                                      if (tmp___35) {
#line 883
                                        tmp___30 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                                    "TCMP");
#line 883
                                        tmp___34 = tmp___30;
                                      } else {
#line 883
                                        tmp___33 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                                    "TCMP");
#line 883
                                        tmp___34 = tmp___33;
                                      }
                                    } else {
#line 883
                                      tmp___33 = __builtin_strcmp((char const   *)(pid3frame->id),
                                                                  "TCMP");
#line 883
                                      tmp___34 = tmp___33;
                                    }
#line 883
                                    if (! tmp___34) {
#line 884
                                      tmp___28 = atoi((char const   *)utf8_text);
#line 884
                                      pmp3->compilation = (char )tmp___28;
#line 885
                                      err_log(9, 8U, (char *)"Compilation: %d\n",
                                              pmp3->compilation);
                                    }
                                  } else {
#line 881
                                    pmp3->bpm = atoi((char const   *)utf8_text);
#line 882
                                    err_log(9, 8U, (char *)"BPM: %d\n", pmp3->bpm);
                                  }
                                } else {
#line 878
                                  pmp3->song_length = atoi((char const   *)utf8_text);
#line 879
                                  err_log(9, 8U, (char *)" Length: %d\n", pmp3->song_length);
                                }
                              } else {
#line 875
                                pmp3->year = atoi((char const   *)utf8_text);
#line 876
                                err_log(9, 8U, (char *)" Year: %d\n", pmp3->year);
                              }
                            } else {
#line 867
                              tmp = (char *)utf8_text;
#line 868
                              __strsep_g(& tmp, "/");
#line 869
                              if (tmp) {
#line 870
                                pmp3->total_tracks = atoi((char const   *)tmp);
                              }
#line 872
                              pmp3->track = atoi((char const   *)((char *)utf8_text));
#line 873
                              err_log(9, 8U, (char *)" Track %d of %d\n", pmp3->track,
                                      pmp3->total_tracks);
                            }
                          } else {
#line 859
                            tmp = (char *)utf8_text;
#line 860
                            __strsep_g(& tmp, "/");
#line 861
                            if (tmp) {
#line 862
                              pmp3->total_discs = atoi((char const   *)tmp);
                            }
#line 864
                            pmp3->disc = atoi((char const   *)((char *)utf8_text));
#line 865
                            err_log(9, 8U, (char *)" Disc %d of %d\n", pmp3->disc,
                                    pmp3->total_discs);
                          }
                        } else {
#line 855
                          used = 1;
#line 856
                          pmp3->comment = (char *)utf8_text;
#line 857
                          err_log(9, 8U, (char *)" Comment: %s\n", pmp3->comment);
                        }
                      } else {
#line 831
                        used = 1;
#line 832
                        pmp3->genre = (char *)utf8_text;
#line 833
                        got_numeric_genre = 0;
#line 834
                        err_log(9, 8U, (char *)" Genre: %s\n", utf8_text);
#line 835
                        if (pmp3->genre) {
#line 836
                          tmp___21 = strlen((char const   *)pmp3->genre);
#line 836
                          if (tmp___21) {
#line 839
                            tmp___20 = __ctype_b_loc();
#line 839
                            if ((int const   )*(*tmp___20 + (int )*(pmp3->genre + 0)) & 2048) {
#line 840
                              genre = atoi((char const   *)pmp3->genre);
#line 841
                              got_numeric_genre = 1;
                            } else {
#line 842
                              if ((int )*(pmp3->genre + 0) == 40) {
#line 842
                                tmp___19 = __ctype_b_loc();
#line 842
                                if ((int const   )*(*tmp___19 + (int )*(pmp3->genre + 1)) & 2048) {
#line 843
                                  genre = atoi((char const   *)(pmp3->genre + 1));
#line 844
                                  got_numeric_genre = 1;
                                }
                              }
                            }
                          } else {
#line 837
                            genre = 148;
#line 838
                            got_numeric_genre = 1;
                          }
#line 847
                          if (got_numeric_genre) {
#line 848
                            if (genre < 0) {
#line 849
                              genre = 148;
                            } else {
#line 848
                              if (genre > 148) {
#line 849
                                genre = 148;
                              }
                            }
#line 850
                            free((void *)pmp3->genre);
#line 851
                            tmp___27 = __strdup((char const   *)scan_winamp_genre[genre]);
#line 851
                            pmp3->genre = tmp___27;
                          }
                        }
                      }
                    } else {
#line 827
                      used = 1;
#line 828
                      pmp3->conductor = (char *)utf8_text;
#line 829
                      err_log(9, 8U, (char *)" Conductor: %s\n", utf8_text);
                    }
                  } else {
#line 823
                    used = 1;
#line 824
                    pmp3->orchestra = (char *)utf8_text;
#line 825
                    err_log(9, 8U, (char *)" Orchestra: %s\n", utf8_text);
                  }
                } else {
#line 819
                  used = 1;
#line 820
                  pmp3->grouping = (char *)utf8_text;
#line 821
                  err_log(9, 8U, (char *)" Grouping: %s\n", utf8_text);
                }
              } else {
#line 815
                used = 1;
#line 816
                pmp3->composer = (char *)utf8_text;
#line 817
                err_log(9, 8U, (char *)" Composer: %s\n", utf8_text);
              }
            } else {
#line 811
              used = 1;
#line 812
              pmp3->album = (char *)utf8_text;
#line 813
              err_log(9, 8U, (char *)" Album: %s\n", utf8_text);
            }
          } else {
#line 807
            used = 1;
#line 808
            pmp3->artist = (char *)utf8_text;
#line 809
            err_log(9, 8U, (char *)" Artist: %s\n", utf8_text);
          }
        } else {
#line 803
          used = 1;
#line 804
          pmp3->title = (char *)utf8_text;
#line 805
          err_log(9, 8U, (char *)" Title: %s\n", utf8_text);
        }
      }
    }
#line 891
    if (! used) {
#line 891
      if (have_utf8) {
#line 891
        if (utf8_text) {
#line 892
          free((void *)utf8_text);
        }
      }
    }
#line 895
    if (0) {
#line 895
      __s1_len___16 = strlen((char const   *)(pid3frame->id));
#line 895
      __s2_len___16 = strlen("COMM");
#line 895
      if (! ((unsigned int )((void const   *)(pid3frame->id + 1)) - (unsigned int )((void const   *)(pid3frame->id)) == 1U)) {
        goto _L___36;
      } else {
#line 895
        if (__s1_len___16 >= 4U) {
          _L___36: /* CIL Label */ 
#line 895
          if (! ((unsigned int )((void const   *)("COMM" + 1)) - (unsigned int )((void const   *)"COMM") == 1U)) {
#line 895
            tmp___143 = 1;
          } else {
#line 895
            if (__s2_len___16 >= 4U) {
#line 895
              tmp___143 = 1;
            } else {
#line 895
              tmp___143 = 0;
            }
          }
        } else {
#line 895
          tmp___143 = 0;
        }
      }
#line 895
      if (tmp___143) {
#line 895
        tmp___138 = __builtin_strcmp((char const   *)(pid3frame->id), "COMM");
#line 895
        tmp___142 = tmp___138;
      } else {
#line 895
        tmp___141 = __builtin_strcmp((char const   *)(pid3frame->id), "COMM");
#line 895
        tmp___142 = tmp___141;
      }
    } else {
#line 895
      tmp___141 = __builtin_strcmp((char const   *)(pid3frame->id), "COMM");
#line 895
      tmp___142 = tmp___141;
    }
#line 895
    if (! tmp___142) {
#line 895
      if (pid3frame->nfields == 4U) {
#line 905
        native_text = id3_field_getstring((union id3_field  const  *)(pid3frame->fields + 2));
#line 906
        if (native_text) {
#line 907
          tmp___134 = id3_ucs4_utf8duplicate(native_text);
#line 907
          utf8_text = (unsigned char *)tmp___134;
#line 908
          if (utf8_text) {
#line 908
            tmp___136 = strncasecmp((char const   *)utf8_text, "iTun", 4U);
#line 908
            if (tmp___136 != 0) {
#line 910
              if (utf8_text) {
#line 911
                free((void *)utf8_text);
              }
#line 913
              native_text = id3_field_getfullstring((union id3_field  const  *)(pid3frame->fields + 3));
#line 914
              if (native_text) {
#line 915
                if (pmp3->comment) {
#line 916
                  free((void *)pmp3->comment);
                }
#line 917
                tmp___135 = id3_ucs4_utf8duplicate(native_text);
#line 917
                utf8_text = (unsigned char *)tmp___135;
#line 918
                if (utf8_text) {
#line 919
                  pmp3->comment = (char *)utf8_text;
                }
              }
            } else {
              goto _L___34;
            }
          } else {
            _L___34: /* CIL Label */ 
#line 924
            if (utf8_text) {
#line 925
              free((void *)utf8_text);
            }
          }
        }
      }
    }
#line 930
    index___0 ++;
  }
#line 933
  id3_file_close(pid3file);
#line 934
  err_log(9, 8U, (char *)"Got id3 tag successfully\n");
#line 935
  return (0);
}
}
#line 943 "mp3-scanner.c"
static int scan_freetags(MP3FILE *pmp3 ) 
{ 

  {
#line 944
  if (pmp3->title) {
#line 944
    free((void *)pmp3->title);
  }
#line 945
  if (pmp3->artist) {
#line 945
    free((void *)pmp3->artist);
  }
#line 946
  if (pmp3->album) {
#line 946
    free((void *)pmp3->album);
  }
#line 947
  if (pmp3->genre) {
#line 947
    free((void *)pmp3->genre);
  }
#line 948
  if (pmp3->comment) {
#line 948
    free((void *)pmp3->comment);
  }
#line 949
  if (pmp3->type) {
#line 949
    free((void *)pmp3->type);
  }
#line 950
  if (pmp3->composer) {
#line 950
    free((void *)pmp3->composer);
  }
#line 951
  if (pmp3->orchestra) {
#line 951
    free((void *)pmp3->orchestra);
  }
#line 952
  if (pmp3->conductor) {
#line 952
    free((void *)pmp3->conductor);
  }
#line 953
  if (pmp3->grouping) {
#line 953
    free((void *)pmp3->grouping);
  }
#line 954
  if (pmp3->description) {
#line 954
    free((void *)pmp3->description);
  }
#line 956
  return (0);
}
}
#line 965 "mp3-scanner.c"
static int scan_get_fileinfo(char *file , MP3FILE *pmp3 ) 
{ FILE *infile ;
  off_t file_size ;
  taghandler *hdl ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 972
  hdl = taghandlers;
#line 972
  while (hdl->suffix) {
#line 973
    if (0) {
#line 973
      __s1_len = strlen((char const   *)hdl->suffix);
#line 973
      __s2_len = strlen((char const   *)pmp3->type);
#line 973
      if (! ((unsigned int )((void const   *)(hdl->suffix + 1)) - (unsigned int )((void const   *)hdl->suffix) == 1U)) {
        goto _L___0;
      } else {
#line 973
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 973
          if (! ((unsigned int )((void const   *)(pmp3->type + 1)) - (unsigned int )((void const   *)pmp3->type) == 1U)) {
#line 973
            tmp___5 = 1;
          } else {
#line 973
            if (__s2_len >= 4U) {
#line 973
              tmp___5 = 1;
            } else {
#line 973
              tmp___5 = 0;
            }
          }
        } else {
#line 973
          tmp___5 = 0;
        }
      }
#line 973
      if (tmp___5) {
#line 973
        tmp___0 = __builtin_strcmp((char const   *)hdl->suffix, (char const   *)pmp3->type);
#line 973
        tmp___4 = tmp___0;
      } else {
#line 973
        tmp___3 = __builtin_strcmp((char const   *)hdl->suffix, (char const   *)pmp3->type);
#line 973
        tmp___4 = tmp___3;
      }
    } else {
#line 973
      tmp___3 = __builtin_strcmp((char const   *)hdl->suffix, (char const   *)pmp3->type);
#line 973
      tmp___4 = tmp___3;
    }
#line 973
    if (! tmp___4) {
#line 974
      break;
    }
#line 972
    hdl ++;
  }
#line 976
  if (hdl->files) {
#line 977
    tmp___6 = (*(hdl->files))(file, pmp3);
#line 977
    return (tmp___6);
  }
#line 980
  infile = fopen((char const   * __restrict  )file, (char const   * __restrict  )"rb");
#line 980
  if (! infile) {
#line 981
    err_log(2, 8U, (char *)"Could not open %s for reading\n", file);
#line 982
    return (-1);
  }
#line 986
  fseek(infile, 0L, 2);
#line 987
  file_size = ftell(infile);
#line 988
  fseek(infile, 0L, 0);
#line 990
  pmp3->file_size = (int )file_size;
#line 992
  fclose(infile);
#line 993
  return (0);
}
}
#line 1004 "mp3-scanner.c"
off_t aac_drilltoatom(FILE *aac_fp , char *atom_path , unsigned int *atom_length ) 
{ long atom_offset ;
  off_t file_size ;
  char *cur_p ;
  char *end_p ;
  char atom_name[5] ;
  long tmp ;
  char *tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___10 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  long tmp___23 ;

  {
#line 1011
  fseek(aac_fp, 0L, 2);
#line 1012
  file_size = ftell(aac_fp);
#line 1013
  rewind(aac_fp);
#line 1015
  end_p = atom_path;
#line 1016
  while ((int )*end_p != 0) {
#line 1018
    end_p ++;
  }
#line 1020
  atom_name[4] = (char )'\000';
#line 1021
  cur_p = atom_path;
#line 1023
  while ((unsigned int )cur_p != (unsigned int )((void *)0)) {
#line 1025
    if (end_p - cur_p < 4) {
#line 1027
      return (-1L);
    }
#line 1029
    __builtin_strncpy(atom_name, (char const   *)cur_p, 4U);
#line 1030
    atom_offset = scan_aac_findatom(aac_fp, file_size, atom_name, (int *)atom_length);
#line 1031
    if (atom_offset == -1L) {
#line 1033
      return (-1L);
    }
#line 1035
    tmp = ftell(aac_fp);
#line 1035
    err_log(9, 8U, (char *)"Found %s atom at off %ld.\n", atom_name, tmp - 8L);
#line 1036
    tmp___1 = __builtin_strchr(cur_p, ':');
#line 1036
    cur_p = tmp___1;
#line 1037
    if ((unsigned int )cur_p != (unsigned int )((void *)0)) {
#line 1039
      cur_p ++;
#line 1044
      if (0) {
#line 1044
        __s1_len___1 = strlen((char const   *)(atom_name));
#line 1044
        __s2_len___1 = strlen("meta");
#line 1044
        if (! ((unsigned int )((void const   *)(atom_name + 1)) - (unsigned int )((void const   *)(atom_name)) == 1U)) {
          goto _L___4;
        } else {
#line 1044
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 1044
            if (! ((unsigned int )((void const   *)("meta" + 1)) - (unsigned int )((void const   *)"meta") == 1U)) {
#line 1044
              tmp___22 = 1;
            } else {
#line 1044
              if (__s2_len___1 >= 4U) {
#line 1044
                tmp___22 = 1;
              } else {
#line 1044
                tmp___22 = 0;
              }
            }
          } else {
#line 1044
            tmp___22 = 0;
          }
        }
#line 1044
        if (tmp___22) {
#line 1044
          tmp___17 = __builtin_strcmp((char const   *)(atom_name), "meta");
#line 1044
          tmp___21 = tmp___17;
        } else {
#line 1044
          tmp___20 = __builtin_strcmp((char const   *)(atom_name), "meta");
#line 1044
          tmp___21 = tmp___20;
        }
      } else {
#line 1044
        tmp___20 = __builtin_strcmp((char const   *)(atom_name), "meta");
#line 1044
        tmp___21 = tmp___20;
      }
#line 1044
      if (tmp___21) {
#line 1046
        if (0) {
#line 1046
          __s1_len___0 = strlen((char const   *)(atom_name));
#line 1046
          __s2_len___0 = strlen("stsd");
#line 1046
          if (! ((unsigned int )((void const   *)(atom_name + 1)) - (unsigned int )((void const   *)(atom_name)) == 1U)) {
            goto _L___2;
          } else {
#line 1046
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 1046
              if (! ((unsigned int )((void const   *)("stsd" + 1)) - (unsigned int )((void const   *)"stsd") == 1U)) {
#line 1046
                tmp___15 = 1;
              } else {
#line 1046
                if (__s2_len___0 >= 4U) {
#line 1046
                  tmp___15 = 1;
                } else {
#line 1046
                  tmp___15 = 0;
                }
              }
            } else {
#line 1046
              tmp___15 = 0;
            }
          }
#line 1046
          if (tmp___15) {
#line 1046
            tmp___10 = __builtin_strcmp((char const   *)(atom_name), "stsd");
#line 1046
            tmp___14 = tmp___10;
          } else {
#line 1046
            tmp___13 = __builtin_strcmp((char const   *)(atom_name), "stsd");
#line 1046
            tmp___14 = tmp___13;
          }
        } else {
#line 1046
          tmp___13 = __builtin_strcmp((char const   *)(atom_name), "stsd");
#line 1046
          tmp___14 = tmp___13;
        }
#line 1046
        if (tmp___14) {
#line 1048
          if (0) {
#line 1048
            __s1_len = strlen((char const   *)(atom_name));
#line 1048
            __s2_len = strlen("mp4a");
#line 1048
            if (! ((unsigned int )((void const   *)(atom_name + 1)) - (unsigned int )((void const   *)(atom_name)) == 1U)) {
              goto _L___0;
            } else {
#line 1048
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 1048
                if (! ((unsigned int )((void const   *)("mp4a" + 1)) - (unsigned int )((void const   *)"mp4a") == 1U)) {
#line 1048
                  tmp___8 = 1;
                } else {
#line 1048
                  if (__s2_len >= 4U) {
#line 1048
                    tmp___8 = 1;
                  } else {
#line 1048
                    tmp___8 = 0;
                  }
                }
              } else {
#line 1048
                tmp___8 = 0;
              }
            }
#line 1048
            if (tmp___8) {
#line 1048
              tmp___3 = __builtin_strcmp((char const   *)(atom_name), "mp4a");
#line 1048
              tmp___7 = tmp___3;
            } else {
#line 1048
              tmp___6 = __builtin_strcmp((char const   *)(atom_name), "mp4a");
#line 1048
              tmp___7 = tmp___6;
            }
          } else {
#line 1048
            tmp___6 = __builtin_strcmp((char const   *)(atom_name), "mp4a");
#line 1048
            tmp___7 = tmp___6;
          }
#line 1048
          if (! tmp___7) {
#line 1049
            fseek(aac_fp, 28L, 1);
          }
        } else {
#line 1047
          fseek(aac_fp, 8L, 1);
        }
      } else {
#line 1045
        fseek(aac_fp, 4L, 1);
      }
    }
  }
#line 1054
  tmp___23 = ftell(aac_fp);
#line 1054
  return (tmp___23 - 8L);
}
}
#line 1062 "mp3-scanner.c"
static int scan_get_urlfileinfo(char *file , MP3FILE *pmp3 ) 
{ FILE *infile ;
  char *head ;
  char *tail ;
  char linebuffer[256] ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___3 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___12 ;
  char *tmp___18 ;

  {
#line 1067
  err_log(9, 8U, (char *)"Getting URL file info\n");
#line 1069
  infile = fopen((char const   * __restrict  )file, (char const   * __restrict  )"rb");
#line 1069
  if (! infile) {
#line 1070
    err_log(2, 8U, (char *)"Could not open %s for reading\n", file);
#line 1071
    return (-1);
  }
#line 1074
  fgets((char * __restrict  )(linebuffer), (int )sizeof(linebuffer), (FILE * __restrict  )infile);
#line 1075
  while (1) {
#line 1075
    tmp___0 = strlen((char const   *)(linebuffer));
#line 1075
    if (! ((int )linebuffer[tmp___0 - 1U] == 10)) {
#line 1075
      tmp___1 = strlen((char const   *)(linebuffer));
#line 1075
      if (! ((int )linebuffer[tmp___1 - 1U] == 13)) {
#line 1075
        break;
      }
    }
#line 1077
    tmp = strlen((char const   *)(linebuffer));
#line 1077
    linebuffer[tmp - 1U] = (char )'\000';
  }
#line 1080
  head = linebuffer;
#line 1081
  tmp___3 = __builtin_strchr(head, ',');
#line 1081
  tail = tmp___3;
#line 1082
  if (! tail) {
#line 1083
    err_log(1, 8U, (char *)"Badly formatted .url file - must be bitrate,descr,url\n");
#line 1084
    fclose(infile);
#line 1085
    return (-1);
  }
#line 1088
  pmp3->bitrate = atoi((char const   *)head);
#line 1089
  tail ++;
#line 1089
  head = tail;
#line 1090
  tmp___5 = __builtin_strchr(head, ',');
#line 1090
  tail = tmp___5;
#line 1091
  if (! tail) {
#line 1092
    err_log(1, 8U, (char *)"Badly formatted .url file - must be bitrate,descr,url\n");
#line 1093
    fclose(infile);
#line 1094
    return (-1);
  }
#line 1097
  tmp___6 = tail;
#line 1097
  tail ++;
#line 1097
  *tmp___6 = (char )'\000';
#line 1099
  tmp___12 = __strdup((char const   *)head);
#line 1099
  pmp3->title = tmp___12;
#line 1100
  tmp___18 = __strdup((char const   *)tail);
#line 1100
  pmp3->url = tmp___18;
#line 1101
  fclose(infile);
#line 1103
  err_log(9, 8U, (char *)"  Title:    %s\n", pmp3->title);
#line 1104
  err_log(9, 8U, (char *)"  Bitrate:  %d\n", pmp3->bitrate);
#line 1105
  err_log(9, 8U, (char *)"  URL:      %s\n", pmp3->url);
#line 1107
  return (0);
}
}
#line 1115 "mp3-scanner.c"
static int scan_get_aacfileinfo(char *file , MP3FILE *pmp3 ) 
{ FILE *infile ;
  long atom_offset ;
  int atom_length ;
  int sample_size ;
  int samples ;
  unsigned int bit_rate ;
  off_t file_size ;
  int ms ;
  unsigned char buffer___0[2] ;
  int time___0 ;
  register unsigned int __v ;
  register unsigned int __x ;
  time_t tmp ;
  register unsigned int __v___0 ;
  register unsigned int __x___0 ;
  time_t tmp___0 ;
  register unsigned int __v___1 ;
  register unsigned int __x___1 ;
  register unsigned int __v___2 ;
  register unsigned int __x___2 ;
  long tmp___1 ;
  register unsigned int __v___3 ;
  register unsigned int __x___3 ;

  {
#line 1125
  time___0 = 0;
#line 1127
  err_log(9, 8U, (char *)"Getting AAC file info\n");
#line 1129
  infile = fopen((char const   * __restrict  )file, (char const   * __restrict  )"rb");
#line 1129
  if (! infile) {
#line 1130
    err_log(2, 8U, (char *)"Could not open %s for reading\n", file);
#line 1131
    return (-1);
  }
#line 1134
  fseek(infile, 0L, 2);
#line 1135
  file_size = ftell(infile);
#line 1136
  fseek(infile, 0L, 0);
#line 1138
  pmp3->file_size = (int )file_size;
#line 1141
  atom_offset = aac_drilltoatom(infile, (char *)"moov:mvhd", (unsigned int *)(& atom_length));
#line 1142
  if (atom_offset != -1L) {
#line 1143
    fseek(infile, 4L, 1);
#line 1144
    fread((void * __restrict  )((void *)(& time___0)), sizeof(int ), 1U, (FILE * __restrict  )infile);
#line 1145
    __x = (unsigned int )time___0;
#line 1145
    __asm__  ("bswap %0": "=r" (__v): "0" (__x));
#line 1145
    time___0 = (int )__v;
#line 1146
    tmp = mac_to_unix_time(time___0);
#line 1146
    pmp3->time_added = (int )tmp;
#line 1148
    fread((void * __restrict  )((void *)(& time___0)), sizeof(int ), 1U, (FILE * __restrict  )infile);
#line 1149
    __x___0 = (unsigned int )time___0;
#line 1149
    __asm__  ("bswap %0": "=r" (__v___0): "0" (__x___0));
#line 1149
    time___0 = (int )__v___0;
#line 1150
    tmp___0 = mac_to_unix_time(time___0);
#line 1150
    pmp3->time_modified = (int )tmp___0;
#line 1151
    fread((void * __restrict  )((void *)(& sample_size)), 1U, sizeof(int ), (FILE * __restrict  )infile);
#line 1152
    fread((void * __restrict  )((void *)(& samples)), 1U, sizeof(int ), (FILE * __restrict  )infile);
#line 1154
    __x___1 = (unsigned int )sample_size;
#line 1154
    __asm__  ("bswap %0": "=r" (__v___1): "0" (__x___1));
#line 1154
    sample_size = (int )__v___1;
#line 1155
    __x___2 = (unsigned int )samples;
#line 1155
    __asm__  ("bswap %0": "=r" (__v___2): "0" (__x___2));
#line 1155
    samples = (int )__v___2;
#line 1158
    ms = 1000;
#line 1159
    while (1) {
#line 1159
      if (ms > 9) {
#line 1159
        if (! (! (sample_size % 10))) {
#line 1159
          break;
        }
      } else {
#line 1159
        break;
      }
#line 1160
      sample_size /= 10;
#line 1161
      ms /= 10;
    }
#line 1165
    pmp3->song_length = (samples * ms) / sample_size;
#line 1167
    err_log(9, 8U, (char *)"Song length: %d seconds\n", pmp3->song_length / 1000);
  }
#line 1170
  pmp3->bitrate = 0;
#line 1175
  atom_offset = aac_drilltoatom(infile, (char *)"moov:trak:mdia:minf:stbl:stsd:mp4a",
                                (unsigned int *)(& atom_length));
#line 1176
  if (atom_offset != -1L) {
#line 1177
    fseek(infile, atom_offset + 32L, 0);
#line 1182
    fread((void * __restrict  )(buffer___0), sizeof(unsigned char ), 2U, (FILE * __restrict  )infile);
#line 1184
    pmp3->samplerate = ((int )buffer___0[0] << 8) | (int )buffer___0[1];
#line 1187
    fseek(infile, 2L, 1);
#line 1191
    tmp___1 = ftell(infile);
#line 1191
    atom_offset = scan_aac_findatom(infile, (long )atom_length - (tmp___1 - atom_offset),
                                    (char *)"esds", & atom_length);
#line 1193
    if (atom_offset != -1L) {
#line 1194
      fseek(infile, atom_offset + 22L, 1);
#line 1196
      fread((void * __restrict  )((void *)(& bit_rate)), sizeof(unsigned int ), 1U,
            (FILE * __restrict  )infile);
#line 1198
      __x___3 = bit_rate;
#line 1198
      __asm__  ("bswap %0": "=r" (__v___3): "0" (__x___3));
#line 1198
      pmp3->bitrate = (int )(__v___3 / 1000U);
    } else {
#line 1200
      err_log(9, 8U, (char *)"Could not find \'esds\' atom to determine bit rate.\n");
    }
  } else {
#line 1204
    err_log(9, 8U, (char *)"Could not find \'mp4a\' atom to determine sample rate.\n");
  }
#line 1208
  if (pmp3->bitrate == 0) {
#line 1210
    err_log(9, 8U, (char *)"Could not find \'esds\' atom. Calculating bit rate.\n");
#line 1212
    atom_offset = aac_drilltoatom(infile, (char *)"mdat", (unsigned int *)(& atom_length));
#line 1214
    if (atom_offset != -1L) {
#line 1214
      if (pmp3->song_length) {
#line 1215
        pmp3->bitrate = atom_length / ((pmp3->song_length / 1000) * 128);
      }
    }
  }
#line 1220
  fclose(infile);
#line 1221
  return (0);
}
}
#line 1233 "mp3-scanner.c"
static int scan_decode_mp3_frame(unsigned char *frame , SCAN_FRAMEINFO *pfi ) 
{ int ver ;
  int layer_index ;
  int sample_index ;
  int bitrate_index ;
  int samplerate_index ;

  {
#line 1240
  if ((int )*(frame + 0) != 255) {
#line 1241
    pfi->is_valid = 0;
#line 1242
    return (-1);
  } else {
#line 1240
    if ((int )*(frame + 1) < 224) {
#line 1241
      pfi->is_valid = 0;
#line 1242
      return (-1);
    }
  }
#line 1245
  ver = ((int )*(frame + 1) & 24) >> 3;
#line 1246
  pfi->layer = 4 - (((int )*(frame + 1) & 6) >> 1);
#line 1248
  layer_index = -1;
#line 1249
  sample_index = -1;
#line 1251
  switch (ver) {
  case 0: 
#line 1253
  pfi->version = 2.5;
#line 1254
  sample_index = 2;
#line 1255
  if (pfi->layer == 1) {
#line 1256
    layer_index = 3;
  }
#line 1257
  if (pfi->layer == 2) {
#line 1258
    layer_index = 4;
  } else {
#line 1257
    if (pfi->layer == 3) {
#line 1258
      layer_index = 4;
    }
  }
#line 1259
  break;
  case 2: 
#line 1261
  pfi->version = 2.0;
#line 1262
  sample_index = 1;
#line 1263
  if (pfi->layer == 1) {
#line 1264
    layer_index = 3;
  }
#line 1265
  if (pfi->layer == 2) {
#line 1266
    layer_index = 4;
  } else {
#line 1265
    if (pfi->layer == 3) {
#line 1266
      layer_index = 4;
    }
  }
#line 1267
  break;
  case 3: 
#line 1269
  pfi->version = 1.0;
#line 1270
  sample_index = 0;
#line 1271
  if (pfi->layer == 1) {
#line 1272
    layer_index = 0;
  }
#line 1273
  if (pfi->layer == 2) {
#line 1274
    layer_index = 1;
  }
#line 1275
  if (pfi->layer == 3) {
#line 1276
    layer_index = 2;
  }
#line 1277
  break;
  }
#line 1280
  if (layer_index < 0) {
#line 1281
    pfi->is_valid = 0;
#line 1282
    return (-1);
  } else {
#line 1280
    if (layer_index > 4) {
#line 1281
      pfi->is_valid = 0;
#line 1282
      return (-1);
    }
  }
#line 1285
  if (sample_index < 0) {
#line 1286
    pfi->is_valid = 0;
#line 1287
    return (-1);
  } else {
#line 1285
    if (sample_index > 2) {
#line 1286
      pfi->is_valid = 0;
#line 1287
      return (-1);
    }
  }
#line 1290
  if (pfi->layer == 1) {
#line 1290
    pfi->samples_per_frame = 384;
  }
#line 1291
  if (pfi->layer == 2) {
#line 1291
    pfi->samples_per_frame = 1152;
  }
#line 1292
  if (pfi->layer == 3) {
#line 1293
    if (pfi->version == 1.0) {
#line 1294
      pfi->samples_per_frame = 1152;
    } else {
#line 1296
      pfi->samples_per_frame = 576;
    }
  }
#line 1300
  bitrate_index = ((int )*(frame + 2) & 240) >> 4;
#line 1301
  samplerate_index = ((int )*(frame + 2) & 12) >> 2;
#line 1303
  if (bitrate_index == 15) {
#line 1304
    pfi->is_valid = 0;
#line 1305
    return (-1);
  } else {
#line 1303
    if (bitrate_index == 0) {
#line 1304
      pfi->is_valid = 0;
#line 1305
      return (-1);
    }
  }
#line 1308
  if (samplerate_index == 3) {
#line 1309
    pfi->is_valid = 0;
#line 1310
    return (-1);
  }
#line 1313
  pfi->bitrate = scan_br_table[layer_index][bitrate_index];
#line 1314
  pfi->samplerate = scan_sample_table[sample_index][samplerate_index];
#line 1316
  if (((int )*(frame + 3) & (192 >> 6)) == 3) {
#line 1317
    pfi->stereo = 0;
  } else {
#line 1319
    pfi->stereo = 1;
  }
#line 1321
  if ((int )*(frame + 2) & 2) {
#line 1322
    pfi->padding = 1;
  } else {
#line 1324
    pfi->padding = 0;
  }
#line 1327
  if (pfi->version == 1.0) {
#line 1328
    if (pfi->stereo) {
#line 1329
      pfi->xing_offset = 32;
    } else {
#line 1331
      pfi->xing_offset = 17;
    }
  } else {
#line 1334
    if (pfi->stereo) {
#line 1335
      pfi->xing_offset = 17;
    } else {
#line 1337
      pfi->xing_offset = 9;
    }
  }
#line 1341
  pfi->crc_protected = (int )*(frame + 1) & 254;
#line 1343
  if (pfi->layer == 1) {
#line 1344
    pfi->frame_length = (((12 * pfi->bitrate) * 1000) / pfi->samplerate + pfi->padding) * 4;
  } else {
#line 1346
    pfi->frame_length = ((144 * pfi->bitrate) * 1000) / pfi->samplerate + pfi->padding;
  }
#line 1349
  if (pfi->frame_length > 2880) {
#line 1350
    pfi->is_valid = 0;
#line 1351
    return (-1);
  } else {
#line 1349
    if (pfi->frame_length <= 0) {
#line 1350
      pfi->is_valid = 0;
#line 1351
      return (-1);
    }
  }
#line 1354
  pfi->is_valid = 1;
#line 1355
  return (0);
}
}
#line 1366 "mp3-scanner.c"
void scan_get_average_bitrate(FILE *infile , SCAN_FRAMEINFO *pfi ) 
{ off_t file_size ;
  unsigned char frame_buffer[2900] ;
  unsigned char header[4] ;
  int index___0 ;
  int found ;
  off_t pos ;
  SCAN_FRAMEINFO fi ;
  int frame_count ;
  int bitrate_total ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
#line 1370
  index___0 = 0;
#line 1371
  found = 0;
#line 1374
  frame_count = 0;
#line 1375
  bitrate_total = 0;
#line 1377
  err_log(9, 8U, (char *)"Starting averaging bitrate\n");
#line 1379
  fseek(infile, 0L, 2);
#line 1380
  file_size = ftell(infile);
#line 1382
  pos = file_size / 2L;
#line 1385
  fseek(infile, pos, 0);
#line 1386
  tmp = fread((void * __restrict  )(frame_buffer), 1U, sizeof(frame_buffer), (FILE * __restrict  )infile);
#line 1386
  if (tmp != sizeof(frame_buffer)) {
#line 1387
    return;
  }
#line 1389
  while (! found) {
#line 1390
    while (1) {
#line 1390
      if ((int )frame_buffer[index___0] != 255) {
#line 1390
        if (! ((unsigned int )index___0 < sizeof(frame_buffer) - 4U)) {
#line 1390
          break;
        }
      } else {
#line 1390
        break;
      }
#line 1391
      index___0 ++;
    }
#line 1393
    if ((unsigned int )index___0 >= sizeof(frame_buffer) - 4U) {
#line 1394
      err_log(9, 8U, (char *)"Could not find frame... quitting\n");
#line 1395
      return;
    }
#line 1398
    tmp___2 = scan_decode_mp3_frame(& frame_buffer[index___0], & fi);
#line 1398
    if (! tmp___2) {
#line 1400
      fseek(infile, (pos + (off_t )index___0) + (off_t )fi.frame_length, 0);
#line 1401
      tmp___0 = fread((void * __restrict  )(header), 1U, sizeof(header), (FILE * __restrict  )infile);
#line 1401
      if (tmp___0 != sizeof(header)) {
#line 1402
        err_log(9, 8U, (char *)"Could not read frame header\n");
#line 1403
        return;
      }
#line 1406
      tmp___1 = scan_decode_mp3_frame(header, & fi);
#line 1406
      if (! tmp___1) {
#line 1407
        found = 1;
      }
    }
#line 1410
    if (! found) {
#line 1411
      index___0 ++;
    }
  }
#line 1414
  pos += (off_t )index___0;
#line 1417
  while (frame_count < 10) {
#line 1418
    fseek(infile, pos, 0);
#line 1419
    tmp___3 = fread((void * __restrict  )(header), 1U, sizeof(header), (FILE * __restrict  )infile);
#line 1419
    if (tmp___3 != sizeof(header)) {
#line 1420
      err_log(9, 8U, (char *)"Could not read frame header\n");
#line 1421
      return;
    }
#line 1423
    tmp___4 = scan_decode_mp3_frame(header, & fi);
#line 1423
    if (tmp___4) {
#line 1424
      err_log(9, 8U, (char *)"Invalid frame header while averaging\n");
#line 1425
      return;
    }
#line 1428
    bitrate_total += fi.bitrate;
#line 1429
    frame_count ++;
#line 1430
    pos += (off_t )fi.frame_length;
  }
#line 1433
  err_log(9, 8U, (char *)"Old bitrate: %d\n", pfi->bitrate);
#line 1434
  pfi->bitrate = bitrate_total / frame_count;
#line 1435
  err_log(9, 8U, (char *)"New bitrate: %d\n", pfi->bitrate);
#line 1437
  return;
}
}
#line 1450 "mp3-scanner.c"
void scan_get_frame_count(FILE *infile , SCAN_FRAMEINFO *pfi ) 
{ int pos ;
  int frames ;
  unsigned char frame_buffer[4] ;
  SCAN_FRAMEINFO fi ;
  off_t file_size ;
  int err ;
  int cbr ;
  int last_bitrate ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 1452
  frames = 0;
#line 1456
  err = 0;
#line 1457
  cbr = 1;
#line 1458
  last_bitrate = 0;
#line 1460
  err_log(9, 8U, (char *)"Starting frame count\n");
#line 1462
  fseek(infile, 0L, 2);
#line 1463
  file_size = ftell(infile);
#line 1465
  pos = pfi->frame_offset;
#line 1467
  while (1) {
#line 1468
    err = 1;
#line 1469
    err_log(10, 8U, (char *)"Seeking to %d\n", pos);
#line 1471
    fseek(infile, (long )pos, 0);
#line 1472
    tmp___0 = fread((void * __restrict  )(frame_buffer), 1U, sizeof(frame_buffer),
                    (FILE * __restrict  )infile);
#line 1472
    if (tmp___0 == sizeof(frame_buffer)) {
#line 1474
      tmp = scan_decode_mp3_frame(frame_buffer, & fi);
#line 1474
      if (! tmp) {
#line 1475
        frames ++;
#line 1476
        pos += fi.frame_length;
#line 1477
        err = 0;
#line 1479
        if (last_bitrate) {
#line 1479
          if (fi.bitrate != last_bitrate) {
#line 1480
            cbr = 0;
          }
        }
#line 1481
        last_bitrate = fi.bitrate;
#line 1484
        if (cbr) {
#line 1484
          if (frames > 100) {
#line 1485
            err_log(9, 8U, (char *)"File appears to be CBR... quitting frame count\n");
#line 1486
            return;
          }
        }
      }
    }
#line 1491
    if (err) {
#line 1492
      if ((off_t )pos > file_size - 4096L) {
#line 1493
        pfi->number_of_frames = frames;
#line 1494
        err_log(9, 8U, (char *)"Estimated frame count: %d\n", frames);
#line 1495
        return;
      } else {
#line 1497
        err_log(9, 8U, (char *)"Frame count aborted on error.  Pos=%d, Count=%d\n",
                pos, frames);
#line 1499
        return;
      }
    }
  }
}
}
#line 1513 "mp3-scanner.c"
static int scan_get_mp3fileinfo(char *file , MP3FILE *pmp3 ) 
{ FILE *infile ;
  SCAN_ID3HEADER *pid3 ;
  SCAN_FRAMEINFO fi ;
  unsigned int size ;
  off_t fp_size ;
  off_t file_size ;
  unsigned char buffer___0[1024] ;
  int index___0 ;
  int xing_flags ;
  int found ;
  int first_check ;
  char frame_buffer[4] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  register unsigned short __v ;
  register unsigned short __x ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int tmp___22 ;

  {
#line 1517
  size = 0U;
#line 1518
  fp_size = (off_t )0;
#line 1529
  infile = fopen((char const   * __restrict  )file, (char const   * __restrict  )"rb");
#line 1529
  if (! infile) {
#line 1530
    err_log(2, 8U, (char *)"Could not open %s for reading\n", file);
#line 1531
    return (-1);
  }
#line 1534
  memset((void *)(& fi), 0, sizeof(fi));
#line 1536
  fseek(infile, 0L, 2);
#line 1537
  file_size = ftell(infile);
#line 1538
  fseek(infile, 0L, 0);
#line 1540
  pmp3->file_size = (int )file_size;
#line 1542
  tmp___2 = fread((void * __restrict  )(buffer___0), 1U, sizeof(buffer___0), (FILE * __restrict  )infile);
#line 1542
  if (tmp___2 != sizeof(buffer___0)) {
#line 1543
    tmp___1 = ferror(infile);
#line 1543
    if (tmp___1) {
#line 1544
      tmp = __errno_location();
#line 1544
      tmp___0 = strerror(*tmp);
#line 1544
      err_log(1, 8U, (char *)"Error reading: %s\n", tmp___0);
    } else {
#line 1546
      err_log(1, 8U, (char *)"Short file: %s\n", file);
    }
#line 1548
    fclose(infile);
#line 1549
    return (-1);
  }
#line 1552
  pid3 = (SCAN_ID3HEADER *)(buffer___0);
#line 1554
  found = 0;
#line 1555
  fp_size = 0L;
#line 1557
  if (0) {
#line 1557
    if (0) {
#line 1557
      __s1_len = strlen((char const   *)(pid3->id));
#line 1557
      __s2_len = strlen("ID3");
#line 1557
      if (! ((unsigned int )((void const   *)(pid3->id + 1)) - (unsigned int )((void const   *)(pid3->id)) == 1U)) {
        goto _L___0;
      } else {
#line 1557
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 1557
          if (! ((unsigned int )((void const   *)("ID3" + 1)) - (unsigned int )((void const   *)"ID3") == 1U)) {
#line 1557
            tmp___11 = 1;
          } else {
#line 1557
            if (__s2_len >= 4U) {
#line 1557
              tmp___11 = 1;
            } else {
#line 1557
              tmp___11 = 0;
            }
          }
        } else {
#line 1557
          tmp___11 = 0;
        }
      }
#line 1557
      if (tmp___11) {
#line 1557
        tmp___6 = __builtin_strcmp((char const   *)(pid3->id), "ID3");
#line 1557
        tmp___10 = tmp___6;
      } else {
#line 1557
        tmp___9 = __builtin_strcmp((char const   *)(pid3->id), "ID3");
#line 1557
        tmp___10 = tmp___9;
      }
    } else {
#line 1557
      tmp___9 = __builtin_strcmp((char const   *)(pid3->id), "ID3");
#line 1557
      tmp___10 = tmp___9;
    }
#line 1557
    tmp___13 = tmp___10;
  } else {
#line 1557
    tmp___12 = strncmp((char const   *)(pid3->id), "ID3", 3U);
#line 1557
    tmp___13 = tmp___12;
  }
#line 1557
  if (tmp___13 == 0) {
#line 1559
    err_log(9, 8U, (char *)"Found ID3 header\n");
#line 1560
    size = (unsigned int )(((((int )pid3->size[0] << 21) | ((int )pid3->size[1] << 14)) | ((int )pid3->size[2] << 7)) | (int )pid3->size[3]);
#line 1562
    fp_size = (long )(size + sizeof(SCAN_ID3HEADER ));
#line 1563
    first_check = 1;
#line 1564
    err_log(9, 8U, (char *)"Header length: %d\n", size);
  }
#line 1567
  index___0 = 0;
#line 1573
  while (! found) {
#line 1574
    fseek(infile, fp_size, 0);
#line 1575
    err_log(9, 8U, (char *)"Reading in new block at %d\n", (int )fp_size);
#line 1576
    tmp___16 = fread((void * __restrict  )(buffer___0), 1U, sizeof(buffer___0), (FILE * __restrict  )infile);
#line 1576
    if (tmp___16 < sizeof(buffer___0)) {
#line 1577
      err_log(1, 8U, (char *)"Short read: %s\n", file);
#line 1578
      fclose(infile);
#line 1579
      return (0);
    }
#line 1582
    index___0 = 0;
#line 1583
    while (! found) {
#line 1584
      while (1) {
#line 1584
        if ((int )buffer___0[index___0] != 255) {
#line 1584
          if (! ((unsigned int )index___0 < sizeof(buffer___0) - 50U)) {
#line 1584
            break;
          }
        } else {
#line 1584
          break;
        }
#line 1585
        index___0 ++;
      }
#line 1587
      if (first_check) {
#line 1587
        if (index___0) {
#line 1588
          fp_size = 0L;
#line 1589
          err_log(9, 8U, (char *)"Bad header... dropping back for full frame search\n");
#line 1590
          first_check = 0;
#line 1591
          break;
        }
      }
#line 1594
      if ((unsigned int )index___0 > sizeof(buffer___0) - 50U) {
#line 1595
        fp_size += (off_t )index___0;
#line 1596
        err_log(9, 8U, (char *)"Block exhausted\n");
#line 1597
        break;
      }
#line 1600
      tmp___20 = scan_decode_mp3_frame(& buffer___0[index___0], & fi);
#line 1600
      if (! tmp___20) {
#line 1601
        err_log(9, 8U, (char *)"valid header at %d\n", index___0);
#line 1602
        tmp___19 = strncasecmp((char const   *)((char *)(& buffer___0[(index___0 + fi.xing_offset) + 4])),
                               "XING", 4U);
#line 1602
        if (tmp___19 == 0) {
#line 1605
          found = 1;
#line 1606
          fp_size += (off_t )index___0;
        } else {
#line 1609
          err_log(9, 8U, (char *)"Found valid frame at %04x\n", (int )fp_size + index___0);
#line 1610
          err_log(9, 8U, (char *)"Checking at %04x\n", ((int )fp_size + index___0) + fi.frame_length);
#line 1611
          fseek(infile, (fp_size + (off_t )index___0) + (off_t )fi.frame_length, 0);
#line 1612
          tmp___18 = fread((void * __restrict  )(frame_buffer), 1U, sizeof(frame_buffer),
                           (FILE * __restrict  )infile);
#line 1612
          if (tmp___18 == sizeof(frame_buffer)) {
#line 1613
            tmp___17 = scan_decode_mp3_frame((unsigned char *)(frame_buffer), & fi);
#line 1613
            if (! tmp___17) {
#line 1614
              found = 1;
#line 1615
              fp_size += (off_t )index___0;
            }
          } else {
#line 1618
            err_log(1, 8U, (char *)"Could not read frame header: %s\n", file);
#line 1619
            fclose(infile);
#line 1620
            return (0);
          }
#line 1623
          if (! found) {
#line 1624
            err_log(9, 8U, (char *)"Didn\'t pan out.\n");
          }
        }
      }
#line 1629
      if (! found) {
#line 1630
        index___0 ++;
#line 1631
        if (first_check) {
#line 1637
          err_log(9, 8U, (char *)"Bad header... dropping back for full frame search\n");
#line 1638
          first_check = 0;
#line 1639
          fp_size = 0L;
#line 1640
          break;
        }
      }
    }
  }
#line 1646
  file_size -= fp_size;
#line 1647
  fi.frame_offset = (int )fp_size;
#line 1649
  tmp___21 = scan_decode_mp3_frame(& buffer___0[index___0], & fi);
#line 1649
  if (tmp___21) {
#line 1650
    fclose(infile);
#line 1651
    err_log(1, 8U, (char *)"Could not find sync frame: %s\n", file);
#line 1652
    err_log(1, 8U, (char *)"If this is a valid mp3 file that plays in other applications, please email me at rpedde@users.sourceforge.net and tell me you got this error.  Thanks");
#line 1655
    return (0);
  }
#line 1658
  err_log(9, 8U, (char *)" MPEG Version: %0.1g\n", fi.version);
#line 1659
  err_log(9, 8U, (char *)" Layer: %d\n", fi.layer);
#line 1660
  err_log(9, 8U, (char *)" Sample Rate: %d\n", fi.samplerate);
#line 1661
  err_log(9, 8U, (char *)" Bit Rate: %d\n", fi.bitrate);
#line 1664
  tmp___22 = strncasecmp((char const   *)((char *)(& buffer___0[(index___0 + fi.xing_offset) + 4])),
                         "XING", 4U);
#line 1664
  if (tmp___22 == 0) {
#line 1665
    err_log(9, 8U, (char *)"Found Xing header\n");
#line 1666
    xing_flags = *((int *)(& buffer___0[((index___0 + fi.xing_offset) + 4) + 4]));
#line 1667
    __x = (unsigned short )xing_flags;
#line 1667
    __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 1667
    xing_flags = (int )__v;
#line 1669
    err_log(9, 8U, (char *)"Xing Flags: %02X\n", xing_flags);
#line 1671
    if (xing_flags & 1) {
#line 1673
      fi.number_of_frames = *((int *)(& buffer___0[((index___0 + fi.xing_offset) + 4) + 8]));
#line 1674
      __x___0 = (unsigned short )fi.number_of_frames;
#line 1674
      __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 1674
      fi.number_of_frames = (int )__v___0;
    }
  }
#line 1678
  if (config.scan_type != 0) {
#line 1678
    if (fi.number_of_frames == 0) {
#line 1678
      if (! pmp3->song_length) {
#line 1683
        err_log(9, 8U, (char *)"Starting aggressive file length scan\n");
#line 1684
        if (config.scan_type == 1) {
#line 1686
          scan_get_average_bitrate(infile, & fi);
        } else {
#line 1689
          scan_get_frame_count(infile, & fi);
        }
      }
    }
  }
#line 1693
  pmp3->bitrate = fi.bitrate;
#line 1694
  pmp3->samplerate = fi.samplerate;
#line 1697
  if (! pmp3->song_length) {
#line 1700
    if (! fi.number_of_frames) {
#line 1701
      pmp3->song_length = (int )(((double )file_size * 8.) / (double )fi.bitrate);
    } else {
#line 1705
      pmp3->song_length = (int )(((double )(fi.number_of_frames * fi.samples_per_frame) * 1000.) / (double )fi.samplerate);
    }
  }
#line 1710
  err_log(9, 8U, (char *)" Song Length: %d\n", pmp3->song_length);
#line 1712
  fclose(infile);
#line 1713
  return (0);
}
}
#line 1723 "mp3-scanner.c"
void make_composite_tags(MP3FILE *song ) 
{ int len ;
  char fdescr[50] ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___7 ;
  char *tmp___13 ;
  char *tmp___19 ;
  char *tmp___25 ;

  {
#line 1728
  len = 0;
#line 1730
  if (! song->artist) {
#line 1730
    if (song->orchestra) {
      goto _L;
    } else {
#line 1730
      if (song->conductor) {
        _L: /* CIL Label */ 
#line 1731
        if (song->orchestra) {
#line 1732
          tmp = strlen((char const   *)song->orchestra);
#line 1732
          len = (int )((size_t )len + tmp);
        }
#line 1733
        if (song->conductor) {
#line 1734
          tmp___0 = strlen((char const   *)song->conductor);
#line 1734
          len = (int )((size_t )len + tmp___0);
        }
#line 1736
        len += 3;
#line 1738
        tmp___1 = calloc((unsigned int )len, 1U);
#line 1738
        song->artist = (char *)tmp___1;
#line 1739
        if (song->artist) {
#line 1740
          if (song->orchestra) {
#line 1741
            strcat((char * __restrict  )song->artist, (char const   * __restrict  )song->orchestra);
          }
#line 1743
          if (song->orchestra) {
#line 1743
            if (song->conductor) {
#line 1744
              strcat((char * __restrict  )song->artist, (char const   * __restrict  )" - ");
            }
          }
#line 1746
          if (song->conductor) {
#line 1747
            strcat((char * __restrict  )song->artist, (char const   * __restrict  )song->conductor);
          }
        }
      }
    }
  }
#line 1751
  sprintf((char * __restrict  )(fdescr), (char const   * __restrict  )"%s audio file",
          song->type);
#line 1752
  tmp___7 = __strdup((char const   *)(fdescr));
#line 1752
  song->description = tmp___7;
#line 1754
  if (song->url) {
#line 1755
    tmp___13 = __strdup("Playlist URL");
#line 1755
    song->description = tmp___13;
#line 1756
    song->data_kind = 1;
#line 1758
    if (song->type) {
#line 1759
      free((void *)song->type);
    }
#line 1760
    tmp___19 = __strdup("pls");
#line 1760
    song->type = tmp___19;
  } else {
#line 1762
    song->data_kind = 0;
  }
#line 1765
  if (! song->title) {
#line 1766
    tmp___25 = __strdup((char const   *)song->fname);
#line 1766
    song->title = tmp___25;
  }
#line 1769
  song->item_kind = 2;
#line 1770
  return;
}
}
#line 1 "playlist.o"
#pragma merger(0,"/tmp/cil-YoKqtb2M.i","-g,-g,-O2")
#line 236 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 52 "playlist.h"
SMART_PLAYLIST pl_smart ;
#line 37 "playlist.c"
int yyparse(void) ;
#line 40 "playlist.c"
SMART_PLAYLIST pl_smart  =    {(char *)((void *)0), 0U, (PL_NODE *)((void *)0), (struct tag_smart_playlist *)((void *)0)};
#line 41 "playlist.c"
int pl_error  =    0;
#line 45
void pl_dump_node(PL_NODE *pnode , int indent ) ;
#line 47
int pl_eval_node(MP3FILE *pmp3 , PL_NODE *pnode ) ;
#line 49
FILE *yyin ;
#line 56 "playlist.c"
void pl_dump(void) 
{ SMART_PLAYLIST *pcurrent ;

  {
#line 57
  pcurrent = pl_smart.next;
#line 59
  while (pcurrent) {
#line 60
    printf((char const   * __restrict  )"Playlist %s:\n", pcurrent->name);
#line 61
    pl_dump_node(pcurrent->root, 1);
#line 62
    pcurrent = pcurrent->next;
  }
#line 64
  return;
}
}
#line 71 "playlist.c"
void pl_dump_node(PL_NODE *pnode , int indent ) 
{ int index___0 ;
  int not ;
  unsigned int boolarg ;
  char datebuffer[40] ;
  struct tm *ptm ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 73
  not = 0;
#line 78
  index___0 = 0;
#line 78
  while (index___0 < indent) {
#line 79
    printf((char const   * __restrict  )" ");
#line 78
    index___0 ++;
  }
#line 82
  if (pnode->op == 258) {
#line 83
    printf((char const   * __restrict  )"AND\n");
  } else {
#line 84
    if (pnode->op == 259) {
#line 85
      printf((char const   * __restrict  )"OR\n");
    }
  }
#line 88
  if (pnode->op == 258) {
#line 89
    pl_dump_node(pnode->arg1.plval, indent + 1);
#line 90
    pl_dump_node(pnode->arg2.plval, indent + 1);
#line 91
    return;
  } else {
#line 88
    if (pnode->op == 259) {
#line 89
      pl_dump_node(pnode->arg1.plval, indent + 1);
#line 90
      pl_dump_node(pnode->arg2.plval, indent + 1);
#line 91
      return;
    }
  }
#line 94
  switch (pnode->arg1.ival) {
  case 260: 
#line 96
  printf((char const   * __restrict  )"ARTIST ");
#line 97
  break;
  case 261: 
#line 99
  printf((char const   * __restrict  )"ALBUM ");
#line 100
  break;
  case 262: 
#line 102
  printf((char const   * __restrict  )"GENRE ");
#line 103
  break;
  case 263: 
#line 105
  printf((char const   * __restrict  )"PATH ");
#line 106
  break;
  case 264: 
#line 108
  printf((char const   * __restrict  )"COMPOSER ");
#line 109
  break;
  case 265: 
#line 111
  printf((char const   * __restrict  )"ORCHESTRA ");
#line 112
  break;
  case 266: 
#line 114
  printf((char const   * __restrict  )"CONDUCTOR ");
#line 115
  break;
  case 267: 
#line 117
  printf((char const   * __restrict  )"GROUPING ");
#line 118
  break;
  case 268: 
#line 120
  printf((char const   * __restrict  )"TYPE ");
#line 121
  break;
  case 269: 
#line 123
  printf((char const   * __restrict  )"COMMENT ");
#line 124
  break;
  case 281: 
#line 126
  printf((char const   * __restrict  )"YEAR ");
#line 127
  break;
  case 282: 
#line 129
  printf((char const   * __restrict  )"BPM ");
#line 130
  break;
  case 283: 
#line 132
  printf((char const   * __restrict  )"BITRATE ");
#line 133
  break;
  case 284: 
#line 135
  printf((char const   * __restrict  )"DATE ");
#line 136
  break;
  default: 
#line 138
  printf((char const   * __restrict  )"<unknown tag> ");
#line 139
  break;
  }
#line 142
  boolarg = (unsigned int )(pnode->op & 2147483647);
#line 143
  if ((unsigned int )pnode->op & 2147483648U) {
#line 144
    not = 1;
  }
#line 146
  switch ((int )boolarg) {
  case 275: 
#line 148
  if (not) {
#line 148
    tmp = "IS NOT ";
  } else {
#line 148
    tmp = "IS ";
  }
#line 148
  printf((char const   * __restrict  )"%s", tmp);
#line 149
  break;
  case 276: 
#line 151
  if (not) {
#line 151
    tmp___0 = "DOES NOT INCLUDE ";
  } else {
#line 151
    tmp___0 = "INCLUDES ";
  }
#line 151
  printf((char const   * __restrict  )"%s", tmp___0);
#line 152
  break;
  case 270: 
#line 154
  printf((char const   * __restrict  )"EQUALS ");
#line 155
  break;
  case 271: 
#line 157
  printf((char const   * __restrict  )"< ");
#line 158
  break;
  case 272: 
#line 160
  printf((char const   * __restrict  )"<= ");
#line 161
  break;
  case 273: 
#line 163
  printf((char const   * __restrict  )"> ");
#line 164
  break;
  case 274: 
#line 166
  printf((char const   * __restrict  )">= ");
#line 167
  break;
  case 285: 
#line 169
  printf((char const   * __restrict  )"BEFORE ");
#line 170
  break;
  case 286: 
#line 172
  printf((char const   * __restrict  )"AFTER ");
#line 173
  break;
  default: 
#line 175
  printf((char const   * __restrict  )"<unknown boolop> ");
#line 176
  break;
  }
#line 179
  switch (pnode->type) {
  case 1: 
#line 181
  printf((char const   * __restrict  )"%s\n", pnode->arg2.cval);
#line 182
  break;
  case 0: 
#line 184
  printf((char const   * __restrict  )"%d\n", pnode->arg2.ival);
#line 185
  break;
  case 2: 
#line 187
  ptm = localtime((time_t const   *)((time_t *)(& pnode->arg2.ival)));
#line 188
  strftime((char * __restrict  )(datebuffer), sizeof(datebuffer), (char const   * __restrict  )"%Y-%m-%d",
           (struct tm  const  * __restrict  )ptm);
#line 189
  printf((char const   * __restrict  )"%s\n", datebuffer);
#line 190
  break;
  default: 
#line 192
  printf((char const   * __restrict  )"<unknown type>\n");
#line 193
  break;
  }
#line 195
  return;
}
}
#line 203 "playlist.c"
int pl_load(char *file ) 
{ FILE *fin ;
  int result ;

  {
#line 207
  fin = fopen((char const   * __restrict  )file, (char const   * __restrict  )"r");
#line 208
  if (! fin) {
#line 209
    return (-1);
  }
#line 212
  yyin = fin;
#line 213
  result = yyparse();
#line 214
  fclose(fin);
#line 216
  if (pl_error) {
#line 217
    return (-1);
  }
#line 220
  return (0);
}
}
#line 228 "playlist.c"
void pl_register(void) 
{ SMART_PLAYLIST *pcurrent ;

  {
#line 232
  err_log(5, 128U, (char *)"Finished loading smart playlists\n");
#line 233
  pcurrent = pl_smart.next;
#line 234
  while (pcurrent) {
#line 235
    err_log(5, 128U, (char *)"Adding smart playlist %s as %d\n", pcurrent->name, pcurrent->id);
#line 236
    db_add_playlist((unsigned long )pcurrent->id, pcurrent->name, 0, 1);
#line 237
    pcurrent = pcurrent->next;
  }
#line 239
  return;
}
}
#line 246 "playlist.c"
void pl_eval(MP3FILE *pmp3 ) 
{ SMART_PLAYLIST *pcurrent ;
  int tmp ;

  {
#line 249
  pcurrent = pl_smart.next;
#line 250
  while (pcurrent) {
#line 251
    tmp = pl_eval_node(pmp3, pcurrent->root);
#line 251
    if (tmp) {
#line 252
      err_log(9, 128U, (char *)"Match song to playlist %s (%d)\n", pcurrent->name,
              pcurrent->id);
#line 253
      db_add_playlist_song((unsigned long )pcurrent->id, pmp3->id);
    }
#line 256
    pcurrent = pcurrent->next;
  }
#line 258
  return;
}
}
#line 266 "playlist.c"
int pl_eval_node(MP3FILE *pmp3 , PL_NODE *pnode ) 
{ int r_arg ;
  int r_arg2 ;
  char *cval ;
  int ival ;
  int boolarg ;
  int not ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 268
  cval = (char *)((void *)0);
#line 269
  ival = 0;
#line 271
  not = 0;
#line 272
  retval = 0;
#line 274
  r_arg2 = 0;
#line 274
  r_arg = r_arg2;
#line 276
  if (pnode->op == 258) {
    goto _L;
  } else {
#line 276
    if (pnode->op == 259) {
      _L: /* CIL Label */ 
#line 277
      r_arg = pl_eval_node(pmp3, pnode->arg1.plval);
#line 278
      if (pnode->op == 258) {
#line 278
        if (! r_arg) {
#line 279
          return (0);
        }
      }
#line 280
      if (pnode->op == 259) {
#line 280
        if (r_arg) {
#line 281
          return (1);
        }
      }
#line 283
      r_arg2 = pl_eval_node(pmp3, pnode->arg2.plval);
#line 284
      if (pnode->op == 258) {
#line 285
        if (r_arg) {
#line 285
          if (r_arg2) {
#line 285
            tmp = 1;
          } else {
#line 285
            tmp = 0;
          }
        } else {
#line 285
          tmp = 0;
        }
#line 285
        return (tmp);
      }
#line 287
      if (r_arg) {
#line 287
        tmp___0 = 1;
      } else {
#line 287
        if (r_arg2) {
#line 287
          tmp___0 = 1;
        } else {
#line 287
          tmp___0 = 0;
        }
      }
#line 287
      return (tmp___0);
    }
  }
#line 291
  switch (pnode->arg1.ival) {
  case 261: 
#line 293
  cval = pmp3->album;
#line 294
  break;
  case 260: 
#line 296
  cval = pmp3->artist;
#line 297
  break;
  case 262: 
#line 299
  cval = pmp3->genre;
#line 300
  break;
  case 263: 
#line 302
  cval = pmp3->path;
#line 303
  break;
  case 264: 
#line 305
  cval = pmp3->composer;
#line 306
  break;
  case 265: 
#line 308
  cval = pmp3->orchestra;
#line 309
  break;
  case 266: 
#line 311
  cval = pmp3->conductor;
#line 312
  break;
  case 267: 
#line 314
  cval = pmp3->grouping;
#line 315
  break;
  case 268: 
#line 317
  cval = pmp3->description;
#line 318
  break;
  case 269: 
#line 320
  cval = pmp3->comment;
#line 321
  break;
  case 281: 
#line 323
  ival = pmp3->year;
#line 324
  break;
  case 282: 
#line 326
  ival = pmp3->bpm;
#line 327
  break;
  case 283: 
#line 329
  ival = pmp3->bitrate / 1024;
#line 330
  break;
  case 284: 
#line 332
  ival = pmp3->time_added;
#line 333
  break;
  default: 
#line 335
  err_log(0, 128U, (char *)"Unknown token in playlist.  This can\'t happen!\n\n");
#line 336
  break;
  }
#line 339
  boolarg = pnode->op & 2147483647;
#line 340
  if ((unsigned int )pnode->op & 2147483648U) {
#line 341
    not = 1;
  }
#line 343
  if (pnode->type == 1) {
#line 344
    if (! cval) {
#line 345
      cval = (char *)"";
    }
#line 347
    err_log(9, 128U, (char *)"Matching %s to %s\n", cval, pnode->arg2.cval);
#line 349
    switch (boolarg) {
    case 275: 
#line 351
    r_arg = strcasecmp((char const   *)cval, (char const   *)pnode->arg2.cval);
#line 352
    if (not) {
#line 352
      retval = r_arg;
    } else {
#line 352
      retval = ! r_arg;
    }
#line 353
    break;
    case 276: 
#line 355
    tmp___1 = strcasestr(cval, pnode->arg2.cval);
#line 355
    r_arg = tmp___1;
#line 356
    if (not) {
#line 356
      retval = ! r_arg;
    } else {
#line 356
      retval = r_arg;
    }
#line 357
    break;
    }
  }
#line 361
  if (pnode->type == 2) {
#line 362
    err_log(9, 128U, (char *)"Comparing (datewise) %d to %d\n", ival, pnode->arg2.ival);
#line 363
    switch (boolarg) {
    case 285: 
#line 365
    r_arg = ival < pnode->arg2.ival;
#line 366
    break;
    case 286: 
#line 368
    r_arg = ival > pnode->arg2.ival;
#line 369
    break;
    }
#line 371
    retval = r_arg;
  }
#line 374
  if (pnode->type == 0) {
#line 375
    err_log(9, 128U, (char *)"Comparing %d to %d\n", ival, pnode->arg2.ival);
#line 377
    switch (boolarg) {
    case 270: 
#line 379
    r_arg = ival == pnode->arg2.ival;
#line 380
    break;
    case 273: 
#line 382
    r_arg = ival > pnode->arg2.ival;
#line 383
    break;
    case 274: 
#line 385
    r_arg = ival >= pnode->arg2.ival;
#line 386
    break;
    case 271: 
#line 388
    r_arg = ival < pnode->arg2.ival;
#line 389
    break;
    case 272: 
#line 391
    r_arg = ival <= pnode->arg2.ival;
#line 392
    break;
    }
#line 394
    if (not) {
#line 394
      retval = ! r_arg;
    } else {
#line 394
      retval = r_arg;
    }
  }
#line 397
  err_log(9, 128U, (char *)"Returning %d\n", retval);
#line 398
  return (retval);
}
}
#line 1 "lexer.o"
#pragma merger(0,"/tmp/cil-CfNEx7eW.i","-g,-g,-O2")
#line 450 "/usr/include/libio.h"
extern  __attribute__((__nothrow__)) int _IO_getc(_IO_FILE *__fp ) ;
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 143
extern struct _IO_FILE *stdout ;
#line 614
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 757
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 101 "lexer.c"
int yyleng  ;
#line 102
FILE *yyout ;
#line 201 "lexer.c"
static YY_BUFFER_STATE yy_current_buffer  =    (YY_BUFFER_STATE )0;
#line 211 "lexer.c"
static char yy_hold_char  ;
#line 213 "lexer.c"
static int yy_n_chars  ;
#line 219 "lexer.c"
static char *yy_c_buf_p  =    (char *)0;
#line 220 "lexer.c"
static int yy_init  =    1;
#line 221 "lexer.c"
static int yy_start  =    0;
#line 226 "lexer.c"
static int yy_did_buffer_switch_on_eof  ;
#line 228
void yyrestart(FILE *input_file ) ;
#line 230
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 231
void yy_load_buffer_state(void) ;
#line 232
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) ;
#line 233
void yy_delete_buffer(YY_BUFFER_STATE b ) ;
#line 234
void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 235
void yy_flush_buffer(YY_BUFFER_STATE b ) ;
#line 238
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) ;
#line 239
YY_BUFFER_STATE yy_scan_string(char const   *yy_str ) ;
#line 240
YY_BUFFER_STATE yy_scan_bytes(char const   *bytes , int len ) ;
#line 242
static void *yy_flex_alloc(yy_size_t size ) ;
#line 244
static void yy_flex_free(void *ptr ) ;
#line 267 "lexer.c"
FILE *yyin  =    (FILE *)0;
#line 267 "lexer.c"
FILE *yyout  =    (FILE *)0;
#line 269
int yylineno ;
#line 270 "lexer.c"
int yylineno  =    1;
#line 271 "lexer.c"
char *yytext  ;
#line 274
static yy_state_type yy_get_previous_state(void) ;
#line 275
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
#line 276
static int yy_get_next_buffer(void) ;
#line 277
static void yy_fatal_error(char const   *msg ) ;
#line 291 "lexer.c"
static short const   yy_acclist[107]  = 
#line 291
  {      (short const   )0,      (short const   )47,      (short const   )45,      (short const   )46, 
        (short const   )1,      (short const   )45,      (short const   )46,      (short const   )1, 
        (short const   )46,      (short const   )38,      (short const   )45,      (short const   )46, 
        (short const   )45,      (short const   )46,      (short const   )45,      (short const   )46, 
        (short const   )45,      (short const   )46,      (short const   )44,      (short const   )45, 
        (short const   )46,      (short const   )40,      (short const   )45,      (short const   )46, 
        (short const   )32,      (short const   )45,      (short const   )46,      (short const   )42, 
        (short const   )45,      (short const   )46,      (short const   )45,      (short const   )46, 
        (short const   )45,      (short const   )46,      (short const   )45,      (short const   )46, 
        (short const   )45,      (short const   )46,      (short const   )45,      (short const   )46, 
        (short const   )45,      (short const   )46,      (short const   )45,      (short const   )46, 
        (short const   )45,      (short const   )46,      (short const   )45,      (short const   )46, 
        (short const   )45,      (short const   )46,      (short const   )45,      (short const   )46, 
        (short const   )45,      (short const   )46,      (short const   )45,      (short const   )46, 
        (short const   )45,      (short const   )46,      (short const   )45,      (short const   )46, 
        (short const   )1,      (short const   )43,      (short const   )2,      (short const   )36, 
        (short const   )44,      (short const   )39,      (short const   )41,      (short const   )30, 
        (short const   )33,      (short const   )34,      (short const   )44,      (short const   )27, 
        (short const   )35,      (short const   )14,      (short const   )23,      (short const   )37, 
        (short const   )44,      (short const   )16,      (short const   )23,      (short const   )6, 
        (short const   )11,      (short const   )24,      (short const   )13,      (short const   )26, 
        (short const   )44,      (short const   )29,      (short const   )4,      (short const   )5, 
        (short const   )25,      (short const   )18,      (short const   )24,      (short const   )26, 
        (short const   )3,      (short const   )28,      (short const   )25,      (short const   )15, 
        (short const   )12,      (short const   )7,      (short const   )10,      (short const   )31, 
        (short const   )9,      (short const   )20,      (short const   )22,      (short const   )8, 
        (short const   )19,      (short const   )17,      (short const   )21};
#line 307 "lexer.c"
static short const   yy_accept[180]  = 
#line 307
  {      (short const   )0,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )2,      (short const   )4,      (short const   )7,      (short const   )9, 
        (short const   )12,      (short const   )14,      (short const   )16,      (short const   )18, 
        (short const   )21,      (short const   )24,      (short const   )27,      (short const   )30, 
        (short const   )32,      (short const   )34,      (short const   )36,      (short const   )38, 
        (short const   )40,      (short const   )42,      (short const   )44,      (short const   )46, 
        (short const   )48,      (short const   )50,      (short const   )52,      (short const   )54, 
        (short const   )56,      (short const   )58,      (short const   )60,      (short const   )61, 
        (short const   )61,      (short const   )62,      (short const   )62,      (short const   )63, 
        (short const   )64,      (short const   )65,      (short const   )66,      (short const   )67, 
        (short const   )67,      (short const   )67,      (short const   )67,      (short const   )67, 
        (short const   )67,      (short const   )67,      (short const   )67,      (short const   )67, 
        (short const   )67,      (short const   )67,      (short const   )67,      (short const   )67, 
        (short const   )67,      (short const   )68,      (short const   )68,      (short const   )68, 
        (short const   )68,      (short const   )69,      (short const   )69,      (short const   )69, 
        (short const   )69,      (short const   )69,      (short const   )69,      (short const   )70, 
        (short const   )71,      (short const   )71,      (short const   )72,      (short const   )72, 
        (short const   )73,      (short const   )73,      (short const   )73,      (short const   )73, 
        (short const   )74,      (short const   )74,      (short const   )74,      (short const   )74, 
        (short const   )75,      (short const   )75,      (short const   )75,      (short const   )75, 
        (short const   )75,      (short const   )75,      (short const   )76,      (short const   )76, 
        (short const   )76,      (short const   )76,      (short const   )76,      (short const   )76, 
        (short const   )76,      (short const   )76,      (short const   )77,      (short const   )77, 
        (short const   )77,      (short const   )77,      (short const   )77,      (short const   )77, 
        (short const   )77,      (short const   )77,      (short const   )77,      (short const   )78, 
        (short const   )79,      (short const   )79,      (short const   )79,      (short const   )79, 
        (short const   )79,      (short const   )79,      (short const   )79,      (short const   )80, 
        (short const   )80,      (short const   )81,      (short const   )82,      (short const   )84, 
        (short const   )84,      (short const   )84,      (short const   )85,      (short const   )86, 
        (short const   )87,      (short const   )87,      (short const   )87,      (short const   )87, 
        (short const   )87,      (short const   )87,      (short const   )87,      (short const   )88, 
        (short const   )88,      (short const   )88,      (short const   )88,      (short const   )89, 
        (short const   )89,      (short const   )90,      (short const   )91,      (short const   )92, 
        (short const   )92,      (short const   )92,      (short const   )93,      (short const   )94, 
        (short const   )94,      (short const   )94,      (short const   )94,      (short const   )94, 
        (short const   )94,      (short const   )94,      (short const   )94,      (short const   )94, 
        (short const   )94,      (short const   )95,      (short const   )95,      (short const   )95, 
        (short const   )95,      (short const   )96,      (short const   )97,      (short const   )97, 
        (short const   )97,      (short const   )97,      (short const   )97,      (short const   )97, 
        (short const   )97,      (short const   )97,      (short const   )97,      (short const   )97, 
        (short const   )97,      (short const   )98,      (short const   )98,      (short const   )99, 
        (short const   )100,      (short const   )100,      (short const   )100,      (short const   )100, 
        (short const   )100,      (short const   )100,      (short const   )100,      (short const   )101, 
        (short const   )101,      (short const   )102,      (short const   )103,      (short const   )104, 
        (short const   )105,      (short const   )106,      (short const   )107,      (short const   )107};
#line 330 "lexer.c"
static int const   yy_ec[256]  = 
#line 330
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )4,      (int const   )5,      (int const   )6,      (int const   )7, 
        (int const   )1,      (int const   )1,      (int const   )8,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )9,      (int const   )1,      (int const   )1, 
        (int const   )10,      (int const   )10,      (int const   )10,      (int const   )10, 
        (int const   )10,      (int const   )10,      (int const   )10,      (int const   )10, 
        (int const   )10,      (int const   )10,      (int const   )1,      (int const   )1, 
        (int const   )11,      (int const   )12,      (int const   )13,      (int const   )1, 
        (int const   )1,      (int const   )14,      (int const   )15,      (int const   )16, 
        (int const   )17,      (int const   )18,      (int const   )19,      (int const   )20, 
        (int const   )21,      (int const   )22,      (int const   )1,      (int const   )23, 
        (int const   )24,      (int const   )25,      (int const   )26,      (int const   )27, 
        (int const   )28,      (int const   )1,      (int const   )29,      (int const   )30, 
        (int const   )31,      (int const   )32,      (int const   )1,      (int const   )33, 
        (int const   )1,      (int const   )34,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )14,      (int const   )15,      (int const   )16, 
        (int const   )17,      (int const   )18,      (int const   )19,      (int const   )20, 
        (int const   )21,      (int const   )22,      (int const   )1,      (int const   )23, 
        (int const   )24,      (int const   )25,      (int const   )26,      (int const   )27, 
        (int const   )28,      (int const   )1,      (int const   )29,      (int const   )30, 
        (int const   )31,      (int const   )32,      (int const   )1,      (int const   )33, 
        (int const   )1,      (int const   )34,      (int const   )1,      (int const   )1, 
        (int const   )35,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1};
#line 362 "lexer.c"
static int const   yy_meta[36]  = 
#line 362
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1};
#line 370 "lexer.c"
static short const   yy_base[181]  = 
#line 370
  {      (short const   )0,      (short const   )0,      (short const   )0,      (short const   )197, 
        (short const   )198,      (short const   )34,      (short const   )37,      (short const   )198, 
        (short const   )39,      (short const   )193,      (short const   )187,      (short const   )184, 
        (short const   )181,      (short const   )198,      (short const   )180,      (short const   )24, 
        (short const   )29,      (short const   )164,      (short const   )176,      (short const   )31, 
        (short const   )26,      (short const   )175,      (short const   )161,      (short const   )160, 
        (short const   )157,      (short const   )171,      (short const   )27,      (short const   )166, 
        (short const   )165,      (short const   )147,      (short const   )60,      (short const   )52, 
        (short const   )198,      (short const   )178,      (short const   )198,      (short const   )198, 
        (short const   )170,      (short const   )198,      (short const   )198,      (short const   )148, 
        (short const   )151,      (short const   )162,      (short const   )159,      (short const   )144, 
        (short const   )155,      (short const   )142,      (short const   )147,      (short const   )40, 
        (short const   )36,      (short const   )145,      (short const   )143,      (short const   )153, 
        (short const   )198,      (short const   )138,      (short const   )141,      (short const   )135, 
        (short const   )149,      (short const   )133,      (short const   )146,      (short const   )134, 
        (short const   )143,      (short const   )45,      (short const   )198,      (short const   )150, 
        (short const   )141,      (short const   )198,      (short const   )126,      (short const   )198, 
        (short const   )135,      (short const   )129,      (short const   )126,      (short const   )198, 
        (short const   )43,      (short const   )137,      (short const   )135,      (short const   )122, 
        (short const   )122,      (short const   )118,      (short const   )125,      (short const   )117, 
        (short const   )116,      (short const   )198,      (short const   )125,      (short const   )124, 
        (short const   )130,      (short const   )125,      (short const   )119,      (short const   )112, 
        (short const   )109,      (short const   )63,      (short const   )110,      (short const   )113, 
        (short const   )107,      (short const   )107,      (short const   )121,      (short const   )116, 
        (short const   )106,      (short const   )100,      (short const   )198,      (short const   )198, 
        (short const   )113,      (short const   )102,      (short const   )97,      (short const   )124, 
        (short const   )106,      (short const   )108,      (short const   )198,      (short const   )91, 
        (short const   )198,      (short const   )94,      (short const   )93,      (short const   )104, 
        (short const   )111,      (short const   )110,      (short const   )198,      (short const   )198, 
        (short const   )88,      (short const   )100,      (short const   )86,      (short const   )90, 
        (short const   )85,      (short const   )98,      (short const   )198,      (short const   )91, 
        (short const   )95,      (short const   )44,      (short const   )81,      (short const   )80, 
        (short const   )198,      (short const   )198,      (short const   )198,      (short const   )80, 
        (short const   )98,      (short const   )198,      (short const   )198,      (short const   )89, 
        (short const   )75,      (short const   )87,      (short const   )73,      (short const   )77, 
        (short const   )84,      (short const   )74,      (short const   )82,      (short const   )81, 
        (short const   )198,      (short const   )67,      (short const   )80,      (short const   )87, 
        (short const   )198,      (short const   )198,      (short const   )66,      (short const   )67, 
        (short const   )73,      (short const   )62,      (short const   )65,      (short const   )72, 
        (short const   )75,      (short const   )59,      (short const   )73,      (short const   )76, 
        (short const   )198,      (short const   )56,      (short const   )198,      (short const   )198, 
        (short const   )53,      (short const   )60,      (short const   )53,      (short const   )67, 
        (short const   )46,      (short const   )69,      (short const   )198,      (short const   )55, 
        (short const   )198,      (short const   )198,      (short const   )198,      (short const   )198, 
        (short const   )198,      (short const   )198,      (short const   )198,      (short const   )73, 
        (short const   )45};
#line 393 "lexer.c"
static short const   yy_def[181]  = 
#line 393
  {      (short const   )0,      (short const   )178,      (short const   )1,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )179,      (short const   )180,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )179, 
        (short const   )178,      (short const   )180,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )0,      (short const   )178, 
        (short const   )178};
#line 416 "lexer.c"
static short const   yy_nxt[234]  = 
#line 416
  {      (short const   )0,      (short const   )4,      (short const   )5,      (short const   )6, 
        (short const   )5,      (short const   )7,      (short const   )8,      (short const   )9, 
        (short const   )10,      (short const   )4,      (short const   )11,      (short const   )12, 
        (short const   )13,      (short const   )14,      (short const   )15,      (short const   )16, 
        (short const   )17,      (short const   )18,      (short const   )4,      (short const   )4, 
        (short const   )19,      (short const   )4,      (short const   )20,      (short const   )4, 
        (short const   )21,      (short const   )22,      (short const   )23,      (short const   )24, 
        (short const   )25,      (short const   )4,      (short const   )4,      (short const   )26, 
        (short const   )4,      (short const   )27,      (short const   )28,      (short const   )29, 
        (short const   )30,      (short const   )30,      (short const   )30,      (short const   )30, 
        (short const   )30,      (short const   )30,      (short const   )32,      (short const   )39, 
        (short const   )40,      (short const   )32,      (short const   )33,      (short const   )44, 
        (short const   )41,      (short const   )49,      (short const   )42,      (short const   )45, 
        (short const   )51,      (short const   )43,      (short const   )58,      (short const   )32, 
        (short const   )52,      (short const   )46,      (short const   )32,      (short const   )87, 
        (short const   )50,      (short const   )59,      (short const   )30,      (short const   )30, 
        (short const   )30,      (short const   )72,      (short const   )73,      (short const   )74, 
        (short const   )95,      (short const   )141,      (short const   )75,      (short const   )96, 
        (short const   )112,      (short const   )113,      (short const   )31,      (short const   )88, 
        (short const   )177,      (short const   )142,      (short const   )143,      (short const   )176, 
        (short const   )175,      (short const   )174,      (short const   )173,      (short const   )172, 
        (short const   )171,      (short const   )170,      (short const   )169,      (short const   )168, 
        (short const   )167,      (short const   )166,      (short const   )165,      (short const   )164, 
        (short const   )163,      (short const   )162,      (short const   )161,      (short const   )160, 
        (short const   )159,      (short const   )158,      (short const   )157,      (short const   )156, 
        (short const   )155,      (short const   )154,      (short const   )153,      (short const   )152, 
        (short const   )151,      (short const   )150,      (short const   )149,      (short const   )148, 
        (short const   )147,      (short const   )146,      (short const   )145,      (short const   )144, 
        (short const   )140,      (short const   )139,      (short const   )138,      (short const   )137, 
        (short const   )136,      (short const   )135,      (short const   )134,      (short const   )133, 
        (short const   )113,      (short const   )132,      (short const   )131,      (short const   )130, 
        (short const   )129,      (short const   )128,      (short const   )127,      (short const   )126, 
        (short const   )125,      (short const   )124,      (short const   )123,      (short const   )122, 
        (short const   )121,      (short const   )120,      (short const   )119,      (short const   )118, 
        (short const   )117,      (short const   )116,      (short const   )115,      (short const   )114, 
        (short const   )111,      (short const   )110,      (short const   )109,      (short const   )108, 
        (short const   )107,      (short const   )106,      (short const   )105,      (short const   )104, 
        (short const   )103,      (short const   )102,      (short const   )101,      (short const   )100, 
        (short const   )99,      (short const   )98,      (short const   )97,      (short const   )94, 
        (short const   )93,      (short const   )92,      (short const   )91,      (short const   )90, 
        (short const   )89,      (short const   )86,      (short const   )85,      (short const   )84, 
        (short const   )83,      (short const   )82,      (short const   )81,      (short const   )80, 
        (short const   )79,      (short const   )78,      (short const   )77,      (short const   )76, 
        (short const   )71,      (short const   )70,      (short const   )69,      (short const   )68, 
        (short const   )67,      (short const   )66,      (short const   )65,      (short const   )64, 
        (short const   )63,      (short const   )34,      (short const   )62,      (short const   )61, 
        (short const   )60,      (short const   )57,      (short const   )56,      (short const   )55, 
        (short const   )54,      (short const   )53,      (short const   )48,      (short const   )47, 
        (short const   )38,      (short const   )37,      (short const   )36,      (short const   )35, 
        (short const   )34,      (short const   )178,      (short const   )3,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178};
#line 446 "lexer.c"
static short const   yy_chk[234]  = 
#line 446
  {      (short const   )0,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )5,      (short const   )5,      (short const   )5,      (short const   )6, 
        (short const   )6,      (short const   )6,      (short const   )8,      (short const   )15, 
        (short const   )15,      (short const   )8,      (short const   )180,      (short const   )16, 
        (short const   )15,      (short const   )19,      (short const   )15,      (short const   )16, 
        (short const   )20,      (short const   )15,      (short const   )26,      (short const   )31, 
        (short const   )20,      (short const   )16,      (short const   )31,      (short const   )61, 
        (short const   )19,      (short const   )26,      (short const   )30,      (short const   )30, 
        (short const   )30,      (short const   )47,      (short const   )47,      (short const   )48, 
        (short const   )72,      (short const   )125,      (short const   )48,      (short const   )72, 
        (short const   )89,      (short const   )89,      (short const   )179,      (short const   )61, 
        (short const   )171,      (short const   )125,      (short const   )125,      (short const   )169, 
        (short const   )168,      (short const   )167,      (short const   )166,      (short const   )165, 
        (short const   )164,      (short const   )161,      (short const   )159,      (short const   )158, 
        (short const   )157,      (short const   )156,      (short const   )155,      (short const   )154, 
        (short const   )153,      (short const   )152,      (short const   )151,      (short const   )150, 
        (short const   )147,      (short const   )146,      (short const   )145,      (short const   )143, 
        (short const   )142,      (short const   )141,      (short const   )140,      (short const   )139, 
        (short const   )138,      (short const   )137,      (short const   )136,      (short const   )135, 
        (short const   )132,      (short const   )131,      (short const   )127,      (short const   )126, 
        (short const   )124,      (short const   )123,      (short const   )121,      (short const   )120, 
        (short const   )119,      (short const   )118,      (short const   )117,      (short const   )116, 
        (short const   )113,      (short const   )112,      (short const   )111,      (short const   )110, 
        (short const   )109,      (short const   )107,      (short const   )105,      (short const   )104, 
        (short const   )103,      (short const   )102,      (short const   )101,      (short const   )100, 
        (short const   )97,      (short const   )96,      (short const   )95,      (short const   )94, 
        (short const   )93,      (short const   )92,      (short const   )91,      (short const   )90, 
        (short const   )88,      (short const   )87,      (short const   )86,      (short const   )85, 
        (short const   )84,      (short const   )83,      (short const   )82,      (short const   )80, 
        (short const   )79,      (short const   )78,      (short const   )77,      (short const   )76, 
        (short const   )75,      (short const   )74,      (short const   )73,      (short const   )70, 
        (short const   )69,      (short const   )68,      (short const   )66,      (short const   )64, 
        (short const   )63,      (short const   )60,      (short const   )59,      (short const   )58, 
        (short const   )57,      (short const   )56,      (short const   )55,      (short const   )54, 
        (short const   )53,      (short const   )51,      (short const   )50,      (short const   )49, 
        (short const   )46,      (short const   )45,      (short const   )44,      (short const   )43, 
        (short const   )42,      (short const   )41,      (short const   )40,      (short const   )39, 
        (short const   )36,      (short const   )33,      (short const   )29,      (short const   )28, 
        (short const   )27,      (short const   )25,      (short const   )24,      (short const   )23, 
        (short const   )22,      (short const   )21,      (short const   )18,      (short const   )17, 
        (short const   )14,      (short const   )12,      (short const   )11,      (short const   )10, 
        (short const   )9,      (short const   )3,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178,      (short const   )178,      (short const   )178, 
        (short const   )178,      (short const   )178};
#line 476 "lexer.c"
static yy_state_type yy_state_buf[16386]  ;
#line 476 "lexer.c"
static yy_state_type *yy_state_ptr  ;
#line 477 "lexer.c"
static char *yy_full_match  ;
#line 478 "lexer.c"
static int yy_lp  ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 194 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 127 "parser.h"
YYSTYPE yylval ;
#line 33 "lexer.l"
time_t l_converttime(int day , int month , int year ) ;
#line 34
time_t l_convertyyyymmdd(char *date ) ;
#line 537 "lexer.c"
int yywrap(void) ;
#line 672 "lexer.c"
int yylex(void) 
{ register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  yy_state_type *tmp ;
  register YY_CHAR yy_c ;
  yy_state_type *tmp___0 ;
  int yyl ;
  time_t tmp___1 ;
  time_t tmp___2 ;
  time_t tmp___3 ;
  time_t tmp___4 ;
  time_t tmp___5 ;
  time_t tmp___6 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 683
  if (yy_init) {
#line 685
    yy_init = 0;
#line 691
    if (! yy_start) {
#line 692
      yy_start = 1;
    }
#line 694
    if (! yyin) {
#line 695
      yyin = stdin;
    }
#line 697
    if (! yyout) {
#line 698
      yyout = stdout;
    }
#line 700
    if (! yy_current_buffer) {
#line 701
      yy_current_buffer = yy_create_buffer(yyin, 16384);
    }
#line 704
    yy_load_buffer_state();
  }
#line 707
  while (1) {
#line 709
    yy_cp = yy_c_buf_p;
#line 712
    *yy_cp = yy_hold_char;
#line 717
    yy_bp = yy_cp;
#line 719
    yy_current_state = yy_start;
#line 720
    yy_state_ptr = yy_state_buf;
#line 721
    tmp = yy_state_ptr;
#line 721
    yy_state_ptr ++;
#line 721
    *tmp = yy_current_state;
    yy_match: 
#line 723
    while (1) {
#line 725
      yy_c = (YY_CHAR )yy_ec[(unsigned int )((unsigned char )*yy_cp)];
#line 726
      while ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state) {
#line 728
        yy_current_state = (int )yy_def[yy_current_state];
#line 729
        if (yy_current_state >= 179) {
#line 730
          yy_c = (unsigned char )yy_meta[(unsigned int )yy_c];
        }
      }
#line 732
      yy_current_state = (int )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 733
      tmp___0 = yy_state_ptr;
#line 733
      yy_state_ptr ++;
#line 733
      *tmp___0 = yy_current_state;
#line 734
      yy_cp ++;
#line 723
      if (! ((int const   )yy_base[yy_current_state] != 198)) {
#line 723
        break;
      }
    }
    yy_find_action: 
#line 739
    yy_state_ptr --;
#line 739
    yy_current_state = *yy_state_ptr;
#line 740
    yy_lp = (int )yy_accept[yy_current_state];
#line 742
    while (1) {
#line 744
      if (yy_lp) {
#line 744
        if (yy_lp < (int )yy_accept[yy_current_state + 1]) {
#line 746
          yy_act = (int )yy_acclist[yy_lp];
#line 748
          yy_full_match = yy_cp;
#line 749
          break;
        }
      }
#line 752
      yy_cp --;
#line 753
      yy_state_ptr --;
#line 753
      yy_current_state = *yy_state_ptr;
#line 754
      yy_lp = (int )yy_accept[yy_current_state];
    }
#line 757
    yytext = yy_bp;
#line 757
    yyleng = yy_cp - yy_bp;
#line 757
    yy_hold_char = *yy_cp;
#line 757
    *yy_cp = (char )'\000';
#line 757
    yy_c_buf_p = yy_cp;
#line 759
    if (yy_act != 47) {
#line 762
      yyl = 0;
#line 762
      while (yyl < yyleng) {
#line 763
        if ((int )*(yytext + yyl) == 10) {
#line 764
          yylineno ++;
        }
#line 762
        yyl ++;
      }
    }
    do_action: 
#line 770
    switch (yy_act) {
    case 1: 
#line 47 "lexer.l"
    break;
    case 2: 
#line 48
    break;
    case 3: 
#line 49
    yylval.ival = 260U;
#line 49
    return (260);
#line 50
    break;
    case 4: 
#line 50
    yylval.ival = 261U;
#line 50
    return (261);
#line 51
    break;
    case 5: 
#line 51
    yylval.ival = 262U;
#line 51
    return (262);
#line 52
    break;
    case 6: 
#line 52
    yylval.ival = 263U;
#line 52
    return (263);
#line 53
    break;
    case 7: 
#line 53
    yylval.ival = 264U;
#line 53
    return (264);
#line 54
    break;
    case 8: 
#line 54
    yylval.ival = 265U;
#line 54
    return (265);
#line 55
    break;
    case 9: 
#line 55
    yylval.ival = 266U;
#line 55
    return (266);
#line 56
    break;
    case 10: 
#line 56
    yylval.ival = 267U;
#line 56
    return (267);
#line 57
    break;
    case 11: 
#line 57
    yylval.ival = 268U;
#line 57
    return (268);
#line 58
    break;
    case 12: 
#line 58
    yylval.ival = 269U;
#line 58
    return (269);
#line 59
    break;
    case 13: 
#line 60
    yylval.ival = 281U;
#line 60
    return (281);
#line 61
    break;
    case 14: 
#line 61
    yylval.ival = 282U;
#line 61
    return (282);
#line 62
    break;
    case 15: 
#line 62
    yylval.ival = 283U;
#line 62
    return (283);
#line 63
    break;
    case 16: 
#line 64
    yylval.ival = 284U;
#line 64
    return (284);
#line 65
    break;
    case 17: 
#line 66
    tmp___1 = l_convertyyyymmdd(yytext);
#line 66
    yylval.ival = (unsigned int )tmp___1;
#line 66
    return (280);
#line 67
    break;
    case 18: 
#line 67
    tmp___2 = time((time_t *)((void *)0));
#line 67
    yylval.ival = (unsigned int )tmp___2;
#line 67
    return (280);
#line 68
    break;
    case 19: 
#line 68
    tmp___3 = time((time_t *)((void *)0));
#line 68
    yylval.ival = (unsigned int )(tmp___3 - 86400L);
#line 68
    return (280);
#line 69
    break;
    case 20: 
#line 69
    tmp___4 = time((time_t *)((void *)0));
#line 69
    yylval.ival = (unsigned int )(tmp___4 - 604800L);
#line 69
    return (280);
#line 70
    break;
    case 21: 
#line 70
    tmp___5 = time((time_t *)((void *)0));
#line 70
    yylval.ival = (unsigned int )(tmp___5 - 2592000L);
#line 70
    return (280);
#line 71
    break;
    case 22: 
#line 71
    tmp___6 = time((time_t *)((void *)0));
#line 71
    yylval.ival = (unsigned int )(tmp___6 - 31536000L);
#line 71
    return (280);
#line 72
    break;
    case 23: 
#line 73
    yylval.ival = 86400U;
#line 73
    return (288);
#line 74
    break;
    case 24: 
#line 74
    yylval.ival = 604800U;
#line 74
    return (288);
#line 75
    break;
    case 25: 
#line 75
    yylval.ival = 2592000U;
#line 75
    return (288);
#line 76
    break;
    case 26: 
#line 76
    yylval.ival = 31536000U;
#line 76
    return (288);
#line 77
    break;
    case 27: 
#line 78
    yylval.ival = 287U;
#line 78
    return (287);
#line 79
    break;
    case 28: 
#line 79
    yylval.ival = 285U;
#line 79
    return (285);
#line 80
    break;
    case 29: 
#line 80
    yylval.ival = 286U;
#line 80
    return (286);
#line 81
    break;
    case 30: 
#line 82
    yylval.ival = 275U;
#line 82
    return (275);
#line 83
    break;
    case 31: 
#line 83
    yylval.ival = 276U;
#line 83
    return (276);
#line 84
    break;
    case 32: 
#line 84
    yylval.ival = 270U;
#line 84
    return (270);
#line 85
    break;
    case 33: 
    case 34: 
#line 87
    yylval.ival = 259U;
#line 87
    return (259);
#line 88
    break;
    case 35: 
    case 36: 
#line 90
    yylval.ival = 258U;
#line 90
    return (258);
#line 91
    break;
    case 37: 
    case 38: 
#line 93
    yylval.ival = 1U;
#line 93
    return (277);
#line 94
    break;
    case 39: 
#line 95
    yylval.ival = 272U;
#line 95
    return (272);
#line 96
    break;
    case 40: 
#line 96
    yylval.ival = 271U;
#line 96
    return (271);
#line 97
    break;
    case 41: 
#line 97
    yylval.ival = 274U;
#line 97
    return (274);
#line 98
    break;
    case 42: 
#line 98
    yylval.ival = 273U;
#line 98
    return (273);
#line 99
    break;
    case 43: 
#line 100
    tmp___12 = __strdup((char const   *)(yytext + 1));
#line 100
    yylval.cval = tmp___12;
#line 101
    tmp___14 = strlen((char const   *)yylval.cval);
#line 101
    if ((int )*(yylval.cval + (tmp___14 - 1U)) == 34) {
#line 102
      tmp___13 = strlen((char const   *)yylval.cval);
#line 102
      *(yylval.cval + (tmp___13 - 1U)) = (char )'\000';
    }
#line 103
    return (278);
#line 104
    break;
    case 44: 
#line 105
    tmp___15 = atoi((char const   *)yytext);
#line 105
    yylval.ival = (unsigned int )tmp___15;
#line 105
    return (279);
#line 106
    break;
    case 45: 
#line 107
    return ((int )*(yytext + 0));
#line 108
    break;
    case 46: 
#line 109
    fwrite((void const   * __restrict  )yytext, (unsigned int )yyleng, 1U, (FILE * __restrict  )yyout);
#line 110
    break;
    case 48: 
#line 998 "lexer.c"
    return (0);
    case 47: 
#line 1003
    yy_amount_of_matched_text = (yy_cp - yytext) - 1;
#line 1006
    *yy_cp = yy_hold_char;
#line 1009
    if (yy_current_buffer->yy_buffer_status == 0) {
#line 1020
      yy_n_chars = yy_current_buffer->yy_n_chars;
#line 1021
      yy_current_buffer->yy_input_file = yyin;
#line 1022
      yy_current_buffer->yy_buffer_status = 1;
    }
#line 1032
    if ((unsigned int )yy_c_buf_p <= (unsigned int )(yy_current_buffer->yy_ch_buf + yy_n_chars)) {
#line 1036
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1038
      yy_current_state = yy_get_previous_state();
#line 1049
      yy_next_state = yy_try_NUL_trans(yy_current_state);
#line 1051
      yy_bp = yytext + 0;
#line 1053
      if (yy_next_state) {
#line 1056
        yy_c_buf_p ++;
#line 1056
        yy_cp = yy_c_buf_p;
#line 1057
        yy_current_state = yy_next_state;
        goto yy_match;
      } else {
#line 1063
        yy_cp = yy_c_buf_p;
        goto yy_find_action;
      }
    } else {
#line 1068
      tmp___16 = yy_get_next_buffer();
#line 1068
      switch (tmp___16) {
      case 1: 
#line 1072
      yy_did_buffer_switch_on_eof = 0;
#line 1074
      tmp___17 = yywrap();
#line 1074
      if (tmp___17) {
#line 1085
        yy_c_buf_p = yytext + 0;
#line 1087
        yy_act = (47 + (yy_start - 1) / 2) + 1;
        goto do_action;
      } else {
#line 1093
        if (! yy_did_buffer_switch_on_eof) {
#line 1094
          yyrestart(yyin);
        }
      }
#line 1096
      break;
      case 0: 
#line 1100
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1103
      yy_current_state = yy_get_previous_state();
#line 1105
      yy_cp = yy_c_buf_p;
#line 1106
      yy_bp = yytext + 0;
      goto yy_match;
      case 2: 
#line 1110
      yy_c_buf_p = yy_current_buffer->yy_ch_buf + yy_n_chars;
#line 1113
      yy_current_state = yy_get_previous_state();
#line 1115
      yy_cp = yy_c_buf_p;
#line 1116
      yy_bp = yytext + 0;
      goto yy_find_action;
      }
    }
#line 1119
    break;
    default: 
#line 1123
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
  }
}
}
#line 1138 "lexer.c"
static int yy_get_next_buffer(void) 
{ register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  int c ;
  int n ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
#line 1140
  dest = yy_current_buffer->yy_ch_buf;
#line 1141
  source = yytext;
#line 1145
  if ((unsigned int )yy_c_buf_p > (unsigned int )(yy_current_buffer->yy_ch_buf + (yy_n_chars + 1))) {
#line 1146
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
  }
#line 1149
  if (yy_current_buffer->yy_fill_buffer == 0) {
#line 1151
    if ((yy_c_buf_p - yytext) - 0 == 1) {
#line 1156
      return (1);
    } else {
#line 1164
      return (2);
    }
  }
#line 1171
  number_to_move = (yy_c_buf_p - yytext) - 1;
#line 1173
  i = 0;
#line 1173
  while (i < number_to_move) {
#line 1174
    tmp = dest;
#line 1174
    dest ++;
#line 1174
    tmp___0 = source;
#line 1174
    source ++;
#line 1174
    *tmp = *tmp___0;
#line 1173
    i ++;
  }
#line 1176
  if (yy_current_buffer->yy_buffer_status == 2) {
#line 1180
    yy_n_chars = 0;
#line 1180
    yy_current_buffer->yy_n_chars = yy_n_chars;
  } else {
#line 1184
    num_to_read = (int )((yy_current_buffer->yy_buf_size - (yy_size_t )number_to_move) - 1U);
#line 1187
    while (num_to_read <= 0) {
#line 1190
      yy_fatal_error("input buffer overflow, can\'t enlarge buffer because scanner uses REJECT");
    }
#line 1229
    if (num_to_read > 8192) {
#line 1230
      num_to_read = 8192;
    }
#line 1233
    if (yy_current_buffer->yy_is_interactive) {
#line 1233
      c = '*';
#line 1233
      n = 0;
#line 1233
      while (1) {
#line 1233
        if (n < num_to_read) {
#line 1233
          c = _IO_getc(yyin);
#line 1233
          if (c != -1) {
#line 1233
            if (! (c != 10)) {
#line 1233
              break;
            }
          } else {
#line 1233
            break;
          }
        } else {
#line 1233
          break;
        }
#line 1233
        *((yy_current_buffer->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1233
        n ++;
      }
#line 1233
      if (c == 10) {
#line 1233
        tmp___1 = n;
#line 1233
        n ++;
#line 1233
        *((yy_current_buffer->yy_ch_buf + number_to_move) + tmp___1) = (char )c;
      }
#line 1233
      if (c == -1) {
#line 1233
        tmp___2 = ferror(yyin);
#line 1233
        if (tmp___2) {
#line 1233
          yy_fatal_error("input in flex scanner failed");
        }
      }
#line 1233
      yy_n_chars = n;
    } else {
#line 1233
      tmp___3 = fread((void * __restrict  )(yy_current_buffer->yy_ch_buf + number_to_move),
                      1U, (unsigned int )num_to_read, (FILE * __restrict  )yyin);
#line 1233
      yy_n_chars = (int )tmp___3;
#line 1233
      if (yy_n_chars == 0) {
#line 1233
        tmp___4 = ferror(yyin);
#line 1233
        if (tmp___4) {
#line 1233
          yy_fatal_error("input in flex scanner failed");
        }
      }
    }
#line 1236
    yy_current_buffer->yy_n_chars = yy_n_chars;
  }
#line 1239
  if (yy_n_chars == 0) {
#line 1241
    if (number_to_move == 0) {
#line 1243
      ret_val = 1;
#line 1244
      yyrestart(yyin);
    } else {
#line 1249
      ret_val = 2;
#line 1250
      yy_current_buffer->yy_buffer_status = 2;
    }
  } else {
#line 1256
    ret_val = 0;
  }
#line 1258
  yy_n_chars += number_to_move;
#line 1259
  *(yy_current_buffer->yy_ch_buf + yy_n_chars) = (char)0;
#line 1260
  *(yy_current_buffer->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
#line 1262
  yytext = yy_current_buffer->yy_ch_buf + 0;
#line 1264
  return (ret_val);
}
}
#line 1270 "lexer.c"
static yy_state_type yy_get_previous_state(void) 
{ register yy_state_type yy_current_state ;
  register char *yy_cp ;
  yy_state_type *tmp ;
  register YY_CHAR yy_c ;
  int tmp___0 ;
  yy_state_type *tmp___1 ;

  {
#line 1275
  yy_current_state = yy_start;
#line 1276
  yy_state_ptr = yy_state_buf;
#line 1277
  tmp = yy_state_ptr;
#line 1277
  yy_state_ptr ++;
#line 1277
  *tmp = yy_current_state;
#line 1279
  yy_cp = yytext + 0;
#line 1279
  while ((unsigned int )yy_cp < (unsigned int )yy_c_buf_p) {
#line 1281
    if (*yy_cp) {
#line 1281
      tmp___0 = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1281
      tmp___0 = (int const   )1;
    }
#line 1281
    yy_c = (YY_CHAR )tmp___0;
#line 1282
    while ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state) {
#line 1284
      yy_current_state = (int )yy_def[yy_current_state];
#line 1285
      if (yy_current_state >= 179) {
#line 1286
        yy_c = (unsigned char )yy_meta[(unsigned int )yy_c];
      }
    }
#line 1288
    yy_current_state = (int )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1289
    tmp___1 = yy_state_ptr;
#line 1289
    yy_state_ptr ++;
#line 1289
    *tmp___1 = yy_current_state;
#line 1279
    yy_cp ++;
  }
#line 1292
  return (yy_current_state);
}
}
#line 1303 "lexer.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) 
{ register int yy_is_jam ;
  register YY_CHAR yy_c ;
  yy_state_type *tmp ;
  int tmp___0 ;

  {
#line 1311
  yy_c = (YY_CHAR )1;
#line 1312
  while ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state) {
#line 1314
    yy_current_state = (int )yy_def[yy_current_state];
#line 1315
    if (yy_current_state >= 179) {
#line 1316
      yy_c = (unsigned char )yy_meta[(unsigned int )yy_c];
    }
  }
#line 1318
  yy_current_state = (int )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1319
  yy_is_jam = yy_current_state == 178;
#line 1320
  if (! yy_is_jam) {
#line 1321
    tmp = yy_state_ptr;
#line 1321
    yy_state_ptr ++;
#line 1321
    *tmp = yy_current_state;
  }
#line 1323
  if (yy_is_jam) {
#line 1323
    tmp___0 = 0;
  } else {
#line 1323
    tmp___0 = yy_current_state;
  }
#line 1323
  return (tmp___0);
}
}
#line 1450 "lexer.c"
void yyrestart(FILE *input_file ) 
{ 

  {
#line 1456
  if (! yy_current_buffer) {
#line 1457
    yy_current_buffer = yy_create_buffer(yyin, 16384);
  }
#line 1459
  yy_init_buffer(yy_current_buffer, input_file);
#line 1460
  yy_load_buffer_state();
#line 1461
  return;
}
}
#line 1465 "lexer.c"
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 

  {
#line 1471
  if ((unsigned int )yy_current_buffer == (unsigned int )new_buffer) {
#line 1472
    return;
  }
#line 1474
  if (yy_current_buffer) {
#line 1477
    *yy_c_buf_p = yy_hold_char;
#line 1478
    yy_current_buffer->yy_buf_pos = yy_c_buf_p;
#line 1479
    yy_current_buffer->yy_n_chars = yy_n_chars;
  }
#line 1482
  yy_current_buffer = new_buffer;
#line 1483
  yy_load_buffer_state();
#line 1490
  yy_did_buffer_switch_on_eof = 1;
#line 1491
  return;
}
}
#line 1495 "lexer.c"
void yy_load_buffer_state(void) 
{ 

  {
#line 1500
  yy_n_chars = yy_current_buffer->yy_n_chars;
#line 1501
  yy_c_buf_p = yy_current_buffer->yy_buf_pos;
#line 1501
  yytext = yy_c_buf_p;
#line 1502
  yyin = yy_current_buffer->yy_input_file;
#line 1503
  yy_hold_char = *yy_c_buf_p;
#line 1504
  return;
}
}
#line 1508 "lexer.c"
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) 
{ YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1517
  tmp = yy_flex_alloc(sizeof(struct yy_buffer_state ));
#line 1517
  b = (struct yy_buffer_state *)tmp;
#line 1518
  if (! b) {
#line 1519
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
  }
#line 1521
  b->yy_buf_size = (unsigned int )size;
#line 1526
  tmp___0 = yy_flex_alloc(b->yy_buf_size + 2U);
#line 1526
  b->yy_ch_buf = (char *)tmp___0;
#line 1527
  if (! b->yy_ch_buf) {
#line 1528
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
  }
#line 1530
  b->yy_is_our_buffer = 1;
#line 1532
  yy_init_buffer(b, file);
#line 1534
  return (b);
}
}
#line 1539 "lexer.c"
void yy_delete_buffer(YY_BUFFER_STATE b ) 
{ 

  {
#line 1545
  if (! b) {
#line 1546
    return;
  }
#line 1548
  if ((unsigned int )b == (unsigned int )yy_current_buffer) {
#line 1549
    yy_current_buffer = (struct yy_buffer_state *)0;
  }
#line 1551
  if (b->yy_is_our_buffer) {
#line 1552
    yy_flex_free((void *)b->yy_ch_buf);
  }
#line 1554
  yy_flex_free((void *)b);
#line 1555
  return;
}
}
#line 1560
extern int isatty(int  ) ;
#line 1565 "lexer.c"
void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 1574
  yy_flush_buffer(b);
#line 1576
  b->yy_input_file = file;
#line 1577
  b->yy_fill_buffer = 1;
#line 1585
  if (file) {
#line 1585
    tmp = fileno(file);
#line 1585
    tmp___0 = isatty(tmp);
#line 1585
    b->yy_is_interactive = tmp___0 > 0;
  } else {
#line 1585
    b->yy_is_interactive = 0;
  }
#line 1588
  return;
}
}
#line 1592 "lexer.c"
void yy_flush_buffer(YY_BUFFER_STATE b ) 
{ 

  {
#line 1599
  if (! b) {
#line 1600
    return;
  }
#line 1602
  b->yy_n_chars = 0;
#line 1608
  *(b->yy_ch_buf + 0) = (char)0;
#line 1609
  *(b->yy_ch_buf + 1) = (char)0;
#line 1611
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1613
  b->yy_at_bol = 1;
#line 1614
  b->yy_buffer_status = 0;
#line 1616
  if ((unsigned int )b == (unsigned int )yy_current_buffer) {
#line 1617
    yy_load_buffer_state();
  }
#line 1618
  return;
}
}
#line 1623 "lexer.c"
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) 
{ YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 1632
  if (size < 2U) {
#line 1636
    return ((struct yy_buffer_state *)0);
  } else {
#line 1632
    if ((int )*(base + (size - 2U)) != 0) {
#line 1636
      return ((struct yy_buffer_state *)0);
    } else {
#line 1632
      if ((int )*(base + (size - 1U)) != 0) {
#line 1636
        return ((struct yy_buffer_state *)0);
      }
    }
  }
#line 1638
  tmp = yy_flex_alloc(sizeof(struct yy_buffer_state ));
#line 1638
  b = (struct yy_buffer_state *)tmp;
#line 1639
  if (! b) {
#line 1640
    yy_fatal_error("out of dynamic memory in yy_scan_buffer()");
  }
#line 1642
  b->yy_buf_size = size - 2U;
#line 1643
  tmp___0 = base;
#line 1643
  b->yy_ch_buf = tmp___0;
#line 1643
  b->yy_buf_pos = tmp___0;
#line 1644
  b->yy_is_our_buffer = 0;
#line 1645
  b->yy_input_file = (FILE *)0;
#line 1646
  b->yy_n_chars = (int )b->yy_buf_size;
#line 1647
  b->yy_is_interactive = 0;
#line 1648
  b->yy_at_bol = 1;
#line 1649
  b->yy_fill_buffer = 0;
#line 1650
  b->yy_buffer_status = 0;
#line 1652
  yy_switch_to_buffer(b);
#line 1654
  return (b);
}
}
#line 1661 "lexer.c"
YY_BUFFER_STATE yy_scan_string(char const   *yy_str ) 
{ int len ;
  YY_BUFFER_STATE tmp ;

  {
#line 1668
  len = 0;
#line 1668
  while (*(yy_str + len)) {
#line 1668
    len ++;
  }
#line 1671
  tmp = yy_scan_bytes(yy_str, len);
#line 1671
  return (tmp);
}
}
#line 1678 "lexer.c"
YY_BUFFER_STATE yy_scan_bytes(char const   *bytes , int len ) 
{ YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;

  {
#line 1691
  n = (unsigned int )(len + 2);
#line 1692
  tmp = yy_flex_alloc(n);
#line 1692
  buf = (char *)tmp;
#line 1693
  if (! buf) {
#line 1694
    yy_fatal_error("out of dynamic memory in yy_scan_bytes()");
  }
#line 1696
  i = 0;
#line 1696
  while (i < len) {
#line 1697
    *(buf + i) = (char )*(bytes + i);
#line 1696
    i ++;
  }
#line 1699
  tmp___0 = (char)0;
#line 1699
  *(buf + (len + 1)) = tmp___0;
#line 1699
  *(buf + len) = tmp___0;
#line 1701
  b = yy_scan_buffer(buf, n);
#line 1702
  if (! b) {
#line 1703
    yy_fatal_error("bad buffer in yy_scan_bytes()");
  }
#line 1708
  b->yy_is_our_buffer = 1;
#line 1710
  return (b);
}
}
#line 1772 "lexer.c"
static void yy_fatal_error(char const   *msg ) 
{ 

  {
#line 1778
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", msg);
#line 1779
  exit(2);
}
}
#line 1836 "lexer.c"
static void *yy_flex_alloc(yy_size_t size ) 
{ void *tmp ;

  {
#line 1842
  tmp = malloc(size);
#line 1842
  return (tmp);
}
}
#line 1864 "lexer.c"
static void yy_flex_free(void *ptr ) 
{ 

  {
#line 1870
  free(ptr);
#line 1871
  return;
}
}
#line 111 "lexer.l"
time_t l_convertyyyymmdd(char *date ) 
{ char year[5] ;
  char month[3] ;
  char day[3] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  time_t tmp___5 ;

  {
#line 116
  memset((void *)(year), 0, sizeof(year));
#line 117
  memset((void *)(month), 0, sizeof(month));
#line 118
  memset((void *)(day), 0, sizeof(day));
#line 120
  __builtin_strncpy(year, (char const   *)date, 4U);
#line 121
  __builtin_strncpy(month, (char const   *)(date + 5), 2U);
#line 122
  __builtin_strncpy(day, (char const   *)(date + 8), 2U);
#line 124
  tmp = atoi((char const   *)(day));
#line 124
  tmp___0 = atoi((char const   *)(month));
#line 124
  tmp___1 = atoi((char const   *)(year));
#line 124
  err_log(5, 128U, (char *)"Converting %d-%d-%d\n", tmp___1, tmp___0, tmp);
#line 125
  tmp___2 = atoi((char const   *)(year));
#line 125
  tmp___3 = atoi((char const   *)(month));
#line 125
  tmp___4 = atoi((char const   *)(day));
#line 125
  tmp___5 = l_converttime(tmp___4, tmp___3, tmp___2);
#line 125
  return (tmp___5);
}
}
#line 128 "lexer.l"
time_t l_converttime(int day , int month , int year ) 
{ struct tm tm ;
  time_t tmp ;

  {
#line 131
  memset((void *)(& tm), 0, sizeof(tm));
#line 132
  tm.tm_year = year - 1900;
#line 133
  tm.tm_mon = month - 1;
#line 134
  tm.tm_mday = day;
#line 136
  tmp = mktime(& tm);
#line 136
  return (tmp);
}
}
#line 139 "lexer.l"
int yywrap(void) 
{ 

  {
#line 140
  return (1);
}
}
#line 143 "lexer.l"
void yyerror(char *msg ) 
{ 

  {
#line 144
  pl_error = 1;
#line 145
  err_log(1, 128U, (char *)"Playlist error, line %d: %s\n", yylineno, msg);
#line 146
  return;
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned int  ) ;  */
#line 1 "parser.o"
#pragma merger(0,"/tmp/cil-WYznNls7.i","-g,-g,-O2")
#line 37 "parser.y"
PL_NODE *pl_newcharpredicate(int tag , int op , char *value ) ;
#line 38
PL_NODE *pl_newintpredicate(int tag , int op , int value ) ;
#line 39
PL_NODE *pl_newdatepredicate(int tag , int op , int value ) ;
#line 40
PL_NODE *pl_newexpr(PL_NODE *arg1 , int op , PL_NODE *arg2 ) ;
#line 41
int pl_addplaylist(char *name , PL_NODE *root ) ;
#line 45 "parser.y"
int pl_number  =    2;
#line 462 "parser.c"
static yytype_uint8 const   yytranslate[289]  = 
#line 462 "parser.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )37,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )35,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33};
#line 538 "parser.c"
static char const   * const  yytname[52]  = 
#line 538
  {      (char const   * const  )"$end",      (char const   * const  )"error",      (char const   * const  )"$undefined",      (char const   * const  )"AND", 
        (char const   * const  )"OR",      (char const   * const  )"ARTIST",      (char const   * const  )"ALBUM",      (char const   * const  )"GENRE", 
        (char const   * const  )"PATH",      (char const   * const  )"COMPOSER",      (char const   * const  )"ORCHESTRA",      (char const   * const  )"CONDUCTOR", 
        (char const   * const  )"GROUPING",      (char const   * const  )"TYPE",      (char const   * const  )"COMMENT",      (char const   * const  )"EQUALS", 
        (char const   * const  )"LESS",      (char const   * const  )"LESSEQUAL",      (char const   * const  )"GREATER",      (char const   * const  )"GREATEREQUAL", 
        (char const   * const  )"IS",      (char const   * const  )"INCLUDES",      (char const   * const  )"NOT",      (char const   * const  )"ID", 
        (char const   * const  )"NUM",      (char const   * const  )"DATE",      (char const   * const  )"YEAR",      (char const   * const  )"BPM", 
        (char const   * const  )"BITRATE",      (char const   * const  )"DATEADDED",      (char const   * const  )"BEFORE",      (char const   * const  )"AFTER", 
        (char const   * const  )"AGO",      (char const   * const  )"INTERVAL",      (char const   * const  )"\'{\'",      (char const   * const  )"\'}\'", 
        (char const   * const  )"\'(\'",      (char const   * const  )"\')\'",      (char const   * const  )"$accept",      (char const   * const  )"playlistlist", 
        (char const   * const  )"playlist",      (char const   * const  )"expression",      (char const   * const  )"predicate",      (char const   * const  )"datetag", 
        (char const   * const  )"inttag",      (char const   * const  )"intbool",      (char const   * const  )"datebool",      (char const   * const  )"interval", 
        (char const   * const  )"dateval",      (char const   * const  )"strtag",      (char const   * const  )"strbool",      (char const   * const  )0};
#line 564 "parser.c"
static yytype_uint8 const   yyr1[44]  = 
#line 564
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )41,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )44,      (yytype_uint8 const   )44,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )48,      (yytype_uint8 const   )48,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )50,      (yytype_uint8 const   )50};
#line 574 "parser.c"
static yytype_uint8 const   yyr2[44]  = 
#line 574
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2};
#line 586 "parser.c"
static yytype_uint8 const   yydefact[65]  = 
#line 586
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )4,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )0,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )41,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )7,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )24,      (yytype_uint8 const   )0,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )0,      (yytype_uint8 const   )11,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )43,      (yytype_uint8 const   )9,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )30,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29};
#line 598 "parser.c"
static yytype_int8 const   yydefgoto[13]  = 
#line 598
  {      (yytype_int8 const   )-1,      (yytype_int8 const   )2,      (yytype_int8 const   )3,      (yytype_int8 const   )22, 
        (yytype_int8 const   )23,      (yytype_int8 const   )24,      (yytype_int8 const   )25,      (yytype_int8 const   )41, 
        (yytype_int8 const   )34,      (yytype_int8 const   )53,      (yytype_int8 const   )54,      (yytype_int8 const   )26, 
        (yytype_int8 const   )45};
#line 607 "parser.c"
static yytype_int8 const   yypact[65]  = 
#line 607
  {      (yytype_int8 const   )-18,      (yytype_int8 const   )-12,      (yytype_int8 const   )2,      (yytype_int8 const   )-29, 
        (yytype_int8 const   )1,      (yytype_int8 const   )-29,      (yytype_int8 const   )-29,      (yytype_int8 const   )-29, 
        (yytype_int8 const   )-29,      (yytype_int8 const   )-29,      (yytype_int8 const   )-29,      (yytype_int8 const   )-29, 
        (yytype_int8 const   )-29,      (yytype_int8 const   )-29,      (yytype_int8 const   )-29,      (yytype_int8 const   )-29, 
        (yytype_int8 const   )-29,      (yytype_int8 const   )-29,      (yytype_int8 const   )-29,      (yytype_int8 const   )-29, 
        (yytype_int8 const   )-29,      (yytype_int8 const   )1,      (yytype_int8 const   )0,      (yytype_int8 const   )-29, 
        (yytype_int8 const   )9,      (yytype_int8 const   )26,      (yytype_int8 const   )-1,      (yytype_int8 const   )-3, 
        (yytype_int8 const   )1,      (yytype_int8 const   )1,      (yytype_int8 const   )-29,      (yytype_int8 const   )9, 
        (yytype_int8 const   )-29,      (yytype_int8 const   )-29,      (yytype_int8 const   )-7,      (yytype_int8 const   )-29, 
        (yytype_int8 const   )-29,      (yytype_int8 const   )-29,      (yytype_int8 const   )-29,      (yytype_int8 const   )-29, 
        (yytype_int8 const   )26,      (yytype_int8 const   )12,      (yytype_int8 const   )-29,      (yytype_int8 const   )-29, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )15,      (yytype_int8 const   )-29,      (yytype_int8 const   )-29, 
        (yytype_int8 const   )-29,      (yytype_int8 const   )-29,      (yytype_int8 const   )13,      (yytype_int8 const   )-29, 
        (yytype_int8 const   )-29,      (yytype_int8 const   )19,      (yytype_int8 const   )-29,      (yytype_int8 const   )-29, 
        (yytype_int8 const   )-29,      (yytype_int8 const   )-29,      (yytype_int8 const   )-29,      (yytype_int8 const   )-29, 
        (yytype_int8 const   )-7,      (yytype_int8 const   )-7,      (yytype_int8 const   )-29,      (yytype_int8 const   )-29, 
        (yytype_int8 const   )-29};
#line 619 "parser.c"
static yytype_int8 const   yypgoto[13]  = 
#line 619
  {      (yytype_int8 const   )-29,      (yytype_int8 const   )-29,      (yytype_int8 const   )45,      (yytype_int8 const   )-5, 
        (yytype_int8 const   )-29,      (yytype_int8 const   )-29,      (yytype_int8 const   )-29,      (yytype_int8 const   )14, 
        (yytype_int8 const   )21,      (yytype_int8 const   )-29,      (yytype_int8 const   )-28,      (yytype_int8 const   )-29, 
        (yytype_int8 const   )11};
#line 630 "parser.c"
static yytype_uint8 const   yytable[56]  = 
#line 630
  {      (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )5,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )1,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )27,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )44,      (yytype_uint8 const   )4,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )1,      (yytype_uint8 const   )52,      (yytype_uint8 const   )17, 
        (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )64,      (yytype_uint8 const   )46,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )21,      (yytype_uint8 const   )58,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )59,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )60,      (yytype_uint8 const   )61,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )0,      (yytype_uint8 const   )55,      (yytype_uint8 const   )57};
#line 640 "parser.c"
static yytype_int8 const   yycheck[56]  = 
#line 640
  {      (yytype_int8 const   )3,      (yytype_int8 const   )4,      (yytype_int8 const   )0,      (yytype_int8 const   )3, 
        (yytype_int8 const   )4,      (yytype_int8 const   )23,      (yytype_int8 const   )5,      (yytype_int8 const   )6, 
        (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10, 
        (yytype_int8 const   )11,      (yytype_int8 const   )12,      (yytype_int8 const   )13,      (yytype_int8 const   )14, 
        (yytype_int8 const   )21,      (yytype_int8 const   )24,      (yytype_int8 const   )25,      (yytype_int8 const   )20, 
        (yytype_int8 const   )21,      (yytype_int8 const   )22,      (yytype_int8 const   )34,      (yytype_int8 const   )28, 
        (yytype_int8 const   )29,      (yytype_int8 const   )23,      (yytype_int8 const   )33,      (yytype_int8 const   )26, 
        (yytype_int8 const   )27,      (yytype_int8 const   )28,      (yytype_int8 const   )29,      (yytype_int8 const   )22, 
        (yytype_int8 const   )60,      (yytype_int8 const   )61,      (yytype_int8 const   )37,      (yytype_int8 const   )35, 
        (yytype_int8 const   )24,      (yytype_int8 const   )36,      (yytype_int8 const   )23,      (yytype_int8 const   )30, 
        (yytype_int8 const   )31,      (yytype_int8 const   )15,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )18,      (yytype_int8 const   )19,      (yytype_int8 const   )33,      (yytype_int8 const   )2, 
        (yytype_int8 const   )22,      (yytype_int8 const   )30,      (yytype_int8 const   )31,      (yytype_int8 const   )32, 
        (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )40,      (yytype_int8 const   )44};
#line 652 "parser.c"
static yytype_uint8 const   yystos[65]  = 
#line 652
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )23,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )34,      (yytype_uint8 const   )0,      (yytype_uint8 const   )40,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )36,      (yytype_uint8 const   )41,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )44,      (yytype_uint8 const   )49,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )35,      (yytype_uint8 const   )22, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )46,      (yytype_uint8 const   )15, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )45,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )50,      (yytype_uint8 const   )37,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )46,      (yytype_uint8 const   )24,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )50,      (yytype_uint8 const   )23,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )48};
#line 965 "parser.c"
static char *yystpcpy(char *yydest , char const   *yysrc ) 
{ char *yyd ;
  char const   *yys ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;

  {
#line 974
  yyd = yydest;
#line 975
  yys = yysrc;
#line 977
  while (1) {
#line 977
    tmp = yyd;
#line 977
    yyd ++;
#line 977
    tmp___1 = yys;
#line 977
    yys ++;
#line 977
    tmp___0 = (char )*tmp___1;
#line 977
    *tmp = tmp___0;
#line 977
    if (! ((int )tmp___0 != 0)) {
#line 977
      break;
    }
#line 978
    continue;
  }
#line 980
  return (yyd - 1);
}
}
#line 993 "parser.c"
static unsigned int yytnamerr(char *yyres , char const   *yystr ) 
{ unsigned int yyn ;
  char const   *yyp ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 996
  if ((int const   )*yystr == 34) {
#line 998
    yyn = 0U;
#line 999
    yyp = yystr;
#line 1001
    while (1) {
#line 1002
      yyp ++;
#line 1002
      switch ((int )*yyp) {
      case 39: 
      case 44: 
      goto do_not_strip_quotes;
      case 92: 
#line 1009
      yyp ++;
#line 1009
      if ((int const   )*yyp != 92) {
        goto do_not_strip_quotes;
      }
      default: ;
#line 1013
      if (yyres) {
#line 1014
        *(yyres + yyn) = (char )*yyp;
      }
#line 1015
      yyn ++;
#line 1016
      break;
      case 34: 
#line 1019
      if (yyres) {
#line 1020
        *(yyres + yyn) = (char )'\000';
      }
#line 1021
      return (yyn);
      }
    }
    do_not_strip_quotes: ;
  }
#line 1026
  if (! yyres) {
#line 1027
    tmp = strlen(yystr);
#line 1027
    return (tmp);
  }
#line 1029
  tmp___0 = yystpcpy(yyres, yystr);
#line 1029
  return ((unsigned int )(tmp___0 - yyres));
}
}
#line 1069
static unsigned int yysyntax_error(char *yyresult , int yystate , int yychar___0 ) ;
#line 1069 "parser.c"
static char const   yyunexpected[28]  = 
#line 1069
  {      (char const   )'s',      (char const   )'y',      (char const   )'n',      (char const   )'t', 
        (char const   )'a',      (char const   )'x',      (char const   )' ',      (char const   )'e', 
        (char const   )'r',      (char const   )'r',      (char const   )'o',      (char const   )'r', 
        (char const   )',',      (char const   )' ',      (char const   )'u',      (char const   )'n', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 1070 "parser.c"
static char const   yyexpecting[15]  = 
#line 1070
  {      (char const   )',',      (char const   )' ',      (char const   )'e',      (char const   )'x', 
        (char const   )'p',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 1071 "parser.c"
static char const   yyor[7]  = {      (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 1040 "parser.c"
static unsigned int yysyntax_error(char *yyresult , int yystate , int yychar___0 ) 
{ int yyn ;
  int yytype ;
  int tmp ;
  unsigned int yysize0 ;
  unsigned int tmp___0 ;
  unsigned int yysize ;
  unsigned int yysize1 ;
  int yysize_overflow ;
  char const   *yyarg[5] ;
  int yyx ;
  char *yyfmt ;
  char const   *yyf ;
  char yyformat[((sizeof(yyunexpected) + sizeof(yyexpecting)) - 1U) + 3U * (sizeof(yyor) - 1U)] ;
  char const   *yyprefix ;
  int yyxbegin ;
  int tmp___1 ;
  int yychecklim ;
  int yyxend ;
  int tmp___2 ;
  int yycount ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  size_t tmp___5 ;
  char *yyp ;
  int yyi ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  char tmp___8 ;

  {
#line 1043
  yyn = (int )yypact[yystate];
#line 1045
  if (-29 < yyn) {
#line 1045
    if (yyn <= 55) {
#line 1049
      if ((unsigned int )yychar___0 <= 288U) {
#line 1049
        tmp = (int const   )yytranslate[yychar___0];
      } else {
#line 1049
        tmp = (int const   )2;
      }
#line 1049
      yytype = (int )tmp;
#line 1050
      tmp___0 = yytnamerr((char *)0, (char const   *)yytname[yytype]);
#line 1050
      yysize0 = tmp___0;
#line 1051
      yysize = yysize0;
#line 1053
      yysize_overflow = 0;
#line 1076
      yyprefix = yyexpecting;
#line 1080
      if (yyn < 0) {
#line 1080
        tmp___1 = - yyn;
      } else {
#line 1080
        tmp___1 = 0;
      }
#line 1080
      yyxbegin = tmp___1;
#line 1083
      yychecklim = (55 - yyn) + 1;
#line 1084
      if (yychecklim < 38) {
#line 1084
        tmp___2 = yychecklim;
      } else {
#line 1084
        tmp___2 = 38;
      }
#line 1084
      yyxend = tmp___2;
#line 1085
      yycount = 1;
#line 1087
      yyarg[0] = (char const   *)yytname[yytype];
#line 1088
      yyfmt = yystpcpy(yyformat, yyunexpected);
#line 1090
      yyx = yyxbegin;
#line 1090
      while (yyx < yyxend) {
#line 1091
        if ((int const   )yycheck[yyx + yyn] == (int const   )yyx) {
#line 1091
          if (yyx != 1) {
#line 1093
            if (yycount == 5) {
#line 1095
              yycount = 1;
#line 1096
              yysize = yysize0;
#line 1097
              yyformat[sizeof(yyunexpected) - 1U] = (char )'\000';
#line 1098
              break;
            }
#line 1100
            tmp___3 = yycount;
#line 1100
            yycount ++;
#line 1100
            yyarg[tmp___3] = (char const   *)yytname[yyx];
#line 1101
            tmp___4 = yytnamerr((char *)0, (char const   *)yytname[yyx]);
#line 1101
            yysize1 = yysize + tmp___4;
#line 1102
            yysize_overflow |= yysize1 < yysize;
#line 1103
            yysize = yysize1;
#line 1104
            yyfmt = yystpcpy(yyfmt, yyprefix);
#line 1105
            yyprefix = yyor;
          }
        }
#line 1090
        yyx ++;
      }
#line 1108
      yyf = (char const   *)(yyformat);
#line 1109
      tmp___5 = strlen(yyf);
#line 1109
      yysize1 = yysize + tmp___5;
#line 1110
      yysize_overflow |= yysize1 < yysize;
#line 1111
      yysize = yysize1;
#line 1113
      if (yysize_overflow) {
#line 1114
        return (4294967295U);
      }
#line 1116
      if (yyresult) {
#line 1121
        yyp = yyresult;
#line 1122
        yyi = 0;
#line 1123
        while (1) {
#line 1123
          tmp___8 = (char )*yyf;
#line 1123
          *yyp = tmp___8;
#line 1123
          if (! ((int )tmp___8 != 0)) {
#line 1123
            break;
          }
#line 1125
          if ((int )*yyp == 37) {
#line 1125
            if ((int const   )*(yyf + 1) == 115) {
#line 1125
              if (yyi < yycount) {
#line 1127
                tmp___6 = yyi;
#line 1127
                yyi ++;
#line 1127
                tmp___7 = yytnamerr(yyp, yyarg[tmp___6]);
#line 1127
                yyp += tmp___7;
#line 1128
                yyf += 2;
              } else {
#line 1132
                yyp ++;
#line 1133
                yyf ++;
              }
            } else {
#line 1132
              yyp ++;
#line 1133
              yyf ++;
            }
          } else {
#line 1132
            yyp ++;
#line 1133
            yyf ++;
          }
        }
      }
#line 1137
      return (yysize);
    } else {
#line 1046
      return (0U);
    }
  } else {
#line 1046
    return (0U);
  }
}
}
#line 1150 "parser.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep ) 
{ 

  {
#line 1162
  if (! yymsg) {
#line 1163
    yymsg = "Deleting";
  }
#line 1166
  switch (yytype) {
  default: ;
#line 1170
  break;
  }
#line 1172
  return;
}
}
#line 1194 "parser.c"
int yychar  ;
#line 1197 "parser.c"
YYSTYPE yylval  ;
#line 1200 "parser.c"
int yynerrs  ;
#line 1221 "parser.c"
int yyparse(void) 
{ int yystate ;
  int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yytoken ;
  char yymsgbuf[128] ;
  char *yymsg ;
  unsigned int yymsg_alloc ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[200] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned int yystacksize ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned int yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned int yynewbytes ;
  unsigned int yynewbytes___0 ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int yysize___0 ;
  unsigned int tmp___2 ;
  unsigned int yyalloc ;
  void *tmp___3 ;

  {
#line 1237
  yytoken = 0;
#line 1241
  yymsg = yymsgbuf;
#line 1242
  yymsg_alloc = sizeof(yymsgbuf);
#line 1255
  yyss = yyssa;
#line 1260
  yyvs = yyvsa;
#line 1267
  yystacksize = 200U;
#line 1276
  yylen = 0;
#line 1280
  yystate = 0;
#line 1281
  yyerrstatus = 0;
#line 1282
  yynerrs = 0;
#line 1283
  yychar = -2;
#line 1290
  yyssp = yyss;
#line 1291
  yyvsp = yyvs;
  goto yysetstate;
  yynewstate: 
#line 1301
  yyssp ++;
  yysetstate: 
#line 1304
  *yyssp = (short )yystate;
#line 1306
  if ((unsigned int )((yyss + yystacksize) - 1) <= (unsigned int )yyssp) {
#line 1309
    yysize = (unsigned int )((yyssp - yyss) + 1);
#line 1338
    if (10000U <= yystacksize) {
      goto yyexhaustedlab;
    }
#line 1340
    yystacksize *= 2U;
#line 1341
    if (10000U < yystacksize) {
#line 1342
      yystacksize = 10000U;
    }
#line 1345
    yyss1 = yyss;
#line 1346
    tmp = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1U));
#line 1346
    yyptr = (union yyalloc *)tmp;
#line 1348
    if (! yyptr) {
      goto yyexhaustedlab;
    }
#line 1350
    while (1) {
#line 1350
      __builtin_memcpy((void *)(& yyptr->yyss), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1350
      yyss = & yyptr->yyss;
#line 1350
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1U);
#line 1350
      yyptr += yynewbytes / sizeof(*yyptr);
#line 1350
      break;
    }
#line 1351
    while (1) {
#line 1351
      __builtin_memcpy((void *)(& yyptr->yyvs), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1351
      yyvs = & yyptr->yyvs;
#line 1351
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1U);
#line 1351
      yyptr += yynewbytes___0 / sizeof(*yyptr);
#line 1351
      break;
    }
#line 1354
    if ((unsigned int )yyss1 != (unsigned int )(yyssa)) {
#line 1355
      free((void *)yyss1);
    }
#line 1360
    yyssp = (yyss + yysize) - 1;
#line 1361
    yyvsp = (yyvs + yysize) - 1;
#line 1367
    if ((unsigned int )((yyss + yystacksize) - 1) <= (unsigned int )yyssp) {
      goto yyabortlab;
    }
  }
  goto yybackup;
  yybackup: 
#line 1384
  yyn = (int )yypact[yystate];
#line 1385
  if (yyn == -29) {
    goto yydefault;
  }
#line 1391
  if (yychar == -2) {
#line 1394
    yychar = yylex();
  }
#line 1397
  if (yychar <= 0) {
#line 1399
    yytoken = 0;
#line 1399
    yychar = yytoken;
  } else {
#line 1404
    if ((unsigned int )yychar <= 288U) {
#line 1404
      yytoken = (int )yytranslate[yychar];
    } else {
#line 1404
      yytoken = 2;
    }
  }
#line 1410
  yyn += yytoken;
#line 1411
  if (yyn < 0) {
    goto yydefault;
  } else {
#line 1411
    if (55 < yyn) {
      goto yydefault;
    } else {
#line 1411
      if ((int const   )yycheck[yyn] != (int const   )yytoken) {
        goto yydefault;
      }
    }
  }
#line 1413
  yyn = (int )yytable[yyn];
#line 1414
  if (yyn <= 0) {
#line 1416
    if (yyn == 0) {
      goto yyerrlab;
    } else {
#line 1416
      if (yyn == -1) {
        goto yyerrlab;
      }
    }
#line 1418
    yyn = - yyn;
    goto yyreduce;
  }
#line 1422
  if (yyn == 5) {
    goto yyacceptlab;
  }
#line 1427
  if (yyerrstatus) {
#line 1428
    yyerrstatus --;
  }
#line 1434
  if (yychar != 0) {
#line 1435
    yychar = -2;
  }
#line 1437
  yystate = yyn;
#line 1438
  yyvsp ++;
#line 1438
  *yyvsp = yylval;
  goto yynewstate;
  yydefault: 
#line 1447
  yyn = (int )yydefact[yystate];
#line 1448
  if (yyn == 0) {
    goto yyerrlab;
  }
  goto yyreduce;
  yyreduce: 
#line 1458
  yylen = (int )yyr2[yyn];
#line 1468
  yyval = *(yyvsp + (1 - yylen));
#line 1472
  switch (yyn) {
  case 2: ;
#line 109 "parser.y"
  break;
  case 3: ;
#line 110
  break;
  case 4: 
#line 112
  tmp___0 = pl_addplaylist((yyvsp + -3)->cval, (yyvsp + -1)->plval);
#line 112
  yyval.ival = (unsigned int )tmp___0;
#line 113
  break;
  case 5: 
#line 115
  yyval.plval = pl_newexpr((yyvsp + -2)->plval, (int )(yyvsp + -1)->ival, (yyvsp + 0)->plval);
#line 116
  break;
  case 6: 
#line 116
  yyval.plval = pl_newexpr((yyvsp + -2)->plval, (int )(yyvsp + -1)->ival, (yyvsp + 0)->plval);
#line 117
  break;
  case 7: 
#line 117
  yyval.plval = (yyvsp + -1)->plval;
#line 118
  break;
  case 9: 
#line 121
  yyval.plval = pl_newcharpredicate((int )(yyvsp + -2)->ival, (int )(yyvsp + -1)->ival,
                                    (yyvsp + 0)->cval);
#line 122
  break;
  case 10: 
#line 122
  yyval.plval = pl_newintpredicate((int )(yyvsp + -2)->ival, (int )(yyvsp + -1)->ival,
                                   (int )(yyvsp + 0)->ival);
#line 123
  break;
  case 11: 
#line 123
  yyval.plval = pl_newdatepredicate((int )(yyvsp + -2)->ival, (int )(yyvsp + -1)->ival,
                                    (int )(yyvsp + 0)->ival);
#line 124
  break;
  case 12: 
#line 126
  yyval.ival = (yyvsp + 0)->ival;
#line 127
  break;
  case 16: 
#line 134
  yyval.ival = (yyvsp + 0)->ival;
#line 135
  break;
  case 17: 
#line 135
  yyval.ival = (yyvsp + 0)->ival;
#line 136
  break;
  case 18: 
#line 136
  yyval.ival = (yyvsp + 0)->ival;
#line 137
  break;
  case 19: 
#line 137
  yyval.ival = (yyvsp + 0)->ival;
#line 138
  break;
  case 20: 
#line 138
  yyval.ival = (yyvsp + 0)->ival;
#line 139
  break;
  case 21: 
#line 139
  yyval.ival = (yyvsp + 0)->ival | 2147483648U;
#line 140
  break;
  case 22: 
#line 142
  yyval.ival = (yyvsp + 0)->ival;
#line 143
  break;
  case 23: 
#line 143
  yyval.ival = (yyvsp + 0)->ival;
#line 144
  break;
  case 24: 
#line 144
  yyval.ival = (yyvsp + 0)->ival | 2147483648U;
#line 145
  break;
  case 25: 
#line 147
  yyval.ival = (yyvsp + 0)->ival;
#line 148
  break;
  case 26: 
#line 148
  yyval.ival = (yyvsp + -1)->ival * (yyvsp + 0)->ival;
#line 149
  break;
  case 27: 
#line 151
  yyval.ival = (yyvsp + 0)->ival;
#line 152
  break;
  case 28: 
#line 152
  yyval.ival = (yyvsp + 0)->ival - (yyvsp + -2)->ival;
#line 153
  break;
  case 29: 
#line 153
  yyval.ival = (yyvsp + 0)->ival + (yyvsp + -2)->ival;
#line 154
  break;
  case 30: 
#line 154
  tmp___1 = (int )time((void *)0);
#line 154
  yyval.ival = (unsigned int )tmp___1 - (yyvsp + -1)->ival;
#line 155
  break;
  case 41: 
#line 169
  yyval.ival = (yyvsp + 0)->ival;
#line 170
  break;
  case 42: 
#line 170
  yyval.ival = (yyvsp + 0)->ival;
#line 171
  break;
  case 43: 
#line 171
  yyval.ival = (yyvsp + 0)->ival | 2147483648U;
#line 172
  break;
  default: ;
#line 1617 "parser.c"
  break;
  }
#line 1621
  yyvsp -= yylen;
#line 1621
  yyssp -= yylen;
#line 1622
  yylen = 0;
#line 1625
  yyvsp ++;
#line 1625
  *yyvsp = yyval;
#line 1632
  yyn = (int )yyr1[yyn];
#line 1634
  yystate = (int )((int const   )yypgoto[yyn - 38] + (int const   )*yyssp);
#line 1635
  if (0 <= yystate) {
#line 1635
    if (yystate <= 55) {
#line 1635
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 1636
        yystate = (int )yytable[yystate];
      } else {
#line 1638
        yystate = (int )yydefgoto[yyn - 38];
      }
    } else {
#line 1638
      yystate = (int )yydefgoto[yyn - 38];
    }
  } else {
#line 1638
    yystate = (int )yydefgoto[yyn - 38];
  }
  goto yynewstate;
  yyerrlab: 
#line 1648
  if (! yyerrstatus) {
#line 1650
    yynerrs ++;
#line 1655
    tmp___2 = yysyntax_error((char *)0, yystate, yychar);
#line 1655
    yysize___0 = tmp___2;
#line 1656
    if (yymsg_alloc < yysize___0) {
#line 1656
      if (yymsg_alloc < 4294967295U) {
#line 1658
        yyalloc = 2U * yysize___0;
#line 1659
        if (yysize___0 <= yyalloc) {
#line 1659
          if (! (yyalloc <= 4294967295U)) {
#line 1660
            yyalloc = 4294967295U;
          }
        } else {
#line 1660
          yyalloc = 4294967295U;
        }
#line 1661
        if ((unsigned int )yymsg != (unsigned int )(yymsgbuf)) {
#line 1662
          free((void *)yymsg);
        }
#line 1663
        tmp___3 = malloc(yyalloc);
#line 1663
        yymsg = (char *)tmp___3;
#line 1664
        if (yymsg) {
#line 1665
          yymsg_alloc = yyalloc;
        } else {
#line 1668
          yymsg = yymsgbuf;
#line 1669
          yymsg_alloc = sizeof(yymsgbuf);
        }
      }
    }
#line 1673
    if (0U < yysize___0) {
#line 1673
      if (yysize___0 <= yymsg_alloc) {
#line 1675
        yysyntax_error(yymsg, yystate, yychar);
#line 1676
        yyerror(yymsg);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 1680
      yyerror((char *)"syntax error");
#line 1681
      if (yysize___0 != 0U) {
        goto yyexhaustedlab;
      }
    }
  }
#line 1690
  if (yyerrstatus == 3) {
#line 1695
    if (yychar <= 0) {
#line 1698
      if (yychar == 0) {
        goto yyabortlab;
      }
    } else {
#line 1703
      yydestruct("Error: discarding", yytoken, & yylval);
#line 1705
      yychar = -2;
    }
  }
  goto yyerrlab1;
#line 1727
  yyvsp -= yylen;
#line 1727
  yyssp -= yylen;
#line 1728
  yylen = 0;
#line 1730
  yystate = (int )*yyssp;
  goto yyerrlab1;
  yyerrlab1: 
#line 1738
  yyerrstatus = 3;
#line 1740
  while (1) {
#line 1742
    yyn = (int )yypact[yystate];
#line 1743
    if (yyn != -29) {
#line 1745
      yyn ++;
#line 1746
      if (0 <= yyn) {
#line 1746
        if (yyn <= 55) {
#line 1746
          if ((int const   )yycheck[yyn] == 1) {
#line 1748
            yyn = (int )yytable[yyn];
#line 1749
            if (0 < yyn) {
#line 1750
              break;
            }
          }
        }
      }
    }
#line 1755
    if ((unsigned int )yyssp == (unsigned int )yyss) {
      goto yyabortlab;
    }
#line 1759
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp);
#line 1761
    yyvsp --;
#line 1761
    yyssp --;
#line 1762
    yystate = (int )*yyssp;
  }
#line 1766
  if (yyn == 5) {
    goto yyacceptlab;
  }
#line 1769
  yyvsp ++;
#line 1769
  *yyvsp = yylval;
#line 1775
  yystate = yyn;
  goto yynewstate;
  yyacceptlab: 
#line 1783
  yyresult = 0;
  goto yyreturn;
  yyabortlab: 
#line 1790
  yyresult = 1;
  goto yyreturn;
  yyexhaustedlab: 
#line 1798
  yyerror((char *)"memory exhausted");
#line 1799
  yyresult = 2;
  yyreturn: 
#line 1804
  if (yychar != 0) {
#line 1804
    if (yychar != -2) {
#line 1805
      yydestruct("Cleanup: discarding lookahead", yytoken, & yylval);
    }
  }
#line 1809
  yyvsp -= yylen;
#line 1809
  yyssp -= yylen;
#line 1811
  while ((unsigned int )yyssp != (unsigned int )yyss) {
#line 1813
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp);
#line 1815
    yyvsp --;
#line 1815
    yyssp --;
  }
#line 1818
  if ((unsigned int )yyss != (unsigned int )(yyssa)) {
#line 1819
    free((void *)yyss);
  }
#line 1822
  if ((unsigned int )yymsg != (unsigned int )(yymsgbuf)) {
#line 1823
    free((void *)yymsg);
  }
#line 1826
  return (yyresult);
}
}
#line 175 "parser.y"
PL_NODE *pl_newintpredicate(int tag , int op , int value ) 
{ PL_NODE *pnew ;
  void *tmp ;

  {
#line 178
  tmp = malloc(sizeof(PL_NODE ));
#line 178
  pnew = (PL_NODE *)tmp;
#line 179
  if (! pnew) {
#line 180
    return ((PL_NODE *)((void *)0));
  }
#line 182
  pnew->op = op;
#line 183
  pnew->type = 0;
#line 184
  pnew->arg1.ival = tag;
#line 185
  pnew->arg2.ival = value;
#line 186
  return (pnew);
}
}
#line 189 "parser.y"
PL_NODE *pl_newdatepredicate(int tag , int op , int value ) 
{ PL_NODE *pnew ;
  void *tmp ;

  {
#line 192
  tmp = malloc(sizeof(PL_NODE ));
#line 192
  pnew = (PL_NODE *)tmp;
#line 193
  if (! pnew) {
#line 194
    return ((PL_NODE *)((void *)0));
  }
#line 196
  pnew->op = op;
#line 197
  pnew->type = 2;
#line 198
  pnew->arg1.ival = tag;
#line 199
  pnew->arg2.ival = value;
#line 200
  return (pnew);
}
}
#line 203 "parser.y"
PL_NODE *pl_newcharpredicate(int tag , int op , char *value ) 
{ PL_NODE *pnew ;
  void *tmp ;

  {
#line 206
  tmp = malloc(sizeof(PL_NODE ));
#line 206
  pnew = (PL_NODE *)tmp;
#line 207
  if (! pnew) {
#line 208
    return ((PL_NODE *)((void *)0));
  }
#line 210
  pnew->op = op;
#line 211
  pnew->type = 1;
#line 212
  pnew->arg1.ival = tag;
#line 213
  pnew->arg2.cval = value;
#line 214
  return (pnew);
}
}
#line 217 "parser.y"
PL_NODE *pl_newexpr(PL_NODE *arg1 , int op , PL_NODE *arg2 ) 
{ PL_NODE *pnew ;
  void *tmp ;

  {
#line 220
  tmp = malloc(sizeof(PL_NODE ));
#line 220
  pnew = (PL_NODE *)tmp;
#line 221
  if (! pnew) {
#line 222
    return ((PL_NODE *)((void *)0));
  }
#line 224
  pnew->op = op;
#line 225
  pnew->arg1.plval = arg1;
#line 226
  pnew->arg2.plval = arg2;
#line 227
  return (pnew);
}
}
#line 230 "parser.y"
int pl_addplaylist(char *name , PL_NODE *root ) 
{ SMART_PLAYLIST *pnew ;
  void *tmp ;
  int tmp___0 ;

  {
#line 233
  tmp = malloc(sizeof(SMART_PLAYLIST ));
#line 233
  pnew = (SMART_PLAYLIST *)tmp;
#line 234
  if (! pnew) {
#line 235
    return (-1);
  }
#line 237
  pnew->next = pl_smart.next;
#line 238
  pnew->name = name;
#line 239
  pnew->root = root;
#line 240
  tmp___0 = pl_number;
#line 240
  pl_number ++;
#line 240
  pnew->id = (unsigned int )tmp___0;
#line 241
  pl_smart.next = pnew;
#line 243
  return (0);
}
}
#line 1 "strcasestr.o"
#pragma merger(0,"/tmp/cil-KTsj92KD.i","-g,-g,-O2")
#line 1 "strsep.o"
#pragma merger(0,"/tmp/cil-vgwsttuQ.i","-g,-g,-O2")
#line 1 "redblack.o"
#pragma merger(0,"/tmp/cil-72kAvSpm.i","-g,-g,-O2")
#line 1 "redblack.c"
static char rcsid[50]  = 
#line 1 "redblack.c"
  {      (char )'$',      (char )'I',      (char )'d',      (char )':', 
        (char )' ',      (char )'r',      (char )'e',      (char )'d', 
        (char )'b',      (char )'l',      (char )'a',      (char )'c', 
        (char )'k',      (char )'.',      (char )'c',      (char )' ', 
        (char )'2',      (char )'2',      (char )'2',      (char )' ', 
        (char )'2',      (char )'0',      (char )'0',      (char )'4', 
        (char )'-',      (char )'0',      (char )'3',      (char )'-', 
        (char )'1',      (char )'3',      (char )' ',      (char )'2', 
        (char )'3',      (char )':',      (char )'4',      (char )'3', 
        (char )':',      (char )'0',      (char )'2',      (char )'Z', 
        (char )' ',      (char )'r',      (char )'p',      (char )'e', 
        (char )'d',      (char )'d',      (char )'e',      (char )' ', 
        (char )'$',      (char )'\000'};
#line 104 "redblack.h"
void const   *rbfind(void const   *key , struct rbtree *rbinfo ) ;
#line 120
void rbwalk(struct rbtree  const  *rbinfo , void (*action)(void const   * , VISIT  ,
                                                           int  , void * ) , void *arg ) ;
#line 126
struct rblists *rbopenlist(struct rbtree  const  *rbinfo ) ;
#line 127
void const   *rbreadlist(struct rblists *rblistp ) ;
#line 128
void rbcloselist(struct rblists *rblistp ) ;
#line 66 "redblack.c"
struct rbnode rb_null  =    {& rb_null, & rb_null, & rb_null, 0, (void const   *)0};
#line 76 "redblack.c"
static struct rbnode *rb_alloc(void) 
{ void *tmp ;

  {
#line 76
  tmp = malloc(sizeof(struct rbnode ));
#line 76
  return ((struct rbnode *)tmp);
}
}
#line 77 "redblack.c"
static void rb_free(struct rbnode *x ) 
{ 

  {
#line 77
  free((void *)x);
#line 77
  return;
}
}
#line 82
static void rb_left_rotate(struct rbnode **rootp , struct rbnode *x ) ;
#line 83
static void rb_right_rotate(struct rbnode **rootp , struct rbnode *y ) ;
#line 84
static struct rbnode *rb_successor(struct rbnode  const  *x ) ;
#line 85
static struct rbnode *rb_predecessor(struct rbnode  const  *x ) ;
#line 86
static struct rbnode *rb_traverse(int insert , void const   *key , struct rbtree *rbinfo ) ;
#line 90
static struct rbnode *rb_lookup(int mode , void const   *key , struct rbtree *rbinfo ) ;
#line 94
static void rb_destroy(struct rbnode *x ) ;
#line 98
static void rb_delete(struct rbnode **rootp , struct rbnode *z ) ;
#line 99
static void rb_delete_fix(struct rbnode **rootp , struct rbnode *x ) ;
#line 103
static void rb_walk(struct rbnode  const  *x , void (*action)(void const   * , VISIT  ,
                                                              int  , void * ) , void *arg ,
                    int level ) ;
#line 107
static struct rblists *rb_openlist(struct rbnode  const  *rootp ) ;
#line 108
static void const   *rb_readlist(struct rblists *rblistp ) ;
#line 109
static void rb_closelist(struct rblists *rblistp ) ;
#line 136 "redblack.c"
struct rbtree *rbinit(int (*cmp)(void const   * , void const   * , void const   * ) ,
                      void const   *config___0 ) 
{ struct rbtree *retval ;
  char c ;
  void *tmp ;

  {
#line 145
  c = rcsid[0];
#line 147
  tmp = malloc(sizeof(struct rbtree ));
#line 147
  retval = (struct rbtree *)tmp;
#line 147
  if ((unsigned int )retval == (unsigned int )((void *)0)) {
#line 148
    return ((struct rbtree *)((void *)0));
  }
#line 151
  retval->rb_cmp = cmp;
#line 152
  retval->rb_config = config___0;
#line 154
  retval->rb_root = & rb_null;
#line 156
  return (retval);
}
}
#line 160 "redblack.c"
void rbdestroy(struct rbtree *rbinfo ) 
{ 

  {
#line 163
  if ((unsigned int )rbinfo == (unsigned int )((void *)0)) {
#line 164
    return;
  }
#line 166
  if ((unsigned int )rbinfo->rb_root != (unsigned int )(& rb_null)) {
#line 167
    rb_destroy(rbinfo->rb_root);
  }
#line 169
  free((void *)rbinfo);
#line 170
  return;
}
}
#line 174 "redblack.c"
void const   *rbsearch(void const   *key , struct rbtree *rbinfo ) 
{ struct rbnode *x ;
  void *tmp ;

  {
#line 179
  if ((unsigned int )rbinfo == (unsigned int )((void *)0)) {
#line 180
    return ((void const   *)((void *)0));
  }
#line 182
  x = rb_traverse(1, key, rbinfo);
#line 184
  if ((unsigned int )x == (unsigned int )(& rb_null)) {
#line 184
    tmp = (void *)0;
  } else {
#line 184
    tmp = (void *)x->key;
  }
#line 184
  return ((void const   *)tmp);
}
}
#line 189 "redblack.c"
void const   *rbfind(void const   *key , struct rbtree *rbinfo ) 
{ struct rbnode *x ;
  void *tmp ;

  {
#line 194
  if ((unsigned int )rbinfo == (unsigned int )((void *)0)) {
#line 195
    return ((void const   *)((void *)0));
  }
#line 198
  if ((unsigned int )rbinfo->rb_root == (unsigned int )(& rb_null)) {
#line 199
    return ((void const   *)((void *)0));
  }
#line 201
  x = rb_traverse(0, key, rbinfo);
#line 203
  if ((unsigned int )x == (unsigned int )(& rb_null)) {
#line 203
    tmp = (void *)0;
  } else {
#line 203
    tmp = (void *)x->key;
  }
#line 203
  return ((void const   *)tmp);
}
}
#line 208 "redblack.c"
void const   *rbdelete(void const   *key , struct rbtree *rbinfo ) 
{ struct rbnode *x ;
  void const   *y ;

  {
#line 214
  if ((unsigned int )rbinfo == (unsigned int )((void *)0)) {
#line 215
    return ((void const   *)((void *)0));
  }
#line 217
  x = rb_traverse(0, key, rbinfo);
#line 219
  if ((unsigned int )x == (unsigned int )(& rb_null)) {
#line 221
    return ((void const   *)((void *)0));
  } else {
#line 225
    y = x->key;
#line 226
    rb_delete(& rbinfo->rb_root, x);
#line 228
    return (y);
  }
}
}
#line 234 "redblack.c"
void rbwalk(struct rbtree  const  *rbinfo , void (*action)(void const   * , VISIT  ,
                                                           int  , void * ) , void *arg ) 
{ 

  {
#line 237
  if ((unsigned int )rbinfo == (unsigned int )((void *)0)) {
#line 238
    return;
  }
#line 240
  rb_walk((struct rbnode  const  *)rbinfo->rb_root, action, arg, 0);
#line 241
  return;
}
}
#line 245 "redblack.c"
struct rblists *rbopenlist(struct rbtree  const  *rbinfo ) 
{ struct rblists *tmp ;

  {
#line 248
  if ((unsigned int )rbinfo == (unsigned int )((void *)0)) {
#line 249
    return ((struct rblists *)((void *)0));
  }
#line 251
  tmp = rb_openlist((struct rbnode  const  *)rbinfo->rb_root);
#line 251
  return (tmp);
}
}
#line 254 "redblack.c"
void const   *rbreadlist(struct rblists *rblistp ) 
{ void const   *tmp ;

  {
#line 257
  if ((unsigned int )rblistp == (unsigned int )((void *)0)) {
#line 258
    return ((void const   *)((void *)0));
  }
#line 260
  tmp = rb_readlist(rblistp);
#line 260
  return (tmp);
}
}
#line 263 "redblack.c"
void rbcloselist(struct rblists *rblistp ) 
{ 

  {
#line 266
  if ((unsigned int )rblistp == (unsigned int )((void *)0)) {
#line 267
    return;
  }
#line 269
  rb_closelist(rblistp);
#line 270
  return;
}
}
#line 274 "redblack.c"
void const   *rblookup(int mode , void const   *key , struct rbtree *rbinfo ) 
{ struct rbnode *x ;
  void *tmp ;

  {
#line 280
  if ((unsigned int )rbinfo == (unsigned int )((void *)0)) {
#line 281
    return ((void const   *)((void *)0));
  } else {
#line 280
    if ((unsigned int )rbinfo->rb_root == (unsigned int )((void *)0)) {
#line 281
      return ((void const   *)((void *)0));
    }
  }
#line 283
  x = rb_lookup(mode, key, rbinfo);
#line 285
  if ((unsigned int )x == (unsigned int )(& rb_null)) {
#line 285
    tmp = (void *)0;
  } else {
#line 285
    tmp = (void *)x->key;
  }
#line 285
  return ((void const   *)tmp);
}
}
#line 294 "redblack.c"
static struct rbnode *rb_traverse(int insert , void const   *key , struct rbtree *rbinfo ) 
{ struct rbnode *x ;
  struct rbnode *y ;
  struct rbnode *z ;
  int cmp ;
  int found ;

  {
#line 299
  found = 0;
#line 302
  y = & rb_null;
#line 303
  x = rbinfo->rb_root;
#line 306
  while (1) {
#line 306
    if ((unsigned int )x != (unsigned int )(& rb_null)) {
#line 306
      if (! (found == 0)) {
#line 306
        break;
      }
    } else {
#line 306
      break;
    }
#line 308
    y = x;
#line 311
    cmp = (*(rbinfo->rb_cmp))(key, x->key, rbinfo->rb_config);
#line 316
    if (cmp < 0) {
#line 317
      x = x->left;
    } else {
#line 318
      if (cmp > 0) {
#line 319
        x = x->right;
      } else {
#line 321
        found = 1;
      }
    }
  }
#line 324
  if (found) {
#line 325
    return (x);
  } else {
#line 324
    if (! insert) {
#line 325
      return (x);
    }
  }
#line 327
  z = rb_alloc();
#line 327
  if ((unsigned int )z == (unsigned int )((void *)0)) {
#line 330
    return (& rb_null);
  }
#line 333
  z->key = key;
#line 334
  z->up = y;
#line 335
  if ((unsigned int )y == (unsigned int )(& rb_null)) {
#line 337
    rbinfo->rb_root = z;
  } else {
#line 342
    cmp = (*(rbinfo->rb_cmp))(z->key, y->key, rbinfo->rb_config);
#line 346
    if (cmp < 0) {
#line 347
      y->left = z;
    } else {
#line 349
      y->right = z;
    }
  }
#line 352
  z->left = & rb_null;
#line 353
  z->right = & rb_null;
#line 356
  z->colour = 1;
#line 361
  x = z;
#line 368
  while (1) {
#line 368
    if ((unsigned int )x != (unsigned int )rbinfo->rb_root) {
#line 368
      if (! ((int )(x->up)->colour == 1)) {
#line 368
        break;
      }
    } else {
#line 368
      break;
    }
#line 371
    if ((unsigned int )x->up == (unsigned int )((x->up)->up)->left) {
#line 374
      y = ((x->up)->up)->right;
#line 375
      if ((int )y->colour == 1) {
#line 378
        (x->up)->colour = 0;
#line 380
        y->colour = 0;
#line 382
        ((x->up)->up)->colour = 1;
#line 385
        x = (x->up)->up;
      } else {
#line 390
        if ((unsigned int )x == (unsigned int )(x->up)->right) {
#line 393
          x = x->up;
#line 394
          rb_left_rotate(& rbinfo->rb_root, x);
        }
#line 398
        (x->up)->colour = 0;
#line 400
        ((x->up)->up)->colour = 1;
#line 402
        rb_right_rotate(& rbinfo->rb_root, (x->up)->up);
      }
    } else {
#line 411
      y = ((x->up)->up)->left;
#line 412
      if ((int )y->colour == 1) {
#line 414
        (x->up)->colour = 0;
#line 415
        y->colour = 0;
#line 416
        ((x->up)->up)->colour = 1;
#line 418
        x = (x->up)->up;
      } else {
#line 422
        if ((unsigned int )x == (unsigned int )(x->up)->left) {
#line 424
          x = x->up;
#line 425
          rb_right_rotate(& rbinfo->rb_root, x);
        }
#line 428
        (x->up)->colour = 0;
#line 429
        ((x->up)->up)->colour = 1;
#line 430
        rb_left_rotate(& rbinfo->rb_root, (x->up)->up);
      }
    }
  }
#line 436
  (rbinfo->rb_root)->colour = 0;
#line 438
  return (z);
}
}
#line 444 "redblack.c"
static struct rbnode *rb_lookup(int mode , void const   *key , struct rbtree *rbinfo ) 
{ struct rbnode *x ;
  struct rbnode *y ;
  int cmp ;
  int found ;
  struct rbnode *tmp ;
  struct rbnode *tmp___0 ;
  struct rbnode *tmp___1 ;
  struct rbnode *tmp___2 ;

  {
#line 449
  found = 0;
#line 451
  y = & rb_null;
#line 452
  x = rbinfo->rb_root;
#line 454
  if (mode == 7) {
#line 457
    while ((unsigned int )x != (unsigned int )(& rb_null)) {
#line 459
      y = x;
#line 460
      x = x->left;
    }
#line 463
    return (y);
  } else {
#line 465
    if (mode == 8) {
#line 468
      while ((unsigned int )x != (unsigned int )(& rb_null)) {
#line 470
        y = x;
#line 471
        x = x->right;
      }
#line 474
      return (y);
    }
  }
#line 478
  while (1) {
#line 478
    if ((unsigned int )x != (unsigned int )(& rb_null)) {
#line 478
      if (! (found == 0)) {
#line 478
        break;
      }
    } else {
#line 478
      break;
    }
#line 480
    y = x;
#line 483
    cmp = (*(rbinfo->rb_cmp))(key, x->key, rbinfo->rb_config);
#line 489
    if (cmp < 0) {
#line 490
      x = x->left;
    } else {
#line 491
      if (cmp > 0) {
#line 492
        x = x->right;
      } else {
#line 494
        found = 1;
      }
    }
  }
#line 497
  if (found) {
#line 497
    if (mode == 0) {
#line 498
      return (x);
    } else {
#line 497
      if (mode == 1) {
#line 498
        return (x);
      } else {
#line 497
        if (mode == 2) {
#line 498
          return (x);
        }
      }
    }
  }
#line 500
  if (! found) {
#line 500
    if (mode == 0) {
#line 501
      return (& rb_null);
    } else {
#line 500
      if (mode == 5) {
#line 501
        return (& rb_null);
      } else {
#line 500
        if (mode == 6) {
#line 501
          return (& rb_null);
        }
      }
    }
  }
#line 503
  if (mode == 1) {
    goto _L;
  } else {
#line 503
    if (! found) {
#line 503
      if (mode == 4) {
        _L: /* CIL Label */ 
#line 505
        if (cmp > 0) {
#line 506
          tmp = rb_successor((struct rbnode  const  *)y);
#line 506
          return (tmp);
        } else {
#line 508
          return (y);
        }
      }
    }
  }
#line 511
  if (mode == 2) {
    goto _L___0;
  } else {
#line 511
    if (! found) {
#line 511
      if (mode == 3) {
        _L___0: /* CIL Label */ 
#line 513
        if (cmp < 0) {
#line 514
          tmp___0 = rb_predecessor((struct rbnode  const  *)y);
#line 514
          return (tmp___0);
        } else {
#line 516
          return (y);
        }
      }
    }
  }
#line 519
  if (mode == 5) {
#line 520
    tmp___1 = rb_successor((struct rbnode  const  *)x);
#line 520
    return (tmp___1);
  } else {
#line 519
    if (found) {
#line 519
      if (mode == 4) {
#line 520
        tmp___1 = rb_successor((struct rbnode  const  *)x);
#line 520
        return (tmp___1);
      }
    }
  }
#line 522
  if (mode == 6) {
#line 523
    tmp___2 = rb_predecessor((struct rbnode  const  *)x);
#line 523
    return (tmp___2);
  } else {
#line 522
    if (found) {
#line 522
      if (mode == 3) {
#line 523
        tmp___2 = rb_predecessor((struct rbnode  const  *)x);
#line 523
        return (tmp___2);
      }
    }
  }
#line 526
  return (& rb_null);
}
}
#line 535 "redblack.c"
static void rb_destroy(struct rbnode *x ) 
{ 

  {
#line 538
  if ((unsigned int )x != (unsigned int )(& rb_null)) {
#line 540
    if ((unsigned int )x->left != (unsigned int )(& rb_null)) {
#line 541
      rb_destroy(x->left);
    }
#line 542
    if ((unsigned int )x->right != (unsigned int )(& rb_null)) {
#line 543
      rb_destroy(x->right);
    }
#line 544
    rb_free(x);
  }
#line 546
  return;
}
}
#line 563 "redblack.c"
static void rb_left_rotate(struct rbnode **rootp , struct rbnode *x ) 
{ struct rbnode *y ;

  {
#line 571
  y = x->right;
#line 574
  x->right = y->left;
#line 577
  if ((unsigned int )y->left != (unsigned int )(& rb_null)) {
#line 578
    (y->left)->up = x;
  }
#line 581
  y->up = x->up;
#line 584
  if ((unsigned int )x->up == (unsigned int )(& rb_null)) {
#line 586
    *rootp = y;
  } else {
#line 591
    if ((unsigned int )x == (unsigned int )(x->up)->left) {
#line 593
      (x->up)->left = y;
    } else {
#line 597
      (x->up)->right = y;
    }
  }
#line 602
  y->left = x;
#line 605
  x->up = y;
#line 606
  return;
}
}
#line 608 "redblack.c"
static void rb_right_rotate(struct rbnode **rootp , struct rbnode *y ) 
{ struct rbnode *x ;

  {
#line 616
  x = y->left;
#line 619
  y->left = x->right;
#line 622
  if ((unsigned int )x->right != (unsigned int )(& rb_null)) {
#line 623
    (x->right)->up = y;
  }
#line 626
  x->up = y->up;
#line 629
  if ((unsigned int )y->up == (unsigned int )(& rb_null)) {
#line 631
    *rootp = x;
  } else {
#line 636
    if ((unsigned int )y == (unsigned int )(y->up)->left) {
#line 638
      (y->up)->left = x;
    } else {
#line 642
      (y->up)->right = x;
    }
  }
#line 647
  x->right = y;
#line 650
  y->up = x;
#line 651
  return;
}
}
#line 655 "redblack.c"
static struct rbnode *rb_successor(struct rbnode  const  *x ) 
{ struct rbnode *y ;

  {
#line 660
  if ((unsigned int )x->right != (unsigned int )(& rb_null)) {
#line 666
    y = (struct rbnode *)x->right;
#line 666
    while ((unsigned int )y->left != (unsigned int )(& rb_null)) {
#line 666
      y = y->left;
    }
  } else {
#line 674
    y = (struct rbnode *)x->up;
#line 675
    while (1) {
#line 675
      if ((unsigned int )y != (unsigned int )(& rb_null)) {
#line 675
        if (! ((unsigned int )x == (unsigned int )y->right)) {
#line 675
          break;
        }
      } else {
#line 675
        break;
      }
#line 677
      x = (struct rbnode  const  *)y;
#line 678
      y = y->up;
    }
  }
#line 681
  return (y);
}
}
#line 686 "redblack.c"
static struct rbnode *rb_predecessor(struct rbnode  const  *x ) 
{ struct rbnode *y ;

  {
#line 691
  if ((unsigned int )x->left != (unsigned int )(& rb_null)) {
#line 697
    y = (struct rbnode *)x->left;
#line 697
    while ((unsigned int )y->right != (unsigned int )(& rb_null)) {
#line 697
      y = y->right;
    }
  } else {
#line 705
    y = (struct rbnode *)x->up;
#line 706
    while (1) {
#line 706
      if ((unsigned int )y != (unsigned int )(& rb_null)) {
#line 706
        if (! ((unsigned int )x == (unsigned int )y->left)) {
#line 706
          break;
        }
      } else {
#line 706
        break;
      }
#line 708
      x = (struct rbnode  const  *)y;
#line 709
      y = y->up;
    }
  }
#line 712
  return (y);
}
}
#line 718 "redblack.c"
static void rb_delete(struct rbnode **rootp , struct rbnode *z ) 
{ struct rbnode *x ;
  struct rbnode *y ;

  {
#line 723
  if ((unsigned int )z->left == (unsigned int )(& rb_null)) {
#line 724
    y = z;
  } else {
#line 723
    if ((unsigned int )z->right == (unsigned int )(& rb_null)) {
#line 724
      y = z;
    } else {
#line 726
      y = rb_successor((struct rbnode  const  *)z);
    }
  }
#line 728
  if ((unsigned int )y->left != (unsigned int )(& rb_null)) {
#line 729
    x = y->left;
  } else {
#line 731
    x = y->right;
  }
#line 733
  x->up = y->up;
#line 735
  if ((unsigned int )y->up == (unsigned int )(& rb_null)) {
#line 737
    *rootp = x;
  } else {
#line 741
    if ((unsigned int )y == (unsigned int )(y->up)->left) {
#line 742
      (y->up)->left = x;
    } else {
#line 744
      (y->up)->right = x;
    }
  }
#line 747
  if ((unsigned int )y != (unsigned int )z) {
#line 749
    z->key = y->key;
  }
#line 752
  if ((int )y->colour == 0) {
#line 753
    rb_delete_fix(rootp, x);
  }
#line 755
  rb_free(y);
#line 756
  return;
}
}
#line 759 "redblack.c"
static void rb_delete_fix(struct rbnode **rootp , struct rbnode *x ) 
{ struct rbnode *w ;

  {
#line 764
  while (1) {
#line 764
    if ((unsigned int )x != (unsigned int )*rootp) {
#line 764
      if (! ((int )x->colour == 0)) {
#line 764
        break;
      }
    } else {
#line 764
      break;
    }
#line 766
    if ((unsigned int )x == (unsigned int )(x->up)->left) {
#line 768
      w = (x->up)->right;
#line 769
      if ((int )w->colour == 1) {
#line 771
        w->colour = 0;
#line 772
        (x->up)->colour = 1;
#line 773
        rb_left_rotate(rootp, x->up);
#line 774
        w = (x->up)->right;
      }
#line 777
      if ((int )(w->left)->colour == 0) {
#line 777
        if ((int )(w->right)->colour == 0) {
#line 779
          w->colour = 1;
#line 780
          x = x->up;
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 784
        if ((int )(w->right)->colour == 0) {
#line 786
          (w->left)->colour = 0;
#line 787
          w->colour = 1;
#line 788
          rb_right_rotate(rootp, w);
#line 789
          w = (x->up)->right;
        }
#line 793
        w->colour = (x->up)->colour;
#line 794
        (x->up)->colour = 0;
#line 795
        (w->right)->colour = 0;
#line 796
        rb_left_rotate(rootp, x->up);
#line 797
        x = *rootp;
      }
    } else {
#line 802
      w = (x->up)->left;
#line 803
      if ((int )w->colour == 1) {
#line 805
        w->colour = 0;
#line 806
        (x->up)->colour = 1;
#line 807
        rb_right_rotate(rootp, x->up);
#line 808
        w = (x->up)->left;
      }
#line 811
      if ((int )(w->right)->colour == 0) {
#line 811
        if ((int )(w->left)->colour == 0) {
#line 813
          w->colour = 1;
#line 814
          x = x->up;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 818
        if ((int )(w->left)->colour == 0) {
#line 820
          (w->right)->colour = 0;
#line 821
          w->colour = 1;
#line 822
          rb_left_rotate(rootp, w);
#line 823
          w = (x->up)->left;
        }
#line 826
        w->colour = (x->up)->colour;
#line 827
        (x->up)->colour = 0;
#line 828
        (w->left)->colour = 0;
#line 829
        rb_right_rotate(rootp, x->up);
#line 830
        x = *rootp;
      }
    }
  }
#line 835
  x->colour = 0;
#line 836
  return;
}
}
#line 840 "redblack.c"
static void rb_walk(struct rbnode  const  *x , void (*action)(void const   * , VISIT  ,
                                                              int  , void * ) , void *arg ,
                    int level ) 
{ 

  {
#line 843
  if ((unsigned int )x == (unsigned int )(& rb_null)) {
#line 844
    return;
  }
#line 846
  if ((unsigned int )x->left == (unsigned int )(& rb_null)) {
#line 846
    if ((unsigned int )x->right == (unsigned int )(& rb_null)) {
#line 849
      (*action)((void const   *)x->key, 3, level, arg);
    } else {
#line 853
      (*action)((void const   *)x->key, 0, level, arg);
#line 855
      rb_walk((struct rbnode  const  *)x->left, action, arg, level + 1);
#line 857
      (*action)((void const   *)x->key, 1, level, arg);
#line 859
      rb_walk((struct rbnode  const  *)x->right, action, arg, level + 1);
#line 861
      (*action)((void const   *)x->key, 2, level, arg);
    }
  } else {
#line 853
    (*action)((void const   *)x->key, 0, level, arg);
#line 855
    rb_walk((struct rbnode  const  *)x->left, action, arg, level + 1);
#line 857
    (*action)((void const   *)x->key, 1, level, arg);
#line 859
    rb_walk((struct rbnode  const  *)x->right, action, arg, level + 1);
#line 861
    (*action)((void const   *)x->key, 2, level, arg);
  }
#line 863
  return;
}
}
#line 867 "redblack.c"
static struct rblists *rb_openlist(struct rbnode  const  *rootp ) 
{ struct rblists *rblistp ;
  void *tmp ;

  {
#line 872
  tmp = malloc(sizeof(struct rblists ));
#line 872
  rblistp = (struct rblists *)tmp;
#line 873
  if (! rblistp) {
#line 874
    return ((struct rblists *)((void *)0));
  }
#line 876
  rblistp->rootp = rootp;
#line 877
  rblistp->nextp = rootp;
#line 879
  if ((unsigned int )rootp != (unsigned int )(& rb_null)) {
#line 881
    while ((unsigned int )(rblistp->nextp)->left != (unsigned int )(& rb_null)) {
#line 883
      rblistp->nextp = (struct rbnode  const  *)(rblistp->nextp)->left;
    }
  }
#line 887
  return (rblistp);
}
}
#line 890 "redblack.c"
static void const   *rb_readlist(struct rblists *rblistp ) 
{ void const   *key ;
  struct rbnode *tmp ;

  {
#line 893
  key = (void const   *)((void *)0);
#line 895
  if ((unsigned int )rblistp != (unsigned int )((void *)0)) {
#line 895
    if ((unsigned int )rblistp->nextp != (unsigned int )(& rb_null)) {
#line 897
      key = (void const   *)(rblistp->nextp)->key;
#line 898
      tmp = rb_successor(rblistp->nextp);
#line 898
      rblistp->nextp = (struct rbnode  const  *)tmp;
    }
  }
#line 901
  return (key);
}
}
#line 904 "redblack.c"
static void rb_closelist(struct rblists *rblistp ) 
{ 

  {
#line 907
  if (rblistp) {
#line 908
    free((void *)rblistp);
  }
#line 909
  return;
}
}
#line 1 "dynamic-art.o"
#pragma merger(0,"/tmp/cil-I9cbbDYr.i","-g,-g,-O2")
#line 727 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 488 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 212 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 41 "dynamic-art.c"
int *da_get_current_tag_info(int file_fd ) ;
#line 80 "dynamic-art.c"
int da_get_image_fd(char *filename ) 
{ unsigned char buffer___0[255] ;
  char *path_end ;
  int fd ;

  {
#line 84
  __builtin_strncpy((char *)(buffer___0), (char const   *)filename, 255U);
#line 85
  path_end = strrchr((char const   *)(buffer___0), '/');
#line 86
  strcpy((char * __restrict  )(path_end + 1), (char const   * __restrict  )config.artfilename);
#line 87
  fd = open((char const   *)(buffer___0), 0);
#line 88
  if (fd != -1) {
#line 89
    err_log(5, 256U, (char *)"Found image file %s (fd %d)\n", buffer___0, fd);
  }
#line 91
  return (fd);
}
}
#line 101 "dynamic-art.c"
int *da_get_current_tag_info(int file_fd ) 
{ unsigned char buffer___0[10] ;
  int *tag_info ;
  void *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 105
  tmp = calloc(2U, sizeof(int ));
#line 105
  tag_info = (int *)tmp;
#line 107
  r_read(file_fd, (void *)(buffer___0), 10U);
#line 108
  if (0) {
#line 108
    if (0) {
#line 108
      __s1_len = strlen((char const   *)(buffer___0));
#line 108
      __s2_len = strlen("ID3");
#line 108
      if (! ((unsigned int )((void const   *)(buffer___0 + 1)) - (unsigned int )((void const   *)(buffer___0)) == 1U)) {
        goto _L___0;
      } else {
#line 108
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 108
          if (! ((unsigned int )((void const   *)("ID3" + 1)) - (unsigned int )((void const   *)"ID3") == 1U)) {
#line 108
            tmp___8 = 1;
          } else {
#line 108
            if (__s2_len >= 4U) {
#line 108
              tmp___8 = 1;
            } else {
#line 108
              tmp___8 = 0;
            }
          }
        } else {
#line 108
          tmp___8 = 0;
        }
      }
#line 108
      if (tmp___8) {
#line 108
        tmp___3 = __builtin_strcmp((char const   *)(buffer___0), "ID3");
#line 108
        tmp___7 = tmp___3;
      } else {
#line 108
        tmp___6 = __builtin_strcmp((char const   *)(buffer___0), "ID3");
#line 108
        tmp___7 = tmp___6;
      }
    } else {
#line 108
      tmp___6 = __builtin_strcmp((char const   *)(buffer___0), "ID3");
#line 108
      tmp___7 = tmp___6;
    }
#line 108
    tmp___10 = tmp___7;
  } else {
#line 108
    tmp___9 = strncmp((char const   *)(buffer___0), "ID3", 3U);
#line 108
    tmp___10 = tmp___9;
  }
#line 108
  if (tmp___10 == 0) {
#line 109
    *(tag_info + 0) = (int )buffer___0[3];
#line 110
    *(tag_info + 1) = ((((int )buffer___0[6] << 21) + ((int )buffer___0[7] << 14)) + ((int )buffer___0[8] << 7)) + (int )buffer___0[9];
#line 111
    return (tag_info);
  } else {
#line 114
    lseek(file_fd, 0L, 0);
#line 115
    *(tag_info + 0) = 2;
#line 116
    *(tag_info + 1) = 0;
#line 117
    return (tag_info);
  }
}
}
#line 129 "dynamic-art.c"
int da_attach_image(int img_fd , int out_fd , int mp3_fd , int offset ) 
{ long img_size ;
  int tag_size ;
  int *tag_info ;
  unsigned char buffer___0[4] ;
  struct stat sb ;

  {
#line 137
  fstat(img_fd, & sb);
#line 138
  img_size = sb.st_size;
#line 140
  err_log(5, 256U, (char *)"Image appears to be %ld bytes\n", img_size);
#line 141
  if (img_size < 1L) {
#line 142
    r_close(img_fd);
#line 143
    return (0);
  }
#line 146
  if ((long )offset > img_size + 24L) {
#line 147
    lseek(mp3_fd, ((long )offset - img_size) - 24L, 0);
#line 148
    r_close(img_fd);
#line 149
    return (0);
  }
#line 152
  tag_info = da_get_current_tag_info(mp3_fd);
#line 153
  tag_size = *(tag_info + 1);
#line 155
  err_log(5, 256U, (char *)"Current tag size is %d bytes\n", tag_size);
#line 157
  if (*(tag_info + 0) == 3) {
#line 158
    r_write(out_fd, (void *)"ID3\003\000\000", 6U);
#line 159
    tag_size = (int )((long )tag_size + ((img_size + 14L) + 8L));
  } else {
#line 161
    r_write(out_fd, (void *)"ID3\002\000\000", 6U);
#line 162
    tag_size = (int )((long )tag_size + ((img_size + 6L) + 6L));
  }
#line 165
  buffer___0[3] = (unsigned char )(tag_size & 127);
#line 166
  buffer___0[2] = (unsigned char )((tag_size & 16256) >> 7);
#line 167
  buffer___0[1] = (unsigned char )((tag_size & 2080768) >> 14);
#line 168
  buffer___0[0] = (unsigned char )((tag_size & 266338304) >> 21);
#line 170
  r_write(out_fd, (void *)(buffer___0), 4U);
#line 172
  if (*(tag_info + 0) == 3) {
#line 173
    r_write(out_fd, (void *)"APIC\000", 5U);
#line 174
    img_size += 14L;
  } else {
#line 176
    r_write(out_fd, (void *)"PIC", 3U);
#line 177
    img_size += 6L;
  }
#line 179
  buffer___0[0] = (unsigned char )((img_size & 16711680L) >> 16);
#line 180
  buffer___0[1] = (unsigned char )((img_size & 65280L) >> 8);
#line 181
  buffer___0[2] = (unsigned char )(img_size & 255L);
#line 182
  r_write(out_fd, (void *)(buffer___0), 3U);
#line 183
  if (*(tag_info + 0) == 3) {
#line 184
    r_write(out_fd, (void *)"\000\000\000image/jpeg\000\000\000", 16U);
  } else {
#line 186
    r_write(out_fd, (void *)"\000JPG\000\000", 6U);
  }
#line 188
  lseek(img_fd, 0L, 0);
#line 189
  copyfile(img_fd, out_fd);
#line 190
  err_log(5, 256U, (char *)"Done copying IMG %ld\n", img_size);
#line 191
  r_close(img_fd);
#line 192
  free((void *)tag_info);
#line 193
  return (0);
}
}
#line 235
int fcopyblock(FILE *fromfp , int tofd , size_t size ) ;
#line 202 "dynamic-art.c"
off_t da_aac_rewrite_stco_atom(off_t extra_size , int out_fd , FILE *aac_fp , off_t last_pos ) 
{ int aac_fd ;
  struct stat sb ;
  unsigned char buffer___0[4] ;
  off_t file_size ;
  int atom_offset ;
  int atom_length ;
  off_t cur_pos ;
  off_t old_pos ;
  int i ;
  unsigned int num_entries ;
  unsigned int offset_entry ;
  off_t tmp ;
  long tmp___0 ;

  {
#line 217
  aac_fd = fileno(aac_fp);
#line 219
  fstat(aac_fd, & sb);
#line 220
  file_size = sb.st_size;
#line 224
  tmp = aac_drilltoatom(aac_fp, (char *)"moov:trak:mdia:minf:stbl:stco", (unsigned int *)(& atom_length));
#line 224
  atom_offset = (int )tmp;
#line 226
  if (atom_offset != -1) {
#line 228
    fseek(aac_fp, 4L, 1);
#line 230
    old_pos = last_pos;
#line 231
    cur_pos = ftell(aac_fp);
#line 234
    fseek(aac_fp, old_pos, 0);
#line 235
    fcopyblock(aac_fp, out_fd, cur_pos - old_pos);
#line 238
    fread((void * __restrict  )(buffer___0), 1U, 4U, (FILE * __restrict  )aac_fp);
#line 239
    r_write(out_fd, (void *)(buffer___0), 4U);
#line 241
    num_entries = (unsigned int )(((((int )buffer___0[0] << 24) | ((int )buffer___0[1] << 16)) | ((int )buffer___0[2] << 8)) | (int )buffer___0[3]);
#line 243
    err_log(9, 256U, (char *)"Readjusting %d \'stco\' table offsets.\n", num_entries);
#line 245
    i = 0;
#line 245
    while ((unsigned int )i < num_entries) {
#line 246
      fread((void * __restrict  )(buffer___0), 1U, 4U, (FILE * __restrict  )aac_fp);
#line 247
      offset_entry = (unsigned int )(((((int )buffer___0[0] << 24) | ((int )buffer___0[1] << 16)) | ((int )buffer___0[2] << 8)) | (int )buffer___0[3]);
#line 249
      offset_entry = (unsigned int )((unsigned long )offset_entry + (unsigned long )extra_size);
#line 250
      buffer___0[3] = (unsigned char )(offset_entry & 255U);
#line 251
      buffer___0[2] = (unsigned char )((offset_entry >> 8) & 255U);
#line 252
      buffer___0[1] = (unsigned char )((offset_entry >> 16) & 255U);
#line 253
      buffer___0[0] = (unsigned char )((offset_entry >> 24) & 255U);
#line 254
      r_write(out_fd, (void *)(buffer___0), 4U);
#line 255
      offset_entry = 0U;
#line 245
      i ++;
    }
#line 257
    tmp___0 = ftell(aac_fp);
#line 257
    return (tmp___0);
  } else {
#line 259
    err_log(1, 256U, (char *)"No \'stco\' atom found.\n");
  }
#line 261
  return (last_pos);
}
}
#line 268 "dynamic-art.c"
off_t da_aac_insert_covr_atom(off_t extra_size , int out_fd , FILE *aac_fp , off_t last_pos ,
                              off_t file_size , int img_fd ) 
{ int aac_fd ;
  struct stat sb ;
  off_t old_pos ;
  unsigned char buffer___0[4] ;
  int atom_offset ;
  int atom_length ;
  off_t cur_pos ;
  char *cp ;
  unsigned char img_type_flag ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 279
  img_type_flag = (unsigned char)0;
#line 282
  cp = strrchr((char const   *)config.artfilename, '.');
#line 283
  if (cp) {
#line 284
    tmp___0 = strcasecmp((char const   *)cp, ".jpeg");
#line 284
    if (tmp___0) {
#line 284
      tmp___1 = strcasecmp((char const   *)cp, ".jpg");
#line 284
      if (tmp___1) {
#line 287
        tmp = strcasecmp((char const   *)cp, ".png");
#line 287
        if (tmp) {
#line 290
          err_log(1, 256U, (char *)"Image type \'%s\' not supported.\n", cp);
#line 291
          return (0L);
        } else {
#line 288
          img_type_flag = (unsigned char)14;
        }
      } else {
#line 285
        img_type_flag = (unsigned char)13;
      }
    } else {
#line 285
      img_type_flag = (unsigned char)13;
    }
  } else {
#line 294
    err_log(1, 256U, (char *)"No file extension for image file.\n");
  }
#line 297
  aac_fd = fileno(aac_fp);
#line 298
  fstat(aac_fd, & sb);
#line 299
  file_size = sb.st_size;
#line 300
  rewind(aac_fp);
#line 302
  atom_offset = (int )scan_aac_findatom(aac_fp, file_size, "moov", & atom_length);
#line 303
  if (atom_offset != -1) {
#line 304
    atom_offset = (int )scan_aac_findatom(aac_fp, atom_length - 8, "udta", & atom_length);
#line 305
    if (atom_offset != -1) {
#line 306
      old_pos = last_pos;
#line 307
      tmp___2 = ftell(aac_fp);
#line 307
      cur_pos = tmp___2 - 8L;
#line 308
      err_log(5, 256U, (char *)"Found udta atom at %ld.\n", cur_pos);
#line 309
      fseek(aac_fp, old_pos, 0);
#line 310
      fcopyblock(aac_fp, out_fd, cur_pos - old_pos);
#line 313
      atom_length = (int )((off_t )atom_length + extra_size);
#line 314
      buffer___0[3] = (unsigned char )(atom_length & 255);
#line 315
      buffer___0[2] = (unsigned char )((atom_length >> 8) & 255);
#line 316
      buffer___0[1] = (unsigned char )((atom_length >> 16) & 255);
#line 317
      buffer___0[0] = (unsigned char )((atom_length >> 24) & 255);
#line 318
      r_write(out_fd, (void *)(buffer___0), 4U);
#line 320
      cur_pos += 4L;
#line 321
      fseek(aac_fp, 8L, 1);
#line 323
      atom_offset = (int )scan_aac_findatom(aac_fp, atom_length - 8, "meta", & atom_length);
#line 324
      if (atom_offset != -1) {
#line 325
        old_pos = cur_pos;
#line 326
        tmp___3 = ftell(aac_fp);
#line 326
        cur_pos = tmp___3 - 8L;
#line 327
        err_log(5, 256U, (char *)"Found meta atom at %ld.\n", cur_pos);
#line 328
        fseek(aac_fp, old_pos, 0);
#line 329
        fcopyblock(aac_fp, out_fd, cur_pos - old_pos);
#line 332
        atom_length = (int )((off_t )atom_length + extra_size);
#line 333
        buffer___0[3] = (unsigned char )(atom_length & 255);
#line 334
        buffer___0[2] = (unsigned char )((atom_length >> 8) & 255);
#line 335
        buffer___0[1] = (unsigned char )((atom_length >> 16) & 255);
#line 336
        buffer___0[0] = (unsigned char )((atom_length >> 24) & 255);
#line 337
        r_write(out_fd, (void *)(buffer___0), 4U);
#line 339
        cur_pos += 4L;
#line 340
        fseek(aac_fp, 12L, 1);
#line 342
        atom_offset = (int )scan_aac_findatom(aac_fp, atom_length - 8, "ilst", & atom_length);
#line 343
        if (atom_offset != -1) {
#line 344
          old_pos = cur_pos;
#line 345
          tmp___4 = ftell(aac_fp);
#line 345
          cur_pos = tmp___4 - 8L;
#line 346
          err_log(5, 256U, (char *)"Found ilst atom at %ld.\n", cur_pos);
#line 347
          fseek(aac_fp, old_pos, 0);
#line 348
          fcopyblock(aac_fp, out_fd, cur_pos - old_pos);
#line 350
          old_pos = cur_pos + 4L;
#line 351
          cur_pos += (off_t )atom_length;
#line 354
          atom_length = (int )((off_t )atom_length + extra_size);
#line 355
          buffer___0[3] = (unsigned char )(atom_length & 255);
#line 356
          buffer___0[2] = (unsigned char )((atom_length >> 8) & 255);
#line 357
          buffer___0[1] = (unsigned char )((atom_length >> 16) & 255);
#line 358
          buffer___0[0] = (unsigned char )((atom_length >> 24) & 255);
#line 359
          r_write(out_fd, (void *)(buffer___0), 4U);
#line 363
          fseek(aac_fp, old_pos, 0);
#line 364
          fcopyblock(aac_fp, out_fd, cur_pos - old_pos);
#line 365
          cur_pos = ftell(aac_fp);
#line 368
          atom_length = (int )extra_size;
#line 369
          buffer___0[3] = (unsigned char )(atom_length & 255);
#line 370
          buffer___0[2] = (unsigned char )((atom_length >> 8) & 255);
#line 371
          buffer___0[1] = (unsigned char )((atom_length >> 16) & 255);
#line 372
          buffer___0[0] = (unsigned char )((atom_length >> 24) & 255);
#line 373
          r_write(out_fd, (void *)(buffer___0), 4U);
#line 375
          r_write(out_fd, (void *)"covr", 4U);
#line 378
          atom_length = (int )(extra_size - 8L);
#line 379
          buffer___0[3] = (unsigned char )(atom_length & 255);
#line 380
          buffer___0[2] = (unsigned char )((atom_length >> 8) & 255);
#line 381
          buffer___0[1] = (unsigned char )((atom_length >> 16) & 255);
#line 382
          buffer___0[0] = (unsigned char )((atom_length >> 24) & 255);
#line 383
          r_write(out_fd, (void *)(buffer___0), 4U);
#line 385
          r_write(out_fd, (void *)"data", 4U);
#line 388
          buffer___0[3] = img_type_flag;
#line 389
          buffer___0[2] = (unsigned char)0;
#line 390
          buffer___0[1] = (unsigned char)0;
#line 391
          buffer___0[0] = (unsigned char)0;
#line 392
          r_write(out_fd, (void *)(buffer___0), 4U);
#line 395
          buffer___0[3] = (unsigned char)0;
#line 396
          buffer___0[2] = (unsigned char)0;
#line 397
          buffer___0[1] = (unsigned char)0;
#line 398
          buffer___0[0] = (unsigned char)0;
#line 400
          r_write(out_fd, (void *)(buffer___0), 4U);
#line 403
          lseek(img_fd, 0L, 0);
#line 404
          copyfile(img_fd, out_fd);
#line 405
          last_pos = cur_pos;
        } else {
#line 407
          err_log(1, 256U, (char *)"No \'ilst\' atom found.\n");
        }
      } else {
#line 410
        err_log(1, 256U, (char *)"No \'meta\' atom found.\n");
      }
    } else {
#line 413
      err_log(1, 256U, (char *)"No \'udta\' atom found.\n");
    }
  } else {
#line 416
    err_log(1, 256U, (char *)"No \'moov\' atom found.\n");
  }
#line 421
  lseek(aac_fd, last_pos, 0);
#line 423
  return (last_pos);
}
}
#line 434 "dynamic-art.c"
off_t da_aac_attach_image(int img_fd , int out_fd , int aac_fd , int offset ) 
{ off_t img_size ;
  int atom_length ;
  unsigned int extra_size ;
  off_t file_size ;
  unsigned char buffer___0[4] ;
  struct stat sb ;
  FILE *aac_fp ;
  off_t stco_atom_pos ;
  off_t ilst_atom_pos ;
  off_t last_pos ;
  int tmp ;
  int tmp___0 ;

  {
#line 447
  fstat(img_fd, & sb);
#line 448
  img_size = sb.st_size;
#line 450
  err_log(5, 256U, (char *)"Image size (in bytes): %ld.\n", img_size);
#line 454
  if (img_size < 1L) {
#line 455
    r_close(img_fd);
#line 456
    return (0L);
  }
#line 462
  extra_size = (unsigned int )(img_size + 24L);
#line 464
  fstat(aac_fd, & sb);
#line 465
  file_size = sb.st_size;
#line 467
  tmp = dup(aac_fd);
#line 467
  aac_fp = fdopen(tmp, "r");
#line 469
  stco_atom_pos = aac_drilltoatom(aac_fp, (char *)"moov:trak:mdia:minf:stbl:stco",
                                  (unsigned int *)(& atom_length));
#line 471
  ilst_atom_pos = aac_drilltoatom(aac_fp, (char *)"moov:udta:meta:ilst", (unsigned int *)(& atom_length));
#line 473
  last_pos = aac_drilltoatom(aac_fp, (char *)"mdat", (unsigned int *)(& atom_length));
#line 475
  if (last_pos != -1L) {
#line 476
    if ((off_t )offset >= last_pos) {
#line 479
      return (0L);
    }
  } else {
#line 482
    err_log(1, 256U, (char *)"No \'mdat\' atom.\n");
#line 483
    return (0L);
  }
#line 486
  rewind(aac_fp);
#line 489
  tmp___0 = (int )scan_aac_findatom(aac_fp, file_size, "moov", & atom_length);
#line 489
  last_pos = (long )tmp___0;
#line 490
  if (last_pos != -1L) {
#line 492
    rewind(aac_fp);
#line 493
    fcopyblock(aac_fp, out_fd, last_pos);
#line 496
    atom_length = (int )((unsigned int )atom_length + extra_size);
#line 497
    buffer___0[3] = (unsigned char )(atom_length & 255);
#line 498
    buffer___0[2] = (unsigned char )((atom_length >> 8) & 255);
#line 499
    buffer___0[1] = (unsigned char )((atom_length >> 16) & 255);
#line 500
    buffer___0[0] = (unsigned char )((atom_length >> 24) & 255);
#line 501
    r_write(out_fd, (void *)(buffer___0), 4U);
#line 503
    last_pos += 4L;
  } else {
#line 505
    err_log(1, 256U, (char *)"Could not find \'moov\' atom.\n");
#line 506
    return (0L);
  }
#line 509
  if (stco_atom_pos < ilst_atom_pos) {
#line 510
    last_pos = da_aac_rewrite_stco_atom((long )extra_size, out_fd, aac_fp, last_pos);
#line 511
    last_pos = da_aac_insert_covr_atom((long )extra_size, out_fd, aac_fp, last_pos,
                                       file_size, img_fd);
  } else {
#line 514
    last_pos = da_aac_insert_covr_atom((long )extra_size, out_fd, aac_fp, last_pos,
                                       file_size, img_fd);
#line 516
    last_pos = da_aac_rewrite_stco_atom((long )extra_size, out_fd, aac_fp, last_pos);
  }
#line 520
  lseek(aac_fd, last_pos, 0);
#line 522
  r_close(img_fd);
#line 523
  fclose(aac_fp);
#line 525
  return (last_pos);
}
}
#line 528 "dynamic-art.c"
int copyblock(int fromfd , int tofd , size_t size ) 
{ char buf[4096] ;
  int bytesread ;
  int totalbytes ;
  int blocksize ;
  int bytesleft ;
  ssize_t tmp ;

  {
#line 531
  totalbytes = 0;
#line 532
  blocksize = 4096;
#line 535
  while ((size_t )totalbytes < size) {
#line 536
    bytesleft = (int )(size - (size_t )totalbytes);
#line 537
    if (bytesleft < 4096) {
#line 538
      blocksize = bytesleft;
    } else {
#line 540
      blocksize = 4096;
    }
#line 542
    bytesread = r_read(fromfd, (void *)(buf), (unsigned int )blocksize);
#line 542
    if (bytesread < 0) {
#line 543
      return (-1);
    }
#line 544
    if (bytesread == 0) {
#line 545
      return (totalbytes);
    }
#line 546
    tmp = r_write(tofd, (void *)(buf), (unsigned int )bytesread);
#line 546
    if (tmp < 0) {
#line 547
      return (-1);
    }
#line 548
    totalbytes += bytesread;
  }
#line 550
  return (totalbytes);
}
}
#line 553 "dynamic-art.c"
int fcopyblock(FILE *fromfp , int tofd , size_t size ) 
{ char buf[4096] ;
  int bytesread ;
  int totalbytes ;
  int blocksize ;
  int bytesleft ;
  int tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;

  {
#line 556
  totalbytes = 0;
#line 557
  blocksize = 4096;
#line 560
  while ((size_t )totalbytes < size) {
#line 561
    bytesleft = (int )(size - (size_t )totalbytes);
#line 562
    if (bytesleft < 4096) {
#line 563
      blocksize = bytesleft;
    } else {
#line 565
      blocksize = 4096;
    }
#line 567
    tmp___0 = fread((void * __restrict  )(buf), 1U, (unsigned int )blocksize, (FILE * __restrict  )fromfp);
#line 567
    bytesread = (int )tmp___0;
#line 567
    if (bytesread < blocksize) {
#line 568
      tmp = ferror(fromfp);
#line 568
      if (tmp) {
#line 569
        return (-1);
      }
    }
#line 571
    tmp___1 = r_write(tofd, (void *)(buf), (unsigned int )bytesread);
#line 571
    if (tmp___1 < 0) {
#line 572
      return (-1);
    }
#line 574
    tmp___2 = feof(fromfp);
#line 574
    if (tmp___2) {
#line 575
      return (0);
    }
#line 576
    totalbytes += bytesread;
  }
#line 578
  return (totalbytes);
}
}
#line 1 "query.o"
#pragma merger(0,"/tmp/cil-s5gxkK0k.i","-g,-g,-O2")
#line 184 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 210
__inline static  __attribute__((__nothrow__)) long long strtoll(char const   * __restrict  __nptr ,
                                                                char ** __restrict  __endptr ,
                                                                int __base )  __attribute__((__nonnull__(1))) ;
#line 12 "query.c"
static query_field_t const   *find_field(char const   *name , query_field_t const   *fields ) ;
#line 14
static int arith_query(query_node_t *query , void *target ) ;
#line 15
static int string_query(query_node_t *query , void *target ) ;
#line 17
static query_node_t *match_specifier(char const   *query , char const   **cursor ,
                                     query_field_t const   *fields ) ;
#line 20
static query_node_t *group_match(char const   *query , char const   **pcursor , query_field_t const   *fields ) ;
#line 23
static query_node_t *single_match(char const   *query , char const   **pcursor , query_field_t const   *fields ) ;
#line 26
static int get_field_name(char const   **pcursor , char const   *query , char *name ,
                          int len ) ;
#line 34
static query_node_t *match_number(query_field_t const   *field , char not , char opcode ,
                                  char const   **pcursor , char const   *query ) ;
#line 38
static query_node_t *match_string(query_field_t const   *field , char not , char opcode ,
                                  char const   **pcursor , char const   *query ) ;
#line 42
char *query_unescape(char const   *src ) ;
#line 44 "query.c"
query_node_t *query_build(char const   *query , query_field_t const   *fields ) 
{ query_node_t *left ;
  char *raw ;
  char *tmp ;
  char const   *cursor ;
  query_node_t *right ;
  query_type_t join ;
  query_node_t *con ;
  void *tmp___0 ;

  {
#line 46
  left = (query_node_t *)0;
#line 47
  tmp = query_unescape(query);
#line 47
  raw = tmp;
#line 48
  cursor = (char const   *)raw;
#line 49
  right = (query_node_t *)0;
#line 52
  left = match_specifier(query, & cursor, fields);
#line 52
  if ((unsigned int )((query_node_t *)0) == (unsigned int )left) {
    goto error;
  }
#line 55
  while (*cursor) {
#line 59
    switch ((int )*cursor) {
    case 43: 
    case 32: 
#line 62
    join = 1;
#line 62
    break;
    case 44: 
#line 63
    join = 2;
#line 63
    break;
    default: 
#line 65
    err_log(1, 16U, (char *)"Illegal character \'%c\' (0%o) at index %d: %s\n", *cursor,
            *cursor, cursor - (char const   *)raw, raw);
    goto error;
    }
#line 70
    cursor ++;
#line 72
    right = match_specifier((char const   *)raw, & cursor, fields);
#line 72
    if ((unsigned int )((query_node_t *)0) == (unsigned int )right) {
      goto error;
    }
#line 75
    tmp___0 = calloc(1U, sizeof(*con));
#line 75
    con = (query_node_t *)tmp___0;
#line 76
    con->type = join;
#line 77
    con->left.node = left;
#line 78
    con->right.node = right;
#line 80
    left = con;
  }
#line 83
  if ((unsigned int )query != (unsigned int )raw) {
#line 84
    free((void *)raw);
  }
#line 86
  return (left);
  error: 
#line 89
  if ((unsigned int )left != (unsigned int )((query_node_t *)0)) {
#line 90
    query_free(left);
  }
#line 91
  if ((unsigned int )raw != (unsigned int )query) {
#line 92
    free((void *)raw);
  }
#line 94
  return ((query_node_t *)((void *)0));
}
}
#line 97 "query.c"
static query_node_t *match_specifier(char const   *query , char const   **cursor ,
                                     query_field_t const   *fields ) 
{ query_node_t *tmp ;
  query_node_t *tmp___0 ;

  {
#line 101
  switch ((int )*(*cursor)) {
  case 39: 
#line 103
  tmp = single_match(query, cursor, fields);
#line 103
  return (tmp);
  case 40: 
#line 104
  tmp___0 = group_match(query, cursor, fields);
#line 104
  return (tmp___0);
  }
#line 107
  err_log(1, 16U, (char *)"Illegal character \'%c\' (0%o) at index %d: %s\n", *(*cursor),
          *(*cursor), *cursor - query, query);
#line 109
  return ((query_node_t *)((void *)0));
}
}
#line 112 "query.c"
static query_node_t *group_match(char const   *query , char const   **pcursor , query_field_t const   *fields ) 
{ query_node_t *left ;
  query_node_t *right ;
  query_node_t *join ;
  query_type_t opcode ;
  char const   *cursor ;
  void *tmp ;

  {
#line 116
  left = (query_node_t *)0;
#line 117
  right = (query_node_t *)0;
#line 118
  join = (query_node_t *)0;
#line 120
  cursor = *pcursor;
#line 123
  cursor ++;
#line 125
  left = single_match(query, & cursor, fields);
#line 125
  if ((unsigned int )((query_node_t *)0) == (unsigned int )left) {
#line 126
    return ((query_node_t *)((void *)0));
  }
#line 128
  switch ((int )*cursor) {
  case 43: 
  case 32: 
#line 132
  opcode = 1;
#line 133
  break;
  case 44: 
#line 136
  opcode = 2;
#line 137
  break;
  default: 
#line 140
  err_log(1, 16U, (char *)"Illegal character \'%c\' (0%o) at index %d: %s\n", *cursor,
          *cursor, cursor - query, query);
  goto error;
  }
#line 145
  right = single_match(query, & cursor, fields);
#line 145
  if ((unsigned int )((query_node_t *)0) == (unsigned int )right) {
    goto error;
  }
#line 148
  if ((int const   )*cursor != 41) {
#line 150
    err_log(1, 16U, (char *)"Illegal character \'%c\' (0%o) at index %d: %s\n", *cursor,
            *cursor, cursor - query, query);
    goto error;
  }
#line 155
  *pcursor = cursor + 1;
#line 157
  tmp = calloc(1U, sizeof(*join));
#line 157
  join = (query_node_t *)tmp;
#line 158
  join->type = opcode;
#line 159
  join->left.node = left;
#line 160
  join->right.node = right;
#line 162
  return (join);
  error: 
#line 165
  if ((unsigned int )((query_node_t *)0) != (unsigned int )left) {
#line 166
    query_free(left);
  }
#line 167
  if ((unsigned int )((query_node_t *)0) != (unsigned int )right) {
#line 168
    query_free(right);
  }
#line 170
  return ((query_node_t *)0);
}
}
#line 173 "query.c"
static query_node_t *single_match(char const   *query , char const   **pcursor , query_field_t const   *fields ) 
{ char fname[64] ;
  query_field_t const   *field ;
  char not ;
  char op ;
  query_node_t *node ;
  int tmp ;
  char *tmp___1 ;

  {
#line 179
  not = (char)0;
#line 180
  op = (char)0;
#line 181
  node = (query_node_t *)0;
#line 184
  (*pcursor) ++;
#line 187
  tmp = get_field_name(pcursor, query, fname, (int )sizeof(fname));
#line 187
  if (! tmp) {
#line 188
    return ((query_node_t *)((void *)0));
  }
#line 190
  if ((int const   )*(*pcursor) == 33) {
#line 192
    not = (char )'!';
#line 193
    (*pcursor) ++;
  }
#line 196
  tmp___1 = __builtin_strchr((char *)":+-", (int )*(*pcursor));
#line 196
  if (tmp___1) {
#line 198
    op = (char )*(*pcursor);
#line 199
    (*pcursor) ++;
  } else {
#line 203
    err_log(1, 16U, (char *)"Illegal Operator: %c (0%o) at index %d: %s\n", *(*pcursor),
            *(*pcursor), *pcursor - query, query);
#line 205
    return ((query_node_t *)((void *)0));
  }
#line 208
  field = find_field((char const   *)(fname), fields);
#line 208
  if ((unsigned int )((query_field_t const   *)0) == (unsigned int )field) {
#line 210
    err_log(1, 16U, (char *)"Unknown field: %s\n", fname);
#line 211
    return ((query_node_t *)((void *)0));
  }
#line 214
  switch ((int )field->type) {
  case 15: 
  case 16: 
#line 218
  node = match_number(field, not, op, pcursor, query);
#line 219
  break;
  case 17: 
#line 222
  node = match_string(field, not, op, pcursor, query);
#line 223
  break;
  default: 
#line 226
  err_log(1, 16U, (char *)"Invalid field type: %d\n", field->type);
#line 227
  break;
  }
#line 230
  if ((int const   )*(*pcursor) != 39) {
#line 232
    err_log(1, 16U, (char *)"Illegal Character: %c (0%o) index %d: %s\n", *(*pcursor),
            *(*pcursor), *pcursor - query, query);
#line 234
    query_free(node);
#line 235
    node = (query_node_t *)0;
  } else {
#line 238
    (*pcursor) ++;
  }
#line 240
  return (node);
}
}
#line 250
extern int ( /* missing proto */  isalpha)() ;
#line 243 "query.c"
static int get_field_name(char const   **pcursor , char const   *query , char *name ,
                          int len ) 
{ char const   *cursor ;
  int tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 248
  cursor = *pcursor;
#line 250
  tmp = isalpha(*cursor);
#line 250
  if (! tmp) {
#line 251
    return (0);
  }
#line 253
  while (1) {
#line 253
    tmp___2 = isalpha(*cursor);
#line 253
    if (! tmp___2) {
#line 253
      if (! ((int const   )*cursor == 46)) {
#line 253
        break;
      }
    }
#line 255
    len --;
#line 255
    if (len <= 0) {
#line 257
      err_log(1, 16U, (char *)"token length exceeded at offset %d: %s\n", cursor - query,
              query);
#line 259
      return (0);
    }
#line 262
    tmp___0 = name;
#line 262
    name ++;
#line 262
    tmp___1 = cursor;
#line 262
    cursor ++;
#line 262
    *tmp___0 = (char )*tmp___1;
  }
#line 265
  *pcursor = cursor;
#line 267
  *name = (char)0;
#line 269
  return (1);
}
}
#line 272 "query.c"
static query_node_t *match_number(query_field_t const   *field , char not , char opcode ,
                                  char const   **pcursor , char const   *query ) 
{ query_node_t *node ;
  void *tmp ;
  long tmp___0 ;

  {
#line 277
  tmp = calloc(1U, sizeof(*node));
#line 277
  node = (query_node_t *)tmp;
#line 279
  switch ((int )opcode) {
  case 58: 
#line 282
  if (not) {
#line 282
    node->type = 5;
  } else {
#line 282
    node->type = 4;
  }
#line 283
  break;
  case 43: 
  case 32: 
#line 286
  if (not) {
#line 286
    node->type = 6;
  } else {
#line 286
    node->type = 9;
  }
#line 287
  break;
  case 45: 
#line 289
  if (not) {
#line 289
    node->type = 8;
  } else {
#line 289
    node->type = 7;
  }
#line 290
  break;
  }
#line 293
  node->left.field = field;
#line 295
  switch ((int )field->type) {
  case 15: 
#line 298
  tmp___0 = strtol((char const   * __restrict  )*pcursor, (char ** __restrict  )((char **)pcursor),
                   10);
#line 298
  node->right.i32 = (int )tmp___0;
#line 299
  break;
  case 16: 
#line 301
  node->right.i64 = strtoll((char const   * __restrict  )*pcursor, (char ** __restrict  )((char **)pcursor),
                            10);
#line 302
  break;
  }
#line 305
  if ((int const   )*(*pcursor) != 39) {
#line 307
    err_log(1, 16U, (char *)"Illegal char in number \'%c\' (0%o) at index %d: %s\n",
            *(*pcursor), *(*pcursor), *pcursor - query, query);
#line 309
    free((void *)node);
#line 310
    return ((query_node_t *)0);
  }
#line 313
  return (node);
}
}
#line 316 "query.c"
static query_node_t *match_string(query_field_t const   *field , char not , char opcode ,
                                  char const   **pcursor , char const   *query ) 
{ char match[64] ;
  char *dst ;
  int left ;
  char const   *cursor ;
  query_type_t op ;
  query_node_t *node ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  void *tmp___3 ;
  char *tmp___9 ;

  {
#line 322
  dst = match;
#line 323
  left = (int )sizeof(match);
#line 324
  cursor = *pcursor;
#line 325
  op = 10;
#line 328
  if ((int )opcode != 58) {
#line 330
    err_log(1, 16U, (char *)"Illegal operation on string: %c at index %d: %s\n", opcode,
            (cursor - query) - 1);
#line 332
    return ((query_node_t *)((void *)0));
  }
#line 335
  if ((int const   )*cursor == 42) {
#line 337
    op = 12;
#line 338
    cursor ++;
  }
#line 341
  while (1) {
#line 341
    if (*cursor) {
#line 341
      if (! ((int const   )*cursor != 39)) {
#line 341
        break;
      }
    } else {
#line 341
      break;
    }
#line 343
    left --;
#line 343
    if (left == 0) {
#line 345
      err_log(1, 16U, (char *)"string too long at index %d: %s\n", cursor - query,
              query);
#line 347
      return ((query_node_t *)((void *)0));
    }
#line 350
    if ((int const   )*cursor == 92) {
#line 352
      cursor ++;
#line 352
      switch ((int )*cursor) {
      case 42: 
      case 39: 
      case 92: 
#line 357
      tmp = dst;
#line 357
      dst ++;
#line 357
      tmp___0 = cursor;
#line 357
      cursor ++;
#line 357
      *tmp = (char )*tmp___0;
#line 358
      break;
      default: 
#line 360
      err_log(1, 16U, (char *)"Illegal escape: %c (0%o) at index %d: %s\n", *cursor,
              *cursor, cursor - query, query);
#line 362
      return ((query_node_t *)((void *)0));
      }
    } else {
#line 366
      tmp___1 = dst;
#line 366
      dst ++;
#line 366
      tmp___2 = cursor;
#line 366
      cursor ++;
#line 366
      *tmp___1 = (char )*tmp___2;
    }
  }
#line 369
  if ((int )*(dst + -1) == 42) {
#line 371
    if ((int )op == 10) {
#line 371
      op = 11;
    } else {
#line 371
      op = 13;
    }
#line 372
    dst --;
  }
#line 375
  *dst = (char)0;
#line 377
  tmp___3 = calloc(1U, sizeof(*node));
#line 377
  node = (query_node_t *)tmp___3;
#line 378
  node->type = op;
#line 379
  node->left.field = field;
#line 380
  tmp___9 = __strdup((char const   *)(match));
#line 380
  node->right.str = tmp___9;
#line 382
  *pcursor = cursor;
#line 384
  return (node);
}
}
#line 387 "query.c"
int query_test(query_node_t *query , void *target ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 389
  switch ((int )query->type) {
  case 1: 
#line 393
  tmp = query_test(query->left.node, target);
#line 393
  if (tmp) {
#line 393
    tmp___0 = query_test(query->right.node, target);
#line 393
    if (tmp___0) {
#line 393
      tmp___1 = 1;
    } else {
#line 393
      tmp___1 = 0;
    }
  } else {
#line 393
    tmp___1 = 0;
  }
#line 393
  return (tmp___1);
  case 2: 
#line 397
  tmp___2 = query_test(query->left.node, target);
#line 397
  if (tmp___2) {
#line 397
    tmp___4 = 1;
  } else {
#line 397
    tmp___3 = query_test(query->right.node, target);
#line 397
    if (tmp___3) {
#line 397
      tmp___4 = 1;
    } else {
#line 397
      tmp___4 = 0;
    }
  }
#line 397
  return (tmp___4);
  case 3: 
#line 402
  tmp___5 = query_test(query->left.node, target);
#line 402
  if (tmp___5) {
#line 402
    tmp___6 = 0;
  } else {
#line 402
    tmp___6 = 1;
  }
#line 402
  return (tmp___6);
  case 4: 
  case 5: 
  case 6: 
  case 7: 
  case 8: 
  case 9: 
#line 411
  tmp___7 = arith_query(query, target);
#line 411
  return (tmp___7);
  case 10: 
  case 11: 
  case 12: 
  case 13: 
#line 418
  tmp___8 = string_query(query, target);
#line 418
  return (tmp___8);
#line 419
  break;
  case 14: 
#line 423
  return (query->left.constant);
  }
#line 425
  return (0);
}
}
#line 427 "query.c"
void query_free(query_node_t *query ) 
{ 

  {
#line 429
  if ((unsigned int )((query_node_t *)0) != (unsigned int )query) {
#line 431
    switch ((int )query->type) {
    case 1: 
    case 2: 
#line 436
    query_free(query->left.node);
#line 437
    query_free(query->right.node);
#line 438
    break;
    case 3: 
#line 442
    query_free(query->left.node);
#line 443
    break;
    case 4: 
    case 5: 
    case 6: 
    case 7: 
    case 8: 
    case 9: 
#line 452
    break;
    case 10: 
    case 11: 
    case 12: 
    case 13: 
#line 459
    free((void *)query->right.str);
#line 460
    break;
    case 14: 
#line 464
    break;
    default: 
#line 467
    err_log(1, 16U, (char *)"Illegal query type: %d\n", query->type);
#line 468
    break;
    }
#line 471
    free((void *)query);
  }
#line 473
  return;
}
}
#line 475 "query.c"
static query_field_t const   *find_field(char const   *name , query_field_t const   *fields ) 
{ int tmp ;

  {
#line 477
  while (1) {
#line 477
    if (fields->name) {
#line 477
      tmp = strcasecmp((char const   *)fields->name, name);
#line 477
      if (! tmp) {
#line 477
        break;
      }
    } else {
#line 477
      break;
    }
#line 478
    fields ++;
  }
#line 480
  if ((unsigned int )fields->name == (unsigned int )((char const   * const  )0)) {
#line 482
    err_log(1, 16U, (char *)"Illegal query field: %s\n", name);
#line 483
    return ((query_field_t const   *)((void *)0));
  }
#line 486
  return (fields);
}
}
#line 489 "query.c"
static int arith_query(query_node_t *query , void *target ) 
{ query_field_t const   *field ;
  int tv ;
  long long tv___0 ;

  {
#line 491
  field = query->left.field;
#line 493
  switch ((int )field->type) {
  case 15: 
#line 497
  tv = *((int *)((unsigned int )target + (unsigned int )field->offset));
#line 499
  tv -= query->right.i32;
#line 501
  switch ((int )query->type) {
  case 4: 
#line 503
  return (tv == 0);
  case 5: 
#line 504
  return (tv != 0);
  case 6: 
#line 505
  return (tv <= 0);
  case 7: 
#line 506
  return (tv < 0);
  case 8: 
#line 507
  return (tv >= 0);
  case 9: 
#line 508
  return (tv > 0);
  default: 
#line 510
  err_log(1, 16U, (char *)"illegal query type: %d\n", query->type);
#line 511
  break;
  }
#line 514
  break;
  case 16: 
#line 518
  tv___0 = *((long long *)((unsigned int )target + (unsigned int )field->offset));
#line 520
  tv___0 -= (long long )query->right.i32;
#line 522
  switch ((int )query->type) {
  case 4: 
#line 524
  return (tv___0 == 0LL);
  case 5: 
#line 525
  return (tv___0 != 0LL);
  case 6: 
#line 526
  return (tv___0 <= 0LL);
  case 7: 
#line 527
  return (tv___0 < 0LL);
  case 8: 
#line 528
  return (tv___0 >= 0LL);
  case 9: 
#line 529
  return (tv___0 > 0LL);
  default: 
#line 531
  err_log(1, 16U, (char *)"illegal query type: %d\n", query->type);
#line 532
  break;
  }
#line 535
  break;
  default: 
#line 538
  err_log(1, 16U, (char *)"illegal field type: %d\n", field->type);
#line 539
  break;
  }
#line 542
  return (0);
}
}
#line 545 "query.c"
static int string_query(query_node_t *query , void *target ) 
{ query_field_t const   *field ;
  char const   *ts ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int start ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 547
  field = query->left.field;
#line 550
  if ((int const   )field->type != 17) {
#line 552
    err_log(1, 16U, (char *)"illegal field type: %d\n", field->type);
#line 553
    return (0);
  }
#line 556
  ts = *((char const   **)((unsigned int )target + (unsigned int )field->offset));
#line 558
  if ((unsigned int )((char const   *)0) == (unsigned int )ts) {
#line 559
    tmp = strlen((char const   *)query->right.str);
#line 559
    return (tmp == 0U);
  }
#line 561
  switch ((int )query->type) {
  case 10: 
#line 564
  tmp___0 = strcasecmp((char const   *)query->right.str, ts);
#line 564
  if (tmp___0) {
#line 564
    tmp___1 = 0;
  } else {
#line 564
    tmp___1 = 1;
  }
#line 564
  return (tmp___1);
  case 11: 
#line 567
  tmp___2 = strlen((char const   *)query->right.str);
#line 567
  tmp___3 = strncasecmp((char const   *)query->right.str, ts, tmp___2);
#line 567
  if (tmp___3) {
#line 567
    tmp___4 = 0;
  } else {
#line 567
    tmp___4 = 1;
  }
#line 567
  return (tmp___4);
  case 12: 
#line 571
  tmp___5 = strlen(ts);
#line 571
  tmp___6 = strlen((char const   *)query->right.str);
#line 571
  start = (int )(tmp___5 - tmp___6);
#line 573
  if (start < 0) {
#line 574
    return (0);
  }
#line 576
  tmp___7 = strcasecmp((char const   *)query->right.str, ts + start);
#line 576
  if (tmp___7) {
#line 576
    tmp___8 = 0;
  } else {
#line 576
    tmp___8 = 1;
  }
#line 576
  return (tmp___8);
  case 13: 
#line 580
  tmp___9 = strcasestr(ts, query->right.str);
#line 580
  return (tmp___9);
  default: 
#line 583
  err_log(1, 16U, (char *)"Illegal query type: %d\n", query->type);
#line 584
  break;
  }
#line 587
  return (0);
}
}
#line 592 "query.c"
static char const   *labels[15]  = 
#line 592
  {      "NOP",      "and",      "or",      "not", 
        "==",      "!=",      "<=",      "<", 
        ">=",      ">",      "eq",      "beginswith", 
        "endwith",      "contains",      "constant"};
#line 590 "query.c"
void query_dump(FILE *fp , query_node_t *query , int depth ) 
{ char const   *tmp ;

  {
#line 611
  return;
#line 614
  switch ((int )query->type) {
  case 1: 
  case 2: 
#line 618
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%*s(%s\n", depth,
          "", labels[query->type]);
#line 619
  query_dump(fp, query->left.node, depth + 4);
#line 620
  query_dump(fp, query->right.node, depth + 4);
#line 621
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%*s)\n", depth, "");
#line 622
  break;
  case 3: 
#line 625
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%*s(not\n", depth,
          "");
#line 626
  query_dump(fp, query->left.node, depth + 4);
#line 627
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%*s)\n", depth, "");
#line 628
  break;
  case 4: 
  case 5: 
  case 6: 
  case 7: 
  case 8: 
  case 9: 
#line 637
  if ((int const   )(query->left.field)->type == 15) {
#line 638
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%*s(%s %s %d)\n",
            depth, "", labels[query->type], (query->left.field)->name, query->right.i32);
  } else {
#line 642
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%*s(%s %s %q)\n",
            depth, "", labels[query->type], (query->left.field)->name, query->right.i64);
  }
#line 645
  break;
  case 10: 
  case 11: 
  case 12: 
  case 13: 
#line 652
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%*s(%s %s \"%s\")\n",
          depth, "", labels[query->type], (query->left.field)->name, query->right.str);
#line 655
  break;
  case 14: 
#line 659
  if (query->left.constant) {
#line 659
    tmp = "true";
  } else {
#line 659
    tmp = "false";
  }
#line 659
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%*s(%s)\n", depth,
          "", tmp);
#line 660
  break;
  }
}
}
#line 681
extern int ( /* missing proto */  tolower)() ;
#line 678
extern int ( /* missing proto */  isdigit)() ;
#line 665 "query.c"
char *query_unescape(char const   *src ) 
{ char *copy ;
  size_t tmp ;
  void *tmp___0 ;
  char *dst ;
  int val ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;

  {
#line 667
  tmp = strlen(src);
#line 667
  tmp___0 = malloc(tmp + 1U);
#line 667
  copy = (char *)tmp___0;
#line 668
  dst = copy;
#line 670
  while (*src) {
#line 672
    if ((int const   )*src == 37) {
#line 674
      val = 0;
#line 676
      src ++;
#line 676
      if (*src) {
#line 678
        tmp___2 = isdigit(*src);
#line 678
        if (tmp___2) {
#line 679
          val = (val * 16 + (int )*src) - 48;
        } else {
#line 681
          tmp___1 = tolower(*src);
#line 681
          val = ((val * 16 + tmp___1) - 97) + 10;
        }
      }
#line 684
      src ++;
#line 684
      if (*src) {
#line 686
        tmp___4 = isdigit(*src);
#line 686
        if (tmp___4) {
#line 687
          val = (val * 16 + (int )*src) - 48;
        } else {
#line 689
          tmp___3 = tolower(*src);
#line 689
          val = ((val * 16 + tmp___3) - 97) + 10;
        }
      }
#line 692
      src ++;
#line 693
      tmp___5 = dst;
#line 693
      dst ++;
#line 693
      *tmp___5 = (char )val;
    } else {
#line 696
      tmp___6 = dst;
#line 696
      dst ++;
#line 696
      tmp___7 = src;
#line 696
      src ++;
#line 696
      *tmp___6 = (char )*tmp___7;
    }
  }
#line 699
  tmp___8 = dst;
#line 699
  dst ++;
#line 699
  *tmp___8 = (char)0;
#line 701
  return (copy);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned int  , void * ) ;  */
#line 1 "mDNS.o"
#pragma merger(0,"/tmp/cil-6CFP0XjI.i","-g,-g,-O2")
#line 109 "mDNSDebug.h"
void LogMsg(char const   *format  , ...) ;
#line 1107 "mDNSClientAPI.h"
union __anonunion_mDNSOpaque16_18  const  zeroIPPort ;
#line 1108
union __anonunion_mDNSOpaque32_19  const  zeroIPAddr ;
#line 1109
union __anonunion_mDNSOpaque128_20  const  zerov6Addr ;
#line 1110
union __anonunion_mDNSOpaque32_19  const  onesIPv4Addr ;
#line 1111
union __anonunion_mDNSOpaque128_20  const  onesIPv6Addr ;
#line 1112
struct mDNSInterfaceID_dummystruct * const  mDNSInterface_Any ;
#line 1114
union __anonunion_mDNSOpaque16_18  const  UnicastDNSPort ;
#line 1115
union __anonunion_mDNSOpaque16_18  const  MulticastDNSPort ;
#line 1116
union __anonunion_mDNSOpaque32_19  const  AllDNSAdminGroup ;
#line 1117
union __anonunion_mDNSOpaque32_19  const  AllDNSLinkGroup ;
#line 1118
union __anonunion_mDNSOpaque128_20  const  AllDNSLinkGroupv6 ;
#line 1119
struct __anonstruct_mDNSAddr_22  const  AllDNSLinkGroup_v4 ;
#line 1120
struct __anonstruct_mDNSAddr_22  const  AllDNSLinkGroup_v6 ;
#line 1160
mStatus mDNS_Init(mDNS *m , mDNS_PlatformSupport *p , CacheRecord *rrcachestorage ,
                  mDNSu32 rrcachesize , mDNSBool AdvertiseLocalAddresses , mDNSCallback *Callback ,
                  void *Context ) ;
#line 1173
void mDNS_GrowCache(mDNS *m , CacheRecord *storage , mDNSu32 numrecords ) ;
#line 1174
void mDNS_Close(mDNS *m ) ;
#line 1175
mDNSs32 mDNS_Execute(mDNS *m ) ;
#line 1177
mStatus mDNS_Register(mDNS *m , AuthRecord *rr ) ;
#line 1178
mStatus mDNS_Update(mDNS *m , AuthRecord *rr , mDNSu32 newttl , mDNSu16 newrdlength ,
                    RData *newrdata , mDNSRecordUpdateCallback *Callback ) ;
#line 1181
mStatus mDNS_Deregister(mDNS *m , AuthRecord *rr ) ;
#line 1183
mStatus mDNS_StartQuery(mDNS *m , DNSQuestion *question ) ;
#line 1184
mStatus mDNS_StopQuery(mDNS *m , DNSQuestion *question ) ;
#line 1185
mStatus mDNS_Reconfirm(mDNS *m , CacheRecord *rr ) ;
#line 1186
mStatus mDNS_ReconfirmByValue(mDNS *m , ResourceRecord *rr ) ;
#line 1193
mDNSs32 mDNSPlatformOneSecond ;
#line 1194
mDNSs32 mDNSPlatformTimeNow(void) ;
#line 1218
void mDNS_SetupResourceRecord(AuthRecord *rr , RData *RDataStorage , mDNSInterfaceID InterfaceID ,
                              mDNSu16 rrtype , mDNSu32 ttl , mDNSu8 RecordType , mDNSRecordCallback *Callback ,
                              void *Context ) ;
#line 1221
mStatus mDNS_RegisterService(mDNS *m , ServiceRecordSet *sr , domainlabel const   *name ,
                             domainname const   *type , domainname const   *domain ,
                             domainname const   *host , mDNSIPPort port , mDNSu8 const   *txtinfo ,
                             mDNSu16 txtlen , AuthRecord *SubTypes , mDNSu32 NumSubTypes ,
                             mDNSInterfaceID InterfaceID , mDNSServiceCallback *Callback ,
                             void *Context ) ;
#line 1226
mStatus mDNS_AddRecordToService(mDNS *m , ServiceRecordSet *sr , ExtraResourceRecord *extra ,
                                RData *rdata , mDNSu32 ttl ) ;
#line 1227
mStatus mDNS_RemoveRecordFromService(mDNS *m , ServiceRecordSet *sr , ExtraResourceRecord *extra ) ;
#line 1228
mStatus mDNS_RenameAndReregisterService(mDNS *m , ServiceRecordSet *sr , domainlabel const   *newname ) ;
#line 1229
mStatus mDNS_DeregisterService(mDNS *m , ServiceRecordSet *sr ) ;
#line 1231
mStatus mDNS_RegisterNoSuchService(mDNS *m , AuthRecord *rr , domainlabel const   *name ,
                                   domainname const   *type , domainname const   *domain ,
                                   domainname const   *host , mDNSInterfaceID InterfaceID ,
                                   mDNSRecordCallback *Callback , void *Context ) ;
#line 1237
mStatus mDNS_StartBrowse(mDNS *m , DNSQuestion *question , domainname const   *srv ,
                         domainname const   *domain , mDNSInterfaceID InterfaceID ,
                         mDNSQuestionCallback *Callback , void *Context ) ;
#line 1242
mStatus mDNS_StartResolveService(mDNS *m , ServiceInfoQuery *query , ServiceInfo *info ,
                                 mDNSServiceInfoQueryCallback *Callback , void *Context ) ;
#line 1243
void mDNS_StopResolveService(mDNS *m , ServiceInfoQuery *query ) ;
#line 1253
mStatus mDNS_GetDomains(mDNS *m , DNSQuestion *question , mDNS_DomainType DomainType ,
                        mDNSInterfaceID InterfaceID , mDNSQuestionCallback *Callback ,
                        void *Context ) ;
#line 1258
mStatus mDNS_AdvertiseDomains(mDNS *m , AuthRecord *rr , mDNS_DomainType DomainType ,
                              mDNSInterfaceID InterfaceID , char *domname ) ;
#line 1278
mDNSBool SameDomainLabel(mDNSu8 const   *a , mDNSu8 const   *b ) ;
#line 1279
mDNSBool SameDomainName(domainname const   *d1 , domainname const   *d2 ) ;
#line 1283
mDNSu16 DomainNameLength(domainname const   *name ) ;
#line 1290
mDNSu8 *AppendLiteralLabelString(domainname *name , char const   *cstr ) ;
#line 1291
mDNSu8 *AppendDNSNameString(domainname *name , char const   *cstr ) ;
#line 1292
mDNSu8 *AppendDomainLabel(domainname *name , domainlabel const   *label ) ;
#line 1293
mDNSu8 *AppendDomainName(domainname *name , domainname const   *append ) ;
#line 1300
mDNSBool MakeDomainLabelFromLiteralString(domainlabel *label , char const   *cstr ) ;
#line 1301
mDNSu8 *MakeDomainNameFromDNSNameString(domainname *name , char const   *cstr ) ;
#line 1310
char *ConvertDomainLabelToCString_withescape(domainlabel const   *label , char *ptr ,
                                             char esc ) ;
#line 1313
char *ConvertDomainNameToCString_withescape(domainname const   *name , char *ptr ,
                                            char esc ) ;
#line 1317
void ConvertUTF8PstringToRFC1034HostLabel(mDNSu8 const   *UTF8Name , domainlabel *hostlabel ) ;
#line 1319
mDNSu8 *ConstructServiceName(domainname *fqdn , domainlabel const   *name , domainname const   *type ,
                             domainname const   *domain ) ;
#line 1320
mDNSBool DeconstructServiceName(domainname const   *fqdn , domainlabel *name , domainname *type ,
                                domainname *domain ) ;
#line 1338
mDNSu32 mDNS_vsnprintf(char *sbuffer , mDNSu32 buflen , char const   *fmt , va_list arg ) ;
#line 1339
mDNSu32 mDNS_snprintf(char *sbuffer , mDNSu32 buflen , char const   *fmt  , ...) ;
#line 1340
char *DNSTypeName(mDNSu16 rrtype ) ;
#line 1341
char *GetRRDisplayString_rdb(mDNS *m , ResourceRecord const   *rr , RDataBody *rd ) ;
#line 1343
mDNSBool mDNSSameAddress(mDNSAddr const   *ip1 , mDNSAddr const   *ip2 ) ;
#line 1344
void IncrementLabelSuffix(domainlabel *name , mDNSBool RichText ) ;
#line 1389
mStatus mDNSPlatformInit(mDNS *m ) ;
#line 1390
void mDNSPlatformClose(mDNS *m ) ;
#line 1391
mStatus mDNSPlatformSendUDP(mDNS const   *m , DNSMessage const   *msg , mDNSu8 const   *end ,
                            mDNSInterfaceID InterfaceID , mDNSIPPort srcPort , mDNSAddr const   *dst ,
                            mDNSIPPort dstPort ) ;
#line 1394
void mDNSPlatformLock(mDNS const   *m ) ;
#line 1395
void mDNSPlatformUnlock(mDNS const   *m ) ;
#line 1399
void mDNSPlatformMemCopy(void const   *src , void *dst , mDNSu32 len ) ;
#line 1400
mDNSBool mDNSPlatformMemSame(void const   *src , void const   *dst , mDNSu32 len ) ;
#line 1401
void mDNSPlatformMemZero(void *dst , mDNSu32 len ) ;
#line 1402
void *mDNSPlatformMemAllocate(mDNSu32 len ) ;
#line 1403
void mDNSPlatformMemFree(void *mem ) ;
#line 1404
mStatus mDNSPlatformTimeInit(mDNSs32 *timenow ) ;
#line 1431
void mDNS_GenerateFQDN(mDNS *m ) ;
#line 1432
mStatus mDNS_RegisterInterface(mDNS *m , NetworkInterfaceInfo *set ) ;
#line 1433
void mDNS_DeregisterInterface(mDNS *m , NetworkInterfaceInfo *set ) ;
#line 1434
void mDNSCoreInitComplete(mDNS *m , mStatus result ) ;
#line 1435
void mDNSCoreReceive(mDNS *m , DNSMessage *msg , mDNSu8 const   *end , mDNSAddr const   *srcaddr ,
                     mDNSIPPort srcport , mDNSAddr const   *dstaddr , mDNSIPPort dstport ,
                     mDNSInterfaceID InterfaceID , mDNSu8 ttl ) ;
#line 1438
void mDNSCoreMachineSleep(mDNS *m , mDNSBool sleepstate ) ;
#line 1084 "mDNS.c"
ResourceRecord const   zeroRR  ;
#line 1085 "mDNS.c"
union __anonunion_mDNSOpaque16_18  const  zeroIPPort  =    {{(mDNSu8 )0, (unsigned char)0}};
#line 1086 "mDNS.c"
union __anonunion_mDNSOpaque32_19  const  zeroIPAddr  =    {{(mDNSu8 )0, (unsigned char)0, (unsigned char)0, (unsigned char)0}};
#line 1087 "mDNS.c"
union __anonunion_mDNSOpaque128_20  const  zerov6Addr  =    {{(mDNSu8 )0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}};
#line 1088 "mDNS.c"
union __anonunion_mDNSOpaque32_19  const  onesIPv4Addr  =    {{(mDNSu8 )255, (mDNSu8 )255, (mDNSu8 )255, (mDNSu8 )255}};
#line 1089 "mDNS.c"
union __anonunion_mDNSOpaque128_20  const  onesIPv6Addr  =    {{(mDNSu8 )255, (mDNSu8 )255, (mDNSu8 )255, (mDNSu8 )255, (mDNSu8 )255, (mDNSu8 )255,
     (mDNSu8 )255, (mDNSu8 )255, (mDNSu8 )255, (mDNSu8 )255, (mDNSu8 )255, (mDNSu8 )255,
     (mDNSu8 )255, (mDNSu8 )255, (mDNSu8 )255, (mDNSu8 )255}};
#line 1090 "mDNS.c"
static struct __anonstruct_mDNSAddr_22  const  zeroAddr  =    {(mDNSs32 )0, {{{(mDNSu8 )0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}}}};
#line 1092 "mDNS.c"
struct mDNSInterfaceID_dummystruct * const  mDNSInterface_Any  =    (mDNSInterfaceID const   )0;
#line 1093 "mDNS.c"
static struct mDNSInterfaceID_dummystruct * const  mDNSInterfaceMark  =    (mDNSInterfaceID const   )((struct mDNSInterfaceID_dummystruct *)(~ 0));
#line 1097 "mDNS.c"
union __anonunion_mDNSOpaque16_18  const  UnicastDNSPort  =    {{(mDNSu8 )(53 >> 8), (mDNSu8 )53}};
#line 1098 "mDNS.c"
union __anonunion_mDNSOpaque16_18  const  MulticastDNSPort  =    {{(mDNSu8 )(5353 >> 8), (mDNSu8 )233}};
#line 1099 "mDNS.c"
union __anonunion_mDNSOpaque32_19  const  AllDNSAdminGroup  =    {{(mDNSu8 )239, (mDNSu8 )255, (mDNSu8 )255, (mDNSu8 )251}};
#line 1100 "mDNS.c"
union __anonunion_mDNSOpaque32_19  const  AllDNSLinkGroup  =    {{(mDNSu8 )224, (mDNSu8 )0, (mDNSu8 )0, (mDNSu8 )251}};
#line 1101 "mDNS.c"
union __anonunion_mDNSOpaque128_20  const  AllDNSLinkGroupv6  =    {{(mDNSu8 )255, (mDNSu8 )2, (mDNSu8 )0, (mDNSu8 )0, (mDNSu8 )0, (mDNSu8 )0, (mDNSu8 )0,
     (mDNSu8 )0, (mDNSu8 )0, (mDNSu8 )0, (mDNSu8 )0, (mDNSu8 )0, (mDNSu8 )0, (mDNSu8 )0,
     (mDNSu8 )0, (mDNSu8 )251}};
#line 1102 "mDNS.c"
struct __anonstruct_mDNSAddr_22  const  AllDNSLinkGroup_v4  =    {(mDNSs32 )4, {{{(mDNSu8 )224, (mDNSu8 )0, (mDNSu8 )0, (mDNSu8 )251, (unsigned char)0,
                    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                    (unsigned char)0, (unsigned char)0, (unsigned char)0}}}};
#line 1103 "mDNS.c"
struct __anonstruct_mDNSAddr_22  const  AllDNSLinkGroup_v6  =    {(mDNSs32 )6, {{{(mDNSu8 )255, (mDNSu8 )2, (mDNSu8 )0, (mDNSu8 )0, (mDNSu8 )0,
                    (mDNSu8 )0, (mDNSu8 )0, (mDNSu8 )0, (mDNSu8 )0, (mDNSu8 )0, (mDNSu8 )0,
                    (mDNSu8 )0, (mDNSu8 )0, (mDNSu8 )0, (mDNSu8 )0, (mDNSu8 )251}}}};
#line 1105 "mDNS.c"
static union __anonunion_mDNSOpaque16_18  const  zeroID  =    {{(mDNSu8 )0, (mDNSu8 )0}};
#line 1106 "mDNS.c"
static union __anonunion_mDNSOpaque16_18  const  QueryFlags  =    {{(mDNSu8 )0, (mDNSu8 )0}};
#line 1107 "mDNS.c"
static union __anonunion_mDNSOpaque16_18  const  ResponseFlags  =    {{(mDNSu8 )132, (mDNSu8 )0}};
#line 1118 "mDNS.c"
static char const   * const  mDNS_DomainTypeNames[4]  = {      (char const   * const  )"_browse._dns-sd._udp.local.",      (char const   * const  )"_default._browse._dns-sd._udp.local.",      (char const   * const  )"_register._dns-sd._udp.local.",      (char const   * const  )"_default._register._dns-sd._udp.local."};
#line 1134 "mDNS.c"
static struct mDNSprintf_format  const  mDNSprintf_format_default  ;
#line 1261 "mDNS.c"
static char emsg[9]  = 
#line 1261
  {      (char )'<',      (char )'<',      (char )'N',      (char )'U', 
        (char )'L',      (char )'L',      (char )'>',      (char )'>', 
        (char )'\000'};
#line 1320 "mDNS.c"
static char emsg___0[9]  = 
#line 1320
  {      (char )'<',      (char )'<',      (char )'N',      (char )'U', 
        (char )'L',      (char )'L',      (char )'>',      (char )'>', 
        (char )'\000'};
#line 1148 "mDNS.c"
mDNSu32 mDNS_vsnprintf(char *sbuffer , mDNSu32 buflen , char const   *fmt , va_list arg ) 
{ mDNSu32 nwritten ;
  int c ;
  char *tmp ;
  unsigned int i ;
  unsigned int j ;
  char mDNS_VACB[300] ;
  char *s ;
  char *digits ;
  struct mDNSprintf_format F ;
  int f ;
  int tmp___0 ;
  unsigned long n ;
  long tmp___1 ;
  int tmp___2 ;
  unsigned char *a ;
  unsigned char *tmp___3 ;
  unsigned short *w ;
  mDNSAddr *ip ;
  int tmp___4 ;
  char *a___0 ;
  char *tmp___5 ;
  char *tmp___6 ;
  unsigned char *a___1 ;
  char *tmp___7 ;
  mDNSu32 tmp___8 ;
  mDNSu32 tmp___9 ;
  mDNSu32 tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;

  {
#line 1150
  nwritten = (mDNSu32 )0;
#line 1152
  buflen --;
#line 1154
  c = (int )*fmt;
#line 1154
  while (c != 0) {
#line 1156
    if (c != 37) {
#line 1158
      tmp = sbuffer;
#line 1158
      sbuffer ++;
#line 1158
      *tmp = (char )c;
#line 1159
      nwritten ++;
#line 1159
      if (nwritten >= buflen) {
        goto exit;
      }
    } else {
#line 1163
      i = 0U;
#line 1171
      s = & mDNS_VACB[300];
#line 1172
      F = mDNSprintf_format_default;
#line 1174
      while (1) {
#line 1176
        fmt ++;
#line 1176
        c = (int )*fmt;
#line 1177
        if (c == 45) {
#line 1177
          F.leftJustify = 1U;
        } else {
#line 1178
          if (c == 43) {
#line 1178
            F.forceSign = 1U;
          } else {
#line 1179
            if (c == 32) {
#line 1179
              F.sign = (char )' ';
            } else {
#line 1180
              if (c == 35) {
#line 1180
                F.altForm = (char )((int )F.altForm + 1);
              } else {
#line 1181
                if (c == 48) {
#line 1181
                  F.zeroPad = 1U;
                } else {
#line 1182
                  break;
                }
              }
            }
          }
        }
      }
#line 1185
      if (c == 42) {
#line 1187
        tmp___0 = __builtin_va_arg(arg, int );
#line 1187
        f = tmp___0;
#line 1188
        if (f < 0) {
#line 1188
          f = - f;
#line 1188
          F.leftJustify = 1U;
        }
#line 1189
        F.fieldWidth = (unsigned int )f;
#line 1190
        fmt ++;
#line 1190
        c = (int )*fmt;
      } else {
#line 1194
        while (1) {
#line 1194
          if (c >= 48) {
#line 1194
            if (! (c <= 57)) {
#line 1194
              break;
            }
          } else {
#line 1194
            break;
          }
#line 1195
          F.fieldWidth = 10U * F.fieldWidth + (unsigned int )(c - 48);
#line 1194
          fmt ++;
#line 1194
          c = (int )*fmt;
        }
      }
#line 1198
      if (c == 46) {
#line 1200
        fmt ++;
#line 1200
        c = (int )*fmt;
#line 1200
        if (c == 42) {
#line 1201
          F.precision = __builtin_va_arg(arg, unsigned int );
#line 1201
          fmt ++;
#line 1201
          c = (int )*fmt;
        } else {
#line 1202
          while (1) {
#line 1202
            if (c >= 48) {
#line 1202
              if (! (c <= 57)) {
#line 1202
                break;
              }
            } else {
#line 1202
              break;
            }
#line 1203
            F.precision = 10U * F.precision + (unsigned int )(c - 48);
#line 1202
            fmt ++;
#line 1202
            c = (int )*fmt;
          }
        }
#line 1204
        F.havePrecision = 1U;
      }
#line 1207
      if (F.leftJustify) {
#line 1207
        F.zeroPad = 0U;
      }
      conv: 
#line 1210
      switch (c) {
      case 104: 
#line 1213
      F.hSize = 1U;
#line 1213
      fmt ++;
#line 1213
      c = (int )*fmt;
      goto conv;
      case 108: 
      case 76: 
#line 1215
      F.lSize = 1U;
#line 1215
      fmt ++;
#line 1215
      c = (int )*fmt;
      goto conv;
      case 100: 
      case 105: 
#line 1217
      if (F.lSize) {
#line 1217
        tmp___1 = __builtin_va_arg(arg, long );
#line 1217
        n = (unsigned long )tmp___1;
      } else {
#line 1218
        tmp___2 = __builtin_va_arg(arg, int );
#line 1218
        n = (unsigned long )tmp___2;
      }
#line 1219
      if (F.hSize) {
#line 1219
        n = (unsigned long )((short )n);
      }
#line 1220
      if ((long )n < 0L) {
#line 1220
        n = (unsigned long )(- ((long )n));
#line 1220
        F.sign = (char )'-';
      } else {
#line 1221
        if (F.forceSign) {
#line 1221
          F.sign = (char )'+';
        }
      }
      goto decimal;
      case 117: 
#line 1223
      if (F.lSize) {
#line 1223
        n = __builtin_va_arg(arg, unsigned long );
      } else {
#line 1224
        n = __builtin_va_arg(arg, unsigned int );
      }
#line 1225
      if (F.hSize) {
#line 1225
        n = (unsigned long )((unsigned short )n);
      }
#line 1226
      F.sign = (char)0;
      goto decimal;
      decimal: 
#line 1228
      if (! F.havePrecision) {
#line 1230
        if (F.zeroPad) {
#line 1232
          F.precision = F.fieldWidth;
#line 1233
          if (F.sign) {
#line 1233
            (F.precision) --;
          }
        }
#line 1235
        if (F.precision < 1U) {
#line 1235
          F.precision = 1U;
        }
      }
#line 1237
      if (F.precision > 299U) {
#line 1238
        F.precision = 299U;
      }
#line 1239
      i = 0U;
#line 1239
      while (n) {
#line 1239
        s --;
#line 1239
        *s = (char )(n % 10UL + 48UL);
#line 1239
        n /= 10UL;
#line 1239
        i ++;
      }
#line 1240
      while (i < F.precision) {
#line 1240
        s --;
#line 1240
        *s = (char )'0';
#line 1240
        i ++;
      }
#line 1241
      if (F.sign) {
#line 1241
        s --;
#line 1241
        *s = F.sign;
#line 1241
        i ++;
      }
#line 1242
      break;
      case 111: 
#line 1244
      if (F.lSize) {
#line 1244
        n = __builtin_va_arg(arg, unsigned long );
      } else {
#line 1245
        n = __builtin_va_arg(arg, unsigned int );
      }
#line 1246
      if (F.hSize) {
#line 1246
        n = (unsigned long )((unsigned short )n);
      }
#line 1247
      if (! F.havePrecision) {
#line 1249
        if (F.zeroPad) {
#line 1249
          F.precision = F.fieldWidth;
        }
#line 1250
        if (F.precision < 1U) {
#line 1250
          F.precision = 1U;
        }
      }
#line 1252
      if (F.precision > 299U) {
#line 1253
        F.precision = 299U;
      }
#line 1254
      i = 0U;
#line 1254
      while (n) {
#line 1254
        s --;
#line 1254
        *s = (char )(n % 8UL + 48UL);
#line 1254
        n /= 8UL;
#line 1254
        i ++;
      }
#line 1255
      if (F.altForm) {
#line 1255
        if (i) {
#line 1255
          if ((int )*s != 48) {
#line 1255
            s --;
#line 1255
            *s = (char )'0';
#line 1255
            i ++;
          }
        }
      }
#line 1256
      while (i < F.precision) {
#line 1256
        s --;
#line 1256
        *s = (char )'0';
#line 1256
        i ++;
      }
#line 1257
      break;
      case 97: 
#line 1260
      tmp___3 = __builtin_va_arg(arg, unsigned char *);
#line 1260
      a = tmp___3;
#line 1261
      if (! a) {
#line 1261
        s = emsg;
#line 1261
        i = sizeof(emsg) - 1U;
      } else {
#line 1264
        w = (unsigned short *)a;
#line 1265
        s = mDNS_VACB;
#line 1266
        if (F.altForm) {
#line 1268
          ip = (mDNSAddr *)a;
#line 1269
          a = (unsigned char *)(& ip->ip.v4);
#line 1270
          w = (unsigned short *)(& ip->ip.v6);
#line 1271
          switch (ip->type) {
          case 4: 
#line 1273
          F.precision = 4U;
#line 1273
          break;
          case 6: 
#line 1274
          F.precision = 16U;
#line 1274
          break;
          default: 
#line 1275
          F.precision = 0U;
#line 1275
          break;
          }
        }
#line 1278
        switch ((int )F.precision) {
        case 4: 
#line 1280
        i = mDNS_snprintf(mDNS_VACB, sizeof(mDNS_VACB), "%d.%d.%d.%d", *(a + 0), *(a + 1),
                          *(a + 2), *(a + 3));
#line 1281
        break;
        case 6: 
#line 1282
        i = mDNS_snprintf(mDNS_VACB, sizeof(mDNS_VACB), "%02X:%02X:%02X:%02X:%02X:%02X",
                          *(a + 0), *(a + 1), *(a + 2), *(a + 3), *(a + 4), *(a + 5));
#line 1283
        break;
        case 16: 
#line 1284
        i = mDNS_snprintf(mDNS_VACB, sizeof(mDNS_VACB), "%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X",
                          *(w + 0), *(w + 1), *(w + 2), *(w + 3), *(w + 4), *(w + 5),
                          *(w + 6), *(w + 7));
#line 1285
        break;
        default: 
#line 1286
        i = mDNS_snprintf(mDNS_VACB, sizeof(mDNS_VACB), "%s", "<< ERROR: Must specify address size (i.e. %.4a=IPv4, %.6a=Ethernet, %.16a=IPv6) >>");
#line 1287
        break;
        }
      }
#line 1291
      break;
      case 112: 
#line 1293
      F.lSize = 1U;
#line 1293
      F.havePrecision = F.lSize;
#line 1294
      F.precision = 8U;
      case 88: 
#line 1295
      digits = (char *)"0123456789ABCDEF";
      goto hexadecimal;
      case 120: 
#line 1297
      digits = (char *)"0123456789abcdef";
      hexadecimal: 
#line 1298
      if (F.lSize) {
#line 1298
        n = __builtin_va_arg(arg, unsigned long );
      } else {
#line 1299
        n = __builtin_va_arg(arg, unsigned int );
      }
#line 1300
      if (F.hSize) {
#line 1300
        n = (unsigned long )((unsigned short )n);
      }
#line 1301
      if (! F.havePrecision) {
#line 1303
        if (F.zeroPad) {
#line 1305
          F.precision = F.fieldWidth;
#line 1306
          if (F.altForm) {
#line 1306
            F.precision -= 2U;
          }
        }
#line 1308
        if (F.precision < 1U) {
#line 1308
          F.precision = 1U;
        }
      }
#line 1310
      if (F.precision > 299U) {
#line 1311
        F.precision = 299U;
      }
#line 1312
      i = 0U;
#line 1312
      while (n) {
#line 1312
        s --;
#line 1312
        *s = *(digits + n % 16UL);
#line 1312
        n /= 16UL;
#line 1312
        i ++;
      }
#line 1313
      while (i < F.precision) {
#line 1313
        s --;
#line 1313
        *s = (char )'0';
#line 1313
        i ++;
      }
#line 1314
      if (F.altForm) {
#line 1314
        s --;
#line 1314
        *s = (char )c;
#line 1314
        s --;
#line 1314
        *s = (char )'0';
#line 1314
        i += 2U;
      }
#line 1315
      break;
      case 99: 
#line 1317
      s --;
#line 1317
      tmp___4 = __builtin_va_arg(arg, int );
#line 1317
      *s = (char )tmp___4;
#line 1317
      i = 1U;
#line 1317
      break;
      case 115: 
#line 1319
      s = __builtin_va_arg(arg, char *);
#line 1320
      if (! s) {
#line 1320
        s = emsg___0;
#line 1320
        i = sizeof(emsg___0) - 1U;
      } else {
#line 1321
        switch ((int )F.altForm) {
        case 0: 
#line 1323
        a___0 = s;
#line 1323
        i = 0U;
#line 1323
        while (1) {
#line 1323
          tmp___5 = a___0;
#line 1323
          a___0 ++;
#line 1323
          if (! *tmp___5) {
#line 1323
            break;
          }
#line 1323
          i ++;
        }
#line 1323
        break;
        case 1: 
#line 1324
        tmp___6 = s;
#line 1324
        s ++;
#line 1324
        i = (unsigned int )((unsigned char )*tmp___6);
#line 1324
        break;
        case 2: 
#line 1326
        a___1 = (unsigned char *)s;
#line 1327
        s = mDNS_VACB;
#line 1328
        if ((int )*a___1 == 0) {
#line 1328
          tmp___7 = s;
#line 1328
          s ++;
#line 1328
          *tmp___7 = (char )'.';
        }
#line 1329
        while (*a___1) {
#line 1331
          if ((int )*a___1 > 63) {
#line 1331
            tmp___8 = mDNS_snprintf(s, (unsigned int )(& mDNS_VACB[300] - s), "<<INVALID LABEL LENGTH %u>>",
                                    *a___1);
#line 1331
            s += tmp___8;
#line 1331
            break;
          }
#line 1332
          if ((unsigned int )(s + (int )*a___1) >= (unsigned int )(& mDNS_VACB[254])) {
#line 1332
            tmp___9 = mDNS_snprintf(s, (unsigned int )(& mDNS_VACB[300] - s), "<<NAME TOO LONG>>");
#line 1332
            s += tmp___9;
#line 1332
            break;
          }
#line 1333
          tmp___10 = mDNS_snprintf(s, (unsigned int )(& mDNS_VACB[300] - s), "%#s.",
                                   a___1);
#line 1333
          s += tmp___10;
#line 1334
          a___1 += 1 + (int )*a___1;
        }
#line 1336
        i = (unsigned int )(s - mDNS_VACB);
#line 1337
        s = mDNS_VACB;
#line 1338
        break;
        }
      }
#line 1341
      if (F.havePrecision) {
#line 1341
        if (i > F.precision) {
#line 1342
          i = F.precision;
#line 1342
          while (1) {
#line 1342
            if (i > 0U) {
#line 1342
              if (! (((int )*(s + i) & 192) == 128)) {
#line 1342
                break;
              }
            } else {
#line 1342
              break;
            }
#line 1342
            i --;
          }
        }
      }
#line 1343
      break;
      case 110: 
#line 1345
      s = __builtin_va_arg(arg, char *);
#line 1346
      if (F.hSize) {
#line 1346
        *((short *)s) = (short )nwritten;
      } else {
#line 1347
        if (F.lSize) {
#line 1347
          *((long *)s) = (long )nwritten;
        } else {
#line 1348
          *((int *)s) = (int )nwritten;
        }
      }
      goto __Cont;
      default: 
#line 1351
      s = mDNS_VACB;
#line 1352
      i = mDNS_snprintf(mDNS_VACB, sizeof(mDNS_VACB), "<<UNKNOWN FORMAT CONVERSION CODE %%%c>>",
                        c);
      case 37: 
#line 1354
      tmp___11 = sbuffer;
#line 1354
      sbuffer ++;
#line 1354
      *tmp___11 = (char )c;
#line 1355
      nwritten ++;
#line 1355
      if (nwritten >= buflen) {
        goto exit;
      }
#line 1356
      break;
      }
#line 1359
      if (i < F.fieldWidth) {
#line 1359
        if (! F.leftJustify) {
#line 1360
          while (1) {
#line 1361
            tmp___12 = sbuffer;
#line 1361
            sbuffer ++;
#line 1361
            *tmp___12 = (char )' ';
#line 1362
            nwritten ++;
#line 1362
            if (nwritten >= buflen) {
              goto exit;
            }
#line 1360
            (F.fieldWidth) --;
#line 1360
            if (! (i < F.fieldWidth)) {
#line 1360
              break;
            }
          }
        }
      }
#line 1365
      if (i > buflen - nwritten) {
#line 1366
        i = buflen - nwritten;
#line 1366
        while (1) {
#line 1366
          if (i > 0U) {
#line 1366
            if (! (((int )*(s + i) & 192) == 128)) {
#line 1366
              break;
            }
          } else {
#line 1366
            break;
          }
#line 1366
          i --;
        }
      }
#line 1367
      j = 0U;
#line 1367
      while (j < i) {
#line 1367
        tmp___13 = sbuffer;
#line 1367
        sbuffer ++;
#line 1367
        tmp___14 = s;
#line 1367
        s ++;
#line 1367
        *tmp___13 = *tmp___14;
#line 1367
        j ++;
      }
#line 1368
      nwritten += i;
#line 1369
      if (nwritten >= buflen) {
        goto exit;
      }
#line 1371
      while (i < F.fieldWidth) {
#line 1373
        tmp___15 = sbuffer;
#line 1373
        sbuffer ++;
#line 1373
        *tmp___15 = (char )' ';
#line 1374
        nwritten ++;
#line 1374
        if (nwritten >= buflen) {
          goto exit;
        }
#line 1371
        i ++;
      }
    }
    __Cont: /* CIL Label */ 
#line 1154
    fmt ++;
#line 1154
    c = (int )*fmt;
  }
  exit: 
#line 1379
  tmp___16 = sbuffer;
#line 1379
  sbuffer ++;
#line 1379
  *tmp___16 = (char)0;
#line 1380
  return (nwritten);
}
}
#line 1383 "mDNS.c"
mDNSu32 mDNS_snprintf(char *sbuffer , mDNSu32 buflen , char const   *fmt  , ...) 
{ mDNSu32 length ;
  va_list ptr ;

  {
#line 1388
  __builtin_va_start(ptr, fmt);
#line 1389
  length = mDNS_vsnprintf(sbuffer, buflen, fmt, ptr);
#line 1390
  __builtin_va_end(ptr);
#line 1392
  return (length);
}
}
#line 1415 "mDNS.c"
static char buffer[16]  ;
#line 1401 "mDNS.c"
char *DNSTypeName(mDNSu16 rrtype ) 
{ 

  {
#line 1403
  switch ((int )rrtype) {
  case 1: 
#line 1405
  return ((char *)"Addr");
  case 5: 
#line 1406
  return ((char *)"CNAME");
  case 10: 
#line 1407
  return ((char *)"NULL");
  case 12: 
#line 1408
  return ((char *)"PTR");
  case 13: 
#line 1409
  return ((char *)"HINFO");
  case 16: 
#line 1410
  return ((char *)"TXT");
  case 28: 
#line 1411
  return ((char *)"AAAA");
  case 33: 
#line 1412
  return ((char *)"SRV");
  case 255: 
#line 1413
  return ((char *)"ANY");
  default: 
#line 1416
  mDNS_snprintf(buffer, sizeof(buffer), "(%d)", rrtype);
#line 1417
  return (buffer);
  }
}
}
#line 1422 "mDNS.c"
char *GetRRDisplayString_rdb(mDNS *m , ResourceRecord const   *rr , RDataBody *rd ) 
{ char *ptr ;
  mDNSu32 length ;
  char *tmp ;
  mDNSu32 tmp___0 ;

  {
#line 1424
  ptr = m->MsgBuffer;
#line 1425
  tmp = DNSTypeName((unsigned short )rr->rrtype);
#line 1425
  tmp___0 = mDNS_snprintf(m->MsgBuffer, 79U, "%4d %##s %s ", rr->rdlength, rr->name.c,
                          tmp);
#line 1425
  length = tmp___0;
#line 1426
  switch ((int )rr->rrtype) {
  case 1: 
#line 1428
  mDNS_snprintf(m->MsgBuffer + length, 79U - length, "%.4a", & rd->ip);
#line 1428
  break;
  case 5: 
  case 12: 
#line 1430
  mDNS_snprintf(m->MsgBuffer + length, 79U - length, "%##s", & rd->name);
#line 1430
  break;
  case 13: 
  case 16: 
#line 1432
  mDNS_snprintf(m->MsgBuffer + length, 79U - length, "%#s", rd->txt.c);
#line 1432
  break;
  case 28: 
#line 1433
  mDNS_snprintf(m->MsgBuffer + length, 79U - length, "%.16a", & rd->ipv6);
#line 1433
  break;
  case 33: 
#line 1434
  mDNS_snprintf(m->MsgBuffer + length, 79U - length, "%##s", & rd->srv.target);
#line 1434
  break;
  default: 
#line 1435
  mDNS_snprintf(m->MsgBuffer + length, 79U - length, "RDLen %d: %s", rr->rdlength,
                rd->data);
#line 1436
  break;
  }
#line 1438
  ptr = m->MsgBuffer;
#line 1438
  while (*ptr) {
#line 1438
    if ((int )*ptr < 32) {
#line 1438
      *ptr = (char )'.';
    }
#line 1438
    ptr ++;
  }
#line 1439
  return (m->MsgBuffer);
}
}
#line 1444
static mDNSu32 mDNSRandom(mDNSu32 max ) ;
#line 1444 "mDNS.c"
static mDNSu32 seed  =    (mDNSu32 )0;
#line 1442 "mDNS.c"
static mDNSu32 mDNSRandom(mDNSu32 max ) 
{ mDNSu32 mask ;
  mDNSs32 tmp ;

  {
#line 1445
  mask = (mDNSu32 )1;
#line 1447
  if (! seed) {
#line 1447
    tmp = mDNSPlatformTimeNow();
#line 1447
    seed = (unsigned int )tmp;
  }
#line 1448
  while (mask < max) {
#line 1448
    mask = (mask << 1) | 1U;
  }
#line 1449
  while (1) {
#line 1449
    seed = seed * 21U + 1U;
#line 1449
    if (! ((seed & mask) > max)) {
#line 1449
      break;
    }
  }
#line 1450
  return (seed & mask);
}
}
#line 1474 "mDNS.c"
mDNSBool mDNSSameAddress(mDNSAddr const   *ip1 , mDNSAddr const   *ip2 ) 
{ int tmp ;

  {
#line 1476
  if (ip1->type == ip2->type) {
#line 1478
    switch ((int )ip1->type) {
    case 4: 
#line 1480
    return (ip1->ip.v4.NotAnInteger == ip2->ip.v4.NotAnInteger);
    case 6: 
#line 1481
    if (ip1->ip.v6.l[0] == ip2->ip.v6.l[0]) {
#line 1481
      if (ip1->ip.v6.l[1] == ip2->ip.v6.l[1]) {
#line 1481
        if (ip1->ip.v6.l[2] == ip2->ip.v6.l[2]) {
#line 1481
          if (ip1->ip.v6.l[3] == ip2->ip.v6.l[3]) {
#line 1481
            tmp = 1;
          } else {
#line 1481
            tmp = 0;
          }
        } else {
#line 1481
          tmp = 0;
        }
      } else {
#line 1481
        tmp = 0;
      }
    } else {
#line 1481
      tmp = 0;
    }
#line 1481
    return (tmp);
    }
  }
#line 1484
  return (0);
}
}
#line 1487 "mDNS.c"
static mDNSBool mDNSAddrIsDNSMulticast(mDNSAddr const   *ip ) 
{ int tmp ;

  {
#line 1489
  switch ((int )ip->type) {
  case 4: 
#line 1491
  return (ip->ip.v4.NotAnInteger == AllDNSLinkGroup.NotAnInteger);
  case 6: 
#line 1492
  if (ip->ip.v6.l[0] == AllDNSLinkGroupv6.l[0]) {
#line 1492
    if (ip->ip.v6.l[1] == AllDNSLinkGroupv6.l[1]) {
#line 1492
      if (ip->ip.v6.l[2] == AllDNSLinkGroupv6.l[2]) {
#line 1492
        if (ip->ip.v6.l[3] == AllDNSLinkGroupv6.l[3]) {
#line 1492
          tmp = 1;
        } else {
#line 1492
          tmp = 0;
        }
      } else {
#line 1492
        tmp = 0;
      }
    } else {
#line 1492
      tmp = 0;
    }
  } else {
#line 1492
    tmp = 0;
  }
#line 1492
  return (tmp);
  default: ;
#line 1496
  return (0);
  }
}
}
#line 1500 "mDNS.c"
static NetworkInterfaceInfo const   *GetFirstActiveInterface(NetworkInterfaceInfo const   *intf ) 
{ 

  {
#line 1502
  while (1) {
#line 1502
    if (intf) {
#line 1502
      if (! (! intf->InterfaceActive)) {
#line 1502
        break;
      }
    } else {
#line 1502
      break;
    }
#line 1502
    intf = (NetworkInterfaceInfo const   *)intf->next;
  }
#line 1503
  return (intf);
}
}
#line 1506 "mDNS.c"
static mDNSInterfaceID GetNextActiveInterfaceID(NetworkInterfaceInfo const   *intf ) 
{ NetworkInterfaceInfo const   *next ;
  NetworkInterfaceInfo const   *tmp ;

  {
#line 1508
  tmp = GetFirstActiveInterface((NetworkInterfaceInfo const   *)intf->next);
#line 1508
  next = tmp;
#line 1509
  if (next) {
#line 1509
    return ((struct mDNSInterfaceID_dummystruct *)next->InterfaceID);
  } else {
#line 1509
    return ((struct mDNSInterfaceID_dummystruct *)0L);
  }
}
}
#line 1516 "mDNS.c"
static void SetNextQueryTime(mDNS *m , DNSQuestion const   *q ) 
{ 

  {
#line 1518
  if (q->ThisQInterval > 0) {
#line 1518
    if (! q->DuplicateOf) {
#line 1519
      if (m->NextScheduledQuery - (mDNSs32 )(q->LastQTime + q->ThisQInterval) > 0) {
#line 1520
        m->NextScheduledQuery = (int )(q->LastQTime + q->ThisQInterval);
      }
    }
  }
#line 1521
  return;
}
}
#line 1534 "mDNS.c"
mDNSBool SameDomainLabel(mDNSu8 const   *a , mDNSu8 const   *b ) 
{ int i ;
  int len ;
  mDNSu8 const   *tmp ;
  mDNSu8 const   *tmp___0 ;
  mDNSu8 ac ;
  mDNSu8 const   *tmp___1 ;
  mDNSu8 bc ;
  mDNSu8 const   *tmp___2 ;

  {
#line 1537
  tmp = a;
#line 1537
  a ++;
#line 1537
  len = (int )*tmp;
#line 1539
  if (len > 63) {
#line 1540
    return (0);
  }
#line 1542
  tmp___0 = b;
#line 1542
  b ++;
#line 1542
  if (len != (int )*tmp___0) {
#line 1542
    return (0);
  }
#line 1543
  i = 0;
#line 1543
  while (i < len) {
#line 1545
    tmp___1 = a;
#line 1545
    a ++;
#line 1545
    ac = (mDNSu8 )*tmp___1;
#line 1546
    tmp___2 = b;
#line 1546
    b ++;
#line 1546
    bc = (mDNSu8 )*tmp___2;
#line 1547
    if ((int )ac >= 65) {
#line 1547
      if ((int )ac <= 90) {
#line 1547
        ac = (unsigned char )((int )ac + 32);
      }
    }
#line 1548
    if ((int )bc >= 65) {
#line 1548
      if ((int )bc <= 90) {
#line 1548
        bc = (unsigned char )((int )bc + 32);
      }
    }
#line 1549
    if ((int )ac != (int )bc) {
#line 1549
      return (0);
    }
#line 1543
    i ++;
  }
#line 1551
  return (1);
}
}
#line 1554 "mDNS.c"
mDNSBool SameDomainName(domainname const   *d1 , domainname const   *d2 ) 
{ mDNSu8 const   *a ;
  mDNSu8 const   *b ;
  mDNSu8 const   *max ;
  mDNSBool tmp ;

  {
#line 1556
  a = (mDNSu8 const   *)(d1->c);
#line 1557
  b = (mDNSu8 const   *)(d2->c);
#line 1558
  max = (mDNSu8 const   *)(d1->c + 255);
#line 1560
  while (1) {
#line 1560
    if (! *a) {
#line 1560
      if (! *b) {
#line 1560
        break;
      }
    }
#line 1562
    if ((unsigned int )((a + 1) + (int const   )*a) >= (unsigned int )max) {
#line 1563
      return (0);
    }
#line 1564
    tmp = SameDomainLabel(a, b);
#line 1564
    if (! tmp) {
#line 1564
      return (0);
    }
#line 1565
    a += 1 + (int )*a;
#line 1566
    b += 1 + (int )*b;
  }
#line 1569
  return (1);
}
}
#line 1577 "mDNS.c"
mDNSu16 DomainNameLength(domainname const   *name ) 
{ mDNSu8 const   *src ;

  {
#line 1579
  src = (mDNSu8 const   *)(name->c);
#line 1580
  while (*src) {
#line 1582
    if ((int const   )*src > 63) {
#line 1582
      return ((unsigned short)256);
    }
#line 1583
    src += 1 + (int )*src;
#line 1584
    if (src - (mDNSu8 const   *)(name->c) >= 255) {
#line 1584
      return ((unsigned short)256);
    }
  }
#line 1586
  return ((unsigned short )((src - (mDNSu8 const   *)(name->c)) + 1));
}
}
#line 1598 "mDNS.c"
static mDNSu16 CompressedDomainNameLength(domainname const   *name , domainname const   *parent ) 
{ mDNSu8 const   *src ;
  mDNSBool tmp ;

  {
#line 1600
  src = (mDNSu8 const   *)(name->c);
#line 1601
  if (parent) {
#line 1601
    if ((int )parent->c[0] == 0) {
#line 1601
      parent = (domainname const   *)0L;
    }
  }
#line 1602
  while (*src) {
#line 1604
    if ((int const   )*src > 63) {
#line 1604
      return ((unsigned short)256);
    }
#line 1605
    if (parent) {
#line 1605
      tmp = SameDomainName((domainname const   *)((domainname *)src), parent);
#line 1605
      if (tmp) {
#line 1605
        return ((unsigned short )((src - (mDNSu8 const   *)(name->c)) + 2));
      }
    }
#line 1606
    src += 1 + (int )*src;
#line 1607
    if (src - (mDNSu8 const   *)(name->c) >= 255) {
#line 1607
      return ((unsigned short)256);
    }
  }
#line 1609
  return ((unsigned short )((src - (mDNSu8 const   *)(name->c)) + 1));
}
}
#line 1619 "mDNS.c"
mDNSu8 *AppendLiteralLabelString(domainname *name , char const   *cstr ) 
{ mDNSu8 *ptr ;
  mDNSu16 tmp ;
  mDNSu8 const   *lim1 ;
  mDNSu8 const   *lim2 ;
  mDNSu8 const   *lim ;
  mDNSu8 const   *tmp___0 ;
  mDNSu8 *lengthbyte ;
  mDNSu8 *tmp___1 ;
  mDNSu8 *tmp___2 ;
  char const   *tmp___3 ;
  mDNSu8 *tmp___4 ;

  {
#line 1621
  tmp = DomainNameLength((domainname const   *)name);
#line 1621
  ptr = (name->c + (int )tmp) - 1;
#line 1622
  lim1 = (mDNSu8 const   *)((name->c + 255) - 1);
#line 1623
  lim2 = (mDNSu8 const   *)((ptr + 1) + 63);
#line 1624
  if ((unsigned int )lim1 < (unsigned int )lim2) {
#line 1624
    tmp___0 = lim1;
  } else {
#line 1624
    tmp___0 = lim2;
  }
#line 1624
  lim = tmp___0;
#line 1625
  tmp___1 = ptr;
#line 1625
  ptr ++;
#line 1625
  lengthbyte = tmp___1;
#line 1627
  while (1) {
#line 1627
    if (*cstr) {
#line 1627
      if (! ((unsigned int )ptr < (unsigned int )lim)) {
#line 1627
        break;
      }
    } else {
#line 1627
      break;
    }
#line 1627
    tmp___2 = ptr;
#line 1627
    ptr ++;
#line 1627
    tmp___3 = cstr;
#line 1627
    cstr ++;
#line 1627
    *tmp___2 = (unsigned char )*tmp___3;
  }
#line 1628
  *lengthbyte = (unsigned char )((ptr - lengthbyte) - 1);
#line 1629
  tmp___4 = ptr;
#line 1629
  ptr ++;
#line 1629
  *tmp___4 = (unsigned char)0;
#line 1630
  if (*cstr) {
#line 1630
    return ((mDNSu8 *)0L);
  } else {
#line 1631
    return (ptr);
  }
}
}
#line 1641 "mDNS.c"
mDNSu8 *AppendDNSNameString(domainname *name , char const   *cstr ) 
{ mDNSu8 *ptr ;
  mDNSu16 tmp ;
  mDNSu8 const   *lim ;
  mDNSu8 *lengthbyte ;
  mDNSu8 *tmp___0 ;
  mDNSu8 c ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int v0 ;
  int v1 ;
  int v2 ;
  int val ;
  mDNSu8 *tmp___3 ;
  mDNSu8 *tmp___4 ;

  {
#line 1643
  tmp = DomainNameLength((domainname const   *)name);
#line 1643
  ptr = (name->c + (int )tmp) - 1;
#line 1644
  lim = (mDNSu8 const   *)((name->c + 255) - 1);
#line 1645
  while (1) {
#line 1645
    if (*cstr) {
#line 1645
      if (! ((unsigned int )ptr < (unsigned int )lim)) {
#line 1645
        break;
      }
    } else {
#line 1645
      break;
    }
#line 1647
    tmp___0 = ptr;
#line 1647
    ptr ++;
#line 1647
    lengthbyte = tmp___0;
#line 1648
    while (1) {
#line 1648
      if (*cstr) {
#line 1648
        if ((int const   )*cstr != 46) {
#line 1648
          if (! ((unsigned int )ptr < (unsigned int )lim)) {
#line 1648
            break;
          }
        } else {
#line 1648
          break;
        }
      } else {
#line 1648
        break;
      }
#line 1650
      tmp___1 = cstr;
#line 1650
      cstr ++;
#line 1650
      c = (unsigned char )*tmp___1;
#line 1651
      if ((int )c == 92) {
#line 1653
        if ((int const   )*cstr == 92) {
#line 1654
          tmp___2 = cstr;
#line 1654
          cstr ++;
#line 1654
          c = (unsigned char )*tmp___2;
        } else {
#line 1653
          if ((int const   )*cstr == 46) {
#line 1654
            tmp___2 = cstr;
#line 1654
            cstr ++;
#line 1654
            c = (unsigned char )*tmp___2;
          } else {
#line 1655
            if ((int const   )*(cstr + 0) >= 48) {
#line 1655
              if ((int const   )*(cstr + 0) <= 57) {
#line 1655
                if ((int const   )*(cstr + 1) >= 48) {
#line 1655
                  if ((int const   )*(cstr + 1) <= 57) {
#line 1655
                    if ((int const   )*(cstr + 2) >= 48) {
#line 1655
                      if ((int const   )*(cstr + 2) <= 57) {
#line 1657
                        v0 = (int )((int const   )*(cstr + 0) - 48);
#line 1658
                        v1 = (int )((int const   )*(cstr + 1) - 48);
#line 1659
                        v2 = (int )((int const   )*(cstr + 2) - 48);
#line 1660
                        val = (v0 * 100 + v1 * 10) + v2;
#line 1661
                        if (val <= 255) {
#line 1661
                          c = (unsigned char )val;
#line 1661
                          cstr += 3;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 1664
      tmp___3 = ptr;
#line 1664
      ptr ++;
#line 1664
      *tmp___3 = c;
    }
#line 1666
    if (*cstr) {
#line 1666
      cstr ++;
    }
#line 1667
    if ((ptr - lengthbyte) - 1 > 63) {
#line 1668
      return ((mDNSu8 *)0L);
    }
#line 1669
    *lengthbyte = (unsigned char )((ptr - lengthbyte) - 1);
  }
#line 1672
  tmp___4 = ptr;
#line 1672
  ptr ++;
#line 1672
  *tmp___4 = (unsigned char)0;
#line 1673
  if (*cstr) {
#line 1673
    return ((mDNSu8 *)0L);
  } else {
#line 1674
    return (ptr);
  }
}
}
#line 1682 "mDNS.c"
mDNSu8 *AppendDomainLabel(domainname *name , domainlabel const   *label ) 
{ int i ;
  mDNSu8 *ptr ;
  mDNSu16 tmp ;
  mDNSu8 *tmp___0 ;
  mDNSu8 *tmp___1 ;

  {
#line 1685
  tmp = DomainNameLength((domainname const   *)name);
#line 1685
  ptr = (name->c + (int )tmp) - 1;
#line 1688
  if ((int )label->c[0] > 63) {
#line 1688
    return ((mDNSu8 *)0L);
  }
#line 1691
  if ((unsigned int )(((ptr + 1) + (int )label->c[0]) + 1) > (unsigned int )(name->c + 255)) {
#line 1691
    return ((mDNSu8 *)0L);
  }
#line 1693
  i = 0;
#line 1693
  while (i <= (int )label->c[0]) {
#line 1693
    tmp___0 = ptr;
#line 1693
    ptr ++;
#line 1693
    *tmp___0 = label->c[i];
#line 1693
    i ++;
  }
#line 1694
  tmp___1 = ptr;
#line 1694
  ptr ++;
#line 1694
  *tmp___1 = (unsigned char)0;
#line 1695
  return (ptr);
}
}
#line 1698 "mDNS.c"
mDNSu8 *AppendDomainName(domainname *name , domainname const   *append ) 
{ mDNSu8 *ptr ;
  mDNSu16 tmp ;
  mDNSu8 const   *lim ;
  mDNSu8 const   *src ;
  int i ;
  mDNSu8 *tmp___0 ;

  {
#line 1700
  tmp = DomainNameLength((domainname const   *)name);
#line 1700
  ptr = (name->c + (int )tmp) - 1;
#line 1701
  lim = (mDNSu8 const   *)((name->c + 255) - 1);
#line 1702
  src = (mDNSu8 const   *)(append->c);
#line 1703
  while (*(src + 0)) {
#line 1706
    if ((unsigned int )((ptr + 1) + (int const   )*(src + 0)) > (unsigned int )lim) {
#line 1706
      return ((mDNSu8 *)0L);
    }
#line 1707
    i = 0;
#line 1707
    while (i <= (int )*(src + 0)) {
#line 1707
      tmp___0 = ptr;
#line 1707
      ptr ++;
#line 1707
      *tmp___0 = (unsigned char )*(src + i);
#line 1707
      i ++;
    }
#line 1708
    *ptr = (unsigned char)0;
#line 1709
    src += i;
  }
#line 1711
  return (ptr);
}
}
#line 1720 "mDNS.c"
mDNSBool MakeDomainLabelFromLiteralString(domainlabel *label , char const   *cstr ) 
{ mDNSu8 *ptr ;
  mDNSu8 const   *limit ;
  mDNSu8 *tmp ;
  char const   *tmp___0 ;

  {
#line 1722
  ptr = label->c + 1;
#line 1723
  limit = (mDNSu8 const   *)((label->c + 1) + 63);
#line 1724
  while (1) {
#line 1724
    if (*cstr) {
#line 1724
      if (! ((unsigned int )ptr < (unsigned int )limit)) {
#line 1724
        break;
      }
    } else {
#line 1724
      break;
    }
#line 1724
    tmp = ptr;
#line 1724
    ptr ++;
#line 1724
    tmp___0 = cstr;
#line 1724
    cstr ++;
#line 1724
    *tmp = (unsigned char )*tmp___0;
  }
#line 1725
  label->c[0] = (unsigned char )((ptr - label->c) - 1);
#line 1726
  return ((int const   )*cstr == 0);
}
}
#line 1736 "mDNS.c"
mDNSu8 *MakeDomainNameFromDNSNameString(domainname *name , char const   *cstr ) 
{ mDNSu8 *tmp ;

  {
#line 1738
  name->c[0] = (unsigned char)0;
#line 1739
  tmp = AppendDNSNameString(name, cstr);
#line 1739
  return (tmp);
}
}
#line 1742 "mDNS.c"
char *ConvertDomainLabelToCString_withescape(domainlabel const   *label , char *ptr ,
                                             char esc ) 
{ mDNSu8 const   *src ;
  mDNSu8 len ;
  mDNSu8 const   *tmp ;
  mDNSu8 const   *end ;
  mDNSu8 c ;
  mDNSu8 const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 1744
  src = (mDNSu8 const   *)(label->c);
#line 1745
  tmp = src;
#line 1745
  src ++;
#line 1745
  len = (mDNSu8 )*tmp;
#line 1746
  end = src + (int )len;
#line 1747
  if ((int )len > 63) {
#line 1747
    return ((char *)0L);
  }
#line 1748
  while ((unsigned int )src < (unsigned int )end) {
#line 1750
    tmp___0 = src;
#line 1750
    src ++;
#line 1750
    c = (mDNSu8 )*tmp___0;
#line 1751
    if (esc) {
#line 1753
      if ((int )c == 46) {
#line 1754
        tmp___1 = ptr;
#line 1754
        ptr ++;
#line 1754
        *tmp___1 = esc;
      } else {
#line 1753
        if ((int )c == (int )esc) {
#line 1754
          tmp___1 = ptr;
#line 1754
          ptr ++;
#line 1754
          *tmp___1 = esc;
        } else {
#line 1755
          if ((int )c <= 32) {
#line 1757
            tmp___2 = ptr;
#line 1757
            ptr ++;
#line 1757
            *tmp___2 = esc;
#line 1758
            tmp___3 = ptr;
#line 1758
            ptr ++;
#line 1758
            *tmp___3 = (char )(48 + (int )c / 100);
#line 1759
            tmp___4 = ptr;
#line 1759
            ptr ++;
#line 1759
            *tmp___4 = (char )(48 + ((int )c / 10) % 10);
#line 1760
            c = (unsigned char )(48 + (int )c % 10);
          }
        }
      }
    }
#line 1763
    tmp___5 = ptr;
#line 1763
    ptr ++;
#line 1763
    *tmp___5 = (char )c;
  }
#line 1765
  *ptr = (char)0;
#line 1766
  return (ptr);
}
}
#line 1775 "mDNS.c"
char *ConvertDomainNameToCString_withescape(domainname const   *name , char *ptr ,
                                            char esc ) 
{ mDNSu8 const   *src ;
  mDNSu8 const   *max ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 1777
  src = (mDNSu8 const   *)(name->c);
#line 1778
  max = (mDNSu8 const   *)(name->c + 255);
#line 1780
  if ((int const   )*src == 0) {
#line 1780
    tmp = ptr;
#line 1780
    ptr ++;
#line 1780
    *tmp = (char )'.';
  }
#line 1782
  while (*src) {
#line 1784
    if ((unsigned int )((src + 1) + (int const   )*src) >= (unsigned int )max) {
#line 1784
      return ((char *)0L);
    }
#line 1785
    ptr = ConvertDomainLabelToCString_withescape((domainlabel const   *)src, ptr,
                                                 esc);
#line 1786
    if (! ptr) {
#line 1786
      return ((char *)0L);
    }
#line 1787
    src += 1 + (int )*src;
#line 1788
    tmp___0 = ptr;
#line 1788
    ptr ++;
#line 1788
    *tmp___0 = (char )'.';
  }
#line 1791
  tmp___1 = ptr;
#line 1791
  ptr ++;
#line 1791
  *tmp___1 = (char)0;
#line 1792
  return (ptr);
}
}
#line 1801 "mDNS.c"
void ConvertUTF8PstringToRFC1034HostLabel(mDNSu8 const   *UTF8Name , domainlabel *hostlabel ) 
{ mDNSu8 const   *src ;
  mDNSu8 const   *end ;
  mDNSu8 *ptr ;
  mDNSu8 const   *lim ;
  mDNSu8 *tmp ;
  mDNSu8 *tmp___0 ;

  {
#line 1803
  src = UTF8Name + 1;
#line 1804
  end = (UTF8Name + 1) + (int const   )*(UTF8Name + 0);
#line 1805
  ptr = & hostlabel->c[1];
#line 1806
  lim = (mDNSu8 const   *)(& hostlabel->c[1] + 63);
#line 1807
  while ((unsigned int )src < (unsigned int )end) {
#line 1810
    if ((int const   )*(src + 0) == 39) {
#line 1810
      src ++;
#line 1810
      continue;
    }
#line 1811
    if ((unsigned int )(src + 2) < (unsigned int )end) {
#line 1811
      if ((int const   )*(src + 0) == 226) {
#line 1811
        if ((int const   )*(src + 1) == 128) {
#line 1811
          if ((int const   )*(src + 2) == 153) {
#line 1812
            src += 3;
#line 1812
            continue;
          }
        }
      }
    }
#line 1813
    if ((unsigned int )ptr < (unsigned int )lim) {
#line 1815
      if ((int const   )*src >= 65) {
#line 1815
        if ((int const   )*src <= 90) {
#line 1815
          tmp = ptr;
#line 1815
          ptr ++;
#line 1815
          *tmp = (unsigned char )*src;
        } else {
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 1815
        if ((int const   )*src >= 97) {
#line 1815
          if ((int const   )*src <= 122) {
#line 1815
            tmp = ptr;
#line 1815
            ptr ++;
#line 1815
            *tmp = (unsigned char )*src;
          } else {
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
#line 1815
          if ((int const   )*src >= 48) {
#line 1815
            if ((int const   )*src <= 57) {
#line 1815
              tmp = ptr;
#line 1815
              ptr ++;
#line 1815
              *tmp = (unsigned char )*src;
            } else {
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 1815
            if ((unsigned int )ptr > (unsigned int )(& hostlabel->c[1])) {
#line 1815
              if ((unsigned int )src < (unsigned int )(end - 1)) {
#line 1815
                if ((int const   )*src == 45) {
#line 1815
                  tmp = ptr;
#line 1815
                  ptr ++;
#line 1815
                  *tmp = (unsigned char )*src;
                } else {
                  goto _L___0;
                }
              } else {
                goto _L___0;
              }
            } else {
              _L___0: /* CIL Label */ 
#line 1816
              if ((unsigned int )ptr > (unsigned int )(& hostlabel->c[1])) {
#line 1816
                if ((int )*(ptr + -1) != 45) {
#line 1816
                  tmp___0 = ptr;
#line 1816
                  ptr ++;
#line 1816
                  *tmp___0 = (unsigned char )'-';
                }
              }
            }
          }
        }
      }
    }
#line 1818
    src ++;
  }
#line 1820
  while (1) {
#line 1820
    if ((unsigned int )ptr > (unsigned int )(& hostlabel->c[1])) {
#line 1820
      if (! ((int )*(ptr + -1) == 45)) {
#line 1820
        break;
      }
    } else {
#line 1820
      break;
    }
#line 1820
    ptr --;
  }
#line 1821
  hostlabel->c[0] = (unsigned char )(ptr - & hostlabel->c[1]);
#line 1822
  return;
}
}
#line 1824 "mDNS.c"
mDNSu8 *ConstructServiceName(domainname *fqdn , domainlabel const   *name , domainname const   *type ,
                             domainname const   *domain ) 
{ int i ;
  int len ;
  mDNSu8 *dst ;
  mDNSu8 const   *src ;
  char const   *errormsg ;
  mDNSu8 const   *s2 ;
  mDNSu8 *tmp ;
  mDNSu8 const   *tmp___0 ;
  mDNSu8 *tmp___1 ;
  mDNSu8 const   *tmp___2 ;
  mDNSu8 *tmp___3 ;
  mDNSu8 const   *tmp___4 ;

  {
#line 1828
  dst = fqdn->c;
#line 1834
  if (! name) {
#line 1836
    s2 = (mDNSu8 const   *)((type->c + 1) + (int )type->c[0]);
#line 1837
    if ((int )type->c[0] > 0) {
#line 1837
      if ((int )type->c[0] < 64) {
#line 1837
        if ((int const   )*(s2 + 0) > 0) {
#line 1837
          if ((int const   )*(s2 + 0) < 64) {
#line 1837
            if ((int const   )*(s2 + (1 + (int )*(s2 + 0))) > 0) {
#line 1837
              if ((int const   )*(s2 + (1 + (int )*(s2 + 0))) < 64) {
#line 1841
                name = (domainlabel const   *)((domainlabel *)type);
#line 1842
                type = (domainname const   *)((domainname *)s2);
              }
            }
          }
        }
      }
    }
  }
#line 1846
  if (name) {
#line 1846
    if (name->c[0]) {
#line 1848
      src = (mDNSu8 const   *)(name->c);
#line 1849
      len = (int )*src;
#line 1850
      if (len >= 64) {
#line 1850
        errormsg = "Service instance name too long";
        goto fail;
      }
#line 1851
      i = 0;
#line 1851
      while (i <= len) {
#line 1851
        tmp = dst;
#line 1851
        dst ++;
#line 1851
        tmp___0 = src;
#line 1851
        src ++;
#line 1851
        *tmp = (unsigned char )*tmp___0;
#line 1851
        i ++;
      }
    } else {
#line 1854
      name = (domainlabel const   *)((domainlabel *)"");
    }
  } else {
#line 1854
    name = (domainlabel const   *)((domainlabel *)"");
  }
#line 1856
  src = (mDNSu8 const   *)(type->c);
#line 1857
  len = (int )*src;
#line 1858
  if (len < 2) {
#line 1858
    errormsg = "Invalid service application protocol name";
    goto fail;
  } else {
#line 1858
    if (len >= 64) {
#line 1858
      errormsg = "Invalid service application protocol name";
      goto fail;
    }
  }
#line 1859
  if ((int const   )*(src + 1) != 95) {
#line 1859
    errormsg = "Service application protocol name must begin with underscore";
    goto fail;
  }
#line 1860
  i = 2;
#line 1860
  while (i <= len) {
#line 1861
    if ((int const   )*(src + i) >= 65) {
#line 1861
      if (! ((int const   )*(src + i) <= 90)) {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 1861
      if ((int const   )*(src + i) >= 97) {
#line 1861
        if (! ((int const   )*(src + i) <= 122)) {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 1861
        if ((int const   )*(src + i) >= 48) {
#line 1861
          if (! ((int const   )*(src + i) <= 57)) {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 1861
          if ((int const   )*(src + i) != 45) {
#line 1861
            if ((int const   )*(src + i) != 95) {
#line 1862
              errormsg = "Service application protocol name must contain only letters, digits, and hyphens";
              goto fail;
            }
          }
        }
      }
    }
#line 1860
    i ++;
  }
#line 1863
  i = 0;
#line 1863
  while (i <= len) {
#line 1863
    tmp___1 = dst;
#line 1863
    dst ++;
#line 1863
    tmp___2 = src;
#line 1863
    src ++;
#line 1863
    *tmp___1 = (unsigned char )*tmp___2;
#line 1863
    i ++;
  }
#line 1865
  len = (int )*src;
#line 1867
  if (len == 4) {
#line 1867
    if ((int const   )*(src + 1) == 95) {
#line 1867
      if (((int const   )*(src + 2) | 32) == 117) {
#line 1867
        if (((int const   )*(src + 3) | 32) == 100) {
          goto _L___2;
        } else {
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 1867
        if (((int const   )*(src + 2) | 32) == 116) {
#line 1867
          if (((int const   )*(src + 3) | 32) == 99) {
            _L___2: /* CIL Label */ 
#line 1867
            if (! (((int const   )*(src + 4) | 32) == 112)) {
#line 1870
              errormsg = "Service transport protocol name must be _udp or _tcp";
              goto fail;
            }
          } else {
#line 1870
            errormsg = "Service transport protocol name must be _udp or _tcp";
            goto fail;
          }
        } else {
#line 1870
          errormsg = "Service transport protocol name must be _udp or _tcp";
          goto fail;
        }
      }
    } else {
#line 1870
      errormsg = "Service transport protocol name must be _udp or _tcp";
      goto fail;
    }
  } else {
#line 1870
    errormsg = "Service transport protocol name must be _udp or _tcp";
    goto fail;
  }
#line 1871
  i = 0;
#line 1871
  while (i <= len) {
#line 1871
    tmp___3 = dst;
#line 1871
    dst ++;
#line 1871
    tmp___4 = src;
#line 1871
    src ++;
#line 1871
    *tmp___3 = (unsigned char )*tmp___4;
#line 1871
    i ++;
  }
#line 1873
  if (*src) {
#line 1873
    errormsg = "Service type must have only two labels";
    goto fail;
  }
#line 1875
  *dst = (unsigned char)0;
#line 1876
  dst = AppendDomainName(fqdn, domain);
#line 1877
  if (! dst) {
#line 1877
    errormsg = "Service domain too long";
    goto fail;
  }
#line 1878
  return (dst);
  fail: 
#line 1881
  LogMsg("ConstructServiceName: %s: %#s.%##s%##s", errormsg, name->c, type->c, domain->c);
#line 1882
  return ((mDNSu8 *)0L);
}
}
#line 1885 "mDNS.c"
mDNSBool DeconstructServiceName(domainname const   *fqdn , domainlabel *name , domainname *type ,
                                domainname *domain ) 
{ int i ;
  int len ;
  mDNSu8 const   *src ;
  mDNSu8 const   *max ;
  mDNSu8 *dst ;
  mDNSu8 *tmp ;
  mDNSu8 const   *tmp___0 ;
  mDNSu8 *tmp___1 ;
  mDNSu8 const   *tmp___2 ;
  mDNSu8 *tmp___3 ;
  mDNSu8 const   *tmp___4 ;
  mDNSu8 *tmp___5 ;
  mDNSu8 *tmp___6 ;
  mDNSu8 const   *tmp___7 ;
  mDNSu8 *tmp___8 ;

  {
#line 1889
  src = (mDNSu8 const   *)(fqdn->c);
#line 1890
  max = (mDNSu8 const   *)(fqdn->c + 255);
#line 1893
  dst = name->c;
#line 1894
  len = (int )*src;
#line 1895
  if (len >= 64) {
#line 1895
    return (0);
  }
#line 1896
  i = 0;
#line 1896
  while (i <= len) {
#line 1896
    tmp = dst;
#line 1896
    dst ++;
#line 1896
    tmp___0 = src;
#line 1896
    src ++;
#line 1896
    *tmp = (unsigned char )*tmp___0;
#line 1896
    i ++;
  }
#line 1898
  dst = type->c;
#line 1899
  len = (int )*src;
#line 1900
  if (len >= 64) {
#line 1900
    return (0);
  }
#line 1901
  i = 0;
#line 1901
  while (i <= len) {
#line 1901
    tmp___1 = dst;
#line 1901
    dst ++;
#line 1901
    tmp___2 = src;
#line 1901
    src ++;
#line 1901
    *tmp___1 = (unsigned char )*tmp___2;
#line 1901
    i ++;
  }
#line 1903
  len = (int )*src;
#line 1904
  if (len >= 64) {
#line 1904
    return (0);
  }
#line 1905
  i = 0;
#line 1905
  while (i <= len) {
#line 1905
    tmp___3 = dst;
#line 1905
    dst ++;
#line 1905
    tmp___4 = src;
#line 1905
    src ++;
#line 1905
    *tmp___3 = (unsigned char )*tmp___4;
#line 1905
    i ++;
  }
#line 1906
  tmp___5 = dst;
#line 1906
  dst ++;
#line 1906
  *tmp___5 = (unsigned char)0;
#line 1908
  dst = domain->c;
#line 1909
  while (*src) {
#line 1911
    len = (int )*src;
#line 1912
    if (len >= 64) {
#line 1913
      return (0);
    }
#line 1914
    if ((unsigned int )(((src + 1) + len) + 1) >= (unsigned int )max) {
#line 1915
      return (0);
    }
#line 1916
    i = 0;
#line 1916
    while (i <= len) {
#line 1916
      tmp___6 = dst;
#line 1916
      dst ++;
#line 1916
      tmp___7 = src;
#line 1916
      src ++;
#line 1916
      *tmp___6 = (unsigned char )*tmp___7;
#line 1916
      i ++;
    }
  }
#line 1918
  tmp___8 = dst;
#line 1918
  dst ++;
#line 1918
  *tmp___8 = (unsigned char)0;
#line 1920
  return (1);
}
}
#line 1925 "mDNS.c"
static mDNSBool LabelContainsSuffix(domainlabel const   *name , mDNSBool RichText ) 
{ mDNSu16 l ;
  mDNSu16 tmp ;
  int tmp___0 ;

  {
#line 1927
  l = (mDNSu16 )name->c[0];
#line 1929
  if (RichText) {
#line 1931
    if ((int )l < 4) {
#line 1931
      return (0);
    }
#line 1932
    tmp = l;
#line 1932
    l = (mDNSu16 )((int )l - 1);
#line 1932
    if ((int )name->c[tmp] != 41) {
#line 1932
      return (0);
    }
#line 1933
    if ((int )name->c[l] >= 48) {
#line 1933
      if (! ((int )name->c[l] <= 57)) {
#line 1933
        return (0);
      }
    } else {
#line 1933
      return (0);
    }
#line 1934
    l = (mDNSu16 )((int )l - 1);
#line 1935
    while (1) {
#line 1935
      if ((int )l > 2) {
#line 1935
        if ((int )name->c[l] >= 48) {
#line 1935
          if (! ((int )name->c[l] <= 57)) {
#line 1935
            break;
          }
        } else {
#line 1935
          break;
        }
      } else {
#line 1935
        break;
      }
#line 1935
      l = (mDNSu16 )((int )l - 1);
    }
#line 1936
    if ((int )name->c[l] == 40) {
#line 1936
      if ((int )name->c[(int )l - 1] == 32) {
#line 1936
        tmp___0 = 1;
      } else {
#line 1936
        tmp___0 = 0;
      }
    } else {
#line 1936
      tmp___0 = 0;
    }
#line 1936
    return (tmp___0);
  } else {
#line 1940
    if ((int )l < 2) {
#line 1940
      return (0);
    }
#line 1941
    if ((int )name->c[l] >= 48) {
#line 1941
      if (! ((int )name->c[l] <= 57)) {
#line 1941
        return (0);
      }
    } else {
#line 1941
      return (0);
    }
#line 1942
    l = (mDNSu16 )((int )l - 1);
#line 1943
    while (1) {
#line 1943
      if ((int )l > 2) {
#line 1943
        if ((int )name->c[l] >= 48) {
#line 1943
          if (! ((int )name->c[l] <= 57)) {
#line 1943
            break;
          }
        } else {
#line 1943
          break;
        }
      } else {
#line 1943
        break;
      }
#line 1943
      l = (mDNSu16 )((int )l - 1);
    }
#line 1944
    return ((int )name->c[l] == 45);
  }
}
}
#line 1951 "mDNS.c"
static mDNSu32 RemoveLabelSuffix(domainlabel *name , mDNSBool RichText ) 
{ mDNSu32 val ;
  mDNSu32 multiplier ;

  {
#line 1953
  val = (mDNSu32 )0;
#line 1953
  multiplier = (mDNSu32 )1;
#line 1956
  if (RichText) {
#line 1956
    if ((int )name->c[0] >= 1) {
#line 1956
      if ((int )name->c[name->c[0]] == 41) {
#line 1956
        name->c[0] = (mDNSu8 )((int )name->c[0] - 1);
      }
    }
  }
#line 1959
  while (1) {
#line 1959
    if ((int )name->c[name->c[0]] >= 48) {
#line 1959
      if (! ((int )name->c[name->c[0]] <= 57)) {
#line 1959
        break;
      }
    } else {
#line 1959
      break;
    }
#line 1960
    val += (mDNSu32 )((int )name->c[name->c[0]] - 48) * multiplier;
#line 1960
    multiplier *= 10U;
#line 1960
    name->c[0] = (mDNSu8 )((int )name->c[0] - 1);
  }
#line 1963
  if (RichText) {
#line 1965
    if ((int )name->c[0] >= 2) {
#line 1965
      if ((int )name->c[name->c[0]] == 40) {
#line 1965
        if ((int )name->c[(int )name->c[0] - 1] == 32) {
#line 1965
          name->c[0] = (unsigned char )((int )name->c[0] - 2);
        }
      }
    }
  } else {
#line 1969
    if ((int )name->c[0] >= 1) {
#line 1969
      if ((int )name->c[name->c[0]] == 45) {
#line 1969
        name->c[0] = (unsigned char )((int )name->c[0] - 1);
      }
    }
  }
#line 1972
  return (val);
}
}
#line 1977 "mDNS.c"
static void AppendLabelSuffix(domainlabel *name , mDNSu32 val , mDNSBool RichText ) 
{ mDNSu32 divisor ;
  mDNSu32 chars ;

  {
#line 1979
  divisor = (mDNSu32 )1;
#line 1979
  chars = (mDNSu32 )2;
#line 1980
  if (RichText) {
#line 1980
    chars = 4U;
  }
#line 1983
  if (RichText) {
#line 1983
    while ((int )name->c[name->c[0]] == 32) {
#line 1983
      name->c[0] = (mDNSu8 )((int )name->c[0] - 1);
    }
  }
#line 1985
  while (val >= divisor * 10U) {
#line 1985
    divisor *= 10U;
#line 1985
    chars ++;
  }
#line 1987
  if ((int )name->c[0] > (int )((unsigned char )(63U - chars))) {
#line 1989
    name->c[0] = (unsigned char )(63U - chars);
#line 1992
    while (1) {
#line 1992
      if ((int )name->c[0] > 0) {
#line 1992
        if (! (((int )name->c[(int )name->c[0] + 1] & 192) == 128)) {
#line 1992
          break;
        }
      } else {
#line 1992
        break;
      }
#line 1992
      name->c[0] = (mDNSu8 )((int )name->c[0] - 1);
    }
  }
#line 1995
  if (RichText) {
#line 1995
    name->c[0] = (mDNSu8 )((int )name->c[0] + 1);
#line 1995
    name->c[name->c[0]] = (unsigned char )' ';
#line 1995
    name->c[0] = (mDNSu8 )((int )name->c[0] + 1);
#line 1995
    name->c[name->c[0]] = (unsigned char )'(';
  } else {
#line 1996
    name->c[0] = (mDNSu8 )((int )name->c[0] + 1);
#line 1996
    name->c[name->c[0]] = (unsigned char )'-';
  }
#line 1998
  while (divisor) {
#line 2000
    name->c[0] = (mDNSu8 )((int )name->c[0] + 1);
#line 2000
    name->c[name->c[0]] = (unsigned char )(48U + val / divisor);
#line 2001
    val %= divisor;
#line 2002
    divisor /= 10U;
  }
#line 2005
  if (RichText) {
#line 2005
    name->c[0] = (mDNSu8 )((int )name->c[0] + 1);
#line 2005
    name->c[name->c[0]] = (unsigned char )')';
  }
#line 2006
  return;
}
}
#line 2008 "mDNS.c"
void IncrementLabelSuffix(domainlabel *name , mDNSBool RichText ) 
{ mDNSu32 val ;
  mDNSBool tmp ;
  mDNSu32 tmp___0 ;

  {
#line 2010
  val = (mDNSu32 )0;
#line 2012
  tmp = LabelContainsSuffix((domainlabel const   *)name, RichText);
#line 2012
  if (tmp) {
#line 2013
    val = RemoveLabelSuffix(name, RichText);
  }
#line 2019
  if (val == 0U) {
#line 2019
    val = 2U;
  } else {
#line 2020
    if (val < 10U) {
#line 2020
      val ++;
    } else {
#line 2021
      tmp___0 = mDNSRandom(99U);
#line 2021
      val += 1U + tmp___0;
    }
  }
#line 2023
  AppendLabelSuffix(name, val, RichText);
#line 2024
  return;
}
}
#line 2078 "mDNS.c"
static mDNSBool SameRData(ResourceRecord const   *r1 , ResourceRecord const   *r2 ) 
{ mDNSBool tmp ;
  mDNSBool tmp___0 ;
  int tmp___1 ;
  mDNSBool tmp___2 ;

  {
#line 2080
  if ((int const   )r1->rrtype != (int const   )r2->rrtype) {
#line 2080
    return (0);
  }
#line 2081
  if ((int const   )r1->rdlength != (int const   )r2->rdlength) {
#line 2081
    return (0);
  }
#line 2082
  if (r1->rdatahash != r2->rdatahash) {
#line 2082
    return (0);
  }
#line 2083
  if (r1->rdnamehash != r2->rdnamehash) {
#line 2083
    return (0);
  }
#line 2084
  switch ((int )r1->rrtype) {
  case 5: 
  case 12: 
#line 2087
  tmp = SameDomainName((domainname const   *)(& (r1->rdata)->u.name), (domainname const   *)(& (r2->rdata)->u.name));
#line 2087
  return (tmp);
  case 33: 
#line 2089
  if ((int )(r1->rdata)->u.srv.priority == (int )(r2->rdata)->u.srv.priority) {
#line 2089
    if ((int )(r1->rdata)->u.srv.weight == (int )(r2->rdata)->u.srv.weight) {
#line 2089
      if ((int )(r1->rdata)->u.srv.port.NotAnInteger == (int )(r2->rdata)->u.srv.port.NotAnInteger) {
#line 2089
        tmp___0 = SameDomainName((domainname const   *)(& (r1->rdata)->u.srv.target),
                                 (domainname const   *)(& (r2->rdata)->u.srv.target));
#line 2089
        if (tmp___0) {
#line 2089
          tmp___1 = 1;
        } else {
#line 2089
          tmp___1 = 0;
        }
      } else {
#line 2089
        tmp___1 = 0;
      }
    } else {
#line 2089
      tmp___1 = 0;
    }
  } else {
#line 2089
    tmp___1 = 0;
  }
#line 2089
  return (tmp___1);
  default: 
#line 2094
  tmp___2 = mDNSPlatformMemSame((void const   *)((r1->rdata)->u.data), (void const   *)((r2->rdata)->u.data),
                                (unsigned int )r1->rdlength);
#line 2094
  return (tmp___2);
  }
}
}
#line 2098 "mDNS.c"
static mDNSBool ResourceRecordAnswersQuestion(ResourceRecord const   *rr , DNSQuestion const   *q ) 
{ mDNSBool tmp ;
  int tmp___0 ;

  {
#line 2100
  if (rr->InterfaceID) {
#line 2100
    if (q->InterfaceID) {
#line 2100
      if ((unsigned int )rr->InterfaceID != (unsigned int )q->InterfaceID) {
#line 2102
        return (0);
      }
    }
  }
#line 2105
  if ((int const   )rr->rrtype != 5) {
#line 2105
    if ((int const   )rr->rrtype != (int const   )q->qtype) {
#line 2105
      if ((int const   )q->qtype != 255) {
#line 2105
        return (0);
      }
    }
  }
#line 2106
  if ((int const   )rr->rrclass != (int const   )q->qclass) {
#line 2106
    if ((int const   )q->qclass != 255) {
#line 2106
      return (0);
    }
  }
#line 2107
  if (rr->namehash == q->qnamehash) {
#line 2107
    tmp = SameDomainName(& rr->name, & q->qname);
#line 2107
    if (tmp) {
#line 2107
      tmp___0 = 1;
    } else {
#line 2107
      tmp___0 = 0;
    }
  } else {
#line 2107
    tmp___0 = 0;
  }
#line 2107
  return (tmp___0);
}
}
#line 2110 "mDNS.c"
static mDNSu32 DomainNameHashValue(domainname const   *name ) 
{ mDNSu32 sum ;
  mDNSu8 const   *c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2112
  sum = (mDNSu32 )0;
#line 2115
  c = (mDNSu8 const   *)(name->c);
#line 2115
  while (1) {
#line 2115
    if ((int const   )*(c + 0) != 0) {
#line 2115
      if (! ((int const   )*(c + 1) != 0)) {
#line 2115
        break;
      }
    } else {
#line 2115
      break;
    }
#line 2117
    if ((int const   )*(c + 0) >= 65) {
#line 2117
      if ((int const   )*(c + 0) <= 90) {
#line 2117
        tmp = ((int const   )*(c + 0) + 97) - 65;
      } else {
#line 2117
        tmp = (int const   )*(c + 0);
      }
    } else {
#line 2117
      tmp = (int const   )*(c + 0);
    }
#line 2117
    if ((int const   )*(c + 1) >= 65) {
#line 2117
      if ((int const   )*(c + 1) <= 90) {
#line 2117
        tmp___0 = ((int const   )*(c + 1) + 97) - 65;
      } else {
#line 2117
        tmp___0 = (int const   )*(c + 1);
      }
    } else {
#line 2117
      tmp___0 = (int const   )*(c + 1);
    }
#line 2117
    sum += (mDNSu32 )((tmp << 8) | tmp___0);
#line 2119
    sum = (sum << 3) | (sum >> 29);
#line 2115
    c += 2;
  }
#line 2121
  if (*(c + 0)) {
#line 2121
    if ((int const   )*(c + 0) >= 65) {
#line 2121
      if ((int const   )*(c + 0) <= 90) {
#line 2121
        tmp___1 = ((int const   )*(c + 0) + 97) - 65;
      } else {
#line 2121
        tmp___1 = (int const   )*(c + 0);
      }
    } else {
#line 2121
      tmp___1 = (int const   )*(c + 0);
    }
#line 2121
    sum += (mDNSu32 )(tmp___1 << 8);
  }
#line 2122
  return (sum);
}
}
#line 2127 "mDNS.c"
static mDNSu32 RDataHashValue(mDNSu16 rdlength , RDataBody const   *rdb ) 
{ mDNSu32 sum ;
  int i ;

  {
#line 2129
  sum = (mDNSu32 )0;
#line 2131
  i = 0;
#line 2131
  while (i + 1 < (int )rdlength) {
#line 2133
    sum += ((unsigned int )rdb->data[i] << 8) | (unsigned int )rdb->data[i + 1];
#line 2134
    sum = (sum << 3) | (sum >> 29);
#line 2131
    i += 2;
  }
#line 2136
  if (i < (int )rdlength) {
#line 2138
    sum += (unsigned int )rdb->data[i] << 8;
  }
#line 2140
  return (sum);
}
}
#line 2149 "mDNS.c"
static mDNSBool SameResourceRecordSignature(ResourceRecord const   *r1 , ResourceRecord const   *r2 ) 
{ mDNSBool tmp ;
  int tmp___0 ;

  {
#line 2151
  if (! r1) {
#line 2151
    LogMsg("SameResourceRecordSignature ERROR: r1 is NULL");
#line 2151
    return (0);
  }
#line 2152
  if (! r2) {
#line 2152
    LogMsg("SameResourceRecordSignature ERROR: r2 is NULL");
#line 2152
    return (0);
  }
#line 2153
  if (r1->InterfaceID) {
#line 2153
    if (r2->InterfaceID) {
#line 2153
      if ((unsigned int )r1->InterfaceID != (unsigned int )r2->InterfaceID) {
#line 2155
        return (0);
      }
    }
  }
#line 2156
  if ((int const   )r1->rrtype == (int const   )r2->rrtype) {
#line 2156
    if ((int const   )r1->rrclass == (int const   )r2->rrclass) {
#line 2156
      if (r1->namehash == r2->namehash) {
#line 2156
        tmp = SameDomainName(& r1->name, & r2->name);
#line 2156
        if (tmp) {
#line 2156
          tmp___0 = 1;
        } else {
#line 2156
          tmp___0 = 0;
        }
      } else {
#line 2156
        tmp___0 = 0;
      }
    } else {
#line 2156
      tmp___0 = 0;
    }
  } else {
#line 2156
    tmp___0 = 0;
  }
#line 2156
  return (tmp___0);
}
}
#line 2162 "mDNS.c"
static mDNSBool PacketRRMatchesSignature(CacheRecord const   *pktrr , AuthRecord const   *authrr ) 
{ mDNSBool tmp ;
  int tmp___0 ;

  {
#line 2164
  if (! pktrr) {
#line 2164
    LogMsg("PacketRRMatchesSignature ERROR: pktrr is NULL");
#line 2164
    return (0);
  }
#line 2165
  if (! authrr) {
#line 2165
    LogMsg("PacketRRMatchesSignature ERROR: authrr is NULL");
#line 2165
    return (0);
  }
#line 2166
  if (pktrr->resrec.InterfaceID) {
#line 2166
    if (authrr->resrec.InterfaceID) {
#line 2166
      if ((unsigned int )pktrr->resrec.InterfaceID != (unsigned int )authrr->resrec.InterfaceID) {
#line 2168
        return (0);
      }
    }
  }
#line 2169
  if ((int const   )authrr->resrec.RecordType != 2) {
#line 2169
    if ((int const   )pktrr->resrec.rrtype != (int const   )authrr->resrec.rrtype) {
#line 2169
      return (0);
    }
  }
#line 2170
  if ((int const   )pktrr->resrec.rrclass == (int const   )authrr->resrec.rrclass) {
#line 2170
    if (pktrr->resrec.namehash == authrr->resrec.namehash) {
#line 2170
      tmp = SameDomainName(& pktrr->resrec.name, & authrr->resrec.name);
#line 2170
      if (tmp) {
#line 2170
        tmp___0 = 1;
      } else {
#line 2170
        tmp___0 = 0;
      }
    } else {
#line 2170
      tmp___0 = 0;
    }
  } else {
#line 2170
    tmp___0 = 0;
  }
#line 2170
  return (tmp___0);
}
}
#line 2175 "mDNS.c"
static mDNSBool IdenticalResourceRecord(ResourceRecord const   *r1 , ResourceRecord const   *r2 ) 
{ mDNSBool tmp ;
  mDNSBool tmp___0 ;

  {
#line 2177
  if (! r1) {
#line 2177
    LogMsg("IdenticalResourceRecord ERROR: r1 is NULL");
#line 2177
    return (0);
  }
#line 2178
  if (! r2) {
#line 2178
    LogMsg("IdenticalResourceRecord ERROR: r2 is NULL");
#line 2178
    return (0);
  }
#line 2179
  if ((int const   )r1->rrtype != (int const   )r2->rrtype) {
#line 2179
    return (0);
  } else {
#line 2179
    if ((int const   )r1->rrclass != (int const   )r2->rrclass) {
#line 2179
      return (0);
    } else {
#line 2179
      if (r1->namehash != r2->namehash) {
#line 2179
        return (0);
      } else {
#line 2179
        tmp = SameDomainName(& r1->name, & r2->name);
#line 2179
        if (! tmp) {
#line 2179
          return (0);
        }
      }
    }
  }
#line 2180
  tmp___0 = SameRData(r1, r2);
#line 2180
  return (tmp___0);
}
}
#line 2190 "mDNS.c"
static mDNSBool ShouldSuppressKnownAnswer(CacheRecord const   *ka , AuthRecord const   *rr ) 
{ mDNSBool tmp ;

  {
#line 2193
  tmp = IdenticalResourceRecord(& ka->resrec, & rr->resrec);
#line 2193
  if (! tmp) {
#line 2193
    return (0);
  }
#line 2204
  return (ka->resrec.rroriginalttl >= rr->resrec.rroriginalttl / 2U);
}
}
#line 2207 "mDNS.c"
static mDNSu16 GetRDLength(ResourceRecord const   *rr , mDNSBool estimate ) 
{ RDataBody *rd ;
  domainname const   *name ;
  domainname const   *tmp ;
  mDNSu16 tmp___0 ;
  mDNSu16 tmp___1 ;

  {
#line 2209
  rd = & (rr->rdata)->u;
#line 2210
  if (estimate) {
#line 2210
    tmp = & rr->name;
  } else {
#line 2210
    tmp = (domainname const   *)0L;
  }
#line 2210
  name = tmp;
#line 2211
  switch ((int )rr->rrtype) {
  case 1: 
#line 2213
  return ((unsigned short )sizeof(rd->ip));
  case 5: 
  case 12: 
#line 2215
  tmp___0 = CompressedDomainNameLength((domainname const   *)(& rd->name), name);
#line 2215
  return (tmp___0);
  case 13: 
#line 2216
  return ((unsigned short )((2 + (int )rd->data[0]) + (int )rd->data[1 + (int )rd->data[0]]));
  case 10: 
  case 16: 
#line 2218
  return ((unsigned short )rr->rdlength);
  case 28: 
#line 2219
  return ((unsigned short )sizeof(rd->ipv6));
  case 33: 
#line 2220
  tmp___1 = CompressedDomainNameLength((domainname const   *)(& rd->srv.target), name);
#line 2220
  return ((unsigned short )(6 + (int )tmp___1));
  default: ;
#line 2222
  return ((unsigned short )rr->rdlength);
  }
}
}
#line 2226 "mDNS.c"
static void SetNextAnnounceProbeTime(mDNS *m , AuthRecord const   *rr ) 
{ 

  {
#line 2228
  if ((int const   )rr->resrec.RecordType == 2) {
#line 2230
    if (m->NextScheduledProbe - (mDNSs32 )(rr->LastAPTime + rr->ThisAPInterval) >= 0) {
#line 2231
      m->NextScheduledProbe = (int )(rr->LastAPTime + rr->ThisAPInterval);
    }
  } else {
#line 2233
    if (rr->AnnounceCount) {
#line 2233
      if ((int const   )rr->resrec.RecordType & 60) {
#line 2233
        if ((unsigned int )rr->Additional1 == (unsigned int )((AuthRecord * const  )0)) {
          goto _L___1;
        } else {
#line 2233
          if ((int )(rr->Additional1)->resrec.RecordType & 60) {
            _L___1: /* CIL Label */ 
#line 2233
            if ((unsigned int )rr->Additional2 == (unsigned int )((AuthRecord * const  )0)) {
              goto _L___0;
            } else {
#line 2233
              if ((int )(rr->Additional2)->resrec.RecordType & 60) {
                _L___0: /* CIL Label */ 
#line 2233
                if ((unsigned int )rr->DependentOn == (unsigned int )((AuthRecord * const  )0)) {
                  goto _L;
                } else {
#line 2233
                  if ((int )(rr->DependentOn)->resrec.RecordType & 60) {
                    _L: /* CIL Label */ 
#line 2235
                    if (m->NextScheduledResponse - (mDNSs32 )(rr->LastAPTime + rr->ThisAPInterval) >= 0) {
#line 2236
                      m->NextScheduledResponse = (int )(rr->LastAPTime + rr->ThisAPInterval);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 2238
  return;
}
}
#line 2244 "mDNS.c"
static void InitializeLastAPTime(mDNS *m , AuthRecord *rr ) 
{ 

  {
#line 2254
  if (m->SuppressProbes == 0) {
    goto _L;
  } else {
#line 2254
    if (m->SuppressProbes - m->timenow < 0) {
      _L: /* CIL Label */ 
#line 2256
      m->SuppressProbes = (m->timenow + mDNSPlatformOneSecond / 4) | 1;
#line 2258
      if (m->SuppressProbes - m->NextScheduledProbe >= 0) {
#line 2259
        m->SuppressProbes = m->NextScheduledProbe;
      }
#line 2261
      if (m->SuppressProbes - m->NextScheduledQuery >= 0) {
#line 2262
        m->SuppressProbes = m->NextScheduledQuery;
      }
    }
  }
#line 2268
  rr->AnnounceUntil = m->timenow + (int )rr->resrec.rroriginalttl * mDNSPlatformOneSecond;
#line 2269
  rr->LastAPTime = m->SuppressProbes - rr->ThisAPInterval;
#line 2272
  rr->LastMCTime = m->timenow;
#line 2273
  rr->LastMCInterface = (struct mDNSInterfaceID_dummystruct *)mDNSInterfaceMark;
#line 2282
  if ((int )rr->resrec.RecordType != 2) {
#line 2283
    rr->LastAPTime += (mDNSPlatformOneSecond / 4) * 3 + rr->ThisAPInterval / 2;
  }
#line 2285
  SetNextAnnounceProbeTime(m, (AuthRecord const   *)rr);
#line 2286
  return;
}
}
#line 2288 "mDNS.c"
static void SetNewRData(ResourceRecord *rr , RData *NewRData , mDNSu16 rdlength ) 
{ domainname *target ;
  domainname *tmp ;
  mDNSu32 tmp___0 ;

  {
#line 2291
  if (NewRData) {
#line 2293
    rr->rdata = NewRData;
#line 2294
    rr->rdlength = rdlength;
  }
#line 2297
  if ((int )rr->rrtype == 5) {
#line 2297
    target = & (rr->rdata)->u.name;
  } else {
#line 2297
    if ((int )rr->rrtype == 12) {
#line 2297
      target = & (rr->rdata)->u.name;
    } else {
#line 2297
      if ((int )rr->rrtype == 33) {
#line 2297
        tmp = & (rr->rdata)->u.srv.target;
      } else {
#line 2297
        tmp = (domainname *)0L;
      }
#line 2297
      target = tmp;
    }
  }
#line 2298
  rr->rdlength = GetRDLength((ResourceRecord const   *)rr, 0);
#line 2299
  rr->rdestimate = GetRDLength((ResourceRecord const   *)rr, 1);
#line 2300
  rr->rdatahash = RDataHashValue(rr->rdlength, (RDataBody const   *)(& (rr->rdata)->u));
#line 2301
  if (target) {
#line 2301
    tmp___0 = DomainNameHashValue((domainname const   *)target);
#line 2301
    rr->rdnamehash = tmp___0;
  } else {
#line 2301
    rr->rdnamehash = 0U;
  }
#line 2302
  return;
}
}
#line 2304 "mDNS.c"
static void SetTargetToHostName(mDNS *m , AuthRecord *rr ) 
{ domainname *target ;
  domainname *tmp ;
  domainname *tmp___0 ;
  mDNSBool tmp___1 ;
  mDNSu16 tmp___2 ;
  mDNSs32 tmp___3 ;
  mDNSs32 tmp___4 ;
  mDNSBool tmp___5 ;

  {
#line 2306
  if ((int )rr->resrec.rrtype == 5) {
#line 2306
    tmp___0 = & (rr->resrec.rdata)->u.name;
  } else {
#line 2306
    if ((int )rr->resrec.rrtype == 12) {
#line 2306
      tmp___0 = & (rr->resrec.rdata)->u.name;
    } else {
#line 2306
      if ((int )rr->resrec.rrtype == 33) {
#line 2306
        tmp = & (rr->resrec.rdata)->u.srv.target;
      } else {
#line 2306
        tmp = (domainname *)0L;
      }
#line 2306
      tmp___0 = tmp;
    }
  }
#line 2306
  target = tmp___0;
#line 2308
  if (! target) {

  }
#line 2310
  if (target) {
#line 2310
    tmp___1 = SameDomainName((domainname const   *)target, (domainname const   *)(& m->hostname));
#line 2310
    if (tmp___1) {

    }
  }
#line 2313
  if (target) {
#line 2313
    tmp___5 = SameDomainName((domainname const   *)target, (domainname const   *)(& m->hostname));
#line 2313
    if (! tmp___5) {
#line 2315
      tmp___2 = DomainNameLength((domainname const   *)(& m->hostname));
#line 2315
      mDNSPlatformMemCopy((void const   *)(m->hostname.c), (void *)(target->c), (unsigned int )tmp___2);
#line 2316
      SetNewRData(& rr->resrec, (RData *)0L, (unsigned short)0);
#line 2321
      if ((int )rr->resrec.RecordType == 2) {
#line 2321
        rr->ProbeCount = (unsigned char)3;
      } else {
#line 2321
        rr->ProbeCount = (unsigned char)0;
      }
#line 2326
      if ((int )rr->AnnounceCount < 10) {
#line 2326
        if ((int )rr->resrec.RecordType == 8) {

        }
      }
#line 2329
      if ((int )rr->AnnounceCount < 9) {
#line 2330
        rr->AnnounceCount = (unsigned char)9;
      }
#line 2331
      if ((int )rr->resrec.RecordType & 12) {
#line 2331
        rr->ThisAPInterval = mDNSPlatformOneSecond / 2;
      } else {
#line 2331
        if ((int )rr->resrec.RecordType & 2) {
#line 2331
          tmp___4 = mDNSPlatformOneSecond / 4;
        } else {
#line 2331
          if ((int )rr->resrec.RecordType & 48) {
#line 2331
            tmp___3 = mDNSPlatformOneSecond / 2;
          } else {
#line 2331
            tmp___3 = 0;
          }
#line 2331
          tmp___4 = tmp___3;
        }
#line 2331
        rr->ThisAPInterval = tmp___4;
      }
#line 2332
      InitializeLastAPTime(m, rr);
    }
  }
#line 2334
  return;
}
}
#line 2336 "mDNS.c"
static void CompleteProbing(mDNS *m , AuthRecord *rr ) 
{ 

  {
#line 2339
  if (! rr->Acknowledged) {
#line 2339
    if (rr->RecordCallback) {
#line 2343
      rr->Acknowledged = (unsigned char)1;
#line 2344
      (m->mDNS_reentrancy) ++;
#line 2345
      (*(rr->RecordCallback))(m, rr, 0);
#line 2346
      (m->mDNS_reentrancy) --;
    }
  }
#line 2348
  return;
}
}
#line 2352 "mDNS.c"
static mDNSBool ValidateRData(mDNSu16 rrtype , mDNSu16 rdlength , RData const   *rd ) 
{ mDNSu16 len ;
  int tmp ;
  mDNSu8 const   *ptr ;
  mDNSu8 const   *end ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2355
  switch ((int )rrtype) {
  case 1: 
#line 2357
  return ((unsigned int )rdlength == sizeof(mDNSv4Addr ));
  case 2: 
  case 3: 
  case 4: 
  case 5: 
  case 7: 
  case 8: 
  case 9: 
  case 12: 
#line 2369
  len = DomainNameLength(& rd->u.name);
#line 2370
  if ((int )len <= 255) {
#line 2370
    if ((int )rdlength == (int )len) {
#line 2370
      tmp = 1;
    } else {
#line 2370
      tmp = 0;
    }
  } else {
#line 2370
    tmp = 0;
  }
#line 2370
  return (tmp);
  case 13: 
  case 14: 
  case 16: 
#line 2375
  ptr = (mDNSu8 const   *)(rd->u.txt.c);
#line 2376
  end = (mDNSu8 const   *)(rd->u.txt.c + (int )rdlength);
#line 2377
  while ((unsigned int )ptr < (unsigned int )end) {
#line 2377
    ptr += 1 + (int )*(ptr + 0);
  }
#line 2378
  return ((unsigned int )ptr == (unsigned int )end);
  case 28: 
#line 2381
  return ((unsigned int )rdlength == sizeof(mDNSv6Addr ));
  case 15: 
#line 2383
  len = DomainNameLength(& rd->u.mx.exchange);
#line 2384
  if ((int )len <= 255) {
#line 2384
    if ((int )rdlength == 2 + (int )len) {
#line 2384
      tmp___0 = 1;
    } else {
#line 2384
      tmp___0 = 0;
    }
  } else {
#line 2384
    tmp___0 = 0;
  }
#line 2384
  return (tmp___0);
  case 33: 
#line 2386
  len = DomainNameLength(& rd->u.srv.target);
#line 2387
  if ((int )len <= 255) {
#line 2387
    if ((int )rdlength == 6 + (int )len) {
#line 2387
      tmp___1 = 1;
    } else {
#line 2387
      tmp___1 = 0;
    }
  } else {
#line 2387
    tmp___1 = 0;
  }
#line 2387
  return (tmp___1);
  default: ;
#line 2389
  return (1);
  }
}
}
#line 2397 "mDNS.c"
static mStatus mDNS_Register_internal(mDNS *m , AuthRecord *rr ) 
{ domainname *target ;
  domainname *tmp ;
  domainname *tmp___0 ;
  AuthRecord *r ;
  AuthRecord **p ;
  AuthRecord **d ;
  AuthRecord **l ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  NetworkInterfaceInfo *intf ;
  mDNSs32 tmp___4 ;
  mDNSs32 tmp___5 ;
  char *tmp___6 ;
  mDNSu16 tmp___7 ;
  char *tmp___8 ;
  mDNSBool tmp___9 ;
  mDNSu32 tmp___10 ;
  AuthRecord const   *s1 ;
  AuthRecord *tmp___11 ;
  AuthRecord const   *s2 ;
  AuthRecord *tmp___12 ;
  mDNSBool tmp___13 ;
  mDNSBool tmp___14 ;
  mDNSBool tmp___15 ;

  {
#line 2399
  if ((int )rr->resrec.rrtype == 5) {
#line 2399
    tmp___0 = & (rr->resrec.rdata)->u.name;
  } else {
#line 2399
    if ((int )rr->resrec.rrtype == 12) {
#line 2399
      tmp___0 = & (rr->resrec.rdata)->u.name;
    } else {
#line 2399
      if ((int )rr->resrec.rrtype == 33) {
#line 2399
        tmp = & (rr->resrec.rdata)->u.srv.target;
      } else {
#line 2399
        tmp = (domainname *)0L;
      }
#line 2399
      tmp___0 = tmp;
    }
  }
#line 2399
  target = tmp___0;
#line 2401
  p = & m->ResourceRecords;
#line 2402
  d = & m->DuplicateRecords;
#line 2403
  l = & m->LocalOnlyRecords;
#line 2409
  while (1) {
#line 2409
    if (*p) {
#line 2409
      if (! ((unsigned int )*p != (unsigned int )rr)) {
#line 2409
        break;
      }
    } else {
#line 2409
      break;
    }
#line 2409
    p = & (*p)->next;
  }
#line 2410
  while (1) {
#line 2410
    if (*d) {
#line 2410
      if (! ((unsigned int )*d != (unsigned int )rr)) {
#line 2410
        break;
      }
    } else {
#line 2410
      break;
    }
#line 2410
    d = & (*d)->next;
  }
#line 2411
  while (1) {
#line 2411
    if (*l) {
#line 2411
      if (! ((unsigned int )*l != (unsigned int )rr)) {
#line 2411
        break;
      }
    } else {
#line 2411
      break;
    }
#line 2411
    l = & (*l)->next;
  }
#line 2412
  if (*d) {
#line 2414
    tmp___1 = DNSTypeName(rr->resrec.rrtype);
#line 2414
    LogMsg("Error! Tried to register a AuthRecord %p %##s (%s) that\'s already in the list",
           rr, rr->resrec.name.c, tmp___1);
#line 2415
    return (-65547);
  } else {
#line 2412
    if (*p) {
#line 2414
      tmp___1 = DNSTypeName(rr->resrec.rrtype);
#line 2414
      LogMsg("Error! Tried to register a AuthRecord %p %##s (%s) that\'s already in the list",
             rr, rr->resrec.name.c, tmp___1);
#line 2415
      return (-65547);
    } else {
#line 2412
      if (*l) {
#line 2414
        tmp___1 = DNSTypeName(rr->resrec.rrtype);
#line 2414
        LogMsg("Error! Tried to register a AuthRecord %p %##s (%s) that\'s already in the list",
               rr, rr->resrec.name.c, tmp___1);
#line 2415
        return (-65547);
      }
    }
  }
#line 2418
  if (rr->DependentOn) {
#line 2420
    if ((int )rr->resrec.RecordType == 2) {
#line 2421
      rr->resrec.RecordType = (unsigned char)16;
    } else {
#line 2424
      tmp___2 = DNSTypeName(rr->resrec.rrtype);
#line 2424
      LogMsg("mDNS_Register_internal: ERROR! %##s (%s): rr->DependentOn && RecordType != kDNSRecordTypeUnique",
             rr->resrec.name.c, tmp___2);
#line 2426
      return (-65549);
    }
#line 2428
    if (! ((int )(rr->DependentOn)->resrec.RecordType & 18)) {
#line 2430
      tmp___3 = DNSTypeName(rr->resrec.rrtype);
#line 2430
      LogMsg("mDNS_Register_internal: ERROR! %##s (%s): rr->DependentOn->RecordType bad type %X",
             rr->resrec.name.c, tmp___3, (rr->DependentOn)->resrec.RecordType);
#line 2432
      return (-65549);
    }
  }
#line 2437
  if (rr->resrec.InterfaceID) {
#line 2437
    if ((unsigned int )rr->resrec.InterfaceID != (unsigned int )((struct mDNSInterfaceID_dummystruct *)-1)) {
#line 2440
      intf = m->HostInterfaces;
#line 2440
      while (intf) {
#line 2441
        if ((unsigned int )intf->InterfaceID == (unsigned int )rr->resrec.InterfaceID) {
#line 2441
          break;
        }
#line 2440
        intf = intf->next;
      }
#line 2442
      if (! intf) {
#line 2445
        return (-65541);
      }
    }
  }
#line 2449
  rr->next = (AuthRecord *)0L;
#line 2462
  rr->Acknowledged = (unsigned char)0;
#line 2463
  if ((int )rr->resrec.RecordType == 2) {
#line 2463
    rr->ProbeCount = (unsigned char)3;
  } else {
#line 2463
    rr->ProbeCount = (unsigned char)0;
  }
#line 2464
  rr->AnnounceCount = (unsigned char)10;
#line 2465
  rr->IncludeInProbe = (unsigned char)0;
#line 2466
  rr->ImmedAnswer = (struct mDNSInterfaceID_dummystruct *)0L;
#line 2467
  rr->ImmedAdditional = (struct mDNSInterfaceID_dummystruct *)0L;
#line 2468
  rr->SendRNow = (struct mDNSInterfaceID_dummystruct *)0L;
#line 2469
  rr->v4Requester = (union __anonunion_mDNSOpaque32_19 )zeroIPAddr;
#line 2470
  rr->v6Requester = (union __anonunion_mDNSOpaque128_20 )zerov6Addr;
#line 2471
  rr->NextResponse = (AuthRecord *)0L;
#line 2472
  rr->NR_AnswerTo = (mDNSu8 const   *)0L;
#line 2473
  rr->NR_AdditionalTo = (AuthRecord *)0L;
#line 2474
  if ((int )rr->resrec.RecordType & 12) {
#line 2474
    rr->ThisAPInterval = mDNSPlatformOneSecond / 2;
  } else {
#line 2474
    if ((int )rr->resrec.RecordType & 2) {
#line 2474
      tmp___5 = mDNSPlatformOneSecond / 4;
    } else {
#line 2474
      if ((int )rr->resrec.RecordType & 48) {
#line 2474
        tmp___4 = mDNSPlatformOneSecond / 2;
      } else {
#line 2474
        tmp___4 = 0;
      }
#line 2474
      tmp___5 = tmp___4;
    }
#line 2474
    rr->ThisAPInterval = tmp___5;
  }
#line 2475
  InitializeLastAPTime(m, rr);
#line 2480
  rr->NewRData = (RData *)0L;
#line 2481
  rr->newrdlength = (unsigned short)0;
#line 2482
  rr->UpdateCallback = (mDNSRecordUpdateCallback *)0L;
#line 2483
  rr->UpdateCredits = 10U;
#line 2484
  rr->NextUpdateCredit = 0;
#line 2485
  rr->UpdateBlocked = 0;
#line 2494
  if (rr->HostTarget) {
#line 2496
    if (target) {
#line 2496
      target->c[0] = (unsigned char)0;
    }
#line 2497
    SetTargetToHostName(m, rr);
  } else {
#line 2501
    rr->resrec.rdlength = GetRDLength((ResourceRecord const   *)(& rr->resrec), 0);
#line 2502
    rr->resrec.rdestimate = GetRDLength((ResourceRecord const   *)(& rr->resrec),
                                        1);
  }
#line 2505
  tmp___7 = DomainNameLength((domainname const   *)(& rr->resrec.name));
#line 2505
  if (! ((int )tmp___7 <= 255)) {
#line 2506
    tmp___6 = GetRRDisplayString_rdb(m, (ResourceRecord const   *)(& rr->resrec),
                                     & (rr->resrec.rdata)->u);
#line 2506
    LogMsg("Attempt to register record with invalid name: %s", tmp___6);
#line 2506
    return (-65549);
  }
#line 2509
  tmp___9 = ValidateRData(rr->resrec.rrtype, rr->resrec.rdlength, (RData const   *)rr->resrec.rdata);
#line 2509
  if (! tmp___9) {
#line 2510
    tmp___8 = GetRRDisplayString_rdb(m, (ResourceRecord const   *)(& rr->resrec),
                                     & (rr->resrec.rdata)->u);
#line 2510
    LogMsg("Attempt to register record with invalid rdata: %s", tmp___8);
#line 2510
    return (-65549);
  }
#line 2512
  rr->resrec.namehash = DomainNameHashValue((domainname const   *)(& rr->resrec.name));
#line 2513
  rr->resrec.rdatahash = RDataHashValue(rr->resrec.rdlength, (RDataBody const   *)(& (rr->resrec.rdata)->u));
#line 2514
  if (target) {
#line 2514
    tmp___10 = DomainNameHashValue((domainname const   *)target);
#line 2514
    rr->resrec.rdnamehash = tmp___10;
  } else {
#line 2514
    rr->resrec.rdnamehash = 0U;
  }
#line 2516
  if ((unsigned int )rr->resrec.InterfaceID == (unsigned int )((struct mDNSInterfaceID_dummystruct *)-1)) {
#line 2519
    *l = rr;
#line 2520
    if (! m->NewLocalOnlyRecords) {
#line 2520
      m->NewLocalOnlyRecords = rr;
    }
#line 2522
    if ((int )rr->resrec.RecordType & 50) {
#line 2524
      if (rr->RRSet) {
#line 2524
        tmp___11 = rr->RRSet;
      } else {
#line 2524
        tmp___11 = rr;
      }
#line 2524
      s1 = (AuthRecord const   *)tmp___11;
#line 2525
      r = m->LocalOnlyRecords;
#line 2525
      while (r) {
#line 2527
        if (r->RRSet) {
#line 2527
          tmp___12 = r->RRSet;
        } else {
#line 2527
          tmp___12 = r;
        }
#line 2527
        s2 = (AuthRecord const   *)tmp___12;
#line 2528
        if ((unsigned int )s1 != (unsigned int )s2) {
#line 2528
          tmp___13 = SameResourceRecordSignature((ResourceRecord const   *)(& r->resrec),
                                                 (ResourceRecord const   *)(& rr->resrec));
#line 2528
          if (tmp___13) {
#line 2528
            tmp___14 = SameRData((ResourceRecord const   *)(& r->resrec), (ResourceRecord const   *)(& rr->resrec));
#line 2528
            if (! tmp___14) {
#line 2529
              break;
            }
          }
        }
#line 2525
        r = r->next;
      }
#line 2531
      if (r) {
#line 2534
        m->DiscardLocalOnlyRecords = 1;
      } else {
#line 2538
        rr->ProbeCount = (unsigned char)0;
#line 2539
        if ((int )rr->resrec.RecordType == 2) {
#line 2539
          rr->resrec.RecordType = (unsigned char)16;
        }
      }
    }
  } else {
#line 2546
    r = m->ResourceRecords;
#line 2546
    while (r) {
#line 2546
      if ((unsigned int )r->resrec.InterfaceID == (unsigned int )rr->resrec.InterfaceID) {
#line 2546
        if ((int )r->resrec.RecordType == (int )rr->resrec.RecordType) {
          goto _L;
        } else {
#line 2546
          if (((int )r->resrec.RecordType | (int )rr->resrec.RecordType) == 18) {
            _L: /* CIL Label */ 
#line 2546
            tmp___15 = IdenticalResourceRecord((ResourceRecord const   *)(& r->resrec),
                                               (ResourceRecord const   *)(& rr->resrec));
#line 2546
            if (tmp___15) {
#line 2546
              break;
            }
          }
        }
      }
#line 2546
      r = r->next;
    }
#line 2548
    if (r) {
#line 2551
      *d = rr;
#line 2556
      if ((int )rr->resrec.RecordType == 2) {
#line 2556
        if ((int )r->resrec.RecordType == 16) {
#line 2557
          rr->ProbeCount = (unsigned char)0;
        }
      }
    } else {
#line 2562
      *p = rr;
    }
  }
#line 2565
  return (0);
}
}
#line 2568 "mDNS.c"
static void RecordProbeFailure(mDNS *m , AuthRecord const   *rr ) 
{ char *tmp ;

  {
#line 2570
  m->ProbeFailTime = m->timenow;
#line 2571
  (m->NumFailedProbes) ++;
#line 2574
  if (m->NumFailedProbes >= 10) {
#line 2574
    m->SuppressProbes = (m->timenow + mDNSPlatformOneSecond * 5) | 1;
  }
#line 2575
  if (m->NumFailedProbes >= 16) {
#line 2576
    tmp = DNSTypeName((unsigned short )rr->resrec.rrtype);
#line 2576
    LogMsg("Name in use: %##s (%s); need to choose another (%d)", rr->resrec.name.c,
           tmp, m->NumFailedProbes);
  }
#line 2578
  return;
}
}
#line 2587 "mDNS.c"
static mStatus mDNS_Deregister_internal(mDNS *m , AuthRecord *rr , mDNS_Dereg_type drt ) 
{ mDNSu8 RecordType ;
  AuthRecord **p ;
  AuthRecord *r2 ;
  mDNSBool tmp ;
  AuthRecord **d ;
  mDNSBool tmp___0 ;
  AuthRecord *dup___0 ;
  RData *OldRData ;

  {
#line 2589
  RecordType = rr->resrec.RecordType;
#line 2590
  p = & m->ResourceRecords;
#line 2591
  if ((unsigned int )rr->resrec.InterfaceID == (unsigned int )((struct mDNSInterfaceID_dummystruct *)-1)) {
#line 2591
    p = & m->LocalOnlyRecords;
  }
#line 2592
  while (1) {
#line 2592
    if (*p) {
#line 2592
      if (! ((unsigned int )*p != (unsigned int )rr)) {
#line 2592
        break;
      }
    } else {
#line 2592
      break;
    }
#line 2592
    p = & (*p)->next;
  }
#line 2594
  if (*p) {
#line 2597
    if ((int )drt == 1) {
#line 2599
      r2 = m->DuplicateRecords;
#line 2600
      while (r2) {
#line 2602
        if ((unsigned int )r2->resrec.InterfaceID == (unsigned int )rr->resrec.InterfaceID) {
#line 2602
          if ((int )r2->resrec.RecordType == (int )rr->resrec.RecordType) {
            goto _L;
          } else {
#line 2602
            if (((int )r2->resrec.RecordType | (int )rr->resrec.RecordType) == 18) {
              _L: /* CIL Label */ 
#line 2602
              tmp = IdenticalResourceRecord((ResourceRecord const   *)(& r2->resrec),
                                            (ResourceRecord const   *)(& rr->resrec));
#line 2602
              if (tmp) {
#line 2602
                mDNS_Deregister_internal(m, r2, drt);
#line 2602
                r2 = m->DuplicateRecords;
              } else {
#line 2603
                r2 = r2->next;
              }
            } else {
#line 2603
              r2 = r2->next;
            }
          }
        } else {
#line 2603
          r2 = r2->next;
        }
      }
    } else {
#line 2610
      d = & m->DuplicateRecords;
#line 2611
      while (1) {
#line 2611
        if (*d) {
#line 2611
          if ((unsigned int )(*d)->resrec.InterfaceID == (unsigned int )rr->resrec.InterfaceID) {
#line 2611
            if ((int )(*d)->resrec.RecordType == (int )rr->resrec.RecordType) {
              goto _L___0;
            } else {
#line 2611
              if (((int )(*d)->resrec.RecordType | (int )rr->resrec.RecordType) == 18) {
                _L___0: /* CIL Label */ 
#line 2611
                tmp___0 = IdenticalResourceRecord((ResourceRecord const   *)(& (*d)->resrec),
                                                  (ResourceRecord const   *)(& rr->resrec));
#line 2611
                if (tmp___0) {
#line 2611
                  break;
                }
              }
            }
          }
        } else {
#line 2611
          break;
        }
#line 2611
        d = & (*d)->next;
      }
#line 2612
      if (*d) {
#line 2614
        dup___0 = *d;
#line 2616
        *d = dup___0->next;
#line 2617
        dup___0->next = rr->next;
#line 2618
        rr->next = dup___0;
#line 2619
        dup___0->resrec.RecordType = rr->resrec.RecordType;
#line 2620
        dup___0->ProbeCount = rr->ProbeCount;
#line 2621
        dup___0->AnnounceCount = rr->AnnounceCount;
#line 2622
        dup___0->ImmedAnswer = rr->ImmedAnswer;
#line 2623
        dup___0->ImmedAdditional = rr->ImmedAdditional;
#line 2624
        dup___0->v4Requester = rr->v4Requester;
#line 2625
        dup___0->v6Requester = rr->v6Requester;
#line 2626
        dup___0->ThisAPInterval = rr->ThisAPInterval;
#line 2627
        dup___0->AnnounceUntil = rr->AnnounceUntil;
#line 2628
        dup___0->LastAPTime = rr->LastAPTime;
#line 2629
        dup___0->LastMCTime = rr->LastMCTime;
#line 2630
        dup___0->LastMCInterface = rr->LastMCInterface;
#line 2631
        if ((int )RecordType == 8) {
#line 2631
          rr->AnnounceCount = (unsigned char)10;
        }
      }
    }
  } else {
#line 2638
    p = & m->DuplicateRecords;
#line 2639
    while (1) {
#line 2639
      if (*p) {
#line 2639
        if (! ((unsigned int )*p != (unsigned int )rr)) {
#line 2639
          break;
        }
      } else {
#line 2639
        break;
      }
#line 2639
      p = & (*p)->next;
    }
#line 2641
    if (*p) {
#line 2641
      if ((int )RecordType == 8) {
#line 2641
        rr->AnnounceCount = (unsigned char)10;
      }
    }
#line 2642
    if (*p) {

    }
  }
#line 2645
  if (! *p) {
#line 2648
    if ((int )drt != 2) {

    }
#line 2650
    return (-65541);
  }
#line 2655
  if ((int )RecordType == 8) {
#line 2655
    if ((int )rr->AnnounceCount < 10) {
#line 2658
      rr->resrec.RecordType = (unsigned char)1;
#line 2659
      rr->resrec.rroriginalttl = 0U;
#line 2660
      rr->ImmedAnswer = (struct mDNSInterfaceID_dummystruct *)mDNSInterfaceMark;
#line 2661
      if ((unsigned int )rr->resrec.InterfaceID == (unsigned int )((struct mDNSInterfaceID_dummystruct *)-1)) {
#line 2662
        m->DiscardLocalOnlyRecords = 1;
      } else {
#line 2665
        if (m->NextScheduledResponse - (m->timenow + mDNSPlatformOneSecond / 10) >= 0) {
#line 2666
          m->NextScheduledResponse = m->timenow + mDNSPlatformOneSecond / 10;
        }
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 2671
    *p = rr->next;
#line 2673
    if ((unsigned int )m->CurrentRecord == (unsigned int )rr) {
#line 2673
      m->CurrentRecord = rr->next;
    }
#line 2674
    if ((unsigned int )m->NewLocalOnlyRecords == (unsigned int )rr) {
#line 2674
      m->NewLocalOnlyRecords = rr->next;
    }
#line 2675
    rr->next = (AuthRecord *)0L;
#line 2677
    if (! ((int )RecordType == 0)) {
#line 2680
      if (! ((int )RecordType == 1)) {
#line 2686
        rr->resrec.RecordType = (unsigned char)0;
      }
    }
#line 2689
    if ((int )drt == 1) {
      goto _L___1;
    } else {
#line 2689
      if ((int )drt == 2) {
        _L___1: /* CIL Label */ 
#line 2689
        if ((int )RecordType == 8) {

        }
      }
    }
#line 2694
    if (rr->NewRData) {
#line 2696
      OldRData = rr->resrec.rdata;
#line 2697
      SetNewRData(& rr->resrec, rr->NewRData, rr->newrdlength);
#line 2698
      rr->NewRData = (RData *)0L;
#line 2699
      if (rr->UpdateCallback) {
#line 2700
        (*(rr->UpdateCallback))(m, rr, OldRData);
      }
    }
#line 2707
    (m->mDNS_reentrancy) ++;
#line 2708
    if ((int )RecordType == 8) {
#line 2710
      if (rr->RecordCallback) {
#line 2711
        (*(rr->RecordCallback))(m, rr, -65792);
      }
    } else {
#line 2713
      if ((int )drt == 1) {
#line 2715
        RecordProbeFailure(m, (AuthRecord const   *)rr);
#line 2716
        if (rr->RecordCallback) {
#line 2717
          (*(rr->RecordCallback))(m, rr, -65548);
        }
      }
    }
#line 2719
    (m->mDNS_reentrancy) --;
  }
#line 2721
  return (0);
}
}
#line 2731 "mDNS.c"
static void InitializeDNSMessage(DNSMessageHeader *h , mDNSOpaque16 id , mDNSOpaque16 flags ) 
{ 

  {
#line 2733
  h->id = id;
#line 2734
  h->flags = flags;
#line 2735
  h->numQuestions = (unsigned short)0;
#line 2736
  h->numAnswers = (unsigned short)0;
#line 2737
  h->numAuthorities = (unsigned short)0;
#line 2738
  h->numAdditionals = (unsigned short)0;
#line 2739
  return;
}
}
#line 2741 "mDNS.c"
static mDNSu8 const   *FindCompressionPointer(mDNSu8 const   *base , mDNSu8 const   *end ,
                                              mDNSu8 const   *domname ) 
{ mDNSu8 const   *result ;
  mDNSu8 const   *name ;
  mDNSu8 const   *targ ;
  int i ;
  mDNSu8 const   *pointertarget ;

  {
#line 2743
  result = (end - (int const   )*domname) - 1;
#line 2745
  if ((int const   )*domname == 0) {
#line 2745
    return ((mDNSu8 const   *)0L);
  }
#line 2748
  while ((unsigned int )result >= (unsigned int )base) {
#line 2752
    if ((int const   )*(result + 0) == (int const   )*(domname + 0)) {
#line 2752
      if ((int const   )*(result + 1) == (int const   )*(domname + 1)) {
#line 2754
        name = domname;
#line 2755
        targ = result;
#line 2756
        while ((unsigned int )(targ + (int const   )*name) < (unsigned int )end) {
#line 2761
          i = 0;
#line 2761
          while (i <= (int )*name) {
#line 2761
            if ((int const   )*(targ + i) != (int const   )*(name + i)) {
#line 2761
              break;
            }
#line 2761
            i ++;
          }
#line 2762
          if (i <= (int )*name) {
#line 2762
            break;
          }
#line 2763
          targ += 1 + (int )*name;
#line 2764
          name += 1 + (int )*name;
#line 2765
          if ((int const   )*name == 0) {
#line 2765
            if ((int const   )*targ == 0) {
#line 2765
              return (result);
            }
          }
#line 2766
          if ((int const   )*name == 0) {
#line 2766
            break;
          }
#line 2769
          if ((int const   )*(targ + 0) < 64) {
#line 2769
            continue;
          }
#line 2770
          if ((int const   )*(targ + 0) < 192) {
#line 2770
            break;
          }
#line 2771
          if ((unsigned int )(targ + 1) >= (unsigned int )end) {
#line 2771
            break;
          }
#line 2772
          pointertarget = (base + ((int )((unsigned short )((int const   )*(targ + 0) & 63)) << 8)) + (int const   )*(targ + 1);
#line 2773
          if ((unsigned int )targ < (unsigned int )pointertarget) {
#line 2773
            break;
          }
#line 2774
          if ((int const   )*(pointertarget + 0) >= 64) {
#line 2774
            break;
          }
#line 2775
          targ = pointertarget;
        }
      }
    }
#line 2778
    result --;
  }
#line 2780
  return ((mDNSu8 const   *)0L);
}
}
#line 2790 "mDNS.c"
static mDNSu8 *putDomainNameAsLabels(DNSMessage const   *msg , mDNSu8 *ptr , mDNSu8 const   *limit ,
                                     domainname const   *name ) 
{ mDNSu8 const   *base ;
  mDNSu8 const   *np ;
  mDNSu8 const   *max ;
  mDNSu8 const   *pointer ;
  mDNSu8 const   *searchlimit ;
  mDNSu16 offset ;
  mDNSu8 *tmp ;
  mDNSu8 *tmp___0 ;
  int i ;
  mDNSu8 len ;
  mDNSu8 const   *tmp___1 ;
  mDNSu8 *tmp___2 ;
  mDNSu8 *tmp___3 ;
  mDNSu8 const   *tmp___4 ;
  mDNSu8 *tmp___5 ;

  {
#line 2793
  base = (mDNSu8 const   *)msg;
#line 2794
  np = (mDNSu8 const   *)(name->c);
#line 2795
  max = (mDNSu8 const   *)(name->c + 255);
#line 2796
  pointer = (mDNSu8 const   *)0L;
#line 2797
  searchlimit = (mDNSu8 const   *)ptr;
#line 2799
  while (1) {
#line 2799
    if (*np) {
#line 2799
      if (! ((unsigned int )ptr < (unsigned int )(limit - 1))) {
#line 2799
        break;
      }
    } else {
#line 2799
      break;
    }
#line 2801
    if ((int const   )*np > 63) {
#line 2802
      LogMsg("Malformed domain name %##s (label more than 63 bytes)", name->c);
#line 2802
      return ((mDNSu8 *)0L);
    }
#line 2813
    if ((unsigned int )((np + 1) + (int const   )*np) >= (unsigned int )max) {
#line 2814
      LogMsg("Malformed domain name %##s (more than 255 bytes)", name->c);
#line 2814
      return ((mDNSu8 *)0L);
    }
#line 2816
    if (base) {
#line 2816
      pointer = FindCompressionPointer(base, searchlimit, np);
    }
#line 2817
    if (pointer) {
#line 2819
      offset = (unsigned short )(pointer - base);
#line 2820
      tmp = ptr;
#line 2820
      ptr ++;
#line 2820
      *tmp = (unsigned char )(192 | ((int )offset >> 8));
#line 2821
      tmp___0 = ptr;
#line 2821
      ptr ++;
#line 2821
      *tmp___0 = (unsigned char )offset;
#line 2822
      return (ptr);
    } else {
#line 2827
      tmp___1 = np;
#line 2827
      np ++;
#line 2827
      len = (mDNSu8 )*tmp___1;
#line 2828
      if ((unsigned int )((ptr + 1) + (int )len) >= (unsigned int )limit) {
#line 2828
        return ((mDNSu8 *)0L);
      }
#line 2829
      tmp___2 = ptr;
#line 2829
      ptr ++;
#line 2829
      *tmp___2 = len;
#line 2830
      i = 0;
#line 2830
      while (i < (int )len) {
#line 2830
        tmp___3 = ptr;
#line 2830
        ptr ++;
#line 2830
        tmp___4 = np;
#line 2830
        np ++;
#line 2830
        *tmp___3 = (unsigned char )*tmp___4;
#line 2830
        i ++;
      }
    }
  }
#line 2834
  if ((unsigned int )ptr < (unsigned int )limit) {
#line 2836
    tmp___5 = ptr;
#line 2836
    ptr ++;
#line 2836
    *tmp___5 = (unsigned char)0;
#line 2837
    return (ptr);
  }
#line 2840
  return ((mDNSu8 *)0L);
}
}
#line 2843 "mDNS.c"
static mDNSu8 *putRData(DNSMessage const   *msg , mDNSu8 *ptr , mDNSu8 const   *limit ,
                        ResourceRecord *rr ) 
{ mDNSu8 *tmp ;
  mDNSu8 *tmp___0 ;
  mDNSu8 *tmp___1 ;
  mDNSu8 *tmp___2 ;
  mDNSu8 *tmp___3 ;
  mDNSu8 *tmp___4 ;
  mDNSu8 *tmp___5 ;
  mDNSu8 *tmp___6 ;
  mDNSu8 *tmp___7 ;
  mDNSu8 *tmp___8 ;
  mDNSu8 *tmp___9 ;
  mDNSu8 *tmp___10 ;

  {
#line 2845
  switch ((int )rr->rrtype) {
  case 1: 
#line 2847
  if ((int )rr->rdlength != 4) {
#line 2850
    return ((mDNSu8 *)0L);
  }
#line 2852
  if ((unsigned int )(ptr + 4) > (unsigned int )limit) {
#line 2852
    return ((mDNSu8 *)0L);
  }
#line 2853
  tmp = ptr;
#line 2853
  ptr ++;
#line 2853
  *tmp = (rr->rdata)->u.ip.b[0];
#line 2854
  tmp___0 = ptr;
#line 2854
  ptr ++;
#line 2854
  *tmp___0 = (rr->rdata)->u.ip.b[1];
#line 2855
  tmp___1 = ptr;
#line 2855
  ptr ++;
#line 2855
  *tmp___1 = (rr->rdata)->u.ip.b[2];
#line 2856
  tmp___2 = ptr;
#line 2856
  ptr ++;
#line 2856
  *tmp___2 = (rr->rdata)->u.ip.b[3];
#line 2857
  return (ptr);
  case 5: 
  case 12: 
#line 2860
  tmp___3 = putDomainNameAsLabels(msg, ptr, limit, (domainname const   *)(& (rr->rdata)->u.name));
#line 2860
  return (tmp___3);
  case 13: 
  case 16: 
#line 2863
  if ((unsigned int )(ptr + (int )rr->rdlength) > (unsigned int )limit) {
#line 2863
    return ((mDNSu8 *)0L);
  }
#line 2864
  mDNSPlatformMemCopy((void const   *)((rr->rdata)->u.data), (void *)ptr, (unsigned int )rr->rdlength);
#line 2865
  return (ptr + (int )rr->rdlength);
  case 28: 
#line 2867
  if ((unsigned int )rr->rdlength != sizeof((rr->rdata)->u.ipv6)) {
#line 2870
    return ((mDNSu8 *)0L);
  }
#line 2872
  if ((unsigned int )(ptr + sizeof((rr->rdata)->u.ipv6)) > (unsigned int )limit) {
#line 2872
    return ((mDNSu8 *)0L);
  }
#line 2873
  mDNSPlatformMemCopy((void const   *)(& (rr->rdata)->u.ipv6), (void *)ptr, sizeof((rr->rdata)->u.ipv6));
#line 2874
  return (ptr + sizeof((rr->rdata)->u.ipv6));
  case 33: 
#line 2876
  if ((unsigned int )(ptr + 6) > (unsigned int )limit) {
#line 2876
    return ((mDNSu8 *)0L);
  }
#line 2877
  tmp___4 = ptr;
#line 2877
  ptr ++;
#line 2877
  *tmp___4 = (unsigned char )((int )(rr->rdata)->u.srv.priority >> 8);
#line 2878
  tmp___5 = ptr;
#line 2878
  ptr ++;
#line 2878
  *tmp___5 = (unsigned char )(rr->rdata)->u.srv.priority;
#line 2879
  tmp___6 = ptr;
#line 2879
  ptr ++;
#line 2879
  *tmp___6 = (unsigned char )((int )(rr->rdata)->u.srv.weight >> 8);
#line 2880
  tmp___7 = ptr;
#line 2880
  ptr ++;
#line 2880
  *tmp___7 = (unsigned char )(rr->rdata)->u.srv.weight;
#line 2881
  tmp___8 = ptr;
#line 2881
  ptr ++;
#line 2881
  *tmp___8 = (rr->rdata)->u.srv.port.b[0];
#line 2882
  tmp___9 = ptr;
#line 2882
  ptr ++;
#line 2882
  *tmp___9 = (rr->rdata)->u.srv.port.b[1];
#line 2883
  tmp___10 = putDomainNameAsLabels(msg, ptr, limit, (domainname const   *)(& (rr->rdata)->u.srv.target));
#line 2883
  return (tmp___10);
  default: ;
#line 2885
  if ((unsigned int )(ptr + (int )rr->rdlength) > (unsigned int )limit) {
#line 2885
    return ((mDNSu8 *)0L);
  }
#line 2887
  mDNSPlatformMemCopy((void const   *)((rr->rdata)->u.data), (void *)ptr, (unsigned int )rr->rdlength);
#line 2888
  return (ptr + (int )rr->rdlength);
  }
}
}
#line 2892 "mDNS.c"
static mDNSu8 *PutResourceRecordTTL(DNSMessage *msg , mDNSu8 *ptr , mDNSu16 *count ,
                                    ResourceRecord *rr , mDNSu32 ttl ) 
{ mDNSu8 *endofrdata ;
  mDNSu16 actualLength ;
  mDNSu8 const   *limit ;
  char *tmp ;

  {
#line 2896
  limit = (mDNSu8 const   *)(msg->data + 8940);
#line 2900
  if (msg->h.numAnswers) {
#line 2901
    limit = (mDNSu8 const   *)(msg->data + 1440);
  } else {
#line 2900
    if (msg->h.numAuthorities) {
#line 2901
      limit = (mDNSu8 const   *)(msg->data + 1440);
    } else {
#line 2900
      if (msg->h.numAdditionals) {
#line 2901
        limit = (mDNSu8 const   *)(msg->data + 1440);
      }
    }
  }
#line 2903
  if ((int )rr->RecordType == 0) {
#line 2905
    tmp = DNSTypeName(rr->rrtype);
#line 2905
    LogMsg("PutResourceRecord ERROR! Attempt to put kDNSRecordTypeUnregistered %##s (%s)",
           rr->name.c, tmp);
#line 2906
    return (ptr);
  }
#line 2909
  ptr = putDomainNameAsLabels((DNSMessage const   *)msg, ptr, limit, (domainname const   *)(& rr->name));
#line 2910
  if (! ptr) {
#line 2910
    return ((mDNSu8 *)0L);
  } else {
#line 2910
    if ((unsigned int )(ptr + 10) >= (unsigned int )limit) {
#line 2910
      return ((mDNSu8 *)0L);
    }
  }
#line 2911
  *(ptr + 0) = (unsigned char )((int )rr->rrtype >> 8);
#line 2912
  *(ptr + 1) = (unsigned char )rr->rrtype;
#line 2913
  *(ptr + 2) = (unsigned char )((int )rr->rrclass >> 8);
#line 2914
  *(ptr + 3) = (unsigned char )rr->rrclass;
#line 2915
  *(ptr + 4) = (unsigned char )(ttl >> 24);
#line 2916
  *(ptr + 5) = (unsigned char )(ttl >> 16);
#line 2917
  *(ptr + 6) = (unsigned char )(ttl >> 8);
#line 2918
  *(ptr + 7) = (unsigned char )ttl;
#line 2919
  endofrdata = putRData((DNSMessage const   *)msg, ptr + 10, limit, rr);
#line 2920
  if (! endofrdata) {
#line 2920
    return ((mDNSu8 *)0L);
  }
#line 2924
  actualLength = (unsigned short )((endofrdata - ptr) - 10);
#line 2925
  *(ptr + 8) = (unsigned char )((int )actualLength >> 8);
#line 2926
  *(ptr + 9) = (unsigned char )actualLength;
#line 2928
  *count = (mDNSu16 )((int )*count + 1);
#line 2929
  return (endofrdata);
}
}
#line 2934 "mDNS.c"
static mDNSu8 *PutResourceRecordCappedTTL(DNSMessage *msg , mDNSu8 *ptr , mDNSu16 *count ,
                                          ResourceRecord *rr , mDNSu32 maxttl ) 
{ mDNSu8 *tmp ;

  {
#line 2936
  if (maxttl > rr->rroriginalttl) {
#line 2936
    maxttl = rr->rroriginalttl;
  }
#line 2937
  tmp = PutResourceRecordTTL(msg, ptr, count, rr, maxttl);
#line 2937
  return (tmp);
}
}
#line 2957 "mDNS.c"
static mDNSu8 *putQuestion(DNSMessage *msg , mDNSu8 *ptr , mDNSu8 const   *limit ,
                           domainname const   *name , mDNSu16 rrtype , mDNSu16 rrclass ) 
{ 

  {
#line 2960
  ptr = putDomainNameAsLabels((DNSMessage const   *)msg, ptr, limit, name);
#line 2961
  if (! ptr) {
#line 2961
    return ((mDNSu8 *)0L);
  } else {
#line 2961
    if ((unsigned int )(ptr + 4) >= (unsigned int )limit) {
#line 2961
      return ((mDNSu8 *)0L);
    }
  }
#line 2962
  *(ptr + 0) = (unsigned char )((int )rrtype >> 8);
#line 2963
  *(ptr + 1) = (unsigned char )rrtype;
#line 2964
  *(ptr + 2) = (unsigned char )((int )rrclass >> 8);
#line 2965
  *(ptr + 3) = (unsigned char )rrclass;
#line 2966
  msg->h.numQuestions = (mDNSu16 )((int )msg->h.numQuestions + 1);
#line 2967
  return (ptr + 4);
}
}
#line 2976 "mDNS.c"
static mDNSu8 const   *skipDomainName(DNSMessage const   *msg , mDNSu8 const   *ptr ,
                                      mDNSu8 const   *end ) 
{ mDNSu16 total ;
  mDNSu8 len ;
  mDNSu8 const   *tmp ;

  {
#line 2978
  total = (mDNSu16 )0;
#line 2980
  if ((unsigned int )ptr < (unsigned int )((mDNSu8 *)msg)) {
#line 2981
    return ((mDNSu8 const   *)0L);
  } else {
#line 2980
    if ((unsigned int )ptr >= (unsigned int )end) {
#line 2981
      return ((mDNSu8 const   *)0L);
    }
  }
#line 2983
  while (1) {
#line 2985
    tmp = ptr;
#line 2985
    ptr ++;
#line 2985
    len = (mDNSu8 )*tmp;
#line 2986
    if ((int )len == 0) {
#line 2986
      return (ptr);
    }
#line 2987
    switch ((int )len & 192) {
    case 0: 
#line 2989
    if ((unsigned int )(ptr + (int )len) >= (unsigned int )end) {
#line 2990
      return ((mDNSu8 const   *)0L);
    }
#line 2991
    if (((int )total + 1) + (int )len >= 255) {
#line 2992
      return ((mDNSu8 const   *)0L);
    }
#line 2993
    ptr += (int )len;
#line 2994
    total = (unsigned short )((int )total + (1 + (int )len));
#line 2995
    break;
    case 64: ;
#line 2997
    return ((mDNSu8 const   *)0L);
    case 128: ;
#line 2998
    return ((mDNSu8 const   *)0L);
    case 192: 
#line 2999
    return (ptr + 1);
    }
  }
}
}
#line 3005 "mDNS.c"
static mDNSu8 const   *getDomainName(DNSMessage const   *msg , mDNSu8 const   *ptr ,
                                     mDNSu8 const   *end , domainname *name ) 
{ mDNSu8 const   *nextbyte ;
  mDNSu8 *np ;
  mDNSu8 const   *limit ;
  mDNSu8 len ;
  mDNSu8 const   *tmp ;
  int i ;
  mDNSu16 offset ;
  mDNSu8 *tmp___0 ;
  mDNSu8 *tmp___1 ;
  mDNSu8 const   *tmp___2 ;
  mDNSu8 const   *tmp___3 ;

  {
#line 3008
  nextbyte = (mDNSu8 const   *)0L;
#line 3009
  np = name->c;
#line 3010
  limit = (mDNSu8 const   *)(np + 255);
#line 3012
  if ((unsigned int )ptr < (unsigned int )((mDNSu8 *)msg)) {
#line 3013
    return ((mDNSu8 const   *)0L);
  } else {
#line 3012
    if ((unsigned int )ptr >= (unsigned int )end) {
#line 3013
      return ((mDNSu8 const   *)0L);
    }
  }
#line 3015
  *np = (unsigned char)0;
#line 3017
  while (1) {
#line 3019
    tmp = ptr;
#line 3019
    ptr ++;
#line 3019
    len = (mDNSu8 )*tmp;
#line 3020
    if ((int )len == 0) {
#line 3020
      break;
    }
#line 3021
    switch ((int )len & 192) {
    case 0: 
#line 3026
    if ((unsigned int )(ptr + (int )len) >= (unsigned int )end) {
#line 3027
      return ((mDNSu8 const   *)0L);
    }
#line 3028
    if ((unsigned int )((np + 1) + (int )len) >= (unsigned int )limit) {
#line 3029
      return ((mDNSu8 const   *)0L);
    }
#line 3030
    tmp___0 = np;
#line 3030
    np ++;
#line 3030
    *tmp___0 = len;
#line 3031
    i = 0;
#line 3031
    while (i < (int )len) {
#line 3031
      tmp___1 = np;
#line 3031
      np ++;
#line 3031
      tmp___2 = ptr;
#line 3031
      ptr ++;
#line 3031
      *tmp___1 = (unsigned char )*tmp___2;
#line 3031
      i ++;
    }
#line 3032
    *np = (unsigned char)0;
#line 3033
    break;
    case 64: ;
#line 3036
    return ((mDNSu8 const   *)0L);
    case 128: ;
#line 3038
    return ((mDNSu8 const   *)0L);
    case 192: 
#line 3040
    tmp___3 = ptr;
#line 3040
    ptr ++;
#line 3040
    offset = (unsigned short )(((int )((unsigned short )((int )len & 63)) << 8) | (int )*tmp___3);
#line 3041
    if (! nextbyte) {
#line 3041
      nextbyte = ptr;
    }
#line 3042
    ptr = (mDNSu8 const   *)((mDNSu8 *)msg + (int )offset);
#line 3043
    if ((unsigned int )ptr < (unsigned int )((mDNSu8 *)msg)) {
#line 3044
      return ((mDNSu8 const   *)0L);
    } else {
#line 3043
      if ((unsigned int )ptr >= (unsigned int )end) {
#line 3044
        return ((mDNSu8 const   *)0L);
      }
    }
#line 3045
    if ((int const   )*ptr & 192) {
#line 3046
      return ((mDNSu8 const   *)0L);
    }
#line 3047
    break;
    }
  }
#line 3051
  if (nextbyte) {
#line 3051
    return (nextbyte);
  } else {
#line 3052
    return (ptr);
  }
}
}
#line 3055 "mDNS.c"
static mDNSu8 const   *skipResourceRecord(DNSMessage const   *msg , mDNSu8 const   *ptr ,
                                          mDNSu8 const   *end ) 
{ mDNSu16 pktrdlength ;

  {
#line 3059
  ptr = skipDomainName(msg, ptr, end);
#line 3060
  if (! ptr) {
#line 3060
    return ((mDNSu8 const   *)0L);
  }
#line 3062
  if ((unsigned int )(ptr + 10) > (unsigned int )end) {
#line 3062
    return ((mDNSu8 const   *)0L);
  }
#line 3063
  pktrdlength = (unsigned short )(((int )((unsigned short )*(ptr + 8)) << 8) | (int )*(ptr + 9));
#line 3064
  ptr += 10;
#line 3065
  if ((unsigned int )(ptr + (int )pktrdlength) > (unsigned int )end) {
#line 3065
    return ((mDNSu8 const   *)0L);
  }
#line 3067
  return (ptr + (int )pktrdlength);
}
}
#line 3073 "mDNS.c"
static mDNSu8 const   *GetResourceRecord(mDNS *m , DNSMessage const   *msg , mDNSu8 const   *ptr ,
                                         mDNSu8 const   *end , mDNSInterfaceID InterfaceID ,
                                         mDNSu8 RecordType , CacheRecord *rr , RData *RDataStorage ) 
{ mDNSu16 pktrdlength ;
  mDNSu8 const   *tmp ;
  mDNSu8 const   *tmp___0 ;

  {
#line 3078
  rr->next = (CacheRecord *)0L;
#line 3079
  rr->resrec.RecordType = RecordType;
#line 3081
  rr->NextInKAList = (CacheRecord *)0L;
#line 3082
  rr->TimeRcvd = m->timenow;
#line 3083
  rr->NextRequiredQuery = m->timenow;
#line 3084
  rr->LastUsed = m->timenow;
#line 3085
  rr->UseCount = 0U;
#line 3086
  rr->CRActiveQuestion = (DNSQuestion *)0L;
#line 3087
  rr->UnansweredQueries = 0U;
#line 3088
  rr->LastUnansweredTime = 0;
#line 3089
  rr->MPUnansweredQ = 0U;
#line 3090
  rr->MPLastUnansweredQT = 0;
#line 3091
  rr->MPUnansweredKA = 0U;
#line 3092
  rr->MPExpectingKA = 0;
#line 3093
  rr->NextInCFList = (CacheRecord *)0L;
#line 3095
  rr->resrec.InterfaceID = InterfaceID;
#line 3096
  ptr = getDomainName(msg, ptr, end, & rr->resrec.name);
#line 3097
  if (! ptr) {
#line 3097
    return ((mDNSu8 const   *)0L);
  }
#line 3099
  if ((unsigned int )(ptr + 10) > (unsigned int )end) {
#line 3099
    return ((mDNSu8 const   *)0L);
  }
#line 3101
  rr->resrec.rrtype = (unsigned short )(((int )((unsigned short )*(ptr + 0)) << 8) | (int )*(ptr + 1));
#line 3102
  rr->resrec.rrclass = (unsigned short )((((int )((unsigned short )*(ptr + 2)) << 8) | (int )*(ptr + 3)) & 32767);
#line 3103
  rr->resrec.rroriginalttl = ((((unsigned int )*(ptr + 4) << 24) | ((unsigned int )*(ptr + 5) << 16)) | ((unsigned int )*(ptr + 6) << 8)) | (unsigned int )*(ptr + 7);
#line 3104
  if ((unsigned long )rr->resrec.rroriginalttl > 1879048192UL / (unsigned long )mDNSPlatformOneSecond) {
#line 3105
    rr->resrec.rroriginalttl = (unsigned int )(1879048192UL / (unsigned long )mDNSPlatformOneSecond);
  }
#line 3108
  pktrdlength = (unsigned short )(((int )((unsigned short )*(ptr + 8)) << 8) | (int )*(ptr + 9));
#line 3109
  if ((int const   )*(ptr + 2) & (int const   )(32768 >> 8)) {
#line 3110
    rr->resrec.RecordType = (unsigned char )((int )rr->resrec.RecordType | 32);
  }
#line 3111
  ptr += 10;
#line 3112
  if ((unsigned int )(ptr + (int )pktrdlength) > (unsigned int )end) {
#line 3112
    return ((mDNSu8 const   *)0L);
  }
#line 3114
  if (RDataStorage) {
#line 3115
    rr->resrec.rdata = RDataStorage;
  } else {
#line 3118
    rr->resrec.rdata = (RData *)(& rr->rdatastorage);
#line 3119
    (rr->resrec.rdata)->MaxRDLength = (unsigned short )sizeof(RDataBody );
  }
#line 3122
  switch ((int )rr->resrec.rrtype) {
  case 1: 
#line 3124
  (rr->resrec.rdata)->u.ip.b[0] = (unsigned char )*(ptr + 0);
#line 3125
  (rr->resrec.rdata)->u.ip.b[1] = (unsigned char )*(ptr + 1);
#line 3126
  (rr->resrec.rdata)->u.ip.b[2] = (unsigned char )*(ptr + 2);
#line 3127
  (rr->resrec.rdata)->u.ip.b[3] = (unsigned char )*(ptr + 3);
#line 3128
  break;
  case 5: 
  case 12: 
#line 3131
  tmp = getDomainName(msg, ptr, end, & (rr->resrec.rdata)->u.name);
#line 3131
  if (! tmp) {
#line 3132
    return ((mDNSu8 const   *)0L);
  }
#line 3134
  break;
  case 10: 
  case 13: 
  case 16: 
#line 3138
  if ((int )pktrdlength > (int )(rr->resrec.rdata)->MaxRDLength) {
#line 3142
    return ((mDNSu8 const   *)0L);
  }
#line 3144
  rr->resrec.rdlength = pktrdlength;
#line 3145
  mDNSPlatformMemCopy((void const   *)ptr, (void *)((rr->resrec.rdata)->u.data), (unsigned int )pktrdlength);
#line 3146
  break;
  case 28: 
#line 3148
  mDNSPlatformMemCopy((void const   *)ptr, (void *)(& (rr->resrec.rdata)->u.ipv6),
                      sizeof((rr->resrec.rdata)->u.ipv6));
#line 3149
  break;
  case 33: 
#line 3151
  (rr->resrec.rdata)->u.srv.priority = (unsigned short )(((int )((unsigned short )*(ptr + 0)) << 8) | (int )*(ptr + 1));
#line 3152
  (rr->resrec.rdata)->u.srv.weight = (unsigned short )(((int )((unsigned short )*(ptr + 2)) << 8) | (int )*(ptr + 3));
#line 3153
  (rr->resrec.rdata)->u.srv.port.b[0] = (unsigned char )*(ptr + 4);
#line 3154
  (rr->resrec.rdata)->u.srv.port.b[1] = (unsigned char )*(ptr + 5);
#line 3155
  tmp___0 = getDomainName(msg, ptr + 6, end, & (rr->resrec.rdata)->u.srv.target);
#line 3155
  if (! tmp___0) {
#line 3156
    return ((mDNSu8 const   *)0L);
  }
#line 3158
  break;
  default: ;
#line 3160
  if ((int )pktrdlength > (int )(rr->resrec.rdata)->MaxRDLength) {
#line 3164
    return ((mDNSu8 const   *)0L);
  }
#line 3173
  rr->resrec.rdlength = pktrdlength;
#line 3174
  mDNSPlatformMemCopy((void const   *)ptr, (void *)((rr->resrec.rdata)->u.data), (unsigned int )pktrdlength);
#line 3175
  break;
  }
#line 3178
  rr->resrec.namehash = DomainNameHashValue((domainname const   *)(& rr->resrec.name));
#line 3179
  SetNewRData(& rr->resrec, (RData *)0L, (unsigned short)0);
#line 3181
  return (ptr + (int )pktrdlength);
}
}
#line 3184 "mDNS.c"
static mDNSu8 const   *skipQuestion(DNSMessage const   *msg , mDNSu8 const   *ptr ,
                                    mDNSu8 const   *end ) 
{ 

  {
#line 3186
  ptr = skipDomainName(msg, ptr, end);
#line 3187
  if (! ptr) {
#line 3187
    return ((mDNSu8 const   *)0L);
  }
#line 3188
  if ((unsigned int )(ptr + 4) > (unsigned int )end) {
#line 3188
    return ((mDNSu8 const   *)0L);
  }
#line 3189
  return (ptr + 4);
}
}
#line 3192 "mDNS.c"
static mDNSu8 const   *getQuestion(DNSMessage const   *msg , mDNSu8 const   *ptr ,
                                   mDNSu8 const   *end , mDNSInterfaceID InterfaceID ,
                                   DNSQuestion *question ) 
{ 

  {
#line 3195
  question->InterfaceID = InterfaceID;
#line 3196
  ptr = getDomainName(msg, ptr, end, & question->qname);
#line 3197
  if (! ptr) {
#line 3197
    return ((mDNSu8 const   *)0L);
  }
#line 3198
  if ((unsigned int )(ptr + 4) > (unsigned int )end) {
#line 3198
    return ((mDNSu8 const   *)0L);
  }
#line 3200
  question->qnamehash = DomainNameHashValue((domainname const   *)(& question->qname));
#line 3201
  question->qtype = (unsigned short )(((int )((unsigned short )*(ptr + 0)) << 8) | (int )*(ptr + 1));
#line 3202
  question->qclass = (unsigned short )(((int )((unsigned short )*(ptr + 2)) << 8) | (int )*(ptr + 3));
#line 3203
  return (ptr + 4);
}
}
#line 3206 "mDNS.c"
static mDNSu8 const   *LocateAnswers(DNSMessage const   *msg , mDNSu8 const   *end ) 
{ int i ;
  mDNSu8 const   *ptr ;

  {
#line 3209
  ptr = (mDNSu8 const   *)(msg->data);
#line 3210
  i = 0;
#line 3210
  while (1) {
#line 3210
    if (i < (int )msg->h.numQuestions) {
#line 3210
      if (! ptr) {
#line 3210
        break;
      }
    } else {
#line 3210
      break;
    }
#line 3210
    ptr = skipQuestion(msg, ptr, end);
#line 3210
    i ++;
  }
#line 3211
  return (ptr);
}
}
#line 3214 "mDNS.c"
static mDNSu8 const   *LocateAuthorities(DNSMessage const   *msg , mDNSu8 const   *end ) 
{ int i ;
  mDNSu8 const   *ptr ;
  mDNSu8 const   *tmp ;

  {
#line 3217
  tmp = LocateAnswers(msg, end);
#line 3217
  ptr = tmp;
#line 3218
  i = 0;
#line 3218
  while (1) {
#line 3218
    if (i < (int )msg->h.numAnswers) {
#line 3218
      if (! ptr) {
#line 3218
        break;
      }
    } else {
#line 3218
      break;
    }
#line 3218
    ptr = skipResourceRecord(msg, ptr, end);
#line 3218
    i ++;
  }
#line 3219
  return (ptr);
}
}
#line 3229 "mDNS.c"
static mStatus mDNSSendDNSMessage(mDNS const   *m , DNSMessage *msg , mDNSu8 const   *end ,
                                  mDNSInterfaceID InterfaceID , mDNSIPPort srcport ,
                                  mDNSAddr const   *dst , mDNSIPPort dstport ) 
{ mStatus status ;
  mDNSu16 numQuestions ;
  mDNSu16 numAnswers ;
  mDNSu16 numAuthorities ;
  mDNSu16 numAdditionals ;
  mDNSu8 *ptr ;
  mDNSu8 *tmp ;
  mDNSu8 *tmp___0 ;
  mDNSu8 *tmp___1 ;
  mDNSu8 *tmp___2 ;
  mDNSu8 *tmp___3 ;
  mDNSu8 *tmp___4 ;
  mDNSu8 *tmp___5 ;
  mDNSu8 *tmp___6 ;

  {
#line 3233
  numQuestions = msg->h.numQuestions;
#line 3234
  numAnswers = msg->h.numAnswers;
#line 3235
  numAuthorities = msg->h.numAuthorities;
#line 3236
  numAdditionals = msg->h.numAdditionals;
#line 3239
  ptr = (mDNSu8 *)(& msg->h.numQuestions);
#line 3240
  tmp = ptr;
#line 3240
  ptr ++;
#line 3240
  *tmp = (unsigned char )((int )numQuestions >> 8);
#line 3241
  tmp___0 = ptr;
#line 3241
  ptr ++;
#line 3241
  *tmp___0 = (unsigned char )numQuestions;
#line 3242
  tmp___1 = ptr;
#line 3242
  ptr ++;
#line 3242
  *tmp___1 = (unsigned char )((int )numAnswers >> 8);
#line 3243
  tmp___2 = ptr;
#line 3243
  ptr ++;
#line 3243
  *tmp___2 = (unsigned char )numAnswers;
#line 3244
  tmp___3 = ptr;
#line 3244
  ptr ++;
#line 3244
  *tmp___3 = (unsigned char )((int )numAuthorities >> 8);
#line 3245
  tmp___4 = ptr;
#line 3245
  ptr ++;
#line 3245
  *tmp___4 = (unsigned char )numAuthorities;
#line 3246
  tmp___5 = ptr;
#line 3246
  ptr ++;
#line 3246
  *tmp___5 = (unsigned char )((int )numAdditionals >> 8);
#line 3247
  tmp___6 = ptr;
#line 3247
  ptr ++;
#line 3247
  *tmp___6 = (unsigned char )numAdditionals;
#line 3250
  status = mDNSPlatformSendUDP(m, (DNSMessage const   *)msg, end, InterfaceID, srcport,
                               dst, dstport);
#line 3253
  msg->h.numQuestions = numQuestions;
#line 3254
  msg->h.numAnswers = numAnswers;
#line 3255
  msg->h.numAuthorities = numAuthorities;
#line 3256
  msg->h.numAdditionals = numAdditionals;
#line 3258
  return (status);
}
}
#line 3261 "mDNS.c"
static void CompleteDeregistration(mDNS *m , AuthRecord *rr ) 
{ 

  {
#line 3265
  rr->resrec.RecordType = (unsigned char)8;
#line 3266
  rr->AnnounceCount = (unsigned char)10;
#line 3267
  mDNS_Deregister_internal(m, rr, 0);
#line 3268
  return;
}
}
#line 3273 "mDNS.c"
static void DiscardDeregistrations(mDNS *m ) 
{ AuthRecord *rr ;

  {
#line 3275
  if (m->CurrentRecord) {
#line 3275
    LogMsg("DiscardDeregistrations ERROR m->CurrentRecord already set");
  }
#line 3276
  m->CurrentRecord = m->ResourceRecords;
#line 3278
  while (m->CurrentRecord) {
#line 3280
    rr = m->CurrentRecord;
#line 3281
    m->CurrentRecord = rr->next;
#line 3282
    if ((int )rr->resrec.RecordType == 1) {
#line 3283
      CompleteDeregistration(m, rr);
    }
  }
#line 3285
  return;
}
}
#line 3287 "mDNS.c"
static mDNSBool HaveSentEntireRRSet(mDNS const   *m , AuthRecord const   *rr , mDNSInterfaceID InterfaceID ) 
{ AuthRecord const   *a ;
  mDNSBool tmp ;

  {
#line 3291
  a = (AuthRecord const   *)m->ResourceRecords;
#line 3291
  while (a) {
#line 3292
    if ((unsigned int )a->SendRNow == (unsigned int )InterfaceID) {
#line 3292
      if ((unsigned int )a != (unsigned int )rr) {
#line 3292
        tmp = SameResourceRecordSignature(& a->resrec, & rr->resrec);
#line 3292
        if (tmp) {
#line 3292
          break;
        }
      }
    }
#line 3291
    a = (AuthRecord const   *)a->next;
  }
#line 3293
  return ((unsigned int )a == (unsigned int )((AuthRecord const   *)0));
}
}
#line 3312 "mDNS.c"
static void SendResponses(mDNS *m ) 
{ int pktcount ;
  AuthRecord *rr ;
  AuthRecord *r2 ;
  mDNSs32 maxExistingAnnounceInterval ;
  NetworkInterfaceInfo const   *intf ;
  NetworkInterfaceInfo const   *tmp ;
  mDNSBool tmp___0 ;
  mDNSBool tmp___1 ;
  mDNSBool tmp___2 ;
  struct mDNSInterfaceID_dummystruct *tmp___3 ;
  int numDereg ;
  int numAnnounce ;
  int numAnswer ;
  DNSMessage response ;
  mDNSu8 *responseptr ;
  mDNSu8 *newptr ;
  RData *OldRData ;
  mDNSu16 oldrdlength ;
  mDNSBool tmp___4 ;
  mDNSBool tmp___5 ;
  mDNSu32 tmp___6 ;
  AuthRecord const   *a ;
  mDNSBool tmp___7 ;
  NetworkInterfaceInfo const   *next ;
  NetworkInterfaceInfo const   *tmp___8 ;
  RData *OldRData___0 ;

  {
#line 3314
  pktcount = 0;
#line 3316
  maxExistingAnnounceInterval = 0;
#line 3317
  tmp = GetFirstActiveInterface((NetworkInterfaceInfo const   *)m->HostInterfaces);
#line 3317
  intf = tmp;
#line 3319
  m->NextScheduledResponse = m->timenow + 2013265920;
#line 3326
  rr = m->ResourceRecords;
#line 3326
  while (rr) {
#line 3328
    if (rr->NextUpdateCredit) {
#line 3328
      if (m->timenow - rr->NextUpdateCredit >= 0) {
#line 3330
        (rr->UpdateCredits) ++;
#line 3330
        if (rr->UpdateCredits >= 10U) {
#line 3330
          rr->NextUpdateCredit = 0;
        } else {
#line 3331
          rr->NextUpdateCredit = (m->timenow + mDNSPlatformOneSecond * 60) | 1;
        }
      }
    }
#line 3333
    if (rr->AnnounceCount) {
#line 3333
      if (m->timenow - (rr->LastAPTime + rr->ThisAPInterval) >= 0) {
#line 3333
        if ((int )rr->resrec.RecordType & 60) {
#line 3333
          if ((unsigned int )rr->Additional1 == (unsigned int )((AuthRecord *)0)) {
            goto _L___1;
          } else {
#line 3333
            if ((int )(rr->Additional1)->resrec.RecordType & 60) {
              _L___1: /* CIL Label */ 
#line 3333
              if ((unsigned int )rr->Additional2 == (unsigned int )((AuthRecord *)0)) {
                goto _L___0;
              } else {
#line 3333
                if ((int )(rr->Additional2)->resrec.RecordType & 60) {
                  _L___0: /* CIL Label */ 
#line 3333
                  if ((unsigned int )rr->DependentOn == (unsigned int )((AuthRecord *)0)) {
                    goto _L;
                  } else {
#line 3333
                    if ((int )(rr->DependentOn)->resrec.RecordType & 60) {
                      _L: /* CIL Label */ 
#line 3335
                      rr->ImmedAnswer = (struct mDNSInterfaceID_dummystruct *)mDNSInterfaceMark;
#line 3336
                      if (maxExistingAnnounceInterval < rr->ThisAPInterval) {
#line 3337
                        maxExistingAnnounceInterval = rr->ThisAPInterval;
                      }
#line 3338
                      if (rr->UpdateBlocked) {
#line 3338
                        rr->UpdateBlocked = 0;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 3326
    rr = rr->next;
  }
#line 3344
  rr = m->ResourceRecords;
#line 3344
  while (rr) {
#line 3345
    if (rr->resrec.InterfaceID) {
#line 3345
      if (rr->ImmedAnswer) {
#line 3349
        rr->ImmedAnswer = (struct mDNSInterfaceID_dummystruct *)mDNSInterfaceMark;
      } else {
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ 
#line 3345
      if (rr->ThisAPInterval <= maxExistingAnnounceInterval) {
#line 3345
        if (rr->AnnounceCount) {
#line 3345
          if ((m->timenow + rr->ThisAPInterval / 2) - (rr->LastAPTime + rr->ThisAPInterval) >= 0) {
#line 3345
            if ((int )rr->resrec.RecordType & 60) {
#line 3345
              if ((unsigned int )rr->Additional1 == (unsigned int )((AuthRecord *)0)) {
                goto _L___3;
              } else {
#line 3345
                if ((int )(rr->Additional1)->resrec.RecordType & 60) {
                  _L___3: /* CIL Label */ 
#line 3345
                  if ((unsigned int )rr->Additional2 == (unsigned int )((AuthRecord *)0)) {
                    goto _L___2;
                  } else {
#line 3345
                    if ((int )(rr->Additional2)->resrec.RecordType & 60) {
                      _L___2: /* CIL Label */ 
#line 3345
                      if ((unsigned int )rr->DependentOn == (unsigned int )((AuthRecord *)0)) {
#line 3349
                        rr->ImmedAnswer = (struct mDNSInterfaceID_dummystruct *)mDNSInterfaceMark;
                      } else {
#line 3345
                        if ((int )(rr->DependentOn)->resrec.RecordType & 60) {
#line 3349
                          rr->ImmedAnswer = (struct mDNSInterfaceID_dummystruct *)mDNSInterfaceMark;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 3344
    rr = rr->next;
  }
#line 3352
  rr = m->ResourceRecords;
#line 3352
  while (rr) {
#line 3353
    if (rr->ImmedAnswer) {
#line 3353
      if ((int )rr->resrec.rrtype == 33) {
#line 3354
        r2 = m->ResourceRecords;
#line 3354
        while (r2) {
#line 3355
          if ((int )r2->resrec.rrtype == 1) {
            goto _L___8;
          } else {
#line 3355
            if ((int )r2->resrec.rrtype == 28) {
              _L___8: /* CIL Label */ 
#line 3355
              if ((int )r2->resrec.RecordType & 60) {
#line 3355
                if ((unsigned int )r2->Additional1 == (unsigned int )((AuthRecord *)0)) {
                  goto _L___7;
                } else {
#line 3355
                  if ((int )(r2->Additional1)->resrec.RecordType & 60) {
                    _L___7: /* CIL Label */ 
#line 3355
                    if ((unsigned int )r2->Additional2 == (unsigned int )((AuthRecord *)0)) {
                      goto _L___6;
                    } else {
#line 3355
                      if ((int )(r2->Additional2)->resrec.RecordType & 60) {
                        _L___6: /* CIL Label */ 
#line 3355
                        if ((unsigned int )r2->DependentOn == (unsigned int )((AuthRecord *)0)) {
                          goto _L___5;
                        } else {
#line 3355
                          if ((int )(r2->DependentOn)->resrec.RecordType & 60) {
                            _L___5: /* CIL Label */ 
#line 3355
                            if (rr->LastMCTime - r2->LastMCTime >= 0) {
#line 3355
                              if (rr->resrec.rdnamehash == r2->resrec.namehash) {
#line 3355
                                tmp___0 = SameDomainName((domainname const   *)(& (rr->resrec.rdata)->u.srv.target),
                                                         (domainname const   *)(& r2->resrec.name));
#line 3355
                                if (tmp___0) {
#line 3355
                                  if ((unsigned int )rr->ImmedAnswer == (unsigned int )mDNSInterfaceMark) {
#line 3361
                                    r2->ImmedAnswer = (struct mDNSInterfaceID_dummystruct *)mDNSInterfaceMark;
                                  } else {
#line 3355
                                    if ((unsigned int )rr->ImmedAnswer == (unsigned int )r2->resrec.InterfaceID) {
#line 3361
                                      r2->ImmedAnswer = (struct mDNSInterfaceID_dummystruct *)mDNSInterfaceMark;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
#line 3354
          r2 = r2->next;
        }
      }
    }
#line 3352
    rr = rr->next;
  }
#line 3369
  rr = m->ResourceRecords;
#line 3369
  while (rr) {
#line 3370
    if ((int )rr->resrec.RecordType & 50) {
#line 3372
      if (rr->ImmedAnswer) {
#line 3374
        r2 = m->ResourceRecords;
#line 3374
        while (r2) {
#line 3375
          if ((int )r2->resrec.RecordType & 60) {
#line 3375
            if ((unsigned int )r2->Additional1 == (unsigned int )((AuthRecord *)0)) {
              goto _L___11;
            } else {
#line 3375
              if ((int )(r2->Additional1)->resrec.RecordType & 60) {
                _L___11: /* CIL Label */ 
#line 3375
                if ((unsigned int )r2->Additional2 == (unsigned int )((AuthRecord *)0)) {
                  goto _L___10;
                } else {
#line 3375
                  if ((int )(r2->Additional2)->resrec.RecordType & 60) {
                    _L___10: /* CIL Label */ 
#line 3375
                    if ((unsigned int )r2->DependentOn == (unsigned int )((AuthRecord *)0)) {
                      goto _L___9;
                    } else {
#line 3375
                      if ((int )(r2->DependentOn)->resrec.RecordType & 60) {
                        _L___9: /* CIL Label */ 
#line 3376
                        if ((unsigned int )r2->ImmedAnswer != (unsigned int )mDNSInterfaceMark) {
#line 3376
                          if ((unsigned int )r2->ImmedAnswer != (unsigned int )rr->ImmedAnswer) {
#line 3376
                            tmp___1 = SameResourceRecordSignature((ResourceRecord const   *)(& r2->resrec),
                                                                  (ResourceRecord const   *)(& rr->resrec));
#line 3376
                            if (tmp___1) {
#line 3377
                              r2->ImmedAnswer = rr->ImmedAnswer;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
#line 3374
          r2 = r2->next;
        }
      } else {
#line 3379
        if (rr->ImmedAdditional) {
#line 3381
          r2 = m->ResourceRecords;
#line 3381
          while (r2) {
#line 3382
            if ((int )r2->resrec.RecordType & 60) {
#line 3382
              if ((unsigned int )r2->Additional1 == (unsigned int )((AuthRecord *)0)) {
                goto _L___14;
              } else {
#line 3382
                if ((int )(r2->Additional1)->resrec.RecordType & 60) {
                  _L___14: /* CIL Label */ 
#line 3382
                  if ((unsigned int )r2->Additional2 == (unsigned int )((AuthRecord *)0)) {
                    goto _L___13;
                  } else {
#line 3382
                    if ((int )(r2->Additional2)->resrec.RecordType & 60) {
                      _L___13: /* CIL Label */ 
#line 3382
                      if ((unsigned int )r2->DependentOn == (unsigned int )((AuthRecord *)0)) {
                        goto _L___12;
                      } else {
#line 3382
                        if ((int )(r2->DependentOn)->resrec.RecordType & 60) {
                          _L___12: /* CIL Label */ 
#line 3383
                          if ((unsigned int )r2->ImmedAdditional != (unsigned int )rr->ImmedAdditional) {
#line 3383
                            tmp___2 = SameResourceRecordSignature((ResourceRecord const   *)(& r2->resrec),
                                                                  (ResourceRecord const   *)(& rr->resrec));
#line 3383
                            if (tmp___2) {
#line 3384
                              r2->ImmedAdditional = rr->ImmedAdditional;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
#line 3381
            r2 = r2->next;
          }
        }
      }
    }
#line 3369
    rr = rr->next;
  }
#line 3389
  rr = m->ResourceRecords;
#line 3389
  while (rr) {
#line 3391
    if ((unsigned int )rr->ImmedAnswer == (unsigned int )mDNSInterfaceMark) {
#line 3393
      if (! intf) {
#line 3393
        rr->SendRNow = (struct mDNSInterfaceID_dummystruct *)0L;
      } else {
#line 3393
        if (rr->resrec.InterfaceID) {
#line 3393
          tmp___3 = (struct mDNSInterfaceID_dummystruct * const  )rr->resrec.InterfaceID;
        } else {
#line 3393
          tmp___3 = intf->InterfaceID;
        }
#line 3393
        rr->SendRNow = (struct mDNSInterfaceID_dummystruct *)tmp___3;
      }
#line 3394
      rr->ImmedAdditional = (struct mDNSInterfaceID_dummystruct *)0L;
#line 3395
      rr->LastMCTime = m->timenow;
#line 3396
      rr->LastMCInterface = rr->ImmedAnswer;
#line 3398
      if (rr->AnnounceCount) {
#line 3398
        if ((m->timenow + rr->ThisAPInterval / 2) - (rr->LastAPTime + rr->ThisAPInterval) >= 0) {
#line 3400
          rr->AnnounceCount = (mDNSu8 )((int )rr->AnnounceCount - 1);
#line 3401
          rr->ThisAPInterval *= 2;
#line 3402
          rr->LastAPTime = m->timenow;
#line 3403
          if ((rr->LastAPTime + rr->ThisAPInterval) - rr->AnnounceUntil >= 0) {
#line 3403
            rr->AnnounceCount = (unsigned char)0;
          }
        }
      }
    } else {
#line 3407
      if (rr->ImmedAnswer) {
#line 3409
        rr->SendRNow = rr->ImmedAnswer;
#line 3410
        rr->ImmedAdditional = (struct mDNSInterfaceID_dummystruct *)0L;
#line 3411
        rr->LastMCTime = m->timenow;
#line 3412
        rr->LastMCInterface = rr->ImmedAnswer;
      }
    }
#line 3414
    SetNextAnnounceProbeTime(m, (AuthRecord const   *)rr);
#line 3389
    rr = rr->next;
  }
#line 3421
  while (intf) {
#line 3423
    numDereg = 0;
#line 3424
    numAnnounce = 0;
#line 3425
    numAnswer = 0;
#line 3427
    responseptr = response.data;
#line 3429
    InitializeDNSMessage(& response.h, (union __anonunion_mDNSOpaque16_18 )zeroID,
                         (union __anonunion_mDNSOpaque16_18 )ResponseFlags);
#line 3439
    rr = m->ResourceRecords;
#line 3439
    while (rr) {
#line 3440
      if ((unsigned int )rr->SendRNow == (unsigned int )intf->InterfaceID) {
#line 3442
        if ((int )rr->resrec.RecordType == 1) {
#line 3444
          newptr = PutResourceRecordTTL(& response, responseptr, & response.h.numAnswers,
                                        & rr->resrec, 0U);
#line 3445
          if (! newptr) {
#line 3445
            if (response.h.numAnswers) {
#line 3445
              break;
            }
          }
#line 3446
          numDereg ++;
#line 3447
          responseptr = newptr;
        } else {
#line 3449
          if (rr->NewRData) {
#line 3451
            OldRData = rr->resrec.rdata;
#line 3452
            oldrdlength = rr->resrec.rdlength;
#line 3456
            if ((int )rr->resrec.RecordType & 60) {
#line 3456
              if ((unsigned int )rr->Additional1 == (unsigned int )((AuthRecord *)0)) {
                goto _L___17;
              } else {
#line 3456
                if ((int )(rr->Additional1)->resrec.RecordType & 60) {
                  _L___17: /* CIL Label */ 
#line 3456
                  if ((unsigned int )rr->Additional2 == (unsigned int )((AuthRecord *)0)) {
                    goto _L___16;
                  } else {
#line 3456
                    if ((int )(rr->Additional2)->resrec.RecordType & 60) {
                      _L___16: /* CIL Label */ 
#line 3456
                      if ((unsigned int )rr->DependentOn == (unsigned int )((AuthRecord *)0)) {
                        goto _L___15;
                      } else {
#line 3456
                        if ((int )(rr->DependentOn)->resrec.RecordType & 60) {
                          _L___15: /* CIL Label */ 
#line 3456
                          if ((int )rr->AnnounceCount < 9) {
#line 3458
                            newptr = PutResourceRecordTTL(& response, responseptr,
                                                          & response.h.numAnswers,
                                                          & rr->resrec, 0U);
#line 3459
                            if (! newptr) {
#line 3459
                              if (response.h.numAnswers) {
#line 3459
                                break;
                              }
                            }
#line 3460
                            numDereg ++;
#line 3461
                            responseptr = newptr;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
#line 3464
            SetNewRData(& rr->resrec, rr->NewRData, rr->newrdlength);
#line 3465
            if ((int )rr->resrec.RecordType & 50) {
#line 3465
              tmp___4 = HaveSentEntireRRSet((mDNS const   *)m, (AuthRecord const   *)rr,
                                            (struct mDNSInterfaceID_dummystruct *)intf->InterfaceID);
#line 3465
              if (tmp___4) {
#line 3466
                rr->resrec.rrclass = (unsigned short )((int )rr->resrec.rrclass | 32768);
              }
            }
#line 3467
            newptr = PutResourceRecordTTL(& response, responseptr, & response.h.numAnswers,
                                          & rr->resrec, rr->resrec.rroriginalttl);
#line 3468
            rr->resrec.rrclass = (unsigned short )((int )rr->resrec.rrclass & -32769);
#line 3469
            if (newptr) {
#line 3469
              responseptr = newptr;
            }
#line 3470
            SetNewRData(& rr->resrec, OldRData, oldrdlength);
          } else {
#line 3474
            if ((int )rr->resrec.RecordType & 50) {
#line 3474
              tmp___5 = HaveSentEntireRRSet((mDNS const   *)m, (AuthRecord const   *)rr,
                                            (struct mDNSInterfaceID_dummystruct *)intf->InterfaceID);
#line 3474
              if (tmp___5) {
#line 3475
                rr->resrec.rrclass = (unsigned short )((int )rr->resrec.rrclass | 32768);
              }
            }
#line 3476
            if (m->SleepState) {
#line 3476
              tmp___6 = 0U;
            } else {
#line 3476
              tmp___6 = rr->resrec.rroriginalttl;
            }
#line 3476
            newptr = PutResourceRecordTTL(& response, responseptr, & response.h.numAnswers,
                                          & rr->resrec, tmp___6);
#line 3477
            rr->resrec.rrclass = (unsigned short )((int )rr->resrec.rrclass & -32769);
#line 3478
            if (! newptr) {
#line 3478
              if (response.h.numAnswers) {
#line 3478
                break;
              }
            }
#line 3479
            if (rr->LastAPTime == m->timenow) {
#line 3479
              numAnnounce ++;
            } else {
#line 3479
              numAnswer ++;
            }
#line 3480
            responseptr = newptr;
          }
        }
#line 3483
        if ((unsigned int )rr->ImmedAnswer == (unsigned int )mDNSInterfaceMark) {
#line 3483
          if ((unsigned int )rr->resrec.InterfaceID == (unsigned int )mDNSInterface_Any) {
#line 3484
            rr->SendRNow = GetNextActiveInterfaceID(intf);
          } else {
#line 3486
            rr->SendRNow = (struct mDNSInterfaceID_dummystruct *)0L;
          }
        } else {
#line 3486
          rr->SendRNow = (struct mDNSInterfaceID_dummystruct *)0L;
        }
      }
#line 3439
      rr = rr->next;
    }
#line 3490
    newptr = responseptr;
#line 3491
    rr = m->ResourceRecords;
#line 3491
    while (rr) {
#line 3492
      if ((unsigned int )rr->ImmedAdditional == (unsigned int )intf->InterfaceID) {
#line 3495
        rr->ImmedAdditional = (struct mDNSInterfaceID_dummystruct *)0L;
#line 3496
        if (newptr) {
#line 3496
          if ((int )rr->resrec.RecordType & 60) {
#line 3496
            if ((unsigned int )rr->Additional1 == (unsigned int )((AuthRecord *)0)) {
              goto _L___20;
            } else {
#line 3496
              if ((int )(rr->Additional1)->resrec.RecordType & 60) {
                _L___20: /* CIL Label */ 
#line 3496
                if ((unsigned int )rr->Additional2 == (unsigned int )((AuthRecord *)0)) {
                  goto _L___19;
                } else {
#line 3496
                  if ((int )(rr->Additional2)->resrec.RecordType & 60) {
                    _L___19: /* CIL Label */ 
#line 3496
                    if ((unsigned int )rr->DependentOn == (unsigned int )((AuthRecord *)0)) {
                      goto _L___18;
                    } else {
#line 3496
                      if ((int )(rr->DependentOn)->resrec.RecordType & 60) {
                        _L___18: /* CIL Label */ 
#line 3498
                        if ((int )rr->resrec.RecordType & 50) {
#line 3502
                          a = (AuthRecord const   *)m->ResourceRecords;
#line 3502
                          while (a) {
#line 3503
                            if ((unsigned int )a->ImmedAdditional == (unsigned int )intf->InterfaceID) {
#line 3503
                              tmp___7 = SameResourceRecordSignature(& a->resrec, (ResourceRecord const   *)(& rr->resrec));
#line 3503
                              if (tmp___7) {
#line 3503
                                break;
                              }
                            }
#line 3502
                            a = (AuthRecord const   *)a->next;
                          }
#line 3504
                          if ((unsigned int )a == (unsigned int )((AuthRecord const   *)0)) {
#line 3505
                            rr->resrec.rrclass = (unsigned short )((int )rr->resrec.rrclass | 32768);
                          }
                        }
#line 3507
                        newptr = PutResourceRecordTTL(& response, newptr, & response.h.numAdditionals,
                                                      & rr->resrec, rr->resrec.rroriginalttl);
#line 3508
                        if (newptr) {
#line 3508
                          responseptr = newptr;
                        }
#line 3509
                        rr->resrec.rrclass = (unsigned short )((int )rr->resrec.rrclass & -32769);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 3491
      rr = rr->next;
    }
#line 3513
    if ((int )response.h.numAnswers > 0) {
#line 3520
      mDNSSendDNSMessage((mDNS const   *)m, & response, (mDNSu8 const   *)responseptr,
                         (struct mDNSInterfaceID_dummystruct *)intf->InterfaceID,
                         (union __anonunion_mDNSOpaque16_18 )MulticastDNSPort, & AllDNSLinkGroup_v4,
                         (union __anonunion_mDNSOpaque16_18 )MulticastDNSPort);
#line 3521
      mDNSSendDNSMessage((mDNS const   *)m, & response, (mDNSu8 const   *)responseptr,
                         (struct mDNSInterfaceID_dummystruct *)intf->InterfaceID,
                         (union __anonunion_mDNSOpaque16_18 )MulticastDNSPort, & AllDNSLinkGroup_v6,
                         (union __anonunion_mDNSOpaque16_18 )MulticastDNSPort);
#line 3522
      if (! m->SuppressSending) {
#line 3522
        m->SuppressSending = (m->timenow + mDNSPlatformOneSecond / 10) | 1;
      }
#line 3523
      pktcount ++;
#line 3523
      if (pktcount >= 1000) {
#line 3524
        LogMsg("SendResponses exceeded loop limit %d: giving up", pktcount);
#line 3524
        break;
      }
    } else {
#line 3529
      tmp___8 = GetFirstActiveInterface((NetworkInterfaceInfo const   *)intf->next);
#line 3529
      next = tmp___8;
#line 3534
      intf = next;
    }
  }
#line 3542
  if (m->CurrentRecord) {
#line 3542
    LogMsg("SendResponses: ERROR m->CurrentRecord already set");
  }
#line 3543
  m->CurrentRecord = m->ResourceRecords;
#line 3544
  while (m->CurrentRecord) {
#line 3546
    rr = m->CurrentRecord;
#line 3547
    m->CurrentRecord = rr->next;
#line 3549
    if (rr->NewRData) {
#line 3551
      OldRData___0 = rr->resrec.rdata;
#line 3552
      SetNewRData(& rr->resrec, rr->NewRData, rr->newrdlength);
#line 3553
      rr->NewRData = (RData *)0L;
#line 3554
      if (rr->UpdateCallback) {
#line 3555
        (*(rr->UpdateCallback))(m, rr, OldRData___0);
      }
    }
#line 3558
    if ((int )rr->resrec.RecordType == 1) {
#line 3559
      CompleteDeregistration(m, rr);
    } else {
#line 3562
      rr->ImmedAnswer = (struct mDNSInterfaceID_dummystruct *)0L;
#line 3563
      rr->v4Requester = (union __anonunion_mDNSOpaque32_19 )zeroIPAddr;
#line 3564
      rr->v6Requester = (union __anonunion_mDNSOpaque128_20 )zerov6Addr;
    }
  }
#line 3568
  return;
}
}
#line 3590 "mDNS.c"
static void SetNextCacheCheckTime(mDNS *m , CacheRecord *rr ) 
{ mDNSu32 tmp ;
  mDNSs32 tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  mDNSs32 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 3592
  rr->NextRequiredQuery = rr->TimeRcvd + (int )rr->resrec.rroriginalttl * mDNSPlatformOneSecond;
#line 3596
  if (rr->CRActiveQuestion) {
#line 3596
    if (rr->UnansweredQueries < 4U) {
#line 3598
      rr->NextRequiredQuery = (int )((mDNSu32 )rr->NextRequiredQuery - (mDNSu32 )(((int )rr->resrec.rroriginalttl * mDNSPlatformOneSecond) / 20) * (4U - rr->UnansweredQueries));
#line 3599
      tmp = mDNSRandom((unsigned int )((int )rr->resrec.rroriginalttl * mDNSPlatformOneSecond) / 50U);
#line 3599
      rr->NextRequiredQuery = (int )((mDNSu32 )rr->NextRequiredQuery + tmp);
    }
  }
#line 3604
  if ((unsigned int )rr->CRActiveQuestion == (unsigned int )((DNSQuestion *)0)) {
#line 3604
    tmp___5 = 60 * mDNSPlatformOneSecond;
  } else {
#line 3604
    if (rr->UnansweredQueries < 4U) {
#line 3604
      tmp___4 = ((int )rr->resrec.rroriginalttl * mDNSPlatformOneSecond) / 50;
    } else {
#line 3604
      if (rr->resrec.rroriginalttl > 10U) {
#line 3604
        tmp___3 = mDNSPlatformOneSecond;
      } else {
#line 3604
        tmp___3 = mDNSPlatformOneSecond / 10;
      }
#line 3604
      tmp___4 = tmp___3;
    }
#line 3604
    tmp___5 = tmp___4;
  }
#line 3604
  if (m->NextCacheCheck - (rr->NextRequiredQuery + tmp___5) > 0) {
#line 3605
    if ((unsigned int )rr->CRActiveQuestion == (unsigned int )((DNSQuestion *)0)) {
#line 3605
      tmp___2 = 60 * mDNSPlatformOneSecond;
    } else {
#line 3605
      if (rr->UnansweredQueries < 4U) {
#line 3605
        tmp___1 = ((int )rr->resrec.rroriginalttl * mDNSPlatformOneSecond) / 50;
      } else {
#line 3605
        if (rr->resrec.rroriginalttl > 10U) {
#line 3605
          tmp___0 = mDNSPlatformOneSecond;
        } else {
#line 3605
          tmp___0 = mDNSPlatformOneSecond / 10;
        }
#line 3605
        tmp___1 = tmp___0;
      }
#line 3605
      tmp___2 = tmp___1;
    }
#line 3605
    m->NextCacheCheck = rr->NextRequiredQuery + tmp___2;
  }
#line 3606
  return;
}
}
#line 3612 "mDNS.c"
static mStatus mDNS_Reconfirm_internal(mDNS *m , CacheRecord *rr , mDNSu32 interval ) 
{ mDNSu32 tmp ;

  {
#line 3614
  if (interval < (unsigned int )mDNSPlatformOneSecond * 5U) {
#line 3615
    interval = (unsigned int )mDNSPlatformOneSecond * 5U;
  }
#line 3616
  if (interval > 268435456U) {
#line 3617
    interval = 268435456U;
  }
#line 3620
  if ((rr->TimeRcvd + (int )rr->resrec.rroriginalttl * mDNSPlatformOneSecond) - m->timenow > (int )((interval * 4U) / 3U)) {
#line 3623
    tmp = mDNSRandom(interval / 3U);
#line 3623
    interval += tmp;
#line 3624
    rr->TimeRcvd = m->timenow - (int )interval * 3;
#line 3625
    rr->resrec.rroriginalttl = (interval * 4U) / (mDNSu32 )mDNSPlatformOneSecond;
#line 3626
    SetNextCacheCheckTime(m, rr);
  }
#line 3629
  return (0);
}
}
#line 3637 "mDNS.c"
static mDNSBool BuildQuestion(mDNS *m , DNSMessage *query , mDNSu8 **queryptr , DNSQuestion *q ,
                              CacheRecord ***kalistptrptr , mDNSu32 *answerforecast ) 
{ mDNSBool ucast ;
  int tmp ;
  mDNSu16 ucbit ;
  int tmp___0 ;
  mDNSu8 const   *limit ;
  mDNSu8 *newptr ;
  mDNSu8 *tmp___1 ;
  mDNSu32 forecast ;
  CacheRecord *rr ;
  CacheRecord **ka ;
  mDNSu32 tmp___2 ;
  CacheRecord *rr___0 ;
  mDNSBool tmp___3 ;
  CacheRecord *rr___1 ;
  mDNSu32 tmp___4 ;
  mDNSBool tmp___5 ;

  {
#line 3640
  if (q->LargeAnswers) {
#line 3640
    tmp = 1;
  } else {
#line 3640
    if (q->ThisQInterval <= (mDNSPlatformOneSecond / 2) * 2) {
#line 3640
      tmp = 1;
    } else {
#line 3640
      tmp = 0;
    }
  }
#line 3640
  ucast = tmp;
#line 3641
  if (ucast) {
#line 3641
    tmp___0 = 32768;
  } else {
#line 3641
    tmp___0 = 0;
  }
#line 3641
  ucbit = (unsigned short )tmp___0;
#line 3642
  limit = (mDNSu8 const   *)(query->data + 1440);
#line 3643
  tmp___1 = putQuestion(query, *queryptr, limit, (domainname const   *)(& q->qname),
                        q->qtype, (unsigned short )((int )q->qclass | (int )ucbit));
#line 3643
  newptr = tmp___1;
#line 3644
  if (! newptr) {
#line 3647
    return (0);
  } else {
#line 3649
    if ((unsigned int )(newptr + *answerforecast) >= (unsigned int )limit) {
#line 3652
      query->h.numQuestions = (mDNSu16 )((int )query->h.numQuestions - 1);
#line 3653
      return (0);
    } else {
#line 3657
      forecast = *answerforecast;
#line 3659
      ka = *kalistptrptr;
#line 3661
      tmp___2 = DomainNameHashValue((domainname const   *)(& q->qname));
#line 3661
      rr = m->rrcache_hash[tmp___2 % 499U];
#line 3661
      while (rr) {
#line 3662
        if ((unsigned int )rr->resrec.InterfaceID == (unsigned int )q->SendQNow) {
#line 3662
          if ((unsigned int )rr->NextInKAList == (unsigned int )((CacheRecord *)0)) {
#line 3662
            if ((unsigned int )ka != (unsigned int )(& rr->NextInKAList)) {
#line 3662
              if ((int )rr->resrec.rdlength <= 1024) {
#line 3662
                tmp___3 = ResourceRecordAnswersQuestion((ResourceRecord const   *)(& rr->resrec),
                                                        (DNSQuestion const   *)q);
#line 3662
                if (tmp___3) {
#line 3662
                  if ((rr->TimeRcvd + ((int )rr->resrec.rroriginalttl * mDNSPlatformOneSecond) / 2) - m->timenow >= 0) {
#line 3662
                    if (rr->NextRequiredQuery - (m->timenow + q->ThisQInterval) > 0) {
#line 3669
                      *ka = rr;
#line 3670
                      ka = & rr->NextInKAList;
#line 3672
                      forecast += (mDNSu32 )(12 + (int )rr->resrec.rdestimate);
#line 3675
                      if ((int )query->h.numQuestions > 1) {
#line 3675
                        if ((unsigned int )(newptr + forecast) >= (unsigned int )limit) {
#line 3679
                          query->h.numQuestions = (mDNSu16 )((int )query->h.numQuestions - 1);
#line 3680
                          ka = *kalistptrptr;
#line 3681
                          while (*ka) {
#line 3681
                            rr___0 = *ka;
#line 3681
                            *ka = (CacheRecord *)0L;
#line 3681
                            ka = & rr___0->NextInKAList;
                          }
#line 3682
                          return (0);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
#line 3661
        rr = rr->next;
      }
#line 3696
      if (q->UniqueAnswers) {
        goto _L___0;
      } else {
#line 3696
        if ((unsigned int )(newptr + forecast) >= (unsigned int )limit) {
          _L___0: /* CIL Label */ 
#line 3697
          if (q->ThisQInterval == (mDNSPlatformOneSecond / 2) * 8) {
            goto _L;
          } else {
#line 3697
            if (q->ThisQInterval == (mDNSPlatformOneSecond / 2) * 32) {
              _L: /* CIL Label */ 
#line 3699
              query->h.numQuestions = (mDNSu16 )((int )query->h.numQuestions - 1);
#line 3700
              ka = *kalistptrptr;
#line 3701
              while (*ka) {
#line 3701
                rr___1 = *ka;
#line 3701
                *ka = (CacheRecord *)0L;
#line 3701
                ka = & rr___1->NextInKAList;
              }
#line 3702
              return (1);
            }
          }
        }
      }
#line 3706
      *queryptr = newptr;
#line 3707
      *answerforecast = forecast;
#line 3708
      *kalistptrptr = ka;
#line 3709
      if (ucast) {
#line 3709
        m->ExpectUnicastResponse = m->timenow;
      }
#line 3711
      tmp___4 = DomainNameHashValue((domainname const   *)(& q->qname));
#line 3711
      rr = m->rrcache_hash[tmp___4 % 499U];
#line 3711
      while (rr) {
#line 3712
        if ((unsigned int )rr->resrec.InterfaceID == (unsigned int )q->SendQNow) {
#line 3712
          if ((unsigned int )rr->NextInKAList == (unsigned int )((CacheRecord *)0)) {
#line 3712
            if ((unsigned int )ka != (unsigned int )(& rr->NextInKAList)) {
#line 3712
              tmp___5 = ResourceRecordAnswersQuestion((ResourceRecord const   *)(& rr->resrec),
                                                      (DNSQuestion const   *)q);
#line 3712
              if (tmp___5) {
#line 3716
                (rr->UnansweredQueries) ++;
#line 3717
                rr->LastUnansweredTime = m->timenow;
#line 3718
                SetNextCacheCheckTime(m, rr);
              }
            }
          }
        }
#line 3711
        rr = rr->next;
      }
#line 3721
      return (1);
    }
  }
}
}
#line 3725 "mDNS.c"
static void ReconfirmAntecedents(mDNS *m , DNSQuestion *q ) 
{ mDNSu32 slot ;
  CacheRecord *rr ;
  domainname *target ;
  domainname *tmp ;
  mDNSBool tmp___0 ;

  {
#line 3730
  slot = 0U;
#line 3730
  while (slot < 499U) {
#line 3731
    rr = m->rrcache_hash[slot];
#line 3731
    while (rr) {
#line 3732
      if ((int )rr->resrec.rrtype == 5) {
#line 3732
        target = & (rr->resrec.rdata)->u.name;
      } else {
#line 3732
        if ((int )rr->resrec.rrtype == 12) {
#line 3732
          target = & (rr->resrec.rdata)->u.name;
        } else {
#line 3732
          if ((int )rr->resrec.rrtype == 33) {
#line 3732
            tmp = & (rr->resrec.rdata)->u.srv.target;
          } else {
#line 3732
            tmp = (domainname *)0L;
          }
#line 3732
          target = tmp;
        }
      }
#line 3732
      if (target) {
#line 3732
        if (rr->resrec.rdnamehash == q->qnamehash) {
#line 3732
          tmp___0 = SameDomainName((domainname const   *)target, (domainname const   *)(& q->qname));
#line 3732
          if (tmp___0) {
#line 3733
            mDNS_Reconfirm_internal(m, rr, (unsigned int )mDNSPlatformOneSecond * 45U);
          }
        }
      }
#line 3731
      rr = rr->next;
    }
#line 3730
    slot ++;
  }
#line 3734
  return;
}
}
#line 3737 "mDNS.c"
static void ExpireDupSuppressInfo(DupSuppressInfo *ds , mDNSs32 time___0 ) 
{ int i ;

  {
#line 3740
  i = 0;
#line 3740
  while (i < 8) {
#line 3740
    if ((ds + i)->Time - time___0 < 0) {
#line 3740
      (ds + i)->InterfaceID = (struct mDNSInterfaceID_dummystruct *)0L;
    }
#line 3740
    i ++;
  }
#line 3741
  return;
}
}
#line 3743 "mDNS.c"
static void ExpireDupSuppressInfoOnInterface(DupSuppressInfo *ds , mDNSs32 time___0 ,
                                             mDNSInterfaceID InterfaceID ) 
{ int i ;

  {
#line 3746
  i = 0;
#line 3746
  while (i < 8) {
#line 3746
    if ((unsigned int )(ds + i)->InterfaceID == (unsigned int )InterfaceID) {
#line 3746
      if ((ds + i)->Time - time___0 < 0) {
#line 3746
        (ds + i)->InterfaceID = (struct mDNSInterfaceID_dummystruct *)0L;
      }
    }
#line 3746
    i ++;
  }
#line 3747
  return;
}
}
#line 3749 "mDNS.c"
static mDNSBool SuppressOnThisInterface(DupSuppressInfo const   *ds , NetworkInterfaceInfo const   *intf ) 
{ int i ;
  mDNSBool v4 ;
  mDNSBool v6 ;

  {
#line 3752
  v4 = ! intf->IPv4Available;
#line 3753
  v6 = ! intf->IPv6Available;
#line 3754
  i = 0;
#line 3754
  while (i < 8) {
#line 3755
    if ((unsigned int )(ds + i)->InterfaceID == (unsigned int )intf->InterfaceID) {
#line 3757
      if ((ds + i)->Type == 4) {
#line 3757
        v4 = 1;
      } else {
#line 3758
        if ((ds + i)->Type == 6) {
#line 3758
          v6 = 1;
        }
      }
#line 3759
      if (v4) {
#line 3759
        if (v6) {
#line 3759
          return (1);
        }
      }
    }
#line 3754
    i ++;
  }
#line 3761
  return (0);
}
}
#line 3764 "mDNS.c"
static int RecordDupSuppressInfo(DupSuppressInfo *ds , mDNSs32 Time , mDNSInterfaceID InterfaceID ,
                                 mDNSs32 Type ) 
{ int i ;
  int j ;

  {
#line 3769
  i = 0;
#line 3769
  while (i < 8) {
#line 3769
    if ((unsigned int )(ds + i)->InterfaceID == (unsigned int )InterfaceID) {
#line 3769
      if ((ds + i)->Type == Type) {
#line 3769
        break;
      }
    }
#line 3769
    i ++;
  }
#line 3772
  if (i >= 8) {
#line 3774
    i = 0;
#line 3775
    j = 1;
#line 3775
    while (1) {
#line 3775
      if (j < 8) {
#line 3775
        if (! (ds + i)->InterfaceID) {
#line 3775
          break;
        }
      } else {
#line 3775
        break;
      }
#line 3776
      if (! (ds + j)->InterfaceID) {
#line 3777
        i = j;
      } else {
#line 3776
        if ((ds + j)->Time - (ds + i)->Time < 0) {
#line 3777
          i = j;
        }
      }
#line 3775
      j ++;
    }
  }
#line 3781
  (ds + i)->Time = Time;
#line 3782
  (ds + i)->InterfaceID = InterfaceID;
#line 3783
  (ds + i)->Type = Type;
#line 3785
  return (i);
}
}
#line 3788 "mDNS.c"
static mDNSBool AccelerateThisQuery(mDNS *m , DNSQuestion *q ) 
{ mDNSu32 forecast ;
  mDNSu16 tmp ;
  CacheRecord *rr ;
  mDNSu32 tmp___0 ;
  mDNSBool tmp___1 ;

  {
#line 3791
  if (q->ThisQInterval > 0) {
#line 3791
    if (! q->DuplicateOf) {
#line 3791
      if ((m->timenow + q->ThisQInterval / 10) - (q->LastQTime + q->ThisQInterval) >= 0) {
#line 3792
        return (1);
      }
    }
  }
#line 3795
  if (q->ThisQInterval > 0) {
#line 3795
    if (! q->DuplicateOf) {
#line 3795
      if ((m->timenow + q->ThisQInterval / 2) - (q->LastQTime + q->ThisQInterval) >= 0) {
#line 3798
        tmp = DomainNameLength((domainname const   *)(& q->qname));
#line 3798
        forecast = (unsigned int )tmp + 4U;
#line 3800
        tmp___0 = DomainNameHashValue((domainname const   *)(& q->qname));
#line 3800
        rr = m->rrcache_hash[tmp___0 % 499U];
#line 3800
        while (rr) {
#line 3801
          if ((int )rr->resrec.rdlength <= 1024) {
#line 3801
            tmp___1 = ResourceRecordAnswersQuestion((ResourceRecord const   *)(& rr->resrec),
                                                    (DNSQuestion const   *)q);
#line 3801
            if (tmp___1) {
#line 3801
              if ((rr->TimeRcvd + ((int )rr->resrec.rroriginalttl * mDNSPlatformOneSecond) / 2) - m->timenow >= 0) {
#line 3801
                if (rr->NextRequiredQuery - (m->timenow + q->ThisQInterval) > 0) {
#line 3807
                  forecast += (mDNSu32 )(12 + (int )rr->resrec.rdestimate);
#line 3808
                  if (forecast >= 512U) {
#line 3808
                    return (0);
                  }
                }
              }
            }
          }
#line 3800
          rr = rr->next;
        }
#line 3810
        return (1);
      }
    }
  }
#line 3813
  return (0);
}
}
#line 3828 "mDNS.c"
static void SendQueries(mDNS *m ) 
{ int pktcount ;
  DNSQuestion *q ;
  mDNSs32 maxExistingQuestionInterval ;
  NetworkInterfaceInfo const   *intf ;
  NetworkInterfaceInfo const   *tmp ;
  CacheRecord *KnownAnswerList ;
  mDNSu32 slot ;
  CacheRecord *rr ;
  struct mDNSInterfaceID_dummystruct *tmp___0 ;
  mDNSBool tmp___1 ;
  AuthRecord *rr___0 ;
  struct mDNSInterfaceID_dummystruct *tmp___2 ;
  AuthRecord *r2 ;
  mDNSBool tmp___3 ;
  AuthRecord *rr___1 ;
  AuthRecord *rr___2 ;
  DNSMessage query ;
  mDNSu8 *queryptr ;
  CacheRecord **kalistptr ;
  mDNSu32 answerforecast ;
  mDNSInterfaceID tmp___4 ;
  mDNSBool tmp___5 ;
  mDNSBool tmp___6 ;
  mDNSBool ucast ;
  mDNSu16 ucbit ;
  int tmp___7 ;
  mDNSu8 const   *limit ;
  int tmp___8 ;
  mDNSu8 *newptr ;
  mDNSu8 *tmp___9 ;
  mDNSu32 forecast ;
  mDNSInterfaceID tmp___10 ;
  CacheRecord *rr___3 ;
  mDNSu32 SecsSinceRcvd ;
  mDNSu8 *newptr___0 ;
  mDNSu8 *tmp___11 ;
  mDNSu8 *newptr___1 ;
  mDNSu8 *tmp___12 ;
  char *tmp___13 ;
  NetworkInterfaceInfo const   *next ;
  NetworkInterfaceInfo const   *tmp___14 ;

  {
#line 3830
  pktcount = 0;
#line 3833
  maxExistingQuestionInterval = 0;
#line 3834
  tmp = GetFirstActiveInterface((NetworkInterfaceInfo const   *)m->HostInterfaces);
#line 3834
  intf = tmp;
#line 3835
  KnownAnswerList = (CacheRecord *)0L;
#line 3838
  if (m->timenow - m->NextScheduledQuery >= 0) {
#line 3842
    m->NextScheduledQuery = m->timenow + 2013265920;
#line 3846
    slot = 0U;
#line 3846
    while (slot < 499U) {
#line 3847
      rr = m->rrcache_hash[slot];
#line 3847
      while (rr) {
#line 3848
        if (rr->CRActiveQuestion) {
#line 3848
          if (rr->UnansweredQueries < 4U) {
#line 3849
            if ((m->timenow + ((int )rr->resrec.rroriginalttl * mDNSPlatformOneSecond) / 50) - rr->NextRequiredQuery >= 0) {
#line 3851
              q = rr->CRActiveQuestion;
#line 3852
              ExpireDupSuppressInfoOnInterface((DupSuppressInfo *)(q->DupSuppress),
                                               m->timenow - ((int )rr->resrec.rroriginalttl * mDNSPlatformOneSecond) / 20,
                                               rr->resrec.InterfaceID);
#line 3853
              if ((unsigned int )q->SendQNow == (unsigned int )((mDNSInterfaceID )0)) {
#line 3853
                q->SendQNow = rr->resrec.InterfaceID;
              } else {
#line 3854
                if ((unsigned int )q->SendQNow != (unsigned int )rr->resrec.InterfaceID) {
#line 3854
                  q->SendQNow = (struct mDNSInterfaceID_dummystruct *)mDNSInterfaceMark;
                }
              }
            }
          }
        }
#line 3847
        rr = rr->next;
      }
#line 3846
      slot ++;
    }
#line 3858
    q = m->Questions;
#line 3858
    while (q) {
#line 3859
      if (q->ThisQInterval > 0) {
#line 3859
        if (! q->DuplicateOf) {
#line 3859
          if (m->timenow - (q->LastQTime + q->ThisQInterval) >= 0) {
#line 3861
            q->SendQNow = (struct mDNSInterfaceID_dummystruct *)mDNSInterfaceMark;
#line 3862
            if (maxExistingQuestionInterval < q->ThisQInterval) {
#line 3863
              maxExistingQuestionInterval = q->ThisQInterval;
            }
          }
        }
      }
#line 3858
      q = q->next;
    }
#line 3869
    q = m->Questions;
#line 3869
    while (q) {
#line 3871
      if (q->SendQNow) {
        goto _L;
      } else {
#line 3871
        if (q->ThisQInterval > 0) {
#line 3871
          if (! q->DuplicateOf) {
#line 3871
            if (q->ThisQInterval <= maxExistingQuestionInterval) {
#line 3871
              tmp___1 = AccelerateThisQuery(m, q);
#line 3871
              if (tmp___1) {
                _L: /* CIL Label */ 
#line 3875
                if (m->timenow - (q->LastQTime + q->ThisQInterval / 2) >= 0) {
#line 3877
                  q->SendQNow = (struct mDNSInterfaceID_dummystruct *)mDNSInterfaceMark;
#line 3878
                  q->ThisQInterval *= 2;
#line 3879
                  if (q->ThisQInterval > 3600 * mDNSPlatformOneSecond) {
#line 3880
                    q->ThisQInterval = 3600 * mDNSPlatformOneSecond;
                  } else {
#line 3881
                    if (q->CurrentAnswers == 0U) {
#line 3881
                      if (q->ThisQInterval == (mDNSPlatformOneSecond / 2) * 8) {
#line 3884
                        ReconfirmAntecedents(m, q);
                      }
                    }
                  }
                }
#line 3889
                q->SendOnAll = (unsigned int )q->SendQNow == (unsigned int )mDNSInterfaceMark;
#line 3890
                if (q->SendOnAll) {
#line 3892
                  if (! intf) {
#line 3892
                    q->SendQNow = (struct mDNSInterfaceID_dummystruct *)0L;
                  } else {
#line 3892
                    if (q->InterfaceID) {
#line 3892
                      tmp___0 = (struct mDNSInterfaceID_dummystruct * const  )q->InterfaceID;
                    } else {
#line 3892
                      tmp___0 = intf->InterfaceID;
                    }
#line 3892
                    q->SendQNow = (struct mDNSInterfaceID_dummystruct *)tmp___0;
                  }
#line 3893
                  q->LastQTime = m->timenow;
                }
#line 3898
                ExpireDupSuppressInfo((DupSuppressInfo *)(q->DupSuppress), m->timenow - q->ThisQInterval / 2);
#line 3900
                q->LastQTxTime = m->timenow;
#line 3901
                q->RecentAnswers = 0U;
              }
            }
          }
        }
      }
#line 3904
      SetNextQueryTime(m, (DNSQuestion const   *)q);
#line 3869
      q = q->next;
    }
  }
#line 3909
  if (m->timenow - m->NextScheduledProbe >= 0) {
#line 3911
    m->NextScheduledProbe = m->timenow + 2013265920;
#line 3913
    if (m->CurrentRecord) {
#line 3913
      LogMsg("SendQueries:   ERROR m->CurrentRecord already set");
    }
#line 3914
    m->CurrentRecord = m->ResourceRecords;
#line 3915
    while (m->CurrentRecord) {
#line 3917
      rr___0 = m->CurrentRecord;
#line 3918
      m->CurrentRecord = rr___0->next;
#line 3919
      if ((int )rr___0->resrec.RecordType == 2) {
#line 3922
        if (m->timenow - (rr___0->LastAPTime + rr___0->ThisAPInterval) < 0) {
#line 3924
          SetNextAnnounceProbeTime(m, (AuthRecord const   *)rr___0);
        } else {
#line 3927
          if (rr___0->ProbeCount) {
#line 3930
            if (! intf) {
#line 3930
              rr___0->SendRNow = (struct mDNSInterfaceID_dummystruct *)0L;
            } else {
#line 3930
              if (rr___0->resrec.InterfaceID) {
#line 3930
                tmp___2 = (struct mDNSInterfaceID_dummystruct * const  )rr___0->resrec.InterfaceID;
              } else {
#line 3930
                tmp___2 = intf->InterfaceID;
              }
#line 3930
              rr___0->SendRNow = (struct mDNSInterfaceID_dummystruct *)tmp___2;
            }
#line 3931
            rr___0->LastAPTime = m->timenow;
#line 3932
            rr___0->ProbeCount = (mDNSu8 )((int )rr___0->ProbeCount - 1);
#line 3933
            SetNextAnnounceProbeTime(m, (AuthRecord const   *)rr___0);
          } else {
#line 3939
            rr___0->resrec.RecordType = (unsigned char)16;
#line 3940
            rr___0->ThisAPInterval = mDNSPlatformOneSecond / 2;
#line 3941
            rr___0->LastAPTime = m->timenow - mDNSPlatformOneSecond / 2;
#line 3942
            SetNextAnnounceProbeTime(m, (AuthRecord const   *)rr___0);
#line 3944
            r2 = m->DuplicateRecords;
#line 3944
            while (r2) {
#line 3945
              if ((int )r2->resrec.RecordType == 2) {
#line 3945
                if ((unsigned int )r2->resrec.InterfaceID == (unsigned int )rr___0->resrec.InterfaceID) {
#line 3945
                  if ((int )r2->resrec.RecordType == (int )rr___0->resrec.RecordType) {
                    goto _L___0;
                  } else {
#line 3945
                    if (((int )r2->resrec.RecordType | (int )rr___0->resrec.RecordType) == 18) {
                      _L___0: /* CIL Label */ 
#line 3945
                      tmp___3 = IdenticalResourceRecord((ResourceRecord const   *)(& r2->resrec),
                                                        (ResourceRecord const   *)(& rr___0->resrec));
#line 3945
                      if (tmp___3) {
#line 3946
                        r2->ProbeCount = (unsigned char)0;
                      }
                    }
                  }
                }
              }
#line 3944
              r2 = r2->next;
            }
#line 3947
            CompleteProbing(m, rr___0);
          }
        }
      }
    }
#line 3951
    m->CurrentRecord = m->DuplicateRecords;
#line 3952
    while (m->CurrentRecord) {
#line 3954
      rr___1 = m->CurrentRecord;
#line 3955
      m->CurrentRecord = rr___1->next;
#line 3956
      if ((int )rr___1->resrec.RecordType == 2) {
#line 3956
        if ((int )rr___1->ProbeCount == 0) {
#line 3957
          CompleteProbing(m, rr___1);
        }
      }
    }
  }
#line 3962
  while (intf) {
#line 3966
    queryptr = query.data;
#line 3967
    InitializeDNSMessage(& query.h, (union __anonunion_mDNSOpaque16_18 )zeroID, (union __anonunion_mDNSOpaque16_18 )QueryFlags);
#line 3968
    if (KnownAnswerList) {

    }
#line 3969
    if (! KnownAnswerList) {
#line 3972
      kalistptr = & KnownAnswerList;
#line 3973
      answerforecast = (mDNSu32 )0;
#line 3976
      q = m->Questions;
#line 3976
      while (q) {
#line 3977
        if ((unsigned int )q->SendQNow == (unsigned int )intf->InterfaceID) {
#line 3983
          tmp___5 = SuppressOnThisInterface((DupSuppressInfo const   *)(q->DupSuppress),
                                            intf);
#line 3983
          if (tmp___5) {
            goto _L___1;
          } else {
#line 3983
            tmp___6 = BuildQuestion(m, & query, & queryptr, q, & kalistptr, & answerforecast);
#line 3983
            if (tmp___6) {
              _L___1: /* CIL Label */ 
#line 3985
              if (q->InterfaceID) {
#line 3985
                q->SendQNow = (struct mDNSInterfaceID_dummystruct *)0L;
              } else {
#line 3985
                if (! q->SendOnAll) {
#line 3985
                  q->SendQNow = (struct mDNSInterfaceID_dummystruct *)0L;
                } else {
#line 3985
                  tmp___4 = GetNextActiveInterfaceID(intf);
#line 3985
                  q->SendQNow = tmp___4;
                }
              }
            }
          }
        }
#line 3976
        q = q->next;
      }
#line 3989
      rr___2 = m->ResourceRecords;
#line 3989
      while (rr___2) {
#line 3990
        if ((unsigned int )rr___2->SendRNow == (unsigned int )intf->InterfaceID) {
#line 3992
          ucast = (int )rr___2->ProbeCount >= 2;
#line 3993
          if (ucast) {
#line 3993
            tmp___7 = 32768;
          } else {
#line 3993
            tmp___7 = 0;
          }
#line 3993
          ucbit = (unsigned short )tmp___7;
#line 3994
          if (query.h.numQuestions) {
#line 3994
            tmp___8 = 1440;
          } else {
#line 3994
            tmp___8 = 8940;
          }
#line 3994
          limit = (mDNSu8 const   *)(query.data + tmp___8);
#line 3995
          tmp___9 = putQuestion(& query, queryptr, limit, (domainname const   *)(& rr___2->resrec.name),
                                (unsigned short)255, (unsigned short )((int )rr___2->resrec.rrclass | (int )ucbit));
#line 3995
          newptr = tmp___9;
#line 3997
          forecast = (answerforecast + 12U) + (mDNSu32 )rr___2->resrec.rdestimate;
#line 3998
          if (newptr) {
#line 3998
            if ((unsigned int )(newptr + forecast) < (unsigned int )limit) {
#line 4000
              queryptr = newptr;
#line 4001
              answerforecast = forecast;
#line 4002
              if (rr___2->resrec.InterfaceID) {
#line 4002
                rr___2->SendRNow = (struct mDNSInterfaceID_dummystruct *)0L;
              } else {
#line 4002
                tmp___10 = GetNextActiveInterfaceID(intf);
#line 4002
                rr___2->SendRNow = tmp___10;
              }
#line 4003
              rr___2->IncludeInProbe = (unsigned char)1;
            } else {
#line 4009
              query.h.numQuestions = (mDNSu16 )((int )query.h.numQuestions - 1);
            }
          } else {
#line 4009
            query.h.numQuestions = (mDNSu16 )((int )query.h.numQuestions - 1);
          }
        }
#line 3989
        rr___2 = rr___2->next;
      }
    }
#line 4015
    while (KnownAnswerList) {
#line 4017
      rr___3 = KnownAnswerList;
#line 4018
      SecsSinceRcvd = (unsigned int )(m->timenow - rr___3->TimeRcvd) / (unsigned int )mDNSPlatformOneSecond;
#line 4019
      tmp___11 = PutResourceRecordTTL(& query, queryptr, & query.h.numAnswers, & rr___3->resrec,
                                      rr___3->resrec.rroriginalttl - SecsSinceRcvd);
#line 4019
      newptr___0 = tmp___11;
#line 4020
      if (newptr___0) {
#line 4023
        queryptr = newptr___0;
#line 4024
        KnownAnswerList = rr___3->NextInKAList;
#line 4025
        rr___3->NextInKAList = (CacheRecord *)0L;
      } else {
#line 4031
        if ((int )query.h.numQuestions > 1) {
#line 4032
          LogMsg("SendQueries:   Put %d answers; No more space for known answers",
                 query.h.numAnswers);
        }
#line 4033
        query.h.flags.b[0] = (unsigned char )((int )query.h.flags.b[0] | 2);
#line 4034
        break;
      }
    }
#line 4038
    rr___2 = m->ResourceRecords;
#line 4038
    while (rr___2) {
#line 4039
      if (rr___2->IncludeInProbe) {
#line 4041
        tmp___12 = PutResourceRecordTTL(& query, queryptr, & query.h.numAuthorities,
                                        & rr___2->resrec, rr___2->resrec.rroriginalttl);
#line 4041
        newptr___1 = tmp___12;
#line 4042
        rr___2->IncludeInProbe = (unsigned char)0;
#line 4043
        if (newptr___1) {
#line 4043
          queryptr = newptr___1;
        } else {
#line 4044
          tmp___13 = DNSTypeName(rr___2->resrec.rrtype);
#line 4044
          LogMsg("SendQueries:   How did we fail to have space for the Update record %##s (%s)?",
                 rr___2->resrec.name.c, tmp___13);
        }
      }
#line 4038
      rr___2 = rr___2->next;
    }
#line 4048
    if ((unsigned int )queryptr > (unsigned int )(query.data)) {
#line 4050
      if ((int )query.h.flags.b[0] & 2) {
#line 4050
        if ((int )query.h.numQuestions > 1) {
#line 4051
          LogMsg("SendQueries: Should not have more than one question (%d) in a truncated packet\n",
                 query.h.numQuestions);
        }
      }
#line 4056
      mDNSSendDNSMessage((mDNS const   *)m, & query, (mDNSu8 const   *)queryptr, (struct mDNSInterfaceID_dummystruct *)intf->InterfaceID,
                         (union __anonunion_mDNSOpaque16_18 )MulticastDNSPort, & AllDNSLinkGroup_v4,
                         (union __anonunion_mDNSOpaque16_18 )MulticastDNSPort);
#line 4057
      mDNSSendDNSMessage((mDNS const   *)m, & query, (mDNSu8 const   *)queryptr, (struct mDNSInterfaceID_dummystruct *)intf->InterfaceID,
                         (union __anonunion_mDNSOpaque16_18 )MulticastDNSPort, & AllDNSLinkGroup_v6,
                         (union __anonunion_mDNSOpaque16_18 )MulticastDNSPort);
#line 4058
      if (! m->SuppressSending) {
#line 4058
        m->SuppressSending = (m->timenow + mDNSPlatformOneSecond / 10) | 1;
      }
#line 4059
      pktcount ++;
#line 4059
      if (pktcount >= 1000) {
#line 4060
        LogMsg("SendQueries exceeded loop limit %d: giving up", pktcount);
#line 4060
        break;
      }
    } else {
#line 4066
      tmp___14 = GetFirstActiveInterface((NetworkInterfaceInfo const   *)intf->next);
#line 4066
      next = tmp___14;
#line 4071
      intf = next;
    }
  }
#line 4074
  return;
}
}
#line 4084 "mDNS.c"
static void AnswerQuestionWithResourceRecord(mDNS *m , DNSQuestion *q , CacheRecord *rr ,
                                             mDNSBool AddRecord ) 
{ 

  {
#line 4089
  rr->LastUsed = m->timenow;
#line 4090
  (rr->UseCount) ++;
#line 4091
  if (q->ThisQInterval > 0) {
#line 4091
    if (! q->DuplicateOf) {
#line 4091
      if ((unsigned int )rr->CRActiveQuestion != (unsigned int )q) {
#line 4093
        if (! rr->CRActiveQuestion) {
#line 4093
          (m->rrcache_active) ++;
        }
#line 4094
        rr->CRActiveQuestion = q;
#line 4095
        SetNextCacheCheckTime(m, rr);
      }
    }
  }
#line 4103
  (m->mDNS_reentrancy) ++;
#line 4104
  if (q->QuestionCallback) {
#line 4105
    (*(q->QuestionCallback))(m, q, (ResourceRecord const   *)(& rr->resrec), AddRecord);
  }
#line 4106
  (m->mDNS_reentrancy) --;
#line 4107
  return;
}
}
#line 4117 "mDNS.c"
static void CacheRecordAdd(mDNS *m , CacheRecord *rr ) 
{ DNSQuestion *q ;
  char *tmp ;
  mDNSu32 tmp___0 ;
  mDNSBool tmp___1 ;

  {
#line 4119
  if (m->CurrentQuestion) {
#line 4119
    LogMsg("CacheRecordAdd ERROR m->CurrentQuestion already set");
  }
#line 4120
  m->CurrentQuestion = m->Questions;
#line 4121
  while (1) {
#line 4121
    if (m->CurrentQuestion) {
#line 4121
      if (! ((unsigned int )m->CurrentQuestion != (unsigned int )m->NewQuestions)) {
#line 4121
        break;
      }
    } else {
#line 4121
      break;
    }
#line 4123
    q = m->CurrentQuestion;
#line 4124
    m->CurrentQuestion = q->next;
#line 4125
    tmp___1 = ResourceRecordAnswersQuestion((ResourceRecord const   *)(& rr->resrec),
                                            (DNSQuestion const   *)q);
#line 4125
    if (tmp___1) {
#line 4132
      if (q->ThisQInterval > 0) {
#line 4132
        if (! q->DuplicateOf) {
#line 4132
          (q->RecentAnswers) ++;
#line 4132
          if (q->RecentAnswers >= 10U) {
#line 4132
            if (q->ThisQInterval > (mDNSPlatformOneSecond / 2) * 16) {
#line 4132
              if (m->timenow - q->LastQTxTime < mDNSPlatformOneSecond) {
#line 4135
                tmp = DNSTypeName(q->qtype);
#line 4135
                LogMsg("CacheRecordAdd: %##s (%s) got immediate answer burst; restarting exponential backoff sequence",
                       q->qname.c, tmp);
#line 4137
                tmp___0 = mDNSRandom((unsigned int )mDNSPlatformOneSecond * 4U);
#line 4137
                q->LastQTime = (m->timenow - mDNSPlatformOneSecond / 2) + (int )tmp___0;
#line 4138
                q->ThisQInterval = mDNSPlatformOneSecond / 2;
#line 4139
                SetNextQueryTime(m, (DNSQuestion const   *)q);
              }
            }
          }
        }
      }
#line 4142
      (q->CurrentAnswers) ++;
#line 4143
      if ((int )rr->resrec.rdlength > 1024) {
#line 4143
        (q->LargeAnswers) ++;
      }
#line 4144
      if ((int )rr->resrec.RecordType & 32) {
#line 4144
        (q->UniqueAnswers) ++;
      }
#line 4145
      AnswerQuestionWithResourceRecord(m, q, rr, 1);
    }
  }
#line 4149
  m->CurrentQuestion = (DNSQuestion *)0L;
#line 4150
  return;
}
}
#line 4160 "mDNS.c"
static void CacheRecordRmv(mDNS *m , CacheRecord *rr ) 
{ DNSQuestion *q ;
  char *tmp ;
  mDNSBool tmp___0 ;

  {
#line 4162
  if (m->CurrentQuestion) {
#line 4162
    LogMsg("CacheRecordRmv ERROR m->CurrentQuestion already set");
  }
#line 4163
  m->CurrentQuestion = m->Questions;
#line 4164
  while (1) {
#line 4164
    if (m->CurrentQuestion) {
#line 4164
      if (! ((unsigned int )m->CurrentQuestion != (unsigned int )m->NewQuestions)) {
#line 4164
        break;
      }
    } else {
#line 4164
      break;
    }
#line 4166
    q = m->CurrentQuestion;
#line 4167
    m->CurrentQuestion = q->next;
#line 4168
    tmp___0 = ResourceRecordAnswersQuestion((ResourceRecord const   *)(& rr->resrec),
                                            (DNSQuestion const   *)q);
#line 4168
    if (tmp___0) {
#line 4171
      if (q->CurrentAnswers == 0U) {
#line 4172
        tmp = DNSTypeName(q->qtype);
#line 4172
        LogMsg("CacheRecordRmv ERROR: How can CurrentAnswers already be zero for %p %##s (%s)?",
               q, q->qname.c, tmp);
      } else {
#line 4175
        (q->CurrentAnswers) --;
#line 4176
        if ((int )rr->resrec.rdlength > 1024) {
#line 4176
          (q->LargeAnswers) --;
        }
#line 4177
        if ((int )rr->resrec.RecordType & 32) {
#line 4177
          (q->UniqueAnswers) --;
        }
      }
#line 4179
      if (q->CurrentAnswers == 0U) {
#line 4182
        ReconfirmAntecedents(m, q);
      }
#line 4184
      AnswerQuestionWithResourceRecord(m, q, rr, 0);
    }
  }
#line 4188
  m->CurrentQuestion = (DNSQuestion *)0L;
#line 4189
  return;
}
}
#line 4191 "mDNS.c"
static void ReleaseCacheRR(mDNS *m , CacheRecord *r ) 
{ 

  {
#line 4193
  if (r->resrec.rdata) {
#line 4193
    if ((unsigned int )r->resrec.rdata != (unsigned int )((RData *)(& r->rdatastorage))) {
#line 4194
      mDNSPlatformMemFree((void *)r->resrec.rdata);
    }
  }
#line 4195
  r->resrec.rdata = (RData *)0L;
#line 4196
  r->next = m->rrcache_free;
#line 4197
  m->rrcache_free = r;
#line 4198
  (m->rrcache_totalused) --;
#line 4199
  return;
}
}
#line 4201 "mDNS.c"
static void CheckCacheExpiration(mDNS *m , mDNSu32 slot ) 
{ CacheRecord **rp ;
  CacheRecord *rr ;
  mDNSs32 event ;
  mDNSs32 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  mDNSs32 tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 4203
  rp = & m->rrcache_hash[slot];
#line 4205
  if (m->lock_rrcache) {
#line 4205
    LogMsg("CheckCacheExpiration ERROR! Cache already locked!");
#line 4205
    return;
  }
#line 4206
  m->lock_rrcache = (unsigned char)1;
#line 4208
  while (*rp) {
#line 4210
    rr = *rp;
#line 4211
    event = rr->TimeRcvd + (int )rr->resrec.rroriginalttl * mDNSPlatformOneSecond;
#line 4212
    if (m->timenow - event >= 0) {
#line 4214
      *rp = rr->next;
#line 4216
      if (rr->CRActiveQuestion) {
#line 4218
        CacheRecordRmv(m, rr);
#line 4219
        (m->rrcache_active) --;
      }
#line 4221
      (m->rrcache_used[slot]) --;
#line 4222
      ReleaseCacheRR(m, rr);
    } else {
#line 4226
      if (rr->CRActiveQuestion) {
#line 4226
        if (rr->UnansweredQueries < 4U) {
#line 4228
          if (m->timenow - rr->NextRequiredQuery < 0) {
#line 4229
            event = rr->NextRequiredQuery;
          } else {
#line 4234
            m->NextScheduledQuery = m->timenow;
#line 4237
            event = m->timenow + 1073741823;
          }
        }
      }
#line 4240
      if ((unsigned int )rr->CRActiveQuestion == (unsigned int )((DNSQuestion *)0)) {
#line 4240
        tmp___4 = 60 * mDNSPlatformOneSecond;
      } else {
#line 4240
        if (rr->UnansweredQueries < 4U) {
#line 4240
          tmp___3 = ((int )rr->resrec.rroriginalttl * mDNSPlatformOneSecond) / 50;
        } else {
#line 4240
          if (rr->resrec.rroriginalttl > 10U) {
#line 4240
            tmp___2 = mDNSPlatformOneSecond;
          } else {
#line 4240
            tmp___2 = mDNSPlatformOneSecond / 10;
          }
#line 4240
          tmp___3 = tmp___2;
        }
#line 4240
        tmp___4 = tmp___3;
      }
#line 4240
      if (m->NextCacheCheck - (event + tmp___4) > 0) {
#line 4241
        if ((unsigned int )rr->CRActiveQuestion == (unsigned int )((DNSQuestion *)0)) {
#line 4241
          tmp___1 = 60 * mDNSPlatformOneSecond;
        } else {
#line 4241
          if (rr->UnansweredQueries < 4U) {
#line 4241
            tmp___0 = ((int )rr->resrec.rroriginalttl * mDNSPlatformOneSecond) / 50;
          } else {
#line 4241
            if (rr->resrec.rroriginalttl > 10U) {
#line 4241
              tmp = mDNSPlatformOneSecond;
            } else {
#line 4241
              tmp = mDNSPlatformOneSecond / 10;
            }
#line 4241
            tmp___0 = tmp;
          }
#line 4241
          tmp___1 = tmp___0;
        }
#line 4241
        m->NextCacheCheck = event + tmp___1;
      }
#line 4242
      rp = & rr->next;
    }
  }
#line 4245
  if ((unsigned int )m->rrcache_tail[slot] != (unsigned int )rp) {

  }
#line 4246
  m->rrcache_tail[slot] = rp;
#line 4247
  m->lock_rrcache = (unsigned char)0;
#line 4248
  return;
}
}
#line 4250 "mDNS.c"
static void AnswerNewQuestion(mDNS *m ) 
{ mDNSBool ShouldQueryImmediately ;
  CacheRecord *rr ;
  DNSQuestion *q ;
  mDNSu32 slot ;
  mDNSu32 tmp ;
  mDNSu32 SecsSinceRcvd ;
  char *tmp___0 ;
  mDNSBool tmp___1 ;
  mDNSBool tmp___2 ;

  {
#line 4252
  ShouldQueryImmediately = (mDNSBool )1;
#line 4254
  q = m->NewQuestions;
#line 4255
  tmp = DomainNameHashValue((domainname const   *)(& q->qname));
#line 4255
  slot = tmp % 499U;
#line 4259
  CheckCacheExpiration(m, slot);
#line 4260
  m->NewQuestions = q->next;
#line 4262
  if (m->lock_rrcache) {
#line 4262
    LogMsg("AnswerNewQuestion ERROR! Cache already locked!");
  }
#line 4267
  m->lock_rrcache = (unsigned char)1;
#line 4268
  if (m->CurrentQuestion) {
#line 4268
    LogMsg("AnswerNewQuestion ERROR m->CurrentQuestion already set");
  }
#line 4269
  m->CurrentQuestion = q;
#line 4270
  rr = m->rrcache_hash[slot];
#line 4270
  while (rr) {
#line 4271
    tmp___2 = ResourceRecordAnswersQuestion((ResourceRecord const   *)(& rr->resrec),
                                            (DNSQuestion const   *)q);
#line 4271
    if (tmp___2) {
#line 4274
      SecsSinceRcvd = (unsigned int )(m->timenow - rr->TimeRcvd) / (unsigned int )mDNSPlatformOneSecond;
#line 4275
      if (rr->resrec.rroriginalttl <= SecsSinceRcvd) {
#line 4277
        tmp___0 = DNSTypeName(rr->resrec.rrtype);
#line 4277
        LogMsg("AnswerNewQuestion: How is rr->resrec.rroriginalttl %lu <= SecsSinceRcvd %lu for %##s (%s)",
               rr->resrec.rroriginalttl, SecsSinceRcvd, rr->resrec.name.c, tmp___0);
        goto __Cont;
      }
#line 4284
      if ((int )rr->resrec.RecordType & 32) {
#line 4284
        ShouldQueryImmediately = 0;
      }
#line 4285
      (q->CurrentAnswers) ++;
#line 4286
      if ((int )rr->resrec.rdlength > 1024) {
#line 4286
        (q->LargeAnswers) ++;
      }
#line 4287
      if ((int )rr->resrec.RecordType & 32) {
#line 4287
        (q->UniqueAnswers) ++;
      }
#line 4288
      AnswerQuestionWithResourceRecord(m, q, rr, 1);
#line 4290
      if ((unsigned int )m->CurrentQuestion != (unsigned int )q) {
#line 4290
        break;
      }
    } else {
#line 4292
      if ((int )rr->resrec.rrtype == 1) {
        goto _L___0;
      } else {
#line 4292
        if ((int )rr->resrec.rrtype == 28) {
          _L___0: /* CIL Label */ 
#line 4292
          if ((int )q->qtype == 1) {
            goto _L;
          } else {
#line 4292
            if ((int )q->qtype == 28) {
              _L: /* CIL Label */ 
#line 4293
              if (rr->resrec.namehash == q->qnamehash) {
#line 4293
                tmp___1 = SameDomainName((domainname const   *)(& rr->resrec.name),
                                         (domainname const   *)(& q->qname));
#line 4293
                if (tmp___1) {
#line 4294
                  ShouldQueryImmediately = 0;
                }
              }
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 4270
    rr = rr->next;
  }
#line 4296
  if (ShouldQueryImmediately) {
#line 4296
    if ((unsigned int )m->CurrentQuestion == (unsigned int )q) {
#line 4298
      q->ThisQInterval = mDNSPlatformOneSecond / 2;
#line 4299
      q->LastQTime = m->timenow - q->ThisQInterval;
#line 4300
      m->NextScheduledQuery = m->timenow;
    }
  }
#line 4302
  m->CurrentQuestion = (DNSQuestion *)0L;
#line 4303
  m->lock_rrcache = (unsigned char)0;
#line 4304
  return;
}
}
#line 4306 "mDNS.c"
static void AnswerLocalOnlyQuestionWithResourceRecord(mDNS *m , DNSQuestion *q , AuthRecord *rr ,
                                                      mDNSBool AddRecord ) 
{ 

  {
#line 4309
  if (AddRecord) {
#line 4309
    rr->AnnounceCount = (unsigned char)9;
  }
#line 4310
  (m->mDNS_reentrancy) ++;
#line 4311
  if (q->QuestionCallback) {
#line 4312
    (*(q->QuestionCallback))(m, q, (ResourceRecord const   *)(& rr->resrec), AddRecord);
  }
#line 4313
  (m->mDNS_reentrancy) --;
#line 4314
  return;
}
}
#line 4316 "mDNS.c"
static void AnswerNewLocalOnlyQuestion(mDNS *m ) 
{ DNSQuestion *q ;
  AuthRecord *rr ;
  mDNSBool tmp ;

  {
#line 4318
  q = m->NewLocalOnlyQuestions;
#line 4319
  m->NewLocalOnlyQuestions = q->next;
#line 4323
  if (m->CurrentQuestion) {
#line 4323
    LogMsg("AnswerNewQuestion ERROR m->CurrentQuestion already set");
  }
#line 4324
  m->CurrentQuestion = q;
#line 4326
  m->CurrentRecord = m->LocalOnlyRecords;
#line 4327
  while (1) {
#line 4327
    if (m->CurrentRecord) {
#line 4327
      if (! ((unsigned int )m->CurrentRecord != (unsigned int )m->NewLocalOnlyRecords)) {
#line 4327
        break;
      }
    } else {
#line 4327
      break;
    }
#line 4329
    rr = m->CurrentRecord;
#line 4330
    m->CurrentRecord = rr->next;
#line 4331
    tmp = ResourceRecordAnswersQuestion((ResourceRecord const   *)(& rr->resrec),
                                        (DNSQuestion const   *)q);
#line 4331
    if (tmp) {
#line 4333
      AnswerLocalOnlyQuestionWithResourceRecord(m, q, rr, 1);
#line 4335
      if ((unsigned int )m->CurrentQuestion != (unsigned int )q) {
#line 4335
        break;
      }
    }
  }
#line 4339
  m->CurrentQuestion = (DNSQuestion *)0L;
#line 4340
  return;
}
}
#line 4342 "mDNS.c"
static void AnswerLocalOnlyQuestions(mDNS *m , AuthRecord *rr , mDNSBool AddRecord ) 
{ DNSQuestion *q ;
  mDNSBool tmp ;

  {
#line 4344
  if (m->CurrentQuestion) {
#line 4344
    LogMsg("AnswerLocalOnlyQuestions ERROR m->CurrentQuestion already set");
  }
#line 4345
  m->CurrentQuestion = m->LocalOnlyQuestions;
#line 4346
  while (1) {
#line 4346
    if (m->CurrentQuestion) {
#line 4346
      if (! ((unsigned int )m->CurrentQuestion != (unsigned int )m->NewLocalOnlyQuestions)) {
#line 4346
        break;
      }
    } else {
#line 4346
      break;
    }
#line 4348
    q = m->CurrentQuestion;
#line 4349
    m->CurrentQuestion = q->next;
#line 4350
    tmp = ResourceRecordAnswersQuestion((ResourceRecord const   *)(& rr->resrec),
                                        (DNSQuestion const   *)q);
#line 4350
    if (tmp) {
#line 4353
      AnswerLocalOnlyQuestionWithResourceRecord(m, q, rr, AddRecord);
    }
  }
#line 4357
  m->CurrentQuestion = (DNSQuestion *)0L;
#line 4358
  return;
}
}
#line 4360 "mDNS.c"
static void DiscardLocalOnlyRecords(mDNS *m ) 
{ AuthRecord *rr ;

  {
#line 4362
  rr = m->LocalOnlyRecords;
#line 4363
  while (rr) {
#line 4365
    if ((int )rr->resrec.RecordType == 1) {
#line 4366
      AnswerLocalOnlyQuestions(m, rr, 0);
#line 4366
      CompleteDeregistration(m, rr);
#line 4366
      return;
    }
#line 4367
    if (rr->ProbeCount) {
#line 4367
      mDNS_Deregister_internal(m, rr, 1);
#line 4367
      return;
    }
#line 4368
    rr = rr->next;
  }
#line 4370
  m->DiscardLocalOnlyRecords = 0;
#line 4371
  return;
}
}
#line 4373 "mDNS.c"
static void AnswerForNewLocalOnlyRecords(mDNS *m ) 
{ AuthRecord *rr ;

  {
#line 4375
  rr = m->NewLocalOnlyRecords;
#line 4376
  m->NewLocalOnlyRecords = (m->NewLocalOnlyRecords)->next;
#line 4377
  AnswerLocalOnlyQuestions(m, rr, 1);
#line 4378
  return;
}
}
#line 4380 "mDNS.c"
static CacheRecord *GetFreeCacheRR(mDNS *m , mDNSu16 RDLength ) 
{ CacheRecord *r ;
  mDNSu32 slot ;
  CacheRecord **rp ;
  CacheRecord *rr ;
  void *tmp ;
  mDNSu16 tmp___0 ;

  {
#line 4382
  r = (CacheRecord *)0L;
#line 4384
  if (m->lock_rrcache) {
#line 4384
    LogMsg("GetFreeCacheRR ERROR! Cache already locked!");
#line 4384
    return ((CacheRecord *)0L);
  }
#line 4385
  m->lock_rrcache = (unsigned char)1;
#line 4388
  if (! m->rrcache_free) {
#line 4388
    if (m->MainCallback) {
#line 4390
      if (m->rrcache_totalused != m->rrcache_size) {
#line 4391
        LogMsg("GetFreeCacheRR: count mismatch: m->rrcache_totalused %lu != m->rrcache_size %lu",
               m->rrcache_totalused, m->rrcache_size);
      }
#line 4398
      if (m->rrcache_size >= 512U) {
#line 4398
        if (! (m->rrcache_size / 32U > m->rrcache_active)) {
#line 4402
          (*(m->MainCallback))(m, -65790);
        }
      } else {
#line 4402
        (*(m->MainCallback))(m, -65790);
      }
    }
  }
#line 4407
  if (! m->rrcache_free) {
#line 4413
    slot = 0U;
#line 4413
    while (slot < 499U) {
#line 4415
      rp = & m->rrcache_hash[slot];
#line 4416
      while (*rp) {
#line 4419
        if ((*rp)->CRActiveQuestion) {
#line 4420
          rp = & (*rp)->next;
        } else {
#line 4423
          rr = *rp;
#line 4424
          *rp = (*rp)->next;
#line 4425
          (m->rrcache_used[slot]) --;
#line 4426
          ReleaseCacheRR(m, rr);
        }
      }
#line 4429
      if ((unsigned int )m->rrcache_tail[slot] != (unsigned int )rp) {

      }
#line 4430
      m->rrcache_tail[slot] = rp;
#line 4413
      slot ++;
    }
  }
#line 4437
  if (m->rrcache_free) {
#line 4439
    r = m->rrcache_free;
#line 4440
    m->rrcache_free = r->next;
  }
#line 4443
  if (r) {
#line 4445
    (m->rrcache_totalused) ++;
#line 4445
    if (m->rrcache_totalused >= m->rrcache_report) {
#line 4448
      if (m->rrcache_report < 100U) {
#line 4448
        m->rrcache_report += 10U;
      } else {
#line 4449
        m->rrcache_report += 100U;
      }
    }
#line 4451
    mDNSPlatformMemZero((void *)r, sizeof(*r));
#line 4452
    r->resrec.rdata = (RData *)(& r->rdatastorage);
#line 4454
    if ((int )RDLength > 64) {
#line 4456
      tmp = mDNSPlatformMemAllocate((sizeof(RData ) - sizeof(RDataBody )) + (unsigned int )RDLength);
#line 4456
      r->resrec.rdata = (RData *)tmp;
#line 4457
      if (r->resrec.rdata) {
#line 4457
        tmp___0 = RDLength;
#line 4457
        r->resrec.rdlength = tmp___0;
#line 4457
        (r->resrec.rdata)->MaxRDLength = tmp___0;
      } else {
#line 4458
        ReleaseCacheRR(m, r);
#line 4458
        r = (CacheRecord *)0L;
      }
    }
  }
#line 4462
  m->lock_rrcache = (unsigned char)0;
#line 4464
  return (r);
}
}
#line 4467 "mDNS.c"
static void PurgeCacheResourceRecord(mDNS *m , CacheRecord *rr ) 
{ 

  {
#line 4474
  rr->TimeRcvd = m->timenow - mDNSPlatformOneSecond * 60;
#line 4475
  rr->UnansweredQueries = 4U;
#line 4476
  rr->resrec.rroriginalttl = 0U;
#line 4477
  SetNextCacheCheckTime(m, rr);
#line 4478
  return;
}
}
#line 4480 "mDNS.c"
static void mDNS_Lock(mDNS *m ) 
{ mDNSs32 tmp ;
  mDNSs32 tmp___0 ;
  mDNSs32 tmp___1 ;

  {
#line 4483
  mDNSPlatformLock((mDNS const   *)m);
#line 4489
  if (m->mDNS_busy != m->mDNS_reentrancy) {
#line 4490
    LogMsg("mDNS_Lock: Locking failure! mDNS_busy (%ld) != mDNS_reentrancy (%ld)",
           m->mDNS_busy, m->mDNS_reentrancy);
  }
#line 4494
  if (m->mDNS_busy == 0U) {
#line 4496
    if (m->timenow) {
#line 4497
      tmp = mDNSPlatformTimeNow();
#line 4497
      LogMsg("mDNS_Lock: m->timenow already set (%ld/%ld)", m->timenow, tmp + m->timenow_adjust);
    }
#line 4498
    tmp___0 = mDNSPlatformTimeNow();
#line 4498
    m->timenow = tmp___0 + m->timenow_adjust;
#line 4499
    if (m->timenow == 0) {
#line 4499
      m->timenow = 1;
    }
  } else {
#line 4501
    if (m->timenow == 0) {
#line 4503
      LogMsg("mDNS_Lock: m->mDNS_busy is %ld but m->timenow not set", m->mDNS_busy);
#line 4504
      tmp___1 = mDNSPlatformTimeNow();
#line 4504
      m->timenow = tmp___1 + m->timenow_adjust;
#line 4505
      if (m->timenow == 0) {
#line 4505
        m->timenow = 1;
      }
    }
  }
#line 4508
  if (m->timenow_last - m->timenow > 0) {
#line 4510
    m->timenow_adjust += m->timenow_last - m->timenow;
#line 4511
    LogMsg("mDNSPlatformTimeNow went backwards by %ld ticks; setting correction factor to %ld",
           m->timenow_last - m->timenow, m->timenow_adjust);
#line 4512
    m->timenow = m->timenow_last;
  }
#line 4514
  m->timenow_last = m->timenow;
#line 4517
  (m->mDNS_busy) ++;
#line 4518
  return;
}
}
#line 4520 "mDNS.c"
static mDNSs32 GetNextScheduledEvent(mDNS const   *m ) 
{ mDNSs32 e ;

  {
#line 4522
  e = (mDNSs32 )(m->timenow + 2013265920);
#line 4523
  if (m->mDNSPlatformStatus != 0) {
#line 4523
    return (e);
  } else {
#line 4523
    if (m->SleepState) {
#line 4523
      return (e);
    }
  }
#line 4524
  if (m->NewQuestions) {
#line 4524
    return ((int )m->timenow);
  }
#line 4525
  if (m->NewLocalOnlyQuestions) {
#line 4525
    return ((int )m->timenow);
  }
#line 4526
  if (m->NewLocalOnlyRecords) {
#line 4526
    return ((int )m->timenow);
  }
#line 4527
  if (m->DiscardLocalOnlyRecords) {
#line 4527
    return ((int )m->timenow);
  }
#line 4528
  if (m->SuppressSending) {
#line 4528
    return ((int )m->SuppressSending);
  }
#line 4529
  if (e - (mDNSs32 )m->NextCacheCheck > 0) {
#line 4529
    e = (int )m->NextCacheCheck;
  }
#line 4530
  if (e - (mDNSs32 )m->NextScheduledQuery > 0) {
#line 4530
    e = (int )m->NextScheduledQuery;
  }
#line 4531
  if (e - (mDNSs32 )m->NextScheduledProbe > 0) {
#line 4531
    e = (int )m->NextScheduledProbe;
  }
#line 4532
  if (e - (mDNSs32 )m->NextScheduledResponse > 0) {
#line 4532
    e = (int )m->NextScheduledResponse;
  }
#line 4533
  return (e);
}
}
#line 4536 "mDNS.c"
static void mDNS_Unlock(mDNS *m ) 
{ 

  {
#line 4539
  (m->mDNS_busy) --;
#line 4542
  if (m->mDNS_busy != m->mDNS_reentrancy) {
#line 4543
    LogMsg("mDNS_Unlock: Locking failure! mDNS_busy (%ld) != mDNS_reentrancy (%ld)",
           m->mDNS_busy, m->mDNS_reentrancy);
  }
#line 4546
  if (m->mDNS_busy == 0U) {
#line 4548
    m->NextScheduledEvent = GetNextScheduledEvent((mDNS const   *)m);
#line 4549
    if (m->timenow == 0) {
#line 4549
      LogMsg("mDNS_Unlock: ERROR! m->timenow aready zero");
    }
#line 4550
    m->timenow = 0;
  }
#line 4554
  mDNSPlatformUnlock((mDNS const   *)m);
#line 4555
  return;
}
}
#line 4557 "mDNS.c"
mDNSs32 mDNS_Execute(mDNS *m ) 
{ int i ;
  mDNSu32 slot ;

  {
#line 4559
  mDNS_Lock(m);
#line 4561
  if (m->timenow - m->NextScheduledEvent >= 0) {
#line 4566
    if (m->CurrentQuestion) {
#line 4566
      LogMsg("mDNS_Execute: ERROR! m->CurrentQuestion already set");
    }
#line 4569
    if (m->SuppressProbes) {
#line 4569
      if (m->timenow - m->SuppressProbes >= 0) {
#line 4569
        m->SuppressProbes = 0;
      }
    }
#line 4572
    if (m->NumFailedProbes) {
#line 4572
      if (m->timenow - m->ProbeFailTime >= mDNSPlatformOneSecond * 10) {
#line 4572
        m->NumFailedProbes = 0;
      }
    }
#line 4575
    if (m->rrcache_size) {
#line 4575
      if (m->timenow - m->NextCacheCheck >= 0) {
#line 4578
        m->NextCacheCheck = m->timenow + 1073741823;
#line 4579
        slot = 0U;
#line 4579
        while (slot < 499U) {
#line 4579
          CheckCacheExpiration(m, slot);
#line 4579
          slot ++;
        }
      }
    }
#line 4583
    i = 0;
#line 4583
    while (1) {
#line 4583
      if (m->NewQuestions) {
#line 4583
        if (! (i < 1000)) {
#line 4583
          break;
        }
      } else {
#line 4583
        break;
      }
#line 4583
      AnswerNewQuestion(m);
#line 4583
      i ++;
    }
#line 4584
    if (i >= 1000) {

    }
#line 4586
    i = 0;
#line 4586
    while (1) {
#line 4586
      if (m->DiscardLocalOnlyRecords) {
#line 4586
        if (! (i < 1000)) {
#line 4586
          break;
        }
      } else {
#line 4586
        break;
      }
#line 4586
      DiscardLocalOnlyRecords(m);
#line 4586
      i ++;
    }
#line 4587
    if (i >= 1000) {

    }
#line 4589
    i = 0;
#line 4589
    while (1) {
#line 4589
      if (m->NewLocalOnlyQuestions) {
#line 4589
        if (! (i < 1000)) {
#line 4589
          break;
        }
      } else {
#line 4589
        break;
      }
#line 4589
      AnswerNewLocalOnlyQuestion(m);
#line 4589
      i ++;
    }
#line 4590
    if (i >= 1000) {

    }
#line 4592
    i = 0;
#line 4592
    while (1) {
#line 4592
      if (m->NewLocalOnlyRecords) {
#line 4592
        if (! (i < 1000)) {
#line 4592
          break;
        }
      } else {
#line 4592
        break;
      }
#line 4592
      AnswerForNewLocalOnlyRecords(m);
#line 4592
      i ++;
    }
#line 4593
    if (i >= 1000) {

    }
#line 4596
    if (m->mDNSPlatformStatus != 0) {
#line 4596
      DiscardDeregistrations(m);
    } else {
#line 4596
      if (m->SleepState) {
#line 4596
        DiscardDeregistrations(m);
      } else {
#line 4597
        if (m->SuppressSending == 0) {
          goto _L;
        } else {
#line 4597
          if (m->timenow - m->SuppressSending >= 0) {
            _L: /* CIL Label */ 
#line 4605
            m->SuppressSending = 0;
#line 4608
            if (m->timenow - m->NextScheduledQuery >= 0) {
#line 4608
              SendQueries(m);
            } else {
#line 4608
              if (m->timenow - m->NextScheduledProbe >= 0) {
#line 4608
                SendQueries(m);
              }
            }
#line 4609
            if (m->timenow - m->NextScheduledQuery >= 0) {
#line 4611
              LogMsg("mDNS_Execute: SendQueries didn\'t send all its queries; will try again in one second");
#line 4612
              m->NextScheduledQuery = m->timenow + mDNSPlatformOneSecond;
            }
#line 4614
            if (m->timenow - m->NextScheduledProbe >= 0) {
#line 4616
              LogMsg("mDNS_Execute: SendQueries didn\'t send all its probes; will try again in one second");
#line 4617
              m->NextScheduledProbe = m->timenow + mDNSPlatformOneSecond;
            }
#line 4621
            if (m->timenow - m->NextScheduledResponse >= 0) {
#line 4621
              SendResponses(m);
            }
#line 4622
            if (m->timenow - m->NextScheduledResponse >= 0) {
#line 4624
              LogMsg("mDNS_Execute: SendResponses didn\'t send all its responses; will try again in one second");
#line 4625
              m->NextScheduledResponse = m->timenow + mDNSPlatformOneSecond;
            }
          }
        }
      }
    }
#line 4629
    m->RandomQueryDelay = 0;
  }
#line 4652
  mDNS_Unlock(m);
#line 4653
  return (m->NextScheduledEvent);
}
}
#line 4667 "mDNS.c"
void mDNSCoreMachineSleep(mDNS *m , mDNSBool sleepstate ) 
{ AuthRecord *rr ;
  char const   *tmp ;
  DNSQuestion *q ;
  mDNSu32 slot ;
  CacheRecord *cr ;
  mDNSs32 tmp___0 ;
  mDNSs32 tmp___1 ;

  {
#line 4671
  mDNS_Lock(m);
#line 4673
  m->SleepState = sleepstate;
#line 4674
  if (sleepstate) {
#line 4674
    tmp = "Sleeping";
  } else {
#line 4674
    tmp = "Waking";
  }
#line 4674
  LogMsg("mDNSResponder %s at %ld", tmp, m->timenow);
#line 4676
  if (sleepstate) {
#line 4679
    rr = m->ResourceRecords;
#line 4679
    while (rr) {
#line 4680
      if ((int )rr->resrec.RecordType == 8) {
#line 4680
        if ((int )rr->AnnounceCount < 10) {
#line 4681
          rr->ImmedAnswer = (struct mDNSInterfaceID_dummystruct *)mDNSInterfaceMark;
        }
      }
#line 4679
      rr = rr->next;
    }
#line 4682
    SendResponses(m);
  } else {
#line 4691
    q = m->Questions;
#line 4691
    while (q) {
#line 4692
      if (q->ThisQInterval > 0) {
#line 4692
        if (! q->DuplicateOf) {
#line 4694
          q->ThisQInterval = mDNSPlatformOneSecond / 2;
#line 4695
          q->LastQTime = m->timenow - q->ThisQInterval;
#line 4696
          q->RecentAnswers = 0U;
#line 4697
          ExpireDupSuppressInfo((DupSuppressInfo *)(q->DupSuppress), m->timenow);
#line 4698
          m->NextScheduledQuery = m->timenow;
        }
      }
#line 4691
      q = q->next;
    }
#line 4702
    m->NextCacheCheck = m->timenow;
#line 4703
    slot = 0U;
#line 4703
    while (slot < 499U) {
#line 4704
      cr = m->rrcache_hash[slot];
#line 4704
      while (cr) {
#line 4705
        mDNS_Reconfirm_internal(m, cr, (unsigned int )mDNSPlatformOneSecond * 5U);
#line 4704
        cr = cr->next;
      }
#line 4703
      slot ++;
    }
#line 4708
    rr = m->ResourceRecords;
#line 4708
    while (rr) {
#line 4710
      if ((int )rr->resrec.RecordType == 16) {
#line 4710
        if (! rr->DependentOn) {
#line 4710
          rr->resrec.RecordType = (unsigned char)2;
        }
      }
#line 4711
      if ((int )rr->resrec.RecordType == 2) {
#line 4711
        rr->ProbeCount = (unsigned char)3;
      } else {
#line 4711
        rr->ProbeCount = (unsigned char)0;
      }
#line 4712
      if ((int )rr->AnnounceCount < 9) {
#line 4713
        rr->AnnounceCount = (unsigned char)9;
      }
#line 4714
      if ((int )rr->resrec.RecordType & 12) {
#line 4714
        rr->ThisAPInterval = mDNSPlatformOneSecond / 2;
      } else {
#line 4714
        if ((int )rr->resrec.RecordType & 2) {
#line 4714
          tmp___1 = mDNSPlatformOneSecond / 4;
        } else {
#line 4714
          if ((int )rr->resrec.RecordType & 48) {
#line 4714
            tmp___0 = mDNSPlatformOneSecond / 2;
          } else {
#line 4714
            tmp___0 = 0;
          }
#line 4714
          tmp___1 = tmp___0;
        }
#line 4714
        rr->ThisAPInterval = tmp___1;
      }
#line 4715
      InitializeLastAPTime(m, rr);
#line 4708
      rr = rr->next;
    }
  }
#line 4720
  mDNS_Unlock(m);
#line 4721
  return;
}
}
#line 4729 "mDNS.c"
static void AddRecordToResponseList(AuthRecord ***nrpp , AuthRecord *rr , AuthRecord *add ) 
{ 

  {
#line 4731
  if ((unsigned int )rr->NextResponse == (unsigned int )((AuthRecord *)0)) {
#line 4731
    if ((unsigned int )*nrpp != (unsigned int )(& rr->NextResponse)) {
#line 4733
      *(*nrpp) = rr;
#line 4737
      if (add) {
#line 4737
        if (add->NR_AdditionalTo) {
#line 4737
          add = add->NR_AdditionalTo;
        }
      }
#line 4738
      rr->NR_AdditionalTo = add;
#line 4739
      *nrpp = & rr->NextResponse;
    }
  }
#line 4742
  return;
}
}
#line 4746 "mDNS.c"
static mDNSu8 *GenerateUnicastResponse(DNSMessage const   *query , mDNSu8 const   *end ,
                                       mDNSInterfaceID InterfaceID , mDNSBool LegacyQuery ,
                                       DNSMessage *response , AuthRecord *ResponseRecords ) 
{ mDNSu8 *responseptr ;
  mDNSu8 const   *limit ;
  mDNSu8 const   *ptr ;
  AuthRecord *rr ;
  mDNSu32 maxttl ;
  int i ;
  DNSQuestion q ;
  mDNSu8 *p ;
  mDNSu8 *tmp ;
  mDNSu8 *p___0 ;
  mDNSu8 *tmp___0 ;

  {
#line 4749
  responseptr = response->data;
#line 4750
  limit = (mDNSu8 const   *)(response->data + sizeof(response->data));
#line 4751
  ptr = (mDNSu8 const   *)(query->data);
#line 4753
  maxttl = (mDNSu32 )1879048192;
#line 4757
  InitializeDNSMessage(& response->h, (union __anonunion_mDNSOpaque16_18 )query->h.id,
                       (union __anonunion_mDNSOpaque16_18 )ResponseFlags);
#line 4762
  if (LegacyQuery) {
#line 4764
    maxttl = 10U;
#line 4765
    i = 0;
#line 4765
    while (i < (int )query->h.numQuestions) {
#line 4768
      ptr = getQuestion(query, ptr, end, InterfaceID, & q);
#line 4769
      if (! ptr) {
#line 4769
        return ((mDNSu8 *)0L);
      }
#line 4771
      rr = ResponseRecords;
#line 4771
      while (rr) {
#line 4773
        if ((unsigned int )rr->NR_AnswerTo == (unsigned int )ptr) {
#line 4775
          responseptr = putQuestion(response, responseptr, limit, (domainname const   *)(& q.qname),
                                    q.qtype, q.qclass);
#line 4776
          if (! responseptr) {
#line 4776
            return ((mDNSu8 *)0L);
          }
#line 4777
          break;
        }
#line 4771
        rr = rr->NextResponse;
      }
#line 4765
      i ++;
    }
#line 4782
    if ((int )response->h.numQuestions == 0) {
#line 4782
      LogMsg("GenerateUnicastResponse: ERROR! Why no questions?");
#line 4782
      return ((mDNSu8 *)0L);
    }
  }
#line 4788
  rr = ResponseRecords;
#line 4788
  while (rr) {
#line 4789
    if (rr->NR_AnswerTo) {
#line 4791
      tmp = PutResourceRecordCappedTTL(response, responseptr, & response->h.numAnswers,
                                       & rr->resrec, maxttl);
#line 4791
      p = tmp;
#line 4792
      if (p) {
#line 4792
        responseptr = p;
      } else {
#line 4793
        response->h.flags.b[0] = (unsigned char )((int )response->h.flags.b[0] | 2);
      }
    }
#line 4788
    rr = rr->NextResponse;
  }
#line 4799
  rr = ResponseRecords;
#line 4799
  while (rr) {
#line 4800
    if (rr->NR_AdditionalTo) {
#line 4800
      if (! rr->NR_AnswerTo) {
#line 4802
        tmp___0 = PutResourceRecordCappedTTL(response, responseptr, & response->h.numAdditionals,
                                             & rr->resrec, maxttl);
#line 4802
        p___0 = tmp___0;
#line 4803
        if (p___0) {
#line 4803
          responseptr = p___0;
        }
      }
    }
#line 4799
    rr = rr->NextResponse;
  }
#line 4807
  return (responseptr);
}
}
#line 4815 "mDNS.c"
static int CompareRData(AuthRecord *our , CacheRecord *pkt ) 
{ mDNSu8 ourdata[256] ;
  mDNSu8 *ourptr ;
  mDNSu8 *ourend ;
  mDNSu8 pktdata[256] ;
  mDNSu8 *pktptr ;
  mDNSu8 *pktend ;

  {
#line 4817
  ourptr = ourdata;
#line 4818
  pktptr = pktdata;
#line 4819
  if (! our) {
#line 4819
    LogMsg("CompareRData ERROR: our is NULL");
#line 4819
    return (1);
  }
#line 4820
  if (! pkt) {
#line 4820
    LogMsg("CompareRData ERROR: pkt is NULL");
#line 4820
    return (1);
  }
#line 4822
  ourend = putRData((DNSMessage const   *)0L, ourdata, (mDNSu8 const   *)(ourdata + sizeof(ourdata)),
                    & our->resrec);
#line 4823
  pktend = putRData((DNSMessage const   *)0L, pktdata, (mDNSu8 const   *)(pktdata + sizeof(pktdata)),
                    & pkt->resrec);
#line 4824
  while (1) {
#line 4824
    if ((unsigned int )ourptr < (unsigned int )ourend) {
#line 4824
      if ((unsigned int )pktptr < (unsigned int )pktend) {
#line 4824
        if (! ((int )*ourptr == (int )*pktptr)) {
#line 4824
          break;
        }
      } else {
#line 4824
        break;
      }
    } else {
#line 4824
      break;
    }
#line 4824
    ourptr ++;
#line 4824
    pktptr ++;
  }
#line 4825
  if ((unsigned int )ourptr >= (unsigned int )ourend) {
#line 4825
    if ((unsigned int )pktptr >= (unsigned int )pktend) {
#line 4825
      return (0);
    }
  }
#line 4827
  if ((unsigned int )ourptr >= (unsigned int )ourend) {
#line 4827
    return (-1);
  }
#line 4828
  if ((unsigned int )pktptr >= (unsigned int )pktend) {
#line 4828
    return (1);
  }
#line 4829
  if ((int )*pktptr > (int )*ourptr) {
#line 4829
    return (-1);
  }
#line 4830
  if ((int )*pktptr < (int )*ourptr) {
#line 4830
    return (1);
  }
#line 4833
  return (-1);
}
}
#line 4845 "mDNS.c"
static mDNSBool MatchDependentOn(mDNS const   *m , CacheRecord const   *pktrr , AuthRecord const   *master ) 
{ AuthRecord const   *r1 ;
  AuthRecord const   *r2 ;
  mDNSBool tmp ;
  AuthRecord const   *r2___0 ;
  mDNSBool tmp___0 ;

  {
#line 4848
  r1 = (AuthRecord const   *)m->ResourceRecords;
#line 4848
  while (r1) {
#line 4850
    tmp = IdenticalResourceRecord(& r1->resrec, & pktrr->resrec);
#line 4850
    if (tmp) {
#line 4852
      r2 = r1;
#line 4853
      while (r2->DependentOn) {
#line 4853
        r2 = (AuthRecord const   *)r2->DependentOn;
      }
#line 4854
      if ((unsigned int )r2 == (unsigned int )master) {
#line 4854
        return (1);
      }
    }
#line 4848
    r1 = (AuthRecord const   *)r1->next;
  }
#line 4857
  r1 = (AuthRecord const   *)m->DuplicateRecords;
#line 4857
  while (r1) {
#line 4859
    tmp___0 = IdenticalResourceRecord(& r1->resrec, & pktrr->resrec);
#line 4859
    if (tmp___0) {
#line 4861
      r2___0 = r1;
#line 4862
      while (r2___0->DependentOn) {
#line 4862
        r2___0 = (AuthRecord const   *)r2___0->DependentOn;
      }
#line 4863
      if ((unsigned int )r2___0 == (unsigned int )master) {
#line 4863
        return (1);
      }
    }
#line 4857
    r1 = (AuthRecord const   *)r1->next;
  }
#line 4866
  return (0);
}
}
#line 4873 "mDNS.c"
static AuthRecord const   *FindRRSet(mDNS const   *m , CacheRecord const   *pktrr ) 
{ AuthRecord const   *rr ;
  mDNSBool tmp ;

  {
#line 4876
  rr = (AuthRecord const   *)m->ResourceRecords;
#line 4876
  while (rr) {
#line 4878
    tmp = IdenticalResourceRecord(& rr->resrec, & pktrr->resrec);
#line 4878
    if (tmp) {
#line 4880
      while (1) {
#line 4880
        if (rr->RRSet) {
#line 4880
          if (! ((unsigned int )rr != (unsigned int )rr->RRSet)) {
#line 4880
            break;
          }
        } else {
#line 4880
          break;
        }
#line 4880
        rr = (AuthRecord const   *)rr->RRSet;
      }
#line 4881
      return (rr);
    }
#line 4876
    rr = (AuthRecord const   *)rr->next;
  }
#line 4884
  return ((AuthRecord const   *)0L);
}
}
#line 4896 "mDNS.c"
static mDNSBool PacketRRConflict(mDNS const   *m , AuthRecord const   *our , CacheRecord const   *pktrr ) 
{ AuthRecord const   *ourset ;
  AuthRecord const   *tmp ;
  mDNSBool tmp___0 ;
  AuthRecord const   *tmp___1 ;

  {
#line 4898
  if (our->RRSet) {
#line 4898
    tmp = (AuthRecord const   * const  )our->RRSet;
  } else {
#line 4898
    tmp = (AuthRecord const   * const  )our;
  }
#line 4898
  ourset = (AuthRecord const   *)tmp;
#line 4901
  if (! ((int const   )our->resrec.RecordType & 50)) {
#line 4901
    return (0);
  }
#line 4904
  if (our->DependentOn) {
#line 4904
    return (0);
  } else {
#line 4904
    tmp___0 = MatchDependentOn(m, pktrr, our);
#line 4904
    if (tmp___0) {
#line 4904
      return (0);
    }
  }
#line 4907
  tmp___1 = FindRRSet(m, pktrr);
#line 4907
  if ((unsigned int )tmp___1 == (unsigned int )ourset) {
#line 4907
    return (0);
  }
#line 4910
  return (1);
}
}
#line 4916 "mDNS.c"
static void ResolveSimultaneousProbe(mDNS *m , DNSMessage const   *query , mDNSu8 const   *end ,
                                     DNSQuestion *q , AuthRecord *our ) 
{ int i ;
  mDNSu8 const   *ptr ;
  mDNSu8 const   *tmp ;
  mDNSBool FoundUpdate ;
  LargeCacheRecord pkt ;
  int result ;
  mDNSBool tmp___0 ;
  mDNSBool tmp___1 ;

  {
#line 4920
  tmp = LocateAuthorities(query, end);
#line 4920
  ptr = tmp;
#line 4921
  FoundUpdate = (mDNSBool )0;
#line 4923
  i = 0;
#line 4923
  while (i < (int )query->h.numAuthorities) {
#line 4926
    pkt.r.rdatastorage.MaxRDLength = (unsigned short)8192;
#line 4926
    ptr = GetResourceRecord(m, query, ptr, end, q->InterfaceID, (unsigned char)0,
                            & pkt.r, (RData *)(& pkt.r.rdatastorage));
#line 4927
    if (! ptr) {
#line 4927
      break;
    }
#line 4928
    tmp___1 = ResourceRecordAnswersQuestion((ResourceRecord const   *)(& pkt.r.resrec),
                                            (DNSQuestion const   *)q);
#line 4928
    if (tmp___1) {
#line 4930
      FoundUpdate = 1;
#line 4931
      tmp___0 = PacketRRConflict((mDNS const   *)m, (AuthRecord const   *)our, (CacheRecord const   *)(& pkt.r));
#line 4931
      if (tmp___0) {
#line 4933
        result = (int )our->resrec.rrclass - (int )pkt.r.resrec.rrclass;
#line 4934
        if (! result) {
#line 4934
          result = (int )our->resrec.rrtype - (int )pkt.r.resrec.rrtype;
        }
#line 4935
        if (! result) {
#line 4935
          result = CompareRData(our, & pkt.r);
        }
#line 4936
        switch (result) {
        case 1: ;
#line 4939
        break;
        case 0: 
#line 4940
        break;
        case -1: 
#line 4942
        mDNS_Deregister_internal(m, our, 1);
#line 4943
        return;
        }
      }
    }
#line 4923
    i ++;
  }
#line 4948
  if (! FoundUpdate) {

  }
#line 4950
  return;
}
}
#line 4952 "mDNS.c"
static CacheRecord *FindIdenticalRecordInCache(mDNS const   *m , ResourceRecord *pktrr ) 
{ CacheRecord *rr ;
  mDNSu32 tmp ;
  mDNSBool tmp___0 ;

  {
#line 4955
  tmp = DomainNameHashValue((domainname const   *)(& pktrr->name));
#line 4955
  rr = m->rrcache_hash[tmp % 499U];
#line 4955
  while (rr) {
#line 4956
    if ((unsigned int )pktrr->InterfaceID == (unsigned int )rr->resrec.InterfaceID) {
#line 4956
      tmp___0 = IdenticalResourceRecord((ResourceRecord const   *)pktrr, (ResourceRecord const   *)(& rr->resrec));
#line 4956
      if (tmp___0) {
#line 4956
        break;
      }
    }
#line 4955
    rr = rr->next;
  }
#line 4957
  return (rr);
}
}
#line 4961 "mDNS.c"
static mDNSu8 *ProcessQuery(mDNS *m , DNSMessage const   *query , mDNSu8 const   *end ,
                            mDNSAddr const   *srcaddr , mDNSInterfaceID InterfaceID ,
                            mDNSBool LegacyQuery , mDNSBool QueryWasMulticast , DNSMessage *response ) 
{ AuthRecord *ResponseRecords ;
  AuthRecord **nrp ;
  CacheRecord *ExpectedAnswers ;
  CacheRecord **eap ;
  DNSQuestion *DupQuestions ;
  DNSQuestion **dqp ;
  mDNSs32 delayresponse ;
  mDNSBool HaveUnicastAnswer ;
  mDNSu8 const   *ptr ;
  mDNSu8 *responseptr ;
  AuthRecord *rr ;
  AuthRecord *rr2 ;
  int i ;
  mDNSBool QuestionNeedsMulticastResponse ;
  int NumAnswersForThisQuestion ;
  DNSQuestion pktq ;
  DNSQuestion *q ;
  int tmp ;
  mDNSBool tmp___0 ;
  CacheRecord *rr___0 ;
  mDNSu32 tmp___1 ;
  mDNSBool tmp___2 ;
  mDNSBool tmp___3 ;
  mDNSBool tmp___4 ;
  LargeCacheRecord pkt ;
  AuthRecord *rr___1 ;
  CacheRecord *ourcacherr ;
  mDNSBool tmp___5 ;
  mDNSBool tmp___6 ;
  CacheRecord *rr___2 ;
  mDNSBool tmp___7 ;
  DNSQuestion *q___0 ;
  mDNSBool tmp___8 ;
  mDNSBool SendMulticastResponse ;
  mDNSu32 tmp___9 ;
  CacheRecord *rr___3 ;
  mDNSu32 remain ;
  int i___0 ;
  DNSQuestion *q___1 ;

  {
#line 4965
  ResponseRecords = (AuthRecord *)0L;
#line 4966
  nrp = & ResponseRecords;
#line 4967
  ExpectedAnswers = (CacheRecord *)0L;
#line 4968
  eap = & ExpectedAnswers;
#line 4969
  DupQuestions = (DNSQuestion *)0L;
#line 4970
  dqp = & DupQuestions;
#line 4971
  delayresponse = 0;
#line 4972
  HaveUnicastAnswer = (mDNSBool )0;
#line 4973
  ptr = (mDNSu8 const   *)(query->data);
#line 4974
  responseptr = (mDNSu8 *)0L;
#line 4979
  if ((int )query->h.flags.b[0] & 2) {
#line 4979
    delayresponse = mDNSPlatformOneSecond;
  }
#line 4984
  i = 0;
#line 4984
  while (i < (int )query->h.numQuestions) {
#line 4987
    NumAnswersForThisQuestion = 0;
#line 4989
    ptr = getQuestion(query, ptr, end, InterfaceID, & pktq);
#line 4990
    if (! ptr) {
      goto exit;
    }
#line 5001
    if (QueryWasMulticast) {
#line 5001
      if (! LegacyQuery) {
#line 5001
        if (! ((int )pktq.qclass & 32768)) {
#line 5001
          tmp = 1;
        } else {
#line 5001
          tmp = 0;
        }
      } else {
#line 5001
        tmp = 0;
      }
    } else {
#line 5001
      tmp = 0;
    }
#line 5001
    QuestionNeedsMulticastResponse = tmp;
#line 5003
    pktq.qclass = (unsigned short )((int )pktq.qclass & -32769);
#line 5010
    if (m->CurrentRecord) {
#line 5010
      LogMsg("ProcessQuery ERROR m->CurrentRecord already set");
    }
#line 5011
    m->CurrentRecord = m->ResourceRecords;
#line 5012
    while (m->CurrentRecord) {
#line 5014
      rr = m->CurrentRecord;
#line 5015
      m->CurrentRecord = rr->next;
#line 5016
      tmp___0 = ResourceRecordAnswersQuestion((ResourceRecord const   *)(& rr->resrec),
                                              (DNSQuestion const   *)(& pktq));
#line 5016
      if (tmp___0) {
#line 5018
        if ((int )rr->resrec.RecordType == 2) {
#line 5019
          ResolveSimultaneousProbe(m, query, end, & pktq, rr);
        } else {
#line 5020
          if ((int )rr->resrec.RecordType & 60) {
#line 5020
            if ((unsigned int )rr->Additional1 == (unsigned int )((AuthRecord *)0)) {
              goto _L___1;
            } else {
#line 5020
              if ((int )(rr->Additional1)->resrec.RecordType & 60) {
                _L___1: /* CIL Label */ 
#line 5020
                if ((unsigned int )rr->Additional2 == (unsigned int )((AuthRecord *)0)) {
                  goto _L___0;
                } else {
#line 5020
                  if ((int )(rr->Additional2)->resrec.RecordType & 60) {
                    _L___0: /* CIL Label */ 
#line 5020
                    if ((unsigned int )rr->DependentOn == (unsigned int )((AuthRecord *)0)) {
                      goto _L;
                    } else {
#line 5020
                      if ((int )(rr->DependentOn)->resrec.RecordType & 60) {
                        _L: /* CIL Label */ 
#line 5022
                        NumAnswersForThisQuestion ++;
#line 5027
                        if (QuestionNeedsMulticastResponse) {
#line 5032
                          if (m->timenow - (rr->LastMCTime + mDNSPlatformOneSecond) >= 0) {
#line 5034
                            rr->NR_AnswerTo = (mDNSu8 const   *)((mDNSu8 *)(~ 0));
                          } else {
#line 5032
                            if ((unsigned int )rr->LastMCInterface != (unsigned int )mDNSInterfaceMark) {
#line 5032
                              if ((unsigned int )rr->LastMCInterface != (unsigned int )InterfaceID) {
#line 5034
                                rr->NR_AnswerTo = (mDNSu8 const   *)((mDNSu8 *)(~ 0));
                              }
                            }
                          }
                        } else {
#line 5036
                          if (! rr->NR_AnswerTo) {
#line 5036
                            rr->NR_AnswerTo = ptr;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 5044
    if (QuestionNeedsMulticastResponse) {
#line 5049
      if (NumAnswersForThisQuestion == 0) {
#line 5049
        delayresponse = mDNSPlatformOneSecond;
      }
#line 5053
      tmp___1 = DomainNameHashValue((domainname const   *)(& pktq.qname));
#line 5053
      rr___0 = m->rrcache_hash[tmp___1 % 499U];
#line 5053
      while (rr___0) {
#line 5054
        tmp___2 = ResourceRecordAnswersQuestion((ResourceRecord const   *)(& rr___0->resrec),
                                                (DNSQuestion const   *)(& pktq));
#line 5054
        if (tmp___2) {
#line 5054
          if ((int )rr___0->resrec.rdlength <= 1024) {
#line 5055
            if (! rr___0->NextInKAList) {
#line 5055
              if ((unsigned int )eap != (unsigned int )(& rr___0->NextInKAList)) {
#line 5057
                *eap = rr___0;
#line 5058
                eap = & rr___0->NextInKAList;
#line 5059
                if (rr___0->MPUnansweredQ == 0U) {
#line 5064
                  (rr___0->MPUnansweredQ) ++;
#line 5065
                  rr___0->MPLastUnansweredQT = m->timenow;
#line 5066
                  rr___0->MPExpectingKA = 1;
                } else {
#line 5059
                  if (m->timenow - rr___0->MPLastUnansweredQT >= mDNSPlatformOneSecond) {
#line 5064
                    (rr___0->MPUnansweredQ) ++;
#line 5065
                    rr___0->MPLastUnansweredQT = m->timenow;
#line 5066
                    rr___0->MPExpectingKA = 1;
                  }
                }
              }
            }
          }
        }
#line 5053
        rr___0 = rr___0->next;
      }
#line 5074
      if (! ((int )query->h.flags.b[0] & 2)) {
#line 5075
        q = m->Questions;
#line 5075
        while (q) {
#line 5076
          if (q->ThisQInterval > 0) {
#line 5076
            if (! q->DuplicateOf) {
#line 5076
              if (m->timenow - q->LastQTxTime > mDNSPlatformOneSecond / 4) {
#line 5077
                if (! q->InterfaceID) {
                  goto _L___2;
                } else {
#line 5077
                  if ((unsigned int )q->InterfaceID == (unsigned int )InterfaceID) {
                    _L___2: /* CIL Label */ 
#line 5078
                    if ((unsigned int )q->NextInDQList == (unsigned int )((DNSQuestion *)0)) {
#line 5078
                      if ((unsigned int )dqp != (unsigned int )(& q->NextInDQList)) {
#line 5079
                        if ((int )q->qtype == (int )pktq.qtype) {
#line 5079
                          if ((int )q->qclass == (int )pktq.qclass) {
#line 5079
                            if (q->qnamehash == pktq.qnamehash) {
#line 5079
                              tmp___3 = SameDomainName((domainname const   *)(& q->qname),
                                                       (domainname const   *)(& pktq.qname));
#line 5079
                              if (tmp___3) {
#line 5080
                                *dqp = q;
#line 5080
                                dqp = & q->NextInDQList;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
#line 5075
          q = q->next;
        }
      }
    }
#line 4984
    i ++;
  }
#line 5087
  rr = m->ResourceRecords;
#line 5087
  while (rr) {
#line 5088
    if (rr->NR_AnswerTo) {
#line 5089
      AddRecordToResponseList(& nrp, rr, (AuthRecord *)0L);
    }
#line 5087
    rr = rr->next;
  }
#line 5094
  rr = ResponseRecords;
#line 5094
  while (rr) {
#line 5098
    if (rr->Additional1) {
#line 5098
      if ((int )(rr->Additional1)->resrec.RecordType & 60) {
#line 5098
        if ((unsigned int )(rr->Additional1)->Additional1 == (unsigned int )((AuthRecord *)0)) {
          goto _L___5;
        } else {
#line 5098
          if ((int )((rr->Additional1)->Additional1)->resrec.RecordType & 60) {
            _L___5: /* CIL Label */ 
#line 5098
            if ((unsigned int )(rr->Additional1)->Additional2 == (unsigned int )((AuthRecord *)0)) {
              goto _L___4;
            } else {
#line 5098
              if ((int )((rr->Additional1)->Additional2)->resrec.RecordType & 60) {
                _L___4: /* CIL Label */ 
#line 5098
                if ((unsigned int )(rr->Additional1)->DependentOn == (unsigned int )((AuthRecord *)0)) {
                  goto _L___3;
                } else {
#line 5098
                  if ((int )((rr->Additional1)->DependentOn)->resrec.RecordType & 60) {
                    _L___3: /* CIL Label */ 
#line 5098
                    if ((unsigned int )(rr->Additional1)->resrec.InterfaceID == (unsigned int )mDNSInterface_Any) {
#line 5099
                      AddRecordToResponseList(& nrp, rr->Additional1, rr);
                    } else {
#line 5098
                      if ((unsigned int )(rr->Additional1)->resrec.InterfaceID == (unsigned int )InterfaceID) {
#line 5099
                        AddRecordToResponseList(& nrp, rr->Additional1, rr);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 5101
    if (rr->Additional2) {
#line 5101
      if ((int )(rr->Additional2)->resrec.RecordType & 60) {
#line 5101
        if ((unsigned int )(rr->Additional2)->Additional1 == (unsigned int )((AuthRecord *)0)) {
          goto _L___8;
        } else {
#line 5101
          if ((int )((rr->Additional2)->Additional1)->resrec.RecordType & 60) {
            _L___8: /* CIL Label */ 
#line 5101
            if ((unsigned int )(rr->Additional2)->Additional2 == (unsigned int )((AuthRecord *)0)) {
              goto _L___7;
            } else {
#line 5101
              if ((int )((rr->Additional2)->Additional2)->resrec.RecordType & 60) {
                _L___7: /* CIL Label */ 
#line 5101
                if ((unsigned int )(rr->Additional2)->DependentOn == (unsigned int )((AuthRecord *)0)) {
                  goto _L___6;
                } else {
#line 5101
                  if ((int )((rr->Additional2)->DependentOn)->resrec.RecordType & 60) {
                    _L___6: /* CIL Label */ 
#line 5101
                    if ((unsigned int )(rr->Additional2)->resrec.InterfaceID == (unsigned int )mDNSInterface_Any) {
#line 5102
                      AddRecordToResponseList(& nrp, rr->Additional2, rr);
                    } else {
#line 5101
                      if ((unsigned int )(rr->Additional2)->resrec.InterfaceID == (unsigned int )InterfaceID) {
#line 5102
                        AddRecordToResponseList(& nrp, rr->Additional2, rr);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 5105
    if ((int )rr->resrec.rrtype == 33) {
#line 5106
      rr2 = m->ResourceRecords;
#line 5106
      while (rr2) {
#line 5107
        if ((int )rr2->resrec.rrtype == 1) {
          goto _L___13;
        } else {
#line 5107
          if ((int )rr2->resrec.rrtype == 28) {
            _L___13: /* CIL Label */ 
#line 5107
            if ((int )rr2->resrec.RecordType & 60) {
#line 5107
              if ((unsigned int )rr2->Additional1 == (unsigned int )((AuthRecord *)0)) {
                goto _L___12;
              } else {
#line 5107
                if ((int )(rr2->Additional1)->resrec.RecordType & 60) {
                  _L___12: /* CIL Label */ 
#line 5107
                  if ((unsigned int )rr2->Additional2 == (unsigned int )((AuthRecord *)0)) {
                    goto _L___11;
                  } else {
#line 5107
                    if ((int )(rr2->Additional2)->resrec.RecordType & 60) {
                      _L___11: /* CIL Label */ 
#line 5107
                      if ((unsigned int )rr2->DependentOn == (unsigned int )((AuthRecord *)0)) {
                        goto _L___10;
                      } else {
#line 5107
                        if ((int )(rr2->DependentOn)->resrec.RecordType & 60) {
                          _L___10: /* CIL Label */ 
#line 5107
                          if ((unsigned int )rr2->resrec.InterfaceID == (unsigned int )mDNSInterface_Any) {
                            goto _L___9;
                          } else {
#line 5107
                            if ((unsigned int )rr2->resrec.InterfaceID == (unsigned int )InterfaceID) {
                              _L___9: /* CIL Label */ 
#line 5107
                              if (rr->resrec.rdnamehash == rr2->resrec.namehash) {
#line 5107
                                tmp___4 = SameDomainName((domainname const   *)(& (rr->resrec.rdata)->u.srv.target),
                                                         (domainname const   *)(& rr2->resrec.name));
#line 5107
                                if (tmp___4) {
#line 5111
                                  AddRecordToResponseList(& nrp, rr2, rr);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
#line 5106
        rr2 = rr2->next;
      }
    }
#line 5094
    rr = rr->NextResponse;
  }
#line 5117
  i = 0;
#line 5117
  while (i < (int )query->h.numAnswers) {
#line 5123
    pkt.r.rdatastorage.MaxRDLength = (unsigned short)8192;
#line 5123
    ptr = GetResourceRecord(m, query, ptr, end, InterfaceID, (unsigned char)192, & pkt.r,
                            (RData *)(& pkt.r.rdatastorage));
#line 5124
    if (! ptr) {
      goto exit;
    }
#line 5127
    rr___1 = ResponseRecords;
#line 5127
    while (rr___1) {
#line 5128
      if (rr___1->NR_AnswerTo) {
        goto _L___14;
      } else {
#line 5128
        if (rr___1->NR_AdditionalTo) {
          _L___14: /* CIL Label */ 
#line 5128
          tmp___5 = ShouldSuppressKnownAnswer((CacheRecord const   *)(& pkt.r), (AuthRecord const   *)rr___1);
#line 5128
          if (tmp___5) {
#line 5129
            rr___1->NR_AnswerTo = (mDNSu8 const   *)0L;
#line 5129
            rr___1->NR_AdditionalTo = (AuthRecord *)0L;
          }
        }
      }
#line 5127
      rr___1 = rr___1->NextResponse;
    }
#line 5132
    rr___1 = m->ResourceRecords;
#line 5132
    while (rr___1) {
#line 5135
      if ((unsigned int )rr___1->ImmedAnswer == (unsigned int )InterfaceID) {
#line 5135
        tmp___6 = ShouldSuppressKnownAnswer((CacheRecord const   *)(& pkt.r), (AuthRecord const   *)rr___1);
#line 5135
        if (tmp___6) {
#line 5137
          if (srcaddr->type == 4) {
#line 5139
            if (rr___1->v4Requester.NotAnInteger == (mDNSu32 )srcaddr->ip.v4.NotAnInteger) {
#line 5139
              rr___1->v4Requester = (union __anonunion_mDNSOpaque32_19 )zeroIPAddr;
            }
          } else {
#line 5141
            if (srcaddr->type == 6) {
#line 5143
              if (rr___1->v6Requester.l[0] == srcaddr->ip.v6.l[0]) {
#line 5143
                if (rr___1->v6Requester.l[1] == srcaddr->ip.v6.l[1]) {
#line 5143
                  if (rr___1->v6Requester.l[2] == srcaddr->ip.v6.l[2]) {
#line 5143
                    if (rr___1->v6Requester.l[3] == srcaddr->ip.v6.l[3]) {
#line 5143
                      rr___1->v6Requester = (union __anonunion_mDNSOpaque128_20 )zerov6Addr;
                    }
                  }
                }
              }
            }
          }
#line 5145
          if (rr___1->v4Requester.NotAnInteger == (mDNSu32 )zeroIPAddr.NotAnInteger) {
#line 5145
            if (rr___1->v6Requester.l[0] == zerov6Addr.l[0]) {
#line 5145
              if (rr___1->v6Requester.l[1] == zerov6Addr.l[1]) {
#line 5145
                if (rr___1->v6Requester.l[2] == zerov6Addr.l[2]) {
#line 5145
                  if (rr___1->v6Requester.l[3] == zerov6Addr.l[3]) {
#line 5145
                    rr___1->ImmedAnswer = (struct mDNSInterfaceID_dummystruct *)0L;
                  }
                }
              }
            }
          }
        }
      }
#line 5132
      rr___1 = rr___1->next;
    }
#line 5151
    ourcacherr = FindIdenticalRecordInCache((mDNS const   *)m, & pkt.r.resrec);
#line 5152
    if (ourcacherr) {
#line 5152
      if (ourcacherr->MPExpectingKA) {
#line 5152
        if (m->timenow - ourcacherr->MPLastUnansweredQT < mDNSPlatformOneSecond) {
#line 5154
          (ourcacherr->MPUnansweredKA) ++;
#line 5155
          ourcacherr->MPExpectingKA = 0;
        }
      }
    }
#line 5161
    eap = & ExpectedAnswers;
#line 5162
    while (*eap) {
#line 5164
      rr___2 = *eap;
#line 5165
      if ((unsigned int )rr___2->resrec.InterfaceID == (unsigned int )InterfaceID) {
#line 5165
        tmp___7 = IdenticalResourceRecord((ResourceRecord const   *)(& pkt.r.resrec),
                                          (ResourceRecord const   *)(& rr___2->resrec));
#line 5165
        if (tmp___7) {
#line 5166
          *eap = rr___2->NextInKAList;
#line 5166
          rr___2->NextInKAList = (CacheRecord *)0L;
        } else {
#line 5167
          eap = & rr___2->NextInKAList;
        }
      } else {
#line 5167
        eap = & rr___2->NextInKAList;
      }
    }
#line 5171
    if (! ourcacherr) {
#line 5173
      dqp = & DupQuestions;
#line 5174
      while (*dqp) {
#line 5176
        q___0 = *dqp;
#line 5177
        tmp___8 = ResourceRecordAnswersQuestion((ResourceRecord const   *)(& pkt.r.resrec),
                                                (DNSQuestion const   *)q___0);
#line 5177
        if (tmp___8) {
#line 5178
          *dqp = q___0->NextInDQList;
#line 5178
          q___0->NextInDQList = (DNSQuestion *)0L;
        } else {
#line 5179
          dqp = & q___0->NextInDQList;
        }
      }
    }
#line 5117
    i ++;
  }
#line 5187
  rr = ResponseRecords;
#line 5187
  while (rr) {
#line 5188
    if (rr->NR_AdditionalTo) {
#line 5188
      if (! (rr->NR_AdditionalTo)->NR_AnswerTo) {
#line 5188
        if (! (rr->NR_AdditionalTo)->NR_AdditionalTo) {
#line 5189
          rr->NR_AnswerTo = (mDNSu8 const   *)0L;
#line 5189
          rr->NR_AdditionalTo = (AuthRecord *)0L;
        }
      }
    }
#line 5187
    rr = rr->NextResponse;
  }
#line 5194
  rr = ResponseRecords;
#line 5194
  while (rr) {
#line 5196
    if (rr->NR_AnswerTo) {
#line 5198
      SendMulticastResponse = (mDNSBool )0;
#line 5201
      if (m->timenow - (rr->LastMCTime + ((int )rr->resrec.rroriginalttl * mDNSPlatformOneSecond) / 4) >= 0) {
#line 5201
        SendMulticastResponse = 1;
      }
#line 5204
      if ((unsigned int )rr->NR_AnswerTo == (unsigned int )((mDNSu8 *)-1)) {
#line 5204
        SendMulticastResponse = 1;
      } else {
#line 5205
        if (rr->NR_AnswerTo) {
#line 5205
          HaveUnicastAnswer = 1;
        }
      }
#line 5207
      if (SendMulticastResponse) {
#line 5210
        if (rr->ImmedAnswer) {
#line 5210
          if ((unsigned int )rr->ImmedAnswer != (unsigned int )InterfaceID) {
#line 5212
            rr->ImmedAnswer = (struct mDNSInterfaceID_dummystruct *)mDNSInterfaceMark;
#line 5213
            m->NextScheduledResponse = m->timenow;
          } else {
            goto _L___18;
          }
        } else {
          _L___18: /* CIL Label */ 
#line 5218
          rr->ImmedAnswer = InterfaceID;
#line 5219
          m->NextScheduledResponse = m->timenow;
#line 5220
          if (srcaddr->type == 4) {
#line 5222
            if (rr->v4Requester.NotAnInteger == (mDNSu32 )zeroIPAddr.NotAnInteger) {
#line 5222
              rr->v4Requester = (union __anonunion_mDNSOpaque32_19 )srcaddr->ip.v4;
            } else {
#line 5223
              if (! (rr->v4Requester.NotAnInteger == (mDNSu32 )srcaddr->ip.v4.NotAnInteger)) {
#line 5223
                rr->v4Requester = (union __anonunion_mDNSOpaque32_19 )onesIPv4Addr;
              }
            }
          } else {
#line 5225
            if (srcaddr->type == 6) {
#line 5227
              if (rr->v6Requester.l[0] == zerov6Addr.l[0]) {
#line 5227
                if (rr->v6Requester.l[1] == zerov6Addr.l[1]) {
#line 5227
                  if (rr->v6Requester.l[2] == zerov6Addr.l[2]) {
#line 5227
                    if (rr->v6Requester.l[3] == zerov6Addr.l[3]) {
#line 5227
                      rr->v6Requester = (union __anonunion_mDNSOpaque128_20 )srcaddr->ip.v6;
                    } else {
                      goto _L___17;
                    }
                  } else {
                    goto _L___17;
                  }
                } else {
                  goto _L___17;
                }
              } else {
                _L___17: /* CIL Label */ 
#line 5228
                if (rr->v6Requester.l[0] == srcaddr->ip.v6.l[0]) {
#line 5228
                  if (rr->v6Requester.l[1] == srcaddr->ip.v6.l[1]) {
#line 5228
                    if (rr->v6Requester.l[2] == srcaddr->ip.v6.l[2]) {
#line 5228
                      if (! (rr->v6Requester.l[3] == srcaddr->ip.v6.l[3])) {
#line 5228
                        rr->v6Requester = (union __anonunion_mDNSOpaque128_20 )onesIPv6Addr;
                      }
                    } else {
#line 5228
                      rr->v6Requester = (union __anonunion_mDNSOpaque128_20 )onesIPv6Addr;
                    }
                  } else {
#line 5228
                    rr->v6Requester = (union __anonunion_mDNSOpaque128_20 )onesIPv6Addr;
                  }
                } else {
#line 5228
                  rr->v6Requester = (union __anonunion_mDNSOpaque128_20 )onesIPv6Addr;
                }
              }
            }
          }
        }
      }
#line 5232
      if ((int )rr->resrec.RecordType == 8) {
#line 5234
        if ((int )query->h.flags.b[0] & 2) {
#line 5234
          delayresponse = mDNSPlatformOneSecond * 20;
        } else {
#line 5235
          delayresponse = mDNSPlatformOneSecond;
        }
      }
    } else {
#line 5238
      if (rr->NR_AdditionalTo) {
#line 5238
        if ((unsigned int )(rr->NR_AdditionalTo)->NR_AnswerTo == (unsigned int )((mDNSu8 *)-1)) {
#line 5243
          rr->ImmedAdditional = InterfaceID;
        }
      }
    }
#line 5194
    rr = rr->NextResponse;
  }
#line 5252
  if (delayresponse) {
#line 5252
    if (! m->SuppressSending) {
      goto _L___19;
    } else {
#line 5252
      if (m->SuppressSending - m->timenow < (delayresponse + 49) / 50) {
        _L___19: /* CIL Label */ 
#line 5267
        tmp___9 = mDNSRandom((unsigned int )mDNSPlatformOneSecond * 5U);
#line 5267
        m->SuppressSending = m->timenow + ((delayresponse + (int )tmp___9) + 49) / 50;
#line 5268
        if (m->SuppressSending == 0) {
#line 5268
          m->SuppressSending = 1;
        }
      }
    }
  }
#line 5274
  if (HaveUnicastAnswer) {
#line 5275
    responseptr = GenerateUnicastResponse(query, end, InterfaceID, LegacyQuery, response,
                                          ResponseRecords);
  }
  exit: 
#line 5281
  while (ResponseRecords) {
#line 5283
    rr = ResponseRecords;
#line 5284
    ResponseRecords = rr->NextResponse;
#line 5285
    rr->NextResponse = (AuthRecord *)0L;
#line 5286
    rr->NR_AnswerTo = (mDNSu8 const   *)0L;
#line 5287
    rr->NR_AdditionalTo = (AuthRecord *)0L;
  }
#line 5290
  while (ExpectedAnswers) {
#line 5293
    rr___3 = ExpectedAnswers;
#line 5294
    ExpectedAnswers = rr___3->NextInKAList;
#line 5295
    rr___3->NextInKAList = (CacheRecord *)0L;
#line 5299
    if (! ((int )query->h.flags.b[0] & 2)) {
#line 5300
      if (rr___3->UnansweredQueries == 0U) {
        goto _L___20;
      } else {
#line 5300
        if (m->timenow - rr___3->LastUnansweredTime >= mDNSPlatformOneSecond) {
          _L___20: /* CIL Label */ 
#line 5302
          (rr___3->UnansweredQueries) ++;
#line 5303
          rr___3->LastUnansweredTime = m->timenow;
#line 5304
          if (rr___3->UnansweredQueries > 1U) {

          }
#line 5307
          SetNextCacheCheckTime(m, rr___3);
        }
      }
    }
#line 5312
    if (rr___3->UnansweredQueries >= 4U) {
#line 5315
      if ((rr___3->TimeRcvd + (int )rr___3->resrec.rroriginalttl * mDNSPlatformOneSecond) - m->timenow > 4 * mDNSPlatformOneSecond) {

      }
#line 5318
      mDNS_Reconfirm_internal(m, rr___3, (unsigned int )mDNSPlatformOneSecond * 45U);
    } else {
#line 5323
      if (rr___3->MPUnansweredQ * 4U > rr___3->MPUnansweredKA * 5U + 8U) {
#line 5331
        remain = (unsigned int )((rr___3->TimeRcvd + (int )rr___3->resrec.rroriginalttl * mDNSPlatformOneSecond) - m->timenow) / 4U;
#line 5332
        if (remain > 240U * (unsigned int )mDNSPlatformOneSecond) {
#line 5333
          remain = 240U * (unsigned int )mDNSPlatformOneSecond;
        }
#line 5336
        if ((rr___3->TimeRcvd + (int )rr___3->resrec.rroriginalttl * mDNSPlatformOneSecond) - m->timenow > 4 * mDNSPlatformOneSecond) {

        }
#line 5340
        if (remain <= 60U * (unsigned int )mDNSPlatformOneSecond) {
#line 5341
          (rr___3->UnansweredQueries) ++;
        }
#line 5342
        rr___3->MPUnansweredQ = 0U;
#line 5343
        rr___3->MPUnansweredKA = 0U;
#line 5344
        rr___3->MPExpectingKA = 0;
#line 5346
        if (remain < (unsigned int )mDNSPlatformOneSecond * 45U) {
#line 5347
          remain = (unsigned int )mDNSPlatformOneSecond * 45U;
        }
#line 5348
        mDNS_Reconfirm_internal(m, rr___3, remain);
      }
    }
  }
#line 5352
  while (DupQuestions) {
#line 5355
    q___1 = DupQuestions;
#line 5356
    DupQuestions = q___1->NextInDQList;
#line 5357
    q___1->NextInDQList = (DNSQuestion *)0L;
#line 5358
    i___0 = RecordDupSuppressInfo((DupSuppressInfo *)(q___1->DupSuppress), m->timenow,
                                  InterfaceID, (int )srcaddr->type);
  }
#line 5363
  return (responseptr);
}
}
#line 5366 "mDNS.c"
static void mDNSCoreReceiveQuery(mDNS *m , DNSMessage const   *msg , mDNSu8 const   *end ,
                                 mDNSAddr const   *srcaddr , mDNSIPPort srcport ,
                                 mDNSAddr const   *dstaddr , mDNSIPPort dstport ,
                                 mDNSInterfaceID InterfaceID ) 
{ DNSMessage response ;
  mDNSu8 const   *responseend ;
  mDNSBool tmp ;
  mDNSu8 *tmp___0 ;

  {
#line 5371
  responseend = (mDNSu8 const   *)0L;
#line 5382
  tmp = mDNSAddrIsDNSMulticast(dstaddr);
#line 5382
  tmp___0 = ProcessQuery(m, msg, end, srcaddr, InterfaceID, (int )srcport.NotAnInteger != (int )MulticastDNSPort.NotAnInteger,
                         tmp, & response);
#line 5382
  responseend = (mDNSu8 const   *)tmp___0;
#line 5385
  if (responseend) {
#line 5392
    mDNSSendDNSMessage((mDNS const   *)m, & response, responseend, InterfaceID, dstport,
                       srcaddr, srcport);
  }
#line 5394
  return;
}
}
#line 5399 "mDNS.c"
static void mDNSCoreReceiveResponse(mDNS *m , DNSMessage const   *response , mDNSu8 const   *end ,
                                    mDNSAddr const   *srcaddr , mDNSAddr const   *dstaddr ,
                                    mDNSInterfaceID InterfaceID , mDNSu8 ttl ) 
{ int i ;
  mDNSu8 const   *ptr ;
  mDNSu8 const   *tmp ;
  CacheRecord *CacheFlushRecords ;
  CacheRecord **cfp ;
  int totalrecords ;
  mDNSBool tmp___0 ;
  LargeCacheRecord pkt ;
  mDNSu8 RecordType ;
  int tmp___1 ;
  AuthRecord *rr ;
  mDNSBool tmp___2 ;
  mDNSBool tmp___3 ;
  mDNSBool tmp___4 ;
  mDNSu32 slot ;
  mDNSu32 tmp___5 ;
  CacheRecord *rr___0 ;
  DNSQuestion *q ;
  mDNSBool tmp___6 ;
  mDNSBool tmp___7 ;
  RData *saveptr ;
  CacheRecord *r1 ;
  CacheRecord *r2 ;
  mDNSu32 tmp___8 ;
  mDNSBool tmp___9 ;

  {
#line 5404
  tmp = LocateAnswers(response, end);
#line 5404
  ptr = tmp;
#line 5405
  CacheFlushRecords = (CacheRecord *)0L;
#line 5406
  cfp = & CacheFlushRecords;
#line 5411
  totalrecords = (int )(((int const   )response->h.numAnswers + (int const   )response->h.numAuthorities) + (int const   )response->h.numAdditionals);
#line 5427
  if ((int )ttl < 254) {
#line 5435
    return;
  } else {
#line 5427
    tmp___0 = mDNSAddrIsDNSMulticast(dstaddr);
#line 5427
    if (! tmp___0) {
#line 5427
      if ((unsigned int )(m->timenow - m->ExpectUnicastResponse) > (unsigned int )mDNSPlatformOneSecond) {
#line 5435
        return;
      }
    }
  }
#line 5438
  i = 0;
#line 5438
  while (1) {
#line 5438
    if (i < totalrecords) {
#line 5438
      if (ptr) {
#line 5438
        if (! ((unsigned int )ptr < (unsigned int )end)) {
#line 5438
          break;
        }
      } else {
#line 5438
        break;
      }
    } else {
#line 5438
      break;
    }
#line 5441
    if (i < (int )response->h.numAnswers) {
#line 5441
      tmp___1 = 192;
    } else {
#line 5441
      tmp___1 = 128;
    }
#line 5441
    RecordType = (unsigned char )tmp___1;
#line 5442
    pkt.r.rdatastorage.MaxRDLength = (unsigned short)8192;
#line 5442
    ptr = GetResourceRecord(m, response, ptr, end, InterfaceID, RecordType, & pkt.r,
                            (RData *)(& pkt.r.rdatastorage));
#line 5443
    if (! ptr) {
#line 5443
      break;
    }
#line 5446
    if (m->CurrentRecord) {
#line 5446
      LogMsg("mDNSCoreReceiveResponse ERROR m->CurrentRecord already set");
    }
#line 5447
    m->CurrentRecord = m->ResourceRecords;
#line 5448
    while (m->CurrentRecord) {
#line 5450
      rr = m->CurrentRecord;
#line 5451
      m->CurrentRecord = rr->next;
#line 5452
      tmp___4 = PacketRRMatchesSignature((CacheRecord const   *)(& pkt.r), (AuthRecord const   *)rr);
#line 5452
      if (tmp___4) {
#line 5455
        tmp___3 = SameRData((ResourceRecord const   *)(& pkt.r.resrec), (ResourceRecord const   *)(& rr->resrec));
#line 5455
        if (tmp___3) {
#line 5458
          if (pkt.r.resrec.rroriginalttl >= rr->resrec.rroriginalttl / 2U) {
            goto _L;
          } else {
#line 5458
            if (m->SleepState) {
              _L: /* CIL Label */ 
#line 5461
              if ((unsigned int )rr->ImmedAnswer == (unsigned int )InterfaceID) {
#line 5461
                rr->ImmedAnswer = (struct mDNSInterfaceID_dummystruct *)0L;
              }
            } else {
#line 5465
              if ((unsigned int )rr->ImmedAnswer == (unsigned int )((mDNSInterfaceID )0)) {
#line 5465
                rr->ImmedAnswer = InterfaceID;
#line 5465
                m->NextScheduledResponse = m->timenow;
              } else {
#line 5466
                if ((unsigned int )rr->ImmedAnswer != (unsigned int )InterfaceID) {
#line 5466
                  rr->ImmedAnswer = (struct mDNSInterfaceID_dummystruct *)mDNSInterfaceMark;
#line 5466
                  m->NextScheduledResponse = m->timenow;
                }
              }
            }
          }
        } else {
#line 5472
          if (pkt.r.resrec.rroriginalttl > 0U) {
#line 5472
            tmp___2 = PacketRRConflict((mDNS const   *)m, (AuthRecord const   *)rr,
                                       (CacheRecord const   *)(& pkt.r));
#line 5472
            if (tmp___2) {
#line 5479
              while (rr->DependentOn) {
#line 5479
                rr = rr->DependentOn;
              }
#line 5482
              if ((int )rr->ProbeCount <= 3) {
#line 5485
                if ((int )rr->resrec.RecordType == 16) {
#line 5488
                  rr->resrec.RecordType = (unsigned char)2;
#line 5489
                  rr->ProbeCount = (unsigned char)4;
#line 5490
                  rr->ThisAPInterval = mDNSPlatformOneSecond / 4;
#line 5491
                  InitializeLastAPTime(m, rr);
#line 5492
                  RecordProbeFailure(m, (AuthRecord const   *)rr);
                } else {
#line 5495
                  if ((int )rr->resrec.RecordType == 2) {
#line 5498
                    mDNS_Deregister_internal(m, rr, 1);
                  } else {
#line 5504
                    if ((int )rr->resrec.RecordType == 32) {
#line 5508
                      mDNS_Deregister_internal(m, rr, 1);
                    }
                  }
                }
              }
            } else {
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
#line 5518
            if ((int )pkt.r.resrec.RecordType & 32) {
#line 5518
              if (m->timenow - rr->LastMCTime > mDNSPlatformOneSecond / 2) {
#line 5519
                rr->ImmedAnswer = (struct mDNSInterfaceID_dummystruct *)mDNSInterfaceMark;
#line 5519
                m->NextScheduledResponse = m->timenow;
              }
            }
          }
        }
      }
    }
#line 5525
    if (m->rrcache_size) {
#line 5527
      tmp___5 = DomainNameHashValue((domainname const   *)(& pkt.r.resrec.name));
#line 5527
      slot = tmp___5 % 499U;
#line 5530
      rr___0 = m->rrcache_hash[slot];
#line 5530
      while (rr___0) {
#line 5533
        if ((unsigned int )rr___0->resrec.InterfaceID == (unsigned int )InterfaceID) {
#line 5533
          tmp___7 = IdenticalResourceRecord((ResourceRecord const   *)(& pkt.r.resrec),
                                            (ResourceRecord const   *)(& rr___0->resrec));
#line 5533
          if (tmp___7) {
#line 5535
            if ((int )pkt.r.resrec.rdlength > 64) {

            }
#line 5538
            rr___0->TimeRcvd = m->timenow;
#line 5540
            if ((int )pkt.r.resrec.RecordType & 32) {
#line 5543
              if ((unsigned int )rr___0->NextInCFList == (unsigned int )((CacheRecord *)0)) {
#line 5543
                if ((unsigned int )cfp != (unsigned int )(& rr___0->NextInCFList)) {
#line 5544
                  *cfp = rr___0;
#line 5544
                  cfp = & rr___0->NextInCFList;
                }
              }
#line 5547
              if (! ((int )rr___0->resrec.RecordType & 32)) {
#line 5550
                q = m->Questions;
#line 5550
                while (q) {
#line 5550
                  tmp___6 = ResourceRecordAnswersQuestion((ResourceRecord const   *)(& rr___0->resrec),
                                                          (DNSQuestion const   *)q);
#line 5550
                  if (tmp___6) {
#line 5550
                    (q->UniqueAnswers) ++;
                  }
#line 5550
                  q = q->next;
                }
#line 5551
                rr___0->resrec.RecordType = pkt.r.resrec.RecordType;
              }
            }
#line 5555
            if (pkt.r.resrec.rroriginalttl > 0U) {
#line 5557
              rr___0->resrec.rroriginalttl = pkt.r.resrec.rroriginalttl;
#line 5558
              rr___0->UnansweredQueries = 0U;
#line 5559
              rr___0->MPUnansweredQ = 0U;
#line 5560
              rr___0->MPUnansweredKA = 0U;
#line 5561
              rr___0->MPExpectingKA = 0;
            } else {
#line 5570
              rr___0->resrec.rroriginalttl = 1U;
#line 5571
              rr___0->UnansweredQueries = 4U;
            }
#line 5573
            SetNextCacheCheckTime(m, rr___0);
#line 5574
            break;
          }
        }
#line 5530
        rr___0 = rr___0->next;
      }
#line 5580
      if (! rr___0) {
#line 5580
        if (pkt.r.resrec.rroriginalttl > 0U) {
#line 5582
          rr___0 = GetFreeCacheRR(m, pkt.r.resrec.rdlength);
#line 5583
          if (! (! rr___0)) {
#line 5586
            saveptr = rr___0->resrec.rdata;
#line 5587
            *rr___0 = pkt.r;
#line 5588
            rr___0->resrec.rdata = saveptr;
#line 5589
            if ((int )rr___0->resrec.RecordType & 32) {
#line 5590
              *cfp = rr___0;
#line 5590
              cfp = & rr___0->NextInCFList;
            }
#line 5592
            if ((int )pkt.r.resrec.rdlength > 64) {
#line 5593
              mDNSPlatformMemCopy((void const   *)pkt.r.resrec.rdata, (void *)rr___0->resrec.rdata,
                                  (sizeof(RData ) - sizeof(RDataBody )) + (unsigned int )pkt.r.resrec.rdlength);
            }
#line 5594
            rr___0->next = (CacheRecord *)0L;
#line 5595
            *(m->rrcache_tail[slot]) = rr___0;
#line 5596
            m->rrcache_tail[slot] = & rr___0->next;
#line 5597
            (m->rrcache_used[slot]) ++;
#line 5599
            CacheRecordAdd(m, rr___0);
#line 5601
            SetNextCacheCheckTime(m, rr___0);
          }
        }
      }
    }
#line 5438
    i ++;
  }
#line 5609
  while (CacheFlushRecords) {
#line 5611
    r1 = CacheFlushRecords;
#line 5612
    CacheFlushRecords = CacheFlushRecords->NextInCFList;
#line 5613
    r1->NextInCFList = (CacheRecord *)0L;
#line 5614
    tmp___8 = DomainNameHashValue((domainname const   *)(& r1->resrec.name));
#line 5614
    r2 = m->rrcache_hash[tmp___8 % 499U];
#line 5614
    while (r2) {
#line 5615
      tmp___9 = SameResourceRecordSignature((ResourceRecord const   *)(& r1->resrec),
                                            (ResourceRecord const   *)(& r2->resrec));
#line 5615
      if (tmp___9) {
#line 5615
        if (m->timenow - r2->TimeRcvd > mDNSPlatformOneSecond) {
#line 5629
          r2->resrec.rroriginalttl = 1U;
#line 5630
          r2->TimeRcvd = m->timenow;
#line 5631
          r2->UnansweredQueries = 4U;
#line 5632
          SetNextCacheCheckTime(m, r2);
        }
      }
#line 5614
      r2 = r2->next;
    }
  }
#line 5635
  return;
}
}
#line 5637 "mDNS.c"
void mDNSCoreReceive(mDNS *m , DNSMessage *msg , mDNSu8 const   *end , mDNSAddr const   *srcaddr ,
                     mDNSIPPort srcport , mDNSAddr const   *dstaddr , mDNSIPPort dstport ,
                     mDNSInterfaceID InterfaceID , mDNSu8 ttl ) 
{ mDNSu8 StdQ ;
  mDNSu8 StdR ;
  mDNSu8 QR_OP ;
  mDNSu8 *ptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 5641
  StdQ = (mDNSu8 )0;
#line 5642
  StdR = (mDNSu8 )128;
#line 5643
  QR_OP = (unsigned char )((int )msg->h.flags.b[0] & 248);
#line 5646
  ptr = (mDNSu8 *)(& msg->h.numQuestions);
#line 5647
  msg->h.numQuestions = (unsigned short )(((int )((unsigned short )*(ptr + 0)) << 8) | (int )*(ptr + 1));
#line 5648
  msg->h.numAnswers = (unsigned short )(((int )((unsigned short )*(ptr + 2)) << 8) | (int )*(ptr + 3));
#line 5649
  msg->h.numAuthorities = (unsigned short )(((int )((unsigned short )*(ptr + 4)) << 8) | (int )*(ptr + 5));
#line 5650
  msg->h.numAdditionals = (unsigned short )(((int )((unsigned short )*(ptr + 6)) << 8) | (int )*(ptr + 7));
#line 5652
  if (! m) {
#line 5652
    LogMsg("mDNSCoreReceive ERROR m is NULL");
#line 5652
    return;
  }
#line 5656
  if (srcaddr->type == 4) {
#line 5656
    if (srcaddr->ip.v4.NotAnInteger == zeroIPAddr.NotAnInteger) {
#line 5656
      tmp = 0;
    } else {
#line 5656
      if (srcaddr->ip.v4.NotAnInteger == onesIPv4Addr.NotAnInteger) {
#line 5656
        tmp = 0;
      } else {
#line 5656
        tmp = 1;
      }
    }
#line 5656
    tmp___2 = tmp;
  } else {
#line 5656
    if (srcaddr->type == 6) {
#line 5656
      if (srcaddr->ip.v6.l[0] == zerov6Addr.l[0]) {
#line 5656
        if (srcaddr->ip.v6.l[1] == zerov6Addr.l[1]) {
#line 5656
          if (srcaddr->ip.v6.l[2] == zerov6Addr.l[2]) {
#line 5656
            if (srcaddr->ip.v6.l[3] == zerov6Addr.l[3]) {
#line 5656
              tmp___0 = 0;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 5656
        if (srcaddr->ip.v6.l[0] == onesIPv6Addr.l[0]) {
#line 5656
          if (srcaddr->ip.v6.l[1] == onesIPv6Addr.l[1]) {
#line 5656
            if (srcaddr->ip.v6.l[2] == onesIPv6Addr.l[2]) {
#line 5656
              if (srcaddr->ip.v6.l[3] == onesIPv6Addr.l[3]) {
#line 5656
                tmp___0 = 0;
              } else {
#line 5656
                tmp___0 = 1;
              }
            } else {
#line 5656
              tmp___0 = 1;
            }
          } else {
#line 5656
            tmp___0 = 1;
          }
        } else {
#line 5656
          tmp___0 = 1;
        }
      }
#line 5656
      tmp___1 = tmp___0;
    } else {
#line 5656
      tmp___1 = 0;
    }
#line 5656
    tmp___2 = tmp___1;
  }
#line 5656
  if (! tmp___2) {
#line 5656
    return;
  }
#line 5658
  mDNS_Lock(m);
#line 5659
  if ((int )QR_OP == (int )StdQ) {
#line 5659
    mDNSCoreReceiveQuery(m, (DNSMessage const   *)msg, end, srcaddr, srcport, dstaddr,
                         dstport, InterfaceID);
  } else {
#line 5660
    if ((int )QR_OP == (int )StdR) {
#line 5660
      mDNSCoreReceiveResponse(m, (DNSMessage const   *)msg, end, srcaddr, dstaddr,
                              InterfaceID, ttl);
    }
  }
#line 5668
  mDNS_Unlock(m);
#line 5669
  return;
}
}
#line 5678 "mDNS.c"
static DNSQuestion *FindDuplicateQuestion(mDNS const   *m , DNSQuestion const   *question ) 
{ DNSQuestion *q ;
  mDNSBool tmp ;

  {
#line 5685
  q = (DNSQuestion *)m->Questions;
#line 5685
  while (1) {
#line 5685
    if (q) {
#line 5685
      if (! ((unsigned int )q != (unsigned int )question)) {
#line 5685
        break;
      }
    } else {
#line 5685
      break;
    }
#line 5686
    if ((unsigned int )q->InterfaceID == (unsigned int )question->InterfaceID) {
#line 5686
      if ((int )q->qtype == (int )question->qtype) {
#line 5686
        if ((int )q->qclass == (int )question->qclass) {
#line 5686
          if (q->qnamehash == (mDNSu32 )question->qnamehash) {
#line 5686
            tmp = SameDomainName((domainname const   *)(& q->qname), & question->qname);
#line 5686
            if (tmp) {
#line 5691
              return (q);
            }
          }
        }
      }
    }
#line 5685
    q = q->next;
  }
#line 5692
  return ((DNSQuestion *)0L);
}
}
#line 5697 "mDNS.c"
static void UpdateQuestionDuplicates(mDNS *m , DNSQuestion const   *question ) 
{ DNSQuestion *q ;

  {
#line 5700
  q = m->Questions;
#line 5700
  while (q) {
#line 5701
    if ((unsigned int )q->DuplicateOf == (unsigned int )question) {
#line 5703
      q->ThisQInterval = (int )question->ThisQInterval;
#line 5704
      q->LastQTime = (int )question->LastQTime;
#line 5705
      q->RecentAnswers = 0U;
#line 5706
      q->DuplicateOf = FindDuplicateQuestion((mDNS const   *)m, (DNSQuestion const   *)q);
#line 5707
      q->LastQTxTime = (int )question->LastQTxTime;
#line 5708
      SetNextQueryTime(m, (DNSQuestion const   *)q);
    }
#line 5700
    q = q->next;
  }
#line 5710
  return;
}
}
#line 5712 "mDNS.c"
static mStatus mDNS_StartQuery_internal(mDNS *m , DNSQuestion *question ) 
{ int i ;
  DNSQuestion **q ;
  char *tmp ;
  NetworkInterfaceInfo *intf ;
  char *tmp___0 ;
  mDNSu16 tmp___1 ;
  mDNSu32 tmp___2 ;

  {
#line 5717
  if (m->rrcache_size == 0U) {
#line 5718
    return (-65546);
  } else {
#line 5723
    q = & m->Questions;
#line 5724
    if ((unsigned int )question->InterfaceID == (unsigned int )((struct mDNSInterfaceID_dummystruct *)-1)) {
#line 5724
      q = & m->LocalOnlyQuestions;
    }
#line 5725
    while (1) {
#line 5725
      if (*q) {
#line 5725
        if (! ((unsigned int )*q != (unsigned int )question)) {
#line 5725
          break;
        }
      } else {
#line 5725
        break;
      }
#line 5725
      q = & (*q)->next;
    }
#line 5727
    if (*q) {
#line 5729
      tmp = DNSTypeName(question->qtype);
#line 5729
      LogMsg("Error! Tried to add a question %##s (%s) that\'s already in the active list",
             question->qname.c, tmp);
#line 5731
      return (-65547);
    }
#line 5735
    if (question->InterfaceID) {
#line 5735
      if ((unsigned int )question->InterfaceID != (unsigned int )((struct mDNSInterfaceID_dummystruct *)-1)) {
#line 5738
        intf = m->HostInterfaces;
#line 5738
        while (intf) {
#line 5739
          if ((unsigned int )intf->InterfaceID == (unsigned int )question->InterfaceID) {
#line 5739
            break;
          }
#line 5738
          intf = intf->next;
        }
#line 5740
        if (! intf) {
#line 5743
          return (-65541);
        }
      }
    }
#line 5751
    tmp___1 = DomainNameLength((domainname const   *)(& question->qname));
#line 5751
    if (! ((int )tmp___1 <= 255)) {
#line 5753
      tmp___0 = DNSTypeName(question->qtype);
#line 5753
      LogMsg("Attempt to start query with invalid qname %##s %s", question->qname.c,
             tmp___0);
#line 5754
      return (-65549);
    }
#line 5757
    if (! m->RandomQueryDelay) {
#line 5757
      tmp___2 = mDNSRandom((unsigned int )(mDNSPlatformOneSecond / 2));
#line 5757
      m->RandomQueryDelay = 1 + (int )tmp___2;
    }
#line 5759
    question->next = (DNSQuestion *)0L;
#line 5760
    question->qnamehash = DomainNameHashValue((domainname const   *)(& question->qname));
#line 5761
    question->ThisQInterval = (mDNSPlatformOneSecond / 2) * 2;
#line 5762
    question->LastQTime = m->timenow - m->RandomQueryDelay;
#line 5763
    question->RecentAnswers = 0U;
#line 5764
    question->CurrentAnswers = 0U;
#line 5765
    question->LargeAnswers = 0U;
#line 5766
    question->UniqueAnswers = 0U;
#line 5767
    question->DuplicateOf = FindDuplicateQuestion((mDNS const   *)m, (DNSQuestion const   *)question);
#line 5768
    question->NextInDQList = (DNSQuestion *)0L;
#line 5769
    i = 0;
#line 5769
    while (i < 8) {
#line 5770
      question->DupSuppress[i].InterfaceID = (struct mDNSInterfaceID_dummystruct *)0L;
#line 5769
      i ++;
    }
#line 5772
    question->SendQNow = (struct mDNSInterfaceID_dummystruct *)0L;
#line 5773
    question->SendOnAll = 0;
#line 5774
    question->LastQTxTime = m->timenow;
#line 5776
    if (! question->DuplicateOf) {

    }
#line 5783
    *q = question;
#line 5784
    if ((unsigned int )question->InterfaceID == (unsigned int )((struct mDNSInterfaceID_dummystruct *)-1)) {
#line 5786
      if (! m->NewLocalOnlyQuestions) {
#line 5786
        m->NewLocalOnlyQuestions = question;
      }
    } else {
#line 5790
      if (! m->NewQuestions) {
#line 5790
        m->NewQuestions = question;
      }
#line 5791
      SetNextQueryTime(m, (DNSQuestion const   *)question);
    }
#line 5794
    return (0);
  }
}
}
#line 5798 "mDNS.c"
static mStatus mDNS_StopQuery_internal(mDNS *m , DNSQuestion *question ) 
{ CacheRecord *rr ;
  DNSQuestion **q ;
  char *tmp ;
  mDNSu32 tmp___0 ;
  DNSQuestion *q___0 ;
  mDNSBool tmp___1 ;

  {
#line 5801
  q = & m->Questions;
#line 5802
  if ((unsigned int )question->InterfaceID == (unsigned int )((struct mDNSInterfaceID_dummystruct *)-1)) {
#line 5802
    q = & m->LocalOnlyQuestions;
  }
#line 5803
  while (1) {
#line 5803
    if (*q) {
#line 5803
      if (! ((unsigned int )*q != (unsigned int )question)) {
#line 5803
        break;
      }
    } else {
#line 5803
      break;
    }
#line 5803
    q = & (*q)->next;
  }
#line 5804
  if (*q) {
#line 5804
    *q = (*q)->next;
  } else {
#line 5807
    if (question->ThisQInterval >= 0) {
#line 5808
      tmp = DNSTypeName(question->qtype);
#line 5808
      LogMsg("mDNS_StopQuery_internal: Question %##s (%s) not found in active list",
             question->qname.c, tmp);
    }
#line 5810
    return (-65541);
  }
#line 5814
  UpdateQuestionDuplicates(m, (DNSQuestion const   *)question);
#line 5816
  question->ThisQInterval = -1;
#line 5820
  tmp___0 = DomainNameHashValue((domainname const   *)(& question->qname));
#line 5820
  rr = m->rrcache_hash[tmp___0 % 499U];
#line 5820
  while (rr) {
#line 5822
    if ((unsigned int )rr->CRActiveQuestion == (unsigned int )question) {
#line 5825
      q___0 = m->Questions;
#line 5825
      while (q___0) {
#line 5826
        if (q___0->ThisQInterval > 0) {
#line 5826
          if (! q___0->DuplicateOf) {
#line 5826
            tmp___1 = ResourceRecordAnswersQuestion((ResourceRecord const   *)(& rr->resrec),
                                                    (DNSQuestion const   *)q___0);
#line 5826
            if (tmp___1) {
#line 5827
              break;
            }
          }
        }
#line 5825
        q___0 = q___0->next;
      }
#line 5829
      rr->CRActiveQuestion = q___0;
#line 5830
      if (! q___0) {
#line 5830
        (m->rrcache_active) --;
      }
    }
#line 5820
    rr = rr->next;
  }
#line 5836
  if ((unsigned int )m->CurrentQuestion == (unsigned int )question) {
#line 5840
    m->CurrentQuestion = question->next;
  }
#line 5843
  if ((unsigned int )m->NewQuestions == (unsigned int )question) {
#line 5847
    m->NewQuestions = question->next;
  }
#line 5850
  if ((unsigned int )m->NewLocalOnlyQuestions == (unsigned int )question) {
#line 5850
    m->NewLocalOnlyQuestions = question->next;
  }
#line 5853
  question->next = (DNSQuestion *)0L;
#line 5854
  return (0);
}
}
#line 5857 "mDNS.c"
mStatus mDNS_StartQuery(mDNS *m , DNSQuestion *question ) 
{ mStatus status ;

  {
#line 5860
  mDNS_Lock(m);
#line 5861
  status = mDNS_StartQuery_internal(m, question);
#line 5862
  mDNS_Unlock(m);
#line 5863
  return (status);
}
}
#line 5866 "mDNS.c"
mStatus mDNS_StopQuery(mDNS *m , DNSQuestion *question ) 
{ mStatus status ;

  {
#line 5869
  mDNS_Lock(m);
#line 5870
  status = mDNS_StopQuery_internal(m, question);
#line 5871
  mDNS_Unlock(m);
#line 5872
  return (status);
}
}
#line 5875 "mDNS.c"
mStatus mDNS_Reconfirm(mDNS *m , CacheRecord *rr ) 
{ mStatus status ;

  {
#line 5878
  mDNS_Lock(m);
#line 5879
  status = mDNS_Reconfirm_internal(m, rr, (unsigned int )mDNSPlatformOneSecond * 45U);
#line 5880
  mDNS_Unlock(m);
#line 5881
  return (status);
}
}
#line 5884 "mDNS.c"
mStatus mDNS_ReconfirmByValue(mDNS *m , ResourceRecord *rr ) 
{ mStatus status ;
  CacheRecord *cr ;

  {
#line 5886
  status = (mStatus )-65541;
#line 5888
  mDNS_Lock(m);
#line 5889
  cr = FindIdenticalRecordInCache((mDNS const   *)m, rr);
#line 5890
  if (cr) {
#line 5890
    status = mDNS_Reconfirm_internal(m, cr, (unsigned int )mDNSPlatformOneSecond * 45U);
  }
#line 5891
  mDNS_Unlock(m);
#line 5892
  return (status);
}
}
#line 5895 "mDNS.c"
mStatus mDNS_StartBrowse(mDNS *m , DNSQuestion *question , domainname const   *srv ,
                         domainname const   *domain , mDNSInterfaceID InterfaceID ,
                         mDNSQuestionCallback *Callback , void *Context ) 
{ mDNSu8 *tmp ;
  mStatus tmp___0 ;

  {
#line 5899
  question->ThisQInterval = -1;
#line 5900
  question->InterfaceID = InterfaceID;
#line 5901
  question->qtype = (unsigned short)12;
#line 5902
  question->qclass = (unsigned short)1;
#line 5903
  question->QuestionCallback = Callback;
#line 5904
  question->QuestionContext = Context;
#line 5905
  tmp = ConstructServiceName(& question->qname, (domainlabel const   *)0L, srv, domain);
#line 5905
  if (! tmp) {
#line 5905
    return (-65540);
  }
#line 5906
  tmp___0 = mDNS_StartQuery(m, question);
#line 5906
  return (tmp___0);
}
}
#line 5909 "mDNS.c"
static void FoundServiceInfoSRV(mDNS *m , DNSQuestion *question , ResourceRecord const   *answer ,
                                mDNSBool AddRecord ) 
{ ServiceInfoQuery *query ;
  mDNSBool PortChanged ;
  mDNSu16 tmp ;
  mDNSu16 tmp___0 ;
  mDNSu16 tmp___1 ;
  mDNSu16 tmp___2 ;
  mDNSBool tmp___3 ;
  mDNSBool tmp___4 ;

  {
#line 5911
  query = (ServiceInfoQuery *)question->QuestionContext;
#line 5912
  PortChanged = (int )(query->info)->port.NotAnInteger != (int )(answer->rdata)->u.srv.port.NotAnInteger;
#line 5913
  if (! AddRecord) {
#line 5913
    return;
  }
#line 5914
  if ((int const   )answer->rrtype != 33) {
#line 5914
    return;
  }
#line 5916
  (query->info)->port = (answer->rdata)->u.srv.port;
#line 5919
  if (! query->GotSRV) {
#line 5921
    query->GotSRV = (unsigned char)1;
#line 5922
    query->qAv4.InterfaceID = (struct mDNSInterfaceID_dummystruct *)answer->InterfaceID;
#line 5923
    tmp = DomainNameLength((domainname const   *)(& (answer->rdata)->u.srv.target));
#line 5923
    mDNSPlatformMemCopy((void const   *)((answer->rdata)->u.srv.target.c), (void *)(query->qAv4.qname.c),
                        (unsigned int )tmp);
#line 5924
    query->qAv6.InterfaceID = (struct mDNSInterfaceID_dummystruct *)answer->InterfaceID;
#line 5925
    tmp___0 = DomainNameLength((domainname const   *)(& (answer->rdata)->u.srv.target));
#line 5925
    mDNSPlatformMemCopy((void const   *)((answer->rdata)->u.srv.target.c), (void *)(query->qAv6.qname.c),
                        (unsigned int )tmp___0);
#line 5926
    mDNS_StartQuery_internal(m, & query->qAv4);
#line 5927
    mDNS_StartQuery_internal(m, & query->qAv6);
  } else {
#line 5930
    if ((unsigned int )query->qAv4.InterfaceID != (unsigned int )query->qSRV.InterfaceID) {
#line 5930
      if ((unsigned int )query->qAv4.InterfaceID != (unsigned int )answer->InterfaceID) {
        goto _L___0;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 5930
      tmp___4 = SameDomainName((domainname const   *)(& query->qAv4.qname), (domainname const   *)(& (answer->rdata)->u.srv.target));
#line 5930
      if (tmp___4) {
#line 5956
        if (query->ServiceInfoQueryCallback) {
#line 5956
          if (query->GotADD) {
#line 5956
            if (query->GotTXT) {
#line 5956
              if (PortChanged) {
#line 5958
                (query->Answers) ++;
#line 5958
                if (query->Answers >= 100U) {

                }
#line 5962
                (*(query->ServiceInfoQueryCallback))(m, query);
              }
            }
          }
        }
      } else {
        _L___0: /* CIL Label */ 
#line 5933
        mDNS_StopQuery_internal(m, & query->qAv4);
#line 5934
        mDNS_StopQuery_internal(m, & query->qAv6);
#line 5935
        tmp___3 = SameDomainName((domainname const   *)(& query->qAv4.qname), (domainname const   *)(& (answer->rdata)->u.srv.target));
#line 5935
        if (tmp___3) {
#line 5935
          if (! PortChanged) {
#line 5942
            query->qAv4.InterfaceID = query->qSRV.InterfaceID;
#line 5943
            query->qAv6.InterfaceID = query->qSRV.InterfaceID;
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 5947
          query->qAv4.InterfaceID = (struct mDNSInterfaceID_dummystruct *)answer->InterfaceID;
#line 5948
          tmp___1 = DomainNameLength((domainname const   *)(& (answer->rdata)->u.srv.target));
#line 5948
          mDNSPlatformMemCopy((void const   *)((answer->rdata)->u.srv.target.c), (void *)(query->qAv4.qname.c),
                              (unsigned int )tmp___1);
#line 5949
          query->qAv6.InterfaceID = (struct mDNSInterfaceID_dummystruct *)answer->InterfaceID;
#line 5950
          tmp___2 = DomainNameLength((domainname const   *)(& (answer->rdata)->u.srv.target));
#line 5950
          mDNSPlatformMemCopy((void const   *)((answer->rdata)->u.srv.target.c), (void *)(query->qAv6.qname.c),
                              (unsigned int )tmp___2);
        }
#line 5953
        mDNS_StartQuery_internal(m, & query->qAv4);
#line 5954
        mDNS_StartQuery_internal(m, & query->qAv6);
      }
    }
  }
#line 5966
  return;
}
}
#line 5968 "mDNS.c"
static void FoundServiceInfoTXT(mDNS *m , DNSQuestion *question , ResourceRecord const   *answer ,
                                mDNSBool AddRecord ) 
{ ServiceInfoQuery *query ;

  {
#line 5970
  query = (ServiceInfoQuery *)question->QuestionContext;
#line 5971
  if (! AddRecord) {
#line 5971
    return;
  }
#line 5972
  if ((int const   )answer->rrtype != 16) {
#line 5972
    return;
  }
#line 5973
  if ((unsigned int )answer->rdlength > sizeof((query->info)->TXTinfo)) {
#line 5973
    return;
  }
#line 5975
  query->GotTXT = (unsigned char)1;
#line 5976
  (query->info)->TXTlen = (unsigned short )answer->rdlength;
#line 5977
  mDNSPlatformMemCopy((void const   *)((answer->rdata)->u.txt.c), (void *)((query->info)->TXTinfo),
                      (unsigned int )answer->rdlength);
#line 5983
  if (query->ServiceInfoQueryCallback) {
#line 5983
    if (query->GotADD) {
#line 5985
      (query->Answers) ++;
#line 5985
      if (query->Answers >= 100U) {

      }
#line 5988
      (*(query->ServiceInfoQueryCallback))(m, query);
    }
  }
#line 5990
  return;
}
}
#line 5992 "mDNS.c"
static void FoundServiceInfo(mDNS *m , DNSQuestion *question , ResourceRecord const   *answer ,
                             mDNSBool AddRecord ) 
{ ServiceInfoQuery *query ;

  {
#line 5994
  query = (ServiceInfoQuery *)question->QuestionContext;
#line 5995
  if (! AddRecord) {
#line 5995
    return;
  }
#line 5997
  if ((int const   )answer->rrtype == 1) {
#line 5999
    (query->info)->ip.type = 4;
#line 6000
    (query->info)->ip.ip.v4 = (answer->rdata)->u.ip;
  } else {
#line 6002
    if ((int const   )answer->rrtype == 28) {
#line 6004
      (query->info)->ip.type = 6;
#line 6005
      (query->info)->ip.ip.v6 = (answer->rdata)->u.ipv6;
    } else {
#line 6010
      return;
    }
  }
#line 6013
  query->GotADD = (unsigned char)1;
#line 6014
  (query->info)->InterfaceID = (struct mDNSInterfaceID_dummystruct *)answer->InterfaceID;
#line 6020
  if (query->ServiceInfoQueryCallback) {
#line 6020
    if (query->GotTXT) {
#line 6022
      (query->Answers) ++;
#line 6022
      if (query->Answers >= 100U) {
#line 6024
        if ((int const   )answer->rrtype == 1) {

        }
      }
#line 6029
      (*(query->ServiceInfoQueryCallback))(m, query);
    }
  }
#line 6031
  return;
}
}
#line 6037 "mDNS.c"
mStatus mDNS_StartResolveService(mDNS *m , ServiceInfoQuery *query , ServiceInfo *info ,
                                 mDNSServiceInfoQueryCallback *Callback , void *Context ) 
{ mStatus status ;
  mDNSu16 tmp ;
  mDNSu16 tmp___0 ;

  {
#line 6041
  mDNS_Lock(m);
#line 6043
  query->qSRV.ThisQInterval = -1;
#line 6044
  query->qSRV.InterfaceID = info->InterfaceID;
#line 6045
  tmp = DomainNameLength((domainname const   *)(& info->name));
#line 6045
  mDNSPlatformMemCopy((void const   *)(info->name.c), (void *)(query->qSRV.qname.c),
                      (unsigned int )tmp);
#line 6046
  query->qSRV.qtype = (unsigned short)33;
#line 6047
  query->qSRV.qclass = (unsigned short)1;
#line 6048
  query->qSRV.QuestionCallback = & FoundServiceInfoSRV;
#line 6049
  query->qSRV.QuestionContext = (void *)query;
#line 6051
  query->qTXT.ThisQInterval = -1;
#line 6052
  query->qTXT.InterfaceID = info->InterfaceID;
#line 6053
  tmp___0 = DomainNameLength((domainname const   *)(& info->name));
#line 6053
  mDNSPlatformMemCopy((void const   *)(info->name.c), (void *)(query->qTXT.qname.c),
                      (unsigned int )tmp___0);
#line 6054
  query->qTXT.qtype = (unsigned short)16;
#line 6055
  query->qTXT.qclass = (unsigned short)1;
#line 6056
  query->qTXT.QuestionCallback = & FoundServiceInfoTXT;
#line 6057
  query->qTXT.QuestionContext = (void *)query;
#line 6059
  query->qAv4.ThisQInterval = -1;
#line 6060
  query->qAv4.InterfaceID = info->InterfaceID;
#line 6061
  query->qAv4.qname.c[0] = (unsigned char)0;
#line 6062
  query->qAv4.qtype = (unsigned short)1;
#line 6063
  query->qAv4.qclass = (unsigned short)1;
#line 6064
  query->qAv4.QuestionCallback = & FoundServiceInfo;
#line 6065
  query->qAv4.QuestionContext = (void *)query;
#line 6067
  query->qAv6.ThisQInterval = -1;
#line 6068
  query->qAv6.InterfaceID = info->InterfaceID;
#line 6069
  query->qAv6.qname.c[0] = (unsigned char)0;
#line 6070
  query->qAv6.qtype = (unsigned short)28;
#line 6071
  query->qAv6.qclass = (unsigned short)1;
#line 6072
  query->qAv6.QuestionCallback = & FoundServiceInfo;
#line 6073
  query->qAv6.QuestionContext = (void *)query;
#line 6075
  query->GotSRV = (unsigned char)0;
#line 6076
  query->GotTXT = (unsigned char)0;
#line 6077
  query->GotADD = (unsigned char)0;
#line 6078
  query->Answers = 0U;
#line 6080
  query->info = info;
#line 6081
  query->ServiceInfoQueryCallback = Callback;
#line 6082
  query->ServiceInfoQueryContext = Context;
#line 6086
  info->ip = (struct __anonstruct_mDNSAddr_22 )zeroAddr;
#line 6087
  info->port = (union __anonunion_mDNSOpaque16_18 )zeroIPPort;
#line 6088
  info->TXTlen = (unsigned short)0;
#line 6090
  status = mDNS_StartQuery_internal(m, & query->qSRV);
#line 6091
  if (status == 0) {
#line 6091
    status = mDNS_StartQuery_internal(m, & query->qTXT);
  }
#line 6092
  if (status != 0) {
#line 6092
    mDNS_StopResolveService(m, query);
  }
#line 6094
  mDNS_Unlock(m);
#line 6095
  return (status);
}
}
#line 6098 "mDNS.c"
void mDNS_StopResolveService(mDNS *m , ServiceInfoQuery *query ) 
{ 

  {
#line 6100
  mDNS_Lock(m);
#line 6101
  if (query->qSRV.ThisQInterval >= 0) {
#line 6101
    mDNS_StopQuery_internal(m, & query->qSRV);
  }
#line 6102
  if (query->qTXT.ThisQInterval >= 0) {
#line 6102
    mDNS_StopQuery_internal(m, & query->qTXT);
  }
#line 6103
  if (query->qAv4.ThisQInterval >= 0) {
#line 6103
    mDNS_StopQuery_internal(m, & query->qAv4);
  }
#line 6104
  if (query->qAv6.ThisQInterval >= 0) {
#line 6104
    mDNS_StopQuery_internal(m, & query->qAv6);
  }
#line 6105
  mDNS_Unlock(m);
#line 6106
  return;
}
}
#line 6108 "mDNS.c"
mStatus mDNS_GetDomains(mDNS *m , DNSQuestion *question , mDNS_DomainType DomainType ,
                        mDNSInterfaceID InterfaceID , mDNSQuestionCallback *Callback ,
                        void *Context ) 
{ 

  {
#line 6111
  MakeDomainNameFromDNSNameString(& question->qname, (char const   *)mDNS_DomainTypeNames[DomainType]);
#line 6112
  question->InterfaceID = InterfaceID;
#line 6113
  question->qtype = (unsigned short)12;
#line 6114
  question->qclass = (unsigned short)1;
#line 6115
  question->QuestionCallback = Callback;
#line 6116
  question->QuestionContext = Context;
#line 6121
  return (0);
}
}
#line 6132 "mDNS.c"
void mDNS_SetupResourceRecord(AuthRecord *rr , RData *RDataStorage , mDNSInterfaceID InterfaceID ,
                              mDNSu16 rrtype , mDNSu32 ttl , mDNSu8 RecordType , mDNSRecordCallback *Callback ,
                              void *Context ) 
{ 

  {
#line 6136
  if ((unsigned long )ttl > 2147483647UL / (unsigned long )mDNSPlatformOneSecond) {
#line 6137
    ttl = (unsigned int )(2147483647UL / (unsigned long )mDNSPlatformOneSecond);
  } else {
#line 6138
    if (ttl == 0U) {
#line 6139
      ttl = 7200U;
    }
  }
#line 6142
  rr->Additional1 = (AuthRecord *)0L;
#line 6143
  rr->Additional2 = (AuthRecord *)0L;
#line 6144
  rr->DependentOn = (AuthRecord *)0L;
#line 6145
  rr->RRSet = (AuthRecord *)0L;
#line 6146
  rr->RecordCallback = Callback;
#line 6147
  rr->RecordContext = Context;
#line 6149
  rr->resrec.RecordType = RecordType;
#line 6150
  rr->HostTarget = (unsigned char)0;
#line 6156
  rr->resrec.InterfaceID = InterfaceID;
#line 6157
  rr->resrec.name.c[0] = (unsigned char)0;
#line 6158
  rr->resrec.rrtype = rrtype;
#line 6159
  rr->resrec.rrclass = (unsigned short)1;
#line 6160
  rr->resrec.rroriginalttl = ttl;
#line 6165
  if (RDataStorage) {
#line 6166
    rr->resrec.rdata = RDataStorage;
  } else {
#line 6169
    rr->resrec.rdata = & rr->rdatastorage;
#line 6170
    (rr->resrec.rdata)->MaxRDLength = (unsigned short )sizeof(RDataBody );
  }
#line 6172
  return;
}
}
#line 6174 "mDNS.c"
mStatus mDNS_Register(mDNS *m , AuthRecord *rr ) 
{ mStatus status ;

  {
#line 6177
  mDNS_Lock(m);
#line 6178
  status = mDNS_Register_internal(m, rr);
#line 6179
  mDNS_Unlock(m);
#line 6180
  return (status);
}
}
#line 6183 "mDNS.c"
mStatus mDNS_Update(mDNS *m , AuthRecord *rr , mDNSu32 newttl , mDNSu16 newrdlength ,
                    RData *newrdata , mDNSRecordUpdateCallback *Callback ) 
{ char *tmp ;
  mDNSBool tmp___0 ;
  RData *n ;
  mDNSs32 tmp___1 ;
  mDNSs32 tmp___2 ;
  mDNSs32 delay ;

  {
#line 6187
  tmp___0 = ValidateRData(rr->resrec.rrtype, newrdlength, (RData const   *)newrdata);
#line 6187
  if (! tmp___0) {
#line 6188
    tmp = GetRRDisplayString_rdb(m, (ResourceRecord const   *)(& rr->resrec), & newrdata->u);
#line 6188
    LogMsg("Attempt to update record with invalid rdata: %s", tmp);
#line 6188
    return (-65549);
  }
#line 6190
  mDNS_Lock(m);
#line 6193
  if (newttl == 0U) {
#line 6193
    newttl = rr->resrec.rroriginalttl;
  }
#line 6197
  if (rr->NewRData) {
#line 6199
    n = rr->NewRData;
#line 6200
    rr->NewRData = (RData *)0L;
#line 6201
    if (rr->UpdateCallback) {
#line 6202
      (*(rr->UpdateCallback))(m, rr, n);
    }
  }
#line 6205
  if ((int )rr->AnnounceCount < 9) {
#line 6206
    rr->AnnounceCount = (unsigned char)9;
  }
#line 6207
  if ((int )rr->resrec.RecordType & 12) {
#line 6207
    rr->ThisAPInterval = mDNSPlatformOneSecond / 2;
  } else {
#line 6207
    if ((int )rr->resrec.RecordType & 2) {
#line 6207
      tmp___2 = mDNSPlatformOneSecond / 4;
    } else {
#line 6207
      if ((int )rr->resrec.RecordType & 48) {
#line 6207
        tmp___1 = mDNSPlatformOneSecond / 2;
      } else {
#line 6207
        tmp___1 = 0;
      }
#line 6207
      tmp___2 = tmp___1;
    }
#line 6207
    rr->ThisAPInterval = tmp___2;
  }
#line 6208
  InitializeLastAPTime(m, rr);
#line 6209
  rr->NewRData = newrdata;
#line 6210
  rr->newrdlength = newrdlength;
#line 6211
  rr->UpdateCallback = Callback;
#line 6212
  if (! rr->UpdateBlocked) {
#line 6212
    if (rr->UpdateCredits) {
#line 6212
      (rr->UpdateCredits) --;
    }
  }
#line 6213
  if (! rr->NextUpdateCredit) {
#line 6213
    rr->NextUpdateCredit = (m->timenow + mDNSPlatformOneSecond * 60) | 1;
  }
#line 6214
  if ((mDNSu32 )rr->AnnounceCount > rr->UpdateCredits + 1U) {
#line 6214
    rr->AnnounceCount = (unsigned char )(rr->UpdateCredits + 1U);
  }
#line 6215
  if (rr->UpdateCredits <= 5U) {
#line 6217
    delay = 1 << (5U - rr->UpdateCredits);
#line 6218
    if (! rr->UpdateBlocked) {
#line 6218
      rr->UpdateBlocked = (m->timenow + delay * mDNSPlatformOneSecond) | 1;
    }
#line 6219
    rr->LastAPTime = rr->UpdateBlocked;
#line 6220
    rr->ThisAPInterval *= 4;
#line 6221
    LogMsg("Excessive update rate for %##s; delaying announcement by %d seconds",
           rr->resrec.name.c, delay);
  }
#line 6223
  rr->resrec.rroriginalttl = newttl;
#line 6224
  mDNS_Unlock(m);
#line 6225
  return (0);
}
}
#line 6231 "mDNS.c"
mStatus mDNS_Deregister(mDNS *m , AuthRecord *rr ) 
{ mStatus status ;

  {
#line 6234
  mDNS_Lock(m);
#line 6235
  status = mDNS_Deregister_internal(m, rr, 0);
#line 6236
  mDNS_Unlock(m);
#line 6237
  return (status);
}
}
#line 6240
static void HostNameCallback(mDNS *m , AuthRecord *rr , mStatus result ) ;
#line 6242 "mDNS.c"
static NetworkInterfaceInfo *FindFirstAdvertisedInterface(mDNS *m ) 
{ NetworkInterfaceInfo *intf ;

  {
#line 6245
  intf = m->HostInterfaces;
#line 6245
  while (intf) {
#line 6246
    if (intf->Advertise) {
#line 6246
      break;
    }
#line 6245
    intf = intf->next;
  }
#line 6247
  return (intf);
}
}
#line 6278
static void mDNS_AdvertiseInterface(mDNS *m , NetworkInterfaceInfo *set ) ;
#line 6278 "mDNS.c"
static char const   hexValues[17]  = 
#line 6278
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'\000'};
#line 6250 "mDNS.c"
static void mDNS_AdvertiseInterface(mDNS *m , NetworkInterfaceInfo *set ) 
{ char buffer___0[256] ;
  NetworkInterfaceInfo *primary ;
  NetworkInterfaceInfo *tmp ;
  mDNSu16 tmp___0 ;
  int i ;
  mDNSu8 *p ;
  mDNSu16 tmp___1 ;

  {
#line 6253
  tmp = FindFirstAdvertisedInterface(m);
#line 6253
  primary = tmp;
#line 6254
  if (! primary) {
#line 6254
    primary = set;
  }
#line 6256
  mDNS_SetupResourceRecord(& set->RR_A, (RData *)0L, set->InterfaceID, (unsigned short)1,
                           240U, (unsigned char)2, & HostNameCallback, (void *)set);
#line 6257
  mDNS_SetupResourceRecord(& set->RR_PTR, (RData *)0L, set->InterfaceID, (unsigned short)12,
                           240U, (unsigned char)32, (mDNSRecordCallback *)0L, (void *)0L);
#line 6258
  mDNS_SetupResourceRecord(& set->RR_HINFO, (RData *)0L, set->InterfaceID, (unsigned short)13,
                           240U, (unsigned char)2, (mDNSRecordCallback *)0L, (void *)0L);
#line 6262
  tmp___0 = DomainNameLength((domainname const   *)(& m->hostname));
#line 6262
  mDNSPlatformMemCopy((void const   *)(m->hostname.c), (void *)(set->RR_A.resrec.name.c),
                      (unsigned int )tmp___0);
#line 6263
  if (set->ip.type == 4) {
#line 6265
    set->RR_A.resrec.rrtype = (unsigned short)1;
#line 6266
    (set->RR_A.resrec.rdata)->u.ip = set->ip.ip.v4;
#line 6268
    mDNS_snprintf(buffer___0, sizeof(buffer___0), "%d.%d.%d.%d.in-addr.arpa.", set->ip.ip.v4.b[3],
                  set->ip.ip.v4.b[2], set->ip.ip.v4.b[1], set->ip.ip.v4.b[0]);
  } else {
#line 6271
    if (set->ip.type == 6) {
#line 6274
      set->RR_A.resrec.rrtype = (unsigned short)28;
#line 6275
      (set->RR_A.resrec.rdata)->u.ipv6 = set->ip.ip.v6;
#line 6276
      i = 0;
#line 6276
      while (i < 16) {
#line 6279
        buffer___0[i * 4] = (char )hexValues[(int )set->ip.ip.v6.b[15 - i] & 15];
#line 6280
        buffer___0[i * 4 + 1] = (char )'.';
#line 6281
        buffer___0[i * 4 + 2] = (char )hexValues[(int )set->ip.ip.v6.b[15 - i] >> 4];
#line 6282
        buffer___0[i * 4 + 3] = (char )'.';
#line 6276
        i ++;
      }
#line 6284
      mDNS_snprintf(& buffer___0[64], sizeof(buffer___0) - 64U, "ip6.arpa.");
    }
  }
#line 6287
  MakeDomainNameFromDNSNameString(& set->RR_PTR.resrec.name, (char const   *)(buffer___0));
#line 6288
  set->RR_PTR.HostTarget = (unsigned char)1;
#line 6290
  set->RR_A.RRSet = & primary->RR_A;
#line 6292
  mDNS_Register_internal(m, & set->RR_A);
#line 6293
  mDNS_Register_internal(m, & set->RR_PTR);
#line 6295
  if ((int )m->HIHardware.c[0] > 0) {
#line 6295
    if ((int )m->HISoftware.c[0] > 0) {
#line 6295
      if ((int )m->HIHardware.c[0] + (int )m->HISoftware.c[0] <= 254) {
#line 6297
        p = (set->RR_HINFO.resrec.rdata)->u.data;
#line 6298
        tmp___1 = DomainNameLength((domainname const   *)(& m->hostname));
#line 6298
        mDNSPlatformMemCopy((void const   *)(m->hostname.c), (void *)(set->RR_HINFO.resrec.name.c),
                            (unsigned int )tmp___1);
#line 6299
        set->RR_HINFO.DependentOn = & set->RR_A;
#line 6300
        mDNSPlatformMemCopy((void const   *)(& m->HIHardware), (void *)p, 1U + (unsigned int )m->HIHardware.c[0]);
#line 6301
        p += 1 + (int )*(p + 0);
#line 6302
        mDNSPlatformMemCopy((void const   *)(& m->HISoftware), (void *)p, 1U + (unsigned int )m->HISoftware.c[0]);
#line 6303
        mDNS_Register_internal(m, & set->RR_HINFO);
      } else {
#line 6308
        set->RR_HINFO.resrec.RecordType = (unsigned char)0;
      }
    } else {
#line 6308
      set->RR_HINFO.resrec.RecordType = (unsigned char)0;
    }
  } else {
#line 6308
    set->RR_HINFO.resrec.RecordType = (unsigned char)0;
  }
#line 6310
  return;
}
}
#line 6312 "mDNS.c"
static void mDNS_DeadvertiseInterface(mDNS *m , NetworkInterfaceInfo *set ) 
{ NetworkInterfaceInfo *intf ;
  NetworkInterfaceInfo *primary ;
  NetworkInterfaceInfo *tmp ;
  AuthRecord *A ;
  AuthRecord *tmp___0 ;

  {
#line 6316
  tmp = FindFirstAdvertisedInterface(m);
#line 6316
  primary = tmp;
#line 6317
  if (primary) {
#line 6317
    tmp___0 = & primary->RR_A;
  } else {
#line 6317
    tmp___0 = (AuthRecord *)0L;
  }
#line 6317
  A = tmp___0;
#line 6318
  intf = m->HostInterfaces;
#line 6318
  while (intf) {
#line 6319
    if ((unsigned int )intf->RR_A.RRSet == (unsigned int )(& set->RR_A)) {
#line 6320
      intf->RR_A.RRSet = A;
    }
#line 6318
    intf = intf->next;
  }
#line 6327
  if (set->RR_A.resrec.RecordType) {
#line 6327
    mDNS_Deregister_internal(m, & set->RR_A, 0);
  }
#line 6328
  if (set->RR_PTR.resrec.RecordType) {
#line 6328
    mDNS_Deregister_internal(m, & set->RR_PTR, 0);
  }
#line 6329
  if (set->RR_HINFO.resrec.RecordType) {
#line 6329
    mDNS_Deregister_internal(m, & set->RR_HINFO, 0);
  }
#line 6330
  return;
}
}
#line 6332 "mDNS.c"
void mDNS_GenerateFQDN(mDNS *m ) 
{ domainname newname ;
  mDNSu8 *tmp ;
  mDNSu8 *tmp___0 ;
  NetworkInterfaceInfo *intf ;
  AuthRecord *rr ;
  mDNSBool tmp___1 ;

  {
#line 6335
  mDNS_Lock(m);
#line 6337
  newname.c[0] = (unsigned char)0;
#line 6338
  tmp = AppendDomainLabel(& newname, (domainlabel const   *)(& m->hostlabel));
#line 6338
  if (! tmp) {
#line 6338
    LogMsg("ERROR! Cannot create dot-local hostname");
  }
#line 6339
  tmp___0 = AppendLiteralLabelString(& newname, "local");
#line 6339
  if (! tmp___0) {
#line 6339
    LogMsg("ERROR! Cannot create dot-local hostname");
  }
#line 6340
  tmp___1 = SameDomainName((domainname const   *)(& m->hostname), (domainname const   *)(& newname));
#line 6340
  if (! tmp___1) {
#line 6345
    m->hostname = newname;
#line 6348
    intf = m->HostInterfaces;
#line 6348
    while (intf) {
#line 6349
      if (intf->Advertise) {
#line 6349
        mDNS_DeadvertiseInterface(m, intf);
      }
#line 6348
      intf = intf->next;
    }
#line 6352
    intf = m->HostInterfaces;
#line 6352
    while (intf) {
#line 6353
      if (intf->Advertise) {
#line 6353
        mDNS_AdvertiseInterface(m, intf);
      }
#line 6352
      intf = intf->next;
    }
#line 6357
    rr = m->ResourceRecords;
#line 6357
    while (rr) {
#line 6357
      if (rr->HostTarget) {
#line 6357
        SetTargetToHostName(m, rr);
      }
#line 6357
      rr = rr->next;
    }
#line 6358
    rr = m->DuplicateRecords;
#line 6358
    while (rr) {
#line 6358
      if (rr->HostTarget) {
#line 6358
        SetTargetToHostName(m, rr);
      }
#line 6358
      rr = rr->next;
    }
  }
#line 6361
  mDNS_Unlock(m);
#line 6362
  return;
}
}
#line 6364 "mDNS.c"
static void HostNameCallback(mDNS *m , AuthRecord *rr , mStatus result ) 
{ domainlabel oldlabel ;
  mDNSBool tmp ;

  {
#line 6377
  if (result == 0) {
#line 6380
    if (m->MainCallback) {
#line 6381
      (*(m->MainCallback))(m, result);
    }
  } else {
#line 6383
    if (result == -65548) {
#line 6385
      oldlabel = m->hostlabel;
#line 6388
      if (m->MainCallback) {
#line 6389
        (*(m->MainCallback))(m, -65548);
      }
#line 6392
      tmp = SameDomainLabel((mDNSu8 const   *)(m->hostlabel.c), (mDNSu8 const   *)(oldlabel.c));
#line 6392
      if (tmp) {
#line 6393
        IncrementLabelSuffix(& m->hostlabel, 0);
      }
#line 6397
      mDNS_GenerateFQDN(m);
    }
  }
#line 6399
  return;
}
}
#line 6401 "mDNS.c"
static void UpdateInterfaceProtocols(mDNS *m , NetworkInterfaceInfo *active ) 
{ NetworkInterfaceInfo *intf ;

  {
#line 6404
  active->IPv4Available = 0;
#line 6405
  active->IPv6Available = 0;
#line 6406
  intf = m->HostInterfaces;
#line 6406
  while (intf) {
#line 6407
    if ((unsigned int )intf->InterfaceID == (unsigned int )active->InterfaceID) {
#line 6409
      if (intf->ip.type == 4) {
#line 6409
        if (intf->TxAndRx) {
#line 6409
          active->IPv4Available = 1;
        }
      }
#line 6410
      if (intf->ip.type == 6) {
#line 6410
        if (intf->TxAndRx) {
#line 6410
          active->IPv6Available = 1;
        }
      }
    }
#line 6406
    intf = intf->next;
  }
#line 6412
  return;
}
}
#line 6414 "mDNS.c"
mStatus mDNS_RegisterInterface(mDNS *m , NetworkInterfaceInfo *set ) 
{ mDNSBool FirstOfType ;
  NetworkInterfaceInfo **p ;
  int tmp ;
  int tmp___0 ;
  DNSQuestion *q ;
  AuthRecord *rr ;
  mDNSu32 tmp___1 ;
  mDNSs32 tmp___2 ;
  mDNSs32 tmp___3 ;

  {
#line 6416
  FirstOfType = (mDNSBool )1;
#line 6417
  p = & m->HostInterfaces;
#line 6418
  mDNS_Lock(m);
#line 6421
  set->InterfaceActive = 1;
#line 6422
  if (set->ip.type == 4) {
#line 6422
    if (set->TxAndRx) {
#line 6422
      tmp = 1;
    } else {
#line 6422
      tmp = 0;
    }
  } else {
#line 6422
    tmp = 0;
  }
#line 6422
  set->IPv4Available = tmp;
#line 6423
  if (set->ip.type == 6) {
#line 6423
    if (set->TxAndRx) {
#line 6423
      tmp___0 = 1;
    } else {
#line 6423
      tmp___0 = 0;
    }
  } else {
#line 6423
    tmp___0 = 0;
  }
#line 6423
  set->IPv6Available = tmp___0;
#line 6425
  while (*p) {
#line 6427
    if ((unsigned int )*p == (unsigned int )set) {
#line 6429
      LogMsg("Error! Tried to register a NetworkInterfaceInfo that\'s already in the list");
#line 6430
      mDNS_Unlock(m);
#line 6431
      return (-65547);
    }
#line 6435
    if ((unsigned int )(*p)->InterfaceID == (unsigned int )set->InterfaceID) {
#line 6437
      set->InterfaceActive = 0;
#line 6438
      if (set->ip.type == (*p)->ip.type) {
#line 6438
        FirstOfType = 0;
      }
#line 6439
      if (set->ip.type == 4) {
#line 6439
        if (set->TxAndRx) {
#line 6439
          (*p)->IPv4Available = 1;
        }
      }
#line 6440
      if (set->ip.type == 6) {
#line 6440
        if (set->TxAndRx) {
#line 6440
          (*p)->IPv6Available = 1;
        }
      }
    }
#line 6443
    p = & (*p)->next;
  }
#line 6446
  set->next = (NetworkInterfaceInfo *)0L;
#line 6447
  *p = set;
#line 6458
  if (m->KnownBugs & 1U) {
    goto _L___1;
  } else {
#line 6458
    if (FirstOfType) {
      goto _L___1;
    } else {
#line 6458
      if (set->InterfaceActive) {
        _L___1: /* CIL Label */ 
#line 6465
        if (! m->SuppressSending) {
#line 6465
          tmp___1 = mDNSRandom((unsigned int )(mDNSPlatformOneSecond / 2));
#line 6465
          m->SuppressSending = m->timenow + (int )tmp___1;
        }
#line 6466
        q = m->Questions;
#line 6466
        while (q) {
#line 6467
          if (! q->InterfaceID) {
            goto _L;
          } else {
#line 6467
            if ((unsigned int )q->InterfaceID == (unsigned int )set->InterfaceID) {
              _L: /* CIL Label */ 
#line 6469
              q->ThisQInterval = mDNSPlatformOneSecond / 2;
#line 6470
              q->LastQTime = m->timenow - q->ThisQInterval;
#line 6471
              q->RecentAnswers = 0U;
#line 6472
              if (q->ThisQInterval > 0) {
#line 6472
                if (! q->DuplicateOf) {
#line 6472
                  m->NextScheduledQuery = m->timenow;
                }
              }
            }
          }
#line 6466
          q = q->next;
        }
#line 6477
        rr = m->ResourceRecords;
#line 6477
        while (rr) {
#line 6478
          if (! rr->resrec.InterfaceID) {
            goto _L___0;
          } else {
#line 6478
            if ((unsigned int )rr->resrec.InterfaceID == (unsigned int )set->InterfaceID) {
              _L___0: /* CIL Label */ 
#line 6480
              if ((int )rr->resrec.RecordType == 16) {
#line 6480
                if (! rr->DependentOn) {
#line 6480
                  rr->resrec.RecordType = (unsigned char)2;
                }
              }
#line 6481
              if ((int )rr->resrec.RecordType == 2) {
#line 6481
                rr->ProbeCount = (unsigned char)3;
              } else {
#line 6481
                rr->ProbeCount = (unsigned char)0;
              }
#line 6482
              if ((int )rr->AnnounceCount < 9) {
#line 6483
                rr->AnnounceCount = (unsigned char)9;
              }
#line 6484
              if ((int )rr->resrec.RecordType & 12) {
#line 6484
                rr->ThisAPInterval = mDNSPlatformOneSecond / 2;
              } else {
#line 6484
                if ((int )rr->resrec.RecordType & 2) {
#line 6484
                  tmp___3 = mDNSPlatformOneSecond / 4;
                } else {
#line 6484
                  if ((int )rr->resrec.RecordType & 48) {
#line 6484
                    tmp___2 = mDNSPlatformOneSecond / 2;
                  } else {
#line 6484
                    tmp___2 = 0;
                  }
#line 6484
                  tmp___3 = tmp___2;
                }
#line 6484
                rr->ThisAPInterval = tmp___3;
              }
#line 6485
              InitializeLastAPTime(m, rr);
            }
          }
#line 6477
          rr = rr->next;
        }
      }
    }
  }
#line 6489
  if (set->Advertise) {
#line 6490
    mDNS_AdvertiseInterface(m, set);
  }
#line 6492
  mDNS_Unlock(m);
#line 6493
  return (0);
}
}
#line 6499 "mDNS.c"
void mDNS_DeregisterInterface(mDNS *m , NetworkInterfaceInfo *set ) 
{ NetworkInterfaceInfo **p ;
  mDNSBool revalidate ;
  NetworkInterfaceInfo *intf ;
  NetworkInterfaceInfo *intf___0 ;
  CacheRecord *rr ;
  DNSQuestion *q ;
  mDNSu32 slot ;
  mDNSu32 slot___0 ;
  CacheRecord *rr___0 ;

  {
#line 6501
  p = & m->HostInterfaces;
#line 6503
  revalidate = (mDNSBool )0;
#line 6507
  if (m->KnownBugs & 1U) {
#line 6507
    revalidate = 1;
  }
#line 6509
  mDNS_Lock(m);
#line 6512
  while (1) {
#line 6512
    if (*p) {
#line 6512
      if (! ((unsigned int )*p != (unsigned int )set)) {
#line 6512
        break;
      }
    } else {
#line 6512
      break;
    }
#line 6512
    p = & (*p)->next;
  }
#line 6513
  if (! *p) {
#line 6513
    mDNS_Unlock(m);
#line 6513
    return;
  }
#line 6516
  *p = (*p)->next;
#line 6517
  set->next = (NetworkInterfaceInfo *)0L;
#line 6519
  if (! set->InterfaceActive) {
#line 6523
    intf = m->HostInterfaces;
#line 6523
    while (intf) {
#line 6524
      if (intf->InterfaceActive) {
#line 6524
        if ((unsigned int )intf->InterfaceID == (unsigned int )set->InterfaceID) {
#line 6525
          UpdateInterfaceProtocols(m, intf);
        }
      }
#line 6523
      intf = intf->next;
    }
  } else {
#line 6530
    intf___0 = m->HostInterfaces;
#line 6530
    while (intf___0) {
#line 6531
      if ((unsigned int )intf___0->InterfaceID == (unsigned int )set->InterfaceID) {
#line 6532
        break;
      }
#line 6530
      intf___0 = intf___0->next;
    }
#line 6533
    if (intf___0) {
#line 6537
      intf___0->InterfaceActive = 1;
#line 6538
      UpdateInterfaceProtocols(m, intf___0);
#line 6542
      intf___0 = m->HostInterfaces;
#line 6542
      while (intf___0) {
#line 6543
        if ((unsigned int )intf___0->InterfaceID == (unsigned int )set->InterfaceID) {
#line 6543
          if (intf___0->ip.type == set->ip.type) {
#line 6544
            break;
          }
        }
#line 6542
        intf___0 = intf___0->next;
      }
#line 6545
      if (! intf___0) {
#line 6545
        revalidate = 1;
      }
    } else {
#line 6556
      q = m->Questions;
#line 6556
      while (q) {
#line 6557
        if ((unsigned int )q->InterfaceID == (unsigned int )set->InterfaceID) {
#line 6558
          q->ThisQInterval = 0;
        }
#line 6556
        q = q->next;
      }
#line 6561
      revalidate = 0;
#line 6562
      slot = 0U;
#line 6562
      while (slot < 499U) {
#line 6563
        rr = m->rrcache_hash[slot];
#line 6563
        while (rr) {
#line 6564
          if ((unsigned int )rr->resrec.InterfaceID == (unsigned int )set->InterfaceID) {
#line 6565
            PurgeCacheResourceRecord(m, rr);
          }
#line 6563
          rr = rr->next;
        }
#line 6562
        slot ++;
      }
    }
  }
#line 6570
  if (set->Advertise) {
#line 6571
    mDNS_DeadvertiseInterface(m, set);
  }
#line 6577
  if (revalidate) {
#line 6577
    if (! m->mDNS_shutdown) {
#line 6581
      m->NextCacheCheck = m->timenow;
#line 6582
      slot___0 = 0U;
#line 6582
      while (slot___0 < 499U) {
#line 6583
        rr___0 = m->rrcache_hash[slot___0];
#line 6583
        while (rr___0) {
#line 6584
          if ((unsigned int )rr___0->resrec.InterfaceID == (unsigned int )set->InterfaceID) {
#line 6585
            mDNS_Reconfirm_internal(m, rr___0, (unsigned int )mDNSPlatformOneSecond * 5U);
          }
#line 6583
          rr___0 = rr___0->next;
        }
#line 6582
        slot___0 ++;
      }
    }
  }
#line 6588
  mDNS_Unlock(m);
#line 6589
  return;
}
}
#line 6591 "mDNS.c"
static void ServiceCallback(mDNS *m , AuthRecord *rr , mStatus result ) 
{ ServiceRecordSet *sr ;
  mDNSu32 i ;

  {
#line 6593
  sr = (ServiceRecordSet *)rr->RecordContext;
#line 6607
  if (result == -65548) {
#line 6609
    sr->Conflict = 1;
#line 6610
    sr->RR_PTR.AnnounceCount = (unsigned char)10;
#line 6611
    mDNS_DeregisterService(m, sr);
#line 6612
    return;
  }
#line 6615
  if (result == -65792) {
#line 6620
    if ((int )sr->RR_PTR.resrec.RecordType != 0) {
#line 6620
      return;
    }
#line 6621
    i = 0U;
#line 6621
    while (i < sr->NumSubTypes) {
#line 6621
      if ((int )(sr->SubTypes + i)->resrec.RecordType != 0) {
#line 6621
        return;
      }
#line 6621
      i ++;
    }
#line 6625
    if (sr->Conflict) {
#line 6625
      result = -65548;
    }
  }
#line 6630
  if (sr->ServiceCallback) {
#line 6631
    (*(sr->ServiceCallback))(m, sr, result);
  }
#line 6632
  return;
}
}
#line 6642 "mDNS.c"
mStatus mDNS_RegisterService(mDNS *m , ServiceRecordSet *sr , domainlabel const   *name ,
                             domainname const   *type , domainname const   *domain ,
                             domainname const   *host , mDNSIPPort port , mDNSu8 const   *txtinfo ,
                             mDNSu16 txtlen , AuthRecord *SubTypes , mDNSu32 NumSubTypes ,
                             mDNSInterfaceID InterfaceID , mDNSServiceCallback *Callback ,
                             void *Context ) 
{ mStatus err ;
  mDNSu32 i ;
  mDNSu8 *tmp ;
  mDNSu8 *tmp___0 ;
  mDNSu8 *tmp___1 ;
  mDNSu16 tmp___2 ;
  mDNSu16 tmp___3 ;
  mDNSu16 tmp___4 ;
  domainlabel s ;
  mDNSu8 *tmp___5 ;
  mDNSu16 tmp___6 ;
  mDNSu16 tmp___7 ;

  {
#line 6651
  sr->ServiceCallback = Callback;
#line 6652
  sr->ServiceContext = Context;
#line 6653
  sr->Extras = (ExtraResourceRecord *)0L;
#line 6654
  sr->NumSubTypes = NumSubTypes;
#line 6655
  sr->SubTypes = SubTypes;
#line 6656
  sr->Conflict = 0;
#line 6657
  if (host) {
#line 6657
    if (host->c[0]) {
#line 6657
      sr->Host = (struct __anonstruct_domainname_27 )*host;
    } else {
#line 6658
      sr->Host.c[0] = (unsigned char)0;
    }
  } else {
#line 6658
    sr->Host.c[0] = (unsigned char)0;
  }
#line 6661
  mDNS_SetupResourceRecord(& sr->RR_ADV, (RData *)0L, InterfaceID, (unsigned short)12,
                           7200U, (unsigned char)4, & ServiceCallback, (void *)sr);
#line 6662
  mDNS_SetupResourceRecord(& sr->RR_PTR, (RData *)0L, InterfaceID, (unsigned short)12,
                           7200U, (unsigned char)8, & ServiceCallback, (void *)sr);
#line 6663
  mDNS_SetupResourceRecord(& sr->RR_SRV, (RData *)0L, InterfaceID, (unsigned short)33,
                           240U, (unsigned char)2, & ServiceCallback, (void *)sr);
#line 6664
  mDNS_SetupResourceRecord(& sr->RR_TXT, (RData *)0L, InterfaceID, (unsigned short)16,
                           240U, (unsigned char)2, & ServiceCallback, (void *)sr);
#line 6668
  if ((int )(sr->RR_TXT.resrec.rdata)->MaxRDLength < (int )txtlen) {
#line 6669
    (sr->RR_TXT.resrec.rdata)->MaxRDLength = txtlen;
  }
#line 6674
  tmp = ConstructServiceName(& sr->RR_ADV.resrec.name, (domainlabel const   *)((domainlabel *)"\t_services"),
                             (domainname const   *)((domainname *)"\a_dns-sd\004_udp"),
                             domain);
#line 6674
  if ((unsigned int )tmp == (unsigned int )((mDNSu8 *)0)) {
#line 6675
    return (-65540);
  }
#line 6676
  tmp___0 = ConstructServiceName(& sr->RR_PTR.resrec.name, (domainlabel const   *)0L,
                                 type, domain);
#line 6676
  if ((unsigned int )tmp___0 == (unsigned int )((mDNSu8 *)0)) {
#line 6676
    return (-65540);
  }
#line 6677
  tmp___1 = ConstructServiceName(& sr->RR_SRV.resrec.name, name, type, domain);
#line 6677
  if ((unsigned int )tmp___1 == (unsigned int )((mDNSu8 *)0)) {
#line 6677
    return (-65540);
  }
#line 6678
  tmp___2 = DomainNameLength((domainname const   *)(& sr->RR_SRV.resrec.name));
#line 6678
  mDNSPlatformMemCopy((void const   *)(sr->RR_SRV.resrec.name.c), (void *)(sr->RR_TXT.resrec.name.c),
                      (unsigned int )tmp___2);
#line 6681
  tmp___3 = DomainNameLength((domainname const   *)(& sr->RR_PTR.resrec.name));
#line 6681
  mDNSPlatformMemCopy((void const   *)(sr->RR_PTR.resrec.name.c), (void *)((sr->RR_ADV.resrec.rdata)->u.name.c),
                      (unsigned int )tmp___3);
#line 6685
  tmp___4 = DomainNameLength((domainname const   *)(& sr->RR_SRV.resrec.name));
#line 6685
  mDNSPlatformMemCopy((void const   *)(sr->RR_SRV.resrec.name.c), (void *)((sr->RR_PTR.resrec.rdata)->u.name.c),
                      (unsigned int )tmp___4);
#line 6686
  sr->RR_PTR.Additional1 = & sr->RR_SRV;
#line 6687
  sr->RR_PTR.Additional2 = & sr->RR_TXT;
#line 6692
  i = 0U;
#line 6692
  while (i < NumSubTypes) {
#line 6694
    s = *((domainlabel *)(& (sr->SubTypes + i)->resrec.name));
#line 6695
    mDNS_SetupResourceRecord(sr->SubTypes + i, (RData *)0L, InterfaceID, (unsigned short)12,
                             7200U, (unsigned char)8, & ServiceCallback, (void *)sr);
#line 6696
    tmp___5 = ConstructServiceName(& (sr->SubTypes + i)->resrec.name, (domainlabel const   *)(& s),
                                   type, domain);
#line 6696
    if ((unsigned int )tmp___5 == (unsigned int )((mDNSu8 *)0)) {
#line 6696
      return (-65540);
    }
#line 6697
    tmp___6 = DomainNameLength((domainname const   *)(& sr->RR_SRV.resrec.name));
#line 6697
    mDNSPlatformMemCopy((void const   *)(sr->RR_SRV.resrec.name.c), (void *)(((sr->SubTypes + i)->resrec.rdata)->u.name.c),
                        (unsigned int )tmp___6);
#line 6698
    (sr->SubTypes + i)->Additional1 = & sr->RR_SRV;
#line 6699
    (sr->SubTypes + i)->Additional2 = & sr->RR_TXT;
#line 6692
    i ++;
  }
#line 6703
  (sr->RR_SRV.resrec.rdata)->u.srv.priority = (unsigned short)0;
#line 6704
  (sr->RR_SRV.resrec.rdata)->u.srv.weight = (unsigned short)0;
#line 6705
  (sr->RR_SRV.resrec.rdata)->u.srv.port = port;
#line 6708
  if (sr->Host.c[0]) {
#line 6708
    tmp___7 = DomainNameLength((domainname const   *)(& sr->Host));
#line 6708
    mDNSPlatformMemCopy((void const   *)(sr->Host.c), (void *)((sr->RR_SRV.resrec.rdata)->u.srv.target.c),
                        (unsigned int )tmp___7);
  } else {
#line 6709
    sr->RR_SRV.HostTarget = (unsigned char)1;
  }
#line 6713
  if ((unsigned int )txtinfo == (unsigned int )((mDNSu8 const   *)0)) {
#line 6713
    sr->RR_TXT.resrec.rdlength = (unsigned short)0;
  } else {
#line 6714
    if ((unsigned int )txtinfo != (unsigned int )((sr->RR_TXT.resrec.rdata)->u.txt.c)) {
#line 6716
      sr->RR_TXT.resrec.rdlength = txtlen;
#line 6717
      if ((int )sr->RR_TXT.resrec.rdlength > (int )(sr->RR_TXT.resrec.rdata)->MaxRDLength) {
#line 6717
        return (-65540);
      }
#line 6718
      mDNSPlatformMemCopy((void const   *)txtinfo, (void *)((sr->RR_TXT.resrec.rdata)->u.txt.c),
                          (unsigned int )txtlen);
    }
  }
#line 6720
  sr->RR_TXT.DependentOn = & sr->RR_SRV;
#line 6722
  mDNS_Lock(m);
#line 6723
  err = mDNS_Register_internal(m, & sr->RR_SRV);
#line 6724
  if (! err) {
#line 6724
    err = mDNS_Register_internal(m, & sr->RR_TXT);
  }
#line 6730
  if (! err) {
#line 6730
    err = mDNS_Register_internal(m, & sr->RR_ADV);
  }
#line 6731
  i = 0U;
#line 6731
  while (i < NumSubTypes) {
#line 6731
    if (! err) {
#line 6731
      err = mDNS_Register_internal(m, sr->SubTypes + i);
    }
#line 6731
    i ++;
  }
#line 6732
  if (! err) {
#line 6732
    err = mDNS_Register_internal(m, & sr->RR_PTR);
  }
#line 6733
  mDNS_Unlock(m);
#line 6735
  if (err) {
#line 6735
    mDNS_DeregisterService(m, sr);
  }
#line 6736
  return (err);
}
}
#line 6739 "mDNS.c"
mStatus mDNS_AddRecordToService(mDNS *m , ServiceRecordSet *sr , ExtraResourceRecord *extra ,
                                RData *rdata , mDNSu32 ttl ) 
{ mStatus result ;
  ExtraResourceRecord **e ;
  mDNSu16 tmp ;

  {
#line 6742
  result = (mStatus )-65537;
#line 6743
  e = & sr->Extras;
#line 6744
  while (*e) {
#line 6744
    e = & (*e)->next;
  }
#line 6747
  if (ttl == 0U) {
#line 6747
    ttl = 240U;
  }
#line 6749
  extra->next = (ExtraResourceRecord *)0L;
#line 6750
  mDNS_SetupResourceRecord(& extra->r, rdata, sr->RR_PTR.resrec.InterfaceID, extra->r.resrec.rrtype,
                           ttl, (unsigned char)2, & ServiceCallback, (void *)sr);
#line 6751
  tmp = DomainNameLength((domainname const   *)(& sr->RR_SRV.resrec.name));
#line 6751
  mDNSPlatformMemCopy((void const   *)(sr->RR_SRV.resrec.name.c), (void *)(extra->r.resrec.name.c),
                      (unsigned int )tmp);
#line 6752
  extra->r.DependentOn = & sr->RR_SRV;
#line 6756
  result = mDNS_Register(m, & extra->r);
#line 6757
  if (! result) {
#line 6757
    *e = extra;
  }
#line 6758
  return (result);
}
}
#line 6761 "mDNS.c"
mStatus mDNS_RemoveRecordFromService(mDNS *m , ServiceRecordSet *sr , ExtraResourceRecord *extra ) 
{ ExtraResourceRecord **e ;
  mStatus tmp ;

  {
#line 6763
  e = & sr->Extras;
#line 6764
  while (1) {
#line 6764
    if (*e) {
#line 6764
      if (! ((unsigned int )*e != (unsigned int )extra)) {
#line 6764
        break;
      }
    } else {
#line 6764
      break;
    }
#line 6764
    e = & (*e)->next;
  }
#line 6765
  if (! *e) {
#line 6768
    return (-65541);
  }
#line 6773
  *e = (*e)->next;
#line 6774
  tmp = mDNS_Deregister(m, & extra->r);
#line 6774
  return (tmp);
}
}
#line 6777 "mDNS.c"
mStatus mDNS_RenameAndReregisterService(mDNS *m , ServiceRecordSet *sr , domainlabel const   *newname ) 
{ domainlabel name ;
  domainname type ;
  domainname domain ;
  domainname *host ;
  ExtraResourceRecord *extras ;
  mStatus err ;
  ExtraResourceRecord *e ;

  {
#line 6781
  host = (domainname *)0L;
#line 6782
  extras = sr->Extras;
#line 6785
  DeconstructServiceName((domainname const   *)(& sr->RR_SRV.resrec.name), & name,
                         & type, & domain);
#line 6786
  if (! newname) {
#line 6788
    IncrementLabelSuffix(& name, 1);
#line 6789
    newname = (domainlabel const   *)(& name);
  }
#line 6792
  if ((int )sr->RR_SRV.HostTarget == 0) {
#line 6792
    if (sr->Host.c[0]) {
#line 6792
      host = & sr->Host;
    }
  }
#line 6794
  err = mDNS_RegisterService(m, sr, newname, (domainname const   *)(& type), (domainname const   *)(& domain),
                             (domainname const   *)host, (sr->RR_SRV.resrec.rdata)->u.srv.port,
                             (mDNSu8 const   *)((sr->RR_TXT.resrec.rdata)->u.txt.c),
                             sr->RR_TXT.resrec.rdlength, sr->SubTypes, sr->NumSubTypes,
                             sr->RR_PTR.resrec.InterfaceID, sr->ServiceCallback, sr->ServiceContext);
#line 6802
  while (1) {
#line 6802
    if (! err) {
#line 6802
      if (! extras) {
#line 6802
        break;
      }
    } else {
#line 6802
      break;
    }
#line 6804
    e = extras;
#line 6805
    extras = extras->next;
#line 6806
    err = mDNS_AddRecordToService(m, sr, e, e->r.resrec.rdata, e->r.resrec.rroriginalttl);
  }
#line 6809
  return (err);
}
}
#line 6815 "mDNS.c"
mStatus mDNS_DeregisterService(mDNS *m , ServiceRecordSet *sr ) 
{ mDNSu32 i ;
  mStatus status ;
  ExtraResourceRecord *e ;

  {
#line 6817
  if ((int )sr->RR_PTR.resrec.RecordType == 0) {
#line 6820
    return (-65541);
  } else {
#line 6822
    if ((int )sr->RR_PTR.resrec.RecordType == 1) {
#line 6825
      return (0);
    } else {
#line 6832
      mDNS_Lock(m);
#line 6833
      e = sr->Extras;
#line 6837
      mDNS_Deregister_internal(m, & sr->RR_SRV, 2);
#line 6838
      mDNS_Deregister_internal(m, & sr->RR_TXT, 2);
#line 6840
      mDNS_Deregister_internal(m, & sr->RR_ADV, 0);
#line 6844
      while (e) {
#line 6846
        mDNS_Deregister_internal(m, & e->r, 2);
#line 6847
        e = e->next;
      }
#line 6850
      i = 0U;
#line 6850
      while (i < sr->NumSubTypes) {
#line 6851
        mDNS_Deregister_internal(m, sr->SubTypes + i, 0);
#line 6850
        i ++;
      }
#line 6858
      status = mDNS_Deregister_internal(m, & sr->RR_PTR, 0);
#line 6859
      mDNS_Unlock(m);
#line 6860
      return (status);
    }
  }
}
}
#line 6870 "mDNS.c"
mStatus mDNS_RegisterNoSuchService(mDNS *m , AuthRecord *rr , domainlabel const   *name ,
                                   domainname const   *type , domainname const   *domain ,
                                   domainname const   *host , mDNSInterfaceID InterfaceID ,
                                   mDNSRecordCallback *Callback , void *Context ) 
{ mDNSu8 *tmp ;
  mDNSu16 tmp___0 ;
  mStatus tmp___1 ;

  {
#line 6875
  mDNS_SetupResourceRecord(rr, (RData *)0L, InterfaceID, (unsigned short)33, 240U,
                           (unsigned char)2, Callback, Context);
#line 6876
  tmp = ConstructServiceName(& rr->resrec.name, name, type, domain);
#line 6876
  if ((unsigned int )tmp == (unsigned int )((mDNSu8 *)0)) {
#line 6876
    return (-65540);
  }
#line 6877
  (rr->resrec.rdata)->u.srv.priority = (unsigned short)0;
#line 6878
  (rr->resrec.rdata)->u.srv.weight = (unsigned short)0;
#line 6879
  (rr->resrec.rdata)->u.srv.port = (union __anonunion_mDNSOpaque16_18 )zeroIPPort;
#line 6880
  if (host) {
#line 6880
    if (host->c[0]) {
#line 6880
      tmp___0 = DomainNameLength(host);
#line 6880
      mDNSPlatformMemCopy((void const   *)(host->c), (void *)((rr->resrec.rdata)->u.srv.target.c),
                          (unsigned int )tmp___0);
    } else {
#line 6881
      rr->HostTarget = (unsigned char)1;
    }
  } else {
#line 6881
    rr->HostTarget = (unsigned char)1;
  }
#line 6882
  tmp___1 = mDNS_Register(m, rr);
#line 6882
  return (tmp___1);
}
}
#line 6885 "mDNS.c"
mStatus mDNS_AdvertiseDomains(mDNS *m , AuthRecord *rr , mDNS_DomainType DomainType ,
                              mDNSInterfaceID InterfaceID , char *domname ) 
{ mDNSu8 *tmp ;
  mDNSu8 *tmp___0 ;
  mStatus tmp___1 ;

  {
#line 6888
  mDNS_SetupResourceRecord(rr, (RData *)0L, InterfaceID, (unsigned short)12, 7200U,
                           (unsigned char)8, (mDNSRecordCallback *)0L, (void *)0L);
#line 6889
  tmp = MakeDomainNameFromDNSNameString(& rr->resrec.name, (char const   *)mDNS_DomainTypeNames[DomainType]);
#line 6889
  if (! tmp) {
#line 6889
    return (-65540);
  }
#line 6890
  tmp___0 = MakeDomainNameFromDNSNameString(& (rr->resrec.rdata)->u.name, (char const   *)domname);
#line 6890
  if (! tmp___0) {
#line 6890
    return (-65540);
  }
#line 6891
  tmp___1 = mDNS_Register(m, rr);
#line 6891
  return (tmp___1);
}
}
#line 6901 "mDNS.c"
void mDNS_GrowCache(mDNS *m , CacheRecord *storage , mDNSu32 numrecords ) 
{ mDNSu32 i ;

  {
#line 6903
  if (storage) {
#line 6903
    if (numrecords) {
#line 6906
      i = 0U;
#line 6906
      while (i < numrecords) {
#line 6906
        (storage + i)->next = storage + (i + 1U);
#line 6906
        i ++;
      }
#line 6907
      (storage + (numrecords - 1U))->next = m->rrcache_free;
#line 6908
      m->rrcache_free = storage;
#line 6909
      m->rrcache_size += numrecords;
    }
  }
#line 6911
  return;
}
}
#line 6913 "mDNS.c"
mStatus mDNS_Init(mDNS *m , mDNS_PlatformSupport *p , CacheRecord *rrcachestorage ,
                  mDNSu32 rrcachesize , mDNSBool AdvertiseLocalAddresses , mDNSCallback *Callback ,
                  void *Context ) 
{ mDNSu32 slot ;
  mDNSs32 timenow ;
  mStatus result ;
  mStatus tmp ;

  {
#line 6919
  tmp = mDNSPlatformTimeInit(& timenow);
#line 6919
  result = tmp;
#line 6920
  if (result != 0) {
#line 6920
    return (result);
  }
#line 6922
  if (! rrcachestorage) {
#line 6922
    rrcachesize = 0U;
  }
#line 6924
  m->p = p;
#line 6925
  m->KnownBugs = 0U;
#line 6926
  m->AdvertiseLocalAddresses = AdvertiseLocalAddresses;
#line 6927
  m->mDNSPlatformStatus = 1;
#line 6928
  m->MainCallback = Callback;
#line 6929
  m->MainContext = Context;
#line 6932
  m->mDNS_busy = 0U;
#line 6933
  m->mDNS_reentrancy = 0U;
#line 6934
  m->mDNS_shutdown = (unsigned char)0;
#line 6935
  m->lock_rrcache = (unsigned char)0;
#line 6936
  m->lock_Questions = (unsigned char)0;
#line 6937
  m->lock_Records = (unsigned char)0;
#line 6940
  m->timenow = 0;
#line 6941
  m->timenow_last = timenow;
#line 6942
  m->timenow_adjust = 0;
#line 6943
  m->NextScheduledEvent = timenow;
#line 6944
  m->SuppressSending = timenow;
#line 6945
  m->NextCacheCheck = timenow + 2013265920;
#line 6946
  m->NextScheduledQuery = timenow + 2013265920;
#line 6947
  m->NextScheduledProbe = timenow + 2013265920;
#line 6948
  m->NextScheduledResponse = timenow + 2013265920;
#line 6949
  m->ExpectUnicastResponse = timenow + 2013265920;
#line 6950
  m->RandomQueryDelay = 0;
#line 6951
  m->SendDeregistrations = 0;
#line 6952
  m->SendImmediateAnswers = 0;
#line 6953
  m->SleepState = 0;
#line 6956
  m->Questions = (DNSQuestion *)0L;
#line 6957
  m->NewQuestions = (DNSQuestion *)0L;
#line 6958
  m->CurrentQuestion = (DNSQuestion *)0L;
#line 6959
  m->LocalOnlyQuestions = (DNSQuestion *)0L;
#line 6960
  m->NewLocalOnlyQuestions = (DNSQuestion *)0L;
#line 6961
  m->rrcache_size = 0U;
#line 6962
  m->rrcache_totalused = 0U;
#line 6963
  m->rrcache_active = 0U;
#line 6964
  m->rrcache_report = 10U;
#line 6965
  m->rrcache_free = (CacheRecord *)0L;
#line 6967
  slot = 0U;
#line 6967
  while (slot < 499U) {
#line 6969
    m->rrcache_hash[slot] = (CacheRecord *)0L;
#line 6970
    m->rrcache_tail[slot] = & m->rrcache_hash[slot];
#line 6971
    m->rrcache_used[slot] = 0U;
#line 6967
    slot ++;
  }
#line 6974
  mDNS_GrowCache(m, rrcachestorage, rrcachesize);
#line 6977
  m->hostlabel.c[0] = (unsigned char)0;
#line 6978
  m->nicelabel.c[0] = (unsigned char)0;
#line 6979
  m->hostname.c[0] = (unsigned char)0;
#line 6980
  m->HIHardware.c[0] = (unsigned char)0;
#line 6981
  m->HISoftware.c[0] = (unsigned char)0;
#line 6982
  m->ResourceRecords = (AuthRecord *)0L;
#line 6983
  m->DuplicateRecords = (AuthRecord *)0L;
#line 6984
  m->LocalOnlyRecords = (AuthRecord *)0L;
#line 6985
  m->NewLocalOnlyRecords = (AuthRecord *)0L;
#line 6986
  m->DiscardLocalOnlyRecords = 0;
#line 6987
  m->CurrentRecord = (AuthRecord *)0L;
#line 6988
  m->HostInterfaces = (NetworkInterfaceInfo *)0L;
#line 6989
  m->ProbeFailTime = 0;
#line 6990
  m->NumFailedProbes = 0;
#line 6991
  m->SuppressProbes = 0;
#line 6993
  result = mDNSPlatformInit(m);
#line 6995
  return (result);
}
}
#line 6998 "mDNS.c"
void mDNSCoreInitComplete(mDNS *m , mStatus result ) 
{ 

  {
#line 7000
  m->mDNSPlatformStatus = result;
#line 7001
  if (m->MainCallback) {
#line 7002
    (*(m->MainCallback))(m, 0);
  }
#line 7003
  return;
}
}
#line 7005 "mDNS.c"
void mDNS_Close(mDNS *m ) 
{ mDNSu32 rrcache_active ;
  mDNSu32 rrcache_totalused ;
  mDNSu32 slot ;
  NetworkInterfaceInfo *intf ;
  CacheRecord *rr ;
  AuthRecord *rr___0 ;

  {
#line 7007
  rrcache_active = (mDNSu32 )0;
#line 7008
  rrcache_totalused = (mDNSu32 )0;
#line 7011
  mDNS_Lock(m);
#line 7013
  m->mDNS_shutdown = (unsigned char)1;
#line 7015
  rrcache_totalused = m->rrcache_totalused;
#line 7016
  slot = 0U;
#line 7016
  while (slot < 499U) {
#line 7018
    while (m->rrcache_hash[slot]) {
#line 7020
      rr = m->rrcache_hash[slot];
#line 7021
      m->rrcache_hash[slot] = rr->next;
#line 7022
      if (rr->CRActiveQuestion) {
#line 7022
        rrcache_active ++;
      }
#line 7023
      (m->rrcache_used[slot]) --;
#line 7024
      ReleaseCacheRR(m, rr);
    }
#line 7027
    m->rrcache_tail[slot] = & m->rrcache_hash[slot];
#line 7016
    slot ++;
  }
#line 7030
  if (rrcache_active != m->rrcache_active) {
#line 7031
    LogMsg("*** ERROR *** rrcache_active %lu != m->rrcache_active %lu", rrcache_active,
           m->rrcache_active);
  }
#line 7033
  m->Questions = (DNSQuestion *)0L;
#line 7035
  intf = m->HostInterfaces;
#line 7035
  while (intf) {
#line 7036
    if (intf->Advertise) {
#line 7037
      mDNS_DeadvertiseInterface(m, intf);
    }
#line 7035
    intf = intf->next;
  }
#line 7040
  if (m->CurrentRecord) {
#line 7040
    LogMsg("mDNS_Close ERROR m->CurrentRecord already set");
  }
#line 7041
  m->CurrentRecord = m->ResourceRecords;
#line 7042
  while (m->CurrentRecord) {
#line 7044
    rr___0 = m->CurrentRecord;
#line 7045
    m->CurrentRecord = rr___0->next;
#line 7046
    if ((int )rr___0->resrec.RecordType != 1) {
#line 7049
      mDNS_Deregister_internal(m, rr___0, 0);
    }
  }
#line 7053
  if (m->ResourceRecords) {

  }
#line 7057
  if (m->mDNSPlatformStatus != 0) {
#line 7058
    DiscardDeregistrations(m);
  } else {
#line 7060
    while (m->ResourceRecords) {
#line 7061
      SendResponses(m);
    }
  }
#line 7063
  mDNS_Unlock(m);
#line 7065
  mDNSPlatformClose(m);
#line 7067
  return;
}
}
#line 1 "mDNSPosix.o"
#pragma merger(0,"/tmp/cil-gWVVOuzY.i","-g,-g,-O2")
#line 1397 "mDNSClientAPI.h"
void mDNSPlatformStrCopy(void const   *src , void *dst ) ;
#line 1398
mDNSu32 mDNSPlatformStrLen(void const   *src ) ;
#line 74 "mDNSPosix.h"
int gMDNSPlatformPosixVerboseLevel ;
#line 82
extern mStatus mDNSPlatformPosixRefreshInterfaceList(mDNS *m ) ;
#line 91
void mDNSPosixGetFDSet(mDNS *m , int *nfds , fd_set *readfds , struct timeval *timeout ) ;
#line 92
void mDNSPosixProcessFDSet(mDNS *m , fd_set *readfds ) ;
#line 745 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 843 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 150 "/usr/include/sys/socket.h"
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 194 "/usr/include/net/if.h"
extern  __attribute__((__nothrow__)) unsigned int if_nametoindex(char const   *__ifname ) ;
#line 101 "mDNSUNP.h"
ssize_t recvfrom_flags(int fd , void *ptr , size_t nbytes , int *flagsp , struct sockaddr *sa ,
                       socklen_t *salenptr , struct my_in_pktinfo *pktp ) ;
#line 119
struct ifi_info *get_ifi_info(int family , int doaliases ) ;
#line 120
void free_ifi_info(struct ifi_info *ifihead ) ;
#line 170 "mDNSPosix.c"
static int num_registered_interfaces  =    0;
#line 171 "mDNSPosix.c"
static int num_pkts_accepted  =    0;
#line 172 "mDNSPosix.c"
static int num_pkts_rejected  =    0;
#line 177 "mDNSPosix.c"
int gMDNSPlatformPosixVerboseLevel  =    0;
#line 181 "mDNSPosix.c"
void debugf_(char const   *format  , ...) 
{ unsigned char buffer___0[512] ;
  va_list ptr ;
  mDNSu32 tmp ;

  {
#line 185
  __builtin_va_start(ptr, format);
#line 186
  tmp = mDNS_vsnprintf((char *)(buffer___0), sizeof(buffer___0), format, ptr);
#line 186
  buffer___0[tmp] = (unsigned char)0;
#line 187
  __builtin_va_end(ptr);
#line 189
  err_log(5, 2048U, (char *)"%s\n", buffer___0);
#line 190
  return;
}
}
#line 192 "mDNSPosix.c"
void verbosedebugf_(char const   *format  , ...) 
{ unsigned char buffer___0[512] ;
  va_list ptr ;
  mDNSu32 tmp ;

  {
#line 196
  __builtin_va_start(ptr, format);
#line 197
  tmp = mDNS_vsnprintf((char *)(buffer___0), sizeof(buffer___0), format, ptr);
#line 197
  buffer___0[tmp] = (unsigned char)0;
#line 198
  __builtin_va_end(ptr);
#line 199
  err_log(9, 2048U, (char *)"%s\n", buffer___0);
#line 200
  return;
}
}
#line 202 "mDNSPosix.c"
void LogMsg(char const   *format  , ...) 
{ unsigned char buffer___0[512] ;
  va_list ptr ;
  mDNSu32 tmp ;

  {
#line 206
  __builtin_va_start(ptr, format);
#line 207
  tmp = mDNS_vsnprintf((char *)(buffer___0), sizeof(buffer___0), format, ptr);
#line 207
  buffer___0[tmp] = (unsigned char)0;
#line 208
  __builtin_va_end(ptr);
#line 209
  err_log(2, 2048U, (char *)"%s\n", buffer___0);
#line 210
  return;
}
}
#line 214 "mDNSPosix.c"
static void SockAddrTomDNSAddr(struct sockaddr  const  *sa , mDNSAddr *ipAddr , mDNSIPPort *ipPort ) 
{ struct sockaddr_in *sin ;

  {
#line 216
  switch ((int )sa->sa_family) {
  case 2: 
#line 220
  sin = (struct sockaddr_in *)sa;
#line 221
  ipAddr->type = 4;
#line 222
  ipAddr->ip.v4.NotAnInteger = sin->sin_addr.s_addr;
#line 223
  if (ipPort) {
#line 223
    ipPort->NotAnInteger = sin->sin_port;
  }
#line 224
  break;
  default: 
#line 241
  ipAddr->type = 0;
#line 242
  if (ipPort) {
#line 242
    ipPort->NotAnInteger = (unsigned short)0;
  }
#line 243
  break;
  }
#line 245
  return;
}
}
#line 252 "mDNSPosix.c"
mStatus mDNSPlatformSendUDP(mDNS const   *m , DNSMessage const   *msg , mDNSu8 const   *end ,
                            mDNSInterfaceID InterfaceID , mDNSIPPort srcPort , mDNSAddr const   *dst ,
                            mDNSIPPort dstPort ) 
{ int err ;
  struct sockaddr to ;
  PosixNetworkInterface *thisIntf ;
  struct sockaddr_in *sin ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 259
  if (! ((unsigned int )m != (unsigned int )((void *)0))) {
#line 259
    __assert_fail("m != ((void *)0)", "mDNSPosix.c", 259U, "mDNSPlatformSendUDP");
  }
#line 260
  if (! ((unsigned int )msg != (unsigned int )((void *)0))) {
#line 260
    __assert_fail("msg != ((void *)0)", "mDNSPosix.c", 260U, "mDNSPlatformSendUDP");
  }
#line 261
  if (! ((unsigned int )end != (unsigned int )((void *)0))) {
#line 261
    __assert_fail("end != ((void *)0)", "mDNSPosix.c", 261U, "mDNSPlatformSendUDP");
  }
#line 262
  if (! ((char *)end - (char *)msg > 0)) {
#line 262
    __assert_fail("(((char *) end) - ((char *) msg)) > 0", "mDNSPosix.c", 262U, "mDNSPlatformSendUDP");
  }
#line 263
  if (! ((unsigned int )InterfaceID != (unsigned int )((mDNSInterfaceID )0))) {
#line 263
    __assert_fail("InterfaceID != 0", "mDNSPosix.c", 263U, "mDNSPlatformSendUDP");
  }
#line 264
  if (! ((int )srcPort.NotAnInteger != 0)) {
#line 264
    __assert_fail("srcPort.NotAnInteger != 0", "mDNSPosix.c", 264U, "mDNSPlatformSendUDP");
  }
#line 265
  if (! ((int )dstPort.NotAnInteger != 0)) {
#line 265
    __assert_fail("dstPort.NotAnInteger != 0", "mDNSPosix.c", 265U, "mDNSPlatformSendUDP");
  }
#line 267
  if (dst->type == 4) {
#line 269
    sin = (struct sockaddr_in *)(& to);
#line 273
    sin->sin_family = (unsigned short)2;
#line 274
    sin->sin_port = dstPort.NotAnInteger;
#line 275
    sin->sin_addr.s_addr = (unsigned int )dst->ip.v4.NotAnInteger;
  }
#line 290
  err = 0;
#line 291
  thisIntf = (PosixNetworkInterface *)InterfaceID;
#line 292
  if (dst->type == 4) {
#line 293
    if ((int )to.sa_family == 2) {
#line 293
      tmp = sizeof(struct sockaddr_in );
    } else {
#line 293
      tmp = sizeof(struct sockaddr );
    }
#line 293
    err = sendto(thisIntf->multicastSocket, (void const   *)msg, (unsigned int )((char *)end - (char *)msg),
                 0, (struct sockaddr  const  *)(& to), tmp);
  }
#line 300
  if (err > 0) {
#line 300
    err = 0;
  } else {
#line 301
    if (err < 0) {

    }
  }
#line 305
  if (err == 0) {
#line 305
    tmp___0 = 0;
  } else {
#line 305
    tmp___0 = -65537;
  }
#line 305
  return (tmp___0);
}
}
#line 309 "mDNSPosix.c"
static void SocketDataReady(mDNS *m , PosixNetworkInterface *intf , int skt ) 
{ mDNSAddr senderAddr ;
  mDNSAddr destAddr ;
  mDNSIPPort senderPort ;
  ssize_t packetLen ;
  DNSMessage packet ;
  struct my_in_pktinfo packetInfo ;
  struct sockaddr from ;
  socklen_t fromLen ;
  int flags ;
  mDNSBool reject ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 321
  if (! ((unsigned int )m != (unsigned int )((void *)0))) {
#line 321
    __assert_fail("m != ((void *)0)", "mDNSPosix.c", 321U, "SocketDataReady");
  }
#line 322
  if (! ((unsigned int )intf != (unsigned int )((void *)0))) {
#line 322
    __assert_fail("intf != ((void *)0)", "mDNSPosix.c", 322U, "SocketDataReady");
  }
#line 323
  if (! (skt >= 0)) {
#line 323
    __assert_fail("skt >= 0", "mDNSPosix.c", 323U, "SocketDataReady");
  }
#line 325
  fromLen = sizeof(from);
#line 326
  flags = 0;
#line 327
  packetLen = recvfrom_flags(skt, (void *)(& packet), sizeof(packet), & flags, & from,
                             & fromLen, & packetInfo);
#line 329
  if (packetLen >= 0) {
#line 331
    SockAddrTomDNSAddr((struct sockaddr  const  *)(& from), & senderAddr, & senderPort);
#line 332
    SockAddrTomDNSAddr((struct sockaddr  const  *)(& packetInfo.ipi_addr), & destAddr,
                       (mDNSIPPort *)((void *)0));
#line 366
    reject = 0;
#line 367
    if ((int )packetInfo.ipi_ifname[0] != 0) {
#line 367
      if (0) {
#line 367
        __s1_len = strlen((char const   *)(packetInfo.ipi_ifname));
#line 367
        __s2_len = strlen(intf->intfName);
#line 367
        if (! ((unsigned int )((void const   *)(packetInfo.ipi_ifname + 1)) - (unsigned int )((void const   *)(packetInfo.ipi_ifname)) == 1U)) {
          goto _L___0;
        } else {
#line 367
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 367
            if (! ((unsigned int )((void const   *)(intf->intfName + 1)) - (unsigned int )((void const   *)intf->intfName) == 1U)) {
#line 367
              tmp___5 = 1;
            } else {
#line 367
              if (__s2_len >= 4U) {
#line 367
                tmp___5 = 1;
              } else {
#line 367
                tmp___5 = 0;
              }
            }
          } else {
#line 367
            tmp___5 = 0;
          }
        }
#line 367
        if (tmp___5) {
#line 367
          tmp___0 = __builtin_strcmp((char const   *)(packetInfo.ipi_ifname), intf->intfName);
#line 367
          tmp___4 = tmp___0;
        } else {
#line 367
          tmp___3 = __builtin_strcmp((char const   *)(packetInfo.ipi_ifname), intf->intfName);
#line 367
          tmp___4 = tmp___3;
        }
      } else {
#line 367
        tmp___3 = __builtin_strcmp((char const   *)(packetInfo.ipi_ifname), intf->intfName);
#line 367
        tmp___4 = tmp___3;
      }
#line 367
      reject = tmp___4 != 0;
    } else {
#line 368
      if (packetInfo.ipi_ifindex != -1) {
#line 368
        reject = packetInfo.ipi_ifindex != intf->index;
      }
    }
#line 370
    if (reject) {
#line 375
      packetLen = -1;
#line 376
      num_pkts_rejected ++;
#line 377
      if (num_pkts_rejected > ((num_pkts_accepted + 1) * (num_registered_interfaces + 1)) * 2) {
#line 379
        err_log(1, 2048U, (char *)"*** WARNING: Received %d packets; Accepted %d packets; Rejected %d packets because of interface mismatch\n",
                num_pkts_accepted + num_pkts_rejected, num_pkts_accepted, num_pkts_rejected);
#line 382
        num_pkts_accepted = 0;
#line 383
        num_pkts_rejected = 0;
      }
    } else {
#line 390
      num_pkts_accepted ++;
    }
  }
#line 394
  if (packetLen >= 0) {
#line 394
    if (packetLen < (int )sizeof(DNSMessageHeader )) {
#line 397
      packetLen = -1;
    }
  }
#line 400
  if (packetLen >= 0) {
#line 401
    mDNSCoreReceive(m, & packet, (mDNSu8 const   *)((mDNSu8 *)(& packet) + packetLen),
                    (mDNSAddr const   *)(& senderAddr), senderPort, (mDNSAddr const   *)(& destAddr),
                    (union __anonunion_mDNSOpaque16_18 )MulticastDNSPort, intf->coreIntf.InterfaceID,
                    (unsigned char)255);
  }
#line 403
  return;
}
}
#line 412 "mDNSPosix.c"
static void GetUserSpecifiedFriendlyComputerName(domainlabel *namelabel ) 
{ 

  {
#line 414
  MakeDomainLabelFromLiteralString(namelabel, "Fill in Default Service Name Here");
#line 415
  return;
}
}
#line 418 "mDNSPosix.c"
static void GetUserSpecifiedRFC1034ComputerName(domainlabel *namelabel ) 
{ int len ;

  {
#line 420
  len = 0;
#line 421
  gethostname((char *)(& namelabel->c[1]), 63U);
#line 422
  while (1) {
#line 422
    if (len < 63) {
#line 422
      if (namelabel->c[len + 1]) {
#line 422
        if (! ((int )namelabel->c[len + 1] != 46)) {
#line 422
          break;
        }
      } else {
#line 422
        break;
      }
    } else {
#line 422
      break;
    }
#line 422
    len ++;
  }
#line 423
  namelabel->c[0] = (unsigned char )len;
#line 424
  return;
}
}
#line 428 "mDNSPosix.c"
static PosixNetworkInterface *SearchForInterfaceByName(mDNS *m , char const   *intfName ) 
{ PosixNetworkInterface *intf ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 432
  if (! ((unsigned int )m != (unsigned int )((void *)0))) {
#line 432
    __assert_fail("m != ((void *)0)", "mDNSPosix.c", 432U, "SearchForInterfaceByName");
  }
#line 433
  if (! ((unsigned int )intfName != (unsigned int )((void *)0))) {
#line 433
    __assert_fail("intfName != ((void *)0)", "mDNSPosix.c", 433U, "SearchForInterfaceByName");
  }
#line 435
  intf = (PosixNetworkInterface *)m->HostInterfaces;
#line 436
  while (1) {
#line 436
    if ((unsigned int )intf != (unsigned int )((void *)0)) {
#line 436
      if (0) {
#line 436
        __s1_len = strlen(intf->intfName);
#line 436
        __s2_len = strlen(intfName);
#line 436
        if (! ((unsigned int )((void const   *)(intf->intfName + 1)) - (unsigned int )((void const   *)intf->intfName) == 1U)) {
          goto _L___0;
        } else {
#line 436
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 436
            if (! ((unsigned int )((void const   *)(intfName + 1)) - (unsigned int )((void const   *)intfName) == 1U)) {
#line 436
              tmp___5 = 1;
            } else {
#line 436
              if (__s2_len >= 4U) {
#line 436
                tmp___5 = 1;
              } else {
#line 436
                tmp___5 = 0;
              }
            }
          } else {
#line 436
            tmp___5 = 0;
          }
        }
#line 436
        if (tmp___5) {
#line 436
          tmp___0 = __builtin_strcmp(intf->intfName, intfName);
#line 436
          tmp___4 = tmp___0;
        } else {
#line 436
          tmp___3 = __builtin_strcmp(intf->intfName, intfName);
#line 436
          tmp___4 = tmp___3;
        }
      } else {
#line 436
        tmp___3 = __builtin_strcmp(intf->intfName, intfName);
#line 436
        tmp___4 = tmp___3;
      }
#line 436
      if (! (tmp___4 != 0)) {
#line 436
        break;
      }
    } else {
#line 436
      break;
    }
#line 437
    intf = (PosixNetworkInterface *)intf->coreIntf.next;
  }
#line 439
  return (intf);
}
}
#line 444 "mDNSPosix.c"
static void FreePosixNetworkInterface(PosixNetworkInterface *intf ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 446
  if (! ((unsigned int )intf != (unsigned int )((void *)0))) {
#line 446
    __assert_fail("intf != ((void *)0)", "mDNSPosix.c", 446U, "FreePosixNetworkInterface");
  }
#line 447
  if ((unsigned int )intf->intfName != (unsigned int )((void *)0)) {
#line 447
    free((void *)intf->intfName);
  }
#line 448
  if (intf->multicastSocket != -1) {
#line 448
    tmp = close(intf->multicastSocket);
#line 448
    if (! (tmp == 0)) {
#line 448
      __assert_fail("close(intf->multicastSocket) == 0", "mDNSPosix.c", 448U, "FreePosixNetworkInterface");
    }
  }
#line 449
  if (intf->multicastSocketv6 != -1) {
#line 449
    tmp___0 = close(intf->multicastSocketv6);
#line 449
    if (! (tmp___0 == 0)) {
#line 449
      __assert_fail("close(intf->multicastSocketv6) == 0", "mDNSPosix.c", 449U, "FreePosixNetworkInterface");
    }
  }
#line 450
  free((void *)intf);
#line 451
  return;
}
}
#line 454 "mDNSPosix.c"
static void ClearInterfaceList(mDNS *m ) 
{ PosixNetworkInterface *intf ;

  {
#line 456
  if (! ((unsigned int )m != (unsigned int )((void *)0))) {
#line 456
    __assert_fail("m != ((void *)0)", "mDNSPosix.c", 456U, "ClearInterfaceList");
  }
#line 458
  while (m->HostInterfaces) {
#line 460
    intf = (PosixNetworkInterface *)m->HostInterfaces;
#line 461
    mDNS_DeregisterInterface(m, & intf->coreIntf);
#line 462
    if (gMDNSPlatformPosixVerboseLevel > 0) {
#line 462
      err_log(1, 2048U, (char *)"Deregistered interface %s\n", intf->intfName);
    }
#line 463
    FreePosixNetworkInterface(intf);
  }
#line 465
  num_registered_interfaces = 0;
#line 466
  num_pkts_accepted = 0;
#line 467
  num_pkts_rejected = 0;
#line 468
  return;
}
}
#line 475
static int SetupSocket(struct sockaddr *intfAddr , mDNSIPPort port , int interfaceIndex ,
                       int *sktPtr ) ;
#line 475 "mDNSPosix.c"
static int const   kOn  =    (int const   )1;
#line 476 "mDNSPosix.c"
static int const   kIntTwoFiveFive  =    (int const   )255;
#line 477 "mDNSPosix.c"
static unsigned char const   kByteTwoFiveFive  =    (unsigned char const   )255;
#line 472 "mDNSPosix.c"
static int SetupSocket(struct sockaddr *intfAddr , mDNSIPPort port , int interfaceIndex ,
                       int *sktPtr ) 
{ int err ;
  int *tmp ;
  int *tmp___0 ;
  struct ip_mreq imr ;
  struct sockaddr_in bindAddr ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;

  {
#line 474
  err = 0;
#line 480
  if (! ((unsigned int )intfAddr != (unsigned int )((void *)0))) {
#line 480
    __assert_fail("intfAddr != ((void *)0)", "mDNSPosix.c", 480U, "SetupSocket");
  }
#line 481
  if (! ((unsigned int )sktPtr != (unsigned int )((void *)0))) {
#line 481
    __assert_fail("sktPtr != ((void *)0)", "mDNSPosix.c", 481U, "SetupSocket");
  }
#line 482
  if (! (*sktPtr == -1)) {
#line 482
    __assert_fail("*sktPtr == -1", "mDNSPosix.c", 482U, "SetupSocket");
  }
#line 485
  if ((int )intfAddr->sa_family == 2) {
#line 485
    *sktPtr = socket(2, 2, 17);
  } else {
#line 489
    return (22);
  }
#line 491
  if (*sktPtr < 0) {
#line 491
    tmp = __errno_location();
#line 491
    err = *tmp;
#line 491
    perror("socket");
  }
#line 494
  if (err == 0) {
#line 499
    err = setsockopt(*sktPtr, 1, 2, (void const   *)(& kOn), sizeof(kOn));
#line 503
    if (err < 0) {
#line 503
      tmp___0 = __errno_location();
#line 503
      err = *tmp___0;
#line 503
      perror("setsockopt - SO_REUSExxxx");
    }
  }
#line 507
  if ((int )intfAddr->sa_family == 2) {
#line 511
    if (err == 0) {
#line 514
      err = setsockopt(*sktPtr, 0, 8, (void const   *)(& kOn), sizeof(kOn));
#line 515
      if (err < 0) {
#line 515
        tmp___1 = __errno_location();
#line 515
        err = *tmp___1;
#line 515
        perror("setsockopt - IP_PKTINFO");
      }
    }
#line 534
    if (err == 0) {
#line 536
      imr.imr_multiaddr.s_addr = (unsigned int )AllDNSLinkGroup.NotAnInteger;
#line 537
      imr.imr_interface = ((struct sockaddr_in *)intfAddr)->sin_addr;
#line 538
      err = setsockopt(*sktPtr, 0, 35, (void const   *)(& imr), sizeof(imr));
#line 539
      if (err < 0) {
#line 539
        tmp___2 = __errno_location();
#line 539
        err = *tmp___2;
#line 539
        perror("setsockopt - IP_ADD_MEMBERSHIP");
      }
    }
#line 543
    if (err == 0) {
#line 545
      err = setsockopt(*sktPtr, 0, 32, (void const   *)(& ((struct sockaddr_in *)intfAddr)->sin_addr),
                       sizeof(struct in_addr ));
#line 546
      if (err < 0) {
#line 546
        tmp___3 = __errno_location();
#line 546
        err = *tmp___3;
#line 546
        perror("setsockopt - IP_MULTICAST_IF");
      }
    }
#line 550
    if (err == 0) {
#line 552
      err = setsockopt(*sktPtr, 0, 2, (void const   *)(& kIntTwoFiveFive), sizeof(kIntTwoFiveFive));
#line 553
      if (err < 0) {
#line 553
        tmp___4 = __errno_location();
#line 553
        err = *tmp___4;
#line 553
        perror("setsockopt - IP_TTL");
      }
    }
#line 558
    if (err == 0) {
#line 560
      err = setsockopt(*sktPtr, 0, 33, (void const   *)(& kByteTwoFiveFive), sizeof(kByteTwoFiveFive));
#line 561
      if (err < 0) {
#line 561
        tmp___5 = __errno_location();
#line 561
        if (*tmp___5 == 22) {
#line 562
          err = setsockopt(*sktPtr, 0, 33, (void const   *)(& kIntTwoFiveFive), sizeof(kIntTwoFiveFive));
        }
      }
#line 563
      if (err < 0) {
#line 563
        tmp___6 = __errno_location();
#line 563
        err = *tmp___6;
#line 563
        perror("setsockopt - IP_MULTICAST_TTL");
      }
    }
#line 567
    if (err == 0) {
#line 569
      bindAddr.sin_family = (unsigned short)2;
#line 570
      bindAddr.sin_port = port.NotAnInteger;
#line 571
      bindAddr.sin_addr.s_addr = 0U;
#line 572
      err = bind(*sktPtr, (struct sockaddr  const  *)((struct sockaddr *)(& bindAddr)),
                 sizeof(bindAddr));
#line 573
      if (err < 0) {
#line 574
        tmp___7 = __errno_location();
#line 574
        err = *tmp___7;
#line 575
        tmp___8 = __errno_location();
#line 575
        tmp___9 = strerror(*tmp___8);
#line 575
        err_log(1, 2048U, (char *)"bind: %s\n", tmp___9);
      }
    }
  }
#line 659
  if (err == 0) {
#line 661
    err = fcntl(*sktPtr, 3, 0);
#line 662
    if (err < 0) {
#line 662
      tmp___10 = __errno_location();
#line 662
      err = *tmp___10;
    } else {
#line 665
      err = fcntl(*sktPtr, 4, err | 2048);
#line 666
      if (err < 0) {
#line 666
        tmp___11 = __errno_location();
#line 666
        err = *tmp___11;
      }
    }
  }
#line 671
  if (err != 0) {
#line 671
    if (*sktPtr != -1) {
#line 671
      tmp___12 = close(*sktPtr);
#line 671
      if (! (tmp___12 == 0)) {
#line 671
        __assert_fail("close(*sktPtr) == 0", "mDNSPosix.c", 671U, "SetupSocket");
      }
#line 671
      *sktPtr = -1;
    }
  }
#line 672
  if (! ((err == 0) == (*sktPtr != -1))) {
#line 672
    __assert_fail("(err == 0) == (*sktPtr != -1)", "mDNSPosix.c", 672U, "SetupSocket");
  }
#line 673
  return (err);
}
}
#line 678 "mDNSPosix.c"
static int SetupOneInterface(mDNS *m , struct sockaddr *intfAddr , char const   *intfName ) 
{ int err ;
  PosixNetworkInterface *intf ;
  PosixNetworkInterface *alias ;
  void *tmp ;
  char *tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 680
  err = 0;
#line 682
  alias = (PosixNetworkInterface *)((void *)0);
#line 684
  if (! ((unsigned int )m != (unsigned int )((void *)0))) {
#line 684
    __assert_fail("m != ((void *)0)", "mDNSPosix.c", 684U, "SetupOneInterface");
  }
#line 685
  if (! ((unsigned int )intfAddr != (unsigned int )((void *)0))) {
#line 685
    __assert_fail("intfAddr != ((void *)0)", "mDNSPosix.c", 685U, "SetupOneInterface");
  }
#line 686
  if (! ((unsigned int )intfName != (unsigned int )((void *)0))) {
#line 686
    __assert_fail("intfName != ((void *)0)", "mDNSPosix.c", 686U, "SetupOneInterface");
  }
#line 689
  tmp = malloc(sizeof(*intf));
#line 689
  intf = (PosixNetworkInterface *)tmp;
#line 690
  if ((unsigned int )intf == (unsigned int )((void *)0)) {
#line 690
    __assert_fail("0", "mDNSPosix.c", 690U, "SetupOneInterface");
#line 690
    err = 12;
  }
#line 693
  if (err == 0) {
#line 695
    tmp___5 = __strdup(intfName);
#line 695
    intf->intfName = (char const   *)tmp___5;
#line 696
    if ((unsigned int )intf->intfName == (unsigned int )((void *)0)) {
#line 696
      __assert_fail("0", "mDNSPosix.c", 696U, "SetupOneInterface");
#line 696
      err = 12;
    }
  }
#line 699
  if (err == 0) {
#line 702
    SockAddrTomDNSAddr((struct sockaddr  const  *)intfAddr, & intf->coreIntf.ip, (mDNSIPPort *)((void *)0));
#line 703
    intf->coreIntf.Advertise = m->AdvertiseLocalAddresses;
#line 704
    intf->coreIntf.TxAndRx = 1;
#line 707
    if (! ((unsigned int )intf->intfName != (unsigned int )((void *)0))) {
#line 707
      __assert_fail("intf->intfName != ((void *)0)", "mDNSPosix.c", 707U, "SetupOneInterface");
    }
#line 708
    tmp___6 = if_nametoindex(intf->intfName);
#line 708
    intf->index = (int )tmp___6;
#line 709
    intf->multicastSocket = -1;
#line 710
    intf->multicastSocketv6 = -1;
#line 711
    alias = SearchForInterfaceByName(m, intf->intfName);
#line 712
    if ((unsigned int )alias == (unsigned int )((void *)0)) {
#line 712
      alias = intf;
    }
#line 713
    intf->coreIntf.InterfaceID = (struct mDNSInterfaceID_dummystruct *)alias;
#line 715
    if ((unsigned int )alias != (unsigned int )intf) {

    }
  }
#line 720
  if (err == 0) {
#line 722
    if (alias->multicastSocket == -1) {
#line 722
      if ((int )intfAddr->sa_family == 2) {
#line 723
        err = SetupSocket(intfAddr, (union __anonunion_mDNSOpaque16_18 )MulticastDNSPort,
                          intf->index, & alias->multicastSocket);
      }
    }
  }
#line 731
  if (err == 0) {
#line 732
    err = mDNS_RegisterInterface(m, & intf->coreIntf);
  }
#line 735
  if (err == 0) {
#line 737
    num_registered_interfaces ++;
#line 739
    if (gMDNSPlatformPosixVerboseLevel > 0) {
#line 740
      err_log(1, 2048U, (char *)"Registered interface %s\n", intf->intfName);
    }
  } else {
#line 746
    if (intf) {
#line 746
      FreePosixNetworkInterface(intf);
#line 746
      intf = (PosixNetworkInterface *)((void *)0);
    }
  }
#line 749
  if (! ((err == 0) == ((unsigned int )intf != (unsigned int )((void *)0)))) {
#line 749
    __assert_fail("(err == 0) == (intf != ((void *)0))", "mDNSPosix.c", 749U, "SetupOneInterface");
  }
#line 751
  return (err);
}
}
#line 754 "mDNSPosix.c"
static int SetupInterfaceList(mDNS *m ) 
{ mDNSBool foundav4 ;
  int err ;
  struct ifi_info *intfList ;
  struct ifi_info *tmp ;
  struct ifi_info *firstLoopback ;
  struct ifi_info *i ;
  int tmp___0 ;

  {
#line 756
  foundav4 = (mDNSBool )0;
#line 757
  err = 0;
#line 758
  tmp = get_ifi_info(2, 1);
#line 758
  intfList = tmp;
#line 759
  firstLoopback = (struct ifi_info *)((void *)0);
#line 761
  if (! ((unsigned int )m != (unsigned int )((void *)0))) {
#line 761
    __assert_fail("m != ((void *)0)", "mDNSPosix.c", 761U, "SetupInterfaceList");
  }
#line 764
  if ((unsigned int )intfList == (unsigned int )((void *)0)) {
#line 764
    err = 2;
  }
#line 775
  if (err == 0) {
#line 777
    i = intfList;
#line 778
    while (i) {
#line 780
      if ((int )(i->ifi_addr)->sa_family == 2) {
#line 780
        if ((int )i->ifi_flags & 1) {
#line 780
          if (! ((int )i->ifi_flags & 16)) {
#line 786
            if ((int )i->ifi_flags & 8) {
#line 788
              if ((unsigned int )firstLoopback == (unsigned int )((void *)0)) {
#line 789
                firstLoopback = i;
              }
            } else {
#line 793
              tmp___0 = SetupOneInterface(m, i->ifi_addr, (char const   *)(i->ifi_name));
#line 793
              if (tmp___0 == 0) {
#line 794
                if ((int )(i->ifi_addr)->sa_family == 2) {
#line 795
                  foundav4 = 1;
                }
              }
            }
          }
        }
      }
#line 798
      i = i->ifi_next;
    }
#line 806
    if (! foundav4) {
#line 806
      if (firstLoopback) {
#line 807
        SetupOneInterface(m, firstLoopback->ifi_addr, (char const   *)(firstLoopback->ifi_name));
      }
    }
  }
#line 811
  if ((unsigned int )intfList != (unsigned int )((void *)0)) {
#line 811
    free_ifi_info(intfList);
  }
#line 812
  return (err);
}
}
#line 816 "mDNSPosix.c"
mStatus mDNSPlatformInit(mDNS *m ) 
{ int err ;
  int tmp ;

  {
#line 819
  if (! ((unsigned int )m != (unsigned int )((void *)0))) {
#line 819
    __assert_fail("m != ((void *)0)", "mDNSPosix.c", 819U, "mDNSPlatformInit");
  }
#line 824
  m->nicelabel.c[0] = (unsigned char)0;
#line 825
  GetUserSpecifiedFriendlyComputerName(& m->nicelabel);
#line 826
  if ((int )m->nicelabel.c[0] == 0) {
#line 826
    MakeDomainLabelFromLiteralString(& m->nicelabel, "Macintosh");
  }
#line 829
  m->hostlabel.c[0] = (unsigned char)0;
#line 830
  GetUserSpecifiedRFC1034ComputerName(& m->hostlabel);
#line 831
  if ((int )m->hostlabel.c[0] == 0) {
#line 831
    MakeDomainLabelFromLiteralString(& m->hostlabel, "Macintosh");
  }
#line 833
  mDNS_GenerateFQDN(m);
#line 836
  err = SetupInterfaceList(m);
#line 841
  if (err == 0) {
#line 842
    mDNSCoreInitComplete(m, 0);
  }
#line 844
  if (err == 0) {
#line 844
    tmp = 0;
  } else {
#line 844
    tmp = -65537;
  }
#line 844
  return (tmp);
}
}
#line 849 "mDNSPosix.c"
void mDNSPlatformClose(mDNS *m ) 
{ 

  {
#line 851
  if (! ((unsigned int )m != (unsigned int )((void *)0))) {
#line 851
    __assert_fail("m != ((void *)0)", "mDNSPosix.c", 851U, "mDNSPlatformClose");
  }
#line 852
  ClearInterfaceList(m);
#line 853
  return;
}
}
#line 855 "mDNSPosix.c"
extern mStatus mDNSPlatformPosixRefreshInterfaceList(mDNS *m ) 
{ int err ;
  int tmp ;

  {
#line 858
  ClearInterfaceList(m);
#line 859
  err = SetupInterfaceList(m);
#line 860
  if (err == 0) {
#line 860
    tmp = 0;
  } else {
#line 860
    tmp = -65537;
  }
#line 860
  return (tmp);
}
}
#line 872 "mDNSPosix.c"
void mDNSPlatformLock(mDNS const   *m ) 
{ 

  {
#line 875
  return;
}
}
#line 879 "mDNSPosix.c"
void mDNSPlatformUnlock(mDNS const   *m ) 
{ 

  {
#line 882
  return;
}
}
#line 890 "mDNSPosix.c"
void mDNSPlatformStrCopy(void const   *src , void *dst ) 
{ 

  {
#line 892
  strcpy((char * __restrict  )((char *)dst), (char const   * __restrict  )((char *)src));
#line 893
  return;
}
}
#line 897 "mDNSPosix.c"
mDNSu32 mDNSPlatformStrLen(void const   *src ) 
{ size_t tmp ;

  {
#line 899
  tmp = strlen((char const   *)((char *)src));
#line 899
  return (tmp);
}
}
#line 904 "mDNSPosix.c"
void mDNSPlatformMemCopy(void const   *src , void *dst , mDNSu32 len ) 
{ 

  {
#line 906
  memcpy((void * __restrict  )dst, (void const   * __restrict  )src, len);
#line 907
  return;
}
}
#line 911 "mDNSPosix.c"
mDNSBool mDNSPlatformMemSame(void const   *src , void const   *dst , mDNSu32 len ) 
{ int tmp ;

  {
#line 913
  tmp = memcmp(dst, src, len);
#line 913
  return (tmp == 0);
}
}
#line 918 "mDNSPosix.c"
void mDNSPlatformMemZero(void *dst , mDNSu32 len ) 
{ 

  {
#line 920
  memset(dst, 0, len);
#line 921
  return;
}
}
#line 923 "mDNSPosix.c"
void *mDNSPlatformMemAllocate(mDNSu32 len ) 
{ void *tmp ;

  {
#line 923
  tmp = malloc(len);
#line 923
  return (tmp);
}
}
#line 924 "mDNSPosix.c"
void mDNSPlatformMemFree(void *mem ) 
{ 

  {
#line 924
  free(mem);
#line 924
  return;
}
}
#line 926 "mDNSPosix.c"
mDNSs32 mDNSPlatformOneSecond  =    1024;
#line 928 "mDNSPosix.c"
mStatus mDNSPlatformTimeInit(mDNSs32 *timenow ) 
{ 

  {
#line 933
  *timenow = mDNSPlatformTimeNow();
#line 934
  return (0);
}
}
#line 937 "mDNSPosix.c"
mDNSs32 mDNSPlatformTimeNow(void) 
{ struct timeval tv ;

  {
#line 940
  gettimeofday((struct timeval * __restrict  )(& tv), (struct timezone * __restrict  )((void *)0));
#line 947
  return ((int )((tv.tv_sec << 10) | (tv.tv_usec * 16L) / 15625L));
}
}
#line 950 "mDNSPosix.c"
void mDNSPosixGetFDSet(mDNS *m , int *nfds , fd_set *readfds , struct timeval *timeout ) 
{ mDNSs32 ticks ;
  struct timeval interval ;
  mDNSs32 nextevent ;
  mDNSs32 tmp ;
  PosixNetworkInterface *info ;
  mDNSs32 tmp___0 ;

  {
#line 956
  tmp = mDNS_Execute(m);
#line 956
  nextevent = tmp;
#line 959
  info = (PosixNetworkInterface *)m->HostInterfaces;
#line 960
  while (info) {
#line 962
    if (info->multicastSocket != -1) {
#line 964
      if (*nfds < info->multicastSocket + 1) {
#line 965
        *nfds = info->multicastSocket + 1;
      }
#line 966
      __asm__  volatile   ("btsl %1,%0": "=m" (readfds->__fds_bits[(unsigned int )info->multicastSocket / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )info->multicastSocket % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
#line 968
    if (info->multicastSocketv6 != -1) {
#line 970
      if (*nfds < info->multicastSocketv6 + 1) {
#line 971
        *nfds = info->multicastSocketv6 + 1;
      }
#line 972
      __asm__  volatile   ("btsl %1,%0": "=m" (readfds->__fds_bits[(unsigned int )info->multicastSocketv6 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )info->multicastSocketv6 % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
#line 974
    info = (PosixNetworkInterface *)info->coreIntf.next;
  }
#line 978
  tmp___0 = mDNSPlatformTimeNow();
#line 978
  ticks = nextevent - tmp___0;
#line 979
  if (ticks < 1) {
#line 979
    ticks = 1;
  }
#line 980
  interval.tv_sec = (long )(ticks >> 10);
#line 981
  interval.tv_usec = (long )(((ticks & 1023) * 15625) / 16);
#line 984
  if (timeout->tv_sec > interval.tv_sec) {
#line 986
    *timeout = interval;
  } else {
#line 984
    if (timeout->tv_sec == interval.tv_sec) {
#line 984
      if (timeout->tv_usec > interval.tv_usec) {
#line 986
        *timeout = interval;
      }
    }
  }
#line 987
  return;
}
}
#line 989 "mDNSPosix.c"
void mDNSPosixProcessFDSet(mDNS *m , fd_set *readfds ) 
{ PosixNetworkInterface *info ;
  register char __result ;
  register char __result___0 ;

  {
#line 992
  if (! ((unsigned int )m != (unsigned int )((void *)0))) {
#line 992
    __assert_fail("m != ((void *)0)", "mDNSPosix.c", 992U, "mDNSPosixProcessFDSet");
  }
#line 993
  if (! ((unsigned int )readfds != (unsigned int )((void *)0))) {
#line 993
    __assert_fail("readfds != ((void *)0)", "mDNSPosix.c", 993U, "mDNSPosixProcessFDSet");
  }
#line 994
  info = (PosixNetworkInterface *)m->HostInterfaces;
#line 995
  while (info) {
#line 997
    if (info->multicastSocket != -1) {
#line 997
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )info->multicastSocket % (8U * sizeof(__fd_mask ))),
                           "m" (readfds->__fds_bits[(unsigned int )info->multicastSocket / (8U * sizeof(__fd_mask ))]): "cc");
#line 997
      if (__result) {
#line 999
        __asm__  volatile   ("btrl %1,%0": "=m" (readfds->__fds_bits[(unsigned int )info->multicastSocket / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )info->multicastSocket % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
#line 1000
        SocketDataReady(m, info, info->multicastSocket);
      }
    }
#line 1002
    if (info->multicastSocketv6 != -1) {
#line 1002
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )info->multicastSocketv6 % (8U * sizeof(__fd_mask ))),
                           "m" (readfds->__fds_bits[(unsigned int )info->multicastSocketv6 / (8U * sizeof(__fd_mask ))]): "cc");
#line 1002
      if (__result___0) {
#line 1004
        __asm__  volatile   ("btrl %1,%0": "=m" (readfds->__fds_bits[(unsigned int )info->multicastSocketv6 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )info->multicastSocketv6 % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
#line 1005
        SocketDataReady(m, info, info->multicastSocketv6);
      }
    }
#line 1007
    info = (PosixNetworkInterface *)info->coreIntf.next;
  }
#line 1009
  return;
}
}
#line 1 "mDNSUNP.o"
#pragma merger(0,"/tmp/cil-ct4EU74k.i","-g,-g,-O2")
#line 263 "/usr/include/bits/socket.h"
__inline static  __attribute__((__nothrow__)) struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr ,
                                                                            struct cmsghdr *__cmsg ) ;
#line 269
__inline static  __attribute__((__nothrow__)) struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr ,
                                                                            struct cmsghdr *__cmsg ) ;
#line 269 "/usr/include/bits/socket.h"
__inline static struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr , struct cmsghdr *__cmsg ) 
{ 

  {
#line 272
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
#line 274
    return ((struct cmsghdr *)0);
  }
#line 276
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U)));
#line 278
  if ((unsigned int )((unsigned char *)(__cmsg + 1)) > (unsigned int )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
#line 283
    return ((struct cmsghdr *)0);
  } else {
#line 278
    if ((unsigned int )((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U))) > (unsigned int )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
#line 283
      return ((struct cmsghdr *)0);
    }
  }
#line 284
  return (__cmsg);
}
}
#line 179 "/usr/include/sys/socket.h"
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 110 "mDNSUNP.c"
struct ifi_info *get_ifi_info(int family , int doaliases ) 
{ int junk ;
  struct ifi_info *ifi ;
  struct ifi_info *ifihead ;
  struct ifi_info **ifipnext ;
  int sockfd ;
  int len ;
  int lastlen ;
  int flags ;
  int myflags ;
  char *ptr ;
  char *buf ;
  char lastname[16] ;
  char *cptr ;
  struct ifconf ifc ;
  struct ifreq *ifr ;
  struct ifreq ifrcopy ;
  struct sockaddr_in *sinptr ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___17 ;
  void *tmp___18 ;
  unsigned int tmp___19 ;
  void *tmp___20 ;
  int tmp___21 ;
  void *tmp___22 ;
  int tmp___23 ;
  void *tmp___24 ;

  {
#line 124
  sockfd = -1;
#line 125
  buf = (char *)((void *)0);
#line 126
  ifihead = (struct ifi_info *)((void *)0);
#line 128
  sockfd = socket(2, 2, 0);
#line 129
  if (sockfd < 0) {
    goto gotError;
  }
#line 133
  lastlen = 0;
#line 134
  len = (int )(100U * sizeof(struct ifreq ));
#line 135
  while (1) {
#line 136
    tmp = malloc((unsigned int )len);
#line 136
    buf = (char *)tmp;
#line 137
    if ((unsigned int )buf == (unsigned int )((void *)0)) {
      goto gotError;
    }
#line 140
    ifc.ifc_len = len;
#line 141
    ifc.ifc_ifcu.ifcu_buf = buf;
#line 142
    tmp___1 = ioctl(sockfd, 35090UL, & ifc);
#line 142
    if (tmp___1 < 0) {
#line 143
      tmp___0 = __errno_location();
#line 143
      if (*tmp___0 != 22) {
        goto gotError;
      } else {
#line 143
        if (lastlen != 0) {
          goto gotError;
        }
      }
    } else {
#line 147
      if (ifc.ifc_len == lastlen) {
#line 148
        break;
      }
#line 149
      lastlen = ifc.ifc_len;
    }
#line 151
    len = (int )((unsigned int )len + 10U * sizeof(struct ifreq ));
#line 152
    free((void *)buf);
  }
#line 154
  ifihead = (struct ifi_info *)((void *)0);
#line 155
  ifipnext = & ifihead;
#line 156
  lastname[0] = (char)0;
#line 160
  ptr = buf;
#line 160
  while ((unsigned int )ptr < (unsigned int )(buf + ifc.ifc_len)) {
#line 161
    ifr = (struct ifreq *)ptr;
#line 163
    if ((int )ifr->ifr_ifru.ifru_addr.sa_family == 2) {
#line 163
      len = (int )sizeof(struct sockaddr_in );
    } else {
#line 163
      len = (int )sizeof(struct sockaddr );
    }
#line 176
    ptr += sizeof(struct ifreq );
#line 181
    if ((int )ifr->ifr_ifru.ifru_addr.sa_family != family) {
      goto __Cont;
    }
#line 184
    myflags = 0;
#line 185
    tmp___3 = __builtin_strchr(ifr->ifr_ifrn.ifrn_name, ':');
#line 185
    cptr = tmp___3;
#line 185
    if ((unsigned int )cptr != (unsigned int )((void *)0)) {
#line 186
      *cptr = (char)0;
    }
#line 187
    if (0) {
#line 187
      if (0) {
#line 187
        __s1_len = strlen((char const   *)(lastname));
#line 187
        __s2_len = strlen((char const   *)(ifr->ifr_ifrn.ifrn_name));
#line 187
        if (! ((unsigned int )((void const   *)(lastname + 1)) - (unsigned int )((void const   *)(lastname)) == 1U)) {
          goto _L___0;
        } else {
#line 187
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 187
            if (! ((unsigned int )((void const   *)(ifr->ifr_ifrn.ifrn_name + 1)) - (unsigned int )((void const   *)(ifr->ifr_ifrn.ifrn_name)) == 1U)) {
#line 187
              tmp___12 = 1;
            } else {
#line 187
              if (__s2_len >= 4U) {
#line 187
                tmp___12 = 1;
              } else {
#line 187
                tmp___12 = 0;
              }
            }
          } else {
#line 187
            tmp___12 = 0;
          }
        }
#line 187
        if (tmp___12) {
#line 187
          tmp___7 = __builtin_strcmp((char const   *)(lastname), (char const   *)(ifr->ifr_ifrn.ifrn_name));
#line 187
          tmp___11 = tmp___7;
        } else {
#line 187
          tmp___10 = __builtin_strcmp((char const   *)(lastname), (char const   *)(ifr->ifr_ifrn.ifrn_name));
#line 187
          tmp___11 = tmp___10;
        }
      } else {
#line 187
        tmp___10 = __builtin_strcmp((char const   *)(lastname), (char const   *)(ifr->ifr_ifrn.ifrn_name));
#line 187
        tmp___11 = tmp___10;
      }
#line 187
      tmp___14 = tmp___11;
    } else {
#line 187
      tmp___13 = strncmp((char const   *)(lastname), (char const   *)(ifr->ifr_ifrn.ifrn_name),
                         16U);
#line 187
      tmp___14 = tmp___13;
    }
#line 187
    if (tmp___14 == 0) {
#line 188
      if (doaliases == 0) {
        goto __Cont;
      }
#line 190
      myflags = 1;
    }
#line 192
    memcpy((void * __restrict  )(lastname), (void const   * __restrict  )(ifr->ifr_ifrn.ifrn_name),
           16U);
#line 194
    ifrcopy = *ifr;
#line 195
    tmp___17 = ioctl(sockfd, 35091UL, & ifrcopy);
#line 195
    if (tmp___17 < 0) {
      goto gotError;
    }
#line 199
    flags = (int )ifrcopy.ifr_ifru.ifru_flags;
#line 200
    if ((flags & 1) == 0) {
      goto __Cont;
    }
#line 203
    tmp___18 = calloc(1U, sizeof(struct ifi_info ));
#line 203
    ifi = (struct ifi_info *)tmp___18;
#line 204
    if ((unsigned int )ifi == (unsigned int )((void *)0)) {
      goto gotError;
    }
#line 207
    *ifipnext = ifi;
#line 208
    ifipnext = & ifi->ifi_next;
#line 210
    ifi->ifi_flags = (short )flags;
#line 211
    ifi->ifi_myflags = (short )myflags;
#line 212
    tmp___19 = if_nametoindex((char const   *)(ifr->ifr_ifrn.ifrn_name));
#line 212
    ifi->ifi_index = (int )tmp___19;
#line 213
    memcpy((void * __restrict  )(ifi->ifi_name), (void const   * __restrict  )(ifr->ifr_ifrn.ifrn_name),
           16U);
#line 214
    ifi->ifi_name[15] = (char )'\000';
#line 217
    switch ((int )ifr->ifr_ifru.ifru_addr.sa_family) {
    case 2: 
#line 219
    sinptr = (struct sockaddr_in *)(& ifr->ifr_ifru.ifru_addr);
#line 220
    if ((unsigned int )ifi->ifi_addr == (unsigned int )((void *)0)) {
#line 221
      tmp___20 = calloc(1U, sizeof(struct sockaddr_in ));
#line 221
      ifi->ifi_addr = (struct sockaddr *)tmp___20;
#line 222
      if ((unsigned int )ifi->ifi_addr == (unsigned int )((void *)0)) {
        goto gotError;
      }
#line 225
      memcpy((void * __restrict  )ifi->ifi_addr, (void const   * __restrict  )sinptr,
             sizeof(struct sockaddr_in ));
#line 228
      if (flags & 2) {
#line 229
        tmp___21 = ioctl(sockfd, 35097UL, & ifrcopy);
#line 229
        if (tmp___21 < 0) {
          goto gotError;
        }
#line 232
        sinptr = (struct sockaddr_in *)(& ifrcopy.ifr_ifru.ifru_broadaddr);
#line 233
        tmp___22 = calloc(1U, sizeof(struct sockaddr_in ));
#line 233
        ifi->ifi_brdaddr = (struct sockaddr *)tmp___22;
#line 234
        if ((unsigned int )ifi->ifi_brdaddr == (unsigned int )((void *)0)) {
          goto gotError;
        }
#line 237
        memcpy((void * __restrict  )ifi->ifi_brdaddr, (void const   * __restrict  )sinptr,
               sizeof(struct sockaddr_in ));
      }
#line 242
      if (flags & 16) {
#line 243
        tmp___23 = ioctl(sockfd, 35095UL, & ifrcopy);
#line 243
        if (tmp___23 < 0) {
          goto gotError;
        }
#line 246
        sinptr = (struct sockaddr_in *)(& ifrcopy.ifr_ifru.ifru_dstaddr);
#line 247
        tmp___24 = calloc(1U, sizeof(struct sockaddr_in ));
#line 247
        ifi->ifi_dstaddr = (struct sockaddr *)tmp___24;
#line 248
        if ((unsigned int )ifi->ifi_dstaddr == (unsigned int )((void *)0)) {
          goto gotError;
        }
#line 251
        memcpy((void * __restrict  )ifi->ifi_dstaddr, (void const   * __restrict  )sinptr,
               sizeof(struct sockaddr_in ));
      }
    }
#line 255
    break;
    default: ;
#line 276
    break;
    }
    __Cont: /* CIL Label */ ;
  }
  goto done;
  gotError: 
#line 282
  if ((unsigned int )ifihead != (unsigned int )((void *)0)) {
#line 283
    free_ifi_info(ifihead);
#line 284
    ifihead = (struct ifi_info *)((void *)0);
  }
  done: 
#line 288
  if ((unsigned int )buf != (unsigned int )((void *)0)) {
#line 289
    free((void *)buf);
  }
#line 291
  if (sockfd != -1) {
#line 292
    junk = close(sockfd);
#line 293
    if (! (junk == 0)) {
#line 293
      __assert_fail("junk == 0", "mDNSUNP.c", 293U, "get_ifi_info");
    }
  }
#line 295
  return (ifihead);
}
}
#line 300 "mDNSUNP.c"
void free_ifi_info(struct ifi_info *ifihead ) 
{ struct ifi_info *ifi ;
  struct ifi_info *ifinext ;

  {
#line 305
  ifi = ifihead;
#line 305
  while ((unsigned int )ifi != (unsigned int )((void *)0)) {
#line 306
    if ((unsigned int )ifi->ifi_addr != (unsigned int )((void *)0)) {
#line 307
      free((void *)ifi->ifi_addr);
    }
#line 308
    if ((unsigned int )ifi->ifi_brdaddr != (unsigned int )((void *)0)) {
#line 309
      free((void *)ifi->ifi_brdaddr);
    }
#line 310
    if ((unsigned int )ifi->ifi_dstaddr != (unsigned int )((void *)0)) {
#line 311
      free((void *)ifi->ifi_dstaddr);
    }
#line 312
    ifinext = ifi->ifi_next;
#line 313
    free((void *)ifi);
#line 305
    ifi = ifinext;
  }
#line 315
  return;
}
}
#line 318 "mDNSUNP.c"
ssize_t recvfrom_flags(int fd , void *ptr , size_t nbytes , int *flagsp , struct sockaddr *sa ,
                       socklen_t *salenptr , struct my_in_pktinfo *pktp ) 
{ struct msghdr msg ;
  struct iovec iov[1] ;
  ssize_t n ;
  struct cmsghdr *cmptr ;
  union __anonunion_control_un_40 control_un ;
  struct in_pktinfo *tmp ;
  struct sockaddr_in *sin ;

  {
#line 333
  msg.msg_control = (void *)(control_un.control);
#line 334
  msg.msg_controllen = sizeof(control_un.control);
#line 335
  msg.msg_flags = 0;
#line 340
  msg.msg_name = (void *)sa;
#line 341
  msg.msg_namelen = *salenptr;
#line 342
  iov[0].iov_base = ptr;
#line 343
  iov[0].iov_len = nbytes;
#line 344
  msg.msg_iov = iov;
#line 345
  msg.msg_iovlen = 1U;
#line 347
  n = recvmsg(fd, & msg, *flagsp);
#line 347
  if (n < 0) {
#line 348
    return (n);
  }
#line 350
  *salenptr = msg.msg_namelen;
#line 351
  if (pktp) {
#line 359
    memset((void *)pktp, 0, sizeof(struct my_in_pktinfo ));
#line 360
    pktp->ipi_ifindex = -1;
  }
#line 371
  *flagsp = msg.msg_flags;
#line 372
  if (msg.msg_controllen < sizeof(struct cmsghdr )) {
#line 374
    return (n);
  } else {
#line 372
    if (msg.msg_flags & 8) {
#line 374
      return (n);
    } else {
#line 372
      if ((unsigned int )pktp == (unsigned int )((void *)0)) {
#line 374
        return (n);
      }
    }
  }
#line 376
  if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 376
    cmptr = (struct cmsghdr *)msg.msg_control;
  } else {
#line 376
    cmptr = (struct cmsghdr *)((void *)0);
  }
#line 376
  while ((unsigned int )cmptr != (unsigned int )((void *)0)) {
#line 388
    if (cmptr->cmsg_level == 0) {
#line 388
      if (cmptr->cmsg_type == 8) {
#line 391
        sin = (struct sockaddr_in *)(& pktp->ipi_addr);
#line 393
        tmp = (struct in_pktinfo *)(cmptr->__cmsg_data);
#line 394
        sin->sin_family = (unsigned short)2;
#line 395
        sin->sin_addr = tmp->ipi_addr;
#line 396
        sin->sin_port = (unsigned short)0;
#line 397
        pktp->ipi_ifindex = tmp->ipi_ifindex;
        goto __Cont;
      }
    }
#line 445
    __assert_fail("0", "mDNSUNP.c", 445U, "recvfrom_flags");
    __Cont: /* CIL Label */ 
#line 376
    cmptr = __cmsg_nxthdr(& msg, cmptr);
  }
#line 447
  return (n);
}
}
#line 1 "rend-posix.o"
#pragma merger(0,"/tmp/cil-EoFn5swe.i","-g,-g,-O2")
#line 42 "rend-unix.h"
int rend_pipe_to[2] ;
#line 46
int rend_send_response(int value ) ;
#line 47
int rend_private_init(char *user ) ;
#line 48
int rend_read_message(REND_MESSAGE *pmsg ) ;
#line 196 "rend-posix.c"
static mDNS mDNSStorage  ;
#line 197 "rend-posix.c"
static mDNS_PlatformSupport PlatformStorage  ;
#line 200 "rend-posix.c"
static mDNSBool volatile   gStopNow  ;
#line 214 "rend-posix.c"
static void HandleSigInt(int sigraised ) 
{ 

  {
#line 219
  if (! (sigraised == 2)) {
#line 219
    __assert_fail("sigraised == 2", "rend-posix.c", 219U, "HandleSigInt");
  }
#line 221
  err_log(5, 2048U, (char *)"SIGINT\n");
#line 222
  gStopNow = (int volatile   )1;
#line 223
  return;
}
}
#line 225 "rend-posix.c"
static void HandleSigQuit(int sigraised ) 
{ 

  {
#line 232
  if (! (sigraised == 3)) {
#line 232
    __assert_fail("sigraised == 3", "rend-posix.c", 232U, "HandleSigQuit");
  }
#line 234
  err_log(5, 2048U, (char *)"SIGQUIT\n");
#line 236
  mDNS_Close(& mDNSStorage);
#line 237
  exit(0);
}
}
#line 257 "rend-posix.c"
static PosixService *gServiceList  =    (PosixService *)((void *)0);
#line 259 "rend-posix.c"
static void RegistrationCallback(mDNS *m , ServiceRecordSet *thisRegistration , mStatus status ) 
{ 

  {
#line 264
  switch (status) {
  case 0: 
#line 267
  err_log(9, 2048U, (char *)"Callback: Name Registered\n");
#line 270
  break;
  case -65548: 
#line 273
  err_log(2, 2048U, (char *)"Callback: Name Conflict\n");
#line 286
  status = mDNS_RenameAndReregisterService(m, thisRegistration, (domainlabel const   *)0L);
#line 287
  if (! (status == 0)) {
#line 287
    __assert_fail("status == mStatus_NoError", "rend-posix.c", 287U, "RegistrationCallback");
  }
#line 288
  break;
  case -65792: 
#line 291
  err_log(2, 2048U, (char *)"Callback: Memory Free\n");
#line 307
  free((void *)thisRegistration);
#line 308
  break;
  default: 
#line 311
  err_log(2, 2048U, (char *)"Callback: Unknown Status %d\n", status);
#line 312
  break;
  }
#line 314
  return;
}
}
#line 316 "rend-posix.c"
static int gServiceID  =    0;
#line 318 "rend-posix.c"
static mStatus RegisterOneService(char const   *richTextHostName , char const   *serviceType ,
                                  char const   *serviceDomain , mDNSu8 const   *text ,
                                  mDNSu16 textLen , long portNumber ) 
{ mStatus status ;
  PosixService *thisServ ;
  mDNSOpaque16 port ;
  domainlabel name ;
  domainname type ;
  domainname domain ;
  void *tmp ;

  {
#line 332
  status = 0;
#line 333
  tmp = malloc(sizeof(*thisServ));
#line 333
  thisServ = (PosixService *)tmp;
#line 334
  if ((unsigned int )thisServ == (unsigned int )((void *)0)) {
#line 335
    status = -65539;
  }
#line 337
  if (status == 0) {
#line 338
    MakeDomainLabelFromLiteralString(& name, richTextHostName);
#line 339
    MakeDomainNameFromDNSNameString(& type, serviceType);
#line 340
    MakeDomainNameFromDNSNameString(& domain, serviceDomain);
#line 342
    port.b[0] = (unsigned char )((portNumber >> 8) & 255L);
#line 343
    port.b[1] = (unsigned char )(portNumber & 255L);
#line 344
    status = mDNS_RegisterService(& mDNSStorage, & thisServ->coreServ, (domainlabel const   *)(& name),
                                  (domainname const   *)(& type), (domainname const   *)(& domain),
                                  (domainname const   *)((void *)0), port, text, textLen,
                                  (AuthRecord *)((void *)0), 0U, (struct mDNSInterfaceID_dummystruct *)mDNSInterface_Any,
                                  & RegistrationCallback, (void *)thisServ);
  }
#line 353
  if (status == 0) {
#line 354
    thisServ->serviceID = gServiceID;
#line 355
    gServiceID ++;
#line 357
    thisServ->next = gServiceList;
#line 358
    gServiceList = thisServ;
#line 360
    err_log(9, 2048U, (char *)"Registered service %d, name \'%s\', type \'%s\', domain \'%s\', port %ld\n",
            thisServ->serviceID, richTextHostName, serviceType, serviceDomain, portNumber);
  } else {
#line 368
    if ((unsigned int )thisServ != (unsigned int )((void *)0)) {
#line 369
      free((void *)thisServ);
    }
  }
#line 372
  return (status);
}
}
#line 375 "rend-posix.c"
static void DeregisterOurServices(void) 
{ PosixService *thisServ ;
  int thisServID ;

  {
#line 380
  while ((unsigned int )gServiceList != (unsigned int )((void *)0)) {
#line 381
    thisServ = gServiceList;
#line 382
    gServiceList = thisServ->next;
#line 384
    thisServID = thisServ->serviceID;
#line 386
    mDNS_DeregisterService(& mDNSStorage, & thisServ->coreServ);
#line 388
    err_log(9, 2048U, (char *)"Deregistered service %d\n", thisServ->serviceID);
  }
#line 391
  return;
}
}
#line 398 "rend-posix.c"
void rend_callback(void) 
{ REND_MESSAGE msg ;
  int result ;
  int err ;
  int *tmp ;

  {
#line 403
  err_log(9, 2048U, (char *)"Processing rendezvous message\n");
#line 407
  result = rend_read_message(& msg);
#line 407
  if ((unsigned int )result != sizeof(msg)) {
#line 408
    tmp = __errno_location();
#line 408
    err = *tmp;
#line 409
    err_log(0, 2048U, (char *)"Rendezvous socket closed (daap server crashed?) Aborting.\n");
#line 410
    gStopNow = (int volatile   )1;
#line 411
    return;
  }
#line 414
  switch (msg.cmd) {
  case 0: 
#line 416
  err_log(9, 2048U, (char *)"Registering %s.%s (%d)\n", msg.name, msg.type, msg.port);
#line 417
  RegisterOneService((char const   *)(msg.name), (char const   *)(msg.type), "local.",
                     (mDNSu8 const   *)"\ttxtvers=1\034Database ID=beddab1edeadbea7",
                     (unsigned short)39, (long )msg.port);
#line 419
  rend_send_response(0);
#line 420
  break;
  case 1: 
#line 422
  rend_send_response(1);
#line 423
  break;
  case 2: 
#line 425
  err_log(5, 2048U, (char *)"Stopping mDNS\n");
#line 426
  gStopNow = (int volatile   )1;
#line 427
  rend_send_response(0);
#line 428
  break;
  case 3: 
#line 430
  rend_send_response(1);
#line 431
  break;
  default: ;
#line 433
  break;
  }
#line 435
  return;
}
}
#line 439 "rend-posix.c"
int rend_private_init(char *user ) 
{ mStatus status ;
  mDNSBool result ;
  int tmp ;
  int nfds ;
  fd_set readfds ;
  struct timeval timeout ;
  int result___0 ;
  int __d0 ;
  int __d1 ;
  int *tmp___0 ;
  int *tmp___1 ;
  register char __result ;

  {
#line 443
  status = mDNS_Init(& mDNSStorage, & PlatformStorage, (CacheRecord *)0L, 0U, 1, (mDNSCallback *)0L,
                     (void *)0L);
#line 448
  if (status != 0) {
#line 449
    err_log(0, 2048U, (char *)"mDNS Error %d\n", status);
#line 450
    return (-1);
  }
#line 453
  tmp = drop_privs(user);
#line 453
  if (tmp) {
#line 454
    return (-1);
  }
#line 456
  signal(2, & HandleSigInt);
#line 457
  signal(3, & HandleSigQuit);
#line 458
  signal(1, (void (*)(int  ))1);
#line 460
  while (! gStopNow) {
#line 461
    nfds = 1;
#line 469
    while (1) {
#line 469
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readfds.__fds_bits[0]): "memory");
#line 469
      break;
    }
#line 470
    __asm__  volatile   ("btsl %1,%0": "=m" (readfds.__fds_bits[(unsigned int )rend_pipe_to[0] / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )rend_pipe_to[0] % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 475
    timeout.tv_sec = 1073741823L;
#line 476
    timeout.tv_usec = 0L;
#line 479
    mDNSPosixGetFDSet(& mDNSStorage, & nfds, & readfds, & timeout);
#line 482
    err_log(9, 2048U, (char *)"select(%d, %d.%06d)\n", nfds, timeout.tv_sec, timeout.tv_usec);
#line 485
    result___0 = select(nfds, (fd_set * __restrict  )(& readfds), (fd_set * __restrict  )((void *)0),
                        (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(& timeout));
#line 487
    if (result___0 < 0) {
#line 488
      tmp___0 = __errno_location();
#line 488
      if (*tmp___0 != 4) {
#line 488
        gStopNow = (int volatile   )1;
      }
#line 489
      tmp___1 = __errno_location();
#line 489
      err_log(2, 2048U, (char *)"select() returned %d errno %d\n", result___0, *tmp___1);
    } else {
#line 492
      mDNSPosixProcessFDSet(& mDNSStorage, & readfds);
#line 497
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )rend_pipe_to[0] % (8U * sizeof(__fd_mask ))),
                           "m" (readfds.__fds_bits[(unsigned int )rend_pipe_to[0] / (8U * sizeof(__fd_mask ))]): "cc");
#line 497
      if (__result) {
#line 498
        rend_callback();
      }
    }
  }
#line 503
  err_log(9, 2048U, (char *)"Exiting\n");
#line 505
  DeregisterOurServices();
#line 506
  mDNS_Close(& mDNSStorage);
#line 508
  if (status == 0) {
#line 509
    result = 0;
  } else {
#line 511
    result = 2;
  }
#line 513
  err_log(9, 2048U, (char *)"Finished with status %ld, result %d\n", status, result);
#line 516
  exit(result);
}
}
#line 1 "rend-unix.o"
#pragma merger(0,"/tmp/cil-MtGFzXZc.i","-g,-g,-O2")
#line 382 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 42 "rend-unix.h"
int rend_pipe_to[2]  ;
#line 43 "rend-unix.h"
int rend_pipe_from[2]  ;
#line 45
int rend_send_message(REND_MESSAGE *pmsg ) ;
#line 40 "rend-unix.c"
int rend_pid  ;
#line 50 "rend-unix.c"
int rend_init(char *user ) 
{ int err ;
  int fd ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;

  {
#line 54
  tmp = pipe((int *)((int *)(& rend_pipe_to)));
#line 54
  if (tmp == -1) {
#line 55
    return (-1);
  }
#line 57
  tmp___2 = pipe((int *)((int *)(& rend_pipe_from)));
#line 57
  if (tmp___2 == -1) {
#line 58
    tmp___0 = __errno_location();
#line 58
    err = *tmp___0;
#line 59
    close(rend_pipe_to[0]);
#line 60
    close(rend_pipe_to[1]);
#line 61
    tmp___1 = __errno_location();
#line 61
    *tmp___1 = err;
#line 62
    return (-1);
  }
#line 65
  rend_pid = fork();
#line 66
  if (rend_pid == -1) {
#line 67
    tmp___3 = __errno_location();
#line 67
    err = *tmp___3;
#line 68
    close(rend_pipe_to[0]);
#line 69
    close(rend_pipe_to[1]);
#line 70
    close(rend_pipe_from[0]);
#line 71
    close(rend_pipe_from[1]);
#line 72
    tmp___4 = __errno_location();
#line 72
    *tmp___4 = err;
#line 73
    return (-1);
  }
#line 76
  if (rend_pid) {
#line 77
    close(rend_pipe_to[0]);
#line 78
    close(rend_pipe_from[1]);
#line 79
    return (0);
  }
#line 83
  close(rend_pipe_to[1]);
#line 84
  close(rend_pipe_from[0]);
#line 89
  signal(22, (void (*)(int  ))1);
#line 90
  signal(21, (void (*)(int  ))1);
#line 91
  signal(20, (void (*)(int  ))1);
#line 94
  setpgrp();
#line 106
  fd = open("/dev/null", 2, 0);
#line 106
  if (fd != -1) {
#line 107
    dup2(fd, 0);
#line 108
    dup2(fd, 1);
#line 109
    dup2(fd, 2);
#line 110
    if (fd > 2) {
#line 111
      close(fd);
    }
  }
#line 114
  tmp___5 = __errno_location();
#line 114
  *tmp___5 = 0;
#line 116
  chdir("/");
#line 117
  umask(0);
#line 122
  rend_private_init(user);
#line 123
  exit(0);
}
}
#line 131 "rend-unix.c"
int rend_running(void) 
{ REND_MESSAGE msg ;
  int result ;

  {
#line 135
  err_log(9, 2048U, (char *)"Status inquiry\n");
#line 136
  memset((void *)(& msg), 0, sizeof(msg));
#line 137
  msg.cmd = 3;
#line 138
  result = rend_send_message(& msg);
#line 139
  err_log(9, 2048U, (char *)"Returning status %d\n", result);
#line 140
  return (result);
}
}
#line 148 "rend-unix.c"
int rend_stop(void) 
{ REND_MESSAGE msg ;
  int tmp ;

  {
#line 151
  msg.cmd = 2;
#line 152
  tmp = rend_send_message(& msg);
#line 152
  return (tmp);
}
}
#line 160 "rend-unix.c"
int rend_register(char *name , char *type , int port ) 
{ REND_MESSAGE msg ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 163
  tmp = strlen((char const   *)name);
#line 163
  if (tmp + 1U > 256U) {
#line 164
    err_log(0, 2048U, (char *)"Registration failed: name or type too long\n");
#line 165
    return (-1);
  } else {
#line 163
    tmp___0 = strlen((char const   *)type);
#line 163
    if (tmp___0 + 1U > 256U) {
#line 164
      err_log(0, 2048U, (char *)"Registration failed: name or type too long\n");
#line 165
      return (-1);
    }
  }
#line 168
  memset((void *)(& msg), 0, sizeof(msg));
#line 169
  msg.cmd = 0;
#line 170
  strcpy((char * __restrict  )(msg.name), (char const   * __restrict  )name);
#line 171
  strcpy((char * __restrict  )(msg.type), (char const   * __restrict  )type);
#line 172
  msg.port = port;
#line 174
  tmp___1 = rend_send_message(& msg);
#line 174
  return (tmp___1);
}
}
#line 182 "rend-unix.c"
int rend_unregister(char *name , char *type , int port ) 
{ 

  {
#line 183
  return (-1);
}
}
#line 191 "rend-unix.c"
int rend_send_message(REND_MESSAGE *pmsg ) 
{ int retval ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 194
  tmp = r_write(rend_pipe_to[1], (void *)pmsg, sizeof(REND_MESSAGE ));
#line 194
  if (tmp == -1) {
#line 195
    return (-1);
  }
#line 197
  tmp___0 = r_read(rend_pipe_from[0], (void *)(& retval), sizeof(int ));
#line 197
  retval = tmp___0 == -1;
#line 197
  if (retval) {
#line 198
    return (-1);
  }
#line 200
  return (retval);
}
}
#line 208 "rend-unix.c"
int rend_read_message(REND_MESSAGE *pmsg ) 
{ ssize_t tmp ;

  {
#line 209
  tmp = r_read(rend_pipe_to[0], (void *)pmsg, sizeof(REND_MESSAGE ));
#line 209
  return (tmp);
}
}
#line 217 "rend-unix.c"
int rend_send_response(int value ) 
{ ssize_t tmp ;

  {
#line 218
  tmp = r_write(rend_pipe_from[1], (void *)(& value), sizeof(int ));
#line 218
  return (tmp);
}
}
