/* Generated by Frama-C */
#line 106  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/compiler_types.h"
typedef signed char __s8;
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/int-ll64.h"
typedef __s8 s8;
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/int-ll64.h"
typedef __u8 u8;
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/int-ll64.h"
typedef __s16 s16;
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/int-ll64.h"
typedef __u16 u16;
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/int-ll64.h"
typedef __s32 s32;
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/int-ll64.h"
typedef __u32 u32;
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/int-ll64.h"
typedef __s64 s64;
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/int-ll64.h"
typedef __u64 u64;
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/uapi/asm/posix_types_64.h"
typedef long __kernel_long_t;
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 50  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 51  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 73  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 88  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_time64_t;
#line 92  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 93  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 94  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/types.h"
typedef __u16 __be16;
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/types.h"
typedef __u32 __be32;
#line 37  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 38  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/types.h"
typedef unsigned int __poll_t;
#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/types.h"
typedef u32 __kernel_dev_t;
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef unsigned short umode_t;
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef _Bool bool;
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef __kernel_size_t size_t;
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef s32 int32_t;
#line 109  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef u32 uint32_t;
#line 115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef u64 sector_t;
#line 131  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef u64 blkcnt_t;
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef u64 dma_addr_t;
#line 149  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef unsigned int gfp_t;
#line 155  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef unsigned int fmode_t;
#line 156  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef u64 phys_addr_t;
#line 159  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 170  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 170  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 174  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   s64 counter ;
};
#line 174  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 181  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 185 
struct hlist_node;
#line 185  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 189  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 219  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head *) ;
} __attribute__((__aligned__(8)));
#line 14  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_dcb_82598.i.aux"
struct task_struct;
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/export.h"
struct module;
#line 60  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/export.h"
struct kernel_symbol {
   int value_offset ;
   int name_offset ;
   int namespace_offset ;
};
#line 136  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 139 
struct file_system_type;
#line 83  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/printk.h"
struct ctl_table;
#line 87  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jump_label.h"
struct jump_entry;
#line 87 
struct static_key_mod;
#line 87  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jump_label.h"
union __anonunion_8 {
   unsigned long type ;
   struct jump_entry *entries ;
   struct static_key_mod *next ;
};
#line 87  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jump_label.h"
struct static_key {
   atomic_t enabled ;
   union __anonunion_8 __anonCompField_static_key_4 ;
};
#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jump_label.h"
struct jump_entry {
   s32 code ;
   s32 target ;
   long key ;
};
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dynamic_debug.h"
struct device;
#line 65 
struct net_device;
#line 476  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/printk.h"
struct file_operations;
#line 87  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/div64.h"
struct completion;
#line 88 
struct pt_regs;
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bug.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 188  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/math64.h"
typedef __s64 time64_t;
#line 7  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/time_types.h"
struct __kernel_timespec {
   __kernel_time64_t tv_sec ;
   long long tv_nsec ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/time64.h"
struct timespec64 {
   time64_t tv_sec ;
   long tv_nsec ;
};
#line 165 
struct old_timespec32;
#line 167 
enum timespec_type {
    TT_NONE = 0,
    TT_NATIVE = 1,
    TT_COMPAT = 2
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/restart_block.h"
struct __anonstruct_futex_27 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/restart_block.h"
union __anonunion_29 {
   struct __kernel_timespec *rmtp ;
   struct old_timespec32 *compat_rmtp ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/restart_block.h"
struct __anonstruct_nanosleep_28 {
   clockid_t clockid ;
   enum timespec_type type ;
   union __anonunion_29 __anonCompField___anonstruct_nanosleep_28_5 ;
   u64 expires ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/restart_block.h"
struct __anonstruct_poll_30 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/restart_block.h"
union __anonunion_26 {
   struct __anonstruct_futex_27 futex ;
   struct __anonstruct_nanosleep_28 nanosleep ;
   struct __anonstruct_poll_30 poll ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/restart_block.h"
struct restart_block {
   long (*fn)(struct restart_block *) ;
   union __anonunion_26 __anonCompField_restart_block_6 ;
};
#line 58  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/page_64.h"
struct page;
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/getorder.h"
struct mm_struct;
#line 49 
struct io_bitmap;
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/ptrace.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/desc_defs.h"
struct desc_struct {
   u16 limit0 ;
   u16 base0 ;
   u16 base1 : 8 ;
   u16 type : 4 ;
   u16 s : 1 ;
   u16 dpl : 2 ;
   u16 p : 1 ;
   u16 limit1 : 4 ;
   u16 avl : 1 ;
   u16 l : 1 ;
   u16 d : 1 ;
   u16 g : 1 ;
   u16 base2 : 8 ;
} __attribute__((__packed__));
#line 119  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/desc_defs.h"
typedef unsigned long pteval_t;
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pmdval_t;
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pudval_t;
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_53 {
   pteval_t pte ;
};
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_53 pte_t;
#line 265  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 267  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 266  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_54 {
   pgdval_t pgd ;
};
#line 266  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_54 pgd_t;
#line 319  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pud_t_56 {
   pudval_t pud ;
};
#line 319  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pud_t_56 pud_t;
#line 345  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pmd_t_57 {
   pmdval_t pmd ;
};
#line 345  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pmd_t_57 pmd_t;
#line 505  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 519 
struct file;
#line 530 
struct seq_file;
#line 360  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/nospec-branch.h"
struct thread_struct;
#line 362 
struct cpumask;
#line 365 
struct vm_area_struct;
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qspinlock_types.h"
struct __anonstruct_59 {
   u8 locked ;
   u8 pending ;
};
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qspinlock_types.h"
struct __anonstruct_60 {
   u16 locked_pending ;
   u16 tail ;
};
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qspinlock_types.h"
union __anonunion_58 {
   atomic_t val ;
   struct __anonstruct_59 __anonCompField___anonunion_58_7 ;
   struct __anonstruct_60 __anonCompField___anonunion_58_8 ;
};
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qspinlock_types.h"
struct qspinlock {
   union __anonunion_58 __anonCompField_qspinlock_9 ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qrwlock_types.h"
struct __anonstruct_62 {
   u8 wlocked ;
   u8 __lstate[3U] ;
};
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qrwlock_types.h"
union __anonunion_61 {
   atomic_t cnts ;
   struct __anonstruct_62 __anonCompField___anonunion_61_10 ;
};
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qrwlock_types.h"
struct qrwlock {
   union __anonunion_61 __anonCompField_qrwlock_11 ;
   arch_spinlock_t wait_lock ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/math_emu.h"
struct math_emu_info {
   long ___orig_eip ;
   struct pt_regs *regs ;
};
#line 2288  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/atomic-fallback.h"
typedef atomic64_t atomic_long_t;
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/tracepoint-defs.h"
struct tracepoint_func {
   void *func ;
   void *data ;
   int prio ;
};
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/tracepoint-defs.h"
struct tracepoint {
   char *name ;
   struct static_key key ;
   int (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
#line 37  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/tracepoint-defs.h"
typedef int tracepoint_ptr_t;
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/tracepoint-defs.h"
struct bpf_raw_event_map {
   struct tracepoint *tp ;
   void *bpf_func ;
   u32 num_args ;
   u32 writable_size ;
} __attribute__((__aligned__(32)));
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_90 {
   u64 rip ;
   u64 rdp ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_91 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
union __anonunion_89 {
   struct __anonstruct_90 __anonCompField___anonunion_89_17 ;
   struct __anonstruct_91 __anonCompField___anonunion_89_18 ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
union __anonunion_92 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_89 __anonCompField_fxregs_state_19 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_92 __anonCompField_fxregs_state_20 ;
} __attribute__((__aligned__(16)));
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 232  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
} __attribute__((__packed__));
#line 253  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 extended_state_area[0U] ;
} __attribute__((__packed__, __aligned__(64)));
#line 268  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
   u8 __padding[4096U] ;
};
#line 281  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned long avx512_timestamp ;
   union fpregs_state state ;
};
#line 73  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/orc_types.h"
struct orc_entry {
   s16 sp_offset ;
   s16 bp_offset ;
   unsigned int sp_reg : 4 ;
   unsigned int bp_reg : 4 ;
   unsigned int type : 2 ;
   unsigned int end : 1 ;
} __attribute__((__packed__));
#line 180  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/processor.h"
struct seq_operations;
#line 478 
struct perf_event;
#line 479  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_95 {
   unsigned long seg ;
};
#line 479  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_95 mm_segment_t;
#line 485  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fsbase ;
   unsigned long gsbase ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct io_bitmap *io_bitmap ;
   unsigned long iopl_emul ;
   mm_segment_t addr_limit ;
   unsigned int sig_on_uaccess_err : 1 ;
   unsigned int uaccess_err : 1 ;
   struct fpu fpu ;
};
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/thread_info.h"
struct thread_info {
   unsigned long flags ;
   u32 status ;
};
#line 35  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bottom_half.h"
struct lockdep_map;
#line 55  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockdep.h"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__));
#line 60  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockdep.h"
union __anonunion_96 {
   struct hlist_node hash_entry ;
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 60  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockdep.h"
struct lock_class_key {
   union __anonunion_96 __anonCompField_lock_class_key_23 ;
};
#line 68 
struct lock_trace;
#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockdep.h"
struct lock_class {
   struct hlist_node hash_entry ;
   struct list_head lock_entry ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct lock_trace *usage_traces[9U] ;
   int name_version ;
   char *name ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 157  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char *name ;
   int cpu ;
   unsigned long ip ;
};
#line 226  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned int class_idx : 13 ;
   unsigned int irq_context : 2 ;
   unsigned int trylock : 1 ;
   unsigned int read : 2 ;
   unsigned int check : 1 ;
   unsigned int hardirqs_off : 1 ;
   unsigned int references : 12 ;
   unsigned int pin_count ;
};
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_types.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_types.h"
struct __anonstruct_98 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_types.h"
union __anonunion_97 {
   struct raw_spinlock rlock ;
   struct __anonstruct_98 __anonCompField___anonunion_97_24 ;
};
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_97 __anonCompField_spinlock_25 ;
};
#line 73  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 74  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_types.h"
struct __anonstruct_rwlock_t_99 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 74  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_types.h"
typedef struct __anonstruct_rwlock_t_99 rwlock_t;
#line 57  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
struct mutex;
#line 27  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
struct kmem_cache;
#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/uuid.h"
struct __anonstruct_uuid_t_105 {
   __u8 b[16U] ;
};
#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/uuid.h"
typedef struct __anonstruct_uuid_t_105 uuid_t;
#line 87  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uuid.h"
typedef unsigned long kernel_ulong_t;
#line 210  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
   __u32 cls ;
   __u32 cls_msk ;
};
#line 260  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void *data ;
};
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ioport.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char *name ;
   unsigned long flags ;
   unsigned long desc ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 40 
struct ww_acquire_ctx;
#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mutex.h"
struct mutex {
   atomic_long_t owner ;
   spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct list_head wait_list ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   struct ww_acquire_ctx *ww_ctx ;
   void *magic ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/wait.h"
struct wait_queue_head {
   spinlock_t lock ;
   struct list_head head ;
};
#line 38  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/wait.h"
typedef struct wait_queue_head wait_queue_head_t;
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/seqlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 403  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_117 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 403  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_117 seqlock_t;
#line 601  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/seqlock.h"
struct __anonstruct_nodemask_t_118 {
   unsigned long bits[16U] ;
};
#line 601  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/seqlock.h"
typedef struct __anonstruct_nodemask_t_118 nodemask_t;
#line 7  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/tlbbatch.h"
struct arch_tlbflush_unmap_batch {
   struct cpumask cpumask ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types_task.h"
struct vmacache {
   u64 seqnum ;
   struct vm_area_struct *vmas[4U] ;
};
#line 54  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types_task.h"
struct task_rss_stat {
   int events ;
   int count[4U] ;
};
#line 60  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types_task.h"
struct mm_rss_stat {
   atomic_long_t count[4U] ;
};
#line 64  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types_task.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 76  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types_task.h"
struct tlbflush_unmap_batch {
   struct arch_tlbflush_unmap_batch arch ;
   bool flush_required ;
   bool writable ;
};
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rbtree.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(8)));
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 125  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rbtree.h"
struct rb_root_cached {
   struct rb_root rb_root ;
   struct rb_node *rb_leftmost ;
};
#line 35  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rwsem.h"
struct rw_semaphore {
   atomic_long_t count ;
   atomic_long_t owner ;
   struct optimistic_spin_queue osq ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 26  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/completion.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 120 
struct inode;
#line 121 
struct notifier_block;
#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timex.h"
typedef s32 old_time32_t;
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/time32.h"
struct old_timespec32 {
   old_time32_t tv_sec ;
   s32 tv_nsec ;
};
#line 461  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jiffies.h"
typedef s64 ktime_t;
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(struct timer_list *) ;
   u32 flags ;
   struct lockdep_map lockdep_map ;
};
#line 196 
struct hrtimer;
#line 197 
enum hrtimer_restart;
#line 221 
struct workqueue_struct;
#line 222 
struct work_struct;
#line 102  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *) ;
   struct lockdep_map lockdep_map ;
};
#line 115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 124  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/workqueue.h"
struct rcu_work {
   struct work_struct work ;
   struct callback_head rcu ;
   struct workqueue_struct *wq ;
};
#line 67  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcu_segcblist.h"
struct rcu_segcblist {
   struct callback_head *head ;
   struct callback_head **tails[4U] ;
   unsigned long gp_seq[4U] ;
   atomic_long_t len ;
   long len_lazy ;
   u8 enabled ;
   u8 offloaded ;
};
#line 80 
struct srcu_struct;
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/srcu.h"
struct srcu_node;
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/srcutree.h"
struct srcu_data {
   unsigned long srcu_lock_count[2U] ;
   unsigned long srcu_unlock_count[2U] ;
   spinlock_t lock ;
   struct rcu_segcblist srcu_cblist ;
   unsigned long srcu_gp_seq_needed ;
   unsigned long srcu_gp_seq_needed_exp ;
   bool srcu_cblist_invoking ;
   struct timer_list delay_work ;
   struct work_struct work ;
   struct callback_head srcu_barrier_head ;
   struct srcu_node *mynode ;
   unsigned long grpmask ;
   int cpu ;
   struct srcu_struct *ssp ;
};
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/srcutree.h"
struct srcu_node {
   spinlock_t lock ;
   unsigned long srcu_have_cbs[4U] ;
   unsigned long srcu_data_have_cbs[4U] ;
   unsigned long srcu_gp_seq_needed_exp ;
   struct srcu_node *srcu_parent ;
   int grplo ;
   int grphi ;
};
#line 64  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/srcutree.h"
struct srcu_struct {
   struct srcu_node node[521U] ;
   struct srcu_node *level[4U] ;
   struct mutex srcu_cb_mutex ;
   spinlock_t lock ;
   struct mutex srcu_gp_mutex ;
   unsigned int srcu_idx ;
   unsigned long srcu_gp_seq ;
   unsigned long srcu_gp_seq_needed ;
   unsigned long srcu_gp_seq_needed_exp ;
   unsigned long srcu_last_gp_end ;
   struct srcu_data *sda ;
   unsigned long srcu_barrier_seq ;
   struct mutex srcu_barrier_mutex ;
   struct completion srcu_barrier_completion ;
   atomic_t srcu_barrier_cpu_cnt ;
   struct delayed_work work ;
   struct lockdep_map dep_map ;
};
#line 54  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block *, unsigned long , void *) ;
   struct notifier_block *next ;
   int priority ;
};
#line 70  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/notifier.h"
struct raw_notifier_head {
   struct notifier_block *head ;
};
#line 50  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 57 
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
};
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
struct __anonstruct_129 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
struct __anonstruct_130 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
union __anonunion_128 {
   struct __anonstruct_129 __anonCompField___anonunion_128_28 ;
   struct __anonstruct_130 __anonCompField___anonunion_128_29 ;
};
#line 61 
struct uprobe;
#line 61 
struct return_instance;
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion_128 __anonCompField_uprobe_task_30 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 83  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
struct return_instance {
   struct uprobe *uprobe ;
   unsigned long func ;
   unsigned long stack ;
   unsigned long orig_ret_vaddr ;
   bool chained ;
   struct return_instance *next ;
};
#line 98 
struct xol_area;
#line 101  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 140 
struct ldt_struct;
#line 140 
struct vdso_image;
#line 140  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
struct __anonstruct_mm_context_t_131 {
   u64 ctx_id ;
   atomic64_t tlb_gen ;
   struct rw_semaphore ldt_usr_sem ;
   struct ldt_struct *ldt ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   struct vdso_image *vdso_image ;
   atomic_t perf_rdpmc_allowed ;
   u16 pkey_allocation_map ;
   s16 execute_only_pkey ;
   void *bd_addr ;
};
#line 140  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
typedef struct __anonstruct_mm_context_t_131 mm_context_t;
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct address_space;
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_133 {
   struct list_head lru ;
   struct address_space *mapping ;
   unsigned long index ;
   unsigned long private ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_134 {
   dma_addr_t dma_addr ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_137 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
union __anonunion_136 {
   struct list_head slab_list ;
   struct __anonstruct_137 __anonCompField___anonunion_136_33 ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_139 {
   unsigned int inuse : 16 ;
   unsigned int objects : 15 ;
   unsigned int frozen : 1 ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
union __anonunion_138 {
   void *s_mem ;
   unsigned long counters ;
   struct __anonstruct_139 __anonCompField___anonunion_138_35 ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_135 {
   union __anonunion_136 __anonCompField___anonstruct_135_34 ;
   struct kmem_cache *slab_cache ;
   void *freelist ;
   union __anonunion_138 __anonCompField___anonstruct_135_36 ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_140 {
   unsigned long compound_head ;
   unsigned char compound_dtor ;
   unsigned char compound_order ;
   atomic_t compound_mapcount ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_141 {
   unsigned long _compound_pad_1 ;
   unsigned long _compound_pad_2 ;
   struct list_head deferred_list ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
union __anonunion_143 {
   struct mm_struct *pt_mm ;
   atomic_t pt_frag_refcount ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_142 {
   unsigned long _pt_pad_1 ;
   pgtable_t pmd_huge_pte ;
   unsigned long _pt_pad_2 ;
   union __anonunion_143 __anonCompField___anonstruct_142_40 ;
   spinlock_t *ptl ;
};
#line 68 
struct dev_pagemap;
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_144 {
   struct dev_pagemap *pgmap ;
   void *zone_device_data ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
union __anonunion_132 {
   struct __anonstruct_133 __anonCompField___anonunion_132_31 ;
   struct __anonstruct_134 __anonCompField___anonunion_132_32 ;
   struct __anonstruct_135 __anonCompField___anonunion_132_37 ;
   struct __anonstruct_140 __anonCompField___anonunion_132_38 ;
   struct __anonstruct_141 __anonCompField___anonunion_132_39 ;
   struct __anonstruct_142 __anonCompField___anonunion_132_41 ;
   struct __anonstruct_144 __anonCompField___anonunion_132_42 ;
   struct callback_head callback_head ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
union __anonunion_145 {
   atomic_t _mapcount ;
   unsigned int page_type ;
   unsigned int active ;
   int units ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct page {
   unsigned long flags ;
   union __anonunion_132 __anonCompField_page_43 ;
   union __anonunion_145 __anonCompField_page_44 ;
   atomic_t _refcount ;
   struct mem_cgroup *mem_cgroup ;
} __attribute__((__aligned__(16)));
#line 278  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
struct userfaultfd_ctx;
#line 278  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
struct vm_userfaultfd_ctx {
   struct userfaultfd_ctx *ctx ;
};
#line 292  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
struct __anonstruct_shared_146 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 292 
struct anon_vma;
#line 292 
struct vm_operations_struct;
#line 292 
struct mempolicy;
#line 292  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_146 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   atomic_long_t swap_readahead_info ;
   struct mempolicy *vm_policy ;
   struct vm_userfaultfd_ctx vm_userfaultfd_ctx ;
} __attribute__((__designated_init__));
#line 358  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 363  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 368 
struct kioctx_table;
#line 370 
struct linux_binfmt;
#line 370 
struct user_namespace;
#line 370 
struct mmu_notifier_mm;
#line 370  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
struct __anonstruct_147 {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u64 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long mmap_compat_base ;
   unsigned long mmap_compat_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t membarrier_state ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t pgtables_bytes ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   atomic64_t pinned_vm ;
   unsigned long data_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   spinlock_t arg_lock ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct user_namespace *user_ns ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   atomic_t tlb_flush_pending ;
   bool tlb_flush_batched ;
   struct uprobes_state uprobes_state ;
   atomic_long_t hugetlb_usage ;
   struct work_struct async_put_work ;
} __attribute__((__designated_init__));
#line 370  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
struct mm_struct {
   struct __anonstruct_147 __anonCompField_mm_struct_45 ;
   unsigned long cpu_bitmap[] ;
};
#line 642 
struct vm_fault;
#line 643  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
typedef unsigned int vm_fault_t;
#line 316  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
typedef unsigned int isolate_mode_t;
#line 824 
struct vmem_altmap;
#line 440  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/io.h"
struct fwnode_operations;
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fwnode.h"
struct fwnode_handle {
   struct fwnode_handle *secondary ;
   struct fwnode_operations *ops ;
   struct device *dev ;
};
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fwnode.h"
struct fwnode_endpoint {
   unsigned int port ;
   unsigned int id ;
   struct fwnode_handle *local_fwnode ;
};
#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fwnode.h"
struct fwnode_reference_args {
   struct fwnode_handle *fwnode ;
   unsigned int nargs ;
   u64 args[8U] ;
};
#line 110  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fwnode.h"
struct fwnode_operations {
   struct fwnode_handle *(*get)(struct fwnode_handle *) ;
   void (*put)(struct fwnode_handle *) ;
   bool (*device_is_available)(struct fwnode_handle *) ;
   void *(*device_get_match_data)(struct fwnode_handle *, struct device *) ;
   bool (*property_present)(struct fwnode_handle *, char *) ;
   int (*property_read_int_array)(struct fwnode_handle *, char *, unsigned int , void *, size_t ) ;
   int (*property_read_string_array)(struct fwnode_handle *, char *, char **, size_t ) ;
   char *(*get_name)(struct fwnode_handle *) ;
   char *(*get_name_prefix)(struct fwnode_handle *) ;
   struct fwnode_handle *(*get_parent)(struct fwnode_handle *) ;
   struct fwnode_handle *(*get_next_child_node)(struct fwnode_handle *, struct fwnode_handle *) ;
   struct fwnode_handle *(*get_named_child_node)(struct fwnode_handle *, char *) ;
   int (*get_reference_args)(struct fwnode_handle *, char *, char *, unsigned int , unsigned int , struct fwnode_reference_args *) ;
   struct fwnode_handle *(*graph_get_next_endpoint)(struct fwnode_handle *, struct fwnode_handle *) ;
   struct fwnode_handle *(*graph_get_remote_endpoint)(struct fwnode_handle *) ;
   struct fwnode_handle *(*graph_get_port_parent)(struct fwnode_handle *) ;
   int (*graph_parse_endpoint)(struct fwnode_handle *, struct fwnode_endpoint *) ;
   int (*add_links)(struct fwnode_handle *, struct device *) ;
};
#line 54  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/llist.h"
struct llist_node;
#line 58  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/vmalloc.h"
struct vm_struct {
   struct vm_struct *next ;
   void *addr ;
   unsigned long size ;
   unsigned long flags ;
   struct page **pages ;
   unsigned int nr_pages ;
   phys_addr_t phys_addr ;
   void *caller ;
};
#line 292  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/xarray.h"
struct xarray {
   spinlock_t xa_lock ;
   gfp_t xa_flags ;
   void *xa_head ;
};
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/idr.h"
struct idr {
   struct xarray idr_rt ;
   unsigned int idr_base ;
   unsigned int idr_next ;
};
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uidgid.h"
struct __anonstruct_kuid_t_251 {
   uid_t val ;
};
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_251 kuid_t;
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uidgid.h"
struct __anonstruct_kgid_t_252 {
   gid_t val ;
};
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_252 kgid_t;
#line 140 
struct dentry;
#line 141 
struct iattr;
#line 142 
struct super_block;
#line 144 
struct fs_context;
#line 146 
struct kernfs_open_node;
#line 147 
struct kernfs_iattrs;
#line 84  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_root;
#line 84  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 96 
struct kernfs_node;
#line 96  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 100 
struct kernfs_ops;
#line 100  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 116  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
union __anonunion_253 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 116  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char *name ;
   struct rb_node rb ;
   void *ns ;
   unsigned int hash ;
   union __anonunion_253 __anonCompField_kernfs_node_49 ;
   void *priv ;
   u64 id ;
   unsigned short flags ;
   umode_t mode ;
   struct kernfs_iattrs *iattr ;
};
#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*show_options)(struct seq_file *, struct kernfs_root *) ;
   int (*mkdir)(struct kernfs_node *, char *, umode_t ) ;
   int (*rmdir)(struct kernfs_node *) ;
   int (*rename)(struct kernfs_node *, struct kernfs_node *, char *) ;
   int (*show_path)(struct seq_file *, struct kernfs_node *, struct kernfs_root *) ;
};
#line 173  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct idr ino_idr ;
   u32 last_id_lowbits ;
   u32 id_highbits ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 190  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   struct seq_file *seq_file ;
   void *priv ;
   struct mutex mutex ;
   struct mutex prealloc_mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped : 1 ;
   bool released : 1 ;
   struct vm_operations_struct *vm_ops ;
};
#line 210  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_ops {
   int (*open)(struct kernfs_open_file *) ;
   void (*release)(struct kernfs_open_file *) ;
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   ssize_t (*read)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   __poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *) ;
   int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *) ;
   struct lock_class_key lockdep_key ;
};
#line 596 
struct kobject;
#line 597 
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
};
#line 39  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kobject_ns.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void *(*netlink_ns)(struct sock *) ;
   void *(*initial_ns)(void) ;
   void (*drop_ns)(void *) ;
};
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/stat.h"
struct kstat {
   u32 result_mask ;
   umode_t mode ;
   unsigned int nlink ;
   uint32_t blksize ;
   u64 attributes ;
   u64 attributes_mask ;
   u64 ino ;
   dev_t dev ;
   dev_t rdev ;
   kuid_t uid ;
   kgid_t gid ;
   loff_t size ;
   struct timespec64 atime ;
   struct timespec64 mtime ;
   struct timespec64 ctime ;
   struct timespec64 btime ;
   u64 blocks ;
};
#line 51 
struct bin_attribute;
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysfs.h"
struct attribute {
   char *name ;
   umode_t mode ;
   bool ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 84  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysfs.h"
struct attribute_group {
   char *name ;
   umode_t (*is_visible)(struct kobject *, struct attribute *, int ) ;
   umode_t (*is_bin_visible)(struct kobject *, struct bin_attribute *, int ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *) ;
};
#line 223  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject *, struct attribute *, char *) ;
   ssize_t (*store)(struct kobject *, struct attribute *, char *, size_t ) ;
};
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/refcount.h"
struct refcount_struct {
   atomic_t refs ;
};
#line 101  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/refcount.h"
typedef struct refcount_struct refcount_t;
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kref.h"
struct kref {
   refcount_t refcount ;
};
#line 65  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kobject.h"
struct kset;
#line 65 
struct kobj_type;
#line 65  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kobject.h"
struct kobject {
   char *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
   unsigned int uevent_suppress : 1 ;
};
#line 139  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *) ;
   struct sysfs_ops *sysfs_ops ;
   struct attribute **default_attrs ;
   struct attribute_group **default_groups ;
   struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *) ;
   void *(*namespace)(struct kobject *) ;
   void (*get_ownership)(struct kobject *, kuid_t *, kgid_t *) ;
};
#line 149  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 157  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kobject.h"
struct kset_uevent_ops {
   int (*filter)(struct kset *, struct kobject *) ;
   char *(*name)(struct kset *, struct kobject *) ;
   int (*uevent)(struct kset *, struct kobject *, struct kobj_uevent_env *) ;
};
#line 193  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops *uevent_ops ;
} __attribute__((__designated_init__));
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timerqueue.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root_cached rb_root ;
};
#line 60 
struct hrtimer_clock_base;
#line 61 
struct hrtimer_cpu_base;
#line 80 
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
};
#line 117  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/hrtimer.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer *) ;
   struct hrtimer_clock_base *base ;
   u8 state ;
   u8 is_rel ;
   u8 is_soft ;
   u8 is_hard ;
};
#line 158  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   unsigned int index ;
   clockid_t clockid ;
   seqcount_t seq ;
   struct hrtimer *running ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
} __attribute__((__aligned__(64)));
#line 213  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   unsigned int hres_active : 1 ;
   unsigned int in_hrtirq : 1 ;
   unsigned int hang_detected : 1 ;
   unsigned int softirq_activated : 1 ;
   unsigned int nr_events ;
   unsigned short nr_retries ;
   unsigned short nr_hangs ;
   unsigned int max_hang_time ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   ktime_t softirq_expires_next ;
   struct hrtimer *softirq_next_timer ;
   struct hrtimer_clock_base clock_base[8U] ;
} __attribute__((__aligned__(64)));
#line 50  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 278  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *) ;
   void (*complete)(struct device *) ;
   int (*suspend)(struct device *) ;
   int (*resume)(struct device *) ;
   int (*freeze)(struct device *) ;
   int (*thaw)(struct device *) ;
   int (*poweroff)(struct device *) ;
   int (*restore)(struct device *) ;
   int (*suspend_late)(struct device *) ;
   int (*resume_early)(struct device *) ;
   int (*freeze_late)(struct device *) ;
   int (*thaw_early)(struct device *) ;
   int (*poweroff_late)(struct device *) ;
   int (*restore_early)(struct device *) ;
   int (*suspend_noirq)(struct device *) ;
   int (*resume_noirq)(struct device *) ;
   int (*freeze_noirq)(struct device *) ;
   int (*thaw_noirq)(struct device *) ;
   int (*poweroff_noirq)(struct device *) ;
   int (*restore_noirq)(struct device *) ;
   int (*runtime_suspend)(struct device *) ;
   int (*runtime_resume)(struct device *) ;
   int (*runtime_idle)(struct device *) ;
};
#line 303 
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
};
#line 310 
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
};
#line 318 
struct wakeup_source;
#line 319 
struct wake_irq;
#line 320 
struct pm_domain_data;
#line 530  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
   struct pm_domain_data *domain_data ;
};
#line 573 
struct dev_pm_qos;
#line 573  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int async_suspend : 1 ;
   bool in_dpm_list : 1 ;
   bool is_prepared : 1 ;
   bool is_suspended : 1 ;
   bool is_noirq_suspended : 1 ;
   bool is_late_suspended : 1 ;
   bool no_pm : 1 ;
   bool early_init : 1 ;
   bool direct_complete : 1 ;
   u32 driver_flags ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path : 1 ;
   bool syscore : 1 ;
   bool no_pm_callbacks : 1 ;
   unsigned int must_resume : 1 ;
   unsigned int may_skip_resume : 1 ;
   struct hrtimer suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned int disable_depth : 3 ;
   unsigned int idle_notification : 1 ;
   unsigned int request_pending : 1 ;
   unsigned int deferred_resume : 1 ;
   unsigned int runtime_auto : 1 ;
   bool ignore_children : 1 ;
   unsigned int no_callbacks : 1 ;
   unsigned int irq_safe : 1 ;
   unsigned int use_autosuspend : 1 ;
   unsigned int timer_autosuspends : 1 ;
   unsigned int memalloc_noio : 1 ;
   unsigned int links_count ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   u64 last_busy ;
   u64 active_time ;
   u64 suspended_time ;
   u64 accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device *, s32 ) ;
   struct dev_pm_qos *qos ;
};
#line 650  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   int (*start)(struct device *) ;
   void (*detach)(struct device *, bool ) ;
   int (*activate)(struct device *) ;
   void (*sync)(struct device *) ;
   void (*dismiss)(struct device *) ;
};
#line 628  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rculist.h"
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_TGID = 1,
    PIDTYPE_PGID = 2,
    PIDTYPE_SID = 3,
    PIDTYPE_MAX = 4
};
#line 54  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pid.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
};
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pid.h"
struct pid {
   refcount_t count ;
   unsigned int level ;
   struct hlist_head tasks[4U] ;
   wait_queue_head_t wait_pidfd ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rhashtable-types.h"
struct rhash_head {
   struct rhash_head *next ;
};
#line 33 
struct rhashtable;
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rhashtable-types.h"
struct rhashtable_compare_arg {
   struct rhashtable *ht ;
   void *key ;
};
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rhashtable-types.h"
struct rhashtable_params {
   u16 nelem_hint ;
   u16 key_len ;
   u16 key_offset ;
   u16 head_offset ;
   unsigned int max_size ;
   u16 min_size ;
   bool automatic_shrinking ;
   u32 (*hashfn)(void *, u32 , u32 ) ;
   u32 (*obj_hashfn)(void *, u32 , u32 ) ;
   int (*obj_cmpfn)(struct rhashtable_compare_arg *, void *) ;
};
#line 81  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rhashtable-types.h"
struct rhashtable {
   struct bucket_table *tbl ;
   unsigned int key_len ;
   unsigned int max_elems ;
   struct rhashtable_params p ;
   bool rhlist ;
   struct work_struct run_work ;
   struct mutex mutex ;
   spinlock_t lock ;
   atomic_t nelems ;
};
#line 67  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/sem.h"
struct sem_undo_list;
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 83  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 40  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/seccomp.h"
struct seccomp_filter;
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/latencytop.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/types.h"
struct task_cputime {
   u64 stime ;
   u64 utime ;
   unsigned long long sum_exec_runtime ;
};
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_294 {
   unsigned long sig[1U] ;
};
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_294 sigset_t;
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/signal.h"
typedef void __signalfn_t(int );
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_295 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_296 {
   __kernel_timer_t _tid ;
   int _overrun ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_297 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_298 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_301 {
   char _dummy_bnd[8U] ;
   void *_lower ;
   void *_upper ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_pkey_302 {
   char _dummy_pkey[8U] ;
   __u32 _pkey ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
union __anonunion_300 {
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_301 _addr_bnd ;
   struct __anonstruct__addr_pkey_302 _addr_pkey ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_299 {
   void *_addr ;
   union __anonunion_300 __anonCompField___anonstruct__sigfault_299_50 ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_303 {
   long _band ;
   int _fd ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_304 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
union __sifields {
   struct __anonstruct__kill_295 _kill ;
   struct __anonstruct__timer_296 _timer ;
   struct __anonstruct__rt_297 _rt ;
   struct __anonstruct__sigchld_298 _sigchld ;
   struct __anonstruct__sigfault_299 _sigfault ;
   struct __anonstruct__sigpoll_303 _sigpoll ;
   struct __anonstruct__sigsys_304 _sigsys ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/signal_types.h"
struct __anonstruct_309 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __sifields _sifields ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/signal_types.h"
struct kernel_siginfo {
   struct __anonstruct_309 __anonCompField_kernel_siginfo_53 ;
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/signal_types.h"
typedef struct kernel_siginfo kernel_siginfo_t;
#line 20 
struct user_struct;
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/signal_types.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 35  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/signal_types.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 49  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/signal_types.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/task_io_accounting.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/posix-timers.h"
struct posix_cputimer_base {
   u64 nextevt ;
   struct timerqueue_head tqhead ;
};
#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/posix-timers.h"
struct posix_cputimers {
   struct posix_cputimer_base bases[3U] ;
   unsigned int timers_active ;
   unsigned int expiry_active ;
};
#line 193 
struct signal_struct;
#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/rseq.h"
union __anonunion_rseq_cs_314 {
   __u64 ptr64 ;
   __u64 ptr ;
};
#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/rseq.h"
struct rseq {
   __u32 cpu_id_start ;
   __u32 cpu_id ;
   union __anonunion_rseq_cs_314 rseq_cs ;
   __u32 flags ;
} __attribute__((__aligned__(32)));
#line 146 
struct audit_context;
#line 150 
struct capture_control;
#line 151 
struct cfs_rq;
#line 152 
struct fs_struct;
#line 153 
struct futex_pi_state;
#line 154 
struct io_context;
#line 155 
struct nameidata;
#line 156 
struct nsproxy;
#line 157 
struct perf_event_context;
#line 158 
struct pipe_inode_info;
#line 160 
struct reclaim_state;
#line 161 
struct robust_list_head;
#line 166 
struct sighand_struct;
#line 167 
struct task_delay_info;
#line 168 
struct task_group;
#line 242  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct prev_cputime {
   u64 utime ;
   u64 stime ;
   raw_spinlock_t lock ;
};
#line 290  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 325  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 352  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct util_est {
   unsigned int enqueued ;
   unsigned int ewma ;
} __attribute__((__aligned__(8)));
#line 401  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct sched_avg {
   u64 last_update_time ;
   u64 load_sum ;
   u64 runnable_load_sum ;
   u32 util_sum ;
   u32 period_contrib ;
   unsigned long load_avg ;
   unsigned long runnable_load_avg ;
   unsigned long util_avg ;
   struct util_est util_est ;
} __attribute__((__aligned__(64)));
#line 413  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 449  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   unsigned long runnable_weight ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 486 
struct rt_rq;
#line 486  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   unsigned short on_rq ;
   unsigned short on_list ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
} __attribute__((__designated_init__));
#line 504  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   u64 dl_density ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   unsigned int dl_throttled : 1 ;
   unsigned int dl_boosted : 1 ;
   unsigned int dl_yielded : 1 ;
   unsigned int dl_non_contending : 1 ;
   unsigned int dl_overrun : 1 ;
   struct hrtimer dl_timer ;
   struct hrtimer inactive_timer ;
};
#line 600  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct uclamp_se {
   unsigned int value : 11 ;
   unsigned int bucket_id : 3 ;
   unsigned int active : 1 ;
   unsigned int user_defined : 1 ;
};
#line 625  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};
#line 629 
struct sched_class;
#line 629 
struct cred;
#line 629 
struct key;
#line 629 
struct files_struct;
#line 629 
struct rt_mutex_waiter;
#line 629 
struct css_set;
#line 629 
struct compat_robust_list_head;
#line 629 
struct numa_group;
#line 629  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
union __anonunion_316 {
   refcount_t rcu_users ;
   struct callback_head rcu ;
};
#line 629 
struct ftrace_ret_stack;
#line 629 
struct kcov;
#line 629  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct task_struct {
   struct thread_info thread_info ;
   long state ;
   void *stack ;
   refcount_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   unsigned int cpu ;
   unsigned int wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   struct task_struct *last_wakee ;
   int recent_used_cpu ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct uclamp_se uclamp_req[2U] ;
   struct uclamp_se uclamp[2U] ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t *cpus_ptr ;
   cpumask_t cpus_mask ;
   unsigned long rcu_tasks_nvcsw ;
   u8 rcu_tasks_holdout ;
   u8 rcu_tasks_idx ;
   int rcu_tasks_idle_cpu ;
   struct list_head rcu_tasks_holdout_list ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   struct vmacache vmacache ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned int sched_reset_on_fork : 1 ;
   unsigned int sched_contributes_to_load : 1 ;
   unsigned int sched_migrated : 1 ;
   unsigned int sched_remote_wakeup : 1 ;
   unsigned int sched_psi_wake_requeue : 1 ;
   unsigned int  ;
   unsigned int in_execve : 1 ;
   unsigned int in_iowait : 1 ;
   unsigned int restore_sigmask : 1 ;
   unsigned int in_user_fault : 1 ;
   unsigned int brk_randomized : 1 ;
   unsigned int no_cgroup_migration : 1 ;
   unsigned int frozen : 1 ;
   unsigned int use_memdelay : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid *thread_pid ;
   struct hlist_node pid_links[4U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   u64 utime ;
   u64 stime ;
   u64 gtime ;
   struct prev_cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 start_boottime ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct posix_cputimers posix_cputimers ;
   struct cred *ptracer_cred ;
   struct cred *real_cred ;
   struct cred *cred ;
   struct key *cached_requested_key ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   unsigned long last_switch_time ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   unsigned int sas_ss_flags ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root_cached pi_waiters ;
   struct task_struct *pi_top_task ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   int non_block_count ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   unsigned int in_ubsan ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   struct capture_control *capture_control ;
   unsigned long ptrace_message ;
   kernel_siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   unsigned int psi_flags ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   u64 acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   u32 closid ;
   u32 rmid ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct mutex futex_exit_mutex ;
   unsigned int futex_state ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_prev ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct rseq *rseq ;
   u32 rseq_sig ;
   unsigned long rseq_event_mask ;
   struct tlbflush_unmap_batch tlb_ubc ;
   union __anonunion_316 __anonCompField_task_struct_55 ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   unsigned int fail_nth ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   u64 timer_slack_ns ;
   u64 default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   int curr_ret_depth ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   unsigned int kcov_mode ;
   unsigned int kcov_size ;
   void *kcov_area ;
   struct kcov *kcov ;
   u64 kcov_handle ;
   int kcov_sequence ;
   struct mem_cgroup *memcg_in_oom ;
   gfp_t memcg_oom_gfp_mask ;
   int memcg_oom_order ;
   unsigned int memcg_nr_pages_over_high ;
   struct mem_cgroup *active_memcg ;
   struct request_queue *throttle_queue ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
   struct task_struct *oom_reaper_list ;
   struct vm_struct *stack_vm_area ;
   refcount_t stack_refcount ;
   int patch_state ;
   void *security ;
   struct thread_struct thread ;
};
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ratelimit.h"
struct ratelimit_state {
   raw_spinlock_t lock ;
   int interval ;
   int burst ;
   int printed ;
   int missed ;
   unsigned long begin ;
   unsigned long flags ;
};
#line 5  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/device.h"
struct dev_archdata {
   void *iommu ;
};
#line 12 
struct dma_map_ops;
#line 23 
struct device_driver;
#line 24 
struct driver_private;
#line 25 
struct class;
#line 26 
struct subsys_private;
#line 27 
struct bus_type;
#line 28 
struct iommu_ops;
#line 29 
struct iommu_group;
#line 30 
struct iommu_fwspec;
#line 31 
struct dev_pin_info;
#line 32 
struct iommu_param;
#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
struct bus_type {
   char *name ;
   char *dev_name ;
   struct device *dev_root ;
   struct attribute_group **bus_groups ;
   struct attribute_group **dev_groups ;
   struct attribute_group **drv_groups ;
   int (*match)(struct device *, struct device_driver *) ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   int (*probe)(struct device *) ;
   void (*sync_state)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*online)(struct device *) ;
   int (*offline)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   int (*num_vf)(struct device *) ;
   int (*dma_configure)(struct device *) ;
   struct dev_pm_ops *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
   bool need_parent_lock ;
};
#line 164 
struct device_type;
#line 309 
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
};
#line 383  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
struct device_driver {
   char *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id *of_match_table ;
   struct acpi_device_id *acpi_match_table ;
   int (*probe)(struct device *) ;
   void (*sync_state)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct attribute_group **groups ;
   struct attribute_group **dev_groups ;
   struct dev_pm_ops *pm ;
   void (*coredump)(struct device *) ;
   struct driver_private *p ;
};
#line 589  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
struct class {
   char *name ;
   struct module *owner ;
   struct attribute_group **class_groups ;
   struct attribute_group **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *) ;
   void (*class_release)(struct class *) ;
   void (*dev_release)(struct device *) ;
   int (*shutdown_pre)(struct device *) ;
   struct kobj_ns_type_operations *ns_type ;
   void *(*namespace)(struct device *) ;
   void (*get_ownership)(struct device *, kuid_t *, kgid_t *) ;
   struct dev_pm_ops *pm ;
   struct subsys_private *p ;
};
#line 809  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
struct device_type {
   char *name ;
   struct attribute_group **groups ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *, kuid_t *, kgid_t *) ;
   void (*release)(struct device *) ;
   struct dev_pm_ops *pm ;
};
#line 1008  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 1139 
enum dl_dev_state {
    DL_DEV_NO_DRIVER = 0,
    DL_DEV_PROBING = 1,
    DL_DEV_DRIVER_BOUND = 2,
    DL_DEV_UNBINDING = 3
};
#line 1164  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
struct dev_links_info {
   struct list_head suppliers ;
   struct list_head consumers ;
   struct list_head needs_suppliers ;
   struct list_head defer_sync ;
   bool need_for_probe ;
   enum dl_dev_state status ;
};
#line 1259 
struct dma_coherent_mem;
#line 1259 
struct cma;
#line 1259  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
struct device {
   struct kobject kobj ;
   struct device *parent ;
   struct device_private *p ;
   char *init_name ;
   struct device_type *type ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct mutex lockdep_mutex ;
   struct mutex mutex ;
   struct dev_links_info links ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct irq_domain *msi_domain ;
   struct dev_pin_info *pins ;
   struct list_head msi_list ;
   struct dma_map_ops *dma_ops ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   u64 bus_dma_limit ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   int numa_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct class *class ;
   struct attribute_group **groups ;
   void (*release)(struct device *) ;
   struct iommu_group *iommu_group ;
   struct iommu_fwspec *iommu_fwspec ;
   struct iommu_param *iommu_param ;
   bool offline_disabled : 1 ;
   bool offline : 1 ;
   bool of_node_reused : 1 ;
   bool state_synced : 1 ;
};
#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pm_wakeup.h"
struct wakeup_source {
   char *name ;
   int id ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   struct device *dev ;
   bool active : 1 ;
   bool autosleep_enabled : 1 ;
};
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/extable.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
   int handler ;
};
#line 110  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/interrupt.h"
struct proc_dir_entry;
#line 157  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/io.h"
struct percpu_ref;
#line 158  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/io.h"
typedef void percpu_ref_func_t(struct percpu_ref *);
#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic : 1 ;
   bool allow_reinit : 1 ;
   struct callback_head rcu ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/shrinker.h"
struct shrink_control {
   gfp_t gfp_mask ;
   int nid ;
   unsigned long nr_to_scan ;
   unsigned long nr_scanned ;
   struct mem_cgroup *memcg ;
};
#line 60  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker *, struct shrink_control *) ;
   unsigned long (*scan_objects)(struct shrinker *, struct shrink_control *) ;
   long batch ;
   int seeks ;
   unsigned int flags ;
   struct list_head list ;
   int id ;
   atomic_long_t *nr_deferred ;
};
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memremap.h"
struct vmem_altmap {
   unsigned long base_pfn ;
   unsigned long end_pfn ;
   unsigned long reserve ;
   unsigned long free ;
   unsigned long align ;
   unsigned long alloc ;
};
#line 26 
enum memory_type {
    MEMORY_DEVICE_PRIVATE = 1,
    MEMORY_DEVICE_FS_DAX = 2,
    MEMORY_DEVICE_DEVDAX = 3,
    MEMORY_DEVICE_PCI_P2PDMA = 4
};
#line 67  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memremap.h"
struct dev_pagemap_ops {
   void (*page_free)(struct page *) ;
   void (*kill)(struct dev_pagemap *) ;
   void (*cleanup)(struct dev_pagemap *) ;
   vm_fault_t (*migrate_to_ram)(struct vm_fault *) ;
};
#line 107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memremap.h"
struct dev_pagemap {
   struct vmem_altmap altmap ;
   struct resource res ;
   struct percpu_ref *ref ;
   struct percpu_ref internal_ref ;
   struct completion done ;
   enum memory_type type ;
   unsigned int flags ;
   struct dev_pagemap_ops *ops ;
};
#line 176 
struct file_ra_state;
#line 417  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm.h"
struct vm_fault {
   struct vm_area_struct *vma ;
   unsigned int flags ;
   gfp_t gfp_mask ;
   unsigned long pgoff ;
   unsigned long address ;
   pmd_t *pmd ;
   pud_t *pud ;
   pte_t orig_pte ;
   struct page *cow_page ;
   struct mem_cgroup *memcg ;
   struct page *page ;
   pte_t *pte ;
   spinlock_t *ptl ;
   pgtable_t prealloc_pte ;
};
#line 448 
enum page_entry_size {
    PE_SIZE_PTE = 0,
    PE_SIZE_PMD = 1,
    PE_SIZE_PUD = 2
};
#line 467  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *) ;
   void (*close)(struct vm_area_struct *) ;
   int (*split)(struct vm_area_struct *, unsigned long ) ;
   int (*mremap)(struct vm_area_struct *) ;
   vm_fault_t (*fault)(struct vm_fault *) ;
   vm_fault_t (*huge_fault)(struct vm_fault *, enum page_entry_size ) ;
   void (*map_pages)(struct vm_fault *, unsigned long , unsigned long ) ;
   unsigned long (*pagesize)(struct vm_area_struct *) ;
   vm_fault_t (*page_mkwrite)(struct vm_fault *) ;
   vm_fault_t (*pfn_mkwrite)(struct vm_fault *) ;
   int (*access)(struct vm_area_struct *, unsigned long , void *, int , int ) ;
   char *(*name)(struct vm_area_struct *) ;
   int (*set_policy)(struct vm_area_struct *, struct mempolicy *) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *, unsigned long ) ;
   struct page *(*find_special_page)(struct vm_area_struct *, unsigned long ) ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_bl.h"
struct hlist_bl_node;
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_bl.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 38  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockref.h"
struct __anonstruct_408 {
   spinlock_t lock ;
   int count ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockref.h"
union __anonunion_407 {
   struct __anonstruct_408 __anonCompField___anonunion_407_57 ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockref.h"
struct lockref {
   union __anonunion_407 __anonCompField_lockref_58 ;
};
#line 78  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/stringhash.h"
struct path;
#line 79 
struct vfsmount;
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dcache.h"
struct __anonstruct_410 {
   u32 hash ;
   u32 len ;
};
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dcache.h"
union __anonunion_409 {
   struct __anonstruct_410 __anonCompField___anonunion_409_59 ;
   u64 hash_len ;
};
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dcache.h"
struct qstr {
   union __anonunion_409 __anonCompField_qstr_60 ;
   unsigned char *name ;
};
#line 89 
struct dentry_operations;
#line 89  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dcache.h"
union __anonunion_411 {
   struct list_head d_lru ;
   wait_queue_head_t *d_wait ;
};
#line 89  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dcache.h"
union __anonunion_d_u_412 {
   struct hlist_node d_alias ;
   struct hlist_bl_node d_in_lookup_hash ;
   struct callback_head d_rcu ;
};
#line 89  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   union __anonunion_411 __anonCompField_dentry_61 ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_412 d_u ;
} __attribute__((__designated_init__));
#line 135  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_weak_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_hash)(struct dentry *, struct qstr *) ;
   int (*d_compare)(struct dentry *, unsigned int , char *, struct qstr *) ;
   int (*d_delete)(struct dentry *) ;
   int (*d_init)(struct dentry *) ;
   void (*d_release)(struct dentry *) ;
   void (*d_prune)(struct dentry *) ;
   void (*d_iput)(struct dentry *, struct inode *) ;
   char *(*d_dname)(struct dentry *, char *, int ) ;
   struct vfsmount *(*d_automount)(struct path *) ;
   int (*d_manage)(struct path *, bool ) ;
   struct dentry *(*d_real)(struct dentry *, struct inode *) ;
} __attribute__((__aligned__(64)));
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/path.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
} __attribute__((__designated_init__));
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_lru.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_lru.h"
struct list_lru_memcg {
   struct callback_head rcu ;
   struct list_lru_one *lru[0U] ;
};
#line 40  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
   long nr_items ;
} __attribute__((__aligned__(64)));
#line 52  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
   int shrinker_id ;
   bool memcg_aware ;
};
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fiemap.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 39 
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2,
    MIGRATE_SYNC_NO_COPY = 3
};
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcuwait.h"
struct rcuwait {
   struct task_struct *task ;
};
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcu_sync.h"
struct rcu_sync {
   int gp_state ;
   int gp_count ;
   wait_queue_head_t gp_wait ;
   struct callback_head cb_head ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/percpu-rwsem.h"
struct percpu_rw_semaphore {
   struct rcu_sync rss ;
   unsigned int *read_count ;
   struct rw_semaphore rw_sem ;
   struct rcuwait writer ;
   int readers_block ;
};
#line 10  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/delayed_call.h"
struct delayed_call {
   void (*fn)(void *) ;
   void *arg ;
};
#line 35  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/delayed_call.h"
typedef u32 errseq_t;
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/iocontext.h"
union __anonunion_419 {
   struct list_head q_node ;
   struct kmem_cache *__rcu_icq_cache ;
};
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/iocontext.h"
union __anonunion_420 {
   struct hlist_node ioc_node ;
   struct callback_head __rcu_head ;
};
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/iocontext.h"
struct io_cq {
   struct request_queue *q ;
   struct io_context *ioc ;
   union __anonunion_419 __anonCompField_io_cq_62 ;
   union __anonunion_420 __anonCompField_io_cq_63 ;
   unsigned int flags ;
};
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/iocontext.h"
struct io_context {
   atomic_long_t refcount ;
   atomic_t active_ref ;
   atomic_t nr_tasks ;
   spinlock_t lock ;
   unsigned short ioprio ;
   int nr_batch_requests ;
   unsigned long last_waited ;
   struct xarray icq_tree ;
   struct io_cq *icq_hint ;
   struct hlist_head icq_list ;
   struct work_struct release_work ;
};
#line 287  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fs.h"
struct export_operations;
#line 289 
struct iovec;
#line 290 
struct kiocb;
#line 291 
struct kstatfs;
#line 292 
struct swap_info_struct;
#line 293 
struct iov_iter;
#line 294 
struct fscrypt_info;
#line 295 
struct fscrypt_operations;
#line 296 
struct fsverity_info;
#line 297 
struct fsverity_operations;
#line 298 
struct fs_parameter_description;
#line 224  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec64 ia_atime ;
   struct timespec64 ia_mtime ;
   struct timespec64 ia_ctime ;
   struct file *ia_file ;
};
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/percpu_counter.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 214  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dqblk_xfs.h"
struct dquot;
#line 215 
struct kqid;
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/projid.h"
struct __anonstruct_kprojid_t_421 {
   projid_t val ;
};
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_421 kprojid_t;
#line 180  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
};
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
typedef long long qsize_t;
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
union __anonunion_422 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct kqid {
   union __anonunion_422 __anonCompField_kqid_64 ;
   enum quota_type type ;
};
#line 205  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time64_t dqb_btime ;
   time64_t dqb_itime ;
};
#line 216 
struct quota_format_type;
#line 222  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 294  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   spinlock_t dq_dqb_lock ;
   atomic_t dq_count ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 310  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *, int ) ;
   int (*read_file_info)(struct super_block *, int ) ;
   int (*write_file_info)(struct super_block *, int ) ;
   int (*free_file_info)(struct super_block *, int ) ;
   int (*read_dqblk)(struct dquot *) ;
   int (*commit_dqblk)(struct dquot *) ;
   int (*release_dqblk)(struct dquot *) ;
   int (*get_next_id)(struct super_block *, struct kqid *) ;
};
#line 322  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot *) ;
   struct dquot *(*alloc_dquot)(struct super_block *, int ) ;
   void (*destroy_dquot)(struct dquot *) ;
   int (*acquire_dquot)(struct dquot *) ;
   int (*release_dquot)(struct dquot *) ;
   int (*mark_dirty)(struct dquot *) ;
   int (*write_info)(struct super_block *, int ) ;
   qsize_t *(*get_reserved_space)(struct inode *) ;
   int (*get_projid)(struct inode *, kprojid_t *) ;
   int (*get_inode_usage)(struct inode *, qsize_t *) ;
   int (*get_next_id)(struct super_block *, struct kqid *) ;
};
#line 343  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 395  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
#line 409  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};
#line 415  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};
#line 428  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block *, int , int , struct path *) ;
   int (*quota_off)(struct super_block *, int ) ;
   int (*quota_enable)(struct super_block *, unsigned int ) ;
   int (*quota_disable)(struct super_block *, unsigned int ) ;
   int (*quota_sync)(struct super_block *, int ) ;
   int (*set_info)(struct super_block *, int , struct qc_info *) ;
   int (*get_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*get_nextdqblk)(struct super_block *, struct kqid *, struct qc_dqblk *) ;
   int (*set_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*get_state)(struct super_block *, struct qc_state *) ;
   int (*rm_xquota)(struct super_block *, unsigned int ) ;
};
#line 443  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 518  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct rw_semaphore dqio_sem ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops *ops[3U] ;
};
#line 538 
enum rw_hint {
    WRITE_LIFE_NOT_SET = 0,
    WRITE_LIFE_NONE = 1,
    WRITE_LIFE_SHORT = 2,
    WRITE_LIFE_MEDIUM = 3,
    WRITE_LIFE_LONG = 4,
    WRITE_LIFE_EXTREME = 5
};
#line 318  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb *, long , long ) ;
   void *private ;
   int ki_flags ;
   u16 ki_hint ;
   u16 ki_ioprio ;
   unsigned int ki_cookie ;
};
#line 362  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *, struct writeback_control *) ;
   int (*readpage)(struct file *, struct page *) ;
   int (*writepages)(struct address_space *, struct writeback_control *) ;
   int (*set_page_dirty)(struct page *) ;
   int (*readpages)(struct file *, struct address_space *, struct list_head *, unsigned int ) ;
   int (*write_begin)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page **, void **) ;
   int (*write_end)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page *, void *) ;
   sector_t (*bmap)(struct address_space *, sector_t ) ;
   void (*invalidatepage)(struct page *, unsigned int , unsigned int ) ;
   int (*releasepage)(struct page *, gfp_t ) ;
   void (*freepage)(struct page *) ;
   ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *) ;
   int (*migratepage)(struct address_space *, struct page *, struct page *, enum migrate_mode ) ;
   bool (*isolate_page)(struct page *, isolate_mode_t ) ;
   void (*putback_page)(struct page *) ;
   int (*launder_page)(struct page *) ;
   int (*is_partially_uptodate)(struct page *, unsigned long , unsigned long ) ;
   void (*is_dirty_writeback)(struct page *, bool *, bool *) ;
   int (*error_remove_page)(struct address_space *, struct page *) ;
   int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *) ;
   void (*swap_deactivate)(struct file *) ;
};
#line 445  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct xarray i_pages ;
   gfp_t gfp_mask ;
   atomic_t i_mmap_writable ;
   atomic_t nr_thps ;
   struct rb_root_cached i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrexceptional ;
   unsigned long writeback_index ;
   struct address_space_operations *a_ops ;
   unsigned long flags ;
   errseq_t wb_err ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
} __attribute__((__designated_init__, __aligned__(8)));
#line 473  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   u8 bd_partno ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct backing_dev_info *bd_bdi ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
} __attribute__((__designated_init__));
#line 587 
struct posix_acl;
#line 614 
struct fsnotify_mark_connector;
#line 628 
struct inode_operations;
#line 628  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
union __anonunion_427 {
   unsigned int i_nlink ;
   unsigned int __i_nlink ;
};
#line 628  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
union __anonunion_428 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 628  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
union __anonunion_429 {
   struct file_operations *i_fop ;
   void (*free_inode)(struct inode *) ;
};
#line 628 
struct file_lock_context;
#line 628 
struct cdev;
#line 628  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
union __anonunion_430 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
   unsigned int i_dir_seq ;
};
#line 628  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_427 __anonCompField_inode_65 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec64 i_atime ;
   struct timespec64 i_mtime ;
   struct timespec64 i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   u8 i_blkbits ;
   u8 i_write_hint ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct rw_semaphore i_rwsem ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_io_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   struct list_head i_wb_list ;
   union __anonunion_428 __anonCompField_inode_66 ;
   atomic64_t i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   union __anonunion_429 __anonCompField_inode_67 ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion_430 __anonCompField_inode_68 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct fsnotify_mark_connector *i_fsnotify_marks ;
   struct fscrypt_info *i_crypt_info ;
   struct fsverity_info *i_verity_info ;
   void *i_private ;
} __attribute__((__designated_init__));
#line 904  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 915  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 935  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
union __anonunion_f_u_431 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 935  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct file {
   union __anonunion_f_u_431 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations *f_op ;
   spinlock_t f_lock ;
   enum rw_hint f_write_hint ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
   errseq_t f_wb_err ;
} __attribute__((__designated_init__, __aligned__(4)));
#line 988  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
typedef void *fl_owner_t;
#line 1026 
struct file_lock;
#line 1029  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock *, struct file_lock *) ;
   void (*fl_release_private)(struct file_lock *) ;
};
#line 1034  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct lock_manager_operations {
   fl_owner_t (*lm_get_owner)(fl_owner_t ) ;
   void (*lm_put_owner)(fl_owner_t ) ;
   void (*lm_notify)(struct file_lock *) ;
   int (*lm_grant)(struct file_lock *, int ) ;
   bool (*lm_break)(struct file_lock *) ;
   int (*lm_change)(struct file_lock *, int , struct list_head *) ;
   void (*lm_setup)(struct file_lock *, void **) ;
};
#line 1052 
struct net;
#line 1058 
struct nlm_lockowner;
#line 10  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/nfs_fs_i.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 15 
struct nfs4_lock_state;
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 1079  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct fasync_struct;
#line 1079  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct __anonstruct_afs_433 {
   struct list_head link ;
   int state ;
   unsigned int debug_id ;
};
#line 1079  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
union __anonunion_fl_u_432 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_433 afs ;
};
#line 1079  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct file_lock {
   struct file_lock *fl_blocker ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_blocked_requests ;
   struct list_head fl_blocked_member ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations *fl_ops ;
   struct lock_manager_operations *fl_lmops ;
   union __anonunion_fl_u_432 fl_u ;
} __attribute__((__designated_init__));
#line 1117  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1331  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct fasync_struct {
   rwlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1418  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct sb_writers {
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct percpu_rw_semaphore rw_sem[3U] ;
};
#line 1424 
struct super_operations;
#line 1424 
struct xattr_handler;
#line 1424 
struct mtd_info;
#line 1424  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations *s_op ;
   struct dquot_operations *dq_op ;
   struct quotactl_ops *s_qcop ;
   struct export_operations *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler **s_xattr ;
   struct fscrypt_operations *s_cop ;
   struct key *s_master_keys ;
   struct fsverity_operations *s_vop ;
   struct hlist_bl_head s_roots ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   void *s_fs_info ;
   u32 s_time_gran ;
   time64_t s_time_min ;
   time64_t s_time_max ;
   __u32 s_fsnotify_mask ;
   struct fsnotify_mark_connector *s_fsnotify_marks ;
   char s_id[32U] ;
   uuid_t s_uuid ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   struct dentry_operations *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   atomic_long_t s_fsnotify_inode_refs ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct user_namespace *s_user_ns ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   struct work_struct destroy_work ;
   struct mutex s_sync_lock ;
   int s_stack_depth ;
   spinlock_t s_inode_list_lock ;
   struct list_head s_inodes ;
   spinlock_t s_inode_wblist_lock ;
   struct list_head s_inodes_wb ;
} __attribute__((__designated_init__));
#line 1746  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1756 
struct dir_context;
#line 1767  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context *, char *, int , loff_t , u64 , unsigned int ) ;
   loff_t pos ;
};
#line 1821  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file *, loff_t , int ) ;
   ssize_t (*read)(struct file *, char *, size_t , loff_t *) ;
   ssize_t (*write)(struct file *, char *, size_t , loff_t *) ;
   ssize_t (*read_iter)(struct kiocb *, struct iov_iter *) ;
   ssize_t (*write_iter)(struct kiocb *, struct iov_iter *) ;
   int (*iopoll)(struct kiocb *, bool ) ;
   int (*iterate)(struct file *, struct dir_context *) ;
   int (*iterate_shared)(struct file *, struct dir_context *) ;
   __poll_t (*poll)(struct file *, struct poll_table_struct *) ;
   long (*unlocked_ioctl)(struct file *, unsigned int , unsigned long ) ;
   long (*compat_ioctl)(struct file *, unsigned int , unsigned long ) ;
   int (*mmap)(struct file *, struct vm_area_struct *) ;
   unsigned long mmap_supported_flags ;
   int (*open)(struct inode *, struct file *) ;
   int (*flush)(struct file *, fl_owner_t ) ;
   int (*release)(struct inode *, struct file *) ;
   int (*fsync)(struct file *, loff_t , loff_t , int ) ;
   int (*fasync)(int , struct file *, int ) ;
   int (*lock)(struct file *, int , struct file_lock *) ;
   ssize_t (*sendpage)(struct file *, struct page *, int , size_t , loff_t *, int ) ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   int (*check_flags)(int ) ;
   int (*flock)(struct file *, int , struct file_lock *) ;
   ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ) ;
   ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*setlease)(struct file *, long , struct file_lock **, void **) ;
   long (*fallocate)(struct file *, int , loff_t , loff_t ) ;
   void (*show_fdinfo)(struct seq_file *, struct file *) ;
   ssize_t (*copy_file_range)(struct file *, loff_t , struct file *, loff_t , size_t , unsigned int ) ;
   loff_t (*remap_file_range)(struct file *, loff_t , struct file *, loff_t , loff_t , unsigned int ) ;
   int (*fadvise)(struct file *, loff_t , loff_t , int ) ;
} __attribute__((__designated_init__));
#line 1863  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode *, struct dentry *, unsigned int ) ;
   char *(*get_link)(struct dentry *, struct inode *, struct delayed_call *) ;
   int (*permission)(struct inode *, int ) ;
   struct posix_acl *(*get_acl)(struct inode *, int ) ;
   int (*readlink)(struct dentry *, char *, int ) ;
   int (*create)(struct inode *, struct dentry *, umode_t , bool ) ;
   int (*link)(struct dentry *, struct inode *, struct dentry *) ;
   int (*unlink)(struct inode *, struct dentry *) ;
   int (*symlink)(struct inode *, struct dentry *, char *) ;
   int (*mkdir)(struct inode *, struct dentry *, umode_t ) ;
   int (*rmdir)(struct inode *, struct dentry *) ;
   int (*mknod)(struct inode *, struct dentry *, umode_t , dev_t ) ;
   int (*rename)(struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int ) ;
   int (*setattr)(struct dentry *, struct iattr *) ;
   int (*getattr)(struct path *, struct kstat *, u32 , unsigned int ) ;
   ssize_t (*listxattr)(struct dentry *, char *, size_t ) ;
   int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 , u64 ) ;
   int (*update_time)(struct inode *, struct timespec64 *, int ) ;
   int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int , umode_t ) ;
   int (*tmpfile)(struct inode *, struct dentry *, umode_t ) ;
   int (*set_acl)(struct inode *, struct posix_acl *, int ) ;
} __attribute__((__aligned__(64)));
#line 1942  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *) ;
   void (*destroy_inode)(struct inode *) ;
   void (*free_inode)(struct inode *) ;
   void (*dirty_inode)(struct inode *, int ) ;
   int (*write_inode)(struct inode *, struct writeback_control *) ;
   int (*drop_inode)(struct inode *) ;
   void (*evict_inode)(struct inode *) ;
   void (*put_super)(struct super_block *) ;
   int (*sync_fs)(struct super_block *, int ) ;
   int (*freeze_super)(struct super_block *) ;
   int (*freeze_fs)(struct super_block *) ;
   int (*thaw_super)(struct super_block *) ;
   int (*unfreeze_fs)(struct super_block *) ;
   int (*statfs)(struct dentry *, struct kstatfs *) ;
   int (*remount_fs)(struct super_block *, int *, char *) ;
   void (*umount_begin)(struct super_block *) ;
   int (*show_options)(struct seq_file *, struct dentry *) ;
   int (*show_devname)(struct seq_file *, struct dentry *) ;
   int (*show_path)(struct seq_file *, struct dentry *) ;
   int (*show_stats)(struct seq_file *, struct dentry *) ;
   ssize_t (*quota_read)(struct super_block *, int , char *, size_t , loff_t ) ;
   ssize_t (*quota_write)(struct super_block *, int , char *, size_t , loff_t ) ;
   struct dquot **(*get_dquots)(struct inode *) ;
   int (*bdev_try_to_free_page)(struct super_block *, struct page *, gfp_t ) ;
   long (*nr_cached_objects)(struct super_block *, struct shrink_control *) ;
   long (*free_cached_objects)(struct super_block *, struct shrink_control *) ;
};
#line 2217  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct file_system_type {
   char *name ;
   int fs_flags ;
   int (*init_fs_context)(struct fs_context *) ;
   struct fs_parameter_description *parameters ;
   struct dentry *(*mount)(struct file_system_type *, int , char *, void *) ;
   void (*kill_sb)(struct super_block *) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 1565  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm.h"
struct kvec;
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/scatterlist.h"
struct scatterlist {
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 71  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-debug.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
};
#line 76  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
struct dma_map_ops {
   void *(*alloc)(struct device *, size_t , dma_addr_t *, gfp_t , unsigned long ) ;
   void (*free)(struct device *, size_t , void *, dma_addr_t , unsigned long ) ;
   int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t , size_t , unsigned long ) ;
   int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t , size_t , unsigned long ) ;
   dma_addr_t (*map_page)(struct device *, struct page *, unsigned long , size_t , enum dma_data_direction , unsigned long ) ;
   void (*unmap_page)(struct device *, dma_addr_t , size_t , enum dma_data_direction , unsigned long ) ;
   int (*map_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , unsigned long ) ;
   void (*unmap_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , unsigned long ) ;
   dma_addr_t (*map_resource)(struct device *, phys_addr_t , size_t , enum dma_data_direction , unsigned long ) ;
   void (*unmap_resource)(struct device *, dma_addr_t , size_t , enum dma_data_direction , unsigned long ) ;
   void (*sync_single_for_cpu)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_single_for_device)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   void (*sync_sg_for_device)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   void (*cache_sync)(struct device *, void *, size_t , enum dma_data_direction ) ;
   int (*dma_supported)(struct device *, u64 ) ;
   u64 (*get_required_mask)(struct device *) ;
   size_t (*max_mapping_size)(struct device *) ;
   unsigned long (*get_merge_boundary)(struct device *) ;
};
#line 41  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dynamic_queue_limits.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/uio.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
#line 30 
struct bio_vec;
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uio.h"
union __anonunion_451 {
   struct iovec *iov ;
   struct kvec *kvec ;
   struct bio_vec *bvec ;
   struct pipe_inode_info *pipe ;
};
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uio.h"
struct __anonstruct_453 {
   unsigned int head ;
   unsigned int start_head ;
};
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uio.h"
union __anonunion_452 {
   unsigned long nr_segs ;
   struct __anonstruct_453 __anonCompField___anonunion_452_70 ;
};
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uio.h"
struct iov_iter {
   unsigned int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion_451 __anonCompField_iov_iter_69 ;
   union __anonunion_452 __anonCompField_iov_iter_71 ;
};
#line 285  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uio.h"
typedef unsigned short __kernel_sa_family_t;
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 422 
struct ns_common;
#line 423  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/socket.h"
struct __anonstruct_sync_serial_settings_456 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 423  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/socket.h"
typedef struct __anonstruct_sync_serial_settings_456 sync_serial_settings;
#line 45  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_457 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 45  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_457 te1_settings;
#line 52  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_458 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 52  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_458 raw_hdlc_proto;
#line 57  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_459 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 57  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_459 fr_proto;
#line 67  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_460 {
   unsigned int dlci ;
};
#line 67  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_460 fr_proto_pvc;
#line 71  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_461 {
   unsigned int dlci ;
   char master[16U] ;
};
#line 71  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_461 fr_proto_pvc_info;
#line 76  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_462 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 76  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_462 cisco_proto;
#line 195  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 206  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_463 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 206  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_463 ifs_ifsu ;
};
#line 232  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_464 {
   char ifrn_name[16U] ;
};
#line 232  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if.h"
union __anonunion_ifr_ifru_465 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 232  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_464 ifr_ifrn ;
   union __anonunion_ifr_ifru_465 ifr_ifru ;
};
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/compat.h"
typedef s32 compat_long_t;
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/compat.h"
typedef u32 compat_uptr_t;
#line 367  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 371  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bvec.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 125  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/net.h"
struct sk_buff;
#line 162  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/checksum_64.h"
struct in6_addr;
#line 180  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/checksum.h"
typedef u64 netdev_features_t;
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/in6.h"
union __anonunion_in6_u_500 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/in6.h"
struct in6_addr {
   union __anonunion_in6_u_500 in6_u ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/in6.h"
struct __anonstruct_siphash_key_t_501 {
   u64 key[2U] ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/in6.h"
typedef struct __anonstruct_siphash_key_t_501 siphash_key_t;
#line 163  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if_ether.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
} __attribute__((__packed__));
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pipe_fs_i.h"
struct pipe_buf_operations;
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pipe_fs_i.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations *ops ;
   unsigned int flags ;
   unsigned long private ;
};
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int head ;
   unsigned int tail ;
   unsigned int max_usage ;
   unsigned int ring_size ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
   struct user_struct *user ;
};
#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*release)(struct pipe_inode_info *, struct pipe_buffer *) ;
   int (*steal)(struct pipe_inode_info *, struct pipe_buffer *) ;
   bool (*get)(struct pipe_inode_info *, struct pipe_buffer *) ;
};
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netfilter/nf_conntrack_common.h"
struct ip_conntrack_stat {
   unsigned int found ;
   unsigned int invalid ;
   unsigned int ignore ;
   unsigned int insert ;
   unsigned int insert_failed ;
   unsigned int drop ;
   unsigned int early_drop ;
   unsigned int error ;
   unsigned int expect_new ;
   unsigned int expect_create ;
   unsigned int expect_delete ;
   unsigned int search_restart ;
};
#line 43 
union bpf_attr;
#line 44 
struct skb_ext;
#line 289  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 562  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_523 {
   struct net_device *dev ;
   unsigned long dev_scratch ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
struct __anonstruct_522 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion_523 __anonCompField___anonstruct_522_87 ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_521 {
   struct __anonstruct_522 __anonCompField___anonunion_521_88 ;
   struct rb_node rbnode ;
   struct list_head list ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_524 {
   struct sock *sk ;
   int ip_defrag_offset ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_525 {
   ktime_t tstamp ;
   u64 skb_mstamp_ns ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
struct __anonstruct_527 {
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff *) ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_526 {
   struct __anonstruct_527 __anonCompField___anonunion_526_92 ;
   struct list_head tcp_tsorted_anchor ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
struct __anonstruct_529 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_528 {
   __wsum csum ;
   struct __anonstruct_529 __anonCompField___anonunion_528_94 ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_530 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_531 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_532 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
struct sk_buff {
   union __anonunion_521 __anonCompField_sk_buff_89 ;
   union __anonunion_524 __anonCompField_sk_buff_90 ;
   union __anonunion_525 __anonCompField_sk_buff_91 ;
   char cb[48U] ;
   union __anonunion_526 __anonCompField_sk_buff_93 ;
   unsigned long _nfct ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   __u8 __cloned_offset[0U] ;
   __u8 cloned : 1 ;
   __u8 nohdr : 1 ;
   __u8 fclone : 2 ;
   __u8 peeked : 1 ;
   __u8 head_frag : 1 ;
   __u8 pfmemalloc : 1 ;
   __u8 active_extensions ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   __u8 pkt_type : 3 ;
   __u8 ignore_df : 1 ;
   __u8 nf_trace : 1 ;
   __u8 ip_summed : 2 ;
   __u8 ooo_okay : 1 ;
   __u8 l4_hash : 1 ;
   __u8 sw_hash : 1 ;
   __u8 wifi_acked_valid : 1 ;
   __u8 wifi_acked : 1 ;
   __u8 no_fcs : 1 ;
   __u8 encapsulation : 1 ;
   __u8 encap_hdr_csum : 1 ;
   __u8 csum_valid : 1 ;
   __u8 __pkt_vlan_present_offset[0U] ;
   __u8 vlan_present : 1 ;
   __u8 csum_complete_sw : 1 ;
   __u8 csum_level : 2 ;
   __u8 csum_not_inet : 1 ;
   __u8 dst_pending_confirm : 1 ;
   __u8 ndisc_nodetype : 2 ;
   __u8 ipvs_property : 1 ;
   __u8 inner_protocol_type : 1 ;
   __u8 remcsum_offload : 1 ;
   __u8 offload_fwd_mark : 1 ;
   __u8 offload_l3_fwd_mark : 1 ;
   __u8 tc_skip_classify : 1 ;
   __u8 tc_at_ingress : 1 ;
   __u8 tc_redirected : 1 ;
   __u8 tc_from_ingress : 1 ;
   __u8 decrypted : 1 ;
   __u16 tc_index ;
   union __anonunion_528 __anonCompField_sk_buff_95 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion_530 __anonCompField_sk_buff_96 ;
   __u32 secmark ;
   union __anonunion_531 __anonCompField_sk_buff_97 ;
   union __anonunion_532 __anonCompField_sk_buff_98 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   refcount_t users ;
   struct skb_ext *extensions ;
};
#line 4108  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
struct skb_ext {
   refcount_t refcnt ;
   u8 offset[3U] ;
   u8 chunks ;
   char data[0U] ;
};
#line 177  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 203  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
#line 244  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};
#line 310  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 335  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 360  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
#line 382  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
#line 462  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 513  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 541  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
#line 575  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 683  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
#line 702  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
#line 758  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 775  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 793  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 812  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_tcpip6_spec {
   __be32 ip6src[4U] ;
   __be32 ip6dst[4U] ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tclass ;
};
#line 829  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_ah_espip6_spec {
   __be32 ip6src[4U] ;
   __be32 ip6dst[4U] ;
   __be32 spi ;
   __u8 tclass ;
};
#line 844  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_usrip6_spec {
   __be32 ip6src[4U] ;
   __be32 ip6dst[4U] ;
   __be32 l4_4_bytes ;
   __u8 tclass ;
   __u8 l4_proto ;
};
#line 852  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethtool_tcpip6_spec tcp_ip6_spec ;
   struct ethtool_tcpip6_spec udp_ip6_spec ;
   struct ethtool_tcpip6_spec sctp_ip6_spec ;
   struct ethtool_ah_espip6_spec ah_ip6_spec ;
   struct ethtool_ah_espip6_spec esp_ip6_spec ;
   struct ethtool_usrip6_spec usr_ip6_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
#line 880  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
#line 905  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 1001  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
union __anonunion_558 {
   __u32 rule_cnt ;
   __u32 rss_context ;
};
#line 1001  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   union __anonunion_558 __anonCompField_ethtool_rxnfc_100 ;
   __u32 rule_locs[0U] ;
};
#line 1130  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
#line 1150  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 1230  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
#line 1302  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_fecparam {
   __u32 cmd ;
   __u32 active_fec ;
   __u32 fec ;
   __u32 reserved ;
};
#line 1876  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_link_settings {
   __u32 cmd ;
   __u32 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __s8 link_mode_masks_nwords ;
   __u8 transceiver ;
   __u8 reserved1[3U] ;
   __u32 reserved[7U] ;
   __u32 link_mode_masks[0U] ;
};
#line 40  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
};
#line 108  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ethtool.h"
struct __anonstruct_link_modes_561 {
   unsigned long supported[2U] ;
   unsigned long advertising[2U] ;
   unsigned long lp_advertising[2U] ;
};
#line 108  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ethtool.h"
struct ethtool_link_ksettings {
   struct ethtool_link_settings base ;
   struct __anonstruct_link_modes_561 link_modes ;
};
#line 325  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ethtool.h"
struct ethtool_ops {
   void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *) ;
   int (*get_regs_len)(struct net_device *) ;
   void (*get_regs)(struct net_device *, struct ethtool_regs *, void *) ;
   void (*get_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   int (*set_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   u32 (*get_msglevel)(struct net_device *) ;
   void (*set_msglevel)(struct net_device *, u32 ) ;
   int (*nway_reset)(struct net_device *) ;
   u32 (*get_link)(struct net_device *) ;
   int (*get_eeprom_len)(struct net_device *) ;
   int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   void (*self_test)(struct net_device *, struct ethtool_test *, u64 *) ;
   void (*get_strings)(struct net_device *, u32 , u8 *) ;
   int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state ) ;
   void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *) ;
   int (*begin)(struct net_device *) ;
   void (*complete)(struct net_device *) ;
   u32 (*get_priv_flags)(struct net_device *) ;
   int (*set_priv_flags)(struct net_device *, u32 ) ;
   int (*get_sset_count)(struct net_device *, int ) ;
   int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *) ;
   int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *) ;
   int (*flash_device)(struct net_device *, struct ethtool_flash *) ;
   int (*reset)(struct net_device *, u32 *) ;
   u32 (*get_rxfh_key_size)(struct net_device *) ;
   u32 (*get_rxfh_indir_size)(struct net_device *) ;
   int (*get_rxfh)(struct net_device *, u32 *, u8 *, u8 *) ;
   int (*set_rxfh)(struct net_device *, u32 *, u8 *, u8 ) ;
   int (*get_rxfh_context)(struct net_device *, u32 *, u8 *, u8 *, u32 ) ;
   int (*set_rxfh_context)(struct net_device *, u32 *, u8 *, u8 , u32 *, bool ) ;
   void (*get_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*set_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*get_dump_flag)(struct net_device *, struct ethtool_dump *) ;
   int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *) ;
   int (*set_dump)(struct net_device *, struct ethtool_dump *) ;
   int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *) ;
   int (*get_module_info)(struct net_device *, struct ethtool_modinfo *) ;
   int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*set_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*get_tunable)(struct net_device *, struct ethtool_tunable *, void *) ;
   int (*set_tunable)(struct net_device *, struct ethtool_tunable *, void *) ;
   int (*get_per_queue_coalesce)(struct net_device *, u32 , struct ethtool_coalesce *) ;
   int (*set_per_queue_coalesce)(struct net_device *, u32 , struct ethtool_coalesce *) ;
   int (*get_link_ksettings)(struct net_device *, struct ethtool_link_ksettings *) ;
   int (*set_link_ksettings)(struct net_device *, struct ethtool_link_ksettings *) ;
   int (*get_fecparam)(struct net_device *, struct ethtool_fecparam *) ;
   int (*set_fecparam)(struct net_device *, struct ethtool_fecparam *) ;
   void (*get_ethtool_phy_stats)(struct net_device *, struct ethtool_stats *, u64 *) ;
};
#line 822  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/sysctl.h"
struct ctl_table_root;
#line 823 
struct ctl_table_header;
#line 824 
struct ctl_dir;
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table *, int , void *, size_t *, loff_t *);
#line 105  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 123  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
struct ctl_table {
   char *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
} __attribute__((__designated_init__));
#line 135  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 142  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
struct __anonstruct_563 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 142  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
union __anonunion_562 {
   struct __anonstruct_563 __anonCompField___anonunion_562_101 ;
   struct callback_head rcu ;
};
#line 142 
struct ctl_table_set;
#line 142  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion_562 __anonCompField_ctl_table_header_102 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
   struct hlist_head inodes ;
};
#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 167  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set *) ;
   struct ctl_dir dir ;
};
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root *) ;
   void (*set_ownership)(struct ctl_table_header *, struct ctl_table *, kuid_t *, kgid_t *) ;
   int (*permissions)(struct ctl_table_header *, struct ctl_table *) ;
};
#line 242 
struct prot_inuse;
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/core.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   int *sock_inuse ;
   struct prot_inuse *prot_inuse ;
};
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct u64_stats_sync {
   };
#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct __anonstruct_local_t_564 {
   atomic_long_t a ;
};
#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
typedef struct __anonstruct_local_t_564 local_t;
#line 119  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/local.h"
struct __anonstruct_local64_t_565 {
   local_t a ;
};
#line 119  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/local.h"
typedef struct __anonstruct_local64_t_565 local64_t;
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/local64.h"
struct __anonstruct_u64_stats_t_566 {
   local64_t v ;
};
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/local64.h"
typedef struct __anonstruct_u64_stats_t_566 u64_stats_t;
#line 51  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct ipstats_mib {
   u64 mibs[37U] ;
   struct u64_stats_sync syncp ;
};
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};
#line 64  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
#line 71  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
#line 81  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
#line 92  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};
#line 104  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[120U] ;
};
#line 110  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
#line 116  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct linux_tls_mib {
   unsigned long mibs[11U] ;
};
#line 7  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/mib.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
   struct linux_tls_mib *tls_statistics ;
};
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/unix.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/packet.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_frag.h"
struct inet_frags;
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_frag.h"
struct fqdir {
   long high_thresh ;
   long low_thresh ;
   int timeout ;
   int max_dist ;
   struct inet_frags *f ;
   struct net *net ;
   bool dead ;
   struct rhashtable rhashtable ;
   atomic_long_t mem ;
   struct work_struct destroy_work ;
};
#line 41  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_frag.h"
struct frag_v4_compare_key {
   __be32 saddr ;
   __be32 daddr ;
   u32 user ;
   u32 vif ;
   __be16 id ;
   u16 protocol ;
};
#line 50  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_frag.h"
struct frag_v6_compare_key {
   struct in6_addr saddr ;
   struct in6_addr daddr ;
   u32 user ;
   __be32 id ;
   u32 iif ;
};
#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_frag.h"
union __anonunion_key_567 {
   struct frag_v4_compare_key v4 ;
   struct frag_v6_compare_key v6 ;
};
#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_frag.h"
struct inet_frag_queue {
   struct rhash_head node ;
   union __anonunion_key_567 key ;
   struct timer_list timer ;
   spinlock_t lock ;
   refcount_t refcnt ;
   struct rb_root rb_fragments ;
   struct sk_buff *fragments_tail ;
   struct sk_buff *last_run_head ;
   ktime_t stamp ;
   int len ;
   int meat ;
   __u8 flags ;
   u16 max_size ;
   struct fqdir *fqdir ;
   struct callback_head rcu ;
};
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_frag.h"
struct inet_frags {
   unsigned int qsize ;
   void (*constructor)(struct inet_frag_queue *, void *) ;
   void (*destructor)(struct inet_frag_queue *) ;
   void (*frag_expire)(struct timer_list *) ;
   struct kmem_cache *frags_cachep ;
   char *frags_cache_name ;
   struct rhashtable_params rhash_params ;
   refcount_t refcnt ;
   struct completion completion ;
};
#line 177 
struct ipv4_devconf;
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ipv4.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};
#line 31 
struct inet_hashinfo;
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ipv4.h"
struct inet_timewait_death_row {
   atomic_t tw_count ;
   struct inet_hashinfo *hashinfo ;
   int sysctl_max_tw_buckets ;
};
#line 40 
struct tcp_fastopen_context;
#line 43 
struct xt_table;
#line 43 
struct tcp_congestion_ops;
#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct ip_ra_chain *ra_chain ;
   struct mutex ra_mutex ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   unsigned int fib_rules_require_fldissect ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   bool fib_has_custom_local_routes ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct fqdir *fqdir ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_default_ttl ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_fwd_update_priority ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_ip_dynaddr ;
   int sysctl_ip_early_demux ;
   int sysctl_raw_l3mdev_accept ;
   int sysctl_tcp_early_demux ;
   int sysctl_udp_early_demux ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_l3mdev_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_mtu_probe_floor ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_min_snd_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   int sysctl_tcp_keepalive_time ;
   int sysctl_tcp_keepalive_probes ;
   int sysctl_tcp_keepalive_intvl ;
   int sysctl_tcp_syn_retries ;
   int sysctl_tcp_synack_retries ;
   int sysctl_tcp_syncookies ;
   int sysctl_tcp_reordering ;
   int sysctl_tcp_retries1 ;
   int sysctl_tcp_retries2 ;
   int sysctl_tcp_orphan_retries ;
   int sysctl_tcp_fin_timeout ;
   unsigned int sysctl_tcp_notsent_lowat ;
   int sysctl_tcp_tw_reuse ;
   int sysctl_tcp_sack ;
   int sysctl_tcp_window_scaling ;
   int sysctl_tcp_timestamps ;
   int sysctl_tcp_early_retrans ;
   int sysctl_tcp_recovery ;
   int sysctl_tcp_thin_linear_timeouts ;
   int sysctl_tcp_slow_start_after_idle ;
   int sysctl_tcp_retrans_collapse ;
   int sysctl_tcp_stdurg ;
   int sysctl_tcp_rfc1337 ;
   int sysctl_tcp_abort_on_overflow ;
   int sysctl_tcp_fack ;
   int sysctl_tcp_max_reordering ;
   int sysctl_tcp_dsack ;
   int sysctl_tcp_app_win ;
   int sysctl_tcp_adv_win_scale ;
   int sysctl_tcp_frto ;
   int sysctl_tcp_nometrics_save ;
   int sysctl_tcp_moderate_rcvbuf ;
   int sysctl_tcp_tso_win_divisor ;
   int sysctl_tcp_workaround_signed_windows ;
   int sysctl_tcp_limit_output_bytes ;
   int sysctl_tcp_challenge_ack_limit ;
   int sysctl_tcp_min_tso_segs ;
   int sysctl_tcp_min_rtt_wlen ;
   int sysctl_tcp_autocorking ;
   int sysctl_tcp_invalid_ratelimit ;
   int sysctl_tcp_pacing_ss_ratio ;
   int sysctl_tcp_pacing_ca_ratio ;
   int sysctl_tcp_wmem[3U] ;
   int sysctl_tcp_rmem[3U] ;
   int sysctl_tcp_comp_sack_nr ;
   unsigned long sysctl_tcp_comp_sack_delay_ns ;
   struct inet_timewait_death_row tcp_death_row ;
   int sysctl_max_syn_backlog ;
   int sysctl_tcp_fastopen ;
   struct tcp_congestion_ops *tcp_congestion_control ;
   struct tcp_fastopen_context *tcp_fastopen_ctx ;
   spinlock_t tcp_fastopen_ctx_lock ;
   unsigned int sysctl_tcp_fastopen_blackhole_timeout ;
   atomic_t tfo_active_disable_times ;
   unsigned long tfo_active_disable_stamp ;
   int sysctl_udp_wmem_min ;
   int sysctl_udp_rmem_min ;
   int sysctl_udp_l3mdev_accept ;
   int sysctl_igmp_max_memberships ;
   int sysctl_igmp_max_msf ;
   int sysctl_igmp_llm_reports ;
   int sysctl_igmp_qrv ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   int sysctl_ip_prot_sock ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   int sysctl_fib_multipath_use_neigh ;
   int sysctl_fib_multipath_hash_policy ;
   struct fib_notifier_ops *notifier_ops ;
   unsigned int fib_seq ;
   struct fib_notifier_ops *ipmr_notifier_ops ;
   unsigned int ipmr_seq ;
   atomic_t rt_genid ;
   siphash_key_t ip_id_key ;
};
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/dst_ops.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops *) ;
   struct dst_entry *(*check)(struct dst_entry *, __u32 ) ;
   unsigned int (*default_advmss)(struct dst_entry *) ;
   unsigned int (*mtu)(struct dst_entry *) ;
   u32 *(*cow_metrics)(struct dst_entry *, unsigned long ) ;
   void (*destroy)(struct dst_entry *) ;
   void (*ifdown)(struct dst_entry *, struct net_device *, int ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry *) ;
   void (*link_failure)(struct sk_buff *) ;
   void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32 , bool ) ;
   void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *) ;
   int (*local_out)(struct net *, struct sock *, struct sk_buff *) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry *, struct sk_buff *, void *) ;
   void (*confirm_neigh)(struct dst_entry *, void *) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ipv6.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int multipath_hash_policy ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int icmpv6_echo_ignore_all ;
   int icmpv6_echo_ignore_multicast ;
   int icmpv6_echo_ignore_anycast ;
   unsigned long icmpv6_ratemask[4U] ;
   unsigned long *icmpv6_ratemask_ptr ;
   int anycast_src_echo_reply ;
   int ip_nonlocal_bind ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
   int flowlabel_reflect ;
   int max_dst_opts_cnt ;
   int max_hbh_opts_cnt ;
   int max_dst_opts_len ;
   int max_hbh_opts_len ;
   int seg6_flowlabel ;
   bool skip_notify_on_dev_down ;
};
#line 56 
struct seg6_pernet_data;
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ipv6.h"
struct __anonstruct_ip6addrlbl_table_569 {
   struct hlist_head head ;
   spinlock_t lock ;
   u32 seq ;
};
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct fqdir *fqdir ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct fib6_info *fib6_null_entry ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct list_head fib6_walkers ;
   struct dst_ops ip6_dst_ops ;
   rwlock_t fib6_walker_lock ;
   spinlock_t fib6_gc_lock ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   unsigned int fib6_rules_require_fldissect ;
   bool fib6_has_custom_rules ;
   unsigned int fib6_routes_require_src ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
   struct seg6_pernet_data *seg6_data ;
   struct fib_notifier_ops *notifier_ops ;
   struct fib_notifier_ops *ip6mr_notifier_ops ;
   unsigned int ipmr_seq ;
   struct __anonstruct_ip6addrlbl_table_569 ip6addrlbl_table ;
};
#line 121  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct fqdir *fqdir ;
};
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/nexthop.h"
struct netns_nexthop {
   struct rb_root rb_root ;
   struct hlist_head *devhash ;
   unsigned int seq ;
   u32 last_id_allocated ;
};
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ieee802154_6lowpan.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct fqdir *fqdir ;
};
#line 21 
struct sctp_mib;
#line 10  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/sctp.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int ps_retrans ;
   int pf_enable ;
   int pf_expose ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int reconf_enable ;
   int auth_enable ;
   int intl_enable ;
   int ecn_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
#line 7  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/dccp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 75  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/netfilter.h"
struct nf_logger;
#line 76 
struct nf_queue_handler;
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/netfilter.h"
struct nf_hook_entries;
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_queue_handler *queue_handler ;
   struct nf_logger *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
   struct nf_hook_entries *hooks_ipv4[5U] ;
   struct nf_hook_entries *hooks_ipv6[5U] ;
   struct nf_hook_entries *hooks_arp[3U] ;
   struct nf_hook_entries *hooks_bridge[5U] ;
   struct nf_hook_entries *hooks_decnet[7U] ;
   bool defrag_ipv4 ;
   bool defrag_ipv6 ;
};
#line 37 
struct ebt_table;
#line 10  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/x_tables.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_nulls.h"
struct hlist_nulls_node;
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_nulls.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_nulls.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct nf_generic_net {
   unsigned int timeout ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct nf_tcp_net {
   unsigned int timeouts[14U] ;
   int tcp_loose ;
   int tcp_be_liberal ;
   int tcp_max_retrans ;
};
#line 38  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct nf_udp_net {
   unsigned int timeouts[2U] ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct nf_icmp_net {
   unsigned int timeout ;
};
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct nf_dccp_net {
   int dccp_loose ;
   unsigned int dccp_timeout[10U] ;
};
#line 54  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct nf_sctp_net {
   unsigned int timeouts[10U] ;
};
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct nf_gre_net {
   struct list_head keymap_list ;
   unsigned int timeouts[2U] ;
};
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct nf_dccp_net dccp ;
   struct nf_sctp_net sctp ;
   struct nf_gre_net gre ;
};
#line 89  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
};
#line 95 
struct nf_ct_event_notifier;
#line 95 
struct nf_exp_event_notifier;
#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   bool auto_assign_helper_warned ;
   struct ctl_table_header *sysctl_header ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
};
#line 7  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/nftables.h"
struct netns_nftables {
   struct list_head tables ;
   struct list_head commit_list ;
   struct list_head module_list ;
   struct mutex commit_mutex ;
   unsigned int base_seq ;
   u8 gencursor ;
   u8 validate_state ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/xfrm.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct list_head inexact_bins ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   spinlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
};
#line 79 
struct mpls_route;
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/mpls.h"
struct netns_mpls {
   int ip_ttl_propagate ;
   int default_ttl ;
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};
#line 20 
struct can_dev_rcv_lists;
#line 21 
struct can_pkg_stats;
#line 22 
struct can_rcv_lists_stats;
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/can.h"
struct netns_can {
   struct proc_dir_entry *proc_dir ;
   struct proc_dir_entry *pde_version ;
   struct proc_dir_entry *pde_stats ;
   struct proc_dir_entry *pde_reset_stats ;
   struct proc_dir_entry *pde_rcvlist_all ;
   struct proc_dir_entry *pde_rcvlist_fil ;
   struct proc_dir_entry *pde_rcvlist_inv ;
   struct proc_dir_entry *pde_rcvlist_sff ;
   struct proc_dir_entry *pde_rcvlist_eff ;
   struct proc_dir_entry *pde_rcvlist_err ;
   struct proc_dir_entry *bcmproc_dir ;
   struct can_dev_rcv_lists *rx_alldev_list ;
   spinlock_t rcvlists_lock ;
   struct timer_list stattimer ;
   struct can_pkg_stats *pkg_stats ;
   struct can_rcv_lists_stats *rcv_lists_stats ;
   struct hlist_head cgw_list ;
};
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/xdp.h"
struct netns_xdp {
   struct mutex lock ;
   struct hlist_head list ;
};
#line 12 
struct proc_ns_operations;
#line 7  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ns_common.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations *ops ;
   unsigned int inum ;
};
#line 13 
struct uevent_sock;
#line 14 
struct netns_ipvs;
#line 55  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/net_namespace.h"
struct key_tag;
#line 55 
struct ucounts;
#line 55  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/net_namespace.h"
struct net {
   refcount_t passive ;
   refcount_t count ;
   spinlock_t rules_mod_lock ;
   unsigned int dev_unreg_count ;
   unsigned int dev_base_seq ;
   int ifindex ;
   spinlock_t nsid_lock ;
   atomic_t fnhe_genid ;
   struct list_head list ;
   struct list_head exit_list ;
   struct llist_node cleanup_list ;
   struct key_tag *key_domain ;
   struct user_namespace *user_ns ;
   struct ucounts *ucounts ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct list_head dev_base_head ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct uevent_sock *uevent_sock ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   struct raw_notifier_head netdev_chain ;
   u32 hash_mix ;
   struct net_device *loopback_dev ;
   struct list_head rules_ops ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_nexthop nexthop ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct ctl_table_header *nf_frag_frags_hdr ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct list_head nfnl_acct_list ;
   struct list_head nfct_timeout_list ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct bpf_prog *flow_dissector_prog ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct netns_can can ;
   struct netns_xdp xdp ;
   struct sock *crypto_nlsk ;
   struct sock *diag_nlsk ;
} __attribute__((__designated_init__));
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/assoc_array.h"
struct assoc_array_ptr;
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/assoc_array.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 83  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/assoc_array.h"
typedef int32_t key_serial_t;
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
typedef uint32_t key_perm_t;
#line 32 
struct key_type;
#line 85  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
struct key_tag {
   struct callback_head rcu ;
   refcount_t usage ;
   bool removed ;
};
#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
struct __anonstruct_582 {
   u16 desc_len ;
   char desc[6U] ;
};
#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
union __anonunion_581 {
   struct __anonstruct_582 __anonCompField___anonunion_581_103 ;
   unsigned long x ;
};
#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
struct keyring_index_key {
   unsigned long hash ;
   union __anonunion_581 __anonCompField_keyring_index_key_104 ;
   struct key_type *type ;
   struct key_tag *domain_tag ;
   char *description ;
};
#line 111  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
union key_payload {
   void *rcu_data0 ;
   void *data[4U] ;
};
#line 153  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
struct key_restriction {
   int (*check)(struct key *, struct key_type *, union key_payload *, struct key *) ;
   struct key *key ;
   struct key_type *keytype ;
};
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
union __anonunion_583 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 172 
struct key_user;
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
union __anonunion_584 {
   time64_t expiry ;
   time64_t revoked_at ;
};
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
struct __anonstruct_586 {
   unsigned long hash ;
   unsigned long len_desc ;
   struct key_type *type ;
   struct key_tag *domain_tag ;
   char *description ;
};
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
union __anonunion_585 {
   struct keyring_index_key index_key ;
   struct __anonstruct_586 __anonCompField___anonunion_585_107 ;
};
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
struct __anonstruct_588 {
   struct list_head name_link ;
   struct assoc_array keys ;
};
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
union __anonunion_587 {
   union key_payload payload ;
   struct __anonstruct_588 __anonCompField___anonunion_587_109 ;
};
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
struct key {
   refcount_t usage ;
   key_serial_t serial ;
   union __anonunion_583 __anonCompField_key_105 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_584 __anonCompField_key_106 ;
   time64_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   short state ;
   unsigned long flags ;
   union __anonunion_585 __anonCompField_key_108 ;
   union __anonunion_587 __anonCompField_key_110 ;
   struct key_restriction *restrict_link ;
};
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/user.h"
struct user_struct {
   refcount_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   unsigned long unix_inflight ;
   atomic_long_t pipe_bufs ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
   struct ratelimit_state ratelimit ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cred.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   kgid_t gid[0U] ;
} __attribute__((__designated_init__));
#line 111  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cred.h"
union __anonunion_591 {
   int non_rcu ;
   struct callback_head rcu ;
};
#line 111  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   kernel_cap_t cap_ambient ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   union __anonunion_591 __anonCompField_cred_111 ;
} __attribute__((__designated_init__));
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/seq_file.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations *op ;
   int poll_event ;
   struct file *file ;
   void *private ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file *, loff_t *) ;
   void (*stop)(struct seq_file *, void *) ;
   void *(*next)(struct seq_file *, void *, loff_t *) ;
   int (*show)(struct seq_file *, void *) ;
};
#line 275  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/net_namespace.h"
struct __anonstruct_possible_net_t_592 {
   struct net *net ;
};
#line 275  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_592 possible_net_t;
#line 58  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
#line 78  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
#line 119  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};
#line 141  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};
#line 157  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
#line 168  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct dcbnl_buffer {
   __u8 prio2buffer[8U] ;
   __u32 buffer_size[8U] ;
   __u32 total_size ;
};
#line 190  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
#line 207  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
#line 244  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
#line 259  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_setets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_getmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_setmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_getqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_setqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_getqcnstats)(struct net_device *, struct ieee_qcn_stats *) ;
   int (*ieee_getpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_setpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_getapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_setapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_delapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_peer_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_peer_getpfc)(struct net_device *, struct ieee_pfc *) ;
   u8 (*getstate)(struct net_device *) ;
   u8 (*setstate)(struct net_device *, u8 ) ;
   void (*getpermhwaddr)(struct net_device *, u8 *) ;
   void (*setpgtccfgtx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgtx)(struct net_device *, int , u8 ) ;
   void (*setpgtccfgrx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgrx)(struct net_device *, int , u8 ) ;
   void (*getpgtccfgtx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgtx)(struct net_device *, int , u8 *) ;
   void (*getpgtccfgrx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgrx)(struct net_device *, int , u8 *) ;
   void (*setpfccfg)(struct net_device *, int , u8 ) ;
   void (*getpfccfg)(struct net_device *, int , u8 *) ;
   u8 (*setall)(struct net_device *) ;
   u8 (*getcap)(struct net_device *, int , u8 *) ;
   int (*getnumtcs)(struct net_device *, int , u8 *) ;
   int (*setnumtcs)(struct net_device *, int , u8 ) ;
   u8 (*getpfcstate)(struct net_device *) ;
   void (*setpfcstate)(struct net_device *, u8 ) ;
   void (*getbcncfg)(struct net_device *, int , u32 *) ;
   void (*setbcncfg)(struct net_device *, int , u32 ) ;
   void (*getbcnrp)(struct net_device *, int , u8 *) ;
   void (*setbcnrp)(struct net_device *, int , u8 ) ;
   int (*setapp)(struct net_device *, u8 , u16 , u8 ) ;
   int (*getapp)(struct net_device *, u8 , u16 ) ;
   u8 (*getfeatcfg)(struct net_device *, int , u8 *) ;
   u8 (*setfeatcfg)(struct net_device *, int , u8 ) ;
   u8 (*getdcbx)(struct net_device *) ;
   u8 (*setdcbx)(struct net_device *, u8 ) ;
   int (*peer_getappinfo)(struct net_device *, struct dcb_peer_app_info *, u16 *) ;
   int (*peer_getapptable)(struct net_device *, struct dcb_app *) ;
   int (*cee_peer_getpg)(struct net_device *, struct cee_pg *) ;
   int (*cee_peer_getpfc)(struct net_device *, struct cee_pfc *) ;
   int (*dcbnl_getbuffer)(struct net_device *, struct dcbnl_buffer *) ;
   int (*dcbnl_setbuffer)(struct net_device *, struct dcbnl_buffer *) ;
};
#line 41  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/taskstats.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
   __u64 thrashing_count ;
   __u64 thrashing_delay_total ;
};
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/cgroupstats.h"
struct mnt_namespace;
#line 60 
struct uts_namespace;
#line 61 
struct ipc_namespace;
#line 62 
struct cgroup_namespace;
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/nsproxy.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
   struct cgroup_namespace *cgroup_ns ;
};
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/user_namespace.h"
struct uid_gid_extent {
   u32 first ;
   u32 lower_first ;
   u32 count ;
};
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/user_namespace.h"
struct __anonstruct_594 {
   struct uid_gid_extent *forward ;
   struct uid_gid_extent *reverse ;
};
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/user_namespace.h"
union __anonunion_593 {
   struct uid_gid_extent extent[5U] ;
   struct __anonstruct_594 __anonCompField___anonunion_593_112 ;
};
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/user_namespace.h"
struct uid_gid_map {
   u32 nr_extents ;
   union __anonunion_593 __anonCompField_uid_gid_map_113 ;
};
#line 55  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/user_namespace.h"
struct user_namespace {
   struct uid_gid_map uid_map ;
   struct uid_gid_map gid_map ;
   struct uid_gid_map projid_map ;
   atomic_t count ;
   struct user_namespace *parent ;
   int level ;
   kuid_t owner ;
   kgid_t group ;
   struct ns_common ns ;
   unsigned long flags ;
   struct list_head keyring_name_list ;
   struct key *user_keyring_register ;
   struct rw_semaphore keyring_sem ;
   struct key *persistent_keyring_register ;
   struct work_struct work ;
   struct ctl_table_set set ;
   struct ctl_table_header *sysctls ;
   struct ucounts *ucounts ;
   int ucount_max[9U] ;
} __attribute__((__designated_init__));
#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/user_namespace.h"
struct ucounts {
   struct hlist_node node ;
   struct user_namespace *ns ;
   kuid_t uid ;
   int count ;
   atomic_t ucount[9U] ;
};
#line 65  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct bpf_insn {
   __u8 code ;
   __u8 dst_reg : 4 ;
   __u8 src_reg : 4 ;
   __s16 off ;
   __s32 imm ;
};
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct bpf_cgroup_storage_key {
   __u64 cgroup_inode_id ;
   __u32 attach_type ;
};
#line 110 
enum bpf_map_type {
    BPF_MAP_TYPE_UNSPEC = 0,
    BPF_MAP_TYPE_HASH = 1,
    BPF_MAP_TYPE_ARRAY = 2,
    BPF_MAP_TYPE_PROG_ARRAY = 3,
    BPF_MAP_TYPE_PERF_EVENT_ARRAY = 4,
    BPF_MAP_TYPE_PERCPU_HASH = 5,
    BPF_MAP_TYPE_PERCPU_ARRAY = 6,
    BPF_MAP_TYPE_STACK_TRACE = 7,
    BPF_MAP_TYPE_CGROUP_ARRAY = 8,
    BPF_MAP_TYPE_LRU_HASH = 9,
    BPF_MAP_TYPE_LRU_PERCPU_HASH = 10,
    BPF_MAP_TYPE_LPM_TRIE = 11,
    BPF_MAP_TYPE_ARRAY_OF_MAPS = 12,
    BPF_MAP_TYPE_HASH_OF_MAPS = 13,
    BPF_MAP_TYPE_DEVMAP = 14,
    BPF_MAP_TYPE_SOCKMAP = 15,
    BPF_MAP_TYPE_CPUMAP = 16,
    BPF_MAP_TYPE_XSKMAP = 17,
    BPF_MAP_TYPE_SOCKHASH = 18,
    BPF_MAP_TYPE_CGROUP_STORAGE = 19,
    BPF_MAP_TYPE_REUSEPORT_SOCKARRAY = 20,
    BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE = 21,
    BPF_MAP_TYPE_QUEUE = 22,
    BPF_MAP_TYPE_STACK = 23,
    BPF_MAP_TYPE_SK_STORAGE = 24,
    BPF_MAP_TYPE_DEVMAP_HASH = 25
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_596 {
   __u32 map_type ;
   __u32 key_size ;
   __u32 value_size ;
   __u32 max_entries ;
   __u32 map_flags ;
   __u32 inner_map_fd ;
   __u32 numa_node ;
   char map_name[16U] ;
   __u32 map_ifindex ;
   __u32 btf_fd ;
   __u32 btf_key_type_id ;
   __u32 btf_value_type_id ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
union __anonunion_598 {
   __u64 value ;
   __u64 next_key ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_597 {
   __u32 map_fd ;
   __u64 key ;
   union __anonunion_598 __anonCompField___anonstruct_597_116 ;
   __u64 flags ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_599 {
   __u32 prog_type ;
   __u32 insn_cnt ;
   __u64 insns ;
   __u64 license ;
   __u32 log_level ;
   __u32 log_size ;
   __u64 log_buf ;
   __u32 kern_version ;
   __u32 prog_flags ;
   char prog_name[16U] ;
   __u32 prog_ifindex ;
   __u32 expected_attach_type ;
   __u32 prog_btf_fd ;
   __u32 func_info_rec_size ;
   __u64 func_info ;
   __u32 func_info_cnt ;
   __u32 line_info_rec_size ;
   __u64 line_info ;
   __u32 line_info_cnt ;
   __u32 attach_btf_id ;
   __u32 attach_prog_fd ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_600 {
   __u64 pathname ;
   __u32 bpf_fd ;
   __u32 file_flags ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_601 {
   __u32 target_fd ;
   __u32 attach_bpf_fd ;
   __u32 attach_type ;
   __u32 attach_flags ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_test_602 {
   __u32 prog_fd ;
   __u32 retval ;
   __u32 data_size_in ;
   __u32 data_size_out ;
   __u64 data_in ;
   __u64 data_out ;
   __u32 repeat ;
   __u32 duration ;
   __u32 ctx_size_in ;
   __u32 ctx_size_out ;
   __u64 ctx_in ;
   __u64 ctx_out ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
union __anonunion_604 {
   __u32 start_id ;
   __u32 prog_id ;
   __u32 map_id ;
   __u32 btf_id ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_603 {
   union __anonunion_604 __anonCompField___anonstruct_603_121 ;
   __u32 next_id ;
   __u32 open_flags ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_info_605 {
   __u32 bpf_fd ;
   __u32 info_len ;
   __u64 info ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_query_606 {
   __u32 target_fd ;
   __u32 attach_type ;
   __u32 query_flags ;
   __u32 attach_flags ;
   __u64 prog_ids ;
   __u32 prog_cnt ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_raw_tracepoint_607 {
   __u64 name ;
   __u32 prog_fd ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_608 {
   __u64 btf ;
   __u64 btf_log_buf ;
   __u32 btf_size ;
   __u32 btf_log_size ;
   __u32 btf_log_level ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_task_fd_query_609 {
   __u32 pid ;
   __u32 fd ;
   __u32 flags ;
   __u32 buf_len ;
   __u64 buf ;
   __u32 prog_id ;
   __u32 fd_type ;
   __u64 probe_offset ;
   __u64 probe_addr ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
union bpf_attr {
   struct __anonstruct_596 __anonCompField_bpf_attr_115 ;
   struct __anonstruct_597 __anonCompField_bpf_attr_117 ;
   struct __anonstruct_599 __anonCompField_bpf_attr_118 ;
   struct __anonstruct_600 __anonCompField_bpf_attr_119 ;
   struct __anonstruct_601 __anonCompField_bpf_attr_120 ;
   struct __anonstruct_test_602 test ;
   struct __anonstruct_603 __anonCompField_bpf_attr_122 ;
   struct __anonstruct_info_605 info ;
   struct __anonstruct_query_606 query ;
   struct __anonstruct_raw_tracepoint_607 raw_tracepoint ;
   struct __anonstruct_608 __anonCompField_bpf_attr_123 ;
   struct __anonstruct_task_fd_query_609 task_fd_query ;
} __attribute__((__aligned__(8)));
#line 3653  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct bpf_func_info {
   __u32 insn_off ;
   __u32 type_id ;
};
#line 3661  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct bpf_line_info {
   __u32 insn_off ;
   __u32 file_name_off ;
   __u32 line_off ;
   __u32 line_col ;
};
#line 40  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rbtree_latch.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};
#line 215 
struct bpf_prog_aux;
#line 216 
struct bpf_map;
#line 217 
struct btf;
#line 218 
struct btf_type;
#line 37  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_map_ops {
   int (*map_alloc_check)(union bpf_attr *) ;
   struct bpf_map *(*map_alloc)(union bpf_attr *) ;
   void (*map_release)(struct bpf_map *, struct file *) ;
   void (*map_free)(struct bpf_map *) ;
   int (*map_get_next_key)(struct bpf_map *, void *, void *) ;
   void (*map_release_uref)(struct bpf_map *) ;
   void *(*map_lookup_elem_sys_only)(struct bpf_map *, void *) ;
   void *(*map_lookup_elem)(struct bpf_map *, void *) ;
   int (*map_update_elem)(struct bpf_map *, void *, void *, u64 ) ;
   int (*map_delete_elem)(struct bpf_map *, void *) ;
   int (*map_push_elem)(struct bpf_map *, void *, u64 ) ;
   int (*map_pop_elem)(struct bpf_map *, void *) ;
   int (*map_peek_elem)(struct bpf_map *, void *) ;
   void *(*map_fd_get_ptr)(struct bpf_map *, struct file *, int ) ;
   void (*map_fd_put_ptr)(void *) ;
   u32 (*map_gen_lookup)(struct bpf_map *, struct bpf_insn *) ;
   u32 (*map_fd_sys_lookup_elem)(void *) ;
   void (*map_seq_show_elem)(struct bpf_map *, void *, struct seq_file *) ;
   int (*map_check_btf)(struct bpf_map *, struct btf *, struct btf_type *, struct btf_type *) ;
   int (*map_poke_track)(struct bpf_map *, struct bpf_prog_aux *) ;
   void (*map_poke_untrack)(struct bpf_map *, struct bpf_prog_aux *) ;
   void (*map_poke_run)(struct bpf_map *, u32 , struct bpf_prog *, struct bpf_prog *) ;
   int (*map_direct_value_addr)(struct bpf_map *, u64 *, u32 ) ;
   int (*map_direct_value_meta)(struct bpf_map *, u64 , u32 *) ;
   int (*map_mmap)(struct bpf_map *, struct vm_area_struct *) ;
};
#line 82  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_map_memory {
   u32 pages ;
   struct user_struct *user ;
};
#line 87  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_map {
   struct bpf_map_ops *ops ;
   struct bpf_map *inner_map_meta ;
   void *security ;
   enum bpf_map_type map_type ;
   u32 key_size ;
   u32 value_size ;
   u32 max_entries ;
   u32 map_flags ;
   int spin_lock_off ;
   u32 id ;
   int numa_node ;
   u32 btf_key_type_id ;
   u32 btf_value_type_id ;
   struct btf *btf ;
   struct bpf_map_memory memory ;
   char name[16U] ;
   bool unpriv_array ;
   bool frozen ;
   atomic64_t refcnt ;
   atomic64_t usercnt ;
   struct work_struct work ;
   struct mutex freeze_mutex ;
   u64 writecnt ;
};
#line 151 
struct bpf_offload_dev;
#line 152 
struct bpf_offloaded_map;
#line 156  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_map_dev_ops {
   int (*map_get_next_key)(struct bpf_offloaded_map *, void *, void *) ;
   int (*map_lookup_elem)(struct bpf_offloaded_map *, void *, void *) ;
   int (*map_update_elem)(struct bpf_offloaded_map *, void *, void *, u64 ) ;
   int (*map_delete_elem)(struct bpf_offloaded_map *, void *) ;
};
#line 166  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_offloaded_map {
   struct bpf_map map ;
   struct net_device *netdev ;
   struct bpf_map_dev_ops *dev_ops ;
   void *dev_priv ;
   struct list_head offloads ;
};
#line 327  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_prog_ops {
   int (*test_run)(struct bpf_prog *, union bpf_attr *, union bpf_attr *) ;
};
#line 369  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_prog_offload {
   struct bpf_prog *prog ;
   struct net_device *netdev ;
   struct bpf_offload_dev *offdev ;
   void *dev_priv ;
   struct list_head offloads ;
   bool dev_state ;
   bool opt_failed ;
   void *jited_image ;
   u32 jited_len ;
};
#line 394  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_prog_stats {
   u64 cnt ;
   u64 nsecs ;
   struct u64_stats_sync syncp ;
} __attribute__((__aligned__(16)));
#line 400  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct btf_func_model {
   u8 ret_size ;
   u8 nr_args ;
   u8 arg_size[12U] ;
};
#line 447 
enum bpf_tramp_prog_type {
    BPF_TRAMP_FENTRY = 0,
    BPF_TRAMP_FEXIT = 1,
    BPF_TRAMP_MAX = 2
};
#line 454  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct __anonstruct_func_642 {
   struct btf_func_model model ;
   void *addr ;
   bool ftrace_managed ;
};
#line 454  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_trampoline {
   struct hlist_node hlist ;
   struct mutex mutex ;
   refcount_t refcnt ;
   u64 key ;
   struct __anonstruct_func_642 func ;
   struct hlist_head progs_hlist[2U] ;
   int progs_cnt[2U] ;
   void *image ;
   u64 selector ;
};
#line 495  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_func_info_aux {
   bool unreliable ;
};
#line 504  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct __anonstruct_tail_call_644 {
   struct bpf_map *map ;
   u32 key ;
};
#line 504  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
union __anonunion_643 {
   struct __anonstruct_tail_call_644 tail_call ;
};
#line 504  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_jit_poke_descriptor {
   void *ip ;
   union __anonunion_643 __anonCompField_bpf_jit_poke_descriptor_148 ;
   bool ip_stable ;
   u8 adj_off ;
   u16 reason ;
};
#line 517  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
union __anonunion_645 {
   struct work_struct work ;
   struct callback_head rcu ;
};
#line 517  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_prog_aux {
   atomic64_t refcnt ;
   u32 used_map_cnt ;
   u32 max_ctx_offset ;
   u32 max_pkt_offset ;
   u32 max_tp_access ;
   u32 stack_depth ;
   u32 id ;
   u32 func_cnt ;
   u32 func_idx ;
   u32 attach_btf_id ;
   struct bpf_prog *linked_prog ;
   bool verifier_zext ;
   bool offload_requested ;
   bool attach_btf_trace ;
   bool func_proto_unreliable ;
   enum bpf_tramp_prog_type trampoline_prog_type ;
   struct bpf_trampoline *trampoline ;
   struct hlist_node tramp_hlist ;
   struct btf_type *attach_func_proto ;
   char *attach_func_name ;
   struct bpf_prog **func ;
   void *jit_data ;
   struct bpf_jit_poke_descriptor *poke_tab ;
   u32 size_poke_tab ;
   struct latch_tree_node ksym_tnode ;
   struct list_head ksym_lnode ;
   struct bpf_prog_ops *ops ;
   struct bpf_map **used_maps ;
   struct bpf_prog *prog ;
   struct user_struct *user ;
   u64 load_time ;
   struct bpf_map *cgroup_storage[2U] ;
   char name[16U] ;
   void *security ;
   struct bpf_prog_offload *offload ;
   struct btf *btf ;
   struct bpf_func_info *func_info ;
   struct bpf_func_info_aux *func_info_aux ;
   struct bpf_line_info *linfo ;
   void **jited_linfo ;
   u32 func_info_cnt ;
   u32 nr_linfo ;
   u32 linfo_idx ;
   u32 num_exentries ;
   struct exception_table_entry *extable ;
   struct bpf_prog_stats *stats ;
   union __anonunion_645 __anonCompField_bpf_prog_aux_149 ;
};
#line 686 
struct bpf_cgroup_storage;
#line 686  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_prog_array_item {
   struct bpf_prog *prog ;
   struct bpf_cgroup_storage *cgroup_storage[2U] ;
};
#line 691  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_prog_array {
   struct callback_head rcu ;
   struct bpf_prog_array_item items[0U] ;
};
#line 1335 
struct cgroup;
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf-cgroup.h"
struct bpf_cgroup_storage_map;
#line 37  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf-cgroup.h"
struct bpf_storage_buffer {
   struct callback_head rcu ;
   char data[0U] ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf-cgroup.h"
union __anonunion_647 {
   struct bpf_storage_buffer *buf ;
   void *percpu_buf ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf-cgroup.h"
struct bpf_cgroup_storage {
   union __anonunion_647 __anonCompField_bpf_cgroup_storage_151 ;
   struct bpf_cgroup_storage_map *map ;
   struct bpf_cgroup_storage_key key ;
   struct list_head list ;
   struct rb_node node ;
   struct callback_head rcu ;
};
#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf-cgroup.h"
struct cgroup_bpf {
   struct bpf_prog_array *effective[26U] ;
   struct list_head progs[26U] ;
   u32 flags[26U] ;
   struct bpf_prog_array *inactive ;
   struct percpu_ref refcnt ;
   struct work_struct release_work ;
};
#line 69  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kthread.h"
struct kthread_work;
#line 86  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kthread.h"
struct kthread_worker {
   unsigned int flags ;
   raw_spinlock_t lock ;
   struct list_head work_list ;
   struct list_head delayed_work_list ;
   struct task_struct *task ;
   struct kthread_work *current_work ;
};
#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kthread.h"
struct kthread_work {
   struct list_head node ;
   void (*func)(struct kthread_work *) ;
   struct kthread_worker *worker ;
   int canceling ;
};
#line 103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kthread.h"
struct kthread_delayed_work {
   struct kthread_work work ;
   struct timer_list timer ;
};
#line 199 
struct cgroup_subsys_state;
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/psi_types.h"
struct psi_group_cpu {
   seqcount_t seq ;
   unsigned int tasks[3U] ;
   u32 state_mask ;
   u32 times[6U] ;
   u64 state_start ;
   u32 times_prev[2U][6U] ;
};
#line 96 
struct psi_group;
#line 128  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/psi_types.h"
struct psi_group {
   struct mutex avgs_lock ;
   struct psi_group_cpu *pcpu ;
   u64 avg_total[5U] ;
   u64 avg_last_update ;
   u64 avg_next_update ;
   struct delayed_work avgs_work ;
   u64 total[2U][5U] ;
   unsigned long avg[5U][3U] ;
   atomic_t poll_scheduled ;
   struct kthread_worker *poll_kworker ;
   struct kthread_delayed_work poll_work ;
   struct mutex trigger_lock ;
   struct list_head triggers ;
   u32 nr_triggers[5U] ;
   u32 poll_states ;
   u64 poll_min_period ;
   u64 polling_total[5U] ;
   u64 polling_next_update ;
   u64 polling_until ;
};
#line 166 
struct cgroup_root;
#line 167 
struct cgroup_subsys;
#line 168 
struct cgroup_taskset;
#line 119  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cgroup_file {
   struct kernfs_node *kn ;
   unsigned long notified_at ;
   struct timer_list notify_timer ;
};
#line 133  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct list_head sibling ;
   struct list_head children ;
   struct list_head rstat_css_node ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   atomic_t online_cnt ;
   struct work_struct destroy_work ;
   struct rcu_work destroy_rwork ;
   struct cgroup_subsys_state *parent ;
};
#line 190  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct css_set {
   struct cgroup_subsys_state *subsys[14U] ;
   refcount_t refcount ;
   struct css_set *dom_cset ;
   struct cgroup *dfl_cgrp ;
   int nr_tasks ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head dying_tasks ;
   struct list_head task_iters ;
   struct list_head e_cset_node[14U] ;
   struct list_head threaded_csets ;
   struct list_head threaded_csets_node ;
   struct hlist_node hlist ;
   struct list_head cgrp_links ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct cgroup *mg_dst_cgrp ;
   struct css_set *mg_dst_cset ;
   bool dead ;
   struct callback_head callback_head ;
};
#line 279  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cgroup_base_stat {
   struct task_cputime cputime ;
};
#line 303  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cgroup_rstat_cpu {
   struct u64_stats_sync bsync ;
   struct cgroup_base_stat bstat ;
   struct cgroup_base_stat last_bstat ;
   struct cgroup *updated_children ;
   struct cgroup *updated_next ;
};
#line 332  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cgroup_freezer_state {
   bool freeze ;
   int e_freeze ;
   int nr_frozen_descendants ;
   int nr_frozen_tasks ;
};
#line 351  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int level ;
   int max_depth ;
   int nr_descendants ;
   int nr_dying_descendants ;
   int max_descendants ;
   int nr_populated_csets ;
   int nr_populated_domain_children ;
   int nr_populated_threaded_children ;
   int nr_threaded_children ;
   struct kernfs_node *kn ;
   struct cgroup_file procs_file ;
   struct cgroup_file events_file ;
   u16 subtree_control ;
   u16 subtree_ss_mask ;
   u16 old_subtree_control ;
   u16 old_subtree_ss_mask ;
   struct cgroup_subsys_state *subsys[14U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[14U] ;
   struct cgroup *dom_cgrp ;
   struct cgroup *old_dom_cgrp ;
   struct cgroup_rstat_cpu *rstat_cpu ;
   struct list_head rstat_css_list ;
   struct cgroup_base_stat last_bstat ;
   struct cgroup_base_stat bstat ;
   struct prev_cputime prev_cputime ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
   struct psi_group psi ;
   struct cgroup_bpf bpf ;
   atomic_t congestion_count ;
   struct cgroup_freezer_state freezer ;
   u64 ancestor_ids[] ;
};
#line 489  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   u64 cgrp_ancestor_id_storage ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 527  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   unsigned long private ;
   size_t max_write_len ;
   unsigned int flags ;
   unsigned int file_offset ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   int (*open)(struct kernfs_open_file *) ;
   void (*release)(struct kernfs_open_file *) ;
   u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *) ;
   s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *) ;
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64 ) ;
   int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64 ) ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   __poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *) ;
   struct lock_class_key lockdep_key ;
};
#line 616  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state *) ;
   int (*css_online)(struct cgroup_subsys_state *) ;
   void (*css_offline)(struct cgroup_subsys_state *) ;
   void (*css_released)(struct cgroup_subsys_state *) ;
   void (*css_free)(struct cgroup_subsys_state *) ;
   void (*css_reset)(struct cgroup_subsys_state *) ;
   void (*css_rstat_flush)(struct cgroup_subsys_state *, int ) ;
   int (*css_extra_stat_show)(struct seq_file *, struct cgroup_subsys_state *) ;
   int (*can_attach)(struct cgroup_taskset *) ;
   void (*cancel_attach)(struct cgroup_taskset *) ;
   void (*attach)(struct cgroup_taskset *) ;
   void (*post_attach)(void) ;
   int (*can_fork)(struct task_struct *) ;
   void (*cancel_fork)(struct task_struct *) ;
   void (*fork)(struct task_struct *) ;
   void (*exit)(struct task_struct *) ;
   void (*release)(struct task_struct *) ;
   void (*bind)(struct cgroup_subsys_state *) ;
   bool early_init : 1 ;
   bool implicit_on_dfl : 1 ;
   bool threaded : 1 ;
   bool broken_hierarchy : 1 ;
   bool warned_broken_hierarchy : 1 ;
   int id ;
   char *name ;
   char *legacy_name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
#line 848  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup.h"
struct cgroup_namespace {
   refcount_t count ;
   struct ns_common ns ;
   struct user_namespace *user_ns ;
   struct ucounts *ucounts ;
   struct css_set *root_cset ;
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netprio_cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp.h"
struct xdp_mem_info {
   u32 type ;
   u32 id ;
};
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp.h"
struct xdp_rxq_info {
   struct net_device *dev ;
   u32 queue_index ;
   u32 reg_state ;
   struct xdp_mem_info mem ;
} __attribute__((__aligned__(64)));
#line 75  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp.h"
struct xdp_frame {
   void *data ;
   u16 len ;
   u16 headroom ;
   u16 metasize ;
   struct xdp_mem_info mem ;
   struct net_device *dev_rx ;
};
#line 175 
struct netdev_bpf;
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/signal.h"
struct sighand_struct {
   spinlock_t siglock ;
   refcount_t count ;
   wait_queue_head_t signalfd_wqh ;
   struct k_sigaction action[64U] ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/signal.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   u64 ac_utime ;
   u64 ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/signal.h"
struct cpu_itimer {
   u64 expires ;
   u64 incr ;
};
#line 45  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/signal.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
#line 64  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/signal.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
};
#line 80 
struct tty_struct;
#line 80 
struct autogroup;
#line 80 
struct tty_audit_buf;
#line 80  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/signal.h"
struct signal_struct {
   refcount_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   struct hlist_head multiprocess ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned int is_child_subreaper : 1 ;
   unsigned int has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct posix_cputimers posix_cputimers ;
   struct pid *pids[4U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   u64 utime ;
   u64 stime ;
   u64 cutime ;
   u64 cstime ;
   u64 gtime ;
   u64 cgtime ;
   struct prev_cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
   bool oom_flag_origin ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mm_struct *oom_mm ;
   struct mutex cred_guard_mutex ;
} __attribute__((__designated_init__));
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 211  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
#line 74  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netlink.h"
struct netlink_ext_ack {
   char *_msg ;
   struct nlattr *bad_attr ;
   u8 cookie[20U] ;
   u8 cookie_len ;
};
#line 180  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netlink.h"
union __anonunion_672 {
   u8 ctx[48U] ;
   long args[6U] ;
};
#line 180  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr *nlh ;
   int (*dump)(struct sk_buff *, struct netlink_callback *) ;
   int (*done)(struct netlink_callback *) ;
   void *data ;
   struct module *module ;
   struct netlink_ext_ack *extack ;
   u16 family ;
   u16 min_dump_alloc ;
   bool strict_check ;
   u16 answer_flags ;
   unsigned int prev_seq ;
   unsigned int seq ;
   union __anonunion_672 __anonCompField_netlink_callback_154 ;
};
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/neighbour.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
   __u64 rx_nohandler ;
};
#line 753  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if_link.h"
struct ifla_vf_guid {
   __u32 vf ;
   __u64 guid ;
};
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
};
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
   __u32 trusted ;
   __be16 vlan_proto ;
};
#line 118  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/hashtable.h"
struct netpoll_info;
#line 119 
struct phy_device;
#line 120 
struct dsa_port;
#line 121 
struct sfp_bus;
#line 122 
struct wireless_dev;
#line 123 
struct wpan_dev;
#line 124 
struct mpls_dev;
#line 69  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = -2147483648,
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16
};
#line 75  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 217  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 237  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct hh_cache {
   unsigned int hh_len ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
#line 263  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff *, struct net_device *, unsigned short , void *, void *, unsigned int ) ;
   int (*parse)(struct sk_buff *, unsigned char *) ;
   int (*cache)(struct neighbour *, struct hh_cache *, __be16 ) ;
   void (*cache_update)(struct hh_cache *, struct net_device *, unsigned char *) ;
   bool (*validate)(char *, unsigned int ) ;
   __be16 (*parse_protocol)(struct sk_buff *) ;
};
#line 372 
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
};
#line 379  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;
#line 421  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);
#line 589  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   unsigned long tx_maxrate ;
   unsigned long trans_timeout ;
   struct net_device *sb_dev ;
   struct xdp_umem *umem ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long state ;
   struct dql dql ;
} __attribute__((__aligned__(64)));
#line 662  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
#line 674  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
#line 684  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
#line 736  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
   struct xdp_rxq_info xdp_rxq ;
   struct xdp_umem *umem ;
} __attribute__((__aligned__(64)));
#line 764  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
#line 777  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *attr_map[0U] ;
};
#line 793  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
#line 803  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
#line 820  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
#line 833 
enum tc_setup_type {
    TC_SETUP_QDISC_MQPRIO = 0,
    TC_SETUP_CLSU32 = 1,
    TC_SETUP_CLSFLOWER = 2,
    TC_SETUP_CLSMATCHALL = 3,
    TC_SETUP_CLSBPF = 4,
    TC_SETUP_BLOCK = 5,
    TC_SETUP_QDISC_CBS = 6,
    TC_SETUP_QDISC_RED = 7,
    TC_SETUP_QDISC_PRIO = 8,
    TC_SETUP_QDISC_MQ = 9,
    TC_SETUP_QDISC_ETF = 10,
    TC_SETUP_ROOT_QDISC = 11,
    TC_SETUP_QDISC_GRED = 12,
    TC_SETUP_QDISC_TAPRIO = 13,
    TC_SETUP_FT = 14
};
#line 851 
enum bpf_netdev_command {
    XDP_SETUP_PROG = 0,
    XDP_SETUP_PROG_HW = 1,
    XDP_QUERY_PROG = 2,
    XDP_QUERY_PROG_HW = 3,
    BPF_OFFLOAD_MAP_ALLOC = 4,
    BPF_OFFLOAD_MAP_FREE = 5,
    XDP_SETUP_XSK_UMEM = 6
};
#line 879  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct __anonstruct_677 {
   u32 flags ;
   struct bpf_prog *prog ;
   struct netlink_ext_ack *extack ;
};
#line 879  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct __anonstruct_678 {
   u32 prog_id ;
   u32 prog_flags ;
};
#line 879  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct __anonstruct_679 {
   struct bpf_offloaded_map *offmap ;
};
#line 879  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct __anonstruct_xsk_680 {
   struct xdp_umem *umem ;
   u16 queue_id ;
};
#line 879  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
union __anonunion_676 {
   struct __anonstruct_677 __anonCompField___anonunion_676_156 ;
   struct __anonstruct_678 __anonCompField___anonunion_676_157 ;
   struct __anonstruct_679 __anonCompField___anonunion_676_158 ;
   struct __anonstruct_xsk_680 xsk ;
};
#line 879  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_bpf {
   enum bpf_netdev_command command ;
   union __anonunion_676 __anonCompField_netdev_bpf_159 ;
};
#line 911  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct xfrmdev_ops {
   int (*xdo_dev_state_add)(struct xfrm_state *) ;
   void (*xdo_dev_state_delete)(struct xfrm_state *) ;
   void (*xdo_dev_state_free)(struct xfrm_state *) ;
   bool (*xdo_dev_offload_ok)(struct sk_buff *, struct xfrm_state *) ;
   void (*xdo_dev_state_advance_esn)(struct xfrm_state *) ;
};
#line 921  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct dev_ifalias {
   struct callback_head rcuhead ;
   char ifalias[] ;
};
#line 926 
struct tlsdev_ops;
#line 929  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_name_node {
   struct hlist_node hlist ;
   struct list_head list ;
   struct net_device *dev ;
   char *name ;
};
#line 1257 
struct devlink_port;
#line 1257  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device *) ;
   void (*ndo_uninit)(struct net_device *) ;
   int (*ndo_open)(struct net_device *) ;
   int (*ndo_stop)(struct net_device *) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t ) ;
   u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, struct net_device *) ;
   void (*ndo_change_rx_flags)(struct net_device *, int ) ;
   void (*ndo_set_rx_mode)(struct net_device *) ;
   int (*ndo_set_mac_address)(struct net_device *, void *) ;
   int (*ndo_validate_addr)(struct net_device *) ;
   int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int ) ;
   int (*ndo_set_config)(struct net_device *, struct ifmap *) ;
   int (*ndo_change_mtu)(struct net_device *, int ) ;
   int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *) ;
   void (*ndo_tx_timeout)(struct net_device *) ;
   void (*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *) ;
   bool (*ndo_has_offload_stats)(struct net_device *, int ) ;
   int (*ndo_get_offload_stats)(int , struct net_device *, void *) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device *) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16 , u16 ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16 , u16 ) ;
   void (*ndo_poll_controller)(struct net_device *) ;
   int (*ndo_netpoll_setup)(struct net_device *, struct netpoll_info *) ;
   void (*ndo_netpoll_cleanup)(struct net_device *) ;
   int (*ndo_set_vf_mac)(struct net_device *, int , u8 *) ;
   int (*ndo_set_vf_vlan)(struct net_device *, int , u16 , u8 , __be16 ) ;
   int (*ndo_set_vf_rate)(struct net_device *, int , int , int ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device *, int , bool ) ;
   int (*ndo_set_vf_trust)(struct net_device *, int , bool ) ;
   int (*ndo_get_vf_config)(struct net_device *, int , struct ifla_vf_info *) ;
   int (*ndo_set_vf_link_state)(struct net_device *, int , int ) ;
   int (*ndo_get_vf_stats)(struct net_device *, int , struct ifla_vf_stats *) ;
   int (*ndo_set_vf_port)(struct net_device *, int , struct nlattr **) ;
   int (*ndo_get_vf_port)(struct net_device *, int , struct sk_buff *) ;
   int (*ndo_get_vf_guid)(struct net_device *, int , struct ifla_vf_guid *, struct ifla_vf_guid *) ;
   int (*ndo_set_vf_guid)(struct net_device *, int , u64 , int ) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device *, int , bool ) ;
   int (*ndo_setup_tc)(struct net_device *, enum tc_setup_type , void *) ;
   int (*ndo_fcoe_enable)(struct net_device *) ;
   int (*ndo_fcoe_disable)(struct net_device *) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device *, u16 ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device *, struct netdev_fcoe_hbainfo *) ;
   int (*ndo_fcoe_get_wwn)(struct net_device *, u64 *, int ) ;
   int (*ndo_rx_flow_steer)(struct net_device *, struct sk_buff *, u16 , u32 ) ;
   int (*ndo_add_slave)(struct net_device *, struct net_device *, struct netlink_ext_ack *) ;
   int (*ndo_del_slave)(struct net_device *, struct net_device *) ;
   netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_set_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_neigh_construct)(struct net_device *, struct neighbour *) ;
   void (*ndo_neigh_destroy)(struct net_device *, struct neighbour *) ;
   int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char *, u16 , u16 , struct netlink_ext_ack *) ;
   int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char *, u16 ) ;
   int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int *) ;
   int (*ndo_fdb_get)(struct sk_buff *, struct nlattr **, struct net_device *, unsigned char *, u16 , u32 , u32 , struct netlink_ext_ack *) ;
   int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16 , struct netlink_ext_ack *) ;
   int (*ndo_bridge_getlink)(struct sk_buff *, u32 , u32 , struct net_device *, u32 , int ) ;
   int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_change_carrier)(struct net_device *, bool ) ;
   int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *) ;
   int (*ndo_get_port_parent_id)(struct net_device *, struct netdev_phys_item_id *) ;
   int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t ) ;
   void (*ndo_udp_tunnel_add)(struct net_device *, struct udp_tunnel_info *) ;
   void (*ndo_udp_tunnel_del)(struct net_device *, struct udp_tunnel_info *) ;
   void *(*ndo_dfwd_add_station)(struct net_device *, struct net_device *) ;
   void (*ndo_dfwd_del_station)(struct net_device *, void *) ;
   int (*ndo_set_tx_maxrate)(struct net_device *, int , u32 ) ;
   int (*ndo_get_iflink)(struct net_device *) ;
   int (*ndo_change_proto_down)(struct net_device *, bool ) ;
   int (*ndo_fill_metadata_dst)(struct net_device *, struct sk_buff *) ;
   void (*ndo_set_rx_headroom)(struct net_device *, int ) ;
   int (*ndo_bpf)(struct net_device *, struct netdev_bpf *) ;
   int (*ndo_xdp_xmit)(struct net_device *, int , struct xdp_frame **, u32 ) ;
   int (*ndo_xsk_wakeup)(struct net_device *, u32 , u32 ) ;
   struct devlink_port *(*ndo_get_devlink_port)(struct net_device *) ;
};
#line 1492 
enum ldv_15039 {
    NETREG_UNINITIALIZED = 0,
    NETREG_REGISTERED = 1,
    NETREG_UNREGISTERING = 2,
    NETREG_UNREGISTERED = 3,
    NETREG_RELEASED = 4,
    NETREG_DUMMY = 5
};
#line 1501 
enum ldv_15040 {
    RTNL_LINK_INITIALIZED = 0,
    RTNL_LINK_INITIALIZING = 1
};
#line 1795  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct __anonstruct_adj_list_681 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1795 
struct iw_handler_def;
#line 1795 
struct iw_public_data;
#line 1795 
struct vlan_info;
#line 1795 
struct tipc_bearer;
#line 1795 
struct in_device;
#line 1795 
struct dn_dev;
#line 1795 
struct cpu_rmap;
#line 1795 
struct pcpu_lstats;
#line 1795 
struct pcpu_sw_netstats;
#line 1795 
struct pcpu_dstats;
#line 1795  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
union __anonunion_682 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
};
#line 1795 
struct garp_port;
#line 1795 
struct mrp_port;
#line 1795  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct netdev_name_node *name_node ;
   struct dev_ifalias *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_681 adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   netdev_features_t gso_partial_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   atomic_long_t rx_nohandler ;
   atomic_t carrier_up_count ;
   atomic_t carrier_down_count ;
   struct iw_handler_def *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops *netdev_ops ;
   struct ethtool_ops *ethtool_ops ;
   struct l3mdev_ops *l3mdev_ops ;
   struct ndisc_ops *ndisc_ops ;
   struct xfrmdev_ops *xfrmdev_ops ;
   struct tlsdev_ops *tlsdev_ops ;
   struct header_ops *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned int min_mtu ;
   unsigned int max_mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned char min_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned char upper_level ;
   unsigned char lower_level ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_port *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   struct bpf_prog *xdp_prog ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct mini_Qdisc *miniq_ingress ;
   struct netdev_queue *ingress_queue ;
   struct nf_hook_entries *nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   struct hlist_head qdisc_hash[16U] ;
   unsigned int tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_cpus_map ;
   struct xps_dev_maps *xps_rxqs_map ;
   struct mini_Qdisc *miniq_egress ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   enum ldv_15039 reg_state : 8 ;
   bool dismantle ;
   enum ldv_15040 rtnl_link_state : 16 ;
   bool needs_free_netdev ;
   void (*priv_destructor)(struct net_device *) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion_682 __anonCompField_net_device_160 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group *sysfs_groups[4U] ;
   struct attribute_group *sysfs_rx_queue_group ;
   struct rtnl_link_ops *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   struct dcbnl_rtnl_ops *dcbnl_ops ;
   s16 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct sfp_bus *sfp_bus ;
   struct lock_class_key qdisc_tx_busylock_key ;
   struct lock_class_key qdisc_running_key ;
   struct lock_class_key qdisc_xmit_lock_key ;
   struct lock_class_key addr_list_lock_key ;
   bool proto_down ;
   unsigned int wol_enabled : 1 ;
};
#line 2400  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
} __attribute__((__aligned__(32)));
#line 2408  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct pcpu_lstats {
   u64_stats_t packets ;
   u64_stats_t bytes ;
   struct u64_stats_sync syncp ;
} __attribute__((__aligned__(16)));
#line 326  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/mdio.h"
struct gpio_desc;
#line 327 
struct mii_bus;
#line 26  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mdio.h"
struct reset_control;
#line 26  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mdio.h"
struct mdio_device {
   struct device dev ;
   struct mii_bus *bus ;
   char modalias[32U] ;
   int (*bus_match)(struct device *, struct device_driver *) ;
   void (*device_free)(struct mdio_device *) ;
   void (*device_remove)(struct mdio_device *) ;
   int addr ;
   int flags ;
   struct gpio_desc *reset_gpio ;
   struct reset_control *reset_ctrl ;
   unsigned int reset_assert_delay ;
   unsigned int reset_deassert_delay ;
};
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mdio.h"
struct mdio_driver_common {
   struct device_driver driver ;
   int flags ;
};
#line 120  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mdio.h"
struct mdio_if_info {
   int prtad ;
   u32 mmds ;
   unsigned int mode_support ;
   struct net_device *dev ;
   int (*mdio_read)(struct net_device *, int , int , u16 ) ;
   int (*mdio_write)(struct net_device *, int , int , u16 , u16 ) ;
};
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/vdso.h"
struct vdso_image {
   void *data ;
   unsigned long size ;
   unsigned long alt ;
   unsigned long alt_len ;
   long sym_vvar_start ;
   long sym_vvar_page ;
   long sym_pvclock_page ;
   long sym_hvclock_page ;
   long sym_VDSO32_NOTE_MASK ;
   long sym___kernel_sigreturn ;
   long sym___kernel_rt_sigreturn ;
   long sym___kernel_vsyscall ;
   long sym_int80_landing_pad ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
typedef __u64 Elf64_Off;
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 192  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 200  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 221  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
struct elf64_hdr {
   unsigned char e_ident[16U] ;
   Elf64_Half e_type ;
   Elf64_Half e_machine ;
   Elf64_Word e_version ;
   Elf64_Addr e_entry ;
   Elf64_Off e_phoff ;
   Elf64_Off e_shoff ;
   Elf64_Word e_flags ;
   Elf64_Half e_ehsize ;
   Elf64_Half e_phentsize ;
   Elf64_Half e_phnum ;
   Elf64_Half e_shentsize ;
   Elf64_Half e_shnum ;
   Elf64_Half e_shstrndx ;
};
#line 237  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
typedef struct elf64_hdr Elf64_Ehdr;
#line 316  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
struct elf64_shdr {
   Elf64_Word sh_name ;
   Elf64_Word sh_type ;
   Elf64_Xword sh_flags ;
   Elf64_Addr sh_addr ;
   Elf64_Off sh_offset ;
   Elf64_Xword sh_size ;
   Elf64_Word sh_link ;
   Elf64_Word sh_info ;
   Elf64_Xword sh_addralign ;
   Elf64_Xword sh_entsize ;
};
#line 328  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
typedef struct elf64_shdr Elf64_Shdr;
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/elf.h"
struct kernel_param;
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/moduleparam.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char *, struct kernel_param *) ;
   int (*get)(char *, struct kernel_param *) ;
   void (*free)(void *) ;
};
#line 69 
struct kparam_string;
#line 69 
struct kparam_array;
#line 69  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/moduleparam.h"
union __anonunion_702 {
   void *arg ;
   struct kparam_string *str ;
   struct kparam_array *arr ;
};
#line 69  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/moduleparam.h"
struct kernel_param {
   char *name ;
   struct module *mod ;
   struct kernel_param_ops *ops ;
   u16 perm ;
   s8 level ;
   u8 flags ;
   union __anonunion_702 __anonCompField_kernel_param_161 ;
};
#line 86  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 92  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops *ops ;
   void *elem ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/error-injection.h"
struct error_injection_entry {
   unsigned long addr ;
   int etype ;
};
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/module.h"
struct mod_arch_specific {
   unsigned int num_orcs ;
   int *orc_unwind_ip ;
   struct orc_entry *orc_unwind ;
};
#line 45  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/module.h"
struct module_param_attrs;
#line 45  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
} __attribute__((__designated_init__));
#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *) ;
   ssize_t (*store)(struct module_attribute *, struct module_kobject *, char *, size_t ) ;
   void (*setup)(struct module *, char *) ;
   int (*test)(struct module *) ;
   void (*free)(struct module *) ;
};
#line 297 
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
};
#line 305  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
#line 310  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/module.h"
struct module_layout {
   void *base ;
   unsigned int size ;
   unsigned int text_size ;
   unsigned int ro_size ;
   unsigned int ro_after_init_size ;
   struct mod_tree_node mtn ;
};
#line 334  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/module.h"
struct mod_kallsyms {
   Elf64_Sym *symtab ;
   unsigned int num_symtab ;
   char *strtab ;
   char *typetab ;
};
#line 342  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/module.h"
struct klp_modinfo {
   Elf64_Ehdr hdr ;
   Elf64_Shdr *sechdrs ;
   char *secstrings ;
   unsigned int symndx ;
};
#line 350 
struct module_sect_attrs;
#line 350 
struct module_notes_attrs;
#line 350 
struct trace_event_call;
#line 350  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char *version ;
   char *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol *syms ;
   s32 *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol *gpl_syms ;
   s32 *gpl_crcs ;
   struct kernel_symbol *unused_syms ;
   s32 *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol *unused_gpl_syms ;
   s32 *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol *gpl_future_syms ;
   s32 *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   struct module_layout core_layout ;
   struct module_layout init_layout ;
   struct mod_arch_specific arch ;
   unsigned long taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   struct mod_kallsyms *kallsyms ;
   struct mod_kallsyms core_kallsyms ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   tracepoint_ptr_t *tracepoints_ptrs ;
   unsigned int num_srcu_structs ;
   struct srcu_struct **srcu_struct_ptrs ;
   unsigned int num_bpf_raw_events ;
   struct bpf_raw_event_map *bpf_raw_events ;
   struct jump_entry *jump_entries ;
   unsigned int num_jump_entries ;
   unsigned int num_trace_bprintk_fmt ;
   char **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_eval_map **trace_evals ;
   unsigned int num_trace_evals ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp ;
   bool klp_alive ;
   struct klp_modinfo *klp_info ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t *ctors ;
   unsigned int num_ctors ;
   struct error_injection_entry *ei_funcs ;
   unsigned int num_ei_funcs ;
} __attribute__((__designated_init__, __aligned__(64)));
#line 65  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/phy.h"
enum ldv_15999 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_INTERNAL = 1,
    PHY_INTERFACE_MODE_MII = 2,
    PHY_INTERFACE_MODE_GMII = 3,
    PHY_INTERFACE_MODE_SGMII = 4,
    PHY_INTERFACE_MODE_TBI = 5,
    PHY_INTERFACE_MODE_REVMII = 6,
    PHY_INTERFACE_MODE_RMII = 7,
    PHY_INTERFACE_MODE_RGMII = 8,
    PHY_INTERFACE_MODE_RGMII_ID = 9,
    PHY_INTERFACE_MODE_RGMII_RXID = 10,
    PHY_INTERFACE_MODE_RGMII_TXID = 11,
    PHY_INTERFACE_MODE_RTBI = 12,
    PHY_INTERFACE_MODE_SMII = 13,
    PHY_INTERFACE_MODE_XGMII = 14,
    PHY_INTERFACE_MODE_MOCA = 15,
    PHY_INTERFACE_MODE_QSGMII = 16,
    PHY_INTERFACE_MODE_TRGMII = 17,
    PHY_INTERFACE_MODE_1000BASEX = 18,
    PHY_INTERFACE_MODE_2500BASEX = 19,
    PHY_INTERFACE_MODE_RXAUI = 20,
    PHY_INTERFACE_MODE_XAUI = 21,
    PHY_INTERFACE_MODE_10GKR = 22,
    PHY_INTERFACE_MODE_USXGMII = 23,
    PHY_INTERFACE_MODE_MAX = 24
};
#line 93  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/phy.h"
typedef enum ldv_15999 phy_interface_t;
#line 186 
struct phylink;
#line 188 
enum ldv_16014 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
};
#line 214  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/phy.h"
struct mii_bus {
   struct module *owner ;
   char *name ;
   char id[61U] ;
   void *priv ;
   int (*read)(struct mii_bus *, int , int ) ;
   int (*write)(struct mii_bus *, int , int , u16 ) ;
   int (*reset)(struct mii_bus *) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_16014 state ;
   struct device dev ;
   struct mdio_device *mdio_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int irq[32U] ;
   int reset_delay_us ;
   struct gpio_desc *reset_gpiod ;
};
#line 278 
enum phy_state {
    PHY_DOWN = 0,
    PHY_READY = 1,
    PHY_HALTED = 2,
    PHY_UP = 3,
    PHY_RUNNING = 4,
    PHY_NOLINK = 5
};
#line 325  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};
#line 363 
struct phy_driver;
#line 363 
struct phy_led_trigger;
#line 363  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/phy.h"
struct phy_device {
   struct mdio_device mdio ;
   struct phy_driver *drv ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   unsigned int is_c45 : 1 ;
   unsigned int is_internal : 1 ;
   unsigned int is_pseudo_fixed_link : 1 ;
   unsigned int is_gigabit_capable : 1 ;
   unsigned int has_fixups : 1 ;
   unsigned int suspended : 1 ;
   unsigned int sysfs_links : 1 ;
   unsigned int loopback_enabled : 1 ;
   unsigned int autoneg : 1 ;
   unsigned int link : 1 ;
   unsigned int autoneg_complete : 1 ;
   unsigned int interrupts : 1 ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   unsigned long supported[2U] ;
   unsigned long advertising[2U] ;
   unsigned long lp_advertising[2U] ;
   unsigned long adv_old[2U] ;
   u32 eee_broken_modes ;
   struct phy_led_trigger *phy_led_triggers ;
   unsigned int phy_num_led_triggers ;
   struct phy_led_trigger *last_triggered ;
   struct phy_led_trigger *led_link_trigger ;
   int irq ;
   void *priv ;
   struct delayed_work state_queue ;
   struct mutex lock ;
   bool sfp_bus_attached ;
   struct sfp_bus *sfp_bus ;
   struct phylink *phylink ;
   struct net_device *attached_dev ;
   u8 mdix ;
   u8 mdix_ctrl ;
   void (*phy_link_change)(struct phy_device *, bool , bool ) ;
   void (*adjust_link)(struct net_device *) ;
};
#line 475  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/phy.h"
struct phy_driver {
   struct mdio_driver_common mdiodrv ;
   u32 phy_id ;
   char *name ;
   u32 phy_id_mask ;
   unsigned long *features ;
   u32 flags ;
   void *driver_data ;
   int (*soft_reset)(struct phy_device *) ;
   int (*config_init)(struct phy_device *) ;
   int (*probe)(struct phy_device *) ;
   int (*get_features)(struct phy_device *) ;
   int (*suspend)(struct phy_device *) ;
   int (*resume)(struct phy_device *) ;
   int (*config_aneg)(struct phy_device *) ;
   int (*aneg_done)(struct phy_device *) ;
   int (*read_status)(struct phy_device *) ;
   int (*ack_interrupt)(struct phy_device *) ;
   int (*config_intr)(struct phy_device *) ;
   int (*did_interrupt)(struct phy_device *) ;
   int (*handle_interrupt)(struct phy_device *) ;
   void (*remove)(struct phy_device *) ;
   int (*match_phy_device)(struct phy_device *) ;
   int (*ts_info)(struct phy_device *, struct ethtool_ts_info *) ;
   int (*hwtstamp)(struct phy_device *, struct ifreq *) ;
   bool (*rxtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   void (*txtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*link_change_notify)(struct phy_device *) ;
   int (*read_mmd)(struct phy_device *, int , u16 ) ;
   int (*write_mmd)(struct phy_device *, int , u16 , u16 ) ;
   int (*read_page)(struct phy_device *) ;
   int (*write_page)(struct phy_device *, int ) ;
   int (*module_info)(struct phy_device *, struct ethtool_modinfo *) ;
   int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_sset_count)(struct phy_device *) ;
   void (*get_strings)(struct phy_device *, u8 *) ;
   void (*get_stats)(struct phy_device *, struct ethtool_stats *, u64 *) ;
   int (*get_tunable)(struct phy_device *, struct ethtool_tunable *, void *) ;
   int (*set_tunable)(struct phy_device *, struct ethtool_tunable *, void *) ;
   int (*set_loopback)(struct phy_device *, bool ) ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cdev.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
} __attribute__((__designated_init__));
#line 202  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_thermal_diode_data {
   u8 location ;
   u8 temp ;
   u8 caution_thresh ;
   u8 max_op_thresh ;
};
#line 209  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_thermal_sensor_data {
   struct ixgbe_thermal_diode_data sensor[3U] ;
};
#line 2891  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
typedef u32 ixgbe_autoneg_advertised;
#line 2951  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
typedef u32 ixgbe_link_speed;
#line 3122 
enum ixgbe_eeprom_type {
    ixgbe_eeprom_uninitialized = 0,
    ixgbe_eeprom_spi = 1,
    ixgbe_flash = 2,
    ixgbe_eeprom_none = 3
};
#line 3129 
enum ixgbe_mac_type {
    ixgbe_mac_unknown = 0,
    ixgbe_mac_82598EB = 1,
    ixgbe_mac_82599EB = 2,
    ixgbe_mac_X540 = 3,
    ixgbe_mac_X550 = 4,
    ixgbe_mac_X550EM_x = 5,
    ixgbe_mac_x550em_a = 6,
    ixgbe_num_macs = 7
};
#line 3140 
enum ixgbe_phy_type {
    ixgbe_phy_unknown = 0,
    ixgbe_phy_none = 1,
    ixgbe_phy_tn = 2,
    ixgbe_phy_aq = 3,
    ixgbe_phy_x550em_kr = 4,
    ixgbe_phy_x550em_kx4 = 5,
    ixgbe_phy_x550em_xfi = 6,
    ixgbe_phy_x550em_ext_t = 7,
    ixgbe_phy_ext_1g_t = 8,
    ixgbe_phy_cu_unknown = 9,
    ixgbe_phy_qt = 10,
    ixgbe_phy_xaui = 11,
    ixgbe_phy_nl = 12,
    ixgbe_phy_sfp_passive_tyco = 13,
    ixgbe_phy_sfp_passive_unknown = 14,
    ixgbe_phy_sfp_active_unknown = 15,
    ixgbe_phy_sfp_avago = 16,
    ixgbe_phy_sfp_ftl = 17,
    ixgbe_phy_sfp_ftl_active = 18,
    ixgbe_phy_sfp_unknown = 19,
    ixgbe_phy_sfp_intel = 20,
    ixgbe_phy_qsfp_passive_unknown = 21,
    ixgbe_phy_qsfp_active_unknown = 22,
    ixgbe_phy_qsfp_intel = 23,
    ixgbe_phy_qsfp_unknown = 24,
    ixgbe_phy_sfp_unsupported = 25,
    ixgbe_phy_sgmii = 26,
    ixgbe_phy_fw = 27,
    ixgbe_phy_generic = 28
};
#line 3172 
enum ixgbe_sfp_type {
    ixgbe_sfp_type_da_cu = 0,
    ixgbe_sfp_type_sr = 1,
    ixgbe_sfp_type_lr = 2,
    ixgbe_sfp_type_da_cu_core0 = 3,
    ixgbe_sfp_type_da_cu_core1 = 4,
    ixgbe_sfp_type_srlr_core0 = 5,
    ixgbe_sfp_type_srlr_core1 = 6,
    ixgbe_sfp_type_da_act_lmt_core0 = 7,
    ixgbe_sfp_type_da_act_lmt_core1 = 8,
    ixgbe_sfp_type_1g_cu_core0 = 9,
    ixgbe_sfp_type_1g_cu_core1 = 10,
    ixgbe_sfp_type_1g_sx_core0 = 11,
    ixgbe_sfp_type_1g_sx_core1 = 12,
    ixgbe_sfp_type_1g_lx_core0 = 13,
    ixgbe_sfp_type_1g_lx_core1 = 14,
    ixgbe_sfp_type_not_present = 65534,
    ixgbe_sfp_type_unknown = 65535
};
#line 3192 
enum ixgbe_media_type {
    ixgbe_media_type_unknown = 0,
    ixgbe_media_type_fiber = 1,
    ixgbe_media_type_fiber_qsfp = 2,
    ixgbe_media_type_fiber_lco = 3,
    ixgbe_media_type_copper = 4,
    ixgbe_media_type_backplane = 5,
    ixgbe_media_type_cx4 = 6,
    ixgbe_media_type_virtual = 7
};
#line 3203 
enum ixgbe_fc_mode {
    ixgbe_fc_none = 0,
    ixgbe_fc_rx_pause = 1,
    ixgbe_fc_tx_pause = 2,
    ixgbe_fc_full = 3,
    ixgbe_fc_default = 4
};
#line 3211 
enum ixgbe_smart_speed {
    ixgbe_smart_speed_auto = 0,
    ixgbe_smart_speed_on = 1,
    ixgbe_smart_speed_off = 2
};
#line 3217 
enum ixgbe_bus_type {
    ixgbe_bus_type_unknown = 0,
    ixgbe_bus_type_pci_express = 1,
    ixgbe_bus_type_internal = 2,
    ixgbe_bus_type_reserved = 3
};
#line 3224 
enum ixgbe_bus_speed {
    ixgbe_bus_speed_unknown = 0,
    ixgbe_bus_speed_33 = 33,
    ixgbe_bus_speed_66 = 66,
    ixgbe_bus_speed_100 = 100,
    ixgbe_bus_speed_120 = 120,
    ixgbe_bus_speed_133 = 133,
    ixgbe_bus_speed_2500 = 2500,
    ixgbe_bus_speed_5000 = 5000,
    ixgbe_bus_speed_8000 = 8000,
    ixgbe_bus_speed_reserved = 8001
};
#line 3237 
enum ixgbe_bus_width {
    ixgbe_bus_width_unknown = 0,
    ixgbe_bus_width_pcie_x1 = 1,
    ixgbe_bus_width_pcie_x2 = 2,
    ixgbe_bus_width_pcie_x4 = 4,
    ixgbe_bus_width_pcie_x8 = 8,
    ixgbe_bus_width_32 = 32,
    ixgbe_bus_width_64 = 64,
    ixgbe_bus_width_reserved = 65
};
#line 3271  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_addr_filter_info {
   u32 num_mc_addrs ;
   u32 rar_used_count ;
   u32 mta_in_use ;
   u32 overflow_promisc ;
   bool uc_set_promisc ;
   bool user_set_promisc ;
};
#line 3281  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_bus_info {
   enum ixgbe_bus_speed speed ;
   enum ixgbe_bus_width width ;
   enum ixgbe_bus_type type ;
   u8 func ;
   u8 lan_id ;
   u8 instance_id ;
};
#line 3292  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_fc_info {
   u32 high_water[8U] ;
   u32 low_water[8U] ;
   u16 pause_time ;
   bool send_xon ;
   bool strict_ieee ;
   bool disable_fc_autoneg ;
   bool fc_was_autonegged ;
   enum ixgbe_fc_mode current_mode ;
   enum ixgbe_fc_mode requested_mode ;
};
#line 3382 
struct ixgbe_hw;
#line 3391  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_eeprom_operations {
   s32 (*init_params)(struct ixgbe_hw *) ;
   s32 (*read)(struct ixgbe_hw *, u16 , u16 *) ;
   s32 (*read_buffer)(struct ixgbe_hw *, u16 , u16 , u16 *) ;
   s32 (*write)(struct ixgbe_hw *, u16 , u16 ) ;
   s32 (*write_buffer)(struct ixgbe_hw *, u16 , u16 , u16 *) ;
   s32 (*validate_checksum)(struct ixgbe_hw *, u16 *) ;
   s32 (*update_checksum)(struct ixgbe_hw *) ;
   s32 (*calc_checksum)(struct ixgbe_hw *) ;
};
#line 3402  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_mac_operations {
   s32 (*init_hw)(struct ixgbe_hw *) ;
   s32 (*reset_hw)(struct ixgbe_hw *) ;
   s32 (*start_hw)(struct ixgbe_hw *) ;
   s32 (*clear_hw_cntrs)(struct ixgbe_hw *) ;
   enum ixgbe_media_type (*get_media_type)(struct ixgbe_hw *) ;
   s32 (*get_mac_addr)(struct ixgbe_hw *, u8 *) ;
   s32 (*get_san_mac_addr)(struct ixgbe_hw *, u8 *) ;
   s32 (*get_device_caps)(struct ixgbe_hw *, u16 *) ;
   s32 (*get_wwn_prefix)(struct ixgbe_hw *, u16 *, u16 *) ;
   s32 (*stop_adapter)(struct ixgbe_hw *) ;
   s32 (*get_bus_info)(struct ixgbe_hw *) ;
   void (*set_lan_id)(struct ixgbe_hw *) ;
   s32 (*read_analog_reg8)(struct ixgbe_hw *, u32 , u8 *) ;
   s32 (*write_analog_reg8)(struct ixgbe_hw *, u32 , u8 ) ;
   s32 (*setup_sfp)(struct ixgbe_hw *) ;
   s32 (*disable_rx_buff)(struct ixgbe_hw *) ;
   s32 (*enable_rx_buff)(struct ixgbe_hw *) ;
   s32 (*enable_rx_dma)(struct ixgbe_hw *, u32 ) ;
   s32 (*acquire_swfw_sync)(struct ixgbe_hw *, u32 ) ;
   void (*release_swfw_sync)(struct ixgbe_hw *, u32 ) ;
   void (*init_swfw_sync)(struct ixgbe_hw *) ;
   s32 (*prot_autoc_read)(struct ixgbe_hw *, bool *, u32 *) ;
   s32 (*prot_autoc_write)(struct ixgbe_hw *, u32 , bool ) ;
   void (*disable_tx_laser)(struct ixgbe_hw *) ;
   void (*enable_tx_laser)(struct ixgbe_hw *) ;
   void (*flap_tx_laser)(struct ixgbe_hw *) ;
   void (*stop_link_on_d3)(struct ixgbe_hw *) ;
   s32 (*setup_link)(struct ixgbe_hw *, ixgbe_link_speed , bool ) ;
   s32 (*setup_mac_link)(struct ixgbe_hw *, ixgbe_link_speed , bool ) ;
   s32 (*check_link)(struct ixgbe_hw *, ixgbe_link_speed *, bool *, bool ) ;
   s32 (*get_link_capabilities)(struct ixgbe_hw *, ixgbe_link_speed *, bool *) ;
   void (*set_rate_select_speed)(struct ixgbe_hw *, ixgbe_link_speed ) ;
   void (*set_rxpba)(struct ixgbe_hw *, int , u32 , int ) ;
   s32 (*led_on)(struct ixgbe_hw *, u32 ) ;
   s32 (*led_off)(struct ixgbe_hw *, u32 ) ;
   s32 (*blink_led_start)(struct ixgbe_hw *, u32 ) ;
   s32 (*blink_led_stop)(struct ixgbe_hw *, u32 ) ;
   s32 (*init_led_link_act)(struct ixgbe_hw *) ;
   s32 (*set_rar)(struct ixgbe_hw *, u32 , u8 *, u32 , u32 ) ;
   s32 (*clear_rar)(struct ixgbe_hw *, u32 ) ;
   s32 (*set_vmdq)(struct ixgbe_hw *, u32 , u32 ) ;
   s32 (*set_vmdq_san_mac)(struct ixgbe_hw *, u32 ) ;
   s32 (*clear_vmdq)(struct ixgbe_hw *, u32 , u32 ) ;
   s32 (*init_rx_addrs)(struct ixgbe_hw *) ;
   s32 (*update_mc_addr_list)(struct ixgbe_hw *, struct net_device *) ;
   s32 (*enable_mc)(struct ixgbe_hw *) ;
   s32 (*disable_mc)(struct ixgbe_hw *) ;
   s32 (*clear_vfta)(struct ixgbe_hw *) ;
   s32 (*set_vfta)(struct ixgbe_hw *, u32 , u32 , bool , bool ) ;
   s32 (*init_uta_tables)(struct ixgbe_hw *) ;
   void (*set_mac_anti_spoofing)(struct ixgbe_hw *, bool , int ) ;
   void (*set_vlan_anti_spoofing)(struct ixgbe_hw *, bool , int ) ;
   s32 (*fc_enable)(struct ixgbe_hw *) ;
   s32 (*setup_fc)(struct ixgbe_hw *) ;
   void (*fc_autoneg)(struct ixgbe_hw *) ;
   s32 (*set_fw_drv_ver)(struct ixgbe_hw *, u8 , u8 , u8 , u8 , u16 , char *) ;
   s32 (*get_thermal_sensor_data)(struct ixgbe_hw *) ;
   s32 (*init_thermal_sensor_thresh)(struct ixgbe_hw *) ;
   bool (*fw_recovery_mode)(struct ixgbe_hw *) ;
   void (*disable_rx)(struct ixgbe_hw *) ;
   void (*enable_rx)(struct ixgbe_hw *) ;
   void (*set_source_address_pruning)(struct ixgbe_hw *, bool , unsigned int ) ;
   void (*set_ethertype_anti_spoofing)(struct ixgbe_hw *, bool , int ) ;
   s32 (*dmac_config)(struct ixgbe_hw *) ;
   s32 (*dmac_update_tcs)(struct ixgbe_hw *) ;
   s32 (*dmac_config_tcs)(struct ixgbe_hw *) ;
   s32 (*read_iosf_sb_reg)(struct ixgbe_hw *, u32 , u32 , u32 *) ;
   s32 (*write_iosf_sb_reg)(struct ixgbe_hw *, u32 , u32 , u32 ) ;
};
#line 3490  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_phy_operations {
   s32 (*identify)(struct ixgbe_hw *) ;
   s32 (*identify_sfp)(struct ixgbe_hw *) ;
   s32 (*init)(struct ixgbe_hw *) ;
   s32 (*reset)(struct ixgbe_hw *) ;
   s32 (*read_reg)(struct ixgbe_hw *, u32 , u32 , u16 *) ;
   s32 (*write_reg)(struct ixgbe_hw *, u32 , u32 , u16 ) ;
   s32 (*read_reg_mdi)(struct ixgbe_hw *, u32 , u32 , u16 *) ;
   s32 (*write_reg_mdi)(struct ixgbe_hw *, u32 , u32 , u16 ) ;
   s32 (*setup_link)(struct ixgbe_hw *) ;
   s32 (*setup_internal_link)(struct ixgbe_hw *) ;
   s32 (*setup_link_speed)(struct ixgbe_hw *, ixgbe_link_speed , bool ) ;
   s32 (*check_link)(struct ixgbe_hw *, ixgbe_link_speed *, bool *) ;
   s32 (*read_i2c_byte)(struct ixgbe_hw *, u8 , u8 , u8 *) ;
   s32 (*write_i2c_byte)(struct ixgbe_hw *, u8 , u8 , u8 ) ;
   s32 (*read_i2c_sff8472)(struct ixgbe_hw *, u8 , u8 *) ;
   s32 (*read_i2c_eeprom)(struct ixgbe_hw *, u8 , u8 *) ;
   s32 (*write_i2c_eeprom)(struct ixgbe_hw *, u8 , u8 ) ;
   s32 (*check_overtemp)(struct ixgbe_hw *) ;
   s32 (*set_phy_power)(struct ixgbe_hw *, bool ) ;
   s32 (*enter_lplu)(struct ixgbe_hw *) ;
   s32 (*handle_lasi)(struct ixgbe_hw *) ;
   s32 (*read_i2c_byte_unlocked)(struct ixgbe_hw *, u8 , u8 , u8 *) ;
   s32 (*write_i2c_byte_unlocked)(struct ixgbe_hw *, u8 , u8 , u8 ) ;
};
#line 3518  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_link_operations {
   s32 (*read_link)(struct ixgbe_hw *, u8 , u16 , u16 *) ;
   s32 (*read_link_unlocked)(struct ixgbe_hw *, u8 , u16 , u16 *) ;
   s32 (*write_link)(struct ixgbe_hw *, u8 , u16 , u16 ) ;
   s32 (*write_link_unlocked)(struct ixgbe_hw *, u8 , u16 , u16 ) ;
};
#line 3527  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_link_info {
   struct ixgbe_link_operations ops ;
   u8 addr ;
};
#line 3532  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_eeprom_info {
   struct ixgbe_eeprom_operations ops ;
   enum ixgbe_eeprom_type type ;
   u32 semaphore_delay ;
   u16 word_size ;
   u16 address_bits ;
   u16 word_page_size ;
   u16 ctrl_word_3 ;
};
#line 3543  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_mac_info {
   struct ixgbe_mac_operations ops ;
   enum ixgbe_mac_type type ;
   u8 addr[6U] ;
   u8 perm_addr[6U] ;
   u8 san_addr[6U] ;
   u16 wwnn_prefix ;
   u16 wwpn_prefix ;
   u16 max_msix_vectors ;
   u32 mta_shadow[128U] ;
   s32 mc_filter_type ;
   u32 mcft_size ;
   u32 vft_size ;
   u32 num_rar_entries ;
   u32 rar_highwater ;
   u32 rx_pb_size ;
   u32 max_tx_queues ;
   u32 max_rx_queues ;
   u32 orig_autoc ;
   u32 orig_autoc2 ;
   bool orig_link_settings_stored ;
   bool autotry_restart ;
   u8 flags ;
   u8 san_mac_rar_index ;
   struct ixgbe_thermal_sensor_data thermal_sensor_data ;
   bool set_lben ;
   u8 led_link_act ;
};
#line 3575  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_phy_info {
   struct ixgbe_phy_operations ops ;
   struct mdio_if_info mdio ;
   enum ixgbe_phy_type type ;
   u32 id ;
   enum ixgbe_sfp_type sfp_type ;
   bool sfp_setup_needed ;
   u32 revision ;
   enum ixgbe_media_type media_type ;
   u32 phy_semaphore_mask ;
   bool reset_disable ;
   ixgbe_autoneg_advertised autoneg_advertised ;
   ixgbe_link_speed speeds_supported ;
   ixgbe_link_speed eee_speeds_supported ;
   ixgbe_link_speed eee_speeds_advertised ;
   enum ixgbe_smart_speed smart_speed ;
   bool smart_speed_active ;
   bool multispeed_fiber ;
   bool reset_if_overtemp ;
   bool qsfp_shared_i2c_bus ;
   u32 nw_mng_if_sel ;
};
#line 107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.h"
struct ixgbe_mbx_operations;
#line 3600  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_mbx_operations {
   s32 (*init_params)(struct ixgbe_hw *) ;
   s32 (*read)(struct ixgbe_hw *, u32 *, u16 , u16 ) ;
   s32 (*write)(struct ixgbe_hw *, u32 *, u16 , u16 ) ;
   s32 (*read_posted)(struct ixgbe_hw *, u32 *, u16 , u16 ) ;
   s32 (*write_posted)(struct ixgbe_hw *, u32 *, u16 , u16 ) ;
   s32 (*check_for_msg)(struct ixgbe_hw *, u16 ) ;
   s32 (*check_for_ack)(struct ixgbe_hw *, u16 ) ;
   s32 (*check_for_rst)(struct ixgbe_hw *, u16 ) ;
};
#line 3611  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_mbx_stats {
   u32 msgs_tx ;
   u32 msgs_rx ;
   u32 acks ;
   u32 reqs ;
   u32 rsts ;
};
#line 3620  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_mbx_info {
   struct ixgbe_mbx_operations *ops ;
   struct ixgbe_mbx_stats stats ;
   u32 timeout ;
   u32 usec_delay ;
   u32 v2p_mailbox ;
   u16 size ;
};
#line 3629  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hw {
   u8 *hw_addr ;
   void *back ;
   struct ixgbe_mac_info mac ;
   struct ixgbe_addr_filter_info addr_ctrl ;
   struct ixgbe_fc_info fc ;
   struct ixgbe_phy_info phy ;
   struct ixgbe_link_info link ;
   struct ixgbe_eeprom_info eeprom ;
   struct ixgbe_bus_info bus ;
   struct ixgbe_mbx_info mbx ;
   u32 *mvals ;
   u16 device_id ;
   u16 vendor_id ;
   u16 subsystem_device_id ;
   u16 subsystem_vendor_id ;
   u8 revision_id ;
   bool adapter_stopped ;
   bool force_full_reset ;
   bool allow_unsupported_sfp ;
   bool wol_enabled ;
   bool need_crosstalk_fix ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
union __anonunion___u_720 {
   u8 *__val ;
   char __c[1U] ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
union __anonunion___u_1451 {
   u8 *__val ;
   char __c[1U] ;
};
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef __u16 __le16;
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/types.h"
typedef __u32 __le32;
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/types.h"
typedef __u64 __le64;
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/types.h"
typedef __u64 __be64;
#line 35  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/types.h"
typedef __u16 __sum16;
#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef unsigned long uintptr_t;
#line 154  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef unsigned int slab_flags_t;
#line 346  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jump_label.h"
struct static_key_true {
   struct static_key key ;
};
#line 350  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jump_label.h"
struct static_key_false {
   struct static_key key ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dynamic_debug.h"
union __anonunion_key_1471 {
   struct static_key_true dd_key_true ;
   struct static_key_false dd_key_false ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dynamic_debug.h"
struct _ddebug {
   char *modname ;
   char *function ;
   char *filename ;
   char *format ;
   unsigned int lineno : 18 ;
   unsigned int flags : 8 ;
   union __anonunion_key_1471 key ;
} __attribute__((__aligned__(8)));
#line 557  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernel.h"
enum system_states {
    SYSTEM_BOOTING = 0,
    SYSTEM_SCHEDULING = 1,
    SYSTEM_RUNNING = 2,
    SYSTEM_HALT = 3,
    SYSTEM_POWER_OFF = 4,
    SYSTEM_RESTART = 5,
    SYSTEM_SUSPEND = 6
};
#line 754  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_1481 {
   struct hlist_node *__val ;
   char __c[1U] ;
};
#line 762  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_1483 {
   struct hlist_node *__val ;
   char __c[1U] ;
};
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/atomic.h"
union __anonunion___u_1529 {
   int __val ;
   char __c[1U] ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/nodemask.h"
enum node_states {
    N_POSSIBLE = 0,
    N_ONLINE = 1,
    N_NORMAL_MEMORY = 2,
    N_HIGH_MEMORY = 2,
    N_MEMORY = 3,
    N_CPU = 4,
    NR_NODE_STATES = 5
};
#line 249  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timekeeping.h"
struct system_device_crosststamp {
   ktime_t device ;
   ktime_t sys_realtime ;
   ktime_t sys_monoraw ;
};
#line 196  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
struct free_area {
   struct list_head free_list[6U] ;
   unsigned long nr_free ;
};
#line 158 
struct pglist_data;
#line 168  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
struct zone_padding {
   char x[0U] ;
} __attribute__((__aligned__(4096)));
#line 285  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
struct zone_reclaim_stat {
   unsigned long recent_rotated[2U] ;
   unsigned long recent_scanned[2U] ;
};
#line 304  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
struct lruvec {
   struct list_head lists[5U] ;
   struct zone_reclaim_stat reclaim_stat ;
   atomic_long_t inactive_age ;
   unsigned long refaults ;
   unsigned long flags ;
   struct pglist_data *pgdat ;
};
#line 340  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
struct per_cpu_pages {
   int count ;
   int high ;
   int batch ;
   struct list_head lists[3U] ;
};
#line 349  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
struct per_cpu_pageset {
   struct per_cpu_pages pcp ;
   s8 expire ;
   u16 vm_numa_stat_diff[6U] ;
   s8 stat_threshold ;
   s8 vm_stat_diff[13U] ;
};
#line 361  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
struct per_cpu_nodestat {
   s8 stat_threshold ;
   s8 vm_node_stat_diff[32U] ;
};
#line 365 
enum zone_type {
    ZONE_DMA = 0,
    ZONE_DMA32 = 1,
    ZONE_NORMAL = 2,
    ZONE_MOVABLE = 3,
    ZONE_DEVICE = 4,
    __MAX_NR_ZONES = 5
};
#line 432  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
struct zone {
   unsigned long _watermark[3U] ;
   unsigned long watermark_boost ;
   unsigned long nr_reserved_highatomic ;
   long lowmem_reserve[5U] ;
   int node ;
   struct pglist_data *zone_pgdat ;
   struct per_cpu_pageset *pageset ;
   unsigned long zone_start_pfn ;
   atomic_long_t managed_pages ;
   unsigned long spanned_pages ;
   unsigned long present_pages ;
   char *name ;
   unsigned long nr_isolate_pageblock ;
   seqlock_t span_seqlock ;
   int initialized ;
   struct zone_padding _pad1_ ;
   struct free_area free_area[11U] ;
   unsigned long flags ;
   spinlock_t lock ;
   struct zone_padding _pad2_ ;
   unsigned long percpu_drift_mark ;
   unsigned long compact_cached_free_pfn ;
   unsigned long compact_cached_migrate_pfn[2U] ;
   unsigned long compact_init_migrate_pfn ;
   unsigned long compact_init_free_pfn ;
   unsigned int compact_considered ;
   unsigned int compact_defer_shift ;
   int compact_order_failed ;
   bool compact_blockskip_flush ;
   bool contiguous ;
   struct zone_padding _pad3_ ;
   atomic_long_t vm_stat[13U] ;
   atomic_long_t vm_numa_stat[6U] ;
} __attribute__((__aligned__(4096)));
#line 665  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
struct zoneref {
   struct zone *zone ;
   int zone_idx ;
};
#line 684  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
struct zonelist {
   struct zoneref _zonerefs[5121U] ;
};
#line 694  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
struct deferred_split {
   spinlock_t split_queue_lock ;
   struct list_head split_queue ;
   unsigned long split_queue_len ;
};
#line 710  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
struct pglist_data {
   struct zone node_zones[5U] ;
   struct zonelist node_zonelists[2U] ;
   int nr_zones ;
   spinlock_t node_size_lock ;
   unsigned long node_start_pfn ;
   unsigned long node_present_pages ;
   unsigned long node_spanned_pages ;
   int node_id ;
   wait_queue_head_t kswapd_wait ;
   wait_queue_head_t pfmemalloc_wait ;
   struct task_struct *kswapd ;
   int kswapd_order ;
   enum zone_type kswapd_classzone_idx ;
   int kswapd_failures ;
   int kcompactd_max_order ;
   enum zone_type kcompactd_classzone_idx ;
   wait_queue_head_t kcompactd_wait ;
   struct task_struct *kcompactd ;
   unsigned long totalreserve_pages ;
   unsigned long min_unmapped_pages ;
   unsigned long min_slab_pages ;
   struct zone_padding _pad1_ ;
   spinlock_t lru_lock ;
   unsigned long first_deferred_pfn ;
   struct deferred_split deferred_split_queue ;
   struct lruvec __lruvec ;
   unsigned long flags ;
   struct zone_padding _pad2_ ;
   struct per_cpu_nodestat *per_cpu_nodestats ;
   atomic_long_t vm_stat[32U] ;
};
#line 282  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 159  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/topology.h"
struct pci_bus;
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/smp.h"
struct __call_single_data {
   struct llist_node llist ;
   void (*func)(void *) ;
   void *info ;
   unsigned int flags ;
};
#line 101  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/refcount.h"
enum refcount_saturation_type {
    REFCOUNT_ADD_NOT_ZERO_OVF = 0,
    REFCOUNT_ADD_OVF = 1,
    REFCOUNT_ADD_UAF = 2,
    REFCOUNT_SUB_UAF = 3,
    REFCOUNT_DEC_LEAK = 4
};
#line 38  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 821  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *, struct device_attribute *, char *) ;
   ssize_t (*store)(struct device *, struct device_attribute *, char *, size_t ) ;
};
#line 1913 
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
};
#line 1919  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
typedef enum irqreturn irqreturn_t;
#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct hotplug_slot;
#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 99  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
typedef int pci_power_t;
#line 153  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 162 
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
};
#line 181  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 207  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 282 
struct pcie_link_state;
#line 283 
struct pci_vpd;
#line 284 
struct pci_sriov;
#line 285 
struct pci_p2pdma;
#line 290 
struct aer_stats;
#line 290 
struct pci_driver;
#line 290  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
union __anonunion_1868 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 290  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u16 aer_cap ;
   struct aer_stats *aer_stats ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   u8 pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   unsigned long *dma_alias_mask ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   unsigned int imm_ready : 1 ;
   u8 pm_cap ;
   unsigned int pme_support : 5 ;
   unsigned int pme_poll : 1 ;
   unsigned int d1_support : 1 ;
   unsigned int d2_support : 1 ;
   unsigned int no_d1d2 : 1 ;
   unsigned int no_d3cold : 1 ;
   unsigned int bridge_d3 : 1 ;
   unsigned int d3cold_allowed : 1 ;
   unsigned int mmio_always_on : 1 ;
   unsigned int wakeup_prepared : 1 ;
   unsigned int runtime_d3cold : 1 ;
   unsigned int skip_bus_pm : 1 ;
   unsigned int ignore_hotplug : 1 ;
   unsigned int hotplug_user_indicators : 1 ;
   unsigned int clear_retrain_link : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   unsigned int ltr_path : 1 ;
   unsigned int eetlp_prefix_path : 1 ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned int transparent : 1 ;
   unsigned int io_window : 1 ;
   unsigned int pref_window : 1 ;
   unsigned int pref_64_window : 1 ;
   unsigned int multifunction : 1 ;
   unsigned int is_busmaster : 1 ;
   unsigned int no_msi : 1 ;
   unsigned int no_64bit_msi : 1 ;
   unsigned int block_cfg_access : 1 ;
   unsigned int broken_parity_status : 1 ;
   unsigned int irq_reroute_variant : 2 ;
   unsigned int msi_enabled : 1 ;
   unsigned int msix_enabled : 1 ;
   unsigned int ari_enabled : 1 ;
   unsigned int ats_enabled : 1 ;
   unsigned int pasid_enabled : 1 ;
   unsigned int pri_enabled : 1 ;
   unsigned int is_managed : 1 ;
   unsigned int needs_freset : 1 ;
   unsigned int state_saved : 1 ;
   unsigned int is_physfn : 1 ;
   unsigned int is_virtfn : 1 ;
   unsigned int reset_fn : 1 ;
   unsigned int is_hotplug_bridge : 1 ;
   unsigned int shpc_managed : 1 ;
   unsigned int is_thunderbolt : 1 ;
   unsigned int untrusted : 1 ;
   unsigned int __aer_firmware_first_valid : 1 ;
   unsigned int __aer_firmware_first : 1 ;
   unsigned int broken_intx_masking : 1 ;
   unsigned int io_window_1k : 1 ;
   unsigned int irq_managed : 1 ;
   unsigned int non_compliant_bars : 1 ;
   unsigned int is_probed : 1 ;
   unsigned int link_active_reporting : 1 ;
   unsigned int no_vf_scan : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   unsigned int broken_cmd_compl : 1 ;
   unsigned int ptm_root : 1 ;
   unsigned int ptm_enabled : 1 ;
   u8 ptm_granularity ;
   struct attribute_group **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion_1868 __anonCompField_pci_dev_59 ;
   u16 ats_cap ;
   u8 ats_stu ;
   u16 pri_cap ;
   u32 pri_reqs_alloc ;
   unsigned int pasid_required : 1 ;
   u16 pasid_cap ;
   u16 pasid_features ;
   struct pci_p2pdma *p2pdma ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
   unsigned long priv_flags ;
};
#line 493 
struct pci_ops;
#line 493 
struct msi_controller;
#line 571  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int is_added : 1 ;
};
#line 697  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct pci_ops {
   int (*add_bus)(struct pci_bus *) ;
   void (*remove_bus)(struct pci_bus *) ;
   void *(*map_bus)(struct pci_bus *, unsigned int , int ) ;
   int (*read)(struct pci_bus *, unsigned int , int , int , u32 *) ;
   int (*write)(struct pci_bus *, unsigned int , int , int , u32 ) ;
};
#line 725  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 729  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 761  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev *, enum pci_channel_state ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev *) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev *) ;
   void (*reset_prepare)(struct pci_dev *) ;
   void (*reset_done)(struct pci_dev *) ;
   void (*resume)(struct pci_dev *) ;
};
#line 824  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char *name ;
   struct pci_device_id *id_table ;
   int (*probe)(struct pci_dev *, struct pci_device_id *) ;
   void (*remove)(struct pci_dev *) ;
   int (*suspend)(struct pci_dev *, pm_message_t ) ;
   int (*resume)(struct pci_dev *) ;
   void (*shutdown)(struct pci_dev *) ;
   int (*sriov_configure)(struct pci_dev *, int ) ;
   struct pci_error_handlers *err_handler ;
   struct attribute_group **groups ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 286  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fs.h"
struct bio;
#line 288 
struct hd_geometry;
#line 339  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
union __anonunion_arg_1898 {
   char *buf ;
   void *data ;
};
#line 339  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct __anonstruct_read_descriptor_t_1897 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_1898 arg ;
   int error ;
};
#line 339  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_1897 read_descriptor_t;
#line 1771 
struct block_device_operations;
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dmapool.h"
struct dma_pool;
#line 1424  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct msix_entry {
   u32 vector ;
   u16 entry ;
};
#line 92  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dynamic_queue_limits.h"
union __anonunion___u_1919 {
   unsigned int __val ;
   char __c[1U] ;
};
#line 92  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dynamic_queue_limits.h"
union __anonunion___u_1921 {
   unsigned int __val ;
   char __c[1U] ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/socket.h"
struct socket;
#line 49  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iov_iter msg_iter ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
   struct kiocb *msg_iocb ;
};
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bvec.h"
struct bvec_iter {
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned int bi_idx ;
   unsigned int bi_bvec_done ;
};
#line 201  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/random.h"
enum ldv_11223 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
};
#line 209  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/random.h"
typedef enum ldv_11223 socket_state;
#line 94  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   unsigned long flags ;
   struct callback_head rcu ;
} __attribute__((__aligned__(64)));
#line 112 
struct proto_ops;
#line 112  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops *ops ;
   struct socket_wq wq ;
};
#line 135  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket *) ;
   int (*bind)(struct socket *, struct sockaddr *, int ) ;
   int (*connect)(struct socket *, struct sockaddr *, int , int ) ;
   int (*socketpair)(struct socket *, struct socket *) ;
   int (*accept)(struct socket *, struct socket *, int , bool ) ;
   int (*getname)(struct socket *, struct sockaddr *, int ) ;
   __poll_t (*poll)(struct file *, struct socket *, struct poll_table_struct *) ;
   int (*ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*compat_ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*gettstamp)(struct socket *, void *, bool , bool ) ;
   int (*listen)(struct socket *, int ) ;
   int (*shutdown)(struct socket *, int ) ;
   int (*setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*compat_setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*compat_getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*sendmsg)(struct socket *, struct msghdr *, size_t ) ;
   int (*recvmsg)(struct socket *, struct msghdr *, size_t , int ) ;
   int (*mmap)(struct file *, struct socket *, struct vm_area_struct *) ;
   ssize_t (*sendpage)(struct socket *, struct page *, int , size_t , int ) ;
   ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*set_peek_off)(struct sock *, int ) ;
   int (*peek_len)(struct socket *) ;
   int (*read_sock)(struct sock *, read_descriptor_t *, int (*)(read_descriptor_t *, struct sk_buff *, unsigned int , size_t )) ;
   int (*sendpage_locked)(struct sock *, struct page *, int , size_t , int ) ;
   int (*sendmsg_locked)(struct sock *, struct msghdr *, size_t ) ;
   int (*set_rcvlowat)(struct sock *, int ) ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow.h"
struct flowi_tunnel {
   __be64 tun_id ;
};
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow.h"
struct flowi_common {
   int flowic_oif ;
   int flowic_iif ;
   __u32 flowic_mark ;
   __u8 flowic_tos ;
   __u8 flowic_scope ;
   __u8 flowic_proto ;
   __u8 flowic_flags ;
   __u32 flowic_secid ;
   kuid_t flowic_uid ;
   struct flowi_tunnel flowic_tun_key ;
   __u32 flowic_multipath_hash ;
};
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow.h"
struct __anonstruct_ports_1986 {
   __be16 dport ;
   __be16 sport ;
};
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow.h"
struct __anonstruct_icmpt_1987 {
   __u8 type ;
   __u8 code ;
};
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow.h"
struct __anonstruct_dnports_1988 {
   __le16 dport ;
   __le16 sport ;
};
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow.h"
struct __anonstruct_mht_1989 {
   __u8 type ;
};
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow.h"
union flowi_uli {
   struct __anonstruct_ports_1986 ports ;
   struct __anonstruct_icmpt_1987 icmpt ;
   struct __anonstruct_dnports_1988 dnports ;
   __be32 spi ;
   __be32 gre_key ;
   struct __anonstruct_mht_1989 mht ;
};
#line 70  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow.h"
struct flowi4 {
   struct flowi_common __fl_common ;
   __be32 saddr ;
   __be32 daddr ;
   union flowi_uli uli ;
} __attribute__((__aligned__(8)));
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow.h"
struct flowi6 {
   struct flowi_common __fl_common ;
   struct in6_addr daddr ;
   struct in6_addr saddr ;
   __be32 flowlabel ;
   union flowi_uli uli ;
   __u32 mp_hash ;
} __attribute__((__aligned__(8)));
#line 158  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow.h"
struct flowidn {
   struct flowi_common __fl_common ;
   __le16 daddr ;
   __le16 saddr ;
   union flowi_uli uli ;
} __attribute__((__aligned__(8)));
#line 173  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow.h"
union __anonunion_u_1990 {
   struct flowi_common __fl_common ;
   struct flowi4 ip4 ;
   struct flowi6 ip6 ;
   struct flowidn dn ;
};
#line 173  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow.h"
struct flowi {
   union __anonunion_u_1990 u ;
} __attribute__((__aligned__(8)));
#line 41  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netfilter/nf_conntrack_common.h"
struct napi_struct;
#line 313  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
typedef struct bio_vec skb_frag_t;
#line 416  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
struct skb_shared_hwtstamps {
   ktime_t hwtstamp ;
};
#line 510  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
struct skb_shared_info {
   __u8 __unused ;
   __u8 meta_len ;
   __u8 nr_frags ;
   __u8 tx_flags ;
   unsigned short gso_size ;
   unsigned short gso_segs ;
   struct sk_buff *frag_list ;
   struct skb_shared_hwtstamps hwtstamps ;
   unsigned int gso_type ;
   u32 tskey ;
   atomic_t dataref ;
   void *destructor_arg ;
   skb_frag_t frags[17U] ;
};
#line 973 
struct rtable;
#line 1165 
enum pkt_hash_types {
    PKT_HASH_TYPE_NONE = 0,
    PKT_HASH_TYPE_L2 = 1,
    PKT_HASH_TYPE_L3 = 2,
    PKT_HASH_TYPE_L4 = 3
};
#line 4082 
enum skb_ext_id {
    SKB_EXT_BRIDGE_NF = 0,
    SKB_EXT_SEC_PATH = 1,
    TC_SKB_EXT = 2,
    SKB_EXT_NUM = 3
};
#line 4312 
struct sec_path;
#line 75  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct icmpv6_mib_device {
   atomic_long_t mibs[6U] ;
};
#line 85  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct icmpv6msg_mib_device {
   atomic_long_t mibs[512U] ;
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/nftables.h"
union __anonunion_xfrm_address_t_2052 {
   __be32 a4 ;
   __be32 a6[4U] ;
   struct in6_addr in6 ;
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/nftables.h"
typedef union __anonunion_xfrm_address_t_2052 xfrm_address_t;
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/xfrm.h"
struct xfrm_id {
   xfrm_address_t daddr ;
   __be32 spi ;
   __u8 proto ;
};
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/xfrm.h"
struct xfrm_sec_ctx {
   __u8 ctx_doi ;
   __u8 ctx_alg ;
   __u16 ctx_len ;
   __u32 ctx_sid ;
   char ctx_str[0U] ;
};
#line 49  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/xfrm.h"
struct xfrm_selector {
   xfrm_address_t daddr ;
   xfrm_address_t saddr ;
   __be16 dport ;
   __be16 dport_mask ;
   __be16 sport ;
   __be16 sport_mask ;
   __u16 family ;
   __u8 prefixlen_d ;
   __u8 prefixlen_s ;
   __u8 proto ;
   int ifindex ;
   __kernel_uid32_t user ;
};
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/xfrm.h"
struct xfrm_lifetime_cfg {
   __u64 soft_byte_limit ;
   __u64 hard_byte_limit ;
   __u64 soft_packet_limit ;
   __u64 hard_packet_limit ;
   __u64 soft_add_expires_seconds ;
   __u64 hard_add_expires_seconds ;
   __u64 soft_use_expires_seconds ;
   __u64 hard_use_expires_seconds ;
};
#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/xfrm.h"
struct xfrm_lifetime_cur {
   __u64 bytes ;
   __u64 packets ;
   __u64 add_time ;
   __u64 use_time ;
};
#line 84  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/xfrm.h"
struct xfrm_replay_state {
   __u32 oseq ;
   __u32 seq ;
   __u32 bitmap ;
};
#line 92  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/xfrm.h"
struct xfrm_replay_state_esn {
   unsigned int bmp_len ;
   __u32 oseq ;
   __u32 seq ;
   __u32 oseq_hi ;
   __u32 seq_hi ;
   __u32 replay_window ;
   __u32 bmp[0U] ;
};
#line 102  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/xfrm.h"
struct xfrm_algo {
   char alg_name[64U] ;
   unsigned int alg_key_len ;
   char alg_key[0U] ;
};
#line 108  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/xfrm.h"
struct xfrm_algo_auth {
   char alg_name[64U] ;
   unsigned int alg_key_len ;
   unsigned int alg_trunc_len ;
   char alg_key[0U] ;
};
#line 115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/xfrm.h"
struct xfrm_algo_aead {
   char alg_name[64U] ;
   unsigned int alg_key_len ;
   unsigned int alg_icv_len ;
   char alg_key[0U] ;
};
#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/xfrm.h"
struct xfrm_stats {
   __u32 replay_window ;
   __u32 replay ;
   __u32 integrity_failed ;
};
#line 249  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/xfrm.h"
struct xfrm_encap_tmpl {
   __u16 encap_type ;
   __be16 encap_sport ;
   __be16 encap_dport ;
   xfrm_address_t encap_oa ;
};
#line 317  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/xfrm.h"
struct xfrm_mark {
   __u32 v ;
   __u32 m ;
};
#line 495  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/xfrm.h"
struct xfrm_address_filter {
   xfrm_address_t saddr ;
   xfrm_address_t daddr ;
   __u16 family ;
   __u8 splen ;
   __u8 dplen ;
};
#line 139  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
enum bpf_prog_type {
    BPF_PROG_TYPE_UNSPEC = 0,
    BPF_PROG_TYPE_SOCKET_FILTER = 1,
    BPF_PROG_TYPE_KPROBE = 2,
    BPF_PROG_TYPE_SCHED_CLS = 3,
    BPF_PROG_TYPE_SCHED_ACT = 4,
    BPF_PROG_TYPE_TRACEPOINT = 5,
    BPF_PROG_TYPE_XDP = 6,
    BPF_PROG_TYPE_PERF_EVENT = 7,
    BPF_PROG_TYPE_CGROUP_SKB = 8,
    BPF_PROG_TYPE_CGROUP_SOCK = 9,
    BPF_PROG_TYPE_LWT_IN = 10,
    BPF_PROG_TYPE_LWT_OUT = 11,
    BPF_PROG_TYPE_LWT_XMIT = 12,
    BPF_PROG_TYPE_SOCK_OPS = 13,
    BPF_PROG_TYPE_SK_SKB = 14,
    BPF_PROG_TYPE_CGROUP_DEVICE = 15,
    BPF_PROG_TYPE_SK_MSG = 16,
    BPF_PROG_TYPE_RAW_TRACEPOINT = 17,
    BPF_PROG_TYPE_CGROUP_SOCK_ADDR = 18,
    BPF_PROG_TYPE_LWT_SEG6LOCAL = 19,
    BPF_PROG_TYPE_LIRC_MODE2 = 20,
    BPF_PROG_TYPE_SK_REUSEPORT = 21,
    BPF_PROG_TYPE_FLOW_DISSECTOR = 22,
    BPF_PROG_TYPE_CGROUP_SYSCTL = 23,
    BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 24,
    BPF_PROG_TYPE_CGROUP_SOCKOPT = 25,
    BPF_PROG_TYPE_TRACING = 26
};
#line 169 
enum bpf_attach_type {
    BPF_CGROUP_INET_INGRESS = 0,
    BPF_CGROUP_INET_EGRESS = 1,
    BPF_CGROUP_INET_SOCK_CREATE = 2,
    BPF_CGROUP_SOCK_OPS = 3,
    BPF_SK_SKB_STREAM_PARSER = 4,
    BPF_SK_SKB_STREAM_VERDICT = 5,
    BPF_CGROUP_DEVICE = 6,
    BPF_SK_MSG_VERDICT = 7,
    BPF_CGROUP_INET4_BIND = 8,
    BPF_CGROUP_INET6_BIND = 9,
    BPF_CGROUP_INET4_CONNECT = 10,
    BPF_CGROUP_INET6_CONNECT = 11,
    BPF_CGROUP_INET4_POST_BIND = 12,
    BPF_CGROUP_INET6_POST_BIND = 13,
    BPF_CGROUP_UDP4_SENDMSG = 14,
    BPF_CGROUP_UDP6_SENDMSG = 15,
    BPF_LIRC_MODE2 = 16,
    BPF_FLOW_DISSECTOR = 17,
    BPF_CGROUP_SYSCTL = 18,
    BPF_CGROUP_UDP4_RECVMSG = 19,
    BPF_CGROUP_UDP6_RECVMSG = 20,
    BPF_CGROUP_GETSOCKOPT = 21,
    BPF_CGROUP_SETSOCKOPT = 22,
    BPF_TRACE_RAW_TP = 23,
    BPF_TRACE_FENTRY = 24,
    BPF_TRACE_FEXIT = 25,
    __MAX_BPF_ATTACH_TYPE = 26
};
#line 893  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct xdp_buff;
#line 783  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct __anonstruct_2115 {
   u8 is_data ;
   u8 padding ;
   u16 prioidx ;
   u32 classid ;
} __attribute__((__packed__));
#line 783  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
union __anonunion_2114 {
   struct __anonstruct_2115 __anonCompField___anonunion_2114_153 ;
   u64 val ;
};
#line 783  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct sock_cgroup_data {
   union __anonunion_2114 __anonCompField_sock_cgroup_data_154 ;
};
#line 41  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netprio_cgroup.h"
enum xdp_mem_type {
    MEM_TYPE_PAGE_SHARED = 0,
    MEM_TYPE_PAGE_ORDER0 = 1,
    MEM_TYPE_PAGE_POOL = 2,
    MEM_TYPE_ZERO_COPY = 3,
    MEM_TYPE_MAX = 4
};
#line 55  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp.h"
struct zero_copy_allocator {
   void (*free)(struct zero_copy_allocator *, unsigned long ) ;
};
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp.h"
struct xdp_buff {
   void *data ;
   void *data_end ;
   void *data_meta ;
   void *data_hard_start ;
   unsigned long handle ;
   struct xdp_rxq_info *rxq ;
};
#line 160  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/security.h"
struct xfrm_policy;
#line 178 
struct request_sock;
#line 410  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if_link.h"
enum macvlan_mode {
    MACVLAN_MODE_PRIVATE = 1,
    MACVLAN_MODE_VEPA = 2,
    MACVLAN_MODE_BRIDGE = 4,
    MACVLAN_MODE_PASSTHRU = 8,
    MACVLAN_MODE_SOURCE = 16
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/pkt_sched.h"
struct tc_stats {
   __u64 bytes ;
   __u32 packets ;
   __u32 drops ;
   __u32 overlimits ;
   __u32 bps ;
   __u32 pps ;
   __u32 qlen ;
   __u32 backlog ;
};
#line 102  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/pkt_sched.h"
struct tc_sizespec {
   unsigned char cell_log ;
   unsigned char size_log ;
   short cell_align ;
   int overhead ;
   unsigned int linklayer ;
   unsigned int mpu ;
   unsigned int mtu ;
   unsigned int tsize ;
};
#line 702  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/pkt_sched.h"
struct tc_mqprio_qopt {
   __u8 num_tc ;
   __u8 prio_tc_map[16U] ;
   __u8 hw ;
   __u16 count[16U] ;
   __u16 offset[16U] ;
};
#line 1163 
enum tca_id {
    TCA_ID_UNSPEC = 0,
    TCA_ID_POLICE = 1,
    TCA_ID_GACT = 5,
    TCA_ID_IPT = 6,
    TCA_ID_PEDIT = 7,
    TCA_ID_MIRRED = 8,
    TCA_ID_NAT = 9,
    TCA_ID_XT = 10,
    TCA_ID_SKBEDIT = 11,
    TCA_ID_VLAN = 12,
    TCA_ID_BPF = 13,
    TCA_ID_CONNMARK = 14,
    TCA_ID_SKBMOD = 15,
    TCA_ID_CSUM = 16,
    TCA_ID_TUNNEL_KEY = 17,
    TCA_ID_SIMP = 22,
    TCA_ID_IFE = 25,
    TCA_ID_SAMPLE = 26,
    TCA_ID_CTINFO = 27,
    TCA_ID_MPLS = 28,
    TCA_ID_CT = 29,
    __TCA_ID_MAX = 255
};
#line 140  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/pkt_cls.h"
struct tcf_t {
   __u64 install ;
   __u64 lastuse ;
   __u64 expires ;
   __u64 firstuse ;
};
#line 212  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/pkt_cls.h"
struct tc_u32_key {
   __be32 mask ;
   __be32 val ;
   int off ;
   int offmask ;
};
#line 219  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/pkt_cls.h"
struct tc_u32_sel {
   unsigned char flags ;
   unsigned char offshift ;
   unsigned char nkeys ;
   __be16 offmask ;
   __u16 off ;
   short offoff ;
   short hoff ;
   __be32 hmask ;
   struct tc_u32_key keys[0U] ;
};
#line 302  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct gro_list {
   struct list_head list ;
   int count ;
};
#line 316  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned long gro_bitmask ;
   int (*poll)(struct napi_struct *, int ) ;
   int poll_owner ;
   struct net_device *dev ;
   struct gro_list gro_hash[8U] ;
   struct sk_buff *skb ;
   struct list_head rx_list ;
   int rx_count ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
#line 362 
enum gro_result {
    GRO_MERGED = 0,
    GRO_MERGED_FREE = 1,
    GRO_HELD = 2,
    GRO_NORMAL = 3,
    GRO_DROP = 4,
    GRO_CONSUMED = 5
};
#line 371  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
typedef enum gro_result gro_result_t;
#line 3610 
enum skb_free_reason {
    SKB_REASON_CONSUMED = 0,
    SKB_REASON_DROPPED = 1
};
#line 86  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ip.h"
struct iphdr {
   __u8 ihl : 4 ;
   __u8 version : 4 ;
   __u8 tos ;
   __be16 tot_len ;
   __be16 id ;
   __be16 frag_off ;
   __u8 ttl ;
   __u8 protocol ;
   __sum16 check ;
   __be32 saddr ;
   __be32 daddr ;
};
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/page_counter.h"
struct page_counter {
   atomic_long_t usage ;
   unsigned long min ;
   unsigned long low ;
   unsigned long max ;
   struct page_counter *parent ;
   unsigned long emin ;
   atomic_long_t min_usage ;
   atomic_long_t children_min_usage ;
   unsigned long elow ;
   atomic_long_t low_usage ;
   atomic_long_t children_low_usage ;
   unsigned long watermark ;
   unsigned long failcnt ;
};
#line 66 
struct eventfd_ctx;
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/vmpressure.h"
struct vmpressure {
   unsigned long scanned ;
   unsigned long reclaimed ;
   unsigned long tree_scanned ;
   unsigned long tree_reclaimed ;
   spinlock_t sr_lock ;
   struct list_head events ;
   struct mutex events_lock ;
   struct work_struct work ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/flex_proportions.h"
struct fprop_global {
   struct percpu_counter events ;
   unsigned int period ;
   seqcount_t sequence ;
};
#line 76  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/flex_proportions.h"
struct fprop_local_percpu {
   struct percpu_counter events ;
   unsigned int period ;
   raw_spinlock_t lock ;
};
#line 116  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/flex_proportions.h"
typedef int congested_fn(void *, int );
#line 45  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/backing-dev-defs.h"
enum wb_reason {
    WB_REASON_BACKGROUND = 0,
    WB_REASON_VMSCAN = 1,
    WB_REASON_SYNC = 2,
    WB_REASON_PERIODIC = 3,
    WB_REASON_LAPTOP_TIMER = 4,
    WB_REASON_FREE_MORE_MEM = 5,
    WB_REASON_FS_FREE_SPACE = 6,
    WB_REASON_FORKER_THREAD = 7,
    WB_REASON_FOREIGN_FLUSH = 8,
    WB_REASON_MAX = 9
};
#line 71  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/backing-dev-defs.h"
struct wb_completion {
   atomic_t cnt ;
   wait_queue_head_t *waitq ;
};
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/backing-dev-defs.h"
struct bdi_writeback_congested {
   unsigned long state ;
   refcount_t refcnt ;
   struct backing_dev_info *__bdi ;
   int blkcg_id ;
   struct rb_node rb_node ;
};
#line 130  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/backing-dev-defs.h"
union __anonunion_2155 {
   struct work_struct release_work ;
   struct callback_head rcu ;
};
#line 130  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/backing-dev-defs.h"
struct bdi_writeback {
   struct backing_dev_info *bdi ;
   unsigned long state ;
   unsigned long last_old_flush ;
   struct list_head b_dirty ;
   struct list_head b_io ;
   struct list_head b_more_io ;
   struct list_head b_dirty_time ;
   spinlock_t list_lock ;
   struct percpu_counter stat[4U] ;
   struct bdi_writeback_congested *congested ;
   unsigned long bw_time_stamp ;
   unsigned long dirtied_stamp ;
   unsigned long written_stamp ;
   unsigned long write_bandwidth ;
   unsigned long avg_write_bandwidth ;
   unsigned long dirty_ratelimit ;
   unsigned long balanced_dirty_ratelimit ;
   struct fprop_local_percpu completions ;
   int dirty_exceeded ;
   enum wb_reason start_all_reason ;
   spinlock_t work_lock ;
   struct list_head work_list ;
   struct delayed_work dwork ;
   unsigned long dirty_sleep ;
   struct list_head bdi_node ;
   struct percpu_ref refcnt ;
   struct fprop_local_percpu memcg_completions ;
   struct cgroup_subsys_state *memcg_css ;
   struct cgroup_subsys_state *blkcg_css ;
   struct list_head memcg_node ;
   struct list_head blkcg_node ;
   union __anonunion_2155 __anonCompField_bdi_writeback_162 ;
};
#line 188  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/backing-dev-defs.h"
struct backing_dev_info {
   u64 id ;
   struct rb_node rb_node ;
   struct list_head bdi_list ;
   unsigned long ra_pages ;
   unsigned long io_pages ;
   congested_fn *congested_fn ;
   void *congested_data ;
   char *name ;
   struct kref refcnt ;
   unsigned int capabilities ;
   unsigned int min_ratio ;
   unsigned int max_ratio ;
   unsigned int max_prop_frac ;
   atomic_long_t tot_write_bandwidth ;
   struct bdi_writeback wb ;
   struct list_head wb_list ;
   struct xarray cgwb_tree ;
   struct rb_root cgwb_congested_tree ;
   struct mutex cgwb_release_mutex ;
   struct rw_semaphore wb_switch_rwsem ;
   wait_queue_head_t wb_waitq ;
   struct device *dev ;
   struct device *owner ;
   struct timer_list laptop_mode_wb_timer ;
   struct dentry *debug_dir ;
};
#line 306 
struct bio_set;
#line 307 
struct bio_integrity_payload;
#line 308  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/backing-dev-defs.h"
typedef void bio_end_io_t(struct bio *);
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk_types.h"
typedef u8 blk_status_t;
#line 112  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk_types.h"
struct bio_issue {
   u64 value ;
};
#line 144 
struct blkcg_gq;
#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk_types.h"
union __anonunion_2156 {
   struct bio_integrity_payload *bi_integrity ;
};
#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk_types.h"
struct bio {
   struct bio *bi_next ;
   struct gendisk *bi_disk ;
   unsigned int bi_opf ;
   unsigned short bi_flags ;
   unsigned short bi_ioprio ;
   unsigned short bi_write_hint ;
   blk_status_t bi_status ;
   u8 bi_partno ;
   atomic_t __bi_remaining ;
   struct bvec_iter bi_iter ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
   struct blkcg_gq *bi_blkg ;
   struct bio_issue bi_issue ;
   u64 bi_iocost_cost ;
   union __anonunion_2156 __anonCompField_bio_163 ;
   unsigned short bi_vcnt ;
   unsigned short bi_max_vecs ;
   atomic_t __bi_cnt ;
   struct bio_vec *bi_io_vec ;
   struct bio_set *bi_pool ;
   struct bio_vec bi_inline_vecs[0U] ;
};
#line 452  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk_types.h"
typedef unsigned int blk_qc_t;
#line 479  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk_types.h"
struct blk_rq_stat {
   u64 mean ;
   u64 min ;
   u64 max ;
   u32 nr_samples ;
   u64 batch ;
};
#line 86  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/genhd.h"
struct disk_stats {
   u64 nsecs[4U] ;
   unsigned long sectors[4U] ;
   unsigned long ios[4U] ;
   unsigned long merges[4U] ;
   unsigned long io_ticks ;
   unsigned long time_in_queue ;
   local_t in_flight[2U] ;
};
#line 103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/genhd.h"
struct partition_meta_info {
   char uuid[37U] ;
   u8 volname[64U] ;
};
#line 108  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/genhd.h"
struct hd_struct {
   sector_t start_sect ;
   sector_t nr_sects ;
   seqcount_t nr_sects_seq ;
   sector_t alignment_offset ;
   unsigned int discard_alignment ;
   struct device __dev ;
   struct kobject *holder_dir ;
   int policy ;
   int partno ;
   struct partition_meta_info *info ;
   int make_it_fail ;
   unsigned long stamp ;
   struct disk_stats *dkstats ;
   struct percpu_ref ref ;
   struct rcu_work rcu_work ;
};
#line 160  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/genhd.h"
struct disk_part_tbl {
   struct callback_head callback_head ;
   int len ;
   struct hd_struct *last_lookup ;
   struct hd_struct *part[] ;
};
#line 166 
struct disk_events;
#line 167 
struct badblocks;
#line 172 
struct blk_integrity_profile;
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/genhd.h"
struct blk_integrity {
   struct blk_integrity_profile *profile ;
   unsigned char flags ;
   unsigned char tuple_size ;
   unsigned char interval_exp ;
   unsigned char tag_size ;
};
#line 182 
struct timer_rand_state;
#line 182  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/genhd.h"
struct gendisk {
   int major ;
   int first_minor ;
   int minors ;
   char disk_name[32U] ;
   char *(*devnode)(struct gendisk *, umode_t *) ;
   unsigned short events ;
   unsigned short event_flags ;
   struct disk_part_tbl *part_tbl ;
   struct hd_struct part0 ;
   struct block_device_operations *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct rw_semaphore lookup_sem ;
   struct kobject *slave_dir ;
   struct timer_rand_state *random ;
   atomic_t sync_io ;
   struct disk_events *ev ;
   struct kobject integrity_kobj ;
   int node_id ;
   struct badblocks *bb ;
   struct lockdep_map lockdep_map ;
};
#line 637  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pagemap.h"
typedef void *mempool_alloc_t(gfp_t , void *);
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mempool.h"
typedef void mempool_free_t(void *, void *);
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mempool.h"
struct mempool_s {
   spinlock_t lock ;
   int min_nr ;
   int curr_nr ;
   void **elements ;
   void *pool_data ;
   mempool_alloc_t *alloc ;
   mempool_free_t *free ;
   wait_queue_head_t wait ;
};
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mempool.h"
typedef struct mempool_s mempool_t;
#line 307  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bio.h"
struct bio_integrity_payload {
   struct bio *bip_bio ;
   struct bvec_iter bip_iter ;
   unsigned short bip_slab ;
   unsigned short bip_vcnt ;
   unsigned short bip_max_vcnt ;
   unsigned short bip_flags ;
   struct bvec_iter bio_iter ;
   struct work_struct bip_work ;
   struct bio_vec *bip_vec ;
   struct bio_vec bip_inline_vecs[0U] ;
};
#line 575  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bio.h"
struct bio_list {
   struct bio *head ;
   struct bio *tail ;
};
#line 703  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bio.h"
struct bio_set {
   struct kmem_cache *bio_slab ;
   unsigned int front_pad ;
   mempool_t bio_pool ;
   mempool_t bvec_pool ;
   mempool_t bio_integrity_pool ;
   mempool_t bvec_integrity_pool ;
   spinlock_t rescue_lock ;
   struct bio_list rescue_list ;
   struct work_struct rescue_work ;
   struct workqueue_struct *rescue_workqueue ;
};
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bsg.h"
struct sg_io_v4 {
   __s32 guard ;
   __u32 protocol ;
   __u32 subprotocol ;
   __u32 request_len ;
   __u64 request ;
   __u64 request_tag ;
   __u32 request_attr ;
   __u32 request_priority ;
   __u32 request_extra ;
   __u32 max_response_len ;
   __u64 response ;
   __u32 dout_iovec_count ;
   __u32 dout_xfer_len ;
   __u32 din_iovec_count ;
   __u32 din_xfer_len ;
   __u64 dout_xferp ;
   __u64 din_xferp ;
   __u32 timeout ;
   __u32 flags ;
   __u64 usr_ptr ;
   __u32 spare_in ;
   __u32 driver_status ;
   __u32 transport_status ;
   __u32 device_status ;
   __u32 retry_delay ;
   __u32 info ;
   __u32 duration ;
   __u32 response_len ;
   __s32 din_resid ;
   __s32 dout_resid ;
   __u64 generated_tag ;
   __u32 spare_out ;
   __u32 padding ;
};
#line 65 
struct request;
#line 10  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bsg.h"
struct bsg_ops {
   int (*check_proto)(struct sg_io_v4 *) ;
   int (*fill_hdr)(struct request *, struct sg_io_v4 *, fmode_t ) ;
   int (*complete_rq)(struct request *, struct sg_io_v4 *) ;
   void (*free_rq)(struct request *) ;
};
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bsg.h"
struct bsg_class_device {
   struct device *class_dev ;
   int minor ;
   struct request_queue *queue ;
   struct bsg_ops *ops ;
};
#line 94  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/blkzoned.h"
struct blk_zone {
   __u64 start ;
   __u64 len ;
   __u64 wp ;
   __u8 type ;
   __u8 cond ;
   __u8 non_seq ;
   __u8 reset ;
   __u8 reserved[36U] ;
};
#line 134 
struct elevator_queue;
#line 135 
struct blk_trace;
#line 138 
struct blk_flush_queue;
#line 139 
struct pr_ops;
#line 140 
struct rq_qos;
#line 141 
struct blk_queue_stats;
#line 142 
struct blk_stat_callback;
#line 143  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/blkzoned.h"
typedef void rq_end_io_fn(struct request *, blk_status_t );
#line 63  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
typedef __u32 req_flags_t;
#line 67 
enum mq_rq_state {
    MQ_RQ_IDLE = 0,
    MQ_RQ_IN_FLIGHT = 1,
    MQ_RQ_COMPLETE = 2
};
#line 132 
struct blk_mq_ctx;
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
union __anonunion_2159 {
   struct hlist_node hash ;
   struct list_head ipi_list ;
};
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
union __anonunion_2160 {
   struct rb_node rb_node ;
   struct bio_vec special_vec ;
   void *completion_data ;
   int error_count ;
};
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
struct __anonstruct_elv_2162 {
   struct io_cq *icq ;
   void *priv[2U] ;
};
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
struct __anonstruct_flush_2163 {
   unsigned int seq ;
   struct list_head list ;
   rq_end_io_fn *saved_end_io ;
};
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
union __anonunion_2161 {
   struct __anonstruct_elv_2162 elv ;
   struct __anonstruct_flush_2163 flush ;
};
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
union __anonunion_2164 {
   struct __call_single_data csd ;
   u64 fifo_time ;
};
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
struct request {
   struct request_queue *q ;
   struct blk_mq_ctx *mq_ctx ;
   struct blk_mq_hw_ctx *mq_hctx ;
   unsigned int cmd_flags ;
   req_flags_t rq_flags ;
   int tag ;
   int internal_tag ;
   unsigned int __data_len ;
   sector_t __sector ;
   struct bio *bio ;
   struct bio *biotail ;
   struct list_head queuelist ;
   union __anonunion_2159 __anonCompField_request_164 ;
   union __anonunion_2160 __anonCompField_request_165 ;
   union __anonunion_2161 __anonCompField_request_166 ;
   struct gendisk *rq_disk ;
   struct hd_struct *part ;
   u64 alloc_time_ns ;
   u64 start_time_ns ;
   u64 io_start_time_ns ;
   unsigned short wbt_flags ;
   unsigned short stats_sectors ;
   unsigned short nr_phys_segments ;
   unsigned short nr_integrity_segments ;
   unsigned short write_hint ;
   unsigned short ioprio ;
   unsigned int extra_len ;
   enum mq_rq_state state ;
   refcount_t ref ;
   unsigned int timeout ;
   unsigned long deadline ;
   union __anonunion_2164 __anonCompField_request_167 ;
   rq_end_io_fn *end_io ;
   void *end_io_data ;
};
#line 285 
struct elevator_type;
#line 286 
struct blk_mq_debugfs_attr;
#line 287 
enum elv_merge {
    ELEVATOR_NO_MERGE = 0,
    ELEVATOR_FRONT_MERGE = 1,
    ELEVATOR_BACK_MERGE = 2,
    ELEVATOR_DISCARD_MERGE = 3
};
#line 294 
struct blk_mq_alloc_data;
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/elevator.h"
struct elevator_mq_ops {
   int (*init_sched)(struct request_queue *, struct elevator_type *) ;
   void (*exit_sched)(struct elevator_queue *) ;
   int (*init_hctx)(struct blk_mq_hw_ctx *, unsigned int ) ;
   void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int ) ;
   void (*depth_updated)(struct blk_mq_hw_ctx *) ;
   bool (*allow_merge)(struct request_queue *, struct request *, struct bio *) ;
   bool (*bio_merge)(struct blk_mq_hw_ctx *, struct bio *, unsigned int ) ;
   int (*request_merge)(struct request_queue *, struct request **, struct bio *) ;
   void (*request_merged)(struct request_queue *, struct request *, enum elv_merge ) ;
   void (*requests_merged)(struct request_queue *, struct request *, struct request *) ;
   void (*limit_depth)(unsigned int , struct blk_mq_alloc_data *) ;
   void (*prepare_request)(struct request *, struct bio *) ;
   void (*finish_request)(struct request *) ;
   void (*insert_requests)(struct blk_mq_hw_ctx *, struct list_head *, bool ) ;
   struct request *(*dispatch_request)(struct blk_mq_hw_ctx *) ;
   bool (*has_work)(struct blk_mq_hw_ctx *) ;
   void (*completed_request)(struct request *, u64 ) ;
   void (*requeue_request)(struct request *) ;
   struct request *(*former_request)(struct request_queue *, struct request *) ;
   struct request *(*next_request)(struct request_queue *, struct request *) ;
   void (*init_icq)(struct io_cq *) ;
   void (*exit_icq)(struct io_cq *) ;
};
#line 57  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/elevator.h"
struct elv_fs_entry {
   struct attribute attr ;
   ssize_t (*show)(struct elevator_queue *, char *) ;
   ssize_t (*store)(struct elevator_queue *, char *, size_t ) ;
};
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/elevator.h"
struct elevator_type {
   struct kmem_cache *icq_cache ;
   struct elevator_mq_ops ops ;
   size_t icq_size ;
   size_t icq_align ;
   struct elv_fs_entry *elevator_attrs ;
   char *elevator_name ;
   char *elevator_alias ;
   unsigned int elevator_features ;
   struct module *elevator_owner ;
   struct blk_mq_debugfs_attr *queue_debugfs_attrs ;
   struct blk_mq_debugfs_attr *hctx_debugfs_attrs ;
   char icq_cache_name[22U] ;
   struct list_head list ;
};
#line 101  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/elevator.h"
struct elevator_queue {
   struct elevator_type *type ;
   void *elevator_data ;
   struct kobject kobj ;
   struct mutex sysfs_lock ;
   unsigned int registered : 1 ;
   struct hlist_head hash[64U] ;
};
#line 153  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/elevator.h"
typedef blk_qc_t make_request_fn(struct request_queue *, struct bio *);
#line 291  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
typedef int dma_drain_needed_fn(struct request *);
#line 304 
enum blk_zoned_model {
    BLK_ZONED_NONE = 0,
    BLK_ZONED_HA = 1,
    BLK_ZONED_HM = 2
};
#line 320  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
struct queue_limits {
   unsigned long bounce_pfn ;
   unsigned long seg_boundary_mask ;
   unsigned long virt_boundary_mask ;
   unsigned int max_hw_sectors ;
   unsigned int max_dev_sectors ;
   unsigned int chunk_sectors ;
   unsigned int max_sectors ;
   unsigned int max_segment_size ;
   unsigned int physical_block_size ;
   unsigned int logical_block_size ;
   unsigned int alignment_offset ;
   unsigned int io_min ;
   unsigned int io_opt ;
   unsigned int max_discard_sectors ;
   unsigned int max_hw_discard_sectors ;
   unsigned int max_write_same_sectors ;
   unsigned int max_write_zeroes_sectors ;
   unsigned int discard_granularity ;
   unsigned int discard_alignment ;
   unsigned short max_segments ;
   unsigned short max_integrity_segments ;
   unsigned short max_discard_segments ;
   unsigned char misaligned ;
   unsigned char discard_misaligned ;
   unsigned char raid_partial_stripes_expensive ;
   enum blk_zoned_model zoned ;
};
#line 394 
struct throtl_data;
#line 394  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
struct request_queue {
   struct request *last_merge ;
   struct elevator_queue *elevator ;
   struct blk_queue_stats *stats ;
   struct rq_qos *rq_qos ;
   make_request_fn *make_request_fn ;
   dma_drain_needed_fn *dma_drain_needed ;
   struct blk_mq_ops *mq_ops ;
   struct blk_mq_ctx *queue_ctx ;
   unsigned int queue_depth ;
   struct blk_mq_hw_ctx **queue_hw_ctx ;
   unsigned int nr_hw_queues ;
   struct backing_dev_info *backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
   atomic_t pm_only ;
   int id ;
   gfp_t bounce_gfp ;
   spinlock_t queue_lock ;
   struct kobject kobj ;
   struct kobject *mq_kobj ;
   struct blk_integrity integrity ;
   struct device *dev ;
   int rpm_status ;
   unsigned int nr_pending ;
   unsigned long nr_requests ;
   unsigned int dma_drain_size ;
   void *dma_drain_buffer ;
   unsigned int dma_pad_mask ;
   unsigned int dma_alignment ;
   unsigned int rq_timeout ;
   int poll_nsec ;
   struct blk_stat_callback *poll_cb ;
   struct blk_rq_stat poll_stat[16U] ;
   struct timer_list timeout ;
   struct work_struct timeout_work ;
   struct list_head icq_list ;
   unsigned long blkcg_pols[1U] ;
   struct blkcg_gq *root_blkg ;
   struct list_head blkg_list ;
   struct queue_limits limits ;
   unsigned int required_elevator_features ;
   unsigned int nr_zones ;
   unsigned long *conv_zones_bitmap ;
   unsigned long *seq_zones_wlock ;
   unsigned int sg_timeout ;
   unsigned int sg_reserved_size ;
   int node ;
   struct blk_trace *blk_trace ;
   struct mutex blk_trace_mutex ;
   struct blk_flush_queue *fq ;
   struct list_head requeue_list ;
   spinlock_t requeue_lock ;
   struct delayed_work requeue_work ;
   struct mutex sysfs_lock ;
   struct mutex sysfs_dir_lock ;
   struct list_head unused_hctx_list ;
   spinlock_t unused_hctx_lock ;
   int mq_freeze_depth ;
   struct bsg_class_device bsg_dev ;
   struct throtl_data *td ;
   struct callback_head callback_head ;
   wait_queue_head_t mq_freeze_wq ;
   struct mutex mq_freeze_lock ;
   struct percpu_ref q_usage_counter ;
   struct blk_mq_tag_set *tag_set ;
   struct list_head tag_set_list ;
   struct bio_set bio_split ;
   struct dentry *debugfs_dir ;
   struct dentry *sched_debugfs_dir ;
   struct dentry *rqos_debugfs_dir ;
   bool mq_sysfs_init_done ;
   size_t cmd_size ;
   struct work_struct release_work ;
   u64 write_hints[5U] ;
};
#line 1160  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
struct blk_plug {
   struct list_head mq_list ;
   struct list_head cb_list ;
   unsigned short rq_count ;
   bool multiple_queues ;
};
#line 1514  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
struct blk_integrity_iter {
   void *prot_buf ;
   void *data_buf ;
   sector_t seed ;
   unsigned int data_size ;
   unsigned short interval ;
   char *disk_name ;
};
#line 1522  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
typedef blk_status_t integrity_processing_fn(struct blk_integrity_iter *);
#line 1524  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
typedef void integrity_prepare_fn(struct request *);
#line 1525  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
typedef void integrity_complete_fn(struct request *, unsigned int );
#line 1527  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
struct blk_integrity_profile {
   integrity_processing_fn *generate_fn ;
   integrity_processing_fn *verify_fn ;
   integrity_prepare_fn *prepare_fn ;
   integrity_complete_fn *complete_fn ;
   char *name ;
};
#line 1693  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
struct block_device_operations {
   int (*open)(struct block_device *, fmode_t ) ;
   void (*release)(struct gendisk *, fmode_t ) ;
   int (*rw_page)(struct block_device *, sector_t , struct page *, unsigned int ) ;
   int (*ioctl)(struct block_device *, fmode_t , unsigned int , unsigned long ) ;
   int (*compat_ioctl)(struct block_device *, fmode_t , unsigned int , unsigned long ) ;
   unsigned int (*check_events)(struct gendisk *, unsigned int ) ;
   int (*media_changed)(struct gendisk *) ;
   void (*unlock_native_capacity)(struct gendisk *) ;
   int (*revalidate_disk)(struct gendisk *) ;
   int (*getgeo)(struct block_device *, struct hd_geometry *) ;
   void (*swap_slot_free_notify)(struct block_device *, unsigned long ) ;
   int (*report_zones)(struct gendisk *, sector_t , unsigned int , int (*)(struct blk_zone *, unsigned int , void *), void *) ;
   struct module *owner ;
   struct pr_ops *pr_ops ;
};
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-cgroup.h"
struct blkcg_policy_data;
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-cgroup.h"
struct blkcg {
   struct cgroup_subsys_state css ;
   spinlock_t lock ;
   struct xarray blkg_tree ;
   struct blkcg_gq *blkg_hint ;
   struct hlist_head blkg_list ;
   struct blkcg_policy_data *cpd[5U] ;
   struct list_head all_blkcgs_node ;
   struct list_head cgwb_list ;
   refcount_t cgwb_refcnt ;
};
#line 63  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-cgroup.h"
struct blkg_iostat {
   u64 bytes[3U] ;
   u64 ios[3U] ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-cgroup.h"
struct blkg_iostat_set {
   struct u64_stats_sync sync ;
   struct blkg_iostat cur ;
   struct blkg_iostat last ;
};
#line 85  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-cgroup.h"
struct blkg_policy_data {
   struct blkcg_gq *blkg ;
   int plid ;
};
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-cgroup.h"
struct blkcg_policy_data {
   struct blkcg *blkcg ;
   int plid ;
};
#line 105  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-cgroup.h"
struct blkcg_gq {
   struct request_queue *q ;
   struct list_head q_node ;
   struct hlist_node blkcg_node ;
   struct blkcg *blkcg ;
   struct bdi_writeback_congested *wb_congested ;
   struct blkcg_gq *parent ;
   struct percpu_ref refcnt ;
   bool online ;
   struct blkg_iostat_set *iostat_cpu ;
   struct blkg_iostat_set iostat ;
   struct blkg_policy_data *pd[5U] ;
   spinlock_t async_bio_lock ;
   struct bio_list async_bios ;
   struct work_struct async_bio_work ;
   atomic_t use_delay ;
   atomic64_t delay_nsec ;
   atomic64_t delay_start ;
   u64 last_delay ;
   int last_use ;
   struct callback_head callback_head ;
};
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/writeback.h"
enum writeback_sync_modes {
    WB_SYNC_NONE = 0,
    WB_SYNC_ALL = 1
};
#line 51  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/writeback.h"
struct writeback_control {
   long nr_to_write ;
   long pages_skipped ;
   loff_t range_start ;
   loff_t range_end ;
   enum writeback_sync_modes sync_mode ;
   unsigned int for_kupdate : 1 ;
   unsigned int for_background : 1 ;
   unsigned int tagged_writepages : 1 ;
   unsigned int for_reclaim : 1 ;
   unsigned int range_cyclic : 1 ;
   unsigned int for_sync : 1 ;
   unsigned int no_cgroup_owner : 1 ;
   unsigned int punt_to_cgroup : 1 ;
   struct bdi_writeback *wb ;
   struct inode *inode ;
   int wb_id ;
   int wb_lcand_id ;
   int wb_tcand_id ;
   size_t wb_bytes ;
   size_t wb_lcand_bytes ;
   size_t wb_tcand_bytes ;
};
#line 129  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/writeback.h"
struct wb_domain {
   spinlock_t lock ;
   struct fprop_global completions ;
   struct timer_list period_timer ;
   unsigned long period_time ;
   unsigned long dirty_limit_tstamp ;
   unsigned long dirty_limit ;
};
#line 69  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memcontrol.h"
struct mem_cgroup_id {
   int id ;
   refcount_t ref ;
};
#line 86  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memcontrol.h"
struct memcg_vmstats_percpu {
   long stat[38U] ;
   unsigned long events[91U] ;
   unsigned long nr_page_events ;
   unsigned long targets[2U] ;
};
#line 93  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memcontrol.h"
struct mem_cgroup_reclaim_iter {
   struct mem_cgroup *position ;
   unsigned int generation ;
};
#line 99  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memcontrol.h"
struct lruvec_stat {
   long count[32U] ;
};
#line 107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memcontrol.h"
struct memcg_shrinker_map {
   struct callback_head rcu ;
   unsigned long map[0U] ;
};
#line 115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memcontrol.h"
struct mem_cgroup_per_node {
   struct lruvec lruvec ;
   struct lruvec_stat *lruvec_stat_local ;
   struct lruvec_stat *lruvec_stat_cpu ;
   atomic_long_t lruvec_stat[32U] ;
   unsigned long lru_zone_size[5U][5U] ;
   struct mem_cgroup_reclaim_iter iter ;
   struct memcg_shrinker_map *shrinker_map ;
   struct rb_node tree_node ;
   unsigned long usage_in_excess ;
   bool on_tree ;
   struct mem_cgroup *memcg ;
};
#line 139  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memcontrol.h"
struct mem_cgroup_threshold {
   struct eventfd_ctx *eventfd ;
   unsigned long threshold ;
};
#line 145  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memcontrol.h"
struct mem_cgroup_threshold_ary {
   int current_threshold ;
   unsigned int size ;
   struct mem_cgroup_threshold entries[0U] ;
};
#line 154  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memcontrol.h"
struct mem_cgroup_thresholds {
   struct mem_cgroup_threshold_ary *primary ;
   struct mem_cgroup_threshold_ary *spare ;
};
#line 164 
enum memcg_kmem_state {
    KMEM_NONE = 0,
    KMEM_ALLOCATED = 1,
    KMEM_ONLINE = 2
};
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memcontrol.h"
struct memcg_padding {
   char x[0U] ;
} __attribute__((__aligned__(4096)));
#line 190  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memcontrol.h"
struct memcg_cgwb_frn {
   u64 bdi_id ;
   int memcg_id ;
   u64 at ;
   struct wb_completion done ;
};
#line 203  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memcontrol.h"
struct mem_cgroup {
   struct cgroup_subsys_state css ;
   struct mem_cgroup_id id ;
   struct page_counter memory ;
   struct page_counter swap ;
   struct page_counter memsw ;
   struct page_counter kmem ;
   struct page_counter tcpmem ;
   unsigned long high ;
   struct work_struct high_work ;
   unsigned long soft_limit ;
   struct vmpressure vmpressure ;
   bool use_hierarchy ;
   bool oom_group ;
   bool oom_lock ;
   int under_oom ;
   int swappiness ;
   int oom_kill_disable ;
   struct cgroup_file events_file ;
   struct cgroup_file events_local_file ;
   struct cgroup_file swap_events_file ;
   struct mutex thresholds_lock ;
   struct mem_cgroup_thresholds thresholds ;
   struct mem_cgroup_thresholds memsw_thresholds ;
   struct list_head oom_notify ;
   unsigned long move_charge_at_immigrate ;
   spinlock_t move_lock ;
   unsigned long move_lock_flags ;
   struct memcg_padding _pad1_ ;
   atomic_t moving_account ;
   struct task_struct *move_lock_task ;
   struct memcg_vmstats_percpu *vmstats_local ;
   struct memcg_vmstats_percpu *vmstats_percpu ;
   struct memcg_padding _pad2_ ;
   atomic_long_t vmstats[38U] ;
   atomic_long_t vmevents[91U] ;
   atomic_long_t memory_events[7U] ;
   atomic_long_t memory_events_local[7U] ;
   unsigned long socket_pressure ;
   bool tcpmem_active ;
   int tcpmem_pressure ;
   int kmemcg_id ;
   enum memcg_kmem_state kmem_state ;
   struct list_head kmem_caches ;
   struct list_head cgwb_list ;
   struct wb_domain cgwb_domain ;
   struct memcg_cgwb_frn cgwb_frn[4U] ;
   struct list_head event_list ;
   spinlock_t event_list_lock ;
   struct deferred_split deferred_split_queue ;
   struct mem_cgroup_per_node *nodeinfo[0U] ;
};
#line 567  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/rtnetlink.h"
struct tcmsg {
   unsigned char tcm_family ;
   unsigned char tcm__pad1 ;
   unsigned short tcm__pad2 ;
   int tcm_ifindex ;
   __u32 tcm_handle ;
   __u32 tcm_parent ;
   __u32 tcm_info ;
};
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_vlan.h"
struct vlan_hdr {
   __be16 h_vlan_TCI ;
   __be16 h_vlan_encapsulated_proto ;
};
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_vlan.h"
struct vlan_ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_vlan_proto ;
   __be16 h_vlan_TCI ;
   __be16 h_vlan_encapsulated_proto ;
};
#line 116  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_vlan.h"
struct vlan_pcpu_stats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 rx_multicast ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
   u32 rx_errors ;
   u32 tx_dropped ;
};
#line 149 
struct netpoll;
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/gen_stats.h"
struct gnet_stats_queue {
   __u32 qlen ;
   __u32 backlog ;
   __u32 drops ;
   __u32 requeues ;
   __u32 overlimits ;
};
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/gen_stats.h"
struct gnet_stats_basic_packed {
   __u64 bytes ;
   __u64 packets ;
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/gen_stats.h"
struct gnet_stats_basic_cpu {
   struct gnet_stats_basic_packed bstats ;
   struct u64_stats_sync syncp ;
} __attribute__((__aligned__(16)));
#line 20 
struct net_rate_estimator;
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/gen_stats.h"
struct gnet_dump {
   spinlock_t *lock ;
   struct sk_buff *skb ;
   struct nlattr *tail ;
   int compat_tc_stats ;
   int compat_xstats ;
   int padattr ;
   void *xstats ;
   int xstats_len ;
   struct tc_stats tc_stats ;
};
#line 291  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
struct __anonstruct_2191 {
   s16 min ;
   s16 max ;
};
#line 291  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
union __anonunion_2190 {
   void *validation_data ;
   struct __anonstruct_2191 __anonCompField___anonunion_2190_168 ;
   int (*validate)(struct nlattr *, struct netlink_ext_ack *) ;
   u16 strict_start_type ;
};
#line 291  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
struct nla_policy {
   u8 type ;
   u8 validation_type ;
   u16 len ;
   union __anonunion_2190 __anonCompField_nla_policy_169 ;
};
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/rtnetlink.h"
struct rtnl_link_ops {
   struct list_head list ;
   char *kind ;
   size_t priv_size ;
   void (*setup)(struct net_device *) ;
   unsigned int maxtype ;
   struct nla_policy *policy ;
   int (*validate)(struct nlattr **, struct nlattr **, struct netlink_ext_ack *) ;
   int (*newlink)(struct net *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *) ;
   int (*changelink)(struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *) ;
   void (*dellink)(struct net_device *, struct list_head *) ;
   size_t (*get_size)(struct net_device *) ;
   int (*fill_info)(struct sk_buff *, struct net_device *) ;
   size_t (*get_xstats_size)(struct net_device *) ;
   int (*fill_xstats)(struct sk_buff *, struct net_device *) ;
   unsigned int (*get_num_tx_queues)(void) ;
   unsigned int (*get_num_rx_queues)(void) ;
   unsigned int slave_maxtype ;
   struct nla_policy *slave_policy ;
   int (*slave_changelink)(struct net_device *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *) ;
   size_t (*get_slave_size)(struct net_device *, struct net_device *) ;
   int (*fill_slave_info)(struct sk_buff *, struct net_device *, struct net_device *) ;
   struct net *(*get_link_net)(struct net_device *) ;
   size_t (*get_linkxstats_size)(struct net_device *, int ) ;
   int (*fill_linkxstats)(struct sk_buff *, struct net_device *, int *, int ) ;
};
#line 173  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jhash.h"
struct rhash_lock_head {
   };
#line 76  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rhashtable.h"
struct bucket_table {
   unsigned int size ;
   unsigned int nest ;
   u32 hash_rnd ;
   struct list_head walkers ;
   struct callback_head rcu ;
   struct bucket_table *future_tbl ;
   struct lockdep_map dep_map ;
   struct rhash_lock_head *buckets[] ;
};
#line 159  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct psample_group;
#line 270 
enum flow_block_command {
    FLOW_BLOCK_BIND = 0,
    FLOW_BLOCK_UNBIND = 1
};
#line 275 
enum flow_block_binder_type {
    FLOW_BLOCK_BINDER_TYPE_UNSPEC = 0,
    FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS = 1,
    FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS = 2
};
#line 281  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct flow_block {
   struct list_head cb_list ;
};
#line 287  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct flow_block_offload {
   enum flow_block_command command ;
   enum flow_block_binder_type binder_type ;
   bool block_shared ;
   bool unlocked_driver_cb ;
   struct net *net ;
   struct flow_block *block ;
   struct list_head cb_list ;
   struct list_head *driver_block_list ;
   struct netlink_ext_ack *extack ;
};
#line 298  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
typedef int flow_setup_cb_t(enum tc_setup_type , void *, void *);
#line 353  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct flow_cls_common_offload {
   u32 chain_index ;
   __be16 protocol ;
   u32 prio ;
   struct netlink_ext_ack *extack ;
};
#line 412 
struct Qdisc_ops;
#line 413 
struct qdisc_walker;
#line 414 
struct tcf_walker;
#line 41  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct qdisc_size_table {
   struct callback_head rcu ;
   struct list_head list ;
   struct tc_sizespec szopts ;
   int refcnt ;
   u16 data[] ;
};
#line 50  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct qdisc_skb_head {
   struct sk_buff *head ;
   struct sk_buff *tail ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 57  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct Qdisc {
   int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **) ;
   struct sk_buff *(*dequeue)(struct Qdisc *) ;
   unsigned int flags ;
   u32 limit ;
   struct Qdisc_ops *ops ;
   struct qdisc_size_table *stab ;
   struct hlist_node hash ;
   u32 handle ;
   u32 parent ;
   struct netdev_queue *dev_queue ;
   struct net_rate_estimator *rate_est ;
   struct gnet_stats_basic_cpu *cpu_bstats ;
   struct gnet_stats_queue *cpu_qstats ;
   int padded ;
   refcount_t refcnt ;
   struct sk_buff_head gso_skb ;
   struct qdisc_skb_head q ;
   struct gnet_stats_basic_packed bstats ;
   seqcount_t running ;
   struct gnet_stats_queue qstats ;
   unsigned long state ;
   struct Qdisc *next_sched ;
   struct sk_buff_head skb_bad_txq ;
   spinlock_t busylock ;
   spinlock_t seqlock ;
   bool empty ;
   struct callback_head rcu ;
};
#line 195 
struct tcf_block;
#line 195  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct Qdisc_class_ops {
   unsigned int flags ;
   struct netdev_queue *(*select_queue)(struct Qdisc *, struct tcmsg *) ;
   int (*graft)(struct Qdisc *, unsigned long , struct Qdisc *, struct Qdisc **, struct netlink_ext_ack *) ;
   struct Qdisc *(*leaf)(struct Qdisc *, unsigned long ) ;
   void (*qlen_notify)(struct Qdisc *, unsigned long ) ;
   unsigned long (*find)(struct Qdisc *, u32 ) ;
   int (*change)(struct Qdisc *, u32 , u32 , struct nlattr **, unsigned long *, struct netlink_ext_ack *) ;
   int (*delete)(struct Qdisc *, unsigned long ) ;
   void (*walk)(struct Qdisc *, struct qdisc_walker *) ;
   struct tcf_block *(*tcf_block)(struct Qdisc *, unsigned long , struct netlink_ext_ack *) ;
   unsigned long (*bind_tcf)(struct Qdisc *, unsigned long , u32 ) ;
   void (*unbind_tcf)(struct Qdisc *, unsigned long ) ;
   int (*dump)(struct Qdisc *, unsigned long , struct sk_buff *, struct tcmsg *) ;
   int (*dump_stats)(struct Qdisc *, unsigned long , struct gnet_dump *) ;
};
#line 235  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct Qdisc_ops {
   struct Qdisc_ops *next ;
   struct Qdisc_class_ops *cl_ops ;
   char id[16U] ;
   int priv_size ;
   unsigned int static_flags ;
   int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **) ;
   struct sk_buff *(*dequeue)(struct Qdisc *) ;
   struct sk_buff *(*peek)(struct Qdisc *) ;
   int (*init)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *) ;
   void (*reset)(struct Qdisc *) ;
   void (*destroy)(struct Qdisc *) ;
   int (*change)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *) ;
   void (*attach)(struct Qdisc *) ;
   int (*change_tx_queue_len)(struct Qdisc *, unsigned int ) ;
   int (*dump)(struct Qdisc *, struct sk_buff *) ;
   int (*dump_stats)(struct Qdisc *, struct gnet_dump *) ;
   void (*ingress_block_set)(struct Qdisc *, u32 ) ;
   void (*egress_block_set)(struct Qdisc *, u32 ) ;
   u32 (*ingress_block_get)(struct Qdisc *) ;
   u32 (*egress_block_get)(struct Qdisc *) ;
   struct module *owner ;
};
#line 272  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct __anonstruct_2265 {
   unsigned long class ;
   u32 classid ;
};
#line 272 
struct tcf_proto;
#line 272  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct __anonstruct_2266 {
   bool ingress ;
   struct gnet_stats_queue *qstats ;
};
#line 272  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
union __anonunion_2264 {
   struct __anonstruct_2265 __anonCompField___anonunion_2264_171 ;
   struct tcf_proto *goto_tp ;
   struct __anonstruct_2266 __anonCompField___anonunion_2264_172 ;
};
#line 272  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct tcf_result {
   union __anonunion_2264 __anonCompField_tcf_result_173 ;
};
#line 287 
struct tcf_chain;
#line 290  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct tcf_proto_ops {
   struct list_head head ;
   char kind[16U] ;
   int (*classify)(struct sk_buff *, struct tcf_proto *, struct tcf_result *) ;
   int (*init)(struct tcf_proto *) ;
   void (*destroy)(struct tcf_proto *, bool , struct netlink_ext_ack *) ;
   void *(*get)(struct tcf_proto *, u32 ) ;
   void (*put)(struct tcf_proto *, void *) ;
   int (*change)(struct net *, struct sk_buff *, struct tcf_proto *, unsigned long , u32 , struct nlattr **, void **, bool , bool , struct netlink_ext_ack *) ;
   int (*delete)(struct tcf_proto *, void *, bool *, bool , struct netlink_ext_ack *) ;
   bool (*delete_empty)(struct tcf_proto *) ;
   void (*walk)(struct tcf_proto *, struct tcf_walker *, bool ) ;
   int (*reoffload)(struct tcf_proto *, bool , flow_setup_cb_t *, void *, struct netlink_ext_ack *) ;
   void (*hw_add)(struct tcf_proto *, void *) ;
   void (*hw_del)(struct tcf_proto *, void *) ;
   void (*bind_class)(void *, u32 , unsigned long ) ;
   void *(*tmplt_create)(struct net *, struct tcf_chain *, struct nlattr **, struct netlink_ext_ack *) ;
   void (*tmplt_destroy)(void *) ;
   int (*dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool ) ;
   int (*tmplt_dump)(struct sk_buff *, struct net *, void *) ;
   struct module *owner ;
   int flags ;
};
#line 348  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct tcf_proto {
   struct tcf_proto *next ;
   void *root ;
   int (*classify)(struct sk_buff *, struct tcf_proto *, struct tcf_result *) ;
   __be16 protocol ;
   u32 prio ;
   void *data ;
   struct tcf_proto_ops *ops ;
   struct tcf_chain *chain ;
   spinlock_t lock ;
   bool deleting ;
   refcount_t refcnt ;
   struct callback_head rcu ;
   struct hlist_node destroy_ht_node ;
};
#line 386  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct tcf_chain {
   struct mutex filter_chain_lock ;
   struct tcf_proto *filter_chain ;
   struct list_head list ;
   struct tcf_block *block ;
   u32 index ;
   unsigned int refcnt ;
   unsigned int action_refcnt ;
   bool explicitly_created ;
   bool flushing ;
   struct tcf_proto_ops *tmplt_ops ;
   void *tmplt_priv ;
   struct callback_head rcu ;
};
#line 402  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct __anonstruct_chain0_2268 {
   struct tcf_chain *chain ;
   struct list_head filter_chain_list ;
};
#line 402  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct tcf_block {
   struct mutex lock ;
   struct list_head chain_list ;
   u32 index ;
   refcount_t refcnt ;
   struct net *net ;
   struct Qdisc *q ;
   struct rw_semaphore cb_lock ;
   struct flow_block flow_block ;
   struct list_head owner_list ;
   bool keep_dst ;
   atomic_t offloadcnt ;
   unsigned int nooffloaddevcnt ;
   unsigned int lockeddevcnt ;
   struct __anonstruct_chain0_2268 chain0 ;
   struct callback_head rcu ;
   struct hlist_head proto_destroy_ht[128U] ;
   struct mutex proto_destroy_lock ;
};
#line 1269  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct mini_Qdisc {
   struct tcf_proto *filter_list ;
   struct gnet_stats_basic_cpu *cpu_bstats ;
   struct gnet_stats_queue *cpu_qstats ;
   struct callback_head rcu ;
};
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/filter.h"
struct sock_filter {
   __u16 code ;
   __u8 jt ;
   __u8 jf ;
   __u32 k ;
};
#line 35 
struct sock_reuseport;
#line 513  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/filter.h"
struct sock_fprog_kern {
   u16 len ;
   struct sock_filter *filter ;
};
#line 526  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/filter.h"
union __anonunion_2281 {
   struct sock_filter insns[0U] ;
   struct bpf_insn insnsi[0U] ;
};
#line 526  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/filter.h"
struct bpf_prog {
   u16 pages ;
   u16 jited : 1 ;
   u16 jit_requested : 1 ;
   u16 gpl_compatible : 1 ;
   u16 cb_access : 1 ;
   u16 dst_needed : 1 ;
   u16 blinded : 1 ;
   u16 is_func : 1 ;
   u16 kprobe_override : 1 ;
   u16 has_callchain_buf : 1 ;
   u16 enforce_expected_attach_type : 1 ;
   enum bpf_prog_type type ;
   enum bpf_attach_type expected_attach_type ;
   u32 len ;
   u32 jited_len ;
   u8 tag[8U] ;
   struct bpf_prog_aux *aux ;
   struct sock_fprog_kern *orig_prog ;
   unsigned int (*bpf_func)(void *, struct bpf_insn *) ;
   union __anonunion_2281 __anonCompField_bpf_prog_175 ;
};
#line 554  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/filter.h"
struct sk_filter {
   refcount_t refcnt ;
   struct callback_head rcu ;
   struct bpf_prog *prog ;
};
#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file *, wait_queue_head_t *, struct poll_table_struct *) ;
   __poll_t _key ;
};
#line 70  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/neighbour.h"
struct neigh_table;
#line 70  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/neighbour.h"
struct neigh_parms {
   possible_net_t net ;
   struct net_device *dev ;
   struct list_head list ;
   int (*neigh_setup)(struct neighbour *) ;
   struct neigh_table *tbl ;
   void *sysctl_table ;
   int dead ;
   refcount_t refcnt ;
   struct callback_head callback_head ;
   int reachable_time ;
   int data[13U] ;
   unsigned long data_state[1U] ;
};
#line 112  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/neighbour.h"
struct neigh_statistics {
   unsigned long allocs ;
   unsigned long destroys ;
   unsigned long hash_grows ;
   unsigned long res_failed ;
   unsigned long lookups ;
   unsigned long hits ;
   unsigned long rcv_probes_mcast ;
   unsigned long rcv_probes_ucast ;
   unsigned long periodic_gc_runs ;
   unsigned long forced_gc_runs ;
   unsigned long unres_discards ;
   unsigned long table_fulls ;
};
#line 134 
struct neigh_ops;
#line 134  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/neighbour.h"
struct neighbour {
   struct neighbour *next ;
   struct neigh_table *tbl ;
   struct neigh_parms *parms ;
   unsigned long confirmed ;
   unsigned long updated ;
   rwlock_t lock ;
   refcount_t refcnt ;
   unsigned int arp_queue_len_bytes ;
   struct sk_buff_head arp_queue ;
   struct timer_list timer ;
   unsigned long used ;
   atomic_t probes ;
   __u8 flags ;
   __u8 nud_state ;
   __u8 type ;
   __u8 dead ;
   u8 protocol ;
   seqlock_t ha_lock ;
   unsigned char ha[32U] ;
   struct hh_cache hh ;
   int (*output)(struct neighbour *, struct sk_buff *) ;
   struct neigh_ops *ops ;
   struct list_head gc_list ;
   struct callback_head rcu ;
   struct net_device *dev ;
   u8 primary_key[0U] ;
} __attribute__((__designated_init__));
#line 163  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/neighbour.h"
struct neigh_ops {
   int family ;
   void (*solicit)(struct neighbour *, struct sk_buff *) ;
   void (*error_report)(struct neighbour *, struct sk_buff *) ;
   int (*output)(struct neighbour *, struct sk_buff *) ;
   int (*connected_output)(struct neighbour *, struct sk_buff *) ;
};
#line 171  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/neighbour.h"
struct pneigh_entry {
   struct pneigh_entry *next ;
   possible_net_t net ;
   struct net_device *dev ;
   u8 flags ;
   u8 protocol ;
   u8 key[0U] ;
};
#line 186  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/neighbour.h"
struct neigh_hash_table {
   struct neighbour **hash_buckets ;
   unsigned int hash_shift ;
   __u32 hash_rnd[4U] ;
   struct callback_head rcu ;
};
#line 194  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/neighbour.h"
struct neigh_table {
   int family ;
   unsigned int entry_size ;
   unsigned int key_len ;
   __be16 protocol ;
   __u32 (*hash)(void *, struct net_device *, __u32 *) ;
   bool (*key_eq)(struct neighbour *, void *) ;
   int (*constructor)(struct neighbour *) ;
   int (*pconstructor)(struct pneigh_entry *) ;
   void (*pdestructor)(struct pneigh_entry *) ;
   void (*proxy_redo)(struct sk_buff *) ;
   bool (*allow_add)(struct net_device *, struct netlink_ext_ack *) ;
   char *id ;
   struct neigh_parms parms ;
   struct list_head parms_list ;
   int gc_interval ;
   int gc_thresh1 ;
   int gc_thresh2 ;
   int gc_thresh3 ;
   unsigned long last_flush ;
   struct delayed_work gc_work ;
   struct timer_list proxy_timer ;
   struct sk_buff_head proxy_queue ;
   atomic_t entries ;
   atomic_t gc_entries ;
   struct list_head gc_list ;
   rwlock_t lock ;
   unsigned long last_rand ;
   struct neigh_statistics *stats ;
   struct neigh_hash_table *nht ;
   struct pneigh_entry **phash_buckets ;
};
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/dst.h"
struct lwtunnel_state;
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/dst.h"
struct dst_entry {
   struct net_device *dev ;
   struct dst_ops *ops ;
   unsigned long _metrics ;
   unsigned long expires ;
   struct xfrm_state *xfrm ;
   int (*input)(struct sk_buff *) ;
   int (*output)(struct net *, struct sock *, struct sk_buff *) ;
   unsigned short flags ;
   short obsolete ;
   unsigned short header_len ;
   unsigned short trailer_len ;
   atomic_t __refcnt ;
   int __use ;
   unsigned long lastuse ;
   struct lwtunnel_state *lwtstate ;
   struct callback_head callback_head ;
   short error ;
   short __pad ;
   __u32 tclassid ;
};
#line 82  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/dst.h"
struct dst_metrics {
   u32 metrics[17U] ;
   refcount_t refcnt ;
} __attribute__((__aligned__(4)));
#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/net_tstamp.h"
struct hwtstamp_config {
   int flags ;
   int tx_type ;
   int rx_filter ;
};
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fib_rules.h"
struct fib_rule_hdr {
   __u8 family ;
   __u8 dst_len ;
   __u8 src_len ;
   __u8 tos ;
   __u8 table ;
   __u8 res1 ;
   __u8 res2 ;
   __u8 action ;
   __u32 flags ;
};
#line 38  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fib_rules.h"
struct fib_rule_port_range {
   __u16 start ;
   __u16 end ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/fib_notifier.h"
struct fib_notifier_ops {
   int family ;
   struct list_head list ;
   unsigned int (*fib_seq_read)(struct net *) ;
   int (*fib_dump)(struct net *, struct notifier_block *, struct netlink_ext_ack *) ;
   struct module *owner ;
   struct callback_head rcu ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/fib_rules.h"
struct fib_kuid_range {
   kuid_t start ;
   kuid_t end ;
};
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/fib_rules.h"
struct fib_rule {
   struct list_head list ;
   int iifindex ;
   int oifindex ;
   u32 mark ;
   u32 mark_mask ;
   u32 flags ;
   u32 table ;
   u8 action ;
   u8 l3mdev ;
   u8 proto ;
   u8 ip_proto ;
   u32 target ;
   __be64 tun_id ;
   struct fib_rule *ctarget ;
   struct net *fr_net ;
   refcount_t refcnt ;
   u32 pref ;
   int suppress_ifgroup ;
   int suppress_prefixlen ;
   char iifname[16U] ;
   char oifname[16U] ;
   struct fib_kuid_range uid_range ;
   struct fib_rule_port_range sport_range ;
   struct fib_rule_port_range dport_range ;
   struct callback_head rcu ;
};
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/fib_rules.h"
struct fib_lookup_arg {
   void *lookup_ptr ;
   void *lookup_data ;
   void *result ;
   struct fib_rule *rule ;
   u32 table ;
   int flags ;
};
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/fib_rules.h"
struct fib_rules_ops {
   int family ;
   struct list_head list ;
   int rule_size ;
   int addr_size ;
   int unresolved_rules ;
   int nr_goto_rules ;
   unsigned int fib_rules_seq ;
   int (*action)(struct fib_rule *, struct flowi *, int , struct fib_lookup_arg *) ;
   bool (*suppress)(struct fib_rule *, struct fib_lookup_arg *) ;
   int (*match)(struct fib_rule *, struct flowi *, int ) ;
   int (*configure)(struct fib_rule *, struct sk_buff *, struct fib_rule_hdr *, struct nlattr **, struct netlink_ext_ack *) ;
   int (*delete)(struct fib_rule *) ;
   int (*compare)(struct fib_rule *, struct fib_rule_hdr *, struct nlattr **) ;
   int (*fill)(struct fib_rule *, struct sk_buff *, struct fib_rule_hdr *) ;
   size_t (*nlmsg_payload)(struct fib_rule *) ;
   void (*flush_cache)(struct fib_rules_ops *) ;
   int nlgroup ;
   struct nla_policy *policy ;
   struct list_head rules_list ;
   struct module *owner ;
   struct net *fro_net ;
   struct callback_head rcu ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/l3mdev.h"
struct l3mdev_ops {
   u32 (*l3mdev_fib_table)(struct net_device *) ;
   struct sk_buff *(*l3mdev_l3_rcv)(struct net_device *, struct sk_buff *, u16 ) ;
   struct sk_buff *(*l3mdev_l3_out)(struct net_device *, struct sock *, struct sk_buff *, u16 ) ;
   struct dst_entry *(*l3mdev_link_scope_lookup)(struct net_device *, struct flowi6 *) ;
};
#line 202  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/l3mdev.h"
struct __anonstruct_socket_lock_t_2303 {
   spinlock_t slock ;
   int owned ;
   wait_queue_head_t wq ;
   struct lockdep_map dep_map ;
};
#line 202  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/l3mdev.h"
typedef struct __anonstruct_socket_lock_t_2303 socket_lock_t;
#line 108  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
struct proto;
#line 109  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
typedef __u32 __portpair;
#line 114  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
typedef __u64 __addrpair;
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
struct __anonstruct_2305 {
   __be32 skc_daddr ;
   __be32 skc_rcv_saddr ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
union __anonunion_2304 {
   __addrpair skc_addrpair ;
   struct __anonstruct_2305 __anonCompField___anonunion_2304_177 ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
union __anonunion_2306 {
   unsigned int skc_hash ;
   __u16 skc_u16hashes[2U] ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
struct __anonstruct_2308 {
   __be16 skc_dport ;
   __u16 skc_num ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
union __anonunion_2307 {
   __portpair skc_portpair ;
   struct __anonstruct_2308 __anonCompField___anonunion_2307_180 ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
union __anonunion_2309 {
   struct hlist_node skc_bind_node ;
   struct hlist_node skc_portaddr_node ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
union __anonunion_2310 {
   unsigned long skc_flags ;
   struct sock *skc_listener ;
   struct inet_timewait_death_row *skc_tw_dr ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
union __anonunion_2311 {
   struct hlist_node skc_node ;
   struct hlist_nulls_node skc_nulls_node ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
union __anonunion_2312 {
   int skc_incoming_cpu ;
   u32 skc_rcv_wnd ;
   u32 skc_tw_rcv_nxt ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
union __anonunion_2313 {
   u32 skc_rxhash ;
   u32 skc_window_clamp ;
   u32 skc_tw_snd_nxt ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
struct sock_common {
   union __anonunion_2304 __anonCompField_sock_common_178 ;
   union __anonunion_2306 __anonCompField_sock_common_179 ;
   union __anonunion_2307 __anonCompField_sock_common_181 ;
   unsigned short skc_family ;
   unsigned char skc_state ;
   unsigned char skc_reuse : 4 ;
   unsigned char skc_reuseport : 1 ;
   unsigned char skc_ipv6only : 1 ;
   unsigned char skc_net_refcnt : 1 ;
   int skc_bound_dev_if ;
   union __anonunion_2309 __anonCompField_sock_common_182 ;
   struct proto *skc_prot ;
   possible_net_t skc_net ;
   struct in6_addr skc_v6_daddr ;
   struct in6_addr skc_v6_rcv_saddr ;
   atomic64_t skc_cookie ;
   union __anonunion_2310 __anonCompField_sock_common_183 ;
   int skc_dontcopy_begin[0U] ;
   union __anonunion_2311 __anonCompField_sock_common_184 ;
   unsigned short skc_tx_queue_mapping ;
   unsigned short skc_rx_queue_mapping ;
   union __anonunion_2312 __anonCompField_sock_common_185 ;
   refcount_t skc_refcnt ;
   int skc_dontcopy_end[0U] ;
   union __anonunion_2313 __anonCompField_sock_common_186 ;
};
#line 231 
struct bpf_sk_storage;
#line 323  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
struct __anonstruct_sk_backlog_2314 {
   atomic_t rmem_alloc ;
   int len ;
   struct sk_buff *head ;
   struct sk_buff *tail ;
};
#line 323  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
union __anonunion_2315 {
   struct socket_wq *sk_wq ;
   struct socket_wq *sk_wq_raw ;
};
#line 323  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
union __anonunion_2316 {
   struct sk_buff *sk_send_head ;
   struct rb_root tcp_rtx_queue ;
};
#line 323  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
struct sock {
   struct sock_common __sk_common ;
   socket_lock_t sk_lock ;
   atomic_t sk_drops ;
   int sk_rcvlowat ;
   struct sk_buff_head sk_error_queue ;
   struct sk_buff *sk_rx_skb_cache ;
   struct sk_buff_head sk_receive_queue ;
   struct __anonstruct_sk_backlog_2314 sk_backlog ;
   int sk_forward_alloc ;
   unsigned int sk_ll_usec ;
   unsigned int sk_napi_id ;
   int sk_rcvbuf ;
   struct sk_filter *sk_filter ;
   union __anonunion_2315 __anonCompField_sock_187 ;
   struct xfrm_policy *sk_policy[2U] ;
   struct dst_entry *sk_rx_dst ;
   struct dst_entry *sk_dst_cache ;
   atomic_t sk_omem_alloc ;
   int sk_sndbuf ;
   int sk_wmem_queued ;
   refcount_t sk_wmem_alloc ;
   unsigned long sk_tsq_flags ;
   union __anonunion_2316 __anonCompField_sock_188 ;
   struct sk_buff *sk_tx_skb_cache ;
   struct sk_buff_head sk_write_queue ;
   __s32 sk_peek_off ;
   int sk_write_pending ;
   __u32 sk_dst_pending_confirm ;
   u32 sk_pacing_status ;
   long sk_sndtimeo ;
   struct timer_list sk_timer ;
   __u32 sk_priority ;
   __u32 sk_mark ;
   unsigned long sk_pacing_rate ;
   unsigned long sk_max_pacing_rate ;
   struct page_frag sk_frag ;
   netdev_features_t sk_route_caps ;
   netdev_features_t sk_route_nocaps ;
   netdev_features_t sk_route_forced_caps ;
   int sk_gso_type ;
   unsigned int sk_gso_max_size ;
   gfp_t sk_allocation ;
   __u32 sk_txhash ;
   unsigned int __sk_flags_offset[0U] ;
   unsigned int sk_padding : 1 ;
   unsigned int sk_kern_sock : 1 ;
   unsigned int sk_no_check_tx : 1 ;
   unsigned int sk_no_check_rx : 1 ;
   unsigned int sk_userlocks : 4 ;
   unsigned int sk_protocol : 8 ;
   unsigned int sk_type : 16 ;
   u16 sk_gso_max_segs ;
   u8 sk_pacing_shift ;
   unsigned long sk_lingertime ;
   struct proto *sk_prot_creator ;
   rwlock_t sk_callback_lock ;
   int sk_err ;
   int sk_err_soft ;
   u32 sk_ack_backlog ;
   u32 sk_max_ack_backlog ;
   kuid_t sk_uid ;
   struct pid *sk_peer_pid ;
   struct cred *sk_peer_cred ;
   long sk_rcvtimeo ;
   ktime_t sk_stamp ;
   u16 sk_tsflags ;
   u8 sk_shutdown ;
   u32 sk_tskey ;
   atomic_t sk_zckey ;
   u8 sk_clockid ;
   u8 sk_txtime_deadline_mode : 1 ;
   u8 sk_txtime_report_errors : 1 ;
   u8 sk_txtime_unused : 6 ;
   struct socket *sk_socket ;
   void *sk_user_data ;
   void *sk_security ;
   struct sock_cgroup_data sk_cgrp_data ;
   struct mem_cgroup *sk_memcg ;
   void (*sk_state_change)(struct sock *) ;
   void (*sk_data_ready)(struct sock *) ;
   void (*sk_write_space)(struct sock *) ;
   void (*sk_error_report)(struct sock *) ;
   int (*sk_backlog_rcv)(struct sock *, struct sk_buff *) ;
   struct sk_buff *(*sk_validate_xmit_skb)(struct sock *, struct net_device *, struct sk_buff *) ;
   void (*sk_destruct)(struct sock *) ;
   struct sock_reuseport *sk_reuseport_cb ;
   struct bpf_sk_storage *sk_bpf_storage ;
   struct callback_head sk_rcu ;
};
#line 1048 
struct request_sock_ops;
#line 1049 
struct timewait_sock_ops;
#line 1050 
struct raw_hashinfo;
#line 1051 
struct smc_hashinfo;
#line 1071 
struct udp_table;
#line 1071  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
union __anonunion_h_2351 {
   struct inet_hashinfo *hashinfo ;
   struct udp_table *udp_table ;
   struct raw_hashinfo *raw_hash ;
   struct smc_hashinfo *smc_hash ;
};
#line 1071  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
struct proto {
   void (*close)(struct sock *, long ) ;
   int (*pre_connect)(struct sock *, struct sockaddr *, int ) ;
   int (*connect)(struct sock *, struct sockaddr *, int ) ;
   int (*disconnect)(struct sock *, int ) ;
   struct sock *(*accept)(struct sock *, int , int *, bool ) ;
   int (*ioctl)(struct sock *, int , unsigned long ) ;
   int (*init)(struct sock *) ;
   void (*destroy)(struct sock *) ;
   void (*shutdown)(struct sock *, int ) ;
   int (*setsockopt)(struct sock *, int , int , char *, unsigned int ) ;
   int (*getsockopt)(struct sock *, int , int , char *, int *) ;
   void (*keepalive)(struct sock *, int ) ;
   int (*compat_setsockopt)(struct sock *, int , int , char *, unsigned int ) ;
   int (*compat_getsockopt)(struct sock *, int , int , char *, int *) ;
   int (*compat_ioctl)(struct sock *, unsigned int , unsigned long ) ;
   int (*sendmsg)(struct sock *, struct msghdr *, size_t ) ;
   int (*recvmsg)(struct sock *, struct msghdr *, size_t , int , int , int *) ;
   int (*sendpage)(struct sock *, struct page *, int , size_t , int ) ;
   int (*bind)(struct sock *, struct sockaddr *, int ) ;
   int (*backlog_rcv)(struct sock *, struct sk_buff *) ;
   void (*release_cb)(struct sock *) ;
   int (*hash)(struct sock *) ;
   void (*unhash)(struct sock *) ;
   void (*rehash)(struct sock *) ;
   int (*get_port)(struct sock *, unsigned short ) ;
   unsigned int inuse_idx ;
   bool (*stream_memory_free)(struct sock *, int ) ;
   bool (*stream_memory_read)(struct sock *) ;
   void (*enter_memory_pressure)(struct sock *) ;
   void (*leave_memory_pressure)(struct sock *) ;
   atomic_long_t *memory_allocated ;
   struct percpu_counter *sockets_allocated ;
   unsigned long *memory_pressure ;
   long *sysctl_mem ;
   int *sysctl_wmem ;
   int *sysctl_rmem ;
   u32 sysctl_wmem_offset ;
   u32 sysctl_rmem_offset ;
   int max_header ;
   bool no_autobind ;
   struct kmem_cache *slab ;
   unsigned int obj_size ;
   slab_flags_t slab_flags ;
   unsigned int useroffset ;
   unsigned int usersize ;
   struct percpu_counter *orphan_count ;
   struct request_sock_ops *rsk_prot ;
   struct timewait_sock_ops *twsk_prot ;
   union __anonunion_h_2351 h ;
   struct module *owner ;
   char name[32U] ;
   struct list_head node ;
   int (*diag_destroy)(struct sock *, int ) ;
} __attribute__((__designated_init__));
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/request_sock.h"
struct request_sock_ops {
   int family ;
   unsigned int obj_size ;
   struct kmem_cache *slab ;
   char *slab_name ;
   int (*rtx_syn_ack)(struct sock *, struct request_sock *) ;
   void (*send_ack)(struct sock *, struct sk_buff *, struct request_sock *) ;
   void (*send_reset)(struct sock *, struct sk_buff *) ;
   void (*destructor)(struct request_sock *) ;
   void (*syn_ack_timeout)(struct request_sock *) ;
};
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/request_sock.h"
struct request_sock {
   struct sock_common __req_common ;
   struct request_sock *dl_next ;
   u16 mss ;
   u8 num_retrans ;
   u8 cookie_ts : 1 ;
   u8 num_timeout : 7 ;
   u32 ts_recent ;
   struct timer_list rsk_timer ;
   struct request_sock_ops *rsk_ops ;
   struct sock *sk ;
   u32 *saved_syn ;
   u32 secid ;
   u32 peer_secid ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/timewait_sock.h"
struct timewait_sock_ops {
   struct kmem_cache *twsk_slab ;
   char *twsk_slab_name ;
   unsigned int twsk_obj_size ;
   int (*twsk_unique)(struct sock *, struct sock *, void *) ;
   void (*twsk_destructor)(struct sock *) ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/tcp.h"
struct tcphdr {
   __be16 source ;
   __be16 dest ;
   __be32 seq ;
   __be32 ack_seq ;
   __u16 res1 : 4 ;
   __u16 doff : 4 ;
   __u16 fin : 1 ;
   __u16 syn : 1 ;
   __u16 rst : 1 ;
   __u16 psh : 1 ;
   __u16 ack : 1 ;
   __u16 urg : 1 ;
   __u16 ece : 1 ;
   __u16 cwr : 1 ;
   __be16 window ;
   __sum16 check ;
   __be16 urg_ptr ;
};
#line 116  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ipv6.h"
struct ipv6hdr {
   __u8 priority : 4 ;
   __u8 version : 4 ;
   __u8 flow_lbl[3U] ;
   __be16 payload_len ;
   __u8 nexthdr ;
   __u8 hop_limit ;
   struct in6_addr saddr ;
   struct in6_addr daddr ;
};
#line 63  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ipv6.h"
struct ipv6_stable_secret {
   bool initialized ;
   struct in6_addr secret ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ipv6.h"
struct ipv6_devconf {
   __s32 forwarding ;
   __s32 hop_limit ;
   __s32 mtu6 ;
   __s32 accept_ra ;
   __s32 accept_redirects ;
   __s32 autoconf ;
   __s32 dad_transmits ;
   __s32 rtr_solicits ;
   __s32 rtr_solicit_interval ;
   __s32 rtr_solicit_max_interval ;
   __s32 rtr_solicit_delay ;
   __s32 force_mld_version ;
   __s32 mldv1_unsolicited_report_interval ;
   __s32 mldv2_unsolicited_report_interval ;
   __s32 use_tempaddr ;
   __s32 temp_valid_lft ;
   __s32 temp_prefered_lft ;
   __s32 regen_max_retry ;
   __s32 max_desync_factor ;
   __s32 max_addresses ;
   __s32 accept_ra_defrtr ;
   __s32 accept_ra_min_hop_limit ;
   __s32 accept_ra_pinfo ;
   __s32 ignore_routes_with_linkdown ;
   __s32 accept_ra_rtr_pref ;
   __s32 rtr_probe_interval ;
   __s32 accept_ra_rt_info_min_plen ;
   __s32 accept_ra_rt_info_max_plen ;
   __s32 proxy_ndp ;
   __s32 accept_source_route ;
   __s32 accept_ra_from_local ;
   __s32 optimistic_dad ;
   __s32 use_optimistic ;
   __s32 mc_forwarding ;
   __s32 disable_ipv6 ;
   __s32 drop_unicast_in_l2_multicast ;
   __s32 accept_dad ;
   __s32 force_tllao ;
   __s32 ndisc_notify ;
   __s32 suppress_frag_ndisc ;
   __s32 accept_ra_mtu ;
   __s32 drop_unsolicited_na ;
   struct ipv6_stable_secret stable_secret ;
   __s32 use_oif_addrs_only ;
   __s32 keep_addr_on_down ;
   __s32 seg6_enabled ;
   __s32 seg6_require_hmac ;
   __u32 enhanced_dad ;
   __u32 addr_gen_mode ;
   __s32 disable_policy ;
   __s32 ndisc_tclass ;
   struct ctl_table_header *sysctl_header ;
};
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/udp.h"
struct udphdr {
   __be16 source ;
   __be16 dest ;
   __be16 len ;
   __sum16 check ;
};
#line 99  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/if_inet6.h"
struct ip6_sf_list {
   struct ip6_sf_list *sf_next ;
   struct in6_addr sf_addr ;
   unsigned long sf_count[2U] ;
   unsigned char sf_gsresp ;
   unsigned char sf_oldin ;
   unsigned char sf_crcount ;
};
#line 114  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/if_inet6.h"
struct ifmcaddr6 {
   struct in6_addr mca_addr ;
   struct inet6_dev *idev ;
   struct ifmcaddr6 *next ;
   struct ip6_sf_list *mca_sources ;
   struct ip6_sf_list *mca_tomb ;
   unsigned int mca_sfmode ;
   unsigned char mca_crcount ;
   unsigned long mca_sfcount[2U] ;
   struct timer_list mca_timer ;
   unsigned int mca_flags ;
   int mca_users ;
   refcount_t mca_refcnt ;
   spinlock_t mca_lock ;
   unsigned long mca_cstamp ;
   unsigned long mca_tstamp ;
};
#line 140  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/if_inet6.h"
struct ifacaddr6 {
   struct in6_addr aca_addr ;
   struct fib6_info *aca_rt ;
   struct ifacaddr6 *aca_next ;
   struct hlist_node aca_addr_lst ;
   int aca_users ;
   refcount_t aca_refcnt ;
   unsigned long aca_cstamp ;
   unsigned long aca_tstamp ;
   struct callback_head rcu ;
};
#line 156  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/if_inet6.h"
struct ipv6_devstat {
   struct proc_dir_entry *proc_dir_entry ;
   struct ipstats_mib *ipv6 ;
   struct icmpv6_mib_device *icmpv6dev ;
   struct icmpv6msg_mib_device *icmpv6msgdev ;
};
#line 163  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/if_inet6.h"
struct inet6_dev {
   struct net_device *dev ;
   struct list_head addr_list ;
   struct ifmcaddr6 *mc_list ;
   struct ifmcaddr6 *mc_tomb ;
   spinlock_t mc_lock ;
   unsigned char mc_qrv ;
   unsigned char mc_gq_running ;
   unsigned char mc_ifc_count ;
   unsigned char mc_dad_count ;
   unsigned long mc_v1_seen ;
   unsigned long mc_qi ;
   unsigned long mc_qri ;
   unsigned long mc_maxdelay ;
   struct timer_list mc_gq_timer ;
   struct timer_list mc_ifc_timer ;
   struct timer_list mc_dad_timer ;
   struct ifacaddr6 *ac_list ;
   rwlock_t lock ;
   refcount_t refcnt ;
   __u32 if_flags ;
   int dead ;
   u32 desync_factor ;
   u8 rndid[8U] ;
   struct list_head tempaddr_list ;
   struct in6_addr token ;
   struct neigh_parms *nd_parms ;
   struct ipv6_devconf cnf ;
   struct ipv6_devstat stats ;
   struct timer_list rs_timer ;
   __s32 rs_interval ;
   __u8 rs_probes ;
   unsigned long tstamp ;
   struct callback_head rcu ;
};
#line 261 
struct fib6_nh;
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_arp.h"
struct prefix_info;
#line 104  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ndisc.h"
struct nd_opt_hdr {
   __u8 nd_opt_type ;
   __u8 nd_opt_len ;
} __attribute__((__packed__));
#line 110  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ndisc.h"
struct ndisc_options {
   struct nd_opt_hdr *nd_opt_array[15U] ;
   struct nd_opt_hdr *nd_opts_ri ;
   struct nd_opt_hdr *nd_opts_ri_end ;
   struct nd_opt_hdr *nd_useropts ;
   struct nd_opt_hdr *nd_useropts_end ;
   struct nd_opt_hdr *nd_802154_opt_array[3U] ;
};
#line 201  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ndisc.h"
struct ndisc_ops {
   int (*is_useropt)(u8 ) ;
   int (*parse_options)(struct net_device *, struct nd_opt_hdr *, struct ndisc_options *) ;
   void (*update)(struct net_device *, struct neighbour *, u32 , u8 , struct ndisc_options *) ;
   int (*opt_addr_space)(struct net_device *, u8 , struct neighbour *, u8 *, u8 **) ;
   void (*fill_addr_option)(struct net_device *, struct sk_buff *, u8 , u8 *) ;
   void (*prefix_rcv_add_addr)(struct net *, struct net_device *, struct prefix_info *, struct inet6_dev *, struct in6_addr *, int , u32 , bool , bool , __u32 , u32 , bool ) ;
};
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inetpeer.h"
struct inet_peer_base {
   struct rb_root rb_root ;
   seqlock_t lock ;
   int total ;
};
#line 54  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip_fib.h"
struct fib_info;
#line 58  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip_fib.h"
struct fib_nh_exception {
   struct fib_nh_exception *fnhe_next ;
   int fnhe_genid ;
   __be32 fnhe_daddr ;
   u32 fnhe_pmtu ;
   bool fnhe_mtu_locked ;
   __be32 fnhe_gw ;
   unsigned long fnhe_expires ;
   struct rtable *fnhe_rth_input ;
   struct rtable *fnhe_rth_output ;
   unsigned long fnhe_stamp ;
   struct callback_head rcu ;
};
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip_fib.h"
struct fnhe_hash_bucket {
   struct fib_nh_exception *chain ;
};
#line 80  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip_fib.h"
union __anonunion_nhc_gw_2443 {
   __be32 ipv4 ;
   struct in6_addr ipv6 ;
};
#line 80  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip_fib.h"
struct fib_nh_common {
   struct net_device *nhc_dev ;
   int nhc_oif ;
   unsigned char nhc_scope ;
   u8 nhc_family ;
   u8 nhc_gw_family ;
   unsigned char nhc_flags ;
   struct lwtunnel_state *nhc_lwtstate ;
   union __anonunion_nhc_gw_2443 nhc_gw ;
   int nhc_weight ;
   atomic_t nhc_upper_bound ;
   struct rtable **nhc_pcpu_rth_output ;
   struct rtable *nhc_rth_input ;
   struct fnhe_hash_bucket *nhc_exceptions ;
};
#line 103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip_fib.h"
struct fib_nh {
   struct fib_nh_common nh_common ;
   struct hlist_node nh_hash ;
   struct fib_info *nh_parent ;
   __u32 nh_tclassid ;
   __be32 nh_saddr ;
   int nh_saddr_genid ;
};
#line 113 
struct nexthop;
#line 131  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip_fib.h"
struct fib_info {
   struct hlist_node fib_hash ;
   struct hlist_node fib_lhash ;
   struct list_head nh_list ;
   struct net *fib_net ;
   int fib_treeref ;
   refcount_t fib_clntref ;
   unsigned int fib_flags ;
   unsigned char fib_dead ;
   unsigned char fib_protocol ;
   unsigned char fib_scope ;
   unsigned char fib_type ;
   __be32 fib_prefsrc ;
   u32 fib_tb_id ;
   u32 fib_priority ;
   struct dst_metrics *fib_metrics ;
   int fib_nhs ;
   bool fib_nh_is_v6 ;
   bool nh_updated ;
   struct nexthop *nh ;
   struct callback_head rcu ;
   struct fib_nh fib_nh[0U] ;
};
#line 235  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip_fib.h"
struct fib_table {
   struct hlist_node tb_hlist ;
   u32 tb_id ;
   int tb_num_default ;
   struct callback_head rcu ;
   unsigned long *tb_data ;
   unsigned long __data[0U] ;
};
#line 49  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/route.h"
struct uncached_list;
#line 49  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/route.h"
union __anonunion_2452 {
   __be32 rt_gw4 ;
   struct in6_addr rt_gw6 ;
};
#line 49  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/route.h"
struct rtable {
   struct dst_entry dst ;
   int rt_genid ;
   unsigned int rt_flags ;
   __u16 rt_type ;
   __u8 rt_is_input ;
   __u8 rt_uses_gateway ;
   int rt_iif ;
   u8 rt_gw_family ;
   union __anonunion_2452 __anonCompField_rtable_196 ;
   u32 rt_mtu_locked : 1 ;
   u32 rt_pmtu : 31 ;
   struct list_head rt_uncached ;
   struct uncached_list *rt_uncached_list ;
};
#line 121  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip.h"
union __anonunion_2453 {
   void (*destructor)(struct sock *) ;
   struct sock *saved_sk ;
};
#line 121  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip.h"
struct ip_ra_chain {
   struct ip_ra_chain *next ;
   struct sock *sk ;
   union __anonunion_2453 __anonCompField_ip_ra_chain_197 ;
   struct callback_head rcu ;
};
#line 101  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip6_checksum.h"
struct macvlan_port;
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_macvlan.h"
struct macvlan_dev {
   struct net_device *dev ;
   struct list_head list ;
   struct hlist_node hlist ;
   struct macvlan_port *port ;
   struct net_device *lowerdev ;
   void *accel_priv ;
   struct vlan_pcpu_stats *pcpu_stats ;
   unsigned long mc_filter[4U] ;
   netdev_features_t set_features ;
   enum macvlan_mode mode ;
   u16 flags ;
   unsigned int macaddr_count ;
   struct netpoll *netpoll ;
};
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/tracepoint.h"
struct trace_eval_map {
   char *system ;
   char *eval_string ;
   unsigned long eval_value ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/trace/events/xdp.h"
union __anonunion___u_2464 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/trace/events/xdp.h"
union __anonunion___u_2466 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/generic.h"
struct __anonstruct_s_2513 {
   unsigned int len ;
   struct callback_head rcu ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/generic.h"
union __anonunion_2512 {
   struct __anonstruct_s_2513 s ;
   void *ptr[0U] ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/generic.h"
struct net_generic {
   union __anonunion_2512 __anonCompField_net_generic_199 ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/lwtunnel.h"
struct lwtunnel_state {
   __u16 type ;
   __u16 flags ;
   __u16 headroom ;
   atomic_t refcnt ;
   int (*orig_output)(struct net *, struct sock *, struct sk_buff *) ;
   int (*orig_input)(struct sk_buff *) ;
   struct callback_head rcu ;
   __u8 data[0U] ;
};
#line 70  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip6_fib.h"
struct fib6_node {
   struct fib6_node *parent ;
   struct fib6_node *left ;
   struct fib6_node *right ;
   struct fib6_node *subtree ;
   struct fib6_info *leaf ;
   __u16 fn_bit ;
   __u16 fn_flags ;
   int fn_sernum ;
   struct fib6_info *rr_ptr ;
   struct callback_head rcu ;
};
#line 127  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip6_fib.h"
struct rt6key {
   struct in6_addr addr ;
   int plen ;
};
#line 134  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip6_fib.h"
struct rt6_exception_bucket {
   struct hlist_head chain ;
   int depth ;
};
#line 150  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip6_fib.h"
struct fib6_nh {
   struct fib_nh_common nh_common ;
   unsigned long last_probe ;
   struct rt6_info **rt6i_pcpu ;
   struct rt6_exception_bucket *rt6i_exception_bucket ;
};
#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip6_fib.h"
union __anonunion_2516 {
   struct list_head fib6_siblings ;
   struct list_head nh_list ;
};
#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip6_fib.h"
struct fib6_info {
   struct fib6_table *fib6_table ;
   struct fib6_info *fib6_next ;
   struct fib6_node *fib6_node ;
   union __anonunion_2516 __anonCompField_fib6_info_200 ;
   unsigned int fib6_nsiblings ;
   refcount_t fib6_ref ;
   unsigned long expires ;
   struct dst_metrics *fib6_metrics ;
   struct rt6key fib6_dst ;
   u32 fib6_flags ;
   struct rt6key fib6_src ;
   struct rt6key fib6_prefsrc ;
   u32 fib6_metric ;
   u8 fib6_protocol ;
   u8 fib6_type ;
   u8 should_flush : 1 ;
   u8 dst_nocount : 1 ;
   u8 dst_nopolicy : 1 ;
   u8 dst_host : 1 ;
   u8 fib6_destroying : 1 ;
   u8 unused : 3 ;
   struct callback_head rcu ;
   struct nexthop *nh ;
   struct fib6_nh fib6_nh[0U] ;
};
#line 202  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip6_fib.h"
struct rt6_info {
   struct dst_entry dst ;
   struct fib6_info *from ;
   struct rt6key rt6i_dst ;
   struct rt6key rt6i_src ;
   struct in6_addr rt6i_gateway ;
   struct inet6_dev *rt6i_idev ;
   u32 rt6i_flags ;
   struct list_head rt6i_uncached ;
   struct uncached_list *rt6i_uncached_list ;
   unsigned short rt6i_nfheader_len ;
};
#line 354  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip6_fib.h"
struct rt6_statistics {
   __u32 fib_nodes ;
   __u32 fib_route_nodes ;
   __u32 fib_rt_entries ;
   __u32 fib_rt_cache ;
   __u32 fib_discarded_routes ;
   atomic_t fib_rt_alloc ;
   atomic_t fib_rt_uncache ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip6_fib.h"
struct fib6_table {
   struct hlist_node tb6_hlist ;
   u32 tb6_id ;
   spinlock_t tb6_lock ;
   struct fib6_node tb6_root ;
   struct inet_peer_base tb6_peers ;
   unsigned int flags ;
   unsigned int fib_seq ;
};
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/addrconf.h"
struct prefix_info {
   __u8 type ;
   __u8 length ;
   __u8 prefix_len ;
   __u8 reserved : 6 ;
   __u8 autoconf : 1 ;
   __u8 onlink : 1 ;
   __be32 valid ;
   __be32 prefered ;
   __be32 reserved2 ;
   struct in6_addr prefix ;
};
#line 49  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/nexthop.h"
union __anonunion_2530 {
   struct fib_nh_common fib_nhc ;
   struct fib_nh fib_nh ;
   struct fib6_nh fib6_nh ;
};
#line 49  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/nexthop.h"
struct nh_info {
   struct hlist_node dev_hash ;
   struct nexthop *nh_parent ;
   u8 family ;
   bool reject_nh ;
   union __anonunion_2530 __anonCompField_nh_info_201 ;
};
#line 63  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/nexthop.h"
struct nh_grp_entry {
   struct nexthop *nh ;
   u8 weight ;
   atomic_t upper_bound ;
   struct list_head nh_list ;
   struct nexthop *nh_parent ;
};
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/nexthop.h"
struct nh_group {
   u16 num_nh ;
   bool mpath ;
   bool has_v4 ;
   struct nh_grp_entry nh_entries[0U] ;
};
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/nexthop.h"
union __anonunion_2531 {
   struct nh_info *nh_info ;
   struct nh_group *nh_grp ;
};
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/nexthop.h"
struct nexthop {
   struct rb_node rb_node ;
   struct list_head fi_list ;
   struct list_head f6i_list ;
   struct list_head grp_list ;
   struct net *net ;
   u32 id ;
   u8 protocol ;
   u8 nh_flags ;
   bool is_group ;
   refcount_t refcnt ;
   struct callback_head rcu ;
   union __anonunion_2531 __anonCompField_nexthop_202 ;
};
#line 57  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/udp.h"
struct udp_hslot {
   struct hlist_head head ;
   int count ;
   spinlock_t lock ;
} __attribute__((__aligned__(16)));
#line 71  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/udp.h"
struct udp_table {
   struct udp_hslot *hash ;
   struct udp_hslot *hash2 ;
   unsigned int mask ;
   unsigned int log ;
};
#line 114  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/udp_tunnel.h"
struct udp_tunnel_info {
   unsigned short type ;
   sa_family_t sa_family ;
   __be16 port ;
};
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/pkt_sched.h"
struct qdisc_walker {
   int stop ;
   int skip ;
   int count ;
   int (*fn)(struct Qdisc *, unsigned long , struct qdisc_walker *) ;
};
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/act_api.h"
struct tcf_idrinfo {
   struct mutex lock ;
   struct idr action_idr ;
   struct net *net ;
};
#line 20 
struct tc_action_ops;
#line 23 
struct tc_cookie;
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/act_api.h"
struct tc_action {
   struct tc_action_ops *ops ;
   __u32 type ;
   struct tcf_idrinfo *idrinfo ;
   u32 tcfa_index ;
   refcount_t tcfa_refcnt ;
   atomic_t tcfa_bindcnt ;
   int tcfa_action ;
   struct tcf_t tcfa_tm ;
   struct gnet_stats_basic_packed tcfa_bstats ;
   struct gnet_stats_basic_packed tcfa_bstats_hw ;
   struct gnet_stats_queue tcfa_qstats ;
   struct net_rate_estimator *tcfa_rate_est ;
   spinlock_t tcfa_lock ;
   struct gnet_stats_basic_cpu *cpu_bstats ;
   struct gnet_stats_basic_cpu *cpu_bstats_hw ;
   struct gnet_stats_queue *cpu_qstats ;
   struct tc_cookie *act_cookie ;
   struct tcf_chain *goto_chain ;
   u32 tcfa_flags ;
};
#line 75  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/act_api.h"
typedef void (*tc_action_priv_destructor)(void *);
#line 83  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/act_api.h"
struct tc_action_ops {
   struct list_head head ;
   char kind[16U] ;
   enum tca_id id ;
   size_t size ;
   struct module *owner ;
   int (*act)(struct sk_buff *, struct tc_action *, struct tcf_result *) ;
   int (*dump)(struct sk_buff *, struct tc_action *, int , int ) ;
   void (*cleanup)(struct tc_action *) ;
   int (*lookup)(struct net *, struct tc_action **, u32 ) ;
   int (*init)(struct net *, struct nlattr *, struct nlattr *, struct tc_action **, int , int , bool , struct tcf_proto *, u32 , struct netlink_ext_ack *) ;
   int (*walk)(struct net *, struct sk_buff *, struct netlink_callback *, int , struct tc_action_ops *, struct netlink_ext_ack *) ;
   void (*stats_update)(struct tc_action *, u64 , u32 , u64 , bool ) ;
   size_t (*get_fill_size)(struct tc_action *) ;
   struct net_device *(*get_dev)(struct tc_action *, tc_action_priv_destructor *) ;
   struct psample_group *(*get_psample_group)(struct tc_action *, tc_action_priv_destructor *) ;
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/pkt_cls.h"
struct tcf_walker {
   int stop ;
   int skip ;
   int count ;
   bool nonempty ;
   unsigned long cookie ;
   int (*fn)(struct tcf_proto *, void *, struct tcf_walker *) ;
};
#line 184  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/pkt_cls.h"
struct tcf_exts {
   __u32 type ;
   int nr_actions ;
   struct tc_action **actions ;
   struct net *net ;
   int action ;
   int police ;
};
#line 529  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/pkt_cls.h"
struct tc_cls_u32_knode {
   struct tcf_exts *exts ;
   struct tcf_result *res ;
   struct tc_u32_sel *sel ;
   u32 handle ;
   u32 val ;
   u32 mask ;
   u32 link_handle ;
   u8 fshift ;
};
#line 540  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/pkt_cls.h"
struct tc_cls_u32_hnode {
   u32 handle ;
   u32 prio ;
   unsigned int divisor ;
};
#line 545 
enum tc_clsu32_command {
    TC_CLSU32_NEW_KNODE = 0,
    TC_CLSU32_REPLACE_KNODE = 1,
    TC_CLSU32_DELETE_KNODE = 2,
    TC_CLSU32_NEW_HNODE = 3,
    TC_CLSU32_REPLACE_HNODE = 4,
    TC_CLSU32_DELETE_HNODE = 5
};
#line 555  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/pkt_cls.h"
union __anonunion_2562 {
   struct tc_cls_u32_knode knode ;
   struct tc_cls_u32_hnode hnode ;
};
#line 555  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/pkt_cls.h"
struct tc_cls_u32_offload {
   struct flow_cls_common_offload common ;
   enum tc_clsu32_command command ;
   union __anonunion_2562 __anonCompField_tc_cls_u32_offload_205 ;
};
#line 678  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/pkt_cls.h"
struct tc_cookie {
   u8 *data ;
   u32 len ;
   struct callback_head rcu ;
};
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/tc_act/tc_gact.h"
struct tcf_gact {
   struct tc_action common ;
   u16 tcfg_ptype ;
   u16 tcfg_pval ;
   int tcfg_paction ;
   atomic_t packets ;
};
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/tc_act/tc_mirred.h"
struct tcf_mirred {
   struct tc_action common ;
   int tcfm_eaction ;
   bool tcfm_mac_header_xmit ;
   struct net_device *tcfm_dev ;
   struct list_head tcfm_list ;
};
#line 105  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if_xdp.h"
struct xsk_queue;
#line 26  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
struct xdp_umem_page {
   void *addr ;
   dma_addr_t dma ;
};
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
struct xdp_umem_fq_reuse {
   u32 nentries ;
   u32 length ;
   u64 handles[] ;
};
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
struct xdp_umem {
   struct xsk_queue *fq ;
   struct xsk_queue *cq ;
   struct xdp_umem_page *pages ;
   u64 chunk_mask ;
   u64 size ;
   u32 headroom ;
   u32 chunk_size_nohr ;
   struct user_struct *user ;
   unsigned long address ;
   refcount_t users ;
   struct work_struct work ;
   struct page **pgs ;
   u32 npgs ;
   u16 queue_id ;
   u8 need_wakeup ;
   u8 flags ;
   int id ;
   struct net_device *dev ;
   struct xdp_umem_fq_reuse *fq_reuse ;
   bool zc ;
   spinlock_t xsk_list_lock ;
   struct list_head xsk_list ;
};
#line 280  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/pfkeyv2.h"
struct fs_pin;
#line 26  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pid_namespace.h"
struct pid_namespace {
   struct kref kref ;
   struct idr idr ;
   struct callback_head rcu ;
   unsigned int pid_allocated ;
   struct task_struct *child_reaper ;
   struct kmem_cache *pid_cachep ;
   unsigned int level ;
   struct pid_namespace *parent ;
   struct vfsmount *proc_mnt ;
   struct dentry *proc_self ;
   struct dentry *proc_thread_self ;
   struct fs_pin *bacct ;
   struct user_namespace *user_ns ;
   struct ucounts *ucounts ;
   struct work_struct proc_work ;
   kgid_t pid_gid ;
   int hide_pid ;
   int reboot ;
   struct ns_common ns ;
} __attribute__((__designated_init__));
#line 119  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
struct xfrm_state_walk {
   struct list_head all ;
   u8 state ;
   u8 dying ;
   u8 proto ;
   u32 seq ;
   struct xfrm_address_filter *filter ;
};
#line 128  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
struct xfrm_state_offload {
   struct net_device *dev ;
   unsigned long offload_handle ;
   unsigned int num_exthdrs ;
   u8 flags ;
};
#line 135  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
struct xfrm_mode {
   u8 encap ;
   u8 family ;
   u8 flags ;
};
#line 147  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
union __anonunion_2584 {
   struct hlist_node gclist ;
   struct hlist_node bydst ;
};
#line 147  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
struct __anonstruct_props_2585 {
   u32 reqid ;
   u8 mode ;
   u8 replay_window ;
   u8 aalgo ;
   u8 ealgo ;
   u8 calgo ;
   u8 flags ;
   u16 family ;
   xfrm_address_t saddr ;
   int header_len ;
   int trailer_len ;
   u32 extra_flags ;
   struct xfrm_mark smark ;
};
#line 147 
struct xfrm_replay;
#line 147 
struct xfrm_type;
#line 147 
struct xfrm_type_offload;
#line 147  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
struct xfrm_state {
   possible_net_t xs_net ;
   union __anonunion_2584 __anonCompField_xfrm_state_214 ;
   struct hlist_node bysrc ;
   struct hlist_node byspi ;
   refcount_t refcnt ;
   spinlock_t lock ;
   struct xfrm_id id ;
   struct xfrm_selector sel ;
   struct xfrm_mark mark ;
   u32 if_id ;
   u32 tfcpad ;
   u32 genid ;
   struct xfrm_state_walk km ;
   struct __anonstruct_props_2585 props ;
   struct xfrm_lifetime_cfg lft ;
   struct xfrm_algo_auth *aalg ;
   struct xfrm_algo *ealg ;
   struct xfrm_algo *calg ;
   struct xfrm_algo_aead *aead ;
   char *geniv ;
   struct xfrm_encap_tmpl *encap ;
   xfrm_address_t *coaddr ;
   struct xfrm_state *tunnel ;
   atomic_t tunnel_users ;
   struct xfrm_replay_state replay ;
   struct xfrm_replay_state_esn *replay_esn ;
   struct xfrm_replay_state preplay ;
   struct xfrm_replay_state_esn *preplay_esn ;
   struct xfrm_replay *repl ;
   u32 xflags ;
   u32 replay_maxage ;
   u32 replay_maxdiff ;
   struct timer_list rtimer ;
   struct xfrm_stats stats ;
   struct xfrm_lifetime_cur curlft ;
   struct hrtimer mtimer ;
   struct xfrm_state_offload xso ;
   long saved_tmo ;
   time64_t lastused ;
   struct page_frag xfrag ;
   struct xfrm_type *type ;
   struct xfrm_mode inner_mode ;
   struct xfrm_mode inner_mode_iaf ;
   struct xfrm_mode outer_mode ;
   struct xfrm_type_offload *type_offload ;
   struct xfrm_sec_ctx *security ;
   void *data ;
};
#line 296  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
struct xfrm_replay {
   void (*advance)(struct xfrm_state *, __be32 ) ;
   int (*check)(struct xfrm_state *, struct sk_buff *, __be32 ) ;
   int (*recheck)(struct xfrm_state *, struct sk_buff *, __be32 ) ;
   void (*notify)(struct xfrm_state *, int ) ;
   int (*overflow)(struct xfrm_state *, struct sk_buff *) ;
};
#line 341 
struct xfrm_tmpl;
#line 390  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
struct xfrm_type {
   char *description ;
   struct module *owner ;
   u8 proto ;
   u8 flags ;
   int (*init_state)(struct xfrm_state *) ;
   void (*destructor)(struct xfrm_state *) ;
   int (*input)(struct xfrm_state *, struct sk_buff *) ;
   int (*output)(struct xfrm_state *, struct sk_buff *) ;
   int (*reject)(struct xfrm_state *, struct sk_buff *, struct flowi *) ;
   int (*hdr_offset)(struct xfrm_state *, struct sk_buff *, u8 **) ;
};
#line 412  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
struct xfrm_type_offload {
   char *description ;
   struct module *owner ;
   u8 proto ;
   void (*encap)(struct xfrm_state *, struct sk_buff *) ;
   int (*input_tail)(struct xfrm_state *, struct sk_buff *) ;
   int (*xmit)(struct xfrm_state *, struct sk_buff *, netdev_features_t ) ;
};
#line 445  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
struct xfrm_tmpl {
   struct xfrm_id id ;
   xfrm_address_t saddr ;
   unsigned short encap_family ;
   u32 reqid ;
   u8 mode ;
   u8 share ;
   u8 optional ;
   u8 allalgs ;
   u32 aalgos ;
   u32 ealgos ;
   u32 calgos ;
};
#line 482  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
struct xfrm_policy_walk_entry {
   struct list_head all ;
   u8 dead ;
};
#line 493  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
struct xfrm_policy_queue {
   struct sk_buff_head hold_queue ;
   struct timer_list hold_timer ;
   unsigned long timeout ;
};
#line 499  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
struct xfrm_policy {
   possible_net_t xp_net ;
   struct hlist_node bydst ;
   struct hlist_node byidx ;
   rwlock_t lock ;
   refcount_t refcnt ;
   u32 pos ;
   struct timer_list timer ;
   atomic_t genid ;
   u32 priority ;
   u32 index ;
   u32 if_id ;
   struct xfrm_mark mark ;
   struct xfrm_selector selector ;
   struct xfrm_lifetime_cfg lft ;
   struct xfrm_lifetime_cur curlft ;
   struct xfrm_policy_walk_entry walk ;
   struct xfrm_policy_queue polq ;
   bool bydst_reinsert ;
   u8 type ;
   u8 action ;
   u8 flags ;
   u8 xfrm_nr ;
   u16 family ;
   struct xfrm_sec_ctx *security ;
   struct xfrm_tmpl xfrm_vec[6U] ;
   struct hlist_node bydst_inexact_list ;
   struct callback_head rcu ;
};
#line 999  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
struct __anonstruct_seq_2593 {
   __u32 low ;
   __u32 hi ;
};
#line 999  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
struct xfrm_offload {
   struct __anonstruct_seq_2593 seq ;
   __u32 flags ;
   __u32 status ;
   __u8 proto ;
};
#line 1029  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
struct sec_path {
   int len ;
   int olen ;
   struct xfrm_state *xvec[6U] ;
   struct xfrm_offload ovec[1U] ;
};
#line 159  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/mii.h"
struct mii_ioctl_data {
   __u16 phy_id ;
   __u16 reg_num ;
   __u16 val_in ;
   __u16 val_out ;
};
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timecounter.h"
struct cyclecounter {
   u64 (*read)(struct cyclecounter *) ;
   u64 mask ;
   u32 mult ;
   u32 shift ;
};
#line 55  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timecounter.h"
struct timecounter {
   struct cyclecounter *cc ;
   u64 cycle_last ;
   u64 nsec ;
   u64 mask ;
   u64 frac ;
};
#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ptp_clock.h"
struct ptp_clock_time {
   __s64 sec ;
   __u32 nsec ;
   __u32 reserved ;
};
#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ptp_clock.h"
struct ptp_extts_request {
   unsigned int index ;
   unsigned int flags ;
   unsigned int rsv[2U] ;
};
#line 101  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ptp_clock.h"
struct ptp_perout_request {
   struct ptp_clock_time start ;
   struct ptp_clock_time period ;
   unsigned int index ;
   unsigned int flags ;
   unsigned int rsv[4U] ;
};
#line 138 
enum ptp_pin_function {
    PTP_PF_NONE = 0,
    PTP_PF_EXTTS = 1,
    PTP_PF_PEROUT = 2,
    PTP_PF_PHYSYNC = 3
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ptp_clock.h"
struct ptp_pin_desc {
   char name[64U] ;
   unsigned int index ;
   unsigned int func ;
   unsigned int chan ;
   unsigned int rsv[5U] ;
};
#line 205 
enum ldv_22345 {
    PTP_CLK_REQ_EXTTS = 0,
    PTP_CLK_REQ_PEROUT = 1,
    PTP_CLK_REQ_PPS = 2
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ptp_clock_kernel.h"
union __anonunion_2599 {
   struct ptp_extts_request extts ;
   struct ptp_perout_request perout ;
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ptp_clock_kernel.h"
struct ptp_clock_request {
   enum ldv_22345 type ;
   union __anonunion_2599 __anonCompField_ptp_clock_request_215 ;
};
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ptp_clock_kernel.h"
struct ptp_system_timestamp {
   struct timespec64 pre_ts ;
   struct timespec64 post_ts ;
};
#line 119  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ptp_clock_kernel.h"
struct ptp_clock_info {
   struct module *owner ;
   char name[16U] ;
   s32 max_adj ;
   int n_alarm ;
   int n_ext_ts ;
   int n_per_out ;
   int n_pins ;
   int pps ;
   struct ptp_pin_desc *pin_config ;
   int (*adjfine)(struct ptp_clock_info *, long ) ;
   int (*adjfreq)(struct ptp_clock_info *, s32 ) ;
   int (*adjtime)(struct ptp_clock_info *, s64 ) ;
   int (*gettime64)(struct ptp_clock_info *, struct timespec64 *) ;
   int (*gettimex64)(struct ptp_clock_info *, struct timespec64 *, struct ptp_system_timestamp *) ;
   int (*getcrosststamp)(struct ptp_clock_info *, struct system_device_crosststamp *) ;
   int (*settime64)(struct ptp_clock_info *, struct timespec64 *) ;
   int (*enable)(struct ptp_clock_info *, struct ptp_clock_request *, int ) ;
   int (*verify)(struct ptp_clock_info *, unsigned int , enum ptp_pin_function , unsigned int ) ;
   long (*do_aux_work)(struct ptp_clock_info *) ;
};
#line 144 
struct ptp_clock;
#line 235  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_nvm_version {
   u32 etk_id ;
   u8 nvm_major ;
   u16 nvm_minor ;
   u8 nvm_id ;
   bool oem_valid ;
   u8 oem_major ;
   u8 oem_minor ;
   u16 oem_release ;
   bool or_valid ;
   u8 or_major ;
   u16 or_build ;
   u8 or_patch ;
};
#line 2840  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_read_2602 {
   __le64 buffer_addr ;
   __le32 cmd_type_len ;
   __le32 olinfo_status ;
};
#line 2840  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_wb_2603 {
   __le64 rsvd ;
   __le32 nxtseq_seed ;
   __le32 status ;
};
#line 2840  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
union ixgbe_adv_tx_desc {
   struct __anonstruct_read_2602 read ;
   struct __anonstruct_wb_2603 wb ;
};
#line 2854  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_read_2604 {
   __le64 pkt_addr ;
   __le64 hdr_addr ;
};
#line 2854  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_hs_rss_2608 {
   __le16 pkt_info ;
   __le16 hdr_info ;
};
#line 2854  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
union __anonunion_lo_dword_2607 {
   __le32 data ;
   struct __anonstruct_hs_rss_2608 hs_rss ;
};
#line 2854  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_csum_ip_2610 {
   __le16 ip_id ;
   __le16 csum ;
};
#line 2854  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
union __anonunion_hi_dword_2609 {
   __le32 rss ;
   struct __anonstruct_csum_ip_2610 csum_ip ;
};
#line 2854  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_lower_2606 {
   union __anonunion_lo_dword_2607 lo_dword ;
   union __anonunion_hi_dword_2609 hi_dword ;
};
#line 2854  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_upper_2611 {
   __le32 status_error ;
   __le16 length ;
   __le16 vlan ;
};
#line 2854  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_wb_2605 {
   struct __anonstruct_lower_2606 lower ;
   struct __anonstruct_upper_2611 upper ;
};
#line 2854  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
union ixgbe_adv_rx_desc {
   struct __anonstruct_read_2604 read ;
   struct __anonstruct_wb_2605 wb ;
};
#line 3052  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_formatted_2612 {
   u8 vm_pool ;
   u8 flow_type ;
   __be16 vlan_id ;
   __be32 dst_ip[4U] ;
   __be32 src_ip[4U] ;
   __be16 src_port ;
   __be16 dst_port ;
   __be16 flex_bytes ;
   __be16 bkt_hash ;
};
#line 3052  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
union ixgbe_atr_input {
   struct __anonstruct_formatted_2612 formatted ;
   __be32 dword_stream[11U] ;
};
#line 3081  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_formatted_2613 {
   u8 vm_pool ;
   u8 flow_type ;
   __be16 vlan_id ;
};
#line 3081  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_port_2614 {
   __be16 src ;
   __be16 dst ;
};
#line 3081  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
union ixgbe_atr_hash_dword {
   struct __anonstruct_formatted_2613 formatted ;
   __be32 ip ;
   struct __anonstruct_port_2614 port ;
   __be16 flex_bytes ;
   __be32 dword ;
};
#line 3305  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hw_stats {
   u64 crcerrs ;
   u64 illerrc ;
   u64 errbc ;
   u64 mspdc ;
   u64 mpctotal ;
   u64 mpc[8U] ;
   u64 mlfc ;
   u64 mrfc ;
   u64 rlec ;
   u64 lxontxc ;
   u64 lxonrxc ;
   u64 lxofftxc ;
   u64 lxoffrxc ;
   u64 pxontxc[8U] ;
   u64 pxonrxc[8U] ;
   u64 pxofftxc[8U] ;
   u64 pxoffrxc[8U] ;
   u64 prc64 ;
   u64 prc127 ;
   u64 prc255 ;
   u64 prc511 ;
   u64 prc1023 ;
   u64 prc1522 ;
   u64 gprc ;
   u64 bprc ;
   u64 mprc ;
   u64 gptc ;
   u64 gorc ;
   u64 gotc ;
   u64 rnbc[8U] ;
   u64 ruc ;
   u64 rfc ;
   u64 roc ;
   u64 rjc ;
   u64 mngprc ;
   u64 mngpdc ;
   u64 mngptc ;
   u64 tor ;
   u64 tpr ;
   u64 tpt ;
   u64 ptc64 ;
   u64 ptc127 ;
   u64 ptc255 ;
   u64 ptc511 ;
   u64 ptc1023 ;
   u64 ptc1522 ;
   u64 mptc ;
   u64 bptc ;
   u64 xec ;
   u64 rqsmr[16U] ;
   u64 tqsmr[8U] ;
   u64 qprc[16U] ;
   u64 qptc[16U] ;
   u64 qbrc[16U] ;
   u64 qbtc[16U] ;
   u64 qprdc[16U] ;
   u64 pxon2offc[8U] ;
   u64 fdirustat_add ;
   u64 fdirustat_remove ;
   u64 fdirfstat_fadd ;
   u64 fdirfstat_fremove ;
   u64 fdirmatch ;
   u64 fdirmiss ;
   u64 fccrc ;
   u64 fcoerpdc ;
   u64 fcoeprc ;
   u64 fcoeptc ;
   u64 fcoedwrc ;
   u64 fcoedwtc ;
   u64 fcoe_noddp ;
   u64 fcoe_noddp_ext_buff ;
   u64 b2ospc ;
   u64 b2ogprc ;
   u64 o2bgptc ;
   u64 o2bspc ;
};
#line 3653  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_info {
   enum ixgbe_mac_type mac ;
   s32 (*get_invariants)(struct ixgbe_hw *) ;
   struct ixgbe_mac_operations *mac_ops ;
   struct ixgbe_eeprom_operations *eeprom_ops ;
   struct ixgbe_phy_operations *phy_ops ;
   struct ixgbe_mbx_operations *mbx_ops ;
   struct ixgbe_link_operations *link_ops ;
   u32 *mvals ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
union __anonunion___u_2616 {
   u8 *__val ;
   char __c[1U] ;
};
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
enum strict_prio_type {
    prio_none = 0,
    prio_group = 1,
    prio_link = 2
};
#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
struct dcb_support {
   u32 capabilities ;
   u8 traffic_classes ;
   u8 pfc_traffic_classes ;
};
#line 74  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
struct tc_bw_alloc {
   u8 bwg_id ;
   u8 bwg_percent ;
   u8 link_percent ;
   u8 up_to_tc_bitmap ;
   u16 data_credits_refill ;
   u16 data_credits_max ;
   enum strict_prio_type prio_type ;
};
#line 84 
enum dcb_pfc_type {
    pfc_disabled = 0,
    pfc_enabled_full = 1,
    pfc_enabled_tx = 2,
    pfc_enabled_rx = 3
};
#line 93  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
struct tc_configuration {
   struct tc_bw_alloc path[2U] ;
   enum dcb_pfc_type dcb_pfc ;
   u16 desc_credits_max ;
   u8 tc ;
};
#line 101  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
struct dcb_num_tcs {
   u8 pg_tcs ;
   u8 pfc_tcs ;
};
#line 106  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
struct ixgbe_dcb_config {
   struct dcb_support support ;
   struct dcb_num_tcs num_tcs ;
   struct tc_configuration tc_config[8U] ;
   u8 bw_percentage[2U][8U] ;
   bool pfc_mode_enable ;
   u32 dcb_cfg_version ;
   u32 link_speed ;
};
#line 35  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.h"
struct ixgbe_fcoe_ddp {
   int len ;
   u32 err ;
   unsigned int sgc ;
   struct scatterlist *sgl ;
   dma_addr_t udp ;
   u64 *udl ;
   struct dma_pool *pool ;
};
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.h"
struct ixgbe_fcoe_ddp_pool {
   struct dma_pool *pool ;
   u64 noddp ;
   u64 noddp_ext_buff ;
};
#line 52  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.h"
struct ixgbe_fcoe {
   struct ixgbe_fcoe_ddp_pool *ddp_pool ;
   atomic_t refcnt ;
   spinlock_t lock ;
   struct ixgbe_fcoe_ddp ddp[2048U] ;
   void *extra_ddp_buffer ;
   dma_addr_t extra_ddp_buffer_dma ;
   unsigned long mode ;
   u8 up ;
};
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.h"
struct rx_sa {
   struct hlist_node hlist ;
   struct xfrm_state *xs ;
   __be32 ipaddr[4U] ;
   u32 key[4U] ;
   u32 salt ;
   u32 mode ;
   u8 iptbl_ind ;
   bool used ;
   bool decrypt ;
   u32 vf ;
};
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.h"
struct rx_ip_sa {
   __be32 ipaddr[4U] ;
   u32 ref_cnt ;
   bool used ;
};
#line 50  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.h"
struct tx_sa {
   struct xfrm_state *xs ;
   u32 key[4U] ;
   u32 salt ;
   u32 mode ;
   bool encrypt ;
   bool used ;
   u32 vf ;
};
#line 60  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.h"
struct ixgbe_ipsec_tx_data {
   u32 flags ;
   u16 trailer_len ;
   u16 sa_idx ;
};
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.h"
struct ixgbe_ipsec {
   u16 num_rx_sa ;
   u16 num_tx_sa ;
   struct rx_ip_sa *ip_tbl ;
   struct rx_sa *rx_tbl ;
   struct tx_sa *tx_tbl ;
   struct hlist_head rx_sa_list[1024U] ;
};
#line 170  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct vf_data_storage {
   struct pci_dev *vfdev ;
   unsigned char vf_mac_addresses[6U] ;
   u16 vf_mc_hashes[30U] ;
   u16 num_vf_mc_hashes ;
   bool clear_to_send ;
   bool pf_set_mac ;
   u16 pf_vlan ;
   u16 pf_qos ;
   u16 tx_rate ;
   u8 spoofchk_enabled ;
   bool rss_query_enabled ;
   u8 trusted ;
   int xcast_mode ;
   unsigned int vf_api ;
};
#line 194  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct vf_macvlans {
   struct list_head l ;
   int vf ;
   bool free ;
   bool is_macvlan ;
   u8 vf_macvlan[6U] ;
};
#line 211  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
union __anonunion_2619 {
   struct sk_buff *skb ;
   struct xdp_frame *xdpf ;
};
#line 211  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_tx_buffer {
   union ixgbe_adv_tx_desc *next_to_watch ;
   unsigned long time_stamp ;
   union __anonunion_2619 __anonCompField_ixgbe_tx_buffer_217 ;
   unsigned int bytecount ;
   unsigned short gso_segs ;
   __be16 protocol ;
   dma_addr_t dma ;
   __u32 len ;
   u32 tx_flags ;
};
#line 226  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct __anonstruct_2621 {
   struct page *page ;
   __u32 page_offset ;
   __u16 pagecnt_bias ;
};
#line 226  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct __anonstruct_2622 {
   void *addr ;
   u64 handle ;
};
#line 226  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
union __anonunion_2620 {
   struct __anonstruct_2621 __anonCompField___anonunion_2620_218 ;
   struct __anonstruct_2622 __anonCompField___anonunion_2620_219 ;
};
#line 226  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_rx_buffer {
   struct sk_buff *skb ;
   dma_addr_t dma ;
   union __anonunion_2620 __anonCompField_ixgbe_rx_buffer_220 ;
};
#line 242  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_queue_stats {
   u64 packets ;
   u64 bytes ;
};
#line 247  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_tx_queue_stats {
   u64 restart_queue ;
   u64 tx_busy ;
   u64 tx_done_old ;
};
#line 253  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_rx_queue_stats {
   u64 rsc_count ;
   u64 rsc_flush ;
   u64 non_eop_descs ;
   u64 alloc_rx_page ;
   u64 alloc_rx_page_failed ;
   u64 alloc_rx_buff_failed ;
   u64 csum_err ;
};
#line 282  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_fwd_adapter {
   unsigned long active_vlans[64U] ;
   struct net_device *netdev ;
   unsigned int tx_base_queue ;
   unsigned int rx_base_queue ;
   int pool ;
};
#line 308 
struct ixgbe_q_vector;
#line 308  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
union __anonunion_2623 {
   struct ixgbe_tx_buffer *tx_buffer_info ;
   struct ixgbe_rx_buffer *rx_buffer_info ;
};
#line 308  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct __anonstruct_2625 {
   u8 atr_sample_rate ;
   u8 atr_count ;
};
#line 308  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
union __anonunion_2624 {
   u16 next_to_alloc ;
   struct __anonstruct_2625 __anonCompField___anonunion_2624_222 ;
};
#line 308  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
union __anonunion_2626 {
   struct ixgbe_tx_queue_stats tx_stats ;
   struct ixgbe_rx_queue_stats rx_stats ;
};
#line 308  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_ring {
   struct ixgbe_ring *next ;
   struct ixgbe_q_vector *q_vector ;
   struct net_device *netdev ;
   struct bpf_prog *xdp_prog ;
   struct device *dev ;
   void *desc ;
   union __anonunion_2623 __anonCompField_ixgbe_ring_221 ;
   unsigned long state ;
   u8 *tail ;
   dma_addr_t dma ;
   unsigned int size ;
   u16 count ;
   u8 queue_index ;
   u8 reg_idx ;
   u16 next_to_use ;
   u16 next_to_clean ;
   unsigned long last_rx_timestamp ;
   union __anonunion_2624 __anonCompField_ixgbe_ring_223 ;
   u8 dcb_tc ;
   struct ixgbe_queue_stats stats ;
   struct u64_stats_sync syncp ;
   union __anonunion_2626 __anonCompField_ixgbe_ring_224 ;
   struct xdp_rxq_info xdp_rxq ;
   struct xdp_umem *xsk_umem ;
   struct zero_copy_allocator zca ;
   u16 ring_idx ;
   u16 rx_buf_len ;
} __attribute__((__aligned__(4096)));
#line 383  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_ring_feature {
   u16 limit ;
   u16 indices ;
   u16 mask ;
   u16 offset ;
} __attribute__((__aligned__(4096)));
#line 426  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_ring_container {
   struct ixgbe_ring *ring ;
   unsigned long next_update ;
   unsigned int total_bytes ;
   unsigned int total_packets ;
   u16 work_limit ;
   u8 count ;
   u8 itr ;
};
#line 447 
struct ixgbe_adapter;
#line 447  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_q_vector {
   struct ixgbe_adapter *adapter ;
   int cpu ;
   u16 v_idx ;
   u16 itr ;
   struct ixgbe_ring_container rx ;
   struct ixgbe_ring_container tx ;
   struct napi_struct napi ;
   cpumask_t affinity_mask ;
   int numa_node ;
   struct callback_head rcu ;
   char name[25U] ;
   struct ixgbe_ring ring[0U] ;
};
#line 475  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct hwmon_attr {
   struct device_attribute dev_attr ;
   struct ixgbe_hw *hw ;
   struct ixgbe_thermal_diode_data *sensor ;
   char name[12U] ;
};
#line 482  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct hwmon_buff {
   struct attribute_group group ;
   struct attribute_group *groups[2U] ;
   struct attribute *attrs[13U] ;
   struct hwmon_attr hwmon_list[12U] ;
   unsigned int n_hwmon ;
};
#line 536  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_mac_addr {
   u8 addr[6U] ;
   u16 pool ;
   u16 state ;
};
#line 557 
struct ixgbe_jump_table;
#line 557  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_adapter {
   unsigned long active_vlans[64U] ;
   struct net_device *netdev ;
   struct bpf_prog *xdp_prog ;
   struct pci_dev *pdev ;
   struct mii_bus *mii_bus ;
   unsigned long state ;
   u32 flags ;
   u32 flags2 ;
   int num_tx_queues ;
   u16 tx_itr_setting ;
   u16 tx_work_limit ;
   u64 tx_ipsec ;
   int num_rx_queues ;
   u16 rx_itr_setting ;
   u64 rx_ipsec ;
   __be16 vxlan_port ;
   __be16 geneve_port ;
   int num_xdp_queues ;
   struct ixgbe_ring *xdp_ring[64U] ;
   unsigned long *af_xdp_zc_qps ;
   struct ixgbe_ring *tx_ring[64U] ;
   u64 restart_queue ;
   u64 lsc_int ;
   u32 tx_timeout_count ;
   struct ixgbe_ring *rx_ring[64U] ;
   int num_rx_pools ;
   int num_rx_queues_per_pool ;
   u64 hw_csum_rx_error ;
   u64 hw_rx_no_dma_resources ;
   u64 rsc_total_count ;
   u64 rsc_total_flush ;
   u64 non_eop_descs ;
   u32 alloc_rx_page ;
   u32 alloc_rx_page_failed ;
   u32 alloc_rx_buff_failed ;
   struct ixgbe_q_vector *q_vector[64U] ;
   struct ieee_pfc *ixgbe_ieee_pfc ;
   struct ieee_ets *ixgbe_ieee_ets ;
   struct ixgbe_dcb_config dcb_cfg ;
   struct ixgbe_dcb_config temp_dcb_cfg ;
   u8 hw_tcs ;
   u8 dcb_set_bitmap ;
   u8 dcbx_cap ;
   enum ixgbe_fc_mode last_lfc_mode ;
   int num_q_vectors ;
   int max_q_vectors ;
   struct ixgbe_ring_feature ring_feature[5U] ;
   struct msix_entry *msix_entries ;
   u32 test_icr ;
   struct ixgbe_ring test_tx_ring ;
   struct ixgbe_ring test_rx_ring ;
   struct ixgbe_hw hw ;
   u16 msg_enable ;
   struct ixgbe_hw_stats stats ;
   u64 tx_busy ;
   unsigned int tx_ring_count ;
   unsigned int xdp_ring_count ;
   unsigned int rx_ring_count ;
   u32 link_speed ;
   bool link_up ;
   unsigned long sfp_poll_time ;
   unsigned long link_check_timeout ;
   struct timer_list service_timer ;
   struct work_struct service_task ;
   struct hlist_head fdir_filter_list ;
   unsigned long fdir_overflow ;
   union ixgbe_atr_input fdir_mask ;
   int fdir_filter_count ;
   u32 fdir_pballoc ;
   u32 atr_sample_rate ;
   spinlock_t fdir_perfect_lock ;
   struct ixgbe_fcoe fcoe ;
   u8 *io_addr ;
   u32 wol ;
   u16 bridge_mode ;
   char eeprom_id[32U] ;
   u16 eeprom_cap ;
   u32 interrupt_event ;
   u32 led_reg ;
   struct ptp_clock *ptp_clock ;
   struct ptp_clock_info ptp_caps ;
   struct work_struct ptp_tx_work ;
   struct sk_buff *ptp_tx_skb ;
   struct hwtstamp_config tstamp_config ;
   unsigned long ptp_tx_start ;
   unsigned long last_overflow_check ;
   unsigned long last_rx_ptp_check ;
   unsigned long last_rx_timestamp ;
   spinlock_t tmreg_lock ;
   struct cyclecounter hw_cc ;
   struct timecounter hw_tc ;
   u32 base_incval ;
   u32 tx_hwtstamp_timeouts ;
   u32 tx_hwtstamp_skipped ;
   u32 rx_hwtstamp_cleared ;
   void (*ptp_setup_sdp)(struct ixgbe_adapter *) ;
   unsigned long active_vfs[1U] ;
   unsigned int num_vfs ;
   struct vf_data_storage *vfinfo ;
   int vf_rate_link_speed ;
   struct vf_macvlans vf_mvs ;
   struct vf_macvlans *mv_list ;
   u32 timer_event_accumulator ;
   u32 vferr_refcount ;
   struct ixgbe_mac_addr *mac_table ;
   struct kobject *info_kobj ;
   struct hwmon_buff *ixgbe_hwmon_buff ;
   struct dentry *ixgbe_dbg_adapter ;
   u8 default_up ;
   unsigned long fwd_bitmask[1U] ;
   struct ixgbe_jump_table *jump_tables[10U] ;
   unsigned long tables ;
   u8 rss_indir_tbl[512U] ;
   u32 *rss_key ;
   struct ixgbe_ipsec *ipsec ;
};
#line 794  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_fdir_filter {
   struct hlist_node fdir_node ;
   union ixgbe_atr_input filter ;
   u16 sw_idx ;
   u64 action ;
};
#line 815  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
union __anonunion_2627 {
   struct sk_buff *head ;
   struct sk_buff *tail ;
};
#line 815  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_cb {
   union __anonunion_2627 __anonCompField_ixgbe_cb_225 ;
   dma_addr_t dma ;
   u16 append_cnt ;
   bool page_released ;
};
#line 10  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_model.h"
struct ixgbe_mat_field {
   unsigned int off ;
   int (*val)(struct ixgbe_fdir_filter *, union ixgbe_atr_input *, u32 , u32 ) ;
   unsigned int type ;
};
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_model.h"
struct ixgbe_jump_table {
   struct ixgbe_mat_field *mat ;
   struct ixgbe_fdir_filter *input ;
   union ixgbe_atr_input *mask ;
   u32 link_hdl ;
   unsigned long child_loc_map[32U] ;
};
#line 78  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_model.h"
struct ixgbe_nexthdr {
   unsigned int o ;
   u32 s ;
   u32 m ;
   unsigned int off ;
   u32 val ;
   u32 mask ;
   struct ixgbe_mat_field *jump ;
};
#line 297  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
union __anonunion___u_2629 {
   u8 *__val ;
   char __c[1U] ;
};
#line 334  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
union __anonunion___u_2631 {
   u8 *__val ;
   char __c[1U] ;
};
#line 426  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
struct ixgbe_reg_info {
   u32 ofs ;
   char *name ;
};
#line 575  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
struct my_u0 {
   u64 a ;
   u64 b ;
};
#line 2206  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
union __anonunion___u_2633 {
   struct bpf_prog *__val ;
   char __c[1U] ;
};
#line 7959  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
union __anonunion_ip_2636 {
   struct iphdr *v4 ;
   struct ipv6hdr *v6 ;
   unsigned char *hdr ;
};
#line 7964  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
union __anonunion_l4_2637 {
   struct tcphdr *tcp ;
   struct udphdr *udp ;
   unsigned char *hdr ;
};
#line 8371  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
union __anonunion_hdr_2639 {
   unsigned char *network ;
   struct iphdr *ipv4 ;
   struct ipv6hdr *ipv6 ;
};
#line 8952  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
union __anonunion___u_2641 {
   struct ixgbe_ring *__val ;
   char __c[1U] ;
};
#line 8968  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
union __anonunion___u_2643 {
   struct ixgbe_ring *__val ;
   char __c[1U] ;
};
#line 8973  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
union __anonunion___u_2645 {
   struct ixgbe_ring *__val ;
   char __c[1U] ;
};
#line 9263  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
struct upper_walk_data {
   struct ixgbe_adapter *adapter ;
   u64 action ;
   int ifindex ;
   u8 queue ;
};
#line 10289  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
union __anonunion___u_2649 {
   struct bpf_prog *__val ;
   char __c[1U] ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
union __anonunion___u_3369 {
   u8 *__val ;
   char __c[1U] ;
};
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/atomic.h"
union __anonunion___u_3447 {
   int __val ;
   char __c[1U] ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 196  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
enum kmalloc_cache_type {
    KMALLOC_NORMAL = 0,
    KMALLOC_RECLAIM = 1,
    KMALLOC_DMA = 2,
    NR_KMALLOC_TYPES = 3
};
#line 2885  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_adv_tx_context_desc {
   __le32 vlan_macip_lens ;
   __le32 fceof_saidx ;
   __le32 type_tucmd_mlhl ;
   __le32 mss_l4len_idx ;
};
#line 55  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timekeeping.h"
enum tk_offsets {
    TK_OFFS_REAL = 0,
    TK_OFFS_BOOT = 1,
    TK_OFFS_TAI = 2,
    TK_OFFS_MAX = 3
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 35  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pps_kernel.h"
struct pps_event_time {
   struct timespec64 ts_real ;
};
#line 163  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ptp_clock_kernel.h"
union __anonunion_4817 {
   u64 timestamp ;
   struct pps_event_time pps_times ;
};
#line 163  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ptp_clock_kernel.h"
struct ptp_clock_event {
   int type ;
   int index ;
   union __anonunion_4817 __anonCompField_ptp_clock_event_163 ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
union __anonunion___u_4833 {
   u8 *__val ;
   char __c[1U] ;
};
#line 439  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/property.h"
typedef u32 phandle;
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   struct bin_attribute attr ;
};
#line 51  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/of.h"
struct device_node {
   char *name ;
   phandle phandle ;
   char *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};
#line 459  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
union __anonunion___u_4848 {
   u32 __val ;
   char __c[1U] ;
};
#line 1283  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
union __anonunion___u_4850 {
   u32 __val ;
   char __c[1U] ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 197 
enum hrtimer_restart;
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
union __anonunion___u_6301 {
   u8 *__val ;
   char __c[1U] ;
};
#line 690  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmdebug.h"
struct wait_queue_entry;
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmdebug.h"
typedef struct wait_queue_entry wait_queue_entry_t;
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/wait.h"
struct wait_queue_entry {
   unsigned int flags ;
   void *private ;
   int (*func)(struct wait_queue_entry *, unsigned int , int , void *) ;
   struct list_head entry ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
union __anonunion___u_7032 {
   u8 *__val ;
   char __c[1U] ;
};
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/scsi/fc/fc_fs.h"
struct fc_frame_header {
   __u8 fh_r_ctl ;
   __u8 fh_d_id[3U] ;
   __u8 fh_cs_ctl ;
   __u8 fh_s_id[3U] ;
   __u8 fh_type ;
   __u8 fh_f_ctl[3U] ;
   __u8 fh_seq_id ;
   __u8 fh_df_ctl ;
   __be16 fh_seq_cnt ;
   __be16 fh_ox_id ;
   __be16 fh_rx_id ;
   __be32 fh_parm_offset ;
};
#line 39  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/scsi/fc/fc_fcoe.h"
struct fcoe_hdr {
   __u8 fcoe_ver ;
   __u8 fcoe_resvd[12U] ;
   __u8 fcoe_sof ;
};
#line 51  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/scsi/fc/fc_fcoe.h"
struct fcoe_crc_eof {
   __le32 fcoe_crc32 ;
   __u8 fcoe_eof ;
   __u8 fcoe_resvd[3U] ;
} __attribute__((__packed__));
#line 294  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
enum blk_eh_timer_return {
    BLK_EH_DONE = 0,
    BLK_EH_RESET_TIMER = 1
};
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sbitmap.h"
struct sbitmap_word {
   unsigned long depth ;
   unsigned long word ;
   unsigned long cleared ;
   spinlock_t swap_lock ;
} __attribute__((__aligned__(64)));
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sbitmap.h"
struct sbitmap {
   unsigned int depth ;
   unsigned int shift ;
   unsigned int map_nr ;
   struct sbitmap_word *map ;
};
#line 582 
struct blk_mq_tags;
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-mq.h"
struct __anonstruct_7055 {
   spinlock_t lock ;
   struct list_head dispatch ;
   unsigned long state ;
} __attribute__((__aligned__(64)));
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-mq.h"
struct blk_mq_hw_ctx {
   struct __anonstruct_7055 __anonCompField_blk_mq_hw_ctx_179 ;
   struct delayed_work run_work ;
   cpumask_var_t cpumask ;
   int next_cpu ;
   int next_cpu_batch ;
   unsigned long flags ;
   void *sched_data ;
   struct request_queue *queue ;
   struct blk_flush_queue *fq ;
   void *driver_data ;
   struct sbitmap ctx_map ;
   struct blk_mq_ctx *dispatch_from ;
   unsigned int dispatch_busy ;
   unsigned short type ;
   unsigned short nr_ctx ;
   struct blk_mq_ctx **ctxs ;
   spinlock_t dispatch_wait_lock ;
   wait_queue_entry_t dispatch_wait ;
   atomic_t wait_index ;
   struct blk_mq_tags *tags ;
   struct blk_mq_tags *sched_tags ;
   unsigned long queued ;
   unsigned long run ;
   unsigned long dispatched[7U] ;
   unsigned int numa_node ;
   unsigned int queue_num ;
   atomic_t nr_active ;
   struct hlist_node cpuhp_dead ;
   struct kobject kobj ;
   unsigned long poll_considered ;
   unsigned long poll_invoked ;
   unsigned long poll_success ;
   struct dentry *debugfs_dir ;
   struct dentry *sched_debugfs_dir ;
   struct list_head hctx_list ;
   struct srcu_struct srcu[0U] ;
};
#line 186  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-mq.h"
struct blk_mq_queue_map {
   unsigned int *mq_map ;
   unsigned int nr_queues ;
   unsigned int queue_offset ;
};
#line 235  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-mq.h"
struct blk_mq_tag_set {
   struct blk_mq_queue_map map[3U] ;
   unsigned int nr_maps ;
   struct blk_mq_ops *ops ;
   unsigned int nr_hw_queues ;
   unsigned int queue_depth ;
   unsigned int reserved_tags ;
   unsigned int cmd_size ;
   int numa_node ;
   unsigned int timeout ;
   unsigned int flags ;
   void *driver_data ;
   struct blk_mq_tags **tags ;
   struct mutex tag_list_lock ;
   struct list_head tag_list ;
};
#line 260  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-mq.h"
struct blk_mq_queue_data {
   struct request *rq ;
   bool last ;
};
#line 264  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-mq.h"
typedef blk_status_t queue_rq_fn(struct blk_mq_hw_ctx *, struct blk_mq_queue_data *);
#line 266  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-mq.h"
typedef void commit_rqs_fn(struct blk_mq_hw_ctx *);
#line 268  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-mq.h"
typedef bool get_budget_fn(struct blk_mq_hw_ctx *);
#line 269  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-mq.h"
typedef void put_budget_fn(struct blk_mq_hw_ctx *);
#line 270  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-mq.h"
typedef enum blk_eh_timer_return timeout_fn(struct request *, bool );
#line 271  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-mq.h"
typedef int init_hctx_fn(struct blk_mq_hw_ctx *, void *, unsigned int );
#line 272  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-mq.h"
typedef void exit_hctx_fn(struct blk_mq_hw_ctx *, unsigned int );
#line 273  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-mq.h"
typedef int init_request_fn(struct blk_mq_tag_set *, struct request *, unsigned int , unsigned int );
#line 274  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-mq.h"
typedef void exit_request_fn(struct blk_mq_tag_set *, struct request *, unsigned int );
#line 281  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-mq.h"
typedef int poll_fn(struct blk_mq_hw_ctx *);
#line 282  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-mq.h"
typedef int map_queues_fn(struct blk_mq_tag_set *);
#line 283  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-mq.h"
typedef bool busy_fn(struct request_queue *);
#line 284  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-mq.h"
typedef void complete_fn(struct request *);
#line 285  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-mq.h"
typedef void cleanup_rq_fn(struct request *);
#line 291  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-mq.h"
struct blk_mq_ops {
   queue_rq_fn *queue_rq ;
   commit_rqs_fn *commit_rqs ;
   get_budget_fn *get_budget ;
   put_budget_fn *put_budget ;
   timeout_fn *timeout ;
   poll_fn *poll ;
   complete_fn *complete ;
   init_hctx_fn *init_hctx ;
   exit_hctx_fn *exit_hctx ;
   init_request_fn *init_request ;
   exit_request_fn *exit_request ;
   void (*initialize_rq_fn)(struct request *) ;
   cleanup_rq_fn *cleanup_rq ;
   busy_fn *busy ;
   map_queues_fn *map_queues ;
   void (*show_rq)(struct seq_file *, struct request *) ;
};
#line 754  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_7084 {
   struct hlist_node *__val ;
   char __c[1U] ;
};
#line 762  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_7086 {
   struct hlist_node *__val ;
   char __c[1U] ;
};
#line 788  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_7088 {
   struct hlist_node *__val ;
   char __c[1U] ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
union __anonunion___u_7785 {
   u8 *__val ;
   char __c[1U] ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
struct ixgbe_stats {
   char stat_string[32U] ;
   int type ;
   int sizeof_stat ;
   int stat_offset ;
};
#line 1338  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
struct ixgbe_reg_test {
   u16 reg ;
   u8 array_len ;
   u8 test_type ;
   u32 mask ;
   u32 write ;
};
#line 3281  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
struct __anonstruct_ixgbe_ls_map_7804 {
   ixgbe_link_speed mac_speed ;
   u32 supported ;
};
#line 3292  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
struct __anonstruct_ixgbe_lp_map_7805 {
   u32 lp_advertised ;
   u32 mac_speed ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
union __anonunion___u_8528 {
   u8 *__val ;
   char __c[1U] ;
};
#line 165  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
union __anonunion___u_8530 {
   u8 *__val ;
   char __c[1U] ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 2728  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
union __anonunion_cmd_or_resp_9227 {
   u8 cmd_resv ;
   u8 ret_status ;
};
#line 2728  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hic_hdr {
   u8 cmd ;
   u8 buf_len ;
   union __anonunion_cmd_or_resp_9227 cmd_or_resp ;
   u8 checksum ;
};
#line 2738  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hic_hdr2_req {
   u8 cmd ;
   u8 buf_lenh ;
   u8 buf_lenl ;
   u8 checksum ;
};
#line 2745  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hic_hdr2_rsp {
   u8 cmd ;
   u8 buf_lenl ;
   u8 buf_lenh_status ;
   u8 checksum ;
};
#line 2752  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
union ixgbe_hic_hdr2 {
   struct ixgbe_hic_hdr2_req req ;
   struct ixgbe_hic_hdr2_rsp rsp ;
};
#line 2768  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hic_drv_info2 {
   struct ixgbe_hic_hdr hdr ;
   u8 port_num ;
   u8 ver_sub ;
   u8 ver_build ;
   u8 ver_min ;
   u8 ver_maj ;
   char driver_string[39U] ;
};
#line 2779  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hic_read_shadow_ram {
   union ixgbe_hic_hdr2 hdr ;
   u32 address ;
   u16 length ;
   u16 pad2 ;
   u16 data ;
   u16 pad3 ;
};
#line 2788  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hic_write_shadow_ram {
   union ixgbe_hic_hdr2 hdr ;
   __be32 address ;
   __be16 length ;
   u16 pad2 ;
   u16 data ;
   u16 pad3 ;
};
#line 2797  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hic_disable_rxen {
   struct ixgbe_hic_hdr hdr ;
   u8 port_number ;
   u8 pad2 ;
   u16 pad3 ;
};
#line 2804  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hic_phy_token_req {
   struct ixgbe_hic_hdr hdr ;
   u8 port_number ;
   u8 command_type ;
   u16 pad ;
};
#line 2811  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hic_internal_phy_req {
   struct ixgbe_hic_hdr hdr ;
   u8 port_number ;
   u8 command_type ;
   __be16 address ;
   u16 rsv1 ;
   __be32 write_data ;
   u16 pad ;
} __attribute__((__packed__));
#line 2821  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hic_internal_phy_resp {
   struct ixgbe_hic_hdr hdr ;
   __be32 read_data ;
};
#line 2826  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hic_phy_activity_req {
   struct ixgbe_hic_hdr hdr ;
   u8 port_number ;
   u8 pad ;
   __le16 activity_id ;
   __be32 data[4U] ;
};
#line 2834  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hic_phy_activity_resp {
   struct ixgbe_hic_hdr hdr ;
   __be32 data[4U] ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
union __anonunion___u_9268 {
   u8 *__val ;
   char __c[1U] ;
};
#line 433  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
union __anonunion_hic_9272 {
   struct ixgbe_hic_phy_activity_req cmd ;
   struct ixgbe_hic_phy_activity_resp rsp ;
};
#line 472  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
struct __anonstruct_ixgbe_fw_map_9274 {
   u16 fw_speed ;
   ixgbe_link_speed phy_speed ;
};
#line 821  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
union __anonunion_hic_9278 {
   struct ixgbe_hic_internal_phy_req cmd ;
   struct ixgbe_hic_internal_phy_resp rsp ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
union __anonunion___u_9999 {
   u8 *__val ;
   char __c[1U] ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 197 
enum hrtimer_restart;
#line 201  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_hw_addr {
   struct list_head list ;
   unsigned char addr[32U] ;
   unsigned char type ;
   bool global_use ;
   int sync_cnt ;
   int refcount ;
   int synced ;
   struct callback_head callback_head ;
};
#line 2757  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hic_drv_info {
   struct ixgbe_hic_hdr hdr ;
   u8 port_num ;
   u8 ver_sub ;
   u8 ver_build ;
   u8 ver_min ;
   u8 ver_maj ;
   u8 pad ;
   u16 pad2 ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
union __anonunion___u_11461 {
   u8 *__val ;
   char __c[1U] ;
};
#line 3681  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
union __anonunion_bp_11474 {
   struct ixgbe_hic_hdr hdr ;
   u32 u32arr[1U] ;
};
#line 762  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_11498 {
   struct hlist_node *__val ;
   char __c[1U] ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 532  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rculist.h"
union __anonunion___u_11758 {
   struct hlist_node *__val ;
   char __c[1U] ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
union __anonunion___u_12197 {
   u8 *__val ;
   char __c[1U] ;
};
#line 65  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dca.h"
enum ixgbe_ipsec_tbl_sel {
    ips_rx_ip_tbl = 1,
    ips_rx_spi_tbl = 2,
    ips_rx_key_tbl = 3
};
#line 75  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.h"
struct sa_mbx_msg {
   __be32 spi ;
   u8 flags ;
   u8 proto ;
   u16 family ;
   __be32 addr[4U] ;
   u32 key[5U] ;
};
#line 142  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/pfkeyv2.h"
struct sadb_alg {
   __u8 sadb_alg_id ;
   __u8 sadb_alg_ivlen ;
   __u16 sadb_alg_minbits ;
   __u16 sadb_alg_maxbits ;
   __u16 sadb_alg_reserved ;
} __attribute__((__packed__));
#line 109  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ip.h"
struct ip_auth_hdr {
   __u8 nexthdr ;
   __u8 hdrlen ;
   __be16 reserved ;
   __be32 spi ;
   __be32 seq_no ;
   __u8 auth_data[0U] ;
};
#line 118  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ip.h"
struct ip_esp_hdr {
   __be32 spi ;
   __be32 seq_no ;
   __u8 enc_data[0U] ;
};
#line 1360  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
struct xfrm_algo_aead_info {
   char *geniv ;
   u16 icv_truncbits ;
};
#line 1365  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
struct xfrm_algo_auth_info {
   u16 icv_truncbits ;
   u16 icv_fullbits ;
};
#line 1370  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
struct xfrm_algo_encr_info {
   char *geniv ;
   u16 blockbits ;
   u16 defkeybits ;
};
#line 1376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
struct xfrm_algo_comp_info {
   u16 threshold ;
};
#line 1380  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
union __anonunion_uinfo_12527 {
   struct xfrm_algo_aead_info aead ;
   struct xfrm_algo_auth_info auth ;
   struct xfrm_algo_encr_info encr ;
   struct xfrm_algo_comp_info comp ;
};
#line 1380  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
struct xfrm_algo_desc {
   char *name ;
   char *compat ;
   u8 available : 1 ;
   u8 pfkey_supported : 1 ;
   union __anonunion_uinfo_12527 uinfo ;
   struct sadb_alg desc ;
};
#line 400  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
union __anonunion___u_13488 {
   struct hlist_node *__val ;
   char __c[1U] ;
};
#line 400  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
union __anonunion___u_13490 {
   struct hlist_node *__val ;
   char __c[1U] ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
union __anonunion___u_14347 {
   u8 *__val ;
   char __c[1U] ;
};
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_14371 {
   struct list_head *__val ;
   char __c[1U] ;
};
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/atomic.h"
union __anonunion___u_14425 {
   int __val ;
   char __c[1U] ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
union __anonunion___u_15339 {
   u8 *__val ;
   char __c[1U] ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
union __anonunion___u_16070 {
   u8 *__val ;
   char __c[1U] ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 550  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
union __anonunion___u_16754 {
   unsigned long __val ;
   char __c[1U] ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/trace/events/xdp.h"
union __anonunion___u_16876 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/trace/events/xdp.h"
union __anonunion___u_16878 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 100  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if_xdp.h"
struct xdp_desc {
   __u64 addr ;
   __u32 len ;
   __u32 options ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
union __anonunion___u_17102 {
   struct bpf_prog *__val ;
   char __c[1U] ;
};
#line 154  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
union __anonunion___u_17104 {
   struct bpf_prog *__val ;
   char __c[1U] ;
};
#line 706  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
union __anonunion___u_17106 {
   struct bpf_prog *__val ;
   char __c[1U] ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
union __anonunion___u_17826 {
   u8 *__val ;
   char __c[1U] ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 197 
enum hrtimer_restart;
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
struct device_private {
   void *driver_data ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/firmware.h"
struct firmware {
   size_t size ;
   u8 *data ;
   struct page **pages ;
   void *priv ;
};
#line 164  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef unsigned long irq_hw_number_t;
#line 303  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ioport.h"
struct irq_data;
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 244  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/idr.h"
struct ida {
   struct xarray xa ;
};
#line 63  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/irqdomain.h"
struct irq_fwspec {
   struct fwnode_handle *fwnode ;
   int param_count ;
   u32 param[16U] ;
};
#line 68 
enum irq_domain_bus_token {
    DOMAIN_BUS_ANY = 0,
    DOMAIN_BUS_WIRED = 1,
    DOMAIN_BUS_GENERIC_MSI = 2,
    DOMAIN_BUS_PCI_MSI = 3,
    DOMAIN_BUS_PLATFORM_MSI = 4,
    DOMAIN_BUS_NEXUS = 5,
    DOMAIN_BUS_IPI = 6,
    DOMAIN_BUS_FSL_MC_MSI = 7,
    DOMAIN_BUS_TI_SCI_INTA_MSI = 8,
    DOMAIN_BUS_WAKEUP = 9
};
#line 104  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/irqdomain.h"
struct irq_domain_ops {
   int (*match)(struct irq_domain *, struct device_node *, enum irq_domain_bus_token ) ;
   int (*select)(struct irq_domain *, struct irq_fwspec *, enum irq_domain_bus_token ) ;
   int (*map)(struct irq_domain *, unsigned int , irq_hw_number_t ) ;
   void (*unmap)(struct irq_domain *, unsigned int ) ;
   int (*xlate)(struct irq_domain *, struct device_node *, u32 *, unsigned int , unsigned long *, unsigned int *) ;
   int (*alloc)(struct irq_domain *, unsigned int , unsigned int , void *) ;
   void (*free)(struct irq_domain *, unsigned int , unsigned int ) ;
   int (*activate)(struct irq_domain *, struct irq_data *, bool ) ;
   void (*deactivate)(struct irq_domain *, struct irq_data *) ;
   int (*translate)(struct irq_domain *, struct irq_fwspec *, unsigned long *, unsigned int *) ;
   void (*debug_show)(struct seq_file *, struct irq_domain *, struct irq_data *, int ) ;
};
#line 132 
struct irq_domain_chip_generic;
#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/irqdomain.h"
struct irq_domain {
   struct list_head link ;
   char *name ;
   struct irq_domain_ops *ops ;
   void *host_data ;
   unsigned int flags ;
   unsigned int mapcount ;
   struct fwnode_handle *fwnode ;
   enum irq_domain_bus_token bus_token ;
   struct irq_domain_chip_generic *gc ;
   struct irq_domain *parent ;
   struct dentry *debugfs_file ;
   irq_hw_number_t hwirq_max ;
   unsigned int revmap_direct_max_irq ;
   unsigned int revmap_size ;
   struct xarray revmap_tree ;
   struct mutex revmap_tree_mutex ;
   unsigned int linear_revmap[] ;
};
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rtmutex.h"
struct rt_mutex {
   raw_spinlock_t wait_lock ;
   struct rb_root_cached waiters ;
   struct task_struct *owner ;
   int save_state ;
   char *name ;
   char *file ;
   int line ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 69  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/i2c.h"
struct i2c_msg {
   __u16 addr ;
   __u16 flags ;
   __u16 len ;
   __u8 *buf ;
};
#line 135  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/i2c.h"
union i2c_smbus_data {
   __u8 byte ;
   __u16 word ;
   __u8 block[34U] ;
};
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/i2c.h"
struct i2c_algorithm;
#line 28 
struct i2c_adapter;
#line 29 
struct i2c_client;
#line 33 
enum i2c_slave_event;
#line 33 
enum i2c_slave_event;
#line 314  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/i2c.h"
struct i2c_client {
   unsigned short flags ;
   unsigned short addr ;
   char name[20U] ;
   struct i2c_adapter *adapter ;
   struct device dev ;
   int init_irq ;
   int irq ;
   struct list_head detected ;
   int (*slave_cb)(struct i2c_client *, enum i2c_slave_event , u8 *) ;
};
#line 360 
enum i2c_slave_event {
    I2C_SLAVE_READ_REQUESTED = 0,
    I2C_SLAVE_WRITE_REQUESTED = 1,
    I2C_SLAVE_READ_PROCESSED = 2,
    I2C_SLAVE_WRITE_RECEIVED = 3,
    I2C_SLAVE_STOP = 4
};
#line 527  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/i2c.h"
struct i2c_algorithm {
   int (*master_xfer)(struct i2c_adapter *, struct i2c_msg *, int ) ;
   int (*master_xfer_atomic)(struct i2c_adapter *, struct i2c_msg *, int ) ;
   int (*smbus_xfer)(struct i2c_adapter *, u16 , unsigned short , char , u8 , int , union i2c_smbus_data *) ;
   int (*smbus_xfer_atomic)(struct i2c_adapter *, u16 , unsigned short , char , u8 , int , union i2c_smbus_data *) ;
   u32 (*functionality)(struct i2c_adapter *) ;
   int (*reg_slave)(struct i2c_client *) ;
   int (*unreg_slave)(struct i2c_client *) ;
};
#line 565  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/i2c.h"
struct i2c_lock_operations {
   void (*lock_bus)(struct i2c_adapter *, unsigned int ) ;
   int (*trylock_bus)(struct i2c_adapter *, unsigned int ) ;
   void (*unlock_bus)(struct i2c_adapter *, unsigned int ) ;
};
#line 618  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/i2c.h"
struct i2c_bus_recovery_info {
   int (*recover_bus)(struct i2c_adapter *) ;
   int (*get_scl)(struct i2c_adapter *) ;
   void (*set_scl)(struct i2c_adapter *, int ) ;
   int (*get_sda)(struct i2c_adapter *) ;
   void (*set_sda)(struct i2c_adapter *, int ) ;
   int (*get_bus_free)(struct i2c_adapter *) ;
   void (*prepare_recovery)(struct i2c_adapter *) ;
   void (*unprepare_recovery)(struct i2c_adapter *) ;
   struct gpio_desc *scl_gpiod ;
   struct gpio_desc *sda_gpiod ;
};
#line 661  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/i2c.h"
struct i2c_adapter_quirks {
   u64 flags ;
   int max_num_msgs ;
   u16 max_write_len ;
   u16 max_read_len ;
   u16 max_comb_1st_msg_len ;
   u16 max_comb_2nd_msg_len ;
};
#line 692  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/i2c.h"
struct i2c_adapter {
   struct module *owner ;
   unsigned int class ;
   struct i2c_algorithm *algo ;
   void *algo_data ;
   struct i2c_lock_operations *lock_ops ;
   struct rt_mutex bus_lock ;
   struct rt_mutex mux_lock ;
   int timeout ;
   int retries ;
   struct device dev ;
   unsigned long locked_flags ;
   int nr ;
   char name[48U] ;
   struct completion dev_released ;
   struct mutex userspace_clients_lock ;
   struct list_head userspace_clients ;
   struct i2c_bus_recovery_info *bus_recovery_info ;
   struct i2c_adapter_quirks *quirks ;
   struct irq_domain *host_notify_domain ;
};
#line 87  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/v4l2-common.h"
struct v4l2_edid {
   __u32 pad ;
   __u32 start_block ;
   __u32 blocks ;
   __u32 reserved[5U] ;
   __u8 *edid ;
};
#line 754 
enum v4l2_priority {
    V4L2_PRIORITY_UNSET = 0,
    V4L2_PRIORITY_BACKGROUND = 1,
    V4L2_PRIORITY_INTERACTIVE = 2,
    V4L2_PRIORITY_RECORD = 3,
    V4L2_PRIORITY_DEFAULT = 2
};
#line 413  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_rect {
   __s32 left ;
   __s32 top ;
   __u32 width ;
   __u32 height ;
};
#line 420  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_fract {
   __u32 numerator ;
   __u32 denominator ;
};
#line 1212  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
typedef __u64 v4l2_std_id;
#line 1394  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_bt_timings {
   __u32 width ;
   __u32 height ;
   __u32 interlaced ;
   __u32 polarities ;
   __u64 pixelclock ;
   __u32 hfrontporch ;
   __u32 hsync ;
   __u32 hbackporch ;
   __u32 vfrontporch ;
   __u32 vsync ;
   __u32 vbackporch ;
   __u32 il_vfrontporch ;
   __u32 il_vsync ;
   __u32 il_vbackporch ;
   __u32 standards ;
   __u32 flags ;
   struct v4l2_fract picture_aspect ;
   __u8 cea861_vic ;
   __u8 hdmi_vic ;
   __u8 reserved[46U] ;
} __attribute__((__packed__));
#line 1517  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
union __anonunion_19616 {
   struct v4l2_bt_timings bt ;
   __u32 reserved[32U] ;
};
#line 1517  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_dv_timings {
   __u32 type ;
   union __anonunion_19616 __anonCompField_v4l2_dv_timings_77 ;
} __attribute__((__packed__));
#line 1536  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_enum_dv_timings {
   __u32 index ;
   __u32 pad ;
   __u32 reserved[2U] ;
   struct v4l2_dv_timings timings ;
};
#line 1554  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_bt_timings_cap {
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u64 min_pixelclock ;
   __u64 max_pixelclock ;
   __u32 standards ;
   __u32 capabilities ;
   __u32 reserved[16U] ;
} __attribute__((__packed__));
#line 1581  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
union __anonunion_19617 {
   struct v4l2_bt_timings_cap bt ;
   __u32 raw_data[32U] ;
};
#line 1581  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_dv_timings_cap {
   __u32 type ;
   __u32 pad ;
   __u32 reserved[2U] ;
   union __anonunion_19617 __anonCompField_v4l2_dv_timings_cap_78 ;
};
#line 1803  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_tuner {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 rxsubchans ;
   __u32 audmode ;
   __s32 signal ;
   __s32 afc ;
   __u32 reserved[4U] ;
};
#line 1817  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_modulator {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 txsubchans ;
   __u32 type ;
   __u32 reserved[3U] ;
};
#line 1860  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_frequency {
   __u32 tuner ;
   __u32 type ;
   __u32 frequency ;
   __u32 reserved[8U] ;
};
#line 1871  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_frequency_band {
   __u32 tuner ;
   __u32 type ;
   __u32 index ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 modulation ;
   __u32 reserved[9U] ;
};
#line 2043  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_vbi_format {
   __u32 sampling_rate ;
   __u32 offset ;
   __u32 samples_per_line ;
   __u32 sample_format ;
   __s32 start[2U] ;
   __u32 count[2U] ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 2071  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_format {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 io_size ;
   __u32 reserved[2U] ;
};
#line 2095  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_cap {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 type ;
   __u32 reserved[3U] ;
};
#line 2106  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_data {
   __u32 id ;
   __u32 field ;
   __u32 line ;
   __u32 reserved ;
   __u8 data[48U] ;
};
#line 2350  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_event_subscription {
   __u32 type ;
   __u32 id ;
   __u32 flags ;
   __u32 reserved[5U] ;
};
#line 2375  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
union __anonunion_19633 {
   __u32 addr ;
   char name[32U] ;
};
#line 2375  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_dbg_match {
   __u32 type ;
   union __anonunion_19633 __anonCompField_v4l2_dbg_match_87 ;
} __attribute__((__packed__));
#line 2383  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_dbg_register {
   struct v4l2_dbg_match match ;
   __u32 size ;
   __u64 reg ;
   __u64 val ;
} __attribute__((__packed__));
#line 57  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_device;
#line 57  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_gobj {
   struct media_device *mdev ;
   u32 id ;
   struct list_head list ;
};
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_entity_enum {
   unsigned long *bmap ;
   int idx_max ;
};
#line 88 
struct media_entity;
#line 88  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct __anonstruct_stack_19637 {
   struct media_entity *entity ;
   struct list_head *link ;
};
#line 88  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_graph {
   struct __anonstruct_stack_19637 stack[16U] ;
   struct media_entity_enum ent_enum ;
   int top ;
};
#line 104  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_pipeline {
   int streaming_count ;
   struct media_graph graph ;
};
#line 132 
struct media_pad;
#line 132 
struct media_interface;
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
union __anonunion_19638 {
   struct media_gobj *gobj0 ;
   struct media_pad *source ;
   struct media_interface *intf ;
};
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
union __anonunion_19639 {
   struct media_gobj *gobj1 ;
   struct media_pad *sink ;
   struct media_entity *entity ;
};
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_link {
   struct media_gobj graph_obj ;
   struct list_head list ;
   union __anonunion_19638 __anonCompField_media_link_90 ;
   union __anonunion_19639 __anonCompField_media_link_91 ;
   struct media_link *reverse ;
   unsigned long flags ;
   bool is_backlink ;
};
#line 149 
enum media_pad_signal_type {
    PAD_SIGNAL_DEFAULT = 0,
    PAD_SIGNAL_ANALOG = 1,
    PAD_SIGNAL_DV = 2,
    PAD_SIGNAL_AUDIO = 3
};
#line 189  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_pad {
   struct media_gobj graph_obj ;
   struct media_entity *entity ;
   u16 index ;
   enum media_pad_signal_type sig_type ;
   unsigned long flags ;
};
#line 214  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_entity_operations {
   int (*get_fwnode_pad)(struct fwnode_endpoint *) ;
   int (*link_setup)(struct media_entity *, struct media_pad *, struct media_pad *, u32 ) ;
   int (*link_validate)(struct media_link *) ;
};
#line 221 
enum media_entity_type {
    MEDIA_ENTITY_TYPE_BASE = 0,
    MEDIA_ENTITY_TYPE_VIDEO_DEVICE = 1,
    MEDIA_ENTITY_TYPE_V4L2_SUBDEV = 2
};
#line 289  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct __anonstruct_dev_19641 {
   u32 major ;
   u32 minor ;
};
#line 289  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
union __anonunion_info_19640 {
   struct __anonstruct_dev_19641 dev ;
};
#line 289  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_entity {
   struct media_gobj graph_obj ;
   char *name ;
   enum media_entity_type obj_type ;
   u32 function ;
   unsigned long flags ;
   u16 num_pads ;
   u16 num_links ;
   u16 num_backlinks ;
   int internal_idx ;
   struct media_pad *pads ;
   struct list_head links ;
   struct media_entity_operations *ops ;
   int stream_count ;
   int use_count ;
   struct media_pipeline *pipe ;
   union __anonunion_info_19640 info ;
};
#line 335  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_interface {
   struct media_gobj graph_obj ;
   struct list_head links ;
   u32 type ;
   u32 flags ;
};
#line 349  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_intf_devnode {
   struct media_interface intf ;
   u32 major ;
   u32 minor ;
};
#line 1087 
enum vfl_devnode_type {
    VFL_TYPE_GRABBER = 0,
    VFL_TYPE_VBI = 1,
    VFL_TYPE_RADIO = 2,
    VFL_TYPE_SUBDEV = 3,
    VFL_TYPE_SDR = 4,
    VFL_TYPE_TOUCH = 5,
    VFL_TYPE_MAX = 6
};
#line 1097 
enum vfl_devnode_direction {
    VFL_DIR_RX = 0,
    VFL_DIR_TX = 1,
    VFL_DIR_M2M = 2
};
#line 1104 
struct video_device;
#line 1105 
struct v4l2_device;
#line 1106 
struct v4l2_ctrl_handler;
#line 104  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-dev.h"
struct v4l2_prio_state {
   atomic_t prios[4U] ;
};
#line 193  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-dev.h"
struct v4l2_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file *, char *, size_t , loff_t *) ;
   ssize_t (*write)(struct file *, char *, size_t , loff_t *) ;
   __poll_t (*poll)(struct file *, struct poll_table_struct *) ;
   long (*unlocked_ioctl)(struct file *, unsigned int , unsigned long ) ;
   long (*compat_ioctl32)(struct file *, unsigned int , unsigned long ) ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   int (*mmap)(struct file *, struct vm_area_struct *) ;
   int (*open)(struct file *) ;
   int (*release)(struct file *) ;
};
#line 256 
struct vb2_queue;
#line 256 
struct v4l2_ioctl_ops;
#line 256  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-dev.h"
struct video_device {
   struct media_entity entity ;
   struct media_intf_devnode *intf_devnode ;
   struct media_pipeline pipe ;
   struct v4l2_file_operations *fops ;
   u32 device_caps ;
   struct device dev ;
   struct cdev *cdev ;
   struct v4l2_device *v4l2_dev ;
   struct device *dev_parent ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct vb2_queue *queue ;
   struct v4l2_prio_state *prio ;
   char name[32U] ;
   enum vfl_devnode_type vfl_type ;
   enum vfl_devnode_direction vfl_dir ;
   int minor ;
   u16 num ;
   unsigned long flags ;
   int index ;
   spinlock_t fh_lock ;
   struct list_head fh_list ;
   int dev_debug ;
   v4l2_std_id tvnorms ;
   void (*release)(struct video_device *) ;
   struct v4l2_ioctl_ops *ioctl_ops ;
   unsigned long valid_ioctls[3U] ;
   struct mutex *lock ;
};
#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-common.h"
struct v4l2_subdev;
#line 96 
struct v4l2_subdev_ops;
#line 335  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-common.h"
struct v4l2_priv_tun_config {
   int tuner ;
   void *priv ;
};
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-devnode.h"
struct media_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file *, char *, size_t , loff_t *) ;
   ssize_t (*write)(struct file *, char *, size_t , loff_t *) ;
   __poll_t (*poll)(struct file *, struct poll_table_struct *) ;
   long (*ioctl)(struct file *, unsigned int , unsigned long ) ;
   long (*compat_ioctl)(struct file *, unsigned int , unsigned long ) ;
   int (*open)(struct file *) ;
   int (*release)(struct file *) ;
};
#line 75  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-devnode.h"
struct media_devnode {
   struct media_device *media_dev ;
   struct media_file_operations *fops ;
   struct device dev ;
   struct cdev cdev ;
   struct device *parent ;
   int minor ;
   unsigned long flags ;
   void (*release)(struct media_devnode *) ;
};
#line 65  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-device.h"
struct media_request;
#line 65  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-device.h"
struct media_device_ops {
   int (*link_notify)(struct media_link *, u32 , unsigned int ) ;
   struct media_request *(*req_alloc)(struct media_device *) ;
   void (*req_free)(struct media_request *) ;
   int (*req_validate)(struct media_request *) ;
   void (*req_queue)(struct media_request *) ;
};
#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-device.h"
struct media_device {
   struct device *dev ;
   struct media_devnode *devnode ;
   char model[32U] ;
   char driver_name[32U] ;
   char serial[40U] ;
   char bus_info[32U] ;
   u32 hw_revision ;
   u64 topology_version ;
   u32 id ;
   struct ida entity_internal_idx ;
   int entity_internal_idx_max ;
   struct list_head entities ;
   struct list_head interfaces ;
   struct list_head pads ;
   struct list_head links ;
   struct list_head entity_notify ;
   struct mutex graph_mutex ;
   struct media_graph pm_count_walk ;
   void *source_priv ;
   int (*enable_source)(struct media_entity *, struct media_pipeline *) ;
   void (*disable_source)(struct media_entity *) ;
   struct media_device_ops *ops ;
   struct mutex req_queue_mutex ;
   atomic_t request_id ;
};
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/v4l2-mediabus.h"
struct v4l2_mbus_framefmt {
   __u32 width ;
   __u32 height ;
   __u32 code ;
   __u32 field ;
   __u32 colorspace ;
   __u16 ycbcr_enc ;
   __u16 quantization ;
   __u16 xfer_func ;
   __u16 reserved[11U] ;
};
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_format {
   __u32 which ;
   __u32 pad ;
   struct v4l2_mbus_framefmt format ;
   __u32 reserved[8U] ;
};
#line 75  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_mbus_code_enum {
   __u32 pad ;
   __u32 index ;
   __u32 code ;
   __u32 which ;
   __u32 reserved[8U] ;
};
#line 90  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_size_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u32 which ;
   __u32 reserved[8U] ;
};
#line 107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval {
   __u32 pad ;
   struct v4l2_fract interval ;
   __u32 reserved[9U] ;
};
#line 123  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 width ;
   __u32 height ;
   struct v4l2_fract interval ;
   __u32 which ;
   __u32 reserved[8U] ;
};
#line 149  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_selection {
   __u32 which ;
   __u32 pad ;
   __u32 target ;
   __u32 flags ;
   struct v4l2_rect r ;
   __u32 reserved[8U] ;
};
#line 157 
struct v4l2_async_notifier;
#line 158 
enum v4l2_async_match_type {
    V4L2_ASYNC_MATCH_CUSTOM = 0,
    V4L2_ASYNC_MATCH_DEVNAME = 1,
    V4L2_ASYNC_MATCH_I2C = 2,
    V4L2_ASYNC_MATCH_FWNODE = 3
};
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-async.h"
struct __anonstruct_i2c_19655 {
   int adapter_id ;
   unsigned short address ;
};
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-async.h"
struct __anonstruct_custom_19656 {
   bool (*match)(struct device *, struct v4l2_async_subdev *) ;
   void *priv ;
};
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-async.h"
union __anonunion_match_19654 {
   struct fwnode_handle *fwnode ;
   char *device_name ;
   struct __anonstruct_i2c_19655 i2c ;
   struct __anonstruct_custom_19656 custom ;
};
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-async.h"
struct v4l2_async_subdev {
   enum v4l2_async_match_type match_type ;
   union __anonunion_match_19654 match ;
   struct list_head list ;
   struct list_head asd_list ;
};
#line 107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-async.h"
struct v4l2_async_notifier_operations {
   int (*bound)(struct v4l2_async_notifier *, struct v4l2_subdev *, struct v4l2_async_subdev *) ;
   int (*complete)(struct v4l2_async_notifier *) ;
   void (*unbind)(struct v4l2_async_notifier *, struct v4l2_subdev *, struct v4l2_async_subdev *) ;
};
#line 129  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-async.h"
struct v4l2_async_notifier {
   struct v4l2_async_notifier_operations *ops ;
   struct v4l2_device *v4l2_dev ;
   struct v4l2_subdev *sd ;
   struct v4l2_async_notifier *parent ;
   struct list_head asd_list ;
   struct list_head waiting ;
   struct list_head done ;
   struct list_head list ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-fh.h"
struct v4l2_m2m_ctx;
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-fh.h"
struct v4l2_fh {
   struct list_head list ;
   struct video_device *vdev ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   enum v4l2_priority prio ;
   wait_queue_head_t wait ;
   struct mutex subscribe_lock ;
   struct list_head subscribed ;
   struct list_head available ;
   unsigned int navailable ;
   u32 sequence ;
   struct v4l2_m2m_ctx *m2m_ctx ;
};
#line 162 
enum v4l2_mbus_type {
    V4L2_MBUS_UNKNOWN = 0,
    V4L2_MBUS_PARALLEL = 1,
    V4L2_MBUS_BT656 = 2,
    V4L2_MBUS_CSI1 = 3,
    V4L2_MBUS_CCP2 = 4,
    V4L2_MBUS_CSI2_DPHY = 5,
    V4L2_MBUS_CSI2_CPHY = 6
};
#line 97  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-mediabus.h"
struct v4l2_mbus_config {
   enum v4l2_mbus_type type ;
   unsigned int flags ;
};
#line 184 
struct v4l2_subdev_fh;
#line 185 
struct tuner_setup;
#line 186 
struct v4l2_mbus_frame_desc;
#line 52  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_decode_vbi_line {
   u32 is_second_field ;
   u8 *p ;
   u32 line ;
   u32 type ;
};
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_io_pin_config {
   u32 flags ;
   u8 pin ;
   u8 function ;
   u8 value ;
   u8 strength ;
};
#line 188  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_core_ops {
   int (*log_status)(struct v4l2_subdev *) ;
   int (*s_io_pin_config)(struct v4l2_subdev *, size_t , struct v4l2_subdev_io_pin_config *) ;
   int (*init)(struct v4l2_subdev *, u32 ) ;
   int (*load_fw)(struct v4l2_subdev *) ;
   int (*reset)(struct v4l2_subdev *, u32 ) ;
   int (*s_gpio)(struct v4l2_subdev *, u32 ) ;
   long (*ioctl)(struct v4l2_subdev *, unsigned int , void *) ;
   long (*compat_ioctl32)(struct v4l2_subdev *, unsigned int , unsigned long ) ;
   int (*g_register)(struct v4l2_subdev *, struct v4l2_dbg_register *) ;
   int (*s_register)(struct v4l2_subdev *, struct v4l2_dbg_register *) ;
   int (*s_power)(struct v4l2_subdev *, int ) ;
   int (*interrupt_service_routine)(struct v4l2_subdev *, u32 , bool *) ;
   int (*subscribe_event)(struct v4l2_subdev *, struct v4l2_fh *, struct v4l2_event_subscription *) ;
   int (*unsubscribe_event)(struct v4l2_subdev *, struct v4l2_fh *, struct v4l2_event_subscription *) ;
};
#line 264  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_tuner_ops {
   int (*standby)(struct v4l2_subdev *) ;
   int (*s_radio)(struct v4l2_subdev *) ;
   int (*s_frequency)(struct v4l2_subdev *, struct v4l2_frequency *) ;
   int (*g_frequency)(struct v4l2_subdev *, struct v4l2_frequency *) ;
   int (*enum_freq_bands)(struct v4l2_subdev *, struct v4l2_frequency_band *) ;
   int (*g_tuner)(struct v4l2_subdev *, struct v4l2_tuner *) ;
   int (*s_tuner)(struct v4l2_subdev *, struct v4l2_tuner *) ;
   int (*g_modulator)(struct v4l2_subdev *, struct v4l2_modulator *) ;
   int (*s_modulator)(struct v4l2_subdev *, struct v4l2_modulator *) ;
   int (*s_type_addr)(struct v4l2_subdev *, struct tuner_setup *) ;
   int (*s_config)(struct v4l2_subdev *, struct v4l2_priv_tun_config *) ;
};
#line 304  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_audio_ops {
   int (*s_clock_freq)(struct v4l2_subdev *, u32 ) ;
   int (*s_i2s_clock_freq)(struct v4l2_subdev *, u32 ) ;
   int (*s_routing)(struct v4l2_subdev *, u32 , u32 , u32 ) ;
   int (*s_stream)(struct v4l2_subdev *, int ) ;
};
#line 310 
enum v4l2_mbus_frame_desc_flags {
    V4L2_MBUS_FRAME_DESC_FL_LEN_MAX = 1,
    V4L2_MBUS_FRAME_DESC_FL_BLOB = 2
};
#line 335  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_mbus_frame_desc_entry {
   enum v4l2_mbus_frame_desc_flags flags ;
   u32 pixelcode ;
   u32 length ;
};
#line 348  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_mbus_frame_desc {
   struct v4l2_mbus_frame_desc_entry entry[4U] ;
   unsigned short num_entries ;
};
#line 415  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_video_ops {
   int (*s_routing)(struct v4l2_subdev *, u32 , u32 , u32 ) ;
   int (*s_crystal_freq)(struct v4l2_subdev *, u32 , u32 ) ;
   int (*g_std)(struct v4l2_subdev *, v4l2_std_id *) ;
   int (*s_std)(struct v4l2_subdev *, v4l2_std_id ) ;
   int (*s_std_output)(struct v4l2_subdev *, v4l2_std_id ) ;
   int (*g_std_output)(struct v4l2_subdev *, v4l2_std_id *) ;
   int (*querystd)(struct v4l2_subdev *, v4l2_std_id *) ;
   int (*g_tvnorms)(struct v4l2_subdev *, v4l2_std_id *) ;
   int (*g_tvnorms_output)(struct v4l2_subdev *, v4l2_std_id *) ;
   int (*g_input_status)(struct v4l2_subdev *, u32 *) ;
   int (*s_stream)(struct v4l2_subdev *, int ) ;
   int (*g_pixelaspect)(struct v4l2_subdev *, struct v4l2_fract *) ;
   int (*g_frame_interval)(struct v4l2_subdev *, struct v4l2_subdev_frame_interval *) ;
   int (*s_frame_interval)(struct v4l2_subdev *, struct v4l2_subdev_frame_interval *) ;
   int (*s_dv_timings)(struct v4l2_subdev *, struct v4l2_dv_timings *) ;
   int (*g_dv_timings)(struct v4l2_subdev *, struct v4l2_dv_timings *) ;
   int (*query_dv_timings)(struct v4l2_subdev *, struct v4l2_dv_timings *) ;
   int (*g_mbus_config)(struct v4l2_subdev *, struct v4l2_mbus_config *) ;
   int (*s_mbus_config)(struct v4l2_subdev *, struct v4l2_mbus_config *) ;
   int (*s_rx_buffer)(struct v4l2_subdev *, void *, unsigned int *) ;
};
#line 481  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_vbi_ops {
   int (*decode_vbi_line)(struct v4l2_subdev *, struct v4l2_decode_vbi_line *) ;
   int (*s_vbi_data)(struct v4l2_subdev *, struct v4l2_sliced_vbi_data *) ;
   int (*g_vbi_data)(struct v4l2_subdev *, struct v4l2_sliced_vbi_data *) ;
   int (*g_sliced_vbi_cap)(struct v4l2_subdev *, struct v4l2_sliced_vbi_cap *) ;
   int (*s_raw_fmt)(struct v4l2_subdev *, struct v4l2_vbi_format *) ;
   int (*g_sliced_fmt)(struct v4l2_subdev *, struct v4l2_sliced_vbi_format *) ;
   int (*s_sliced_fmt)(struct v4l2_subdev *, struct v4l2_sliced_vbi_format *) ;
};
#line 501  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_sensor_ops {
   int (*g_skip_top_lines)(struct v4l2_subdev *, u32 *) ;
   int (*g_skip_frames)(struct v4l2_subdev *, u32 *) ;
};
#line 505 
enum v4l2_subdev_ir_mode {
    V4L2_SUBDEV_IR_MODE_PULSE_WIDTH = 0
};
#line 540  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_parameters {
   unsigned int bytes_per_data_element ;
   enum v4l2_subdev_ir_mode mode ;
   bool enable ;
   bool interrupt_enable ;
   bool shutdown ;
   bool modulation ;
   u32 max_pulse_width ;
   unsigned int carrier_freq ;
   unsigned int duty_cycle ;
   bool invert_level ;
   bool invert_carrier_sense ;
   u32 noise_filter_min_width ;
   unsigned int carrier_range_lower ;
   unsigned int carrier_range_upper ;
   u32 resolution ;
};
#line 599  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_ops {
   int (*rx_read)(struct v4l2_subdev *, u8 *, size_t , ssize_t *) ;
   int (*rx_g_parameters)(struct v4l2_subdev *, struct v4l2_subdev_ir_parameters *) ;
   int (*rx_s_parameters)(struct v4l2_subdev *, struct v4l2_subdev_ir_parameters *) ;
   int (*tx_write)(struct v4l2_subdev *, u8 *, size_t , ssize_t *) ;
   int (*tx_g_parameters)(struct v4l2_subdev *, struct v4l2_subdev_ir_parameters *) ;
   int (*tx_s_parameters)(struct v4l2_subdev *, struct v4l2_subdev_ir_parameters *) ;
};
#line 630  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_pad_config {
   struct v4l2_mbus_framefmt try_fmt ;
   struct v4l2_rect try_crop ;
   struct v4l2_rect try_compose ;
};
#line 674  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_pad_ops {
   int (*init_cfg)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *) ;
   int (*enum_mbus_code)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_mbus_code_enum *) ;
   int (*enum_frame_size)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_frame_size_enum *) ;
   int (*enum_frame_interval)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_frame_interval_enum *) ;
   int (*get_fmt)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_format *) ;
   int (*set_fmt)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_format *) ;
   int (*get_selection)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_selection *) ;
   int (*set_selection)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_selection *) ;
   int (*get_edid)(struct v4l2_subdev *, struct v4l2_edid *) ;
   int (*set_edid)(struct v4l2_subdev *, struct v4l2_edid *) ;
   int (*dv_timings_cap)(struct v4l2_subdev *, struct v4l2_dv_timings_cap *) ;
   int (*enum_dv_timings)(struct v4l2_subdev *, struct v4l2_enum_dv_timings *) ;
   int (*link_validate)(struct v4l2_subdev *, struct media_link *, struct v4l2_subdev_format *, struct v4l2_subdev_format *) ;
   int (*get_frame_desc)(struct v4l2_subdev *, unsigned int , struct v4l2_mbus_frame_desc *) ;
   int (*set_frame_desc)(struct v4l2_subdev *, unsigned int , struct v4l2_mbus_frame_desc *) ;
};
#line 727  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_ops {
   struct v4l2_subdev_core_ops *core ;
   struct v4l2_subdev_tuner_ops *tuner ;
   struct v4l2_subdev_audio_ops *audio ;
   struct v4l2_subdev_video_ops *video ;
   struct v4l2_subdev_vbi_ops *vbi ;
   struct v4l2_subdev_ir_ops *ir ;
   struct v4l2_subdev_sensor_ops *sensor ;
   struct v4l2_subdev_pad_ops *pad ;
};
#line 765  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_internal_ops {
   int (*registered)(struct v4l2_subdev *) ;
   void (*unregistered)(struct v4l2_subdev *) ;
   int (*open)(struct v4l2_subdev *, struct v4l2_subdev_fh *) ;
   int (*close)(struct v4l2_subdev *, struct v4l2_subdev_fh *) ;
   void (*release)(struct v4l2_subdev *) ;
};
#line 772 
struct regulator_bulk_data;
#line 797  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_platform_data {
   struct regulator_bulk_data *regulators ;
   int num_regulators ;
   void *host_priv ;
};
#line 848  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev {
   struct media_entity entity ;
   struct list_head list ;
   struct module *owner ;
   bool owner_v4l2_dev ;
   u32 flags ;
   struct v4l2_device *v4l2_dev ;
   struct v4l2_subdev_ops *ops ;
   struct v4l2_subdev_internal_ops *internal_ops ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   char name[32U] ;
   u32 grp_id ;
   void *dev_priv ;
   void *host_priv ;
   struct video_device *devnode ;
   struct device *dev ;
   struct fwnode_handle *fwnode ;
   struct list_head async_list ;
   struct v4l2_async_subdev *asd ;
   struct v4l2_async_notifier *notifier ;
   struct v4l2_async_notifier *subdev_notifier ;
   struct v4l2_subdev_platform_data *pdata ;
};
#line 906  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_fh {
   struct v4l2_fh vfh ;
   struct module *owner ;
   struct v4l2_subdev_pad_config *pad ;
};
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-device.h"
struct v4l2_device {
   struct device *dev ;
   struct media_device *mdev ;
   struct list_head subdevs ;
   spinlock_t lock ;
   char name[36U] ;
   void (*notify)(struct v4l2_subdev *, unsigned int , void *) ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct v4l2_prio_state prio ;
   struct kref ref ;
   void (*release)(struct v4l2_device *) ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 277  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ptp_clock_kernel.h"
struct dma_chan;
#line 279 
struct spi_controller;
#line 280 
struct spi_transfer;
#line 281 
struct spi_controller_mem_ops;
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spi/spi.h"
struct spi_statistics {
   spinlock_t lock ;
   unsigned long messages ;
   unsigned long transfers ;
   unsigned long errors ;
   unsigned long timedout ;
   unsigned long spi_sync ;
   unsigned long spi_sync_immediate ;
   unsigned long spi_async ;
   unsigned long long bytes ;
   unsigned long long bytes_rx ;
   unsigned long long bytes_tx ;
   unsigned long transfer_bytes_histo[17U] ;
   unsigned long transfers_split_maxsize ;
};
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spi/spi.h"
struct spi_delay {
   u16 value ;
   u8 unit ;
};
#line 157  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_controller *controller ;
   struct spi_controller *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 bits_per_word ;
   bool rt ;
   u32 mode ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32U] ;
   char *driver_override ;
   int cs_gpio ;
   struct gpio_desc *cs_gpiod ;
   struct spi_delay word_delay ;
   struct spi_statistics statistics ;
};
#line 247 
struct spi_message;
#line 452  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spi/spi.h"
struct spi_controller {
   struct device dev ;
   struct list_head list ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u32 mode_bits ;
   u32 bits_per_word_mask ;
   u32 min_speed_hz ;
   u32 max_speed_hz ;
   u16 flags ;
   bool slave ;
   size_t (*max_transfer_size)(struct spi_device *) ;
   size_t (*max_message_size)(struct spi_device *) ;
   struct mutex io_mutex ;
   spinlock_t bus_lock_spinlock ;
   struct mutex bus_lock_mutex ;
   bool bus_lock_flag ;
   int (*setup)(struct spi_device *) ;
   int (*set_cs_timing)(struct spi_device *, struct spi_delay *, struct spi_delay *, struct spi_delay *) ;
   int (*transfer)(struct spi_device *, struct spi_message *) ;
   void (*cleanup)(struct spi_device *) ;
   bool (*can_dma)(struct spi_controller *, struct spi_device *, struct spi_transfer *) ;
   bool queued ;
   struct kthread_worker kworker ;
   struct task_struct *kworker_task ;
   struct kthread_work pump_messages ;
   spinlock_t queue_lock ;
   struct list_head queue ;
   struct spi_message *cur_msg ;
   bool idling ;
   bool busy ;
   bool running ;
   bool rt ;
   bool auto_runtime_pm ;
   bool cur_msg_prepared ;
   bool cur_msg_mapped ;
   struct completion xfer_completion ;
   size_t max_dma_len ;
   int (*prepare_transfer_hardware)(struct spi_controller *) ;
   int (*transfer_one_message)(struct spi_controller *, struct spi_message *) ;
   int (*unprepare_transfer_hardware)(struct spi_controller *) ;
   int (*prepare_message)(struct spi_controller *, struct spi_message *) ;
   int (*unprepare_message)(struct spi_controller *, struct spi_message *) ;
   int (*slave_abort)(struct spi_controller *) ;
   void (*set_cs)(struct spi_device *, bool ) ;
   int (*transfer_one)(struct spi_controller *, struct spi_device *, struct spi_transfer *) ;
   void (*handle_err)(struct spi_controller *, struct spi_message *) ;
   struct spi_controller_mem_ops *mem_ops ;
   struct spi_delay cs_setup ;
   struct spi_delay cs_hold ;
   struct spi_delay cs_inactive ;
   int *cs_gpios ;
   struct gpio_desc **cs_gpiods ;
   bool use_gpio_descriptors ;
   struct spi_statistics statistics ;
   struct dma_chan *dma_tx ;
   struct dma_chan *dma_rx ;
   void *dummy_rx ;
   void *dummy_tx ;
   int (*fw_translate_cs)(struct spi_controller *, unsigned int ) ;
   bool ptp_sts_supported ;
   unsigned long irq_flags ;
};
#line 890  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spi/spi.h"
struct spi_transfer {
   void *tx_buf ;
   void *rx_buf ;
   unsigned int len ;
   dma_addr_t tx_dma ;
   dma_addr_t rx_dma ;
   struct sg_table tx_sg ;
   struct sg_table rx_sg ;
   unsigned int cs_change : 1 ;
   unsigned int tx_nbits : 3 ;
   unsigned int rx_nbits : 3 ;
   u8 bits_per_word ;
   u16 delay_usecs ;
   struct spi_delay delay ;
   struct spi_delay cs_change_delay ;
   struct spi_delay word_delay ;
   u32 speed_hz ;
   u32 effective_speed_hz ;
   unsigned int ptp_sts_word_pre ;
   unsigned int ptp_sts_word_post ;
   struct ptp_system_timestamp *ptp_sts ;
   bool timestamped_pre ;
   bool timestamped_post ;
   struct list_head transfer_list ;
};
#line 961  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned int is_dma_mapped : 1 ;
   void (*complete)(void *) ;
   void *context ;
   unsigned int frame_length ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
   struct list_head resources ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 157  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fb_fix_screeninfo {
   char id[16U] ;
   unsigned long smem_start ;
   __u32 smem_len ;
   __u32 type ;
   __u32 type_aux ;
   __u32 visual ;
   __u16 xpanstep ;
   __u16 ypanstep ;
   __u16 ywrapstep ;
   __u32 line_length ;
   unsigned long mmio_start ;
   __u32 mmio_len ;
   __u32 accel ;
   __u16 capabilities ;
   __u16 reserved[2U] ;
};
#line 188  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fb_bitfield {
   __u32 offset ;
   __u32 length ;
   __u32 msb_right ;
};
#line 241  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fb_var_screeninfo {
   __u32 xres ;
   __u32 yres ;
   __u32 xres_virtual ;
   __u32 yres_virtual ;
   __u32 xoffset ;
   __u32 yoffset ;
   __u32 bits_per_pixel ;
   __u32 grayscale ;
   struct fb_bitfield red ;
   struct fb_bitfield green ;
   struct fb_bitfield blue ;
   struct fb_bitfield transp ;
   __u32 nonstd ;
   __u32 activate ;
   __u32 height ;
   __u32 width ;
   __u32 accel_flags ;
   __u32 pixclock ;
   __u32 left_margin ;
   __u32 right_margin ;
   __u32 upper_margin ;
   __u32 lower_margin ;
   __u32 hsync_len ;
   __u32 vsync_len ;
   __u32 sync ;
   __u32 vmode ;
   __u32 rotate ;
   __u32 colorspace ;
   __u32 reserved[4U] ;
};
#line 281  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fb_cmap {
   __u32 start ;
   __u32 len ;
   __u16 *red ;
   __u16 *green ;
   __u16 *blue ;
   __u16 *transp ;
};
#line 341  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fb_copyarea {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 sx ;
   __u32 sy ;
};
#line 350  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fb_fillrect {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 color ;
   __u32 rop ;
};
#line 359  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fb_image {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 fg_color ;
   __u32 bg_color ;
   __u8 depth ;
   char *data ;
   struct fb_cmap cmap ;
};
#line 383  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fbcurpos {
   __u16 x ;
   __u16 y ;
};
#line 387  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fb_cursor {
   __u16 set ;
   __u16 enable ;
   __u16 rop ;
   char *mask ;
   struct fbcurpos hot ;
   struct fb_image image ;
};
#line 400 
enum backlight_type {
    BACKLIGHT_RAW = 1,
    BACKLIGHT_PLATFORM = 2,
    BACKLIGHT_FIRMWARE = 3,
    BACKLIGHT_TYPE_MAX = 4
};
#line 412 
enum backlight_scale {
    BACKLIGHT_SCALE_UNKNOWN = 0,
    BACKLIGHT_SCALE_LINEAR = 1,
    BACKLIGHT_SCALE_NON_LINEAR = 2
};
#line 418 
struct backlight_device;
#line 419 
struct fb_info;
#line 58  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/backlight.h"
struct backlight_ops {
   unsigned int options ;
   int (*update_status)(struct backlight_device *) ;
   int (*get_brightness)(struct backlight_device *) ;
   int (*check_fb)(struct backlight_device *, struct fb_info *) ;
};
#line 74  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/backlight.h"
struct backlight_properties {
   int brightness ;
   int max_brightness ;
   int power ;
   int fb_blank ;
   enum backlight_type type ;
   unsigned int state ;
   enum backlight_scale scale ;
};
#line 97  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/backlight.h"
struct backlight_device {
   struct backlight_properties props ;
   struct mutex update_lock ;
   struct mutex ops_lock ;
   struct backlight_ops *ops ;
   struct notifier_block fb_notif ;
   struct list_head entry ;
   struct device dev ;
   bool fb_bl_on[32U] ;
   int use_count ;
};
#line 52  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_chroma {
   __u32 redx ;
   __u32 greenx ;
   __u32 bluex ;
   __u32 whitex ;
   __u32 redy ;
   __u32 greeny ;
   __u32 bluey ;
   __u32 whitey ;
};
#line 63 
struct fb_videomode;
#line 63  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_monspecs {
   struct fb_chroma chroma ;
   struct fb_videomode *modedb ;
   __u8 manufacturer[4U] ;
   __u8 monitor[14U] ;
   __u8 serial_no[14U] ;
   __u8 ascii[14U] ;
   __u32 modedb_len ;
   __u32 model ;
   __u32 serial ;
   __u32 year ;
   __u32 week ;
   __u32 hfmin ;
   __u32 hfmax ;
   __u32 dclkmin ;
   __u32 dclkmax ;
   __u16 input ;
   __u16 dpms ;
   __u16 signal ;
   __u16 vfmin ;
   __u16 vfmax ;
   __u16 gamma ;
   __u16 gtf : 1 ;
   __u16 misc ;
   __u8 version ;
   __u8 revision ;
   __u8 max_x ;
   __u8 max_y ;
};
#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_blit_caps {
   u32 x ;
   u32 y ;
   u32 len ;
   u32 flags ;
};
#line 185  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_pixmap {
   u8 *addr ;
   u32 size ;
   u32 offset ;
   u32 buf_align ;
   u32 scan_align ;
   u32 access_align ;
   u32 flags ;
   u32 blit_x ;
   u32 blit_y ;
   void (*writeio)(struct fb_info *, void *, void *, unsigned int ) ;
   void (*readio)(struct fb_info *, void *, void *, unsigned int ) ;
};
#line 203  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_deferred_io {
   unsigned long delay ;
   struct mutex lock ;
   struct list_head pagelist ;
   void (*first_io)(struct fb_info *) ;
   void (*deferred_io)(struct fb_info *, struct list_head *) ;
};
#line 228  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_ops {
   struct module *owner ;
   int (*fb_open)(struct fb_info *, int ) ;
   int (*fb_release)(struct fb_info *, int ) ;
   ssize_t (*fb_read)(struct fb_info *, char *, size_t , loff_t *) ;
   ssize_t (*fb_write)(struct fb_info *, char *, size_t , loff_t *) ;
   int (*fb_check_var)(struct fb_var_screeninfo *, struct fb_info *) ;
   int (*fb_set_par)(struct fb_info *) ;
   int (*fb_setcolreg)(unsigned int , unsigned int , unsigned int , unsigned int , unsigned int , struct fb_info *) ;
   int (*fb_setcmap)(struct fb_cmap *, struct fb_info *) ;
   int (*fb_blank)(int , struct fb_info *) ;
   int (*fb_pan_display)(struct fb_var_screeninfo *, struct fb_info *) ;
   void (*fb_fillrect)(struct fb_info *, struct fb_fillrect *) ;
   void (*fb_copyarea)(struct fb_info *, struct fb_copyarea *) ;
   void (*fb_imageblit)(struct fb_info *, struct fb_image *) ;
   int (*fb_cursor)(struct fb_info *, struct fb_cursor *) ;
   int (*fb_sync)(struct fb_info *) ;
   int (*fb_ioctl)(struct fb_info *, unsigned int , unsigned long ) ;
   int (*fb_compat_ioctl)(struct fb_info *, unsigned int , unsigned long ) ;
   int (*fb_mmap)(struct fb_info *, struct vm_area_struct *) ;
   void (*fb_get_caps)(struct fb_info *, struct fb_blit_caps *, struct fb_var_screeninfo *) ;
   void (*fb_destroy)(struct fb_info *) ;
   int (*fb_debug_enter)(struct fb_info *) ;
   int (*fb_debug_leave)(struct fb_info *) ;
};
#line 306  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_tilemap {
   __u32 width ;
   __u32 height ;
   __u32 depth ;
   __u32 length ;
   __u8 *data ;
};
#line 315  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_tilerect {
   __u32 sx ;
   __u32 sy ;
   __u32 width ;
   __u32 height ;
   __u32 index ;
   __u32 fg ;
   __u32 bg ;
   __u32 rop ;
};
#line 326  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_tilearea {
   __u32 sx ;
   __u32 sy ;
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
};
#line 335  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_tileblit {
   __u32 sx ;
   __u32 sy ;
   __u32 width ;
   __u32 height ;
   __u32 fg ;
   __u32 bg ;
   __u32 length ;
   __u32 *indices ;
};
#line 346  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_tilecursor {
   __u32 sx ;
   __u32 sy ;
   __u32 mode ;
   __u32 shape ;
   __u32 fg ;
   __u32 bg ;
};
#line 355  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_tile_ops {
   void (*fb_settile)(struct fb_info *, struct fb_tilemap *) ;
   void (*fb_tilecopy)(struct fb_info *, struct fb_tilearea *) ;
   void (*fb_tilefill)(struct fb_info *, struct fb_tilerect *) ;
   void (*fb_tileblit)(struct fb_info *, struct fb_tileblit *) ;
   void (*fb_tilecursor)(struct fb_info *, struct fb_tilecursor *) ;
   int (*fb_get_tilemax)(struct fb_info *) ;
};
#line 499  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct aperture {
   resource_size_t base ;
   resource_size_t size ;
};
#line 497  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct apertures_struct {
   unsigned int count ;
   struct aperture ranges[0U] ;
};
#line 439  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
union __anonunion_20557 {
   char *screen_base ;
   char *screen_buffer ;
};
#line 439  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_info {
   atomic_t count ;
   int node ;
   int flags ;
   int fbcon_rotate_hint ;
   struct mutex lock ;
   struct mutex mm_lock ;
   struct fb_var_screeninfo var ;
   struct fb_fix_screeninfo fix ;
   struct fb_monspecs monspecs ;
   struct work_struct queue ;
   struct fb_pixmap pixmap ;
   struct fb_pixmap sprite ;
   struct fb_cmap cmap ;
   struct list_head modelist ;
   struct fb_videomode *mode ;
   struct backlight_device *bl_dev ;
   struct mutex bl_curve_mutex ;
   u8 bl_curve[128U] ;
   struct delayed_work deferred_work ;
   struct fb_deferred_io *fbdefio ;
   struct fb_ops *fbops ;
   struct device *device ;
   struct device *dev ;
   int class_flag ;
   struct fb_tile_ops *tileops ;
   union __anonunion_20557 __anonCompField_fb_info_73 ;
   unsigned long screen_size ;
   void *pseudo_palette ;
   u32 state ;
   void *fbcon_par ;
   void *par ;
   struct apertures_struct *apertures ;
   bool skip_vt_switch ;
};
#line 767  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_videomode {
   char *name ;
   u32 refresh ;
   u32 xres ;
   u32 yres ;
   u32 pixclock ;
   u32 left_margin ;
   u32 right_margin ;
   u32 upper_margin ;
   u32 lower_margin ;
   u32 hsync_len ;
   u32 vsync_len ;
   u32 sync ;
   u32 vmode ;
   u32 flag ;
};
#line 63  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
struct ldv_kmem_cache {
   char *name ;
   unsigned int size ;
};
#line 88  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
typedef unsigned long pthread_t;
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/thread.h"
union pthread_attr_t {
   char __size[56U] ;
   long __align ;
};
#line 30  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/thread.h"
typedef union pthread_attr_t pthread_attr_t;
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 19  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
struct emg_struct_free_irq_7 {
   int arg0 ;
   int signal_pending ;
};
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
struct emg_struct_interrupt_scenario_ixgbe_intr_18 {
   int arg0 ;
   enum irqreturn (*arg1)(int , void *) ;
   enum irqreturn (*arg2)(int , void *) ;
   void *arg3 ;
   int signal_pending ;
};
#line 32  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
struct emg_struct_character_driver_scenario_ixgbe_dbg_netdev_ops_fops_16 {
   struct file_operations *arg0 ;
   int signal_pending ;
};
#line 37  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
struct emg_struct_random_allocationless_scenario_ixgbe_get_channels_22 {
   struct net_device *arg0 ;
   int signal_pending ;
};
#line 42  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
struct emg_struct_pci_scenario_ixgbe_driver_23 {
   struct pci_driver *arg0 ;
   int signal_pending ;
};
#line 47  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
struct emg_struct_timer_scenario_8_24 {
   struct timer_list *arg0 ;
   int signal_pending ;
};
/* compiler builtin: 
   void *__builtin_memcpy(void *, void const *, unsigned long);   */
#line 22  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/common/inline_asm.h"
#line 22 
void ldv_inline_asm(void);
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/compiler.h"
__inline static void __read_once_size(void *p, void *res, int size)
{
  #line 199 
  switch (size) {
    #line 199 
    case 1: 
            #line 199 
    ;
    #line 199 
    *((__u8 *)res) = *((__u8 *)p);
    #line 199 
    break;
    #line 199 
    case 2: 
            #line 199 
    ;
    #line 199 
    *((__u16 *)res) = *((__u16 *)p);
    #line 199 
    break;
    #line 199 
    case 4: 
            #line 199 
    ;
    #line 199 
    *((__u32 *)res) = *((__u32 *)p);
    #line 199 
    break;
    #line 199 
    case 8: 
            #line 199 
    ;
    #line 199 
    *((__u64 *)res) = *((__u64 *)p);
    #line 199 
    break;
    #line 199 
    default: 
             #line 199 
    ;
    #line 200 
    ldv_inline_asm();
    #line 199 
    __builtin_memcpy(res,(void const *)p,(unsigned long)size);
    #line 200 
    ldv_inline_asm();
  }
  #line 203 
  return;
}

#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/irqflags.h"
#line 20 
unsigned long native_save_fl(void);
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/irqflags.h"
unsigned long native_save_fl(void)
{
  #line 22 
  unsigned long flags;
  #line 23 
  ldv_inline_asm();
  #line 35 
  return flags;
}

#line 38 
#line 39 
void native_restore_fl(unsigned long flags);
#line 39  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/irqflags.h"
void native_restore_fl(unsigned long flags)
{
  #line 41 
  ldv_inline_asm();
  #line 42 
  return;
}

#line 67  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val, void *addr)
{
  #line 69 
  ldv_inline_asm();
  #line 70 
  return;
}

#line 139  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static bool ixgbe_removed(void *addr)
{
  #line 141 
  return (_Bool)((long)(addr == (void *)0) != 0L);
}

#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static void ixgbe_write_reg(struct ixgbe_hw *hw, u32 reg, u32 value)
{
  #line 147 
  union __anonunion___u_720 __u;
  #line 146 
  __read_once_size((void *)(& hw->hw_addr),(void *)(& __u.__c),8);
  #line 146 
  u8 *reg_addr = (__u.__val);
  #line 148 
  if ((int)ixgbe_removed((void *)reg_addr) != 0) 
                                                 #line 149 
                                                 return;
  #line 150 
  writel(value,(void *)(reg_addr + (unsigned long)reg));
  #line 151 
  return;
}

#line 173 
#line 173 
u32 ixgbe_read_reg(struct ixgbe_hw *hw, u32 reg);
#line 49  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.h"
#line 174  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c"
s32 ixgbe_dcb_config_pfc_82598(struct ixgbe_hw *hw, u8 pfc_en);
#line 52  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.h"
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c"
s32 ixgbe_dcb_config_rx_arbiter_82598(struct ixgbe_hw *hw, u16 *refill, u16 *max, u8 *prio_type);
#line 57  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.h"
#line 78  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c"
s32 ixgbe_dcb_config_tx_desc_arbiter_82598(struct ixgbe_hw *hw, u16 *refill, u16 *max, u8 *bwg_id, u8 *prio_type);
#line 63  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.h"
#line 127  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c"
s32 ixgbe_dcb_config_tx_data_arbiter_82598(struct ixgbe_hw *hw, u16 *refill, u16 *max, u8 *bwg_id, u8 *prio_type);
#line 69  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.h"
#line 263  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c"
s32 ixgbe_dcb_hw_config_82598(struct ixgbe_hw *hw, u8 pfc_en, u16 *refill, u16 *max, u8 *bwg_id, u8 *prio_type);
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c"
s32 ixgbe_dcb_config_rx_arbiter_82598(struct ixgbe_hw *hw, u16 *refill, u16 *max, u8 *prio_type)
{
  #line 23 
  u32 reg = 0U;
  #line 24 
  u32 credit_refill = 0U;
  #line 25 
  u32 credit_max = 0U;
  #line 26 
  u8 i = (unsigned char)0U;
  #line 28 
  reg = ixgbe_read_reg(hw,20640U) | 2147483648U;
  #line 29 
  ixgbe_write_reg(hw,20640U,reg);
  #line 31 
  reg = ixgbe_read_reg(hw,15616U);
  #line 33 
  reg &= 4294967231U;
  #line 35 
  reg |= 2U;
  #line 37 
  reg |= 4U;
  #line 39 
  ixgbe_write_reg(hw,15616U,reg);
  #line 42 
  i = (unsigned char)0U;
  #line 42 
  while ((unsigned int)i <= 7U) {
    #line 43 
    credit_refill = (unsigned int)*(refill + (unsigned long)i);
    #line 44 
    credit_max = (unsigned int)*(max + (unsigned long)i);
    #line 46 
    reg = (credit_max << 12) | credit_refill;
    #line 48 
    if ((unsigned int)*(prio_type + (unsigned long)i) == 2U) 
                                                             #line 49 
                                                             reg |= 2147483648U;
    #line 51 
    ixgbe_write_reg(hw,(unsigned int)(((int)i + 3848) * 4),reg);
    #line 42 
    i = (u8)((int)i + 1);
  }
  #line 54 
  reg = ixgbe_read_reg(hw,12032U);
  #line 55 
  reg = reg;
  #line 56 
  reg |= 16U;
  #line 57 
  reg |= 64U;
  #line 58 
  ixgbe_write_reg(hw,12032U,reg);
  #line 60 
  reg = ixgbe_read_reg(hw,12288U);
  #line 62 
  reg &= 4294967293U;
  #line 63 
  ixgbe_write_reg(hw,12288U,reg);
  #line 65 
  return 0;
}

#line 78  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c"
s32 ixgbe_dcb_config_tx_desc_arbiter_82598(struct ixgbe_hw *hw, u16 *refill, u16 *max, u8 *bwg_id, u8 *prio_type)
{
  #line 84 
  u32 reg;
  #line 84 
  u32 max_credits;
  #line 85 
  u8 i;
  #line 87 
  reg = ixgbe_read_reg(hw,32576U);
  #line 90 
  reg &= 4294967231U;
  #line 91 
  reg |= 524288U;
  #line 94 
  reg |= 262144U;
  #line 96 
  ixgbe_write_reg(hw,32576U,reg);
  #line 99 
  i = (unsigned char)0U;
  #line 99 
  while ((unsigned int)i <= 7U) {
    #line 100 
    max_credits = (unsigned int)*(max + (unsigned long)i);
    #line 101 
    reg = max_credits << 12;
    #line 102 
    reg = (unsigned int)*(refill + (unsigned long)i) | reg;
    #line 103 
    reg = ((unsigned int)*(bwg_id + (unsigned long)i) << 9) | reg;
    #line 105 
    if ((unsigned int)*(prio_type + (unsigned long)i) == 1U) 
                                                             #line 106 
                                                             reg |= 1073741824U;
    #line 108 
    if ((unsigned int)*(prio_type + (unsigned long)i) == 2U) 
                                                             #line 109 
                                                             reg |= 2147483648U;
    #line 111 
    ixgbe_write_reg(hw,(unsigned int)((int)i * 64 + 24620),reg);
    #line 99 
    i = (u8)((int)i + 1);
  }
  #line 114 
  return 0;
}

#line 127  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c"
s32 ixgbe_dcb_config_tx_data_arbiter_82598(struct ixgbe_hw *hw, u16 *refill, u16 *max, u8 *bwg_id, u8 *prio_type)
{
  #line 133 
  u32 reg;
  #line 134 
  u8 i;
  #line 136 
  reg = ixgbe_read_reg(hw,52480U);
  #line 138 
  reg &= 4294967231U;
  #line 140 
  reg |= 288U;
  #line 142 
  ixgbe_write_reg(hw,52480U,reg);
  #line 145 
  i = (unsigned char)0U;
  #line 145 
  while ((unsigned int)i <= 7U) {
    #line 146 
    reg = (unsigned int)*(refill + (unsigned long)i);
    #line 147 
    reg = ((unsigned int)*(max + (unsigned long)i) << 12) | reg;
    #line 148 
    reg = ((unsigned int)*(bwg_id + (unsigned long)i) << 9) | reg;
    #line 150 
    if ((unsigned int)*(prio_type + (unsigned long)i) == 1U) 
                                                             #line 151 
                                                             reg |= 1073741824U;
    #line 153 
    if ((unsigned int)*(prio_type + (unsigned long)i) == 2U) 
                                                             #line 154 
                                                             reg |= 2147483648U;
    #line 156 
    ixgbe_write_reg(hw,(unsigned int)(((int)i + 13128) * 4),reg);
    #line 145 
    i = (u8)((int)i + 1);
  }
  #line 160 
  reg = ixgbe_read_reg(hw,32256U);
  #line 161 
  reg |= 4U;
  #line 162 
  ixgbe_write_reg(hw,32256U,reg);
  #line 164 
  return 0;
}

#line 174  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c"
s32 ixgbe_dcb_config_pfc_82598(struct ixgbe_hw *hw, u8 pfc_en)
{
  #line 176 
  u32 fcrtl;
  #line 176 
  u32 reg;
  #line 177 
  u8 i;
  #line 180 
  reg = ixgbe_read_reg(hw,15616U);
  #line 181 
  reg &= 4294967287U;
  #line 182 
  reg |= 16U;
  #line 183 
  ixgbe_write_reg(hw,15616U,reg);
  #line 186 
  reg = ixgbe_read_reg(hw,20608U);
  #line 187 
  reg &= 4294918143U;
  #line 189 
  if ((unsigned int)pfc_en != 0U) 
                                  #line 190 
                                  reg |= 16384U;
  #line 192 
  ixgbe_write_reg(hw,20608U,reg);
  #line 195 
  i = (unsigned char)0U;
  #line 195 
  while ((unsigned int)i <= 7U) {
    #line 196 
    if ((((unsigned long)pfc_en >> (int)i) & 1UL) == 0UL) {
      #line 197 
      ixgbe_write_reg(hw,(unsigned int)(((int)i + 1604) * 8),0U);
      #line 198 
      ixgbe_write_reg(hw,(unsigned int)(((int)i + 1612) * 8),0U);
      #line 199 
      goto __Cont;
    }
    #line 202 
    fcrtl = (hw->fc.low_water[(int)i] << 10) | 2147483648U;
    #line 203 
    reg = (hw->fc.high_water[(int)i] << 10) | 2147483648U;
    #line 204 
    ixgbe_write_reg(hw,(unsigned int)(((int)i + 1604) * 8),fcrtl);
    #line 205 
    ixgbe_write_reg(hw,(unsigned int)(((int)i + 1612) * 8),reg);
    #line 195 
    __Cont: 
            #line 195 
    i = (u8)((int)i + 1);
  }
  #line 209 
  reg = (unsigned int)((int)hw->fc.pause_time * 65537);
  #line 210 
  i = (unsigned char)0U;
  #line 210 
  while ((unsigned int)i <= 3U) {
    #line 211 
    ixgbe_write_reg(hw,(unsigned int)(((int)i + 3200) * 4),reg);
    #line 210 
    i = (u8)((int)i + 1);
  }
  #line 214 
  ixgbe_write_reg(hw,12960U,(unsigned int)hw->fc.pause_time / 2U);
  #line 217 
  return 0;
}

#line 227  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c"
static s32 ixgbe_dcb_config_tc_stats_82598(struct ixgbe_hw *hw)
{
  #line 229 
  u32 reg = 0U;
  #line 230 
  u8 i = (unsigned char)0U;
  #line 231 
  u8 j = (unsigned char)0U;
  #line 234 
  i = (unsigned char)0U;
  #line 234 
  j = (unsigned char)0U;
  #line 234 
  while ((unsigned int)i <= 14U && (unsigned int)j <= 7U) {
    #line 235 
    reg = ixgbe_read_reg(hw,(unsigned int)(((int)i + 2240) * 4));
    #line 236 
    reg = (unsigned int)((int)j * 16843009) | reg;
    #line 237 
    ixgbe_write_reg(hw,(unsigned int)(((int)i + 2240) * 4),reg);
    #line 238 
    reg = ixgbe_read_reg(hw,(unsigned int)(((int)i + 2241) * 4));
    #line 239 
    reg = (unsigned int)((int)j * 16843009) | reg;
    #line 240 
    ixgbe_write_reg(hw,(unsigned int)(((int)i + 2241) * 4),reg);
    #line 234 
    i = (unsigned char)((unsigned int)i + 2U);
    #line 234 
    j = (u8)((int)j + 1);
  }
  #line 243 
  i = (unsigned char)0U;
  #line 243 
  while ((unsigned int)i <= 7U) {
    {
      #line 244 
      int tmp;
      #line 246 
      int tmp_0;
      #line 244 
      if ((unsigned int)i <= 7U) 
                                 #line 244 
                                 tmp = ((int)i + 7360) * 4; else 
                                                                 #line 244 
                                                                 tmp = ((int)i + 8576) * 4;
      #line 244 
      ;
      #line 244 
      reg = ixgbe_read_reg(hw,(unsigned int)tmp);
      #line 245 
      reg = (unsigned int)((int)i * 16843009) | reg;
      #line 246 
      ;
      #line 246 
      if ((unsigned int)i <= 7U) 
                                 #line 246 
                                 tmp_0 = ((int)i + 7360) * 4; else 
                                                                   #line 246 
                                                                   tmp_0 = ((int)i + 8576) * 4;
      #line 246 
      ;
      #line 246 
      ixgbe_write_reg(hw,(unsigned int)tmp_0,reg);
    }
    #line 243 
    i = (u8)((int)i + 1);
  }
  #line 249 
  return 0;
}

#line 263  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c"
s32 ixgbe_dcb_hw_config_82598(struct ixgbe_hw *hw, u8 pfc_en, u16 *refill, u16 *max, u8 *bwg_id, u8 *prio_type)
{
  #line 266 
  ixgbe_dcb_config_rx_arbiter_82598(hw,refill,max,prio_type);
  #line 267 
  ixgbe_dcb_config_tx_desc_arbiter_82598(hw,refill,max,bwg_id,prio_type);
  #line 269 
  ixgbe_dcb_config_tx_data_arbiter_82598(hw,refill,max,bwg_id,prio_type);
  #line 271 
  ixgbe_dcb_config_pfc_82598(hw,(unsigned char)((int)pfc_en));
  #line 272 
  ixgbe_dcb_config_tc_stats_82598(hw);
  #line 274 
  return 0;
}

#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static void ixgbe_write_reg_0(struct ixgbe_hw *hw, u32 reg, u32 value)
{
  #line 147 
  union __anonunion___u_1451 __u;
  #line 146 
  __read_once_size((void *)(& hw->hw_addr),(void *)(& __u.__c),8);
  #line 146 
  u8 *reg_addr = (__u.__val);
  #line 148 
  if ((int)ixgbe_removed((void *)reg_addr) != 0) 
                                                 #line 149 
                                                 return;
  #line 150 
  writel(value,(void *)(reg_addr + (unsigned long)reg));
  #line 151 
  return;
}

#line 73  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.h"
#line 190  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c"
s32 ixgbe_dcb_config_pfc_82599(struct ixgbe_hw *hw, u8 pfc_en, u8 *prio_tc);
#line 76  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.h"
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c"
s32 ixgbe_dcb_config_rx_arbiter_82599(struct ixgbe_hw *hw, u16 *refill, u16 *max, u8 *bwg_id, u8 *prio_type, u8 *prio_tc);
#line 83  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.h"
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c"
s32 ixgbe_dcb_config_tx_desc_arbiter_82599(struct ixgbe_hw *hw, u16 *refill, u16 *max, u8 *bwg_id, u8 *prio_type);
#line 89  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.h"
#line 131  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c"
s32 ixgbe_dcb_config_tx_data_arbiter_82599(struct ixgbe_hw *hw, u16 *refill, u16 *max, u8 *bwg_id, u8 *prio_type, u8 *prio_tc);
#line 96  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.h"
#line 333  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c"
s32 ixgbe_dcb_hw_config_82599(struct ixgbe_hw *hw, u8 pfc_en, u16 *refill, u16 *max, u8 *bwg_id, u8 *prio_type, u8 *prio_tc);
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c"
s32 ixgbe_dcb_config_rx_arbiter_82599(struct ixgbe_hw *hw, u16 *refill, u16 *max, u8 *bwg_id, u8 *prio_type, u8 *prio_tc)
{
  #line 27 
  u32 reg = 0U;
  #line 28 
  u32 credit_refill = 0U;
  #line 29 
  u32 credit_max = 0U;
  #line 30 
  u8 i = (unsigned char)0U;
  #line 36 
  reg = 70U;
  #line 37 
  ixgbe_write_reg_0(hw,9264U,reg);
  #line 40 
  reg = 0U;
  #line 41 
  i = (unsigned char)0U;
  #line 41 
  while ((unsigned int)i <= 7U) {
    #line 42 
    reg = (unsigned int)((int)*(prio_tc + (unsigned long)i) << (int)i * 3) | reg;
    #line 41 
    i = (u8)((int)i + 1);
  }
  #line 43 
  ixgbe_write_reg_0(hw,12320U,reg);
  #line 46 
  i = (unsigned char)0U;
  #line 46 
  while ((unsigned int)i <= 7U) {
    #line 47 
    credit_refill = (unsigned int)*(refill + (unsigned long)i);
    #line 48 
    credit_max = (unsigned int)*(max + (unsigned long)i);
    #line 49 
    reg = (credit_max << 12) | credit_refill;
    #line 51 
    reg = ((unsigned int)*(bwg_id + (unsigned long)i) << 9) | reg;
    #line 53 
    if ((unsigned int)*(prio_type + (unsigned long)i) == 2U) 
                                                             #line 54 
                                                             reg |= 2147483648U;
    #line 56 
    ixgbe_write_reg_0(hw,(unsigned int)(((int)i + 2128) * 4),reg);
    #line 46 
    i = (u8)((int)i + 1);
  }
  #line 63 
  reg = 6U;
  #line 64 
  ixgbe_write_reg_0(hw,9264U,reg);
  #line 66 
  return 0;
}

#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c"
s32 ixgbe_dcb_config_tx_desc_arbiter_82599(struct ixgbe_hw *hw, u16 *refill, u16 *max, u8 *bwg_id, u8 *prio_type)
{
  #line 85 
  u32 reg;
  #line 85 
  u32 max_credits;
  #line 86 
  u8 i;
  #line 89 
  i = (unsigned char)0U;
  #line 89 
  while ((int)i >= 0) {
    #line 90 
    ixgbe_write_reg_0(hw,18692U,(unsigned int)i);
    #line 91 
    ixgbe_write_reg_0(hw,18696U,0U);
    #line 89 
    i = (u8)((int)i + 1);
  }
  #line 95 
  i = (unsigned char)0U;
  #line 95 
  while ((unsigned int)i <= 7U) {
    #line 96 
    max_credits = (unsigned int)*(max + (unsigned long)i);
    #line 97 
    reg = max_credits << 12;
    #line 98 
    reg = (unsigned int)*(refill + (unsigned long)i) | reg;
    #line 99 
    reg = ((unsigned int)*(bwg_id + (unsigned long)i) << 9) | reg;
    #line 101 
    if ((unsigned int)*(prio_type + (unsigned long)i) == 1U) 
                                                             #line 102 
                                                             reg |= 1073741824U;
    #line 104 
    if ((unsigned int)*(prio_type + (unsigned long)i) == 2U) 
                                                             #line 105 
                                                             reg |= 2147483648U;
    #line 107 
    ixgbe_write_reg_0(hw,(unsigned int)(((int)i + 4676) * 4),reg);
    #line 95 
    i = (u8)((int)i + 1);
  }
  #line 114 
  reg = 17U;
  #line 115 
  ixgbe_write_reg_0(hw,18688U,reg);
  #line 117 
  return 0;
}

#line 131  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c"
s32 ixgbe_dcb_config_tx_data_arbiter_82599(struct ixgbe_hw *hw, u16 *refill, u16 *max, u8 *bwg_id, u8 *prio_type, u8 *prio_tc)
{
  #line 138 
  u32 reg;
  #line 139 
  u8 i;
  #line 145 
  reg = 16777568U;
  #line 148 
  ixgbe_write_reg_0(hw,52480U,reg);
  #line 151 
  reg = 0U;
  #line 152 
  i = (unsigned char)0U;
  #line 152 
  while ((unsigned int)i <= 7U) {
    #line 153 
    reg = (unsigned int)((int)*(prio_tc + (unsigned long)i) << (int)i * 3) | reg;
    #line 152 
    i = (u8)((int)i + 1);
  }
  #line 154 
  ixgbe_write_reg_0(hw,51200U,reg);
  #line 157 
  i = (unsigned char)0U;
  #line 157 
  while ((unsigned int)i <= 7U) {
    #line 158 
    reg = (unsigned int)*(refill + (unsigned long)i);
    #line 159 
    reg = ((unsigned int)*(max + (unsigned long)i) << 12) | reg;
    #line 160 
    reg = ((unsigned int)*(bwg_id + (unsigned long)i) << 9) | reg;
    #line 162 
    if ((unsigned int)*(prio_type + (unsigned long)i) == 1U) 
                                                             #line 163 
                                                             reg |= 1073741824U;
    #line 165 
    if ((unsigned int)*(prio_type + (unsigned long)i) == 2U) 
                                                             #line 166 
                                                             reg |= 2147483648U;
    #line 168 
    ixgbe_write_reg_0(hw,(unsigned int)(((int)i + 13128) * 4),reg);
    #line 157 
    i = (u8)((int)i + 1);
  }
  #line 175 
  reg = 16777504U;
  #line 177 
  ixgbe_write_reg_0(hw,52480U,reg);
  #line 179 
  return 0;
}

#line 190  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c"
s32 ixgbe_dcb_config_pfc_82599(struct ixgbe_hw *hw, u8 pfc_en, u8 *prio_tc)
{
  #line 192 
  u32 i;
  #line 192 
  u32 j;
  #line 192 
  u32 fcrtl;
  #line 192 
  u32 reg;
  #line 193 
  u8 max_tc = (unsigned char)0U;
  #line 196 
  ixgbe_write_reg_0(hw,15616U,16U);
  #line 199 
  reg = ixgbe_read_reg(hw,17044U);
  #line 200 
  reg |= 2U;
  #line 207 
  reg &= 4294963203U;
  #line 209 
  if (hw->mac.type > (unsigned int)ixgbe_mac_82599EB) 
                                                      #line 210 
                                                      reg = (unsigned int)((int)pfc_en << 4) | reg;
  #line 212 
  if ((unsigned int)pfc_en != 0U) 
                                  #line 213 
                                  reg |= 4U;
  #line 215 
  ixgbe_write_reg_0(hw,17044U,reg);
  #line 217 
  i = 0U;
  #line 217 
  while (i <= 7U) {
    #line 218 
    if ((int)*(prio_tc + (unsigned long)i) > (int)max_tc) 
                                                          #line 219 
                                                          max_tc = *(prio_tc + (unsigned long)i);
    #line 217 
    i ++;
  }
  #line 224 
  i = 0U;
  #line 224 
  while ((unsigned int)max_tc >= i) {
    {
      #line 225 
      int enabled = 0;
      #line 227 
      j = 0U;
      #line 227 
      while (j <= 7U) {
        #line 228 
        if ((unsigned int)*(prio_tc + (unsigned long)j) == i && (((unsigned long)pfc_en >> j) & 1UL) != 0UL) {
          #line 229 
          enabled = 1;
          #line 230 
          break;
        }
        #line 227 
        j ++;
      }
      #line 234 
      if (enabled != 0) {
        #line 235 
        reg = (hw->fc.high_water[i] << 10) | 2147483648U;
        #line 236 
        fcrtl = (hw->fc.low_water[i] << 10) | 2147483648U;
        #line 237 
        ixgbe_write_reg_0(hw,(i + 3208U) * 4U,fcrtl);
      }
      else {
        #line 245 
        reg = ixgbe_read_reg(hw,(i + 3840U) * 4U) + 4294942720U;
        #line 246 
        ixgbe_write_reg_0(hw,(i + 3208U) * 4U,0U);
      }
      #line 249 
      ixgbe_write_reg_0(hw,(i + 3224U) * 4U,reg);
    }
    #line 224 
    i ++;
  }
  #line 252 
  while (i <= 7U) {
    #line 253 
    ixgbe_write_reg_0(hw,(i + 3208U) * 4U,0U);
    #line 254 
    ixgbe_write_reg_0(hw,(i + 3224U) * 4U,0U);
    #line 252 
    i ++;
  }
  #line 258 
  reg = (unsigned int)((int)hw->fc.pause_time * 65537);
  #line 259 
  i = 0U;
  #line 259 
  while (i <= 3U) {
    #line 260 
    ixgbe_write_reg_0(hw,(i + 3200U) * 4U,reg);
    #line 259 
    i ++;
  }
  #line 263 
  ixgbe_write_reg_0(hw,12960U,(unsigned int)hw->fc.pause_time / 2U);
  #line 265 
  return 0;
}

#line 275  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c"
static s32 ixgbe_dcb_config_tc_stats_82599(struct ixgbe_hw *hw)
{
  #line 277 
  u32 reg = 0U;
  #line 278 
  u8 i = (unsigned char)0U;
  #line 286 
  i = (unsigned char)0U;
  #line 286 
  while ((unsigned int)i <= 31U) {
    #line 287 
    reg = (unsigned int)((int)((unsigned int)i / 4U) * 16843009);
    #line 288 
    ixgbe_write_reg_0(hw,(unsigned int)(((int)i + 2240) * 4),reg);
    #line 286 
    i = (u8)((int)i + 1);
  }
  #line 298 
  i = (unsigned char)0U;
  #line 298 
  while ((unsigned int)i <= 31U) {
    #line 299 
    if ((unsigned int)i <= 7U) 
                               #line 300 
                               reg = 0U;
    else 
      #line 301 
      if ((unsigned int)i <= 15U) 
                                  #line 302 
                                  reg = 16843009U;
      else 
        #line 303 
        if ((unsigned int)i <= 19U) 
                                    #line 304 
                                    reg = 33686018U;
        else 
          #line 305 
          if ((unsigned int)i <= 23U) 
                                      #line 306 
                                      reg = 50529027U;
          else 
            #line 307 
            if ((unsigned int)i <= 25U) 
                                        #line 308 
                                        reg = 67372036U;
            else 
              #line 309 
              if ((unsigned int)i <= 27U) 
                                          #line 310 
                                          reg = 84215045U;
              else 
                #line 311 
                if ((unsigned int)i <= 29U) 
                                            #line 312 
                                            reg = 101058054U; else 
                                                                   #line 314 
                                                                   reg = 117901063U;
    #line 315 
    ixgbe_write_reg_0(hw,(unsigned int)(((int)i + 8576) * 4),reg);
    #line 298 
    i = (u8)((int)i + 1);
  }
  #line 318 
  return 0;
}

#line 333  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c"
s32 ixgbe_dcb_hw_config_82599(struct ixgbe_hw *hw, u8 pfc_en, u16 *refill, u16 *max, u8 *bwg_id, u8 *prio_type, u8 *prio_tc)
{
  #line 336 
  ixgbe_dcb_config_rx_arbiter_82599(hw,refill,max,bwg_id,prio_type,prio_tc);
  #line 338 
  ixgbe_dcb_config_tx_desc_arbiter_82599(hw,refill,max,bwg_id,prio_type);
  #line 340 
  ixgbe_dcb_config_tx_data_arbiter_82599(hw,refill,max,bwg_id,prio_type,prio_tc);
  #line 342 
  ixgbe_dcb_config_pfc_82599(hw,(unsigned char)((int)pfc_en),prio_tc);
  #line 343 
  ixgbe_dcb_config_tc_stats_82599(hw);
  #line 345 
  return 0;
}

/* compiler builtin: 
   unsigned short __builtin_bswap16(unsigned short);   */
/* compiler builtin: 
   unsigned int __builtin_bswap32(unsigned int);   */
/* compiler builtin: 
   void __builtin_prefetch(void const * , ...);   */
/* compiler builtin: 
   void __builtin_unreachable(void);   */
#line 4  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
#line 4 
void ldv_atomic_add(int i, atomic_t *v);
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/export.h"
#line 16 
extern struct module __this_module;
#line 220  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/compiler.h"
__inline static void __write_once_size(void *p, void *res, int size)
{
  #line 222 
  switch (size) {
    #line 223 
    case 1: 
            #line 223 
    ;
    #line 223 
    *((__u8 *)p) = *((__u8 *)res);
    #line 223 
    break;
    #line 224 
    case 2: 
            #line 224 
    ;
    #line 224 
    *((__u16 *)p) = *((__u16 *)res);
    #line 224 
    break;
    #line 225 
    case 4: 
            #line 225 
    ;
    #line 225 
    *((__u32 *)p) = *((__u32 *)res);
    #line 225 
    break;
    #line 226 
    case 8: 
            #line 226 
    ;
    #line 226 
    *((__u64 *)p) = *((__u64 *)res);
    #line 226 
    break;
    #line 227 
    default: 
             #line 227 
    ;
    #line 228 
    ldv_inline_asm();
    #line 229 
    __builtin_memcpy(p,(void const *)res,(unsigned long)size);
    #line 230 
    ldv_inline_asm();
  }
  #line 232 
  return;
}

#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kasan-checks.h"
__inline static bool kasan_check_read(void *p, unsigned int size)
{
  #line 36 
  return (_Bool)1;
}

#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/bitops.h"
__inline static void arch_clear_bit(long nr, unsigned long *addr)
{
  #line 74 
  if (0 != 0) 
              #line 76 
              ldv_inline_asm(); else 
                                     #line 79 
                                     ldv_inline_asm();
  #line 80 
  return;
}

#line 85  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/bitops.h"
__inline static void arch_clear_bit_unlock(long nr, unsigned long *addr)
{
  #line 87 
  ldv_inline_asm();
  #line 88 
  arch_clear_bit(nr,addr);
  #line 89 
  return;
}

#line 136  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/bitops.h"
__inline static bool arch_test_and_set_bit(long nr, unsigned long *addr)
{
  #line 138 
  bool c;
  #line 139 
  ldv_inline_asm();
  #line 138 
  return c;
}

#line 142  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/bitops.h"
__inline static bool arch_test_and_set_bit_lock(long nr, unsigned long *addr)
{
  #line 144 
  return arch_test_and_set_bit(nr,addr);
}

#line 204  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/bitops.h"
__inline static bool constant_test_bit(long nr, unsigned long *addr)
{
  #line 207 
  return (_Bool)(((*(addr + (unsigned long)(nr >> 6)) >> (nr & 63L)) & 1UL) != 0UL);
}

#line 210  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/bitops.h"
__inline static bool variable_test_bit(long nr, unsigned long *addr)
{
  #line 212 
  bool oldbit;
  #line 213 
  ldv_inline_asm();
  #line 219 
  return oldbit;
}

#line 283  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/bitops.h"
__inline static int ffs(int x)
{
  #line 285 
  int r;
  #line 286 
  ldv_inline_asm();
  #line 310 
  return r + 1;
}

#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/find.h"
#line 304  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static unsigned long cif_find_next_bit(unsigned long *addr, unsigned long size, unsigned long offset);
#line 70  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/find.h"
#line 70 
unsigned long find_first_zero_bit(unsigned long *, unsigned long);
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
#line 311  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void cif_set_bit(long nr, unsigned long *addr);
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
#line 318  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void cif_clear_bit(long nr, unsigned long *addr);
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
__inline static bool test_and_set_bit(long nr, unsigned long *addr)
{
  #line 70 
  kasan_check_read((void *)(addr + (unsigned long)(nr / 64L)),8U);
  #line 71 
  return arch_test_and_set_bit(nr,addr);
}

#line 108  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-non-atomic.h"
__inline static bool test_bit(long nr, unsigned long *addr)
{
  #line 111 
  int tmp_1;
  #line 110 
  kasan_check_read((void *)(addr + (unsigned long)(nr / 64L)),8U);
  #line 111 
  if (0 != 0) {
    #line 111 
    tmp_1 = (int)constant_test_bit(nr,addr) != 0;
  }
  else {
    #line 111 
    tmp_1 = (int)variable_test_bit(nr,addr) != 0;
  }
  #line 111 
  return (_Bool)(tmp_1 != 0);
}

#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-lock.h"
__inline static void clear_bit_unlock(long nr, unsigned long *addr)
{
  #line 25 
  kasan_check_read((void *)(addr + (unsigned long)(nr / 64L)),8U);
  #line 26 
  arch_clear_bit_unlock(nr,addr);
  #line 27 
  return;
}

#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-lock.h"
__inline static bool test_and_set_bit_lock(long nr, unsigned long *addr)
{
  #line 55 
  kasan_check_read((void *)(addr + (unsigned long)(nr / 64L)),8U);
  #line 56 
  return arch_test_and_set_bit_lock(nr,addr);
}

#line 171  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/printk.h"
#line 171 
int printk(char * , ...);
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/jump_label.h"
__inline static bool arch_static_branch(struct static_key *key, bool branch)
{
  #line 27 
  ldv_inline_asm();
  #line 28 
  ldv_inline_asm();
  #line 34 
  return (_Bool)0;
  #line 35 
  l_yes: 
         #line 35 
  ;
  #line 36 
  return (_Bool)1;
}

#line 198  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jump_label.h"
__inline static bool static_key_false(struct static_key *key)
{
  #line 200 
  return arch_static_branch(key,(_Bool)0);
}

#line 70  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dynamic_debug.h"
#line 70 
void __dynamic_netdev_dbg(struct _ddebug *, struct net_device *, char * , ...);
#line 487  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/printk.h"
#line 487 
void print_hex_dump(char *, char *, int, int, int, void *, size_t, bool);
#line 205  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernel.h"
#line 205 
void __cant_sleep(char *, int, int);
#line 297  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernel.h"
__inline static u32 reciprocal_scale(u32 val, u32 ep_ro)
{
  #line 299 
  return (unsigned int)((unsigned long long)val * (unsigned long long)ep_ro >> 32);
}

#line 469 
#line 469 
int sprintf(char *, char * , ...);
#line 472 
#line 472 
int snprintf(char *, size_t, char * , ...);
#line 570 
#line 570 
extern enum system_states system_state;
#line 26  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
#line 325  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void INIT_LIST_HEAD(struct list_head *list);
#line 752  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static int hlist_empty(struct hlist_head *h)
{
  #line 755 
  union __anonunion___u_1481 __u;
  #line 754 
  __read_once_size((void *)(& h->first),(void *)(& __u.__c),8);
  #line 754 
  return (__u.__val) == (struct hlist_node *)0;
}

#line 757  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void __hlist_del(struct hlist_node *n)
{
  #line 759 
  struct hlist_node *next = n->next;
  #line 760 
  struct hlist_node **pprev = n->pprev;
  {
    #line 763 
    union __anonunion___u_1483 __u = {.__val = next};
    #line 762 
    __write_once_size((void *)pprev,(void *)(& __u.__c),8);
    #line 762 
    struct hlist_node *tmp = __u.__val;
  }
  #line 763 
  if (next != (struct hlist_node *)0) 
                                      #line 764 
                                      next->pprev = pprev;
  #line 765 
  return;
}

#line 767  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void hlist_del(struct hlist_node *n)
{
  #line 769 
  __hlist_del(n);
  #line 770 
  n->next = (struct hlist_node *)(-2401263026318606080);
  #line 771 
  n->pprev = (struct hlist_node **)(-2401263026318606046);
  #line 772 
  return;
}

#line 88  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/percpu.h"
#line 88 
void __bad_percpu_size(void);
#line 309  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/percpu-defs.h"
#line 309 
void __bad_size_call_parameter(void);
#line 314  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/percpu-defs.h"
__inline static void __this_cpu_preempt_check(char *op)
{
  #line 316 
  return;
}

#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/percpu.h"
#line 19 
extern unsigned long __per_cpu_offset[8192U];
#line 89  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bug.h"
#line 89 
void __warn_printk(char * , ...);
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/page_64.h"
#line 14 
extern unsigned long page_offset_base;
#line 15 
#line 15 
extern unsigned long vmalloc_base;
#line 16 
#line 16 
extern unsigned long vmemmap_base;
#line 29 
#line 29 
unsigned long __phys_addr(unsigned long);
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/string_64.h"
#line 14 
void *memcpy(void *, void *, size_t);
#line 18 
#line 18 
void *memset(void *, int, size_t);
#line 61 
#line 61 
int memcmp(void *, void *, size_t);
#line 63 
#line 63 
char *strcpy(char *, char *);
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/string.h"
#line 29 
size_t strlcpy(char *, char *, size_t);
#line 115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bitmap.h"
#line 115 
unsigned long *bitmap_zalloc(unsigned int, gfp_t);
#line 116 
#line 116 
void bitmap_free(unsigned long *);
#line 422 
#line 1130  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void cif_bitmap_clear(unsigned long *map, unsigned int start, unsigned int nbits);
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/cmpxchg.h"
#line 13 
void __xchg_wrong_size(void);
#line 17 
#line 17 
void __xadd_wrong_size(void);
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/cmpxchg_64.h"
__inline static int arch_atomic_read(atomic_t *v)
{
  #line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/atomic.h"
  union __anonunion___u_1529 __u;
  #line 31 
  __read_once_size((void *)(& v->counter),(void *)(& __u.__c),4);
  #line 31 
  return (__u.__val);
}

#line 182  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/atomic.h"
__inline static int arch_atomic_fetch_add(int i, atomic_t *v)
{
  #line 184 
  int __ret;
  #line 184 
  __ret = i;
  #line 184 
  switch (4UL) {
    #line 184 
    case (unsigned long)1: 
                           #line 184 
    ;
    #line 185 
    ldv_inline_asm();
    #line 184 
    break;
    #line 184 
    case (unsigned long)2: 
                           #line 184 
    ;
    #line 185 
    ldv_inline_asm();
    #line 184 
    break;
    #line 184 
    case (unsigned long)4: 
                           #line 184 
    ;
    #line 185 
    ldv_inline_asm();
    #line 184 
    break;
    #line 184 
    case (unsigned long)8: 
                           #line 184 
    ;
    #line 185 
    ldv_inline_asm();
    #line 184 
    break;
    #line 184 
    default: 
             #line 184 
    ;
    #line 184 
    __xadd_wrong_size();
  }
  #line 184 
  return __ret;
}

#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/atomic-instrumented.h"
__inline static int atomic_read(atomic_t *v)
{
  #line 26 
  kasan_check_read((void *)v,4U);
  #line 27 
  return arch_atomic_read(v);
}

#line 60 
#line 353  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void atomic_add(int i, atomic_t *v);
#line 109  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/atomic-instrumented.h"
__inline static int atomic_fetch_add(int i, atomic_t *v)
{
  #line 111 
  kasan_check_read((void *)v,4U);
  #line 112 
  return arch_atomic_fetch_add(i,v);
}

#line 39  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
#line 39 
extern unsigned int nr_cpu_ids;
#line 90 
#line 90 
extern struct cpumask __cpu_possible_mask;
#line 91 
#line 91 
extern struct cpumask __cpu_online_mask;
#line 99 
#line 99 
extern atomic_t __num_online_cpus;
#line 110  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
__inline static unsigned int num_online_cpus(void)
{
  #line 112 
  return (unsigned int)atomic_read(& __num_online_cpus);
}

#line 134  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
__inline static void cpu_max_bits_warn(unsigned int cpu, unsigned int bits)
{
  #line 137 
  int __ret_warn_on = cpu >= bits;
  #line 137 
  if ((long)(__ret_warn_on != 0) != 0L) {
    #line 138 
    ldv_inline_asm();
    #line 139 
    ldv_inline_asm();
  }
  #line 137 
  long tmp = (long)(__ret_warn_on != 0);
  #line 139 
  return;
}

#line 142  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
__inline static unsigned int cpumask_check(unsigned int cpu)
{
  #line 144 
  cpu_max_bits_warn(cpu,nr_cpu_ids);
  #line 145 
  return cpu;
}

#line 228 
#line 228 
unsigned int cpumask_next(int, struct cpumask *);
#line 358  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
__inline static int cpumask_test_cpu(int cpu, struct cpumask *cpumask)
{
  #line 360 
  ;
  #line 360 
  return (int)test_bit((long)cpumask_check((unsigned int)cpu),
                 (unsigned long *)(& cpumask->bits));
}

#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/err.h"
#line 395  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void *ERR_PTR(long error);
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/err.h"
#line 402  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static long PTR_ERR(void *ptr);
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/err.h"
#line 409  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static bool IS_ERR(void *ptr);
#line 834  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/processor.h"
__inline static void prefetchw(void *x)
{
  #line 836 
  ldv_inline_asm();
  #line 837 
  return;
}

#line 173  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/cpufeature.h"
__inline static bool _static_cpu_has(u16 bit)
{
  #line 177 
  ldv_inline_asm();
  #line 178 
  ldv_inline_asm();
  #line 211 
  t_yes: 
         #line 211 
  ;
  #line 212 
  return (_Bool)1;
  #line 213 
  t_no: 
        #line 213 
  ;
  #line 214 
  return (_Bool)0;
}

#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/preempt.h"
__inline static int preempt_count(void)
{
  #line 26 
  int pfo_ret__;
  #line 26 
  switch (4UL) {
    #line 26 
    case (unsigned long)1: 
                           #line 26 
    ;
    #line 27 
    ldv_inline_asm();
    #line 26 
    break;
    #line 26 
    case (unsigned long)2: 
                           #line 26 
    ;
    #line 27 
    ldv_inline_asm();
    #line 26 
    break;
    #line 26 
    case (unsigned long)4: 
                           #line 26 
    ;
    #line 27 
    ldv_inline_asm();
    #line 26 
    break;
    #line 26 
    case (unsigned long)8: 
                           #line 26 
    ;
    #line 27 
    ldv_inline_asm();
    #line 26 
    break;
    #line 26 
    default: 
             #line 26 
    ;
    #line 26 
    __bad_percpu_size();
  }
  #line 26 
  return pfo_ret__ & 2147483647;
}

#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add(int val)
{
  #line 79 
  int tmp;
  #line 79 
  if (0 != 0 && (val == 1 || val == -1)) 
                                         #line 79 
                                         tmp = val; else 
                                                         #line 79 
                                                         tmp = 0;
  #line 79 
  int pao_ID__ = tmp;
  #line 79 
  switch (4UL) {
    #line 79 
    case (unsigned long)1: 
                           #line 79 
    ;
    #line 79 
    if (pao_ID__ == 1) 
                       #line 81 
                       ldv_inline_asm();
    else 
      #line 79 
      if (pao_ID__ == -1) 
                          #line 81 
                          ldv_inline_asm(); else 
                                                 #line 84 
                                                 ldv_inline_asm();
    #line 79 
    break;
    #line 79 
    case (unsigned long)2: 
                           #line 79 
    ;
    #line 79 
    if (pao_ID__ == 1) 
                       #line 81 
                       ldv_inline_asm();
    else 
      #line 79 
      if (pao_ID__ == -1) 
                          #line 81 
                          ldv_inline_asm(); else 
                                                 #line 84 
                                                 ldv_inline_asm();
    #line 79 
    break;
    #line 79 
    case (unsigned long)4: 
                           #line 79 
    ;
    #line 79 
    if (pao_ID__ == 1) 
                       #line 81 
                       ldv_inline_asm();
    else 
      #line 79 
      if (pao_ID__ == -1) 
                          #line 81 
                          ldv_inline_asm(); else 
                                                 #line 84 
                                                 ldv_inline_asm();
    #line 79 
    break;
    #line 79 
    case (unsigned long)8: 
                           #line 79 
    ;
    #line 79 
    if (pao_ID__ == 1) 
                       #line 81 
                       ldv_inline_asm();
    else 
      #line 79 
      if (pao_ID__ == -1) 
                          #line 81 
                          ldv_inline_asm(); else 
                                                 #line 84 
                                                 ldv_inline_asm();
    #line 79 
    break;
    #line 79 
    default: 
             #line 79 
    ;
    #line 79 
    __bad_percpu_size();
  }
  #line 82 
  return;
}

#line 82  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub(int val)
{
  #line 84 
  int tmp;
  #line 84 
  if (0 != 0 && (val == -1 || val == 1)) 
                                         #line 84 
                                         tmp = - val; else 
                                                           #line 84 
                                                           tmp = 0;
  #line 84 
  int pao_ID__ = tmp;
  #line 84 
  switch (4UL) {
    #line 84 
    case (unsigned long)1: 
                           #line 84 
    ;
    #line 84 
    if (pao_ID__ == 1) 
                       #line 86 
                       ldv_inline_asm();
    else 
      #line 84 
      if (pao_ID__ == -1) 
                          #line 86 
                          ldv_inline_asm(); else 
                                                 #line 89 
                                                 ldv_inline_asm();
    #line 84 
    break;
    #line 84 
    case (unsigned long)2: 
                           #line 84 
    ;
    #line 84 
    if (pao_ID__ == 1) 
                       #line 86 
                       ldv_inline_asm();
    else 
      #line 84 
      if (pao_ID__ == -1) 
                          #line 86 
                          ldv_inline_asm(); else 
                                                 #line 89 
                                                 ldv_inline_asm();
    #line 84 
    break;
    #line 84 
    case (unsigned long)4: 
                           #line 84 
    ;
    #line 84 
    if (pao_ID__ == 1) 
                       #line 86 
                       ldv_inline_asm();
    else 
      #line 84 
      if (pao_ID__ == -1) 
                          #line 86 
                          ldv_inline_asm(); else 
                                                 #line 89 
                                                 ldv_inline_asm();
    #line 84 
    break;
    #line 84 
    case (unsigned long)8: 
                           #line 84 
    ;
    #line 84 
    if (pao_ID__ == 1) 
                       #line 86 
                       ldv_inline_asm();
    else 
      #line 84 
      if (pao_ID__ == -1) 
                          #line 86 
                          ldv_inline_asm(); else 
                                                 #line 89 
                                                 ldv_inline_asm();
    #line 84 
    break;
    #line 84 
    default: 
             #line 84 
    ;
    #line 84 
    __bad_percpu_size();
  }
  #line 87 
  return;
}

#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bottom_half.h"
#line 8 
void __local_bh_disable_ip(unsigned long, unsigned int);
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bottom_half.h"
__inline static void local_bh_disable(void)
{
  #line 19 
  __here_0: 
            #line 19 
  ;
  #line 19 
  __local_bh_disable_ip((unsigned long)((void *)0),512U);
  #line 21 
  return;
}

#line 23 
#line 23 
void __local_bh_enable_ip(unsigned long, unsigned int);
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bottom_half.h"
__inline static void local_bh_enable(void)
{
  #line 32 
  __here_0: 
            #line 32 
  ;
  #line 32 
  __local_bh_enable_ip((unsigned long)((void *)0),512U);
  #line 34 
  return;
}

#line 302  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockdep.h"
#line 302 
void lockdep_init_map(struct lockdep_map *, char *, struct lock_class_key *, int);
#line 348 
#line 348 
void lock_acquire(struct lockdep_map *, unsigned int, int, int, int, struct lockdep_map *, unsigned long);
#line 352 
#line 352 
void lock_release(struct lockdep_map *, unsigned long);
#line 658 
#line 658 
void lockdep_rcu_suspicious(char *, int, char *);
#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock.h"
#line 95 
void __raw_spin_lock_init(raw_spinlock_t *, char *, struct lock_class_key *);
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_api_smp.h"
#line 22 
void _raw_spin_lock(raw_spinlock_t *);
#line 39 
#line 39 
void _raw_spin_unlock(raw_spinlock_t *);
#line 325  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock)
{
  #line 327 
  return & lock->__anonCompField_spinlock_25.rlock;
}

#line 336  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock.h"
static void spin_lock(spinlock_t *lock)
{
  #line 338 
  _raw_spin_lock(& lock->__anonCompField_spinlock_25.rlock);
  #line 339 
  return;
}

#line 340 
#line 737  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void cif_spin_lock__xmit_lock_of_netdev_queue(spinlock_t *lock);
#line 340  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock.h"
#line 1067  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void cif_spin_lock_fdir_perfect_lock_of_ixgbe_adapter(spinlock_t *lock);
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock.h"
static void spin_unlock(spinlock_t *lock)
{
  #line 378 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_25.rlock);
  #line 379 
  return;
}

#line 380 
#line 777  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void cif_spin_unlock__xmit_lock_of_netdev_queue(spinlock_t *lock);
#line 380  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock.h"
#line 1076  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void cif_spin_unlock_fdir_perfect_lock_of_ixgbe_adapter(spinlock_t *lock);
#line 40 
#line 40 
void ldv_spin_model_lock(char *);
#line 41 
#line 41 
void ldv_spin_model_unlock(char *);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/err.h"
#line 23 
bool ldv_is_err(void *ptr);
#line 25 
#line 25 
void *ldv_err_ptr(long error);
#line 26 
#line 26 
long ldv_ptr_err(void *ptr);
#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/bitmap.h"
#line 21 
void ldv_set_bit(long nr, unsigned long *addr);
#line 22 
#line 22 
void ldv_clear_bit(long nr, unsigned long *addr);
#line 25 
#line 25 
void ldv_bitmap_clear(unsigned long *map, unsigned int start, int nbits);
#line 22  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/find_bit.h"
#line 22 
unsigned long ldv_find_next_bit(unsigned long *addr, unsigned long size, unsigned long offset);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/list.h"
#line 23 
void ldv_init_list_head(struct list_head *list);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
#line 23 
void *ldv_kzalloc(size_t size, gfp_t flags);
#line 25 
#line 25 
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags);
#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/vmalloc.h"
#line 21 
void *ldv_vmalloc(unsigned long size);
#line 23 
#line 23 
void ldv_vfree(void *addr);
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmdebug.h"
#line 12 
void dump_page(struct page *, char *);
#line 410  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/nodemask.h"
#line 410 
extern nodemask_t node_states[5U];
#line 413  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/nodemask.h"
__inline static int node_state(int node, enum node_states state)
{
  #line 415 
  return (int)test_bit((long)node,
               (unsigned long *)(& node_states[(unsigned int)state].bits));
}

#line 40  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcupdate.h"
#line 40 
void synchronize_rcu(void);
#line 57  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcupdate.h"
__inline static void __rcu_read_lock(void)
{
  #line 59 
  __preempt_count_add(1);
  #line 60 
  ldv_inline_asm();
  #line 62 
  return;
}

#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcupdate.h"
__inline static void __rcu_read_unlock(void)
{
  #line 66 
  ldv_inline_asm();
  #line 64 
  __preempt_count_sub(1);
  #line 66 
  return;
}

#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcutree.h"
#line 56 
bool rcu_is_watching(void);
#line 206  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcupdate.h"
__inline static void rcu_lock_acquire(struct lockdep_map *map)
{
  #line 208 
  __here_0: 
            #line 208 
  ;
  #line 208 
  ;
  #line 208 
  lock_acquire(map,0U,0,2,0,(struct lockdep_map *)0,(unsigned long)((void *)0));
  #line 210 
  return;
}

#line 211  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcupdate.h"
__inline static void rcu_lock_release(struct lockdep_map *map)
{
  #line 213 
  __here_0: 
            #line 213 
  ;
  #line 213 
  ;
  #line 213 
  lock_release(map,(unsigned long)((void *)0));
  #line 215 
  return;
}

#line 216 
#line 216 
extern struct lockdep_map rcu_lock_map;
#line 220 
#line 220 
int debug_lockdep_rcu_enabled(void);
#line 223 
#line 223 
int rcu_read_lock_sched_held(void);
#line 613  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcupdate.h"
__inline static void rcu_read_lock(void)
{
  #line 615 
  __rcu_read_lock();
  #line 617 
  rcu_lock_acquire(& rcu_lock_map);
  {
    #line 618 
    bool __warned;
    #line 618 
    if (debug_lockdep_rcu_enabled() != 0) 
      #line 618 
      if (! __warned) {
        #line 618 
        if (! rcu_is_watching()) {
          #line 618 
          __warned = (_Bool)1;
          #line 618 
          lockdep_rcu_suspicious((char *)"./include/linux/rcupdate.h",618,(char *)"rcu_read_lock() used illegally while idle");
        }
      }
  }
  #line 621 
  return;
}

#line 665  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcupdate.h"
__inline static void rcu_read_unlock(void)
{
  {
    #line 667 
    bool __warned;
    #line 667 
    if (debug_lockdep_rcu_enabled() != 0) 
      #line 667 
      if (! __warned) {
        #line 667 
        if (! rcu_is_watching()) {
          #line 667 
          __warned = (_Bool)1;
          #line 667 
          lockdep_rcu_suspicious((char *)"./include/linux/rcupdate.h",667,(char *)"rcu_read_unlock() used illegally while idle");
        }
      }
  }
  #line 670 
  __rcu_read_unlock();
  #line 671 
  rcu_lock_release(& rcu_lock_map);
  #line 672 
  return;
}

#line 81  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jiffies.h"
#line 81 
extern unsigned long jiffies;
#line 90  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
#line 90 
void init_timer_key(struct timer_list *, void (*)(struct timer_list *), unsigned int, char *, struct lock_class_key *);
#line 173 
#line 1085  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static int cif_mod_timer(struct timer_list *timer, unsigned long expires);
#line 188  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
#line 1093  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static int cif_del_timer_sync(struct timer_list *timer);
#line 207  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/workqueue.h"
#line 207 
void __init_work(struct work_struct *, int);
#line 407 
#line 407 
struct workqueue_struct *alloc_workqueue(char *, unsigned int, int , ...);
#line 436 
#line 436 
void destroy_workqueue(struct workqueue_struct *);
#line 462 
#line 462 
bool cancel_work_sync(struct work_struct *);
#line 496 
#line 495  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static bool cif_queue_work(struct workqueue_struct *wq, struct work_struct *work);
#line 554  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/workqueue.h"
#line 883  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static bool cif_schedule_work(struct work_struct *work);
#line 192  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/page-flags.h"
__inline static int PagePoisoned(struct page *page)
{
  #line 194 
  return page->flags == 18446744073709551615UL;
}

#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/io.h"
__inline static unsigned int readl(void *addr)
{
  #line 59 
  unsigned int ret;
  #line 60 
  ldv_inline_asm();
  #line 59 
  return ret;
}

#line 206 
#line 206 
void *ioremap(resource_size_t, unsigned long);
#line 209 
#line 209 
void iounmap(void *);
#line 104  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/vmalloc.h"
#line 1108  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void *cif_vmalloc(unsigned long size);
#line 107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/vmalloc.h"
#line 1101  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void *cif_vmalloc_node(unsigned long size, int node);
#line 130  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/vmalloc.h"
#line 1115  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void cif_vfree(void *addr);
#line 86  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/topology.h"
__inline static int numa_node_id(void)
{
  #line 88 
  int pscr_ret__;
  {
    #line 88 
    void *__vpp_verify = (void *)0;
    #line 88 
    void *tmp = __vpp_verify;
  }
  #line 88 
  switch (4UL) {
    #line 88 
    int pfo_ret___1;
    #line 88 
    int pfo_ret___2;
    #line 88 
    int pfo_ret__;
    #line 88 
    int pfo_ret___0;
    #line 88 
    case (unsigned long)1: 
                           #line 88 
    ;
    #line 88 
    switch (4UL) {
      #line 88 
      case (unsigned long)1: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      case (unsigned long)2: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      case (unsigned long)4: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      case (unsigned long)8: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      default: 
               #line 88 
      ;
      #line 88 
      __bad_percpu_size();
    }
    #line 88 
    pscr_ret__ = pfo_ret__;
    #line 88 
    break;
    #line 88 
    case (unsigned long)2: 
                           #line 88 
    ;
    #line 88 
    switch (4UL) {
      #line 88 
      case (unsigned long)1: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      case (unsigned long)2: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      case (unsigned long)4: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      case (unsigned long)8: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      default: 
               #line 88 
      ;
      #line 88 
      __bad_percpu_size();
    }
    #line 88 
    pscr_ret__ = pfo_ret___0;
    #line 88 
    break;
    #line 88 
    case (unsigned long)4: 
                           #line 88 
    ;
    #line 88 
    switch (4UL) {
      #line 88 
      case (unsigned long)1: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      case (unsigned long)2: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      case (unsigned long)4: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      case (unsigned long)8: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      default: 
               #line 88 
      ;
      #line 88 
      __bad_percpu_size();
    }
    #line 88 
    pscr_ret__ = pfo_ret___1;
    #line 88 
    break;
    #line 88 
    case (unsigned long)8: 
                           #line 88 
    ;
    #line 88 
    switch (4UL) {
      #line 88 
      case (unsigned long)1: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      case (unsigned long)2: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      case (unsigned long)4: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      case (unsigned long)8: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      default: 
               #line 88 
      ;
      #line 88 
      __bad_percpu_size();
    }
    #line 88 
    pscr_ret__ = pfo_ret___2;
    #line 88 
    break;
    #line 88 
    default: 
             #line 88 
    ;
    #line 88 
    __bad_size_call_parameter();
    #line 88 
    break;
  }
  #line 88 
  return pscr_ret__;
}

#line 177  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/topology.h"
__inline static int numa_mem_id(void)
{
  #line 179 
  return numa_node_id();
}

#line 490  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/gfp.h"
#line 490 
struct page *__alloc_pages_nodemask(gfp_t, unsigned int, int, nodemask_t *);
#line 494  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/gfp.h"
__inline static struct page *__alloc_pages(gfp_t gfp_mask, unsigned int order, int preferred_nid)
{
  #line 496 
  return __alloc_pages_nodemask(gfp_mask,order,preferred_nid,(nodemask_t *)0);
}

#line 504  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/gfp.h"
__inline static struct page *__alloc_pages_node(int nid, gfp_t gfp_mask, unsigned int order)
{
  #line 506 
  if ((long)((unsigned int)nid > 1023U) != 0L) {
    #line 507 
    ldv_inline_asm();
    #line 508 
    ldv_inline_asm();
    #line 509 
    ldv_inline_asm();
    #line 506 
    ;
  }
  {
    #line 507 
    int tmp_0;
    #line 507 
    if ((gfp_mask & 2097152U) != 0U) {
      #line 507 
      if (node_state(nid,(enum node_states)N_ONLINE) == 0) 
                                                           #line 507 
                                                           tmp_0 = 1; else 
                                                                    #line 507 
                                                                    tmp_0 = 0;
    }
    else 
         #line 507 
         tmp_0 = 0;
    #line 507 
    int __ret_warn_on = tmp_0;
    #line 507 
    if ((long)(__ret_warn_on != 0) != 0L) {
      #line 508 
      ldv_inline_asm();
      #line 509 
      ldv_inline_asm();
    }
    #line 507 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  #line 509 
  return __alloc_pages(gfp_mask,order,nid);
}

#line 517  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/gfp.h"
__inline static struct page *alloc_pages_node(int nid, gfp_t gfp_mask, unsigned int order)
{
  #line 520 
  if (nid == -1) 
                 #line 521 
                 nid = numa_mem_id();
  #line 523 
  return __alloc_pages_node(nid,gfp_mask,order);
}

#line 566 
#line 566 
void __free_pages(struct page *, unsigned int);
#line 572 
#line 572 
void __page_frag_cache_drain(struct page *, unsigned int);
#line 114  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/refcount.h"
#line 114 
void refcount_warn_saturate(refcount_t *, enum refcount_saturation_type);
#line 186  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/refcount.h"
__inline static void refcount_add(int i, refcount_t *r)
{
  #line 188 
  int old = atomic_fetch_add(i,& r->refs);
  #line 190 
  if ((long)(old == 0) != 0L) 
                              #line 191 
                              refcount_warn_saturate(r,(enum refcount_saturation_type)REFCOUNT_ADD_UAF);
  else 
    #line 192 
    if ((long)(old < 0) != 0L || (long)(old + i < 0) != 0L) 
                                                            #line 193 
                                                            refcount_warn_saturate(r,(enum refcount_saturation_type)REFCOUNT_ADD_OVF);
  #line 194 
  return;
}

#line 226  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/refcount.h"
__inline static void refcount_inc(refcount_t *r)
{
  #line 228 
  refcount_add(1,r);
  #line 229 
  return;
}

#line 89  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kobject.h"
__inline static char *kobject_name(struct kobject *kobj)
{
  #line 91 
  return kobj->name;
}

#line 441  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
#line 441 
int driver_for_each_device(struct device_driver *, struct device *, void *, int (*)(struct device *, void *));
#line 108  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pm_wakeup.h"
#line 108 
int device_set_wakeup_enable(struct device *, bool);
#line 1370  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
__inline static char *dev_name(struct device *dev)
{
  #line 1373 
  if (dev->init_name != (char *)0) 
                                   #line 1374 
                                   return dev->init_name;
  #line 1376 
  return kobject_name(& dev->kobj);
}

#line 1383  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
__inline static int dev_to_node(struct device *dev)
{
  #line 1385 
  return dev->numa_node;
}

#line 1387  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
__inline static void set_dev_node(struct device *dev, int node)
{
  #line 1389 
  dev->numa_node = node;
  #line 1390 
  return;
}

#line 1417  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
__inline static void *dev_get_drvdata(struct device *dev)
{
  #line 1419 
  return dev->driver_data;
}

#line 1422  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev, void *data)
{
  #line 1424 
  dev->driver_data = data;
  #line 1425 
  return;
}

#line 1680 
#line 1680 
char *dev_driver_string(struct device *);
#line 1712 
#line 1712 
void _dev_err(struct device *, char * , ...);
#line 1714 
#line 1714 
void _dev_warn(struct device *, char * , ...);
#line 1718 
#line 1718 
void _dev_info(struct device *, char * , ...);
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/hardirq.h"
#line 12 
void synchronize_irq(unsigned int);
#line 162  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/interrupt.h"
#line 1051  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static int cif_request_irq(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char *name, void *dev);
#line 189  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/interrupt.h"
#line 1059  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void *cif_free_irq(unsigned int ldv_func_arg1, void *ldv_func_arg2);
#line 352  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/interrupt.h"
#line 352 
int irq_set_affinity_hint(unsigned int, struct cpumask *);
#line 189  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 189 
void kfree(void *);
#line 607 
#line 655  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void *kcalloc(size_t n, size_t size, gfp_t flags);
#line 668  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 676  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void *kzalloc(size_t size, gfp_t flags);
#line 488  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
__inline static int pci_channel_offline(struct pci_dev *pdev)
{
  #line 490 
  return pdev->error_state != 1U;
}

#line 1019 
#line 1019 
void pci_dev_put(struct pci_dev *);
#line 1042 
#line 1042 
int pci_find_ext_capability(struct pci_dev *, int);
#line 1048 
#line 1048 
struct pci_dev *pci_get_device(unsigned int, unsigned int, struct pci_dev *);
#line 1084 
#line 1084 
int pci_read_config_word(struct pci_dev *, int, u16 *);
#line 1085 
#line 1085 
int pci_read_config_dword(struct pci_dev *, int, u32 *);
#line 1087 
#line 1087 
int pci_write_config_word(struct pci_dev *, int, u16);
#line 1090 
#line 1090 
int pcie_capability_read_word(struct pci_dev *, int, u16 *);
#line 1133 
#line 1133 
int pci_enable_device_mem(struct pci_dev *);
#line 1157 
#line 1157 
void pci_disable_device(struct pci_dev *);
#line 1160 
#line 1160 
void pci_set_master(struct pci_dev *);
#line 1185 
#line 1185 
void pcie_print_link_status(struct pci_dev *);
#line 1187 
#line 1187 
int pcie_flr(struct pci_dev *);
#line 1202 
#line 1202 
int pci_select_bars(struct pci_dev *, unsigned long);
#line 1219 
#line 1219 
int pci_save_state(struct pci_dev *);
#line 1220 
#line 1220 
void pci_restore_state(struct pci_dev *);
#line 1233 
#line 1233 
int pci_set_power_state(struct pci_dev *, pci_power_t);
#line 1238 
#line 1238 
int pci_wake_from_d3(struct pci_dev *, bool);
#line 1239 
#line 1239 
int pci_prepare_to_sleep(struct pci_dev *);
#line 1286 
#line 1286 
int pci_request_selected_regions(struct pci_dev *, int, char *);
#line 1288 
#line 1288 
void pci_release_selected_regions(struct pci_dev *, int);
#line 1346 
#line 1161  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static int cif___pci_register_driver(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char *mod_name);
#line 1352  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
#line 1169  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void cif_pci_unregister_driver(struct pci_driver *dev);
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/page_ref.h"
#line 11 
extern struct tracepoint __tracepoint_page_ref_mod;
#line 30 
#line 30 
void __page_ref_mod(struct page *, int);
#line 65  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/page_ref.h"
__inline static int page_ref_count(struct page *page)
{
  #line 67 
  return atomic_read(& page->_refcount);
}

#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/page_ref.h"
__inline static void page_ref_add(struct page *page, int nr)
{
  #line 93 
  atomic_add(nr,& page->_refcount);
  #line 94 
  if ((int)static_key_false(& __tracepoint_page_ref_mod.key) != 0) 
                                                                   #line 95 
                                                                   __page_ref_mod(page,nr);
  #line 96 
  return;
}

#line 628  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm.h"
__inline static bool is_vmalloc_addr(void *x)
{
  #line 633 
  int tmp_1;
  #line 631 
  unsigned long addr = (unsigned long)x;
  #line 633 
  if (addr >= vmalloc_base) {
    #line 633 
    unsigned long tmp_0;
    #line 633 
    if ((int)_static_cpu_has((unsigned short)528) != 0) 
                                                        #line 633 
                                                        tmp_0 = 14073748835532800UL; else 
                                                                    #line 633 
                                                                    tmp_0 = 35184372088832UL;
    #line 633 
    ;
    #line 633 
    if ((tmp_0 + vmalloc_base) + 18446744073709551615UL > addr) 
                                                                #line 633 
                                                                tmp_1 = 1; else 
                                                                    #line 633 
                                                                    tmp_1 = 0;
  }
  else 
       #line 633 
       tmp_1 = 0;
  #line 633 
  return (_Bool)(tmp_1 != 0);
}

#line 1083  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm.h"
__inline static int page_to_nid(struct page *page)
{
  #line 1085 
  struct page *p = page;
  {
    #line 1087 
    if ((long)(PagePoisoned(p) != 0) != 0L) {
      #line 1087 
      dump_page(p,(char *)"VM_BUG_ON_PAGE(");
      #line 1088 
      ldv_inline_asm();
      #line 1089 
      ldv_inline_asm();
      #line 1090 
      ldv_inline_asm();
      #line 1087 
      ;
    }
  }
  #line 1087 
  ;
  #line 1087 
  return (int)(p->flags >> 54UL) & 1023;
}

#line 1299  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm.h"
__inline static void *lowmem_page_address(struct page *page)
{
  #line 1301 
  return (void *)((unsigned long)((unsigned long long)((page - (struct page *)vmemmap_base) / 64L) << 12) + page_offset_base);
}

#line 1369  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm.h"
__inline static bool page_is_pfmemalloc(struct page *page)
{
  #line 1375 
  return (_Bool)(page->__anonCompField_page_43.__anonCompField___anonunion_132_31.index == 18446744073709551615UL);
}

#line 1433  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
#line 1433 
void pci_disable_msix(struct pci_dev *);
#line 1626  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
__inline static int pci_request_mem_regions(struct pci_dev *pdev, char *name)
{
  #line 1628 
  ;
  #line 1628 
  ;
  #line 1628 
  return pci_request_selected_regions(pdev,pci_select_bars(pdev,512UL),name);
}

#line 1633  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
__inline static void pci_release_mem_regions(struct pci_dev *pdev)
{
  #line 1635 
  ;
  #line 1635 
  pci_release_selected_regions(pdev,pci_select_bars(pdev,512UL));
  #line 1637 
  return;
}

#line 1833  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev)
{
  #line 1835 
  return dev_get_drvdata(& pdev->dev);
}

#line 1838  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev, void *data)
{
  #line 1840 
  dev_set_drvdata(& pdev->dev,data);
  #line 1841 
  return;
}

#line 1843  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
__inline static char *pci_name(struct pci_dev *pdev)
{
  #line 1845 
  return dev_name(& pdev->dev);
}

#line 2035 
#line 2035 
int pci_sriov_set_totalvfs(struct pci_dev *, u16);
#line 2092  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
__inline static int pci_pcie_cap(struct pci_dev *dev)
{
  #line 2094 
  return (int)dev->pcie_cap;
}

#line 2103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
__inline static bool pci_is_pcie(struct pci_dev *dev)
{
  #line 2105 
  return (_Bool)(pci_pcie_cap(dev) != 0);
}

#line 2112  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
__inline static u16 pcie_caps_reg(struct pci_dev *dev)
{
  #line 2114 
  return dev->pcie_flags_reg;
}

#line 2121  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
__inline static int pci_pcie_type(struct pci_dev *dev)
{
  #line 2123 
  return ((int)pcie_caps_reg(dev) >> 4) & 15;
}

#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-debug.h"
#line 21 
void debug_dma_map_single(struct device *, void *, unsigned long);
#line 24 
#line 24 
void debug_dma_map_page(struct device *, struct page *, size_t, size_t, int, dma_addr_t);
#line 28 
#line 28 
void debug_dma_mapping_error(struct device *, dma_addr_t);
#line 30 
#line 30 
void debug_dma_unmap_page(struct device *, dma_addr_t, size_t, int);
#line 52 
#line 52 
void debug_dma_sync_single_for_cpu(struct device *, dma_addr_t, size_t, int);
#line 56 
#line 56 
void debug_dma_sync_single_for_device(struct device *, dma_addr_t, size_t, int);
#line 143  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction)
{
  #line 146 
  return (unsigned int)dma_direction <= 2U;
}

#line 191  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static bool dma_is_direct(struct dma_map_ops *ops)
{
  #line 193 
  return (_Bool)((long)(ops == (struct dma_map_ops *)0) != 0L);
}

#line 200 
#line 200 
dma_addr_t dma_direct_map_page(struct device *, struct page *, unsigned long, size_t, enum dma_data_direction, unsigned long);
#line 210 
#line 210 
void dma_direct_sync_single_for_device(struct device *, dma_addr_t, size_t, enum dma_data_direction);
#line 228 
#line 228 
void dma_direct_unmap_page(struct device *, dma_addr_t, size_t, enum dma_data_direction, unsigned long);
#line 232 
#line 232 
void dma_direct_sync_single_for_cpu(struct device *, dma_addr_t, size_t, enum dma_data_direction);
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/dma-mapping.h"
#line 19 
extern struct dma_map_ops *dma_ops;
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_arch_dma_ops(struct bus_type *bus)
{
  #line 23 
  return dma_ops;
}

#line 261  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev)
{
  #line 263 
  if (dev->dma_ops != (struct dma_map_ops *)0) 
                                               #line 264 
                                               return dev->dma_ops;
  #line 265 
  return get_arch_dma_ops(dev->bus);
}

#line 274  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static dma_addr_t dma_map_page_attrs(struct device *dev, struct page *page, size_t offset, size_t size, enum dma_data_direction dir, unsigned long attrs)
{
  #line 279 
  dma_addr_t addr;
  #line 278 
  struct dma_map_ops *ops = get_dma_ops(dev);
  #line 281 
  if ((long)(valid_dma_direction((int)dir) == 0) != 0L) {
    #line 282 
    ldv_inline_asm();
    #line 283 
    ldv_inline_asm();
    #line 284 
    ldv_inline_asm();
    #line 281 
    ;
  }
  #line 282 
  if ((int)dma_is_direct(ops) != 0) 
                                    #line 283 
                                    addr = dma_direct_map_page(dev,page,offset,size,dir,attrs); else 
                                                                    #line 285 
                                                                    addr = (*(ops->map_page))(dev,page,offset,size,dir,attrs);
  #line 286 
  debug_dma_map_page(dev,page,offset,size,(int)dir,addr);
  #line 288 
  return addr;
}

#line 291  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static void dma_unmap_page_attrs(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir, unsigned long attrs)
{
  #line 294 
  struct dma_map_ops *ops = get_dma_ops(dev);
  #line 296 
  if ((long)(valid_dma_direction((int)dir) == 0) != 0L) {
    #line 297 
    ldv_inline_asm();
    #line 298 
    ldv_inline_asm();
    #line 299 
    ldv_inline_asm();
    #line 296 
    ;
  }
  #line 297 
  if ((int)dma_is_direct(ops) != 0) 
                                    #line 298 
                                    dma_direct_unmap_page(dev,addr,size,dir,attrs);
  else 
    #line 299 
    if (ops->unmap_page != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction , unsigned long ))0) 
      #line 300 
      (*(ops->unmap_page))(dev,addr,size,dir,attrs);
  #line 301 
  debug_dma_unmap_page(dev,addr,size,(int)dir);
  #line 302 
  return;
}

#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static void dma_sync_single_for_cpu(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
{
  #line 380 
  struct dma_map_ops *ops = get_dma_ops(dev);
  #line 382 
  if ((long)(valid_dma_direction((int)dir) == 0) != 0L) {
    #line 383 
    ldv_inline_asm();
    #line 384 
    ldv_inline_asm();
    #line 385 
    ldv_inline_asm();
    #line 382 
    ;
  }
  #line 383 
  if ((int)dma_is_direct(ops) != 0) 
                                    #line 384 
                                    dma_direct_sync_single_for_cpu(dev,addr,size,dir);
  else 
    #line 385 
    if (ops->sync_single_for_cpu != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction ))0) 
      #line 386 
      (*(ops->sync_single_for_cpu))(dev,addr,size,dir);
  #line 387 
  debug_dma_sync_single_for_cpu(dev,addr,size,(int)dir);
  #line 388 
  return;
}

#line 390  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static void dma_sync_single_for_device(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
{
  #line 394 
  struct dma_map_ops *ops = get_dma_ops(dev);
  #line 396 
  if ((long)(valid_dma_direction((int)dir) == 0) != 0L) {
    #line 397 
    ldv_inline_asm();
    #line 398 
    ldv_inline_asm();
    #line 399 
    ldv_inline_asm();
    #line 396 
    ;
  }
  #line 397 
  if ((int)dma_is_direct(ops) != 0) 
                                    #line 398 
                                    dma_direct_sync_single_for_device(dev,addr,size,dir);
  else 
    #line 399 
    if (ops->sync_single_for_device != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction ))0) 
      #line 400 
      (*(ops->sync_single_for_device))(dev,addr,size,dir);
  #line 401 
  debug_dma_sync_single_for_device(dev,addr,size,(int)dir);
  #line 402 
  return;
}

#line 433  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
  #line 435 
  debug_dma_mapping_error(dev,dma_addr);
  #line 437 
  if (dma_addr == 18446744073709551615ULL) 
                                           #line 438 
                                           return -12;
  #line 439 
  return 0;
}

#line 442 
#line 442 
void *dma_alloc_attrs(struct device *, size_t, dma_addr_t *, gfp_t, unsigned long);
#line 444 
#line 444 
void dma_free_attrs(struct device *, size_t, void *, dma_addr_t, unsigned long);
#line 460 
#line 460 
int dma_set_mask(struct device *, u64);
#line 461 
#line 461 
int dma_set_coherent_mask(struct device *, u64);
#line 580  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev, void *ptr, size_t size, enum dma_data_direction dir, unsigned long attrs)
{
  #line 584 
  int __ret_warn_once;
  {
    #line 584 
    bool __warned;
    #line 584 
    __ret_warn_once = (int)is_vmalloc_addr(ptr) != 0;
    #line 584 
    if ((long)(__ret_warn_once != 0) != 0L && (long)(! __warned) != 0L) {
      #line 584 
      __warned = (_Bool)1;
      {
        #line 584 
        int __ret_warn_on = 1;
        #line 584 
        if ((long)(__ret_warn_on != 0) != 0L) {
          #line 584 
          __warn_printk((char *)"%s %s: ",dev_driver_string(dev),dev_name(dev));
          #line 585 
          ldv_inline_asm();
          #line 586 
          ldv_inline_asm();
        }
        #line 584 
        long tmp_2 = (long)(__ret_warn_on != 0);
      }
    }
    }
  #line 584 
  if ((long)((long)(__ret_warn_once != 0)) != 0L) 
                                                  #line 586 
                                                  return 18446744073709551615ULL;
  #line 587 
  debug_dma_map_single(dev,ptr,size);
  #line 588 
  ;
  #line 588 
  ;
  #line 588 
  ;
  #line 588 
  ;
  #line 588 
  ;
  #line 588 
  ;
  #line 588 
  return dma_map_page_attrs(dev,
                           (struct page *)((__phys_addr((unsigned long)ptr) >> 12) + vmemmap_base),
                           (unsigned long)ptr & 4095UL,size,dir,attrs);
}

#line 592  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static void dma_unmap_single_attrs(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir, unsigned long attrs)
{
  #line 595 
  dma_unmap_page_attrs(dev,addr,size,dir,attrs);
  #line 596 
  return;
}

#line 598  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static void dma_sync_single_range_for_cpu(struct device *dev, dma_addr_t addr, unsigned long offset, size_t size, enum dma_data_direction dir)
{
  #line 602 
  dma_sync_single_for_cpu(dev,addr + (unsigned long long)offset,size,dir);
  #line 603 
  return;
}

#line 605  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static void dma_sync_single_range_for_device(struct device *dev, dma_addr_t addr, unsigned long offset, size_t size, enum dma_data_direction dir)
{
  #line 609 
  dma_sync_single_for_device(dev,addr + (unsigned long long)offset,size,dir);
  #line 610 
  return;
}

#line 641  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static void *dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *dma_handle, gfp_t gfp)
{
  #line 645 
  return dma_alloc_attrs(dev,size,dma_handle,gfp,
                      (unsigned long)(gfp >> 5) & 256UL);
}

#line 649  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static void dma_free_coherent(struct device *dev, size_t size, void *cpu_addr, dma_addr_t dma_handle)
{
  #line 652 
  dma_free_attrs(dev,size,cpu_addr,dma_handle,0UL);
  #line 653 
  return;
}

#line 669  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static int dma_set_mask_and_coherent(struct device *dev, u64 mask)
{
  #line 671 
  int rc = dma_set_mask(dev,mask);
  #line 672 
  if (rc == 0) 
               #line 673 
               dma_set_coherent_mask(dev,mask);
  #line 674 
  return rc;
}

#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/delay.h"
#line 11 
void __const_udelay(unsigned long);
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/delay.h"
#line 59 
void msleep(unsigned int);
#line 61 
#line 61 
void usleep_range(unsigned long, unsigned long);
#line 73  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dynamic_queue_limits.h"
__inline static void dql_queued(struct dql *dql, unsigned int count)
{
  #line 75 
  if ((long)(count > 268435455U) != 0L) {
    #line 76 
    ldv_inline_asm();
    #line 77 
    ldv_inline_asm();
    #line 78 
    ldv_inline_asm();
    #line 75 
    ;
  }
  #line 77 
  dql->last_obj_cnt = count;
  #line 78 
  ldv_inline_asm();
  #line 86 
  dql->num_queued += count;
  #line 87 
  return;
}

#line 90  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dynamic_queue_limits.h"
__inline static int dql_avail(struct dql *dql)
{
  #line 93 
  union __anonunion___u_1919 __u;
  #line 93 
  union __anonunion___u_1921 __u_0;
  #line 92 
  unsigned int tmp;
  #line 92 
  __read_once_size((void *)(& dql->adj_limit),(void *)(& __u.__c),4);
  #line 92 
  tmp = __u.__val;
  #line 92 
  __read_once_size((void *)(& dql->num_queued),(void *)(& __u_0.__c),4);
  #line 92 
  return (int)(tmp - (__u_0.__val));
}

#line 96 
#line 96 
void dql_completed(struct dql *, unsigned int);
#line 99 
#line 99 
void dql_reset(struct dql *);
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/checksum_64.h"
__inline static __sum16 csum_fold(__wsum sum)
{
  #line 25 
  ldv_inline_asm();
  #line 30 
  return (unsigned short)(~ sum >> 16);
}

#line 130 
#line 130 
__wsum csum_partial(void *, int, __wsum);
#line 183  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/checksum_64.h"
__inline static unsigned int add32_with_carry(unsigned int a, unsigned int b)
{
  #line 185 
  ldv_inline_asm();
  #line 189 
  return a;
}

#line 193  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/checksum_64.h"
__inline static __wsum csum_add(__wsum csum, __wsum addend)
{
  #line 195 
  return add32_with_carry(csum,addend);
}

#line 107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/checksum.h"
__inline static __wsum csum_unfold(__sum16 n)
{
  #line 109 
  return (unsigned int)n;
}

#line 119  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/checksum.h"
__inline static void csum_replace_by_diff(__sum16 *sum, __wsum diff)
{
  #line 121 
  ;
  #line 121 
  *sum = csum_fold(csum_add(diff,~ csum_unfold((unsigned short)((int)*sum))));
  #line 122 
  return;
}

#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/clock.h"
#line 15 
unsigned long long sched_clock(void);
#line 325  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static unsigned int skb_frag_size(skb_frag_t *frag)
{
  #line 327 
  return frag->bv_len;
}

#line 355  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void skb_frag_size_sub(skb_frag_t *frag, int delta)
{
  #line 357 
  frag->bv_len -= (unsigned int)delta;
  #line 358 
  return;
}

#line 1023 
#line 1023 
void consume_skb(struct sk_buff *);
#line 1035 
#line 1035 
struct sk_buff *build_skb(void *, unsigned int);
#line 1116 
#line 1116 
int pskb_expand_head(struct sk_buff *, int, int, gfp_t);
#line 1126 
#line 1126 
int __skb_pad(struct sk_buff *, int, bool);
#line 1214  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void __skb_set_hash(struct sk_buff *skb, __u32 hash, bool is_sw, bool is_l4)
{
  #line 1216 
  skb->l4_hash = (unsigned char)is_l4;
  #line 1217 
  skb->sw_hash = (unsigned char)is_sw;
  #line 1218 
  skb->hash = hash;
  #line 1219 
  return;
}

#line 1222  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void skb_set_hash(struct sk_buff *skb, __u32 hash, enum pkt_hash_types type)
{
  #line 1225 
  __skb_set_hash(skb,hash,(_Bool)0,(_Bool)(type == (unsigned int)PKT_HASH_TYPE_L4));
  #line 1226 
  return;
}

#line 1234 
#line 1234 
void __skb_get_hash(struct sk_buff *);
#line 1337  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static __u32 skb_get_hash(struct sk_buff *skb)
{
  #line 1339 
  if ((unsigned int)skb->l4_hash == 0U && (unsigned int)skb->sw_hash == 0U) 
    #line 1340 
    __skb_get_hash(skb);
  #line 1342 
  return skb->hash;
}

#line 1381  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static unsigned char *skb_end_pointer(struct sk_buff *skb)
{
  #line 1383 
  return skb->head + (unsigned long)skb->end;
}

#line 1580  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static struct sk_buff *skb_get(struct sk_buff *skb)
{
  #line 1582 
  refcount_inc(& skb->users);
  #line 1583 
  return skb;
}

#line 1621  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static int skb_header_cloned(struct sk_buff *skb)
{
  #line 1623 
  int dataref;
  #line 1625 
  if ((unsigned int)skb->cloned == 0U) 
                                       #line 1626 
                                       return 0;
  #line 1628 
  dataref = atomic_read(& ((struct skb_shared_info *)skb_end_pointer(skb))->dataref);
  #line 1629 
  dataref = (dataref & 65535) - (dataref >> 16);
  #line 1630 
  return dataref != 1;
}

#line 2065  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static bool skb_is_nonlinear(struct sk_buff *skb)
{
  #line 2067 
  return (_Bool)(skb->data_len != 0U);
}

#line 2070  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static unsigned int skb_headlen(struct sk_buff *skb)
{
  #line 2072 
  return skb->len - skb->data_len;
}

#line 2142 
#line 2142 
void skb_add_rx_frag(struct sk_buff *, int, struct page *, int, int, unsigned int);
#line 2151  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static unsigned char *skb_tail_pointer(struct sk_buff *skb)
{
  #line 2153 
  return skb->head + (unsigned long)skb->tail;
}

#line 2190  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void *__skb_put(struct sk_buff *skb, unsigned int len)
{
  #line 2192 
  void *tmp = skb_tail_pointer(skb);
  #line 2193 
  if ((long)((int)skb_is_nonlinear(skb) != 0) != 0L) {
    #line 2194 
    ldv_inline_asm();
    #line 2195 
    ldv_inline_asm();
    #line 2196 
    ldv_inline_asm();
    #line 2193 
    ;
  }
  #line 2194 
  skb->tail += len;
  #line 2195 
  skb->len += len;
  #line 2196 
  return tmp;
}

#line 2266 
#line 2266 
void *__pskb_pull_tail(struct sk_buff *, int);
#line 2282  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static bool pskb_may_pull(struct sk_buff *skb, unsigned int len)
{
  #line 2284 
  ;
  #line 2284 
  if ((long)(skb_headlen(skb) >= len) != 0L) 
                                             #line 2285 
                                             return (_Bool)1;
  #line 2286 
  if ((long)(skb->len < len) != 0L) 
                                    #line 2287 
                                    return (_Bool)0;
  #line 2288 
  ;
  #line 2288 
  ;
  #line 2288 
  return (_Bool)(__pskb_pull_tail(skb,(int)(len - skb_headlen(skb))) != (void *)0);
}

#line 2299  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static unsigned int skb_headroom(struct sk_buff *skb)
{
  #line 2301 
  return (unsigned int)(skb->data - skb->head);
}

#line 2338  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void skb_reserve(struct sk_buff *skb, int len)
{
  #line 2340 
  skb->data += (unsigned long)len;
  #line 2341 
  skb->tail += (unsigned int)len;
  #line 2342 
  return;
}

#line 2420  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static unsigned char *skb_inner_network_header(struct sk_buff *skb)
{
  #line 2422 
  return skb->head + (unsigned long)skb->inner_network_header;
}

#line 2458  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static unsigned char *skb_transport_header(struct sk_buff *skb)
{
  #line 2460 
  return skb->head + (unsigned long)skb->transport_header;
}

#line 2475  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static unsigned char *skb_network_header(struct sk_buff *skb)
{
  #line 2477 
  return skb->head + (unsigned long)skb->network_header;
}

#line 2549  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static int skb_checksum_start_offset(struct sk_buff *skb)
{
  #line 2551 
  ;
  #line 2551 
  return (int)((unsigned int)skb->__anonCompField_sk_buff_95.__anonCompField___anonunion_528_94.csum_start - skb_headroom(skb));
}

#line 2554  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static unsigned char *skb_checksum_start(struct sk_buff *skb)
{
  #line 2556 
  return skb->head + (unsigned long)skb->__anonCompField_sk_buff_95.__anonCompField___anonunion_528_94.csum_start;
}

#line 2574  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static int skb_network_offset(struct sk_buff *skb)
{
  #line 2576 
  ;
  #line 2576 
  return (int)(skb_network_header(skb) - skb->data);
}

#line 2820 
#line 2820 
struct sk_buff *__napi_alloc_skb(struct napi_struct *, unsigned int, gfp_t);
#line 2822  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static struct sk_buff *napi_alloc_skb(struct napi_struct *napi, unsigned int length)
{
  #line 2825 
  return __napi_alloc_skb(napi,length,2592U);
}

#line 2827 
#line 2827 
void napi_consume_skb(struct sk_buff *, int);
#line 2841  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static struct page *__dev_alloc_pages(gfp_t gfp_mask, unsigned int order)
{
  #line 2852 
  gfp_mask |= 393216U;
  #line 2854 
  return alloc_pages_node(-1,gfp_mask,order);
}

#line 2857  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static struct page *dev_alloc_pages(unsigned int order)
{
  #line 2859 
  return __dev_alloc_pages(10784U,order);
}

#line 2896  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static unsigned int skb_frag_off(skb_frag_t *frag)
{
  #line 2898 
  return frag->bv_offset;
}

#line 2906  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void skb_frag_off_add(skb_frag_t *frag, int delta)
{
  #line 2908 
  frag->bv_offset += (unsigned int)delta;
  #line 2909 
  return;
}

#line 2938  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static struct page *skb_frag_page(skb_frag_t *frag)
{
  #line 2940 
  return frag->bv_page;
}

#line 2996  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void *skb_frag_address(skb_frag_t *frag)
{
  #line 2998 
  return lowmem_page_address(skb_frag_page(frag)) + (unsigned long)skb_frag_off(frag);
}

#line 3067  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static dma_addr_t skb_frag_dma_map(struct device *dev, skb_frag_t *frag, size_t offset, size_t size, enum dma_data_direction dir)
{
  #line 3072 
  ;
  #line 3072 
  ;
  #line 3072 
  ;
  #line 3072 
  ;
  #line 3072 
  return dma_map_page_attrs(dev,skb_frag_page(frag),
                           (unsigned long)skb_frag_off(frag) + offset,size,
                           dir,0UL);
}

#line 3111  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static int __skb_cow(struct sk_buff *skb, unsigned int headroom, int cloned)
{
  #line 3114 
  int delta = 0;
  #line 3116 
  ;
  #line 3116 
  if (skb_headroom(skb) < headroom) {
    #line 3117 
    delta = (int)(headroom - skb_headroom(skb));
  }
  #line 3119 
  if (delta != 0 || cloned != 0) {
    #line 3120 
    return pskb_expand_head(skb,(delta + 63) & -64,0,2592U);
  }
  #line 3122 
  return 0;
}

#line 3152  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static int skb_cow_head(struct sk_buff *skb, unsigned int headroom)
{
  #line 3154 
  ;
  #line 3154 
  ;
  #line 3154 
  return __skb_cow(skb,headroom,skb_header_cloned(skb));
}

#line 3186  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static int __skb_put_padto(struct sk_buff *skb, unsigned int len, bool free_on_error)
{
  #line 3189 
  unsigned int size = skb->len;
  #line 3191 
  if ((long)(size < len) != 0L) {
    #line 3192 
    len -= size;
    #line 3193 
    if (__skb_pad(skb,(int)len,(_Bool)((bool)((int)free_on_error) != 0)) != 0) 
      #line 3194 
      return -12;
    #line 3195 
    __skb_put(skb,len);
  }
  #line 3197 
  return 0;
}

#line 3210  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static int skb_put_padto(struct sk_buff *skb, unsigned int len)
{
  #line 3212 
  return __skb_put_padto(skb,len,(_Bool)1);
}

#line 3507 
#line 3507 
int skb_copy_bits(struct sk_buff *, int, void *, int);
#line 3563  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void *__skb_header_pointer(struct sk_buff *skb, int offset, int len, void *data, int hlen, void *buffer)
{
  #line 3566 
  if (hlen - offset >= len) 
                            #line 3567 
                            return data + (unsigned long)offset;
  #line 3569 
  if (skb == (struct sk_buff *)0) 
                                  #line 3571 
                                  return (void *)0;
  else {
    #line 3569 
    if (skb_copy_bits(skb,offset,buffer,len) < 0) 
                                                  #line 3571 
                                                  return (void *)0;
  }
  #line 3573 
  return buffer;
}

#line 3577  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void *skb_header_pointer(struct sk_buff *skb, int offset, int len, void *buffer)
{
  #line 3579 
  ;
  #line 3579 
  ;
  #line 3579 
  ;
  #line 3579 
  ;
  #line 3579 
  ;
  #line 3579 
  return __skb_header_pointer(skb,offset,len,(void *)skb->data,
                             (int)skb_headlen(skb),buffer);
}

#line 3615  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void skb_copy_to_linear_data(struct sk_buff *skb, void *from, unsigned int len)
{
  #line 3619 
  memcpy((void *)skb->data,from,(unsigned long)len);
  #line 3620 
  return;
}

#line 3753  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void skb_metadata_set(struct sk_buff *skb, u8 meta_len)
{
  #line 3755 
  ((struct skb_shared_info *)skb_end_pointer(skb))->meta_len = meta_len;
  #line 3756 
  return;
}

#line 3767 
#line 3767 
void skb_clone_tx_timestamp(struct sk_buff *);
#line 3813 
#line 3813 
void skb_tstamp_tx(struct sk_buff *, struct skb_shared_hwtstamps *);
#line 3828  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void skb_tx_timestamp(struct sk_buff *skb)
{
  #line 3830 
  skb_clone_tx_timestamp(skb);
  #line 3831 
  ;
  #line 3831 
  if (((int)((struct skb_shared_info *)skb_end_pointer(skb))->tx_flags & 2) != 0) 
    #line 3832 
    skb_tstamp_tx(skb,(struct skb_shared_hwtstamps *)0);
  #line 3833 
  return;
}

#line 4149  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static bool skb_ext_exist(struct sk_buff *skb, enum skb_ext_id id)
{
  #line 4151 
  return (_Bool)(((int)skb->active_extensions & (1 << (unsigned int)id)) != 0);
}

#line 4160  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void *skb_ext_find(struct sk_buff *skb, enum skb_ext_id id)
{
  #line 4162 
  if ((int)skb_ext_exist(skb,id) != 0) {
    #line 4163 
    struct skb_ext *ext = skb->extensions;
    #line 4165 
    return (void *)ext + (unsigned long)((int)ext->offset[(unsigned int)id] << 3);
  }
  #line 4168 
  return (void *)0;
}

#line 4254  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static int secpath_exists(struct sk_buff *skb)
{
  #line 4257 
  return (int)skb_ext_exist(skb,(enum skb_ext_id)SKB_EXT_SEC_PATH);
}

#line 4277  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static u16 skb_get_queue_mapping(struct sk_buff *skb)
{
  #line 4279 
  return skb->queue_mapping;
}

#line 4287  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void skb_record_rx_queue(struct sk_buff *skb, u16 rx_queue)
{
  #line 4289 
  skb->queue_mapping = (unsigned short)((unsigned int)rx_queue + 1U);
  #line 4290 
  return;
}

#line 4292  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static u16 skb_get_rx_queue(struct sk_buff *skb)
{
  #line 4294 
  return (unsigned short)((unsigned int)skb->queue_mapping + 65535U);
}

#line 4297  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static bool skb_rx_queue_recorded(struct sk_buff *skb)
{
  #line 4299 
  return (_Bool)((unsigned int)skb->queue_mapping != 0U);
}

#line 4312  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static struct sec_path *skb_sec_path(struct sk_buff *skb)
{
  #line 4315 
  return (struct sec_path *)skb_ext_find(skb,(enum skb_ext_id)SKB_EXT_SEC_PATH);
}

#line 4390  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static bool skb_is_gso(struct sk_buff *skb)
{
  #line 4392 
  ;
  #line 4392 
  return (_Bool)((unsigned int)((struct skb_shared_info *)skb_end_pointer(skb))->gso_size != 0U);
}

#line 4467  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void skb_checksum_none_assert(struct sk_buff *skb)
{
  #line 4469 
  return;
}

#line 929  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
__inline static __u64 ethtool_get_flow_spec_ring(__u64 ring_cookie)
{
  #line 931 
  return ring_cookie & 4294967295ULL;
}

#line 934  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
__inline static __u64 ethtool_get_flow_spec_ring_vf(__u64 ring_cookie)
{
  #line 936 
  return (ring_cookie >> 32) & 255ULL;
}

#line 115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/u64_stats_sync.h"
__inline static void u64_stats_init(struct u64_stats_sync *syncp)
{
  #line 117 
  return;
}

#line 158  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/u64_stats_sync.h"
__inline static unsigned int __u64_stats_fetch_begin(struct u64_stats_sync *syncp)
{
  #line 163 
  return 0U;
}

#line 175  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/u64_stats_sync.h"
__inline static bool __u64_stats_fetch_retry(struct u64_stats_sync *syncp, unsigned int start)
{
  #line 181 
  return (_Bool)0;
}

#line 200  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/u64_stats_sync.h"
__inline static unsigned int u64_stats_fetch_begin_irq(struct u64_stats_sync *syncp)
{
  #line 205 
  return __u64_stats_fetch_begin(syncp);
}

#line 208  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/u64_stats_sync.h"
__inline static bool u64_stats_fetch_retry_irq(struct u64_stats_sync *syncp, unsigned int start)
{
  #line 214 
  return __u64_stats_fetch_retry(syncp,start);
}

#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/dcbnl.h"
#line 24 
u8 dcb_ieee_getapp_mask(struct net_device *, struct dcb_app *);
#line 818  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
#line 818 
void bpf_prog_put(struct bpf_prog *);
#line 94  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp.h"
#line 94 
struct xdp_frame *xdp_convert_zc_to_xdp_frame(struct xdp_buff *);
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp.h"
__inline static struct xdp_frame *convert_to_xdp_frame(struct xdp_buff *xdp)
{
  #line 100 
  struct xdp_frame *xdp_frame;
  #line 101 
  int metasize;
  #line 102 
  int headroom;
  #line 104 
  if ((xdp->rxq)->mem.type == 3U) {
    #line 105 
    return xdp_convert_zc_to_xdp_frame(xdp);
  }
  #line 108 
  headroom = (int)(xdp->data - xdp->data_hard_start);
  #line 109 
  metasize = (int)(xdp->data - xdp->data_meta);
  #line 110 
  if (0 > metasize) 
                    #line 110 
                    metasize = 0; else 
                                       #line 110 
                                       metasize = metasize;
  #line 111 
  if ((long)((unsigned int)(headroom - metasize) <= 31U) != 0L) 
                                                                #line 112 
                                                                return (struct xdp_frame *)0;
  #line 115 
  xdp_frame = (struct xdp_frame *)xdp->data_hard_start;
  #line 117 
  xdp_frame->data = xdp->data;
  #line 118 
  xdp_frame->len = (unsigned short)(xdp->data_end - xdp->data);
  #line 119 
  xdp_frame->headroom = (unsigned short)((unsigned int)((unsigned short)headroom) + 65504U);
  #line 120 
  xdp_frame->metasize = (unsigned short)metasize;
  #line 123 
  xdp_frame->mem = (xdp->rxq)->mem;
  #line 125 
  return xdp_frame;
}

#line 128 
#line 128 
void xdp_return_frame(struct xdp_frame *);
#line 129 
#line 129 
void xdp_return_frame_rx_napi(struct xdp_frame *);
#line 147 
#line 147 
int xdp_rxq_info_reg(struct xdp_rxq_info *, struct net_device *, u32);
#line 149 
#line 149 
void xdp_rxq_info_unreg(struct xdp_rxq_info *);
#line 152 
#line 152 
int xdp_rxq_info_reg_mem_model(struct xdp_rxq_info *, enum xdp_mem_type, void *);
#line 154 
#line 154 
void xdp_rxq_info_unreg_mem_model(struct xdp_rxq_info *);
#line 424  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
#line 424 
void __napi_schedule_irqoff(struct napi_struct *);
#line 431 
#line 431 
bool napi_schedule_prep(struct napi_struct *);
#line 452  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void napi_schedule_irqoff(struct napi_struct *n)
{
  #line 454 
  if ((int)napi_schedule_prep(n) != 0) 
                                       #line 455 
                                       __napi_schedule_irqoff(n);
  #line 456 
  return;
}

#line 468 
#line 468 
bool napi_complete_done(struct napi_struct *, int);
#line 503 
#line 503 
void napi_disable(struct napi_struct *);
#line 512  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void napi_enable(struct napi_struct *n)
{
  #line 514 
  int tmp_0;
  #line 514 
  if (test_bit(0L,& n->state)) 
                               #line 514 
                               tmp_0 = 0; else 
                                               #line 514 
                                               tmp_0 = 1;
  #line 514 
  if ((long)tmp_0 != 0L) {
    #line 515 
    ldv_inline_asm();
    #line 516 
    ldv_inline_asm();
    #line 517 
    ldv_inline_asm();
    #line 514 
    ;
  }
  #line 516 
  cif_clear_bit(0L,& n->state);
  #line 517 
  cif_clear_bit(3L,& n->state);
  #line 518 
  return;
}

#line 528  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void napi_synchronize(struct napi_struct *n)
{
  #line 531 
  while (1) {
    #line 531 
    if (! ((int)test_bit(0L,& n->state) != 0)) 
                                               #line 531 
                                               break;
    #line 532 
    msleep(1U);
  }
  #line 536 
  return;
}

#line 2094  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static int netdev_get_prio_tc_map(struct net_device *dev, u32 prio)
{
  #line 2096 
  return (int)dev->prio_tc_map[prio & 15U];
}

#line 2100  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static int netdev_set_prio_tc_map(struct net_device *dev, u8 prio, u8 tc)
{
  #line 2102 
  if ((int)tc >= (int)dev->num_tc) 
                                   #line 2103 
                                   return -22;
  #line 2105 
  dev->prio_tc_map[(int)prio & 15] = (unsigned char)((unsigned int)tc & 15U);
  #line 2106 
  return 0;
}

#line 2110 
#line 2110 
void netdev_reset_tc(struct net_device *);
#line 2112 
#line 2112 
int netdev_set_num_tc(struct net_device *, u8);
#line 2115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static int netdev_get_num_tc(struct net_device *dev)
{
  #line 2117 
  return (int)dev->num_tc;
}

#line 2120 
#line 2120 
void netdev_unbind_sb_channel(struct net_device *, struct net_device *);
#line 2122 
#line 2122 
int netdev_bind_sb_channel_queue(struct net_device *, struct net_device *, u8, u16, u16);
#line 2125 
#line 2125 
int netdev_set_sb_channel(struct net_device *, u16);
#line 2132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static struct netdev_queue *netdev_get_tx_queue(struct net_device *dev, unsigned int index)
{
  #line 2135 
  return dev->_tx + (unsigned long)index;
}

#line 2156 
#line 2156 
u16 netdev_pick_tx(struct net_device *, struct sk_buff *, struct net_device *);
#line 2203  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void *netdev_priv(struct net_device *dev)
{
  #line 2205 
  return (void *)((char *)dev + 3328UL);
}

#line 2579 
#line 2579 
int call_netdevice_notifiers(unsigned long, struct net_device *);
#line 2679 
#line 1153  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void cif_free_netdev(struct net_device *dev);
#line 3094  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
#line 3094 
void netif_schedule_queue(struct netdev_queue *);
#line 3104  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_tx_start_queue(struct netdev_queue *dev_queue)
{
  #line 3106 
  cif_clear_bit(0L,& dev_queue->state);
  #line 3107 
  return;
}

#line 3130 
#line 3130 
void netif_tx_wake_queue(struct netdev_queue *);
#line 3144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_tx_wake_all_queues(struct net_device *dev)
{
  #line 3146 
  unsigned int i;
  #line 3148 
  i = 0U;
  #line 3148 
  while (dev->num_tx_queues > i) {
    {
      #line 3149 
      struct netdev_queue *txq = netdev_get_tx_queue(dev,i);
      #line 3150 
      netif_tx_wake_queue(txq);
    }
    #line 3148 
    i ++;
  }
  #line 3152 
  return;
}

#line 3154  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_tx_stop_queue(struct netdev_queue *dev_queue)
{
  #line 3156 
  cif_set_bit(0L,& dev_queue->state);
  #line 3157 
  return;
}

#line 3171 
#line 3171 
void netif_tx_stop_all_queues(struct net_device *);
#line 3174  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static bool netif_tx_queue_stopped(struct netdev_queue *dev_queue)
{
  #line 3176 
  return test_bit(0L,& dev_queue->state);
}

#line 3190  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static bool netif_xmit_stopped(struct netdev_queue *dev_queue)
{
  #line 3192 
  return (_Bool)((dev_queue->state & 3UL) != 0UL);
}

#line 3235  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netdev_tx_sent_queue(struct netdev_queue *dev_queue, unsigned int bytes)
{
  #line 3239 
  dql_queued(& dev_queue->dql,bytes);
  #line 3241 
  if ((long)(dql_avail(& dev_queue->dql) >= 0) != 0L) 
                                                      #line 3242 
                                                      return;
  #line 3244 
  cif_set_bit(1L,& dev_queue->state);
  #line 3245 
  ldv_inline_asm();
  #line 3254 
  if ((long)(dql_avail(& dev_queue->dql) >= 0) != 0L) 
                                                      #line 3255 
                                                      cif_clear_bit(1L,& dev_queue->state);
  #line 3256 
  return;
}

#line 3301  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netdev_tx_completed_queue(struct netdev_queue *dev_queue, unsigned int pkts, unsigned int bytes)
{
  #line 3305 
  if ((long)(bytes == 0U) != 0L) 
                                 #line 3306 
                                 return;
  #line 3308 
  dql_completed(& dev_queue->dql,bytes);
  #line 3309 
  ldv_inline_asm();
  #line 3317 
  if ((long)(dql_avail(& dev_queue->dql) < 0) != 0L) 
                                                     #line 3318 
                                                     return;
  #line 3320 
  if ((int)test_and_set_bit(1L,& dev_queue->state) != 0) 
                                                         #line 3321 
                                                         netif_schedule_queue(dev_queue);
  #line 3322 
  return;
}

#line 3341  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netdev_tx_reset_queue(struct netdev_queue *q)
{
  #line 3344 
  cif_clear_bit(1L,& q->state);
  #line 3345 
  dql_reset(& q->dql);
  #line 3346 
  return;
}

#line 3387  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static bool netif_running(struct net_device *dev)
{
  #line 3389 
  return test_bit(0L,& dev->state);
}

#line 3406  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_start_subqueue(struct net_device *dev, u16 queue_index)
{
  #line 3408 
  struct netdev_queue *txq = netdev_get_tx_queue(dev,(unsigned int)queue_index);
  #line 3410 
  netif_tx_start_queue(txq);
  #line 3411 
  return;
}

#line 3420  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_stop_subqueue(struct net_device *dev, u16 queue_index)
{
  #line 3422 
  struct netdev_queue *txq = netdev_get_tx_queue(dev,(unsigned int)queue_index);
  #line 3423 
  netif_tx_stop_queue(txq);
  #line 3424 
  return;
}

#line 3433  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static bool __netif_subqueue_stopped(struct net_device *dev, u16 queue_index)
{
  #line 3436 
  struct netdev_queue *txq = netdev_get_tx_queue(dev,(unsigned int)queue_index);
  #line 3438 
  return netif_tx_queue_stopped(txq);
}

#line 3454  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_wake_subqueue(struct net_device *dev, u16 queue_index)
{
  #line 3456 
  struct netdev_queue *txq = netdev_get_tx_queue(dev,(unsigned int)queue_index);
  #line 3458 
  netif_tx_wake_queue(txq);
  #line 3459 
  return;
}

#line 3462 
#line 3462 
int netif_set_xps_queue(struct net_device *, struct cpumask *, u16);
#line 3572  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static bool netif_is_multiqueue(struct net_device *dev)
{
  #line 3574 
  return (_Bool)(dev->num_tx_queues > 1U);
}

#line 3577 
#line 3577 
int netif_set_real_num_tx_queues(struct net_device *, unsigned int);
#line 3580 
#line 3580 
int netif_set_real_num_rx_queues(struct net_device *, unsigned int);
#line 3617 
#line 3617 
void __dev_kfree_skb_any(struct sk_buff *, enum skb_free_reason);
#line 3648  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void dev_kfree_skb_any(struct sk_buff *skb)
{
  #line 3650 
  __dev_kfree_skb_any(skb,(enum skb_free_reason)SKB_REASON_DROPPED);
  #line 3651 
  return;
}

#line 3665 
#line 3665 
gro_result_t napi_gro_receive(struct napi_struct *, struct sk_buff *);
#line 3803  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static bool netif_carrier_ok(struct net_device *dev)
{
  #line 3805 
  int tmp_0;
  #line 3805 
  if ((int)test_bit(2L,& dev->state) != 0) 
                                           #line 3805 
                                           tmp_0 = 0; else 
                                                           #line 3805 
                                                           tmp_0 = 1;
  #line 3805 
  return (_Bool)(tmp_0 != 0);
}

#line 3808 
#line 3808 
unsigned long dev_trans_start(struct net_device *);
#line 3812 
#line 3812 
void netif_carrier_on(struct net_device *);
#line 3814 
#line 3814 
void netif_carrier_off(struct net_device *);
#line 3876  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static bool netif_device_present(struct net_device *dev)
{
  #line 3878 
  return test_bit(1L,& dev->state);
}

#line 3881 
#line 3881 
void netif_device_detach(struct net_device *);
#line 3883 
#line 3883 
void netif_device_attach(struct net_device *);
#line 3923  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static u32 netif_msg_init(int debug_value, int default_msg_enable_bits)
{
  #line 3926 
  if ((unsigned int)debug_value > 31U) 
                                       #line 3927 
                                       return (unsigned int)default_msg_enable_bits;
  #line 3928 
  if (debug_value == 0) 
                        #line 3929 
                        return 0U;
  #line 3931 
  return (1U << debug_value) + 4294967295U;
}

#line 3934  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void __netif_tx_lock(struct netdev_queue *txq, int cpu)
{
  #line 3936 
  cif_spin_lock__xmit_lock_of_netdev_queue(& txq->_xmit_lock);
  #line 3937 
  txq->xmit_lock_owner = cpu;
  #line 3938 
  return;
}

#line 3965  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void __netif_tx_unlock(struct netdev_queue *txq)
{
  #line 3967 
  txq->xmit_lock_owner = -1;
  #line 3968 
  cif_spin_unlock__xmit_lock_of_netdev_queue(& txq->_xmit_lock);
  #line 3969 
  return;
}

#line 3984  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_trans_update(struct net_device *dev)
{
  #line 3986 
  struct netdev_queue *txq = netdev_get_tx_queue(dev,0U);
  #line 3988 
  if (txq->trans_start != jiffies) 
                                   #line 3989 
                                   txq->trans_start = jiffies;
  #line 3990 
  return;
}

#line 4070  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_tx_disable(struct net_device *dev)
{
  #line 4076 
  int pscr_ret__;
  #line 4072 
  unsigned int i;
  #line 4073 
  int cpu;
  #line 4075 
  local_bh_disable();
  #line 4076 
  __this_cpu_preempt_check((char *)"read");
  {
    #line 4076 
    void *__vpp_verify = (void *)0;
    #line 4076 
    void *tmp = __vpp_verify;
  }
  #line 4076 
  switch (4UL) {
    #line 4076 
    int pfo_ret___2;
    #line 4076 
    int pfo_ret__;
    #line 4076 
    int pfo_ret___0;
    #line 4076 
    int pfo_ret___1;
    #line 4076 
    case (unsigned long)1: 
                           #line 4076 
    ;
    #line 4076 
    switch (4UL) {
      #line 4076 
      case (unsigned long)1: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      case (unsigned long)2: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      case (unsigned long)4: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      case (unsigned long)8: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      default: 
               #line 4076 
      ;
      #line 4076 
      __bad_percpu_size();
    }
    #line 4076 
    pscr_ret__ = pfo_ret__;
    #line 4076 
    break;
    #line 4076 
    case (unsigned long)2: 
                           #line 4076 
    ;
    #line 4076 
    switch (4UL) {
      #line 4076 
      case (unsigned long)1: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      case (unsigned long)2: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      case (unsigned long)4: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      case (unsigned long)8: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      default: 
               #line 4076 
      ;
      #line 4076 
      __bad_percpu_size();
    }
    #line 4076 
    pscr_ret__ = pfo_ret___0;
    #line 4076 
    break;
    #line 4076 
    case (unsigned long)4: 
                           #line 4076 
    ;
    #line 4076 
    switch (4UL) {
      #line 4076 
      case (unsigned long)1: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      case (unsigned long)2: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      case (unsigned long)4: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      case (unsigned long)8: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      default: 
               #line 4076 
      ;
      #line 4076 
      __bad_percpu_size();
    }
    #line 4076 
    pscr_ret__ = pfo_ret___1;
    #line 4076 
    break;
    #line 4076 
    case (unsigned long)8: 
                           #line 4076 
    ;
    #line 4076 
    switch (4UL) {
      #line 4076 
      case (unsigned long)1: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      case (unsigned long)2: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      case (unsigned long)4: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      case (unsigned long)8: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      default: 
               #line 4076 
      ;
      #line 4076 
      __bad_percpu_size();
    }
    #line 4076 
    pscr_ret__ = pfo_ret___2;
    #line 4076 
    break;
    #line 4076 
    default: 
             #line 4076 
    ;
    #line 4076 
    __bad_size_call_parameter();
    #line 4076 
    break;
  }
  #line 4076 
  cpu = pscr_ret__;
  #line 4077 
  i = 0U;
  #line 4077 
  while (dev->num_tx_queues > i) {
    {
      #line 4078 
      struct netdev_queue *txq = netdev_get_tx_queue(dev,i);
      #line 4080 
      __netif_tx_lock(txq,cpu);
      #line 4081 
      netif_tx_stop_queue(txq);
      #line 4082 
      __netif_tx_unlock(txq);
    }
    #line 4077 
    i ++;
  }
  #line 4084 
  local_bh_enable();
  #line 4085 
  return;
}

#line 4131 
#line 1145  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static int cif_register_netdev(struct net_device *dev);
#line 4132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
#line 1122  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void cif_unregister_netdev(struct net_device *dev);
#line 4137  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
#line 4137 
int __hw_addr_sync_dev(struct netdev_hw_addr_list *, struct net_device *, int (*)(struct net_device *, unsigned char *), int (*)(struct net_device *, unsigned char *));
#line 4152 
#line 4152 
void __hw_addr_unsync_dev(struct netdev_hw_addr_list *, struct net_device *, int (*)(struct net_device *, unsigned char *));
#line 4159 
#line 4159 
int dev_addr_add(struct net_device *, unsigned char *, unsigned char);
#line 4161 
#line 4161 
int dev_addr_del(struct net_device *, unsigned char *, unsigned char);
#line 4167 
#line 4167 
int dev_uc_add(struct net_device *, unsigned char *);
#line 4186  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static int __dev_uc_sync(struct net_device *dev, int (*sync)(struct net_device *, unsigned char *), int (*unsync)(struct net_device *, unsigned char *))
{
  #line 4192 
  return __hw_addr_sync_dev(& dev->uc,dev,sync,unsync);
}

#line 4202  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void __dev_uc_unsync(struct net_device *dev, int (*unsync)(struct net_device *, unsigned char *))
{
  #line 4206 
  __hw_addr_unsync_dev(& dev->uc,dev,unsync);
  #line 4207 
  return;
}

#line 4290 
#line 4290 
int netdev_walk_all_upper_dev_rcu(struct net_device *, int (*)(struct net_device *, void *), void *);
#line 4371 
#line 4371 
void netdev_rss_key_fill(void *, size_t);
#line 4373 
#line 4373 
int skb_checksum_help(struct sk_buff *);
#line 4452  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static bool netdev_xmit_more(void)
{
  #line 4454 
  u8 pscr_ret__;
  #line 4454 
  __this_cpu_preempt_check((char *)"read");
  {
    #line 4454 
    void *__vpp_verify = (void *)0;
    #line 4454 
    void *tmp = __vpp_verify;
  }
  #line 4454 
  switch (1UL) {
    #line 4454 
    u8 pfo_ret___2;
    #line 4454 
    u8 pfo_ret__;
    #line 4454 
    u8 pfo_ret___0;
    #line 4454 
    u8 pfo_ret___1;
    #line 4454 
    case (unsigned long)1: 
                           #line 4454 
    ;
    #line 4454 
    switch (1UL) {
      #line 4454 
      case (unsigned long)1: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      case (unsigned long)2: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      case (unsigned long)4: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      case (unsigned long)8: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      default: 
               #line 4454 
      ;
      #line 4454 
      __bad_percpu_size();
    }
    #line 4454 
    pscr_ret__ = pfo_ret__;
    #line 4454 
    break;
    #line 4454 
    case (unsigned long)2: 
                           #line 4454 
    ;
    #line 4454 
    switch (1UL) {
      #line 4454 
      case (unsigned long)1: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      case (unsigned long)2: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      case (unsigned long)4: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      case (unsigned long)8: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      default: 
               #line 4454 
      ;
      #line 4454 
      __bad_percpu_size();
    }
    #line 4454 
    pscr_ret__ = pfo_ret___0;
    #line 4454 
    break;
    #line 4454 
    case (unsigned long)4: 
                           #line 4454 
    ;
    #line 4454 
    switch (1UL) {
      #line 4454 
      case (unsigned long)1: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      case (unsigned long)2: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      case (unsigned long)4: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      case (unsigned long)8: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      default: 
               #line 4454 
      ;
      #line 4454 
      __bad_percpu_size();
    }
    #line 4454 
    pscr_ret__ = pfo_ret___1;
    #line 4454 
    break;
    #line 4454 
    case (unsigned long)8: 
                           #line 4454 
    ;
    #line 4454 
    switch (1UL) {
      #line 4454 
      case (unsigned long)1: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      case (unsigned long)2: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      case (unsigned long)4: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      case (unsigned long)8: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      default: 
               #line 4454 
      ;
      #line 4454 
      __bad_percpu_size();
    }
    #line 4454 
    pscr_ret__ = pfo_ret___2;
    #line 4454 
    break;
    #line 4454 
    default: 
             #line 4454 
    ;
    #line 4454 
    __bad_size_call_parameter();
    #line 4454 
    break;
  }
  #line 4454 
  return (_Bool)((unsigned int)pscr_ret__ != 0U);
}

#line 4575  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_set_gso_max_size(struct net_device *dev, unsigned int size)
{
  #line 4578 
  dev->gso_max_size = size;
  #line 4579 
  return;
}

#line 4599  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static bool netif_is_macvlan(struct net_device *dev)
{
  #line 4601 
  return (_Bool)((dev->priv_flags & 65536U) != 0U);
}

#line 4748 
#line 4748 
void netdev_crit(struct net_device *, char * , ...);
#line 4750 
#line 4750 
void netdev_err(struct net_device *, char * , ...);
#line 4752 
#line 4752 
void netdev_warn(struct net_device *, char * , ...);
#line 4756 
#line 4756 
void netdev_info(struct net_device *, char * , ...);
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ip.h"
__inline static struct iphdr *ip_hdr(struct sk_buff *skb)
{
  #line 21 
  return (struct iphdr *)skb_network_header(skb);
}

#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
#line 28 
int eth_platform_get_mac_address(struct device *, u8 *);
#line 31 
#line 31 
u32 eth_get_headlen(struct net_device *, void *, unsigned int);
#line 32 
#line 32 
__be16 eth_type_trans(struct sk_buff *, struct net_device *);
#line 47 
#line 47 
int eth_validate_addr(struct net_device *);
#line 51 
#line 1137  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static struct net_device *cif_alloc_etherdev_mqs(int sizeof_priv, unsigned int txqs, unsigned int rxqs);
#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
static u8 eth_reserved_addr_base[6U] = {(unsigned char)1U, (unsigned char)128U, (unsigned char)194U};
#line 76  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static bool is_link_local_ether_addr(u8 *addr)
{
  #line 78 
  __be16 *a = (__be16 *)addr;
  #line 79 
  __be16 *b = (__be16 *)(& eth_reserved_addr_base);
  #line 80 
  __be16 m = (unsigned short)61695U;
  #line 84 
  return (_Bool)(((*((u32 *)addr) ^ *((u32 *)b)) | ((unsigned int)((int)*(a + 2U) ^ (int)*(b + 2U)) & 61695U)) == 0U);
}

#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static bool is_zero_ether_addr(u8 *addr)
{
  #line 101 
  return (_Bool)((*((u32 *)addr) | (unsigned int)*((u16 *)(addr + 4U))) == 0U);
}

#line 116  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static bool is_multicast_ether_addr(u8 *addr)
{
  #line 119 
  u32 a = *((u32 *)addr);
  #line 126 
  return (_Bool)((a & 1U) != 0U);
}

#line 175  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static bool is_unicast_ether_addr(u8 *addr)
{
  #line 177 
  int tmp_0;
  #line 177 
  if ((int)is_multicast_ether_addr(addr) != 0) 
                                               #line 177 
                                               tmp_0 = 0; else 
                                                               #line 177 
                                                               tmp_0 = 1;
  #line 177 
  return (_Bool)(tmp_0 != 0);
}

#line 191  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static bool is_valid_ether_addr(u8 *addr)
{
  #line 195 
  int tmp_1;
  #line 195 
  if (is_multicast_ether_addr(addr)) 
                                     #line 195 
                                     tmp_1 = 0;
  else {
    #line 195 
    if (is_zero_ether_addr(addr)) 
                                  #line 195 
                                  tmp_1 = 0; else 
                                                  #line 195 
                                                  tmp_1 = 1;
  }
  #line 195 
  return (_Bool)(tmp_1 != 0);
}

#line 276  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static void ether_addr_copy(u8 *dst, u8 *src)
{
  #line 279 
  *((u32 *)dst) = *((u32 *)src);
  #line 280 
  *((u16 *)(dst + 4U)) = *((u16 *)(src + 4U));
  #line 281 
  return;
}

#line 315  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static bool ether_addr_equal(u8 *addr1, u8 *addr2)
{
  #line 318 
  u32 fold = (*((u32 *)addr1) ^ *((u32 *)addr2)) | (unsigned int)((int)*((u16 *)(addr1 + 4U)) ^ (int)*((u16 *)(addr2 + 4U)));
  #line 321 
  return (_Bool)(fold == 0U);
}

#line 530  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static int eth_skb_pad(struct sk_buff *skb)
{
  #line 532 
  return skb_put_padto(skb,60U);
}

#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rtnetlink.h"
#line 33 
void rtnl_lock(void);
#line 34 
#line 34 
void rtnl_unlock(void);
#line 36 
#line 36 
int rtnl_is_locked(void);
#line 45 
#line 45 
bool lockdep_rtnl_is_held(void);
#line 118 
#line 118 
int ndo_dflt_fdb_add(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char *, u16, u16);
#line 130 
#line 130 
int ndo_dflt_bridge_getlink(struct sk_buff *, u32, u32, struct net_device *, u16, u32, u32, int, u32, int (*)(struct sk_buff *, struct net_device *, u32 ));
#line 300  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_vlan.h"
__inline static bool eth_type_vlan(__be16 ethertype)
{
  #line 302 
  switch ((int)ethertype) {
    #line 303 
    case 129: 
              #line 303 
    ;
    #line 304 
    case 43144: 
                #line 304 
    ;
    #line 305 
    return (_Bool)1;
    #line 306 
    default: 
             #line 306 
    ;
    #line 307 
    return (_Bool)0;
  }
}

#line 510  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_vlan.h"
__inline static void __vlan_hwaccel_put_tag(struct sk_buff *skb, __be16 vlan_proto, u16 vlan_tci)
{
  #line 513 
  skb->vlan_proto = vlan_proto;
  #line 514 
  skb->vlan_tci = vlan_tci;
  #line 515 
  skb->vlan_present = (unsigned char)1U;
  #line 516 
  return;
}

#line 580  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_vlan.h"
__inline static __be16 __vlan_get_protocol(struct sk_buff *skb, __be16 type, int *depth)
{
  #line 583 
  unsigned int vlan_depth = (unsigned int)skb->mac_len;
  #line 589 
  if ((int)eth_type_vlan((unsigned short)((int)type)) != 0) {
    #line 590 
    if (vlan_depth != 0U) {
      #line 591 
      int __ret_warn_on;
      #line 591 
      __ret_warn_on = vlan_depth <= 3U;
      #line 591 
      if ((long)(__ret_warn_on != 0) != 0L) {
        #line 592 
        ldv_inline_asm();
        #line 593 
        ldv_inline_asm();
      }
      #line 591 
      if ((long)((long)(__ret_warn_on != 0)) != 0L) 
                                                    #line 592 
                                                    return (unsigned short)0U;
      #line 593 
      vlan_depth += 4294967292U;
    }
    else 
         #line 595 
         vlan_depth = 14U;
    #line 597 
    while (1) {
      {
        #line 598 
        struct vlan_hdr *vh;
        #line 600 
        int tmp_1;
        #line 600 
        if (pskb_may_pull(skb,vlan_depth + 4U)) 
                                                #line 600 
                                                tmp_1 = 0; else 
                                                                #line 600 
                                                                tmp_1 = 1;
        #line 600 
        if ((long)tmp_1 != 0L) 
                               #line 602 
                               return (unsigned short)0U;
        #line 604 
        vh = (struct vlan_hdr *)(skb->data + (unsigned long)vlan_depth);
        #line 605 
        type = vh->h_vlan_encapsulated_proto;
        #line 606 
        vlan_depth += 4U;
      }
      #line 607 
      if (! ((int)eth_type_vlan((unsigned short)((int)type)) != 0)) 
                                                                    #line 597 
                                                                    break;
    }
  }
  #line 610 
  if (depth != (int *)0) 
                         #line 611 
                         *depth = (int)vlan_depth;
  #line 613 
  return type;
}

#line 623  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_vlan.h"
__inline static __be16 vlan_get_protocol(struct sk_buff *skb)
{
  #line 625 
  return __vlan_get_protocol(skb,(unsigned short)((int)skb->protocol),(int *)0);
}

#line 441  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
#line 441 
struct nlattr *nla_find(struct nlattr *, int, int);
#line 501  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
__inline static void *nlmsg_data(struct nlmsghdr *nlh)
{
  #line 503 
  return (void *)((unsigned char *)nlh + 16U);
}

#line 510  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
__inline static int nlmsg_len(struct nlmsghdr *nlh)
{
  #line 512 
  return (int)(nlh->nlmsg_len + 4294967280U);
}

#line 520  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
__inline static struct nlattr *nlmsg_attrdata(struct nlmsghdr *nlh, int hdrlen)
{
  #line 523 
  unsigned char *data = nlmsg_data(nlh);
  #line 524 
  return (struct nlattr *)(data + ((unsigned long)((unsigned int)hdrlen + 3U) & (unsigned long)4294967292U));
}

#line 532  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
__inline static int nlmsg_attrlen(struct nlmsghdr *nlh, int hdrlen)
{
  #line 534 
  ;
  #line 534 
  return (int)((unsigned int)nlmsg_len(nlh) - (((unsigned int)hdrlen + 3U) & 4294967292U));
}

#line 738  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
__inline static struct nlattr *nlmsg_find_attr(struct nlmsghdr *nlh, int hdrlen, int attrtype)
{
  #line 741 
  ;
  #line 741 
  return nla_find(nlmsg_attrdata(nlh,hdrlen),nlmsg_attrlen(nlh,hdrlen),
                 attrtype);
}

#line 1063  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
__inline static int nla_type(struct nlattr *nla)
{
  #line 1065 
  return (int)nla->nla_type & -49153;
}

#line 1072  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
__inline static void *nla_data(struct nlattr *nla)
{
  #line 1074 
  return (void *)((char *)nla + 4U);
}

#line 1081  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
__inline static int nla_len(struct nlattr *nla)
{
  #line 1083 
  return (int)nla->nla_len + -4;
}

#line 1091  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
__inline static int nla_ok(struct nlattr *nla, int remaining)
{
  #line 1094 
  return ((remaining > 3 && (unsigned int)nla->nla_len > 3U) && (int)nla->nla_len <= remaining) != 0;
}

#line 1106  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
__inline static struct nlattr *nla_next(struct nlattr *nla, int *remaining)
{
  #line 1108 
  unsigned int totlen = (unsigned int)((int)nla->nla_len + 3) & 4294967292U;
  #line 1110 
  *remaining = (int)((unsigned int)*remaining - totlen);
  #line 1111 
  return (struct nlattr *)((char *)nla + (unsigned long)totlen);
}

#line 1499  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
__inline static u16 nla_get_u16(struct nlattr *nla)
{
  #line 1501 
  return *((u16 *)nla_data(nla));
}

#line 340  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
#line 340 
int flow_block_cb_setup_simple(struct flow_block_offload *, struct list_head *, flow_setup_cb_t *, void *, void *, bool);
#line 560  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/filter.h"
#line 560 
extern struct static_key_false bpf_stats_enabled_key;
#line 702  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/filter.h"
__inline static u32 bpf_prog_run_xdp(struct bpf_prog *prog, struct xdp_buff *xdp)
{
  #line 711 
  u32 ret;
  #line 711 
  __cant_sleep((char *)"./include/linux/filter.h",711,0);
  {
    #line 711 
    bool branch;
    #line 711 
    branch = arch_static_branch(& bpf_stats_enabled_key.key,(_Bool)0);
    #line 711 
    if ((long)((long)((int)branch != 0)) != 0L) {
      #line 711 
      unsigned long tcp_ptr__;
      #line 711 
      struct bpf_prog_stats *stats;
      #line 711 
      u64 start = sched_clock();
      #line 711 
      ret = (*(prog->bpf_func))((void *)xdp,(struct bpf_insn *)(& prog->__anonCompField_bpf_prog_175.insnsi));
      {
        #line 711 
        void *__vpp_verify = (void *)0;
        #line 711 
        void *tmp_2 = __vpp_verify;
      }
      #line 712 
      ldv_inline_asm();
      #line 711 
      stats = ((struct bpf_prog_stats *)tcp_ptr__);
      #line 711 
      u64_stats_init(& stats->syncp);
      #line 711 
      (stats->cnt) ++;
      #line 711 
      stats->nsecs += sched_clock() - start;
      #line 711 
      u64_stats_init(& stats->syncp);
    }
    else 
         #line 711 
         ret = (*(prog->bpf_func))((void *)xdp,(struct bpf_insn *)(& prog->__anonCompField_bpf_prog_175.insnsi));
  }
  #line 711 
  return ret;
}

#line 920 
#line 920 
int xdp_do_redirect(struct net_device *, struct xdp_buff *, struct bpf_prog *);
#line 923 
#line 923 
void xdp_do_flush_map(void);
#line 925 
#line 925 
void bpf_warn_invalid_xdp_action(u32);
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/udp.h"
__inline static struct udphdr *udp_hdr(struct sk_buff *skb)
{
  #line 23 
  return (struct udphdr *)skb_transport_header(skb);
}

#line 1069  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ipv6.h"
#line 1069 
int ipv6_find_hdr(struct sk_buff *, unsigned int *, int, unsigned short *, int *);
#line 38  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_macvlan.h"
__inline static void macvlan_count_rx(struct macvlan_dev *vlan, unsigned int len, bool success, bool multicast)
{
  #line 42 
  if ((long)((int)success != 0) != 0L) {
    #line 45 
    unsigned long tcp_ptr__;
    #line 43 
    struct vlan_pcpu_stats *pcpu_stats;
    {
      #line 45 
      void *__vpp_verify = (void *)0;
      #line 45 
      void *tmp = __vpp_verify;
    }
    #line 46 
    ldv_inline_asm();
    #line 45 
    pcpu_stats = ((struct vlan_pcpu_stats *)tcp_ptr__);
    #line 46 
    u64_stats_init(& pcpu_stats->syncp);
    #line 47 
    (pcpu_stats->rx_packets) ++;
    #line 48 
    pcpu_stats->rx_bytes += (unsigned long long)len;
    #line 49 
    if ((int)multicast != 0) 
                             #line 50 
                             (pcpu_stats->rx_multicast) ++;
    #line 51 
    u64_stats_init(& pcpu_stats->syncp);
  }
  else {
    {
      #line 53 
      void *__vpp_verify_0 = (void *)0;
      #line 53 
      void *tmp_3 = __vpp_verify_0;
    }
    #line 53 
    switch (4UL) {
      #line 53 
      case (unsigned long)1: 
                             #line 53 
      ;
      {
        #line 53 
        int pao_ID__ = 1;
        #line 53 
        switch (4UL) {
          #line 53 
          case (unsigned long)1: 
                                 #line 53 
          ;
          #line 55 
          ldv_inline_asm();
          #line 53 
          break;
          #line 53 
          case (unsigned long)2: 
                                 #line 53 
          ;
          #line 55 
          ldv_inline_asm();
          #line 53 
          break;
          #line 53 
          case (unsigned long)4: 
                                 #line 53 
          ;
          #line 55 
          ldv_inline_asm();
          #line 53 
          break;
          #line 53 
          case (unsigned long)8: 
                                 #line 53 
          ;
          #line 55 
          ldv_inline_asm();
          #line 53 
          break;
          #line 53 
          default: 
                   #line 53 
          ;
          #line 53 
          __bad_percpu_size();
        }
      }
      #line 53 
      break;
      #line 53 
      case (unsigned long)2: 
                             #line 53 
      ;
      {
        #line 53 
        int pao_ID___0 = 1;
        #line 53 
        switch (4UL) {
          #line 53 
          case (unsigned long)1: 
                                 #line 53 
          ;
          #line 55 
          ldv_inline_asm();
          #line 53 
          break;
          #line 53 
          case (unsigned long)2: 
                                 #line 53 
          ;
          #line 55 
          ldv_inline_asm();
          #line 53 
          break;
          #line 53 
          case (unsigned long)4: 
                                 #line 53 
          ;
          #line 55 
          ldv_inline_asm();
          #line 53 
          break;
          #line 53 
          case (unsigned long)8: 
                                 #line 53 
          ;
          #line 55 
          ldv_inline_asm();
          #line 53 
          break;
          #line 53 
          default: 
                   #line 53 
          ;
          #line 53 
          __bad_percpu_size();
        }
      }
      #line 53 
      break;
      #line 53 
      case (unsigned long)4: 
                             #line 53 
      ;
      {
        #line 53 
        int pao_ID___1 = 1;
        #line 53 
        switch (4UL) {
          #line 53 
          case (unsigned long)1: 
                                 #line 53 
          ;
          #line 55 
          ldv_inline_asm();
          #line 53 
          break;
          #line 53 
          case (unsigned long)2: 
                                 #line 53 
          ;
          #line 55 
          ldv_inline_asm();
          #line 53 
          break;
          #line 53 
          case (unsigned long)4: 
                                 #line 53 
          ;
          #line 55 
          ldv_inline_asm();
          #line 53 
          break;
          #line 53 
          case (unsigned long)8: 
                                 #line 53 
          ;
          #line 55 
          ldv_inline_asm();
          #line 53 
          break;
          #line 53 
          default: 
                   #line 53 
          ;
          #line 53 
          __bad_percpu_size();
        }
      }
      #line 53 
      break;
      #line 53 
      case (unsigned long)8: 
                             #line 53 
      ;
      {
        #line 53 
        int pao_ID___2 = 1;
        #line 53 
        switch (4UL) {
          #line 53 
          case (unsigned long)1: 
                                 #line 53 
          ;
          #line 55 
          ldv_inline_asm();
          #line 53 
          break;
          #line 53 
          case (unsigned long)2: 
                                 #line 53 
          ;
          #line 55 
          ldv_inline_asm();
          #line 53 
          break;
          #line 53 
          case (unsigned long)4: 
                                 #line 53 
          ;
          #line 55 
          ldv_inline_asm();
          #line 53 
          break;
          #line 53 
          case (unsigned long)8: 
                                 #line 53 
          ;
          #line 55 
          ldv_inline_asm();
          #line 53 
          break;
          #line 53 
          default: 
                   #line 53 
          ;
          #line 53 
          __bad_percpu_size();
        }
      }
      #line 53 
      break;
      #line 53 
      default: 
               #line 53 
      ;
      #line 53 
      __bad_size_call_parameter();
      #line 53 
      break;
    }
  }
  #line 56 
  return;
}

#line 84  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_macvlan.h"
__inline static void *macvlan_accel_priv(struct net_device *dev)
{
  #line 86 
  struct macvlan_dev *macvlan = netdev_priv(dev);
  #line 88 
  return macvlan->accel_priv;
}

#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_macvlan.h"
__inline static bool macvlan_supports_dest_filter(struct net_device *dev)
{
  #line 93 
  struct macvlan_dev *macvlan = netdev_priv(dev);
  #line 96 
  return (_Bool)(((unsigned int)macvlan->mode + 4294967295U <= 1U || macvlan->mode == (unsigned int)MACVLAN_MODE_BRIDGE) != 0);
}

#line 100  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_macvlan.h"
__inline static int macvlan_release_l2fw_offload(struct net_device *dev)
{
  #line 102 
  struct macvlan_dev *macvlan = netdev_priv(dev);
  #line 104 
  macvlan->accel_priv = (void *)0;
  #line 105 
  return dev_uc_add(macvlan->lowerdev,dev->dev_addr);
}

#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/trace/events/xdp.h"
#line 28 
extern struct tracepoint __tracepoint_xdp_exception;
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/trace/events/xdp.h"
__inline static void trace_xdp_exception(struct net_device *dev, struct bpf_prog *xdp, u32 act)
{
  #line 28 
  int pscr_ret___0;
  #line 28 
  if ((int)static_key_false(& __tracepoint_xdp_exception.key) != 0) {
    #line 28 
    int pscr_ret__;
    #line 28 
    struct tracepoint_func *________p1;
    #line 28 
    struct tracepoint_func *it_func_ptr;
    #line 28 
    void *it_func;
    #line 28 
    void *__data;
    #line 28 
    int __idx = 0;
    {
      #line 28 
      void *__vpp_verify = (void *)0;
      #line 28 
      void *tmp = __vpp_verify;
    }
    #line 28 
    switch (4UL) {
      #line 28 
      int pfo_ret___1;
      #line 28 
      int pfo_ret___2;
      #line 28 
      int pfo_ret__;
      #line 28 
      int pfo_ret___0;
      #line 28 
      case (unsigned long)1: 
                             #line 28 
      ;
      #line 28 
      switch (4UL) {
        #line 28 
        case (unsigned long)1: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)2: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)4: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)8: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        default: 
                 #line 28 
        ;
        #line 28 
        __bad_percpu_size();
      }
      #line 28 
      pscr_ret__ = pfo_ret__;
      #line 28 
      break;
      #line 28 
      case (unsigned long)2: 
                             #line 28 
      ;
      #line 28 
      switch (4UL) {
        #line 28 
        case (unsigned long)1: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)2: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)4: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)8: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        default: 
                 #line 28 
        ;
        #line 28 
        __bad_percpu_size();
      }
      #line 28 
      pscr_ret__ = pfo_ret___0;
      #line 28 
      break;
      #line 28 
      case (unsigned long)4: 
                             #line 28 
      ;
      #line 28 
      switch (4UL) {
        #line 28 
        case (unsigned long)1: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)2: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)4: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)8: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        default: 
                 #line 28 
        ;
        #line 28 
        __bad_percpu_size();
      }
      #line 28 
      pscr_ret__ = pfo_ret___1;
      #line 28 
      break;
      #line 28 
      case (unsigned long)8: 
                             #line 28 
      ;
      #line 28 
      switch (4UL) {
        #line 28 
        case (unsigned long)1: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)2: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)4: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)8: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        default: 
                 #line 28 
        ;
        #line 28 
        __bad_percpu_size();
      }
      #line 28 
      pscr_ret__ = pfo_ret___2;
      #line 28 
      break;
      #line 28 
      default: 
               #line 28 
      ;
      #line 28 
      __bad_size_call_parameter();
      #line 28 
      break;
    }
    #line 28 
    if (cpumask_test_cpu(pscr_ret__,& __cpu_online_mask) == 0) 
                                                               #line 28 
                                                               return;
    {
      #line 28 
      int __ret_warn_on = 0;
      #line 28 
      if ((long)(__ret_warn_on != 0) != 0L) {
        #line 29 
        ldv_inline_asm();
        #line 30 
        ldv_inline_asm();
      }
      #line 28 
      long tmp_5 = (long)(__ret_warn_on != 0);
    }
    #line 28 
    __preempt_count_add(1);
    #line 29 
    ldv_inline_asm();
    {
      #line 29 
      union __anonunion___u_2464 __u;
      #line 28 
      __read_once_size((void *)(& __tracepoint_xdp_exception.funcs),(void *)(& __u.__c),8);
      #line 28 
      ________p1 = (__u.__val);
      }
    #line 28 
    it_func_ptr = ________p1;
    #line 28 
    if (it_func_ptr != (struct tracepoint_func *)0) 
      #line 28 
      while (1) {
        #line 28 
        it_func = it_func_ptr->func;
        #line 28 
        __data = it_func_ptr->data;
        #line 28 
        (*((void (*)(void *, struct net_device *, struct bpf_prog *, u32 ))it_func))(__data,dev,xdp,act);
        #line 28 
        it_func_ptr ++;
        #line 29 
        ;
        #line 29 
        if (! (it_func_ptr->func != (void *)0)) 
                                                #line 28 
                                                break;
      }
    #line 30 
    ldv_inline_asm();
    #line 28 
    __preempt_count_sub(1);
  }
  {
    #line 28 
    void *__vpp_verify_0 = (void *)0;
    #line 28 
    void *tmp_13 = __vpp_verify_0;
  }
  #line 28 
  switch (4UL) {
    #line 28 
    int pfo_ret___3;
    #line 28 
    int pfo_ret___4;
    #line 28 
    int pfo_ret___5;
    #line 28 
    int pfo_ret___6;
    #line 28 
    case (unsigned long)1: 
                           #line 28 
    ;
    #line 28 
    switch (4UL) {
      #line 28 
      case (unsigned long)1: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)2: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)4: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)8: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      default: 
               #line 28 
      ;
      #line 28 
      __bad_percpu_size();
    }
    #line 28 
    pscr_ret___0 = pfo_ret___3;
    #line 28 
    break;
    #line 28 
    case (unsigned long)2: 
                           #line 28 
    ;
    #line 28 
    switch (4UL) {
      #line 28 
      case (unsigned long)1: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)2: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)4: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)8: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      default: 
               #line 28 
      ;
      #line 28 
      __bad_percpu_size();
    }
    #line 28 
    pscr_ret___0 = pfo_ret___4;
    #line 28 
    break;
    #line 28 
    case (unsigned long)4: 
                           #line 28 
    ;
    #line 28 
    switch (4UL) {
      #line 28 
      case (unsigned long)1: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)2: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)4: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)8: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      default: 
               #line 28 
      ;
      #line 28 
      __bad_percpu_size();
    }
    #line 28 
    pscr_ret___0 = pfo_ret___5;
    #line 28 
    break;
    #line 28 
    case (unsigned long)8: 
                           #line 28 
    ;
    #line 28 
    switch (4UL) {
      #line 28 
      case (unsigned long)1: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)2: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)4: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)8: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      default: 
               #line 28 
      ;
      #line 28 
      __bad_percpu_size();
    }
    #line 28 
    pscr_ret___0 = pfo_ret___6;
    #line 28 
    break;
    #line 28 
    default: 
             #line 28 
    ;
    #line 28 
    __bad_size_call_parameter();
    #line 28 
    break;
  }
  #line 28 
  if (cpumask_test_cpu(pscr_ret___0,& __cpu_online_mask) != 0) {
    #line 28 
    __rcu_read_lock();
    {
      #line 29 
      union __anonunion___u_2466 __u_0;
      #line 28 
      __read_once_size((void *)(& __tracepoint_xdp_exception.funcs),(void *)(& __u_0.__c),8);
      #line 28 
      struct tracepoint_func *________p1_0 = (__u_0.__val);
      {
        #line 28 
        bool __warned;
        #line 28 
        if (debug_lockdep_rcu_enabled() != 0) 
          #line 28 
          if (! __warned) {
            #line 28 
            if (rcu_read_lock_sched_held() == 0) {
              #line 28 
              __warned = (_Bool)1;
              #line 28 
              lockdep_rcu_suspicious((char *)"./include/trace/events/xdp.h",28,(char *)"suspicious rcu_dereference_check() usage");
            }
          }
      }
      #line 28 
      struct tracepoint_func *tmp_11 = ________p1_0;
    }
    #line 28 
    __rcu_read_unlock();
  }
  #line 30 
  return;
}

#line 128  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/udp_tunnel.h"
__inline static void udp_tunnel_get_rx_info(struct net_device *dev)
{
  {
    #line 130 
    bool __warned;
    #line 130 
    int __ret_warn_once = rtnl_is_locked() == 0;
    #line 130 
    if ((long)(__ret_warn_once != 0) != 0L && (long)(! __warned) != 0L) {
      #line 130 
      __warned = (_Bool)1;
      {
        #line 130 
        int __ret_warn_on = 1;
        #line 130 
        if ((long)(__ret_warn_on != 0) != 0L) {
          #line 130 
          __warn_printk((char *)"RTNL: assertion failed at %s (%d)\n",(char *)"./include/net/udp_tunnel.h",130);
          #line 131 
          ldv_inline_asm();
          #line 132 
          ldv_inline_asm();
        }
        #line 130 
        long tmp_2 = (long)(__ret_warn_on != 0);
      }
    }
    #line 130 
    long tmp_4 = (long)(__ret_warn_once != 0);
  }
  #line 131 
  call_netdevice_notifiers(28UL,dev);
  #line 132 
  return;
}

#line 270  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/pkt_cls.h"
__inline static bool tcf_exts_has_actions(struct tcf_exts *exts)
{
  #line 273 
  return (_Bool)(exts->nr_actions != 0);
}

#line 565  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/pkt_cls.h"
__inline static bool tc_can_offload(struct net_device *dev)
{
  #line 567 
  return (_Bool)((dev->features & 281474976710656ULL) != 0ULL);
}

#line 570  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/pkt_cls.h"
__inline static bool tc_can_offload_extack(struct net_device *dev, struct netlink_ext_ack *extack)
{
  #line 573 
  bool can = tc_can_offload(dev);
  #line 575 
  if (! can) {
    #line 576 
    char __msg[37U] = {(char)'T', (char)'C', (char)' ', (char)'o', (char)'f', (char)'f', (char)'l', (char)'o', (char)'a', (char)'d', (char)' ', (char)'i', (char)'s', (char)' ', (char)'d', (char)'i', (char)'s', (char)'a', (char)'b', (char)'l', (char)'e', (char)'d', (char)' ', (char)'o', (char)'n', (char)' ', (char)'n', (char)'e', (char)'t', (char)' ', (char)'d', (char)'e', (char)'v', (char)'i', (char)'c', (char)'e', (char)'\000'};
    #line 576 
    struct netlink_ext_ack *__extack = extack;
    #line 576 
    if (__extack != (struct netlink_ext_ack *)0) 
                                                 #line 576 
                                                 __extack->_msg = (char *)(& __msg);
  }
  #line 578 
  return can;
}

#line 582  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/pkt_cls.h"
__inline static bool tc_cls_can_offload_and_chain0(struct net_device *dev, struct flow_cls_common_offload *common)
{
  #line 585 
  if (! tc_can_offload_extack(dev,common->extack)) 
                                                   #line 586 
                                                   return (_Bool)0;
  #line 587 
  if (common->chain_index != 0U) {
    {
      #line 588 
      char __msg[40U] = {(char)'D', (char)'r', (char)'i', (char)'v', (char)'e', (char)'r', (char)' ', (char)'s', (char)'u', (char)'p', (char)'p', (char)'o', (char)'r', (char)'t', (char)'s', (char)' ', (char)'o', (char)'n', (char)'l', (char)'y', (char)' ', (char)'o', (char)'f', (char)'f', (char)'l', (char)'o', (char)'a', (char)'d', (char)' ', (char)'o', (char)'f', (char)' ', (char)'c', (char)'h', (char)'a', (char)'i', (char)'n', (char)' ', (char)'0', (char)'\000'};
      #line 588 
      struct netlink_ext_ack *__extack = common->extack;
      #line 588 
      if (__extack != (struct netlink_ext_ack *)0) 
                                                   #line 588 
                                                   __extack->_msg = (char *)(& __msg);
    }
    #line 590 
    return (_Bool)0;
  }
  #line 592 
  return (_Bool)1;
}

#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/tc_act/tc_gact.h"
__inline static bool __is_tcf_gact_act(struct tc_action *a, int act, bool is_ext)
{
  #line 23 
  struct tcf_gact *gact;
  #line 25 
  if (a->ops != (struct tc_action_ops *)0 && (a->ops)->id != (unsigned int)TCA_ID_GACT) 
    #line 26 
    return (_Bool)0;
  #line 28 
  gact = (struct tcf_gact *)a;
  #line 29 
  if (! is_ext && gact->common.tcfa_action == act || (int)is_ext != 0 && (gact->common.tcfa_action & -268435456) == act) 
    #line 31 
    return (_Bool)1;
  #line 34 
  return (_Bool)0;
}

#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/tc_act/tc_gact.h"
__inline static bool is_tcf_gact_shot(struct tc_action *a)
{
  #line 44 
  return __is_tcf_gact_act(a,2,(_Bool)0);
}

#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/tc_act/tc_mirred.h"
__inline static bool is_tcf_mirred_egress_redirect(struct tc_action *a)
{
  #line 20 
  if (a->ops != (struct tc_action_ops *)0 && (a->ops)->id == (unsigned int)TCA_ID_MIRRED) 
    #line 21 
    return (_Bool)(((struct tcf_mirred *)a)->tcfm_eaction == 1);
  #line 23 
  return (_Bool)0;
}

#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/tc_act/tc_mirred.h"
__inline static struct net_device *tcf_mirred_dev(struct tc_action *a)
{
  {
    #line 55 
    bool __warned;
    #line 55 
    if (debug_lockdep_rcu_enabled() != 0) 
      #line 55 
      if (! __warned) {
        #line 55 
        if (! lockdep_rtnl_is_held()) {
          #line 55 
          __warned = (_Bool)1;
          #line 55 
          lockdep_rcu_suspicious((char *)"./include/net/tc_act/tc_mirred.h",55,(char *)"suspicious rcu_dereference_protected() usage");
        }
      }
  }
  #line 55 
  return ((struct tcf_mirred *)a)->tcfm_dev;
}

#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/mpls.h"
__inline static bool eth_p_mpls(__be16 eth_type)
{
  #line 20 
  return (_Bool)(((unsigned int)eth_type == 18312U || (unsigned int)eth_type == 18568U) != 0);
}

#line 1824  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
__inline static struct xfrm_offload *xfrm_offload(struct sk_buff *skb)
{
  #line 1827 
  struct sec_path *sp = skb_sec_path(skb);
  #line 1829 
  if ((sp == (struct sec_path *)0 || sp->olen == 0) || sp->len != sp->olen) 
    #line 1830 
    return (struct xfrm_offload *)0;
  #line 1832 
  return & sp->ovec[sp->olen + -1];
}

#line 45  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/aer.h"
#line 45 
int pci_enable_pcie_error_reporting(struct pci_dev *);
#line 46 
#line 46 
int pci_disable_pcie_error_reporting(struct pci_dev *);
#line 51  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mii.h"
__inline static struct mii_ioctl_data *if_mii(struct ifreq *rq)
{
  #line 53 
  return (struct mii_ioctl_data *)(& rq->ifr_ifru);
}

#line 187  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mdio.h"
#line 187 
int mdio_mii_ioctl(struct mdio_if_info *, struct mii_ioctl_data *, int);
#line 320 
#line 320 
int mdiobus_read(struct mii_bus *, int, u32);
#line 322 
#line 322 
int mdiobus_write(struct mii_bus *, int, u32, u16);
#line 268  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/phy.h"
#line 268 
void mdiobus_unregister(struct mii_bus *);
#line 104  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.h"
#line 104 
void ixgbe_init_mbx_params_pf(struct ixgbe_hw *hw);
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
#line 16 
s32 ixgbe_read_pba_string_generic(struct ixgbe_hw *hw, u8 *pba_num, u32 pba_num_size);
#line 19 
#line 19 
enum ixgbe_bus_width ixgbe_convert_bus_width(u16 link_status);
#line 20 
#line 20 
enum ixgbe_bus_speed ixgbe_convert_bus_speed(u16 link_status);
#line 29 
#line 29 
s32 ixgbe_init_eeprom_params_generic(struct ixgbe_hw *hw);
#line 39 
#line 39 
s32 ixgbe_read_eeprom_bit_bang_generic(struct ixgbe_hw *hw, u16 offset, u16 *data);
#line 61 
#line 61 
bool ixgbe_device_supports_autoneg_fc(struct ixgbe_hw *hw);
#line 98 
#line 98 
bool ixgbe_mng_enabled(struct ixgbe_hw *hw);
#line 117 
#line 117 
void ixgbe_get_etk_id(struct ixgbe_hw *hw, struct ixgbe_nvm_version *nvm_ver);
#line 119 
#line 119 
void ixgbe_get_oem_prod_version(struct ixgbe_hw *hw, struct ixgbe_nvm_version *nvm_ver);
#line 121 
#line 121 
void ixgbe_get_orom_version(struct ixgbe_hw *hw, struct ixgbe_nvm_version *nvm_ver);
#line 136 
#line 378  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
u16 ixgbe_read_pci_cfg_word(struct ixgbe_hw *hw, u32 reg);
#line 137  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
#line 408  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_write_pci_cfg_word(struct ixgbe_hw *hw, u32 reg, u16 value);
#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static void ixgbe_write_reg_1(struct ixgbe_hw *hw, u32 reg, u32 value)
{
  #line 147 
  union __anonunion___u_2616 __u;
  #line 146 
  __read_once_size((void *)(& hw->hw_addr),(void *)(& __u.__c),8);
  #line 146 
  u8 *reg_addr = (__u.__val);
  #line 148 
  if ((int)ixgbe_removed((void *)reg_addr) != 0) 
                                                 #line 149 
                                                 return;
  #line 150 
  writel(value,(void *)(reg_addr + (unsigned long)reg));
  #line 151 
  return;
}

#line 124  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
#line 124 
u8 ixgbe_dcb_get_tc_from_up(struct ixgbe_dcb_config *cfg, int direction, u8 up);
#line 127 
#line 127 
s32 ixgbe_dcb_calculate_tc_credits(struct ixgbe_hw *hw, struct ixgbe_dcb_config *dcb_config, int max_frame, u8 direction);
#line 131 
#line 131 
s32 ixgbe_dcb_hw_ets(struct ixgbe_hw *hw, struct ieee_ets *ets, int max_frame);
#line 134 
#line 134 
s32 ixgbe_dcb_hw_pfc_config(struct ixgbe_hw *hw, u8 pfc_en, u8 *prio_tc);
#line 135 
#line 135 
s32 ixgbe_dcb_hw_config(struct ixgbe_hw *hw, struct ixgbe_dcb_config *dcb_config);
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dca.h"
#line 13 
void dca_register_notify(struct notifier_block *);
#line 14 
#line 14 
void dca_unregister_notify(struct notifier_block *);
#line 53 
#line 53 
int dca_add_requester(struct device *);
#line 54 
#line 54 
int dca_remove_requester(struct device *);
#line 56 
#line 56 
u8 dca3_get_tag(struct device *, int);
#line 85  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static int ixgbe_compute_pad(int rx_buf_len)
{
  #line 87 
  int page_size;
  #line 87 
  int pad_size;
  #line 89 
  page_size = (rx_buf_len + 2047) & -2048;
  #line 90 
  pad_size = (int)((unsigned int)(page_size - rx_buf_len) + 4294966976U);
  #line 92 
  return pad_size;
}

#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static int ixgbe_skb_pad(void)
{
  #line 97 
  int rx_buf_len;
  #line 109 
  rx_buf_len = 1536;
  #line 112 
  rx_buf_len = rx_buf_len;
  #line 114 
  return ixgbe_compute_pad(rx_buf_len);
}

#line 399  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static unsigned int ixgbe_rx_bufsz(struct ixgbe_ring *ring)
{
  #line 401 
  if ((int)test_bit(0L,& ring->state) != 0) 
                                            #line 402 
                                            return 3072U;
  #line 404 
  if ((int)test_bit(1L,& ring->state) != 0) 
                                            #line 405 
                                            return 1536U;
  #line 407 
  return 2048U;
}

#line 410  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static unsigned int ixgbe_rx_pg_order(struct ixgbe_ring *ring)
{
  #line 413 
  if ((int)test_bit(0L,& ring->state) != 0) 
                                            #line 414 
                                            return 1U;
  #line 416 
  return 0U;
}

#line 501  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static __le32 ixgbe_test_staterr(union ixgbe_adv_rx_desc *rx_desc, u32 stat_err_bits)
{
  #line 504 
  return rx_desc->wb.upper.status_error & stat_err_bits;
}

#line 507  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static u16 ixgbe_desc_unused(struct ixgbe_ring *ring)
{
  #line 512 
  unsigned int tmp;
  #line 509 
  u16 ntc = ring->next_to_clean;
  #line 510 
  u16 ntu = ring->next_to_use;
  #line 512 
  if ((int)ntc <= (int)ntu) 
                            #line 512 
                            tmp = (unsigned int)ring->count; else 
                                                                  #line 512 
                                                                  tmp = 0U;
  #line 512 
  ;
  #line 512 
  return (unsigned short)(((tmp + (unsigned int)ntc) - (unsigned int)ntu) + 65535U);
}

#line 778  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static u8 ixgbe_max_rss_indices(struct ixgbe_adapter *adapter)
{
  #line 780 
  switch ((unsigned int)adapter->hw.mac.type) {
    #line 781 
    case (unsigned int)1: 
                          #line 781 
    ;
    #line 782 
    case (unsigned int)2: 
                          #line 782 
    ;
    #line 783 
    case (unsigned int)3: 
                          #line 783 
    ;
    #line 784 
    return (unsigned char)16U;
    #line 785 
    case (unsigned int)4: 
                          #line 785 
    ;
    #line 786 
    case (unsigned int)5: 
                          #line 786 
    ;
    #line 787 
    case (unsigned int)6: 
                          #line 787 
    ;
    #line 788 
    return (unsigned char)63U;
    #line 789 
    default: 
             #line 789 
    ;
    #line 790 
    return (unsigned char)0U;
  }
}

#line 837 
#line 1189  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
struct ixgbe_info ixgbe_82598_info;
#line 838  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 2248  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
struct ixgbe_info ixgbe_82599_info;
#line 839  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 915  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
struct ixgbe_info ixgbe_X540_info;
#line 840  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 4048  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
struct ixgbe_info ixgbe_X550_info;
#line 841  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 4058  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
struct ixgbe_info ixgbe_X550EM_x_info;
#line 842  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 4069  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
struct ixgbe_info ixgbe_x550em_x_fw_info;
#line 843  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 4079  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
struct ixgbe_info ixgbe_x550em_a_info;
#line 844  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 4089  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
struct ixgbe_info ixgbe_x550em_a_fw_info;
#line 846  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 755  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
struct dcbnl_rtnl_ops ixgbe_dcbnl_ops;
#line 849  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 49  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
char ixgbe_driver_name[6U];
#line 850  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 60  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
char ixgbe_driver_version[8U];
#line 852  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
char ixgbe_default_device_descr[39U];
#line 855  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 6769  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_open(struct net_device *netdev);
#line 856  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 6861  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_close(struct net_device *netdev);
#line 857  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 5695  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_up(struct ixgbe_adapter *adapter);
#line 858  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 6086  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_down(struct ixgbe_adapter *adapter);
#line 859  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 5672  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_reinit_locked(struct ixgbe_adapter *adapter);
#line 860  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 5909  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_reset(struct ixgbe_adapter *adapter);
#line 861  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 861 
void ixgbe_set_ethtool_ops(struct net_device *netdev);
#line 862 
#line 6536  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_setup_rx_resources(struct ixgbe_adapter *adapter, struct ixgbe_ring *rx_ring);
#line 863  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 6443  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_setup_tx_resources(struct ixgbe_ring *tx_ring);
#line 864  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 6671  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_free_rx_resources(struct ixgbe_ring *rx_ring);
#line 865  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 6630  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_free_tx_resources(struct ixgbe_ring *tx_ring);
#line 866  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 4065  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_configure_rx_ring(struct ixgbe_adapter *adapter, struct ixgbe_ring *ring);
#line 867  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 3477  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_configure_tx_ring(struct ixgbe_adapter *adapter, struct ixgbe_ring *ring);
#line 868  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 5740  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_disable_rx(struct ixgbe_adapter *adapter);
#line 869  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 5812  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_disable_tx(struct ixgbe_adapter *adapter);
#line 870  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 7039  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_update_stats(struct ixgbe_adapter *adapter);
#line 871  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 871 
int ixgbe_init_interrupt_scheme(struct ixgbe_adapter *adapter);
#line 872 
#line 10636  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
bool ixgbe_wol_supported(struct ixgbe_adapter *adapter, u16 device_id, u16 subdevice_id);
#line 875  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 4727  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_full_sync_mac_table(struct ixgbe_adapter *adapter);
#line 877  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 4821  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_add_mac_filter(struct ixgbe_adapter *adapter, u8 *addr, u16 pool);
#line 879  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 4849  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_del_mac_filter(struct ixgbe_adapter *adapter, u8 *addr, u16 pool);
#line 881  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 4457  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_update_pf_promisc_vlvf(struct ixgbe_adapter *adapter, u32 vid);
#line 882  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 882 
void ixgbe_clear_interrupt_scheme(struct ixgbe_adapter *adapter);
#line 883 
#line 8616  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
netdev_tx_t ixgbe_xmit_frame_ring(struct sk_buff *skb, struct ixgbe_adapter *adapter, struct ixgbe_ring *tx_ring);
#line 887  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 1579  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_alloc_rx_buffers(struct ixgbe_ring *rx_ring, u16 cleaned_count);
#line 888  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 2687  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_write_eitr(struct ixgbe_q_vector *q_vector);
#line 889  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 3156  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_poll(struct napi_struct *napi, int budget);
#line 891  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 891 
s32 ixgbe_reinit_fdir_tables_82599(struct ixgbe_hw *hw);
#line 892 
#line 892 
s32 ixgbe_init_fdir_signature_82599(struct ixgbe_hw *hw, u32 fdirctrl);
#line 893 
#line 893 
s32 ixgbe_init_fdir_perfect_82599(struct ixgbe_hw *hw, u32 fdirctrl);
#line 894 
#line 894 
s32 ixgbe_fdir_add_signature_filter_82599(struct ixgbe_hw *hw, union ixgbe_atr_hash_dword input, union ixgbe_atr_hash_dword common, u8 queue);
#line 898 
#line 898 
s32 ixgbe_fdir_set_input_mask_82599(struct ixgbe_hw *hw, union ixgbe_atr_input *input_mask);
#line 900 
#line 900 
s32 ixgbe_fdir_write_perfect_filter_82599(struct ixgbe_hw *hw, union ixgbe_atr_input *input, u16 soft_id, u8 queue);
#line 906 
#line 906 
void ixgbe_atr_compute_perfect_hash_82599(union ixgbe_atr_input *input, union ixgbe_atr_input *input_mask);
#line 908 
#line 908 
int ixgbe_update_ethtool_fdir_entry(struct ixgbe_adapter *adapter, struct ixgbe_fdir_filter *input, u16 sw_idx);
#line 911 
#line 4910  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_set_rx_mode(struct net_device *netdev);
#line 913  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 3675  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_set_rx_drop_en(struct ixgbe_adapter *adapter);
#line 915  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 9105  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_setup_tc(struct net_device *dev, u8 tc);
#line 916  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 916 
void ixgbe_tx_ctxtdesc(struct ixgbe_ring *tx_ring, u32 vlan_macip_lens, u32 fceof_saidx, u32 type_tucmd, u32 mss_l4len_idx);
#line 917 
#line 9683  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_do_reset(struct net_device *netdev);
#line 919  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 919 
void ixgbe_sysfs_exit(struct ixgbe_adapter *adapter);
#line 920 
#line 920 
int ixgbe_sysfs_init(struct ixgbe_adapter *adapter);
#line 923 
#line 923 
void ixgbe_configure_fcoe(struct ixgbe_adapter *adapter);
#line 924 
#line 924 
int ixgbe_fso(struct ixgbe_ring *tx_ring, struct ixgbe_tx_buffer *first, u8 *hdr_len);
#line 926 
#line 926 
int ixgbe_fcoe_ddp(struct ixgbe_adapter *adapter, union ixgbe_adv_rx_desc *rx_desc, struct sk_buff *skb);
#line 928 
#line 928 
int ixgbe_fcoe_ddp_get(struct net_device *netdev, u16 xid, struct scatterlist *sgl, unsigned int sgc);
#line 930 
#line 930 
int ixgbe_fcoe_ddp_target(struct net_device *netdev, u16 xid, struct scatterlist *sgl, unsigned int sgc);
#line 932 
#line 932 
int ixgbe_fcoe_ddp_put(struct net_device *netdev, u16 xid);
#line 933 
#line 933 
int ixgbe_setup_fcoe_ddp_resources(struct ixgbe_adapter *adapter);
#line 934 
#line 934 
void ixgbe_free_fcoe_ddp_resources(struct ixgbe_adapter *adapter);
#line 935 
#line 935 
int ixgbe_fcoe_enable(struct net_device *netdev);
#line 936 
#line 936 
int ixgbe_fcoe_disable(struct net_device *netdev);
#line 941 
#line 941 
int ixgbe_fcoe_get_wwn(struct net_device *netdev, u64 *wwn, int type);
#line 942 
#line 942 
int ixgbe_fcoe_get_hbainfo(struct net_device *netdev, struct netdev_fcoe_hbainfo *info);
#line 944 
#line 944 
u8 ixgbe_fcoe_get_tc(struct ixgbe_adapter *adapter);
#line 947 
#line 947 
void ixgbe_dbg_adapter_init(struct ixgbe_adapter *adapter);
#line 948 
#line 948 
void ixgbe_dbg_adapter_exit(struct ixgbe_adapter *adapter);
#line 949 
#line 949 
void ixgbe_dbg_init(void);
#line 950 
#line 950 
void ixgbe_dbg_exit(void);
#line 957  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static struct netdev_queue *txring_txq(struct ixgbe_ring *ring)
{
  #line 959 
  return netdev_get_tx_queue(ring->netdev,(unsigned int)ring->queue_index);
}

#line 962 
#line 962 
void ixgbe_ptp_init(struct ixgbe_adapter *adapter);
#line 963 
#line 963 
void ixgbe_ptp_suspend(struct ixgbe_adapter *adapter);
#line 964 
#line 964 
void ixgbe_ptp_stop(struct ixgbe_adapter *adapter);
#line 965 
#line 965 
void ixgbe_ptp_overflow_check(struct ixgbe_adapter *adapter);
#line 966 
#line 966 
void ixgbe_ptp_rx_hang(struct ixgbe_adapter *adapter);
#line 967 
#line 967 
void ixgbe_ptp_tx_hang(struct ixgbe_adapter *adapter);
#line 968 
#line 968 
void ixgbe_ptp_rx_pktstamp(struct ixgbe_q_vector *q_vector, struct sk_buff *skb);
#line 969 
#line 969 
void ixgbe_ptp_rx_rgtstamp(struct ixgbe_q_vector *q_vector, struct sk_buff *skb);
#line 970  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static void ixgbe_ptp_rx_hwtstamp(struct ixgbe_ring *rx_ring, union ixgbe_adv_rx_desc *rx_desc, struct sk_buff *skb)
{
  #line 974 
  if ((long)(ixgbe_test_staterr(rx_desc,32768U) != 0U) != 0L) {
    #line 975 
    ixgbe_ptp_rx_pktstamp(rx_ring->q_vector,skb);
    #line 976 
    return;
  }
  #line 979 
  if ((long)(ixgbe_test_staterr(rx_desc,65536U) == 0U) != 0L) 
                                                              #line 980 
                                                              return;
  #line 982 
  ixgbe_ptp_rx_rgtstamp(rx_ring->q_vector,skb);
  #line 987 
  rx_ring->last_rx_timestamp = jiffies;
  #line 988 
  return;
}

#line 990 
#line 990 
int ixgbe_ptp_set_ts_config(struct ixgbe_adapter *adapter, struct ifreq *ifr);
#line 991 
#line 991 
int ixgbe_ptp_get_ts_config(struct ixgbe_adapter *adapter, struct ifreq *ifr);
#line 992 
#line 992 
void ixgbe_ptp_start_cyclecounter(struct ixgbe_adapter *adapter);
#line 993 
#line 993 
void ixgbe_ptp_reset(struct ixgbe_adapter *adapter);
#line 994 
#line 994 
void ixgbe_ptp_check_pps_event(struct ixgbe_adapter *adapter);
#line 996 
#line 9673  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_sriov_reinit(struct ixgbe_adapter *adapter);
#line 1002  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 3764  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
u32 ixgbe_rss_indir_tbl_entries(struct ixgbe_adapter *adapter);
#line 1003  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 3780  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_store_key(struct ixgbe_adapter *adapter);
#line 1004  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 3817  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_store_reta(struct ixgbe_adapter *adapter);
#line 1008  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 1008 
void ixgbe_init_ipsec_offload(struct ixgbe_adapter *adapter);
#line 1009 
#line 1009 
void ixgbe_stop_ipsec_offload(struct ixgbe_adapter *adapter);
#line 1010 
#line 1010 
void ixgbe_ipsec_restore(struct ixgbe_adapter *adapter);
#line 1011 
#line 1011 
void ixgbe_ipsec_rx(struct ixgbe_ring *rx_ring, union ixgbe_adv_rx_desc *rx_desc, struct sk_buff *skb);
#line 1014 
#line 1014 
int ixgbe_ipsec_tx(struct ixgbe_ring *tx_ring, struct ixgbe_tx_buffer *first, struct ixgbe_ipsec_tx_data *itd);
#line 124  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h"
#line 124 
s32 ixgbe_mii_bus_init(struct ixgbe_hw *hw);
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.h"
#line 16 
void ixgbe_restore_vf_multicasts(struct ixgbe_adapter *adapter);
#line 18 
#line 18 
void ixgbe_msg_task(struct ixgbe_adapter *adapter);
#line 19 
#line 19 
int ixgbe_vf_configuration(struct pci_dev *pdev, unsigned int event_mask);
#line 20 
#line 20 
void ixgbe_disable_tx_rx(struct ixgbe_adapter *adapter);
#line 21 
#line 21 
void ixgbe_ping_all_vfs(struct ixgbe_adapter *adapter);
#line 22 
#line 22 
int ixgbe_ndo_set_vf_mac(struct net_device *netdev, int vf, u8 *mac);
#line 23 
#line 23 
int ixgbe_ndo_set_vf_vlan(struct net_device *netdev, int vf, u16 vlan, u8 qos, __be16 vlan_proto);
#line 25 
#line 25 
int ixgbe_link_mbps(struct ixgbe_adapter *adapter);
#line 26 
#line 26 
int ixgbe_ndo_set_vf_bw(struct net_device *netdev, int vf, int min_tx_rate, int max_tx_rate);
#line 28 
#line 28 
int ixgbe_ndo_set_vf_spoofchk(struct net_device *netdev, int vf, bool setting);
#line 29 
#line 29 
int ixgbe_ndo_set_vf_rss_query_en(struct net_device *netdev, int vf, bool setting);
#line 31 
#line 31 
int ixgbe_ndo_set_vf_trust(struct net_device *netdev, int vf, bool setting);
#line 32 
#line 32 
int ixgbe_ndo_get_vf_config(struct net_device *netdev, int vf, struct ifla_vf_info *ivi);
#line 34 
#line 34 
void ixgbe_check_vf_rate_limit(struct ixgbe_adapter *adapter);
#line 35 
#line 35 
int ixgbe_disable_sriov(struct ixgbe_adapter *adapter);
#line 37 
#line 37 
void ixgbe_enable_sriov(struct ixgbe_adapter *adapter, unsigned int max_vfs_0);
#line 39 
#line 39 
int ixgbe_pci_sriov_configure(struct pci_dev *dev, int num_vfs);
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_model.h"
__inline static int ixgbe_mat_prgm_sip(struct ixgbe_fdir_filter *input, union ixgbe_atr_input *mask, u32 val, u32 m)
{
  #line 32 
  input->filter.formatted.src_ip[0] = val;
  #line 33 
  mask->formatted.src_ip[0] = m;
  #line 34 
  return 0;
}

#line 37  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_model.h"
__inline static int ixgbe_mat_prgm_dip(struct ixgbe_fdir_filter *input, union ixgbe_atr_input *mask, u32 val, u32 m)
{
  #line 41 
  input->filter.formatted.dst_ip[0] = val;
  #line 42 
  mask->formatted.dst_ip[0] = m;
  #line 43 
  return 0;
}

#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_model.h"
static struct ixgbe_mat_field ixgbe_ipv4_fields[3U] = {{.off = 12U, .val = & ixgbe_mat_prgm_sip}, {.off = 16U, .val = & ixgbe_mat_prgm_dip}};
#line 54  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_model.h"
__inline static int ixgbe_mat_prgm_ports(struct ixgbe_fdir_filter *input, union ixgbe_atr_input *mask, u32 val, u32 m)
{
  #line 58 
  input->filter.formatted.src_port = (unsigned short)val;
  #line 59 
  mask->formatted.src_port = (unsigned short)m;
  #line 60 
  input->filter.formatted.dst_port = (unsigned short)(val >> 16);
  #line 61 
  mask->formatted.dst_port = (unsigned short)(m >> 16);
  #line 63 
  return 0;
}

#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_model.h"
static struct ixgbe_mat_field ixgbe_tcp_fields[2U] = {{.val = & ixgbe_mat_prgm_ports, .type = 2U}};
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_model.h"
static struct ixgbe_mat_field ixgbe_udp_fields[2U] = {{.val = & ixgbe_mat_prgm_ports, .type = 1U}};
#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_model.h"
static struct ixgbe_nexthdr ixgbe_ipv4_jumps[3U] = {{.s = 6U, .m = 15U, .off = 8U, .val = 1536U, .mask = 65280U, .jump = (struct ixgbe_mat_field *)(& ixgbe_tcp_fields)}, {.s = 6U, .m = 15U, .off = 8U, .val = 4352U, .mask = 65280U, .jump = (struct ixgbe_mat_field *)(& ixgbe_udp_fields)}};
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_txrx_common.h"
#line 8559  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_xmit_xdp_ring(struct ixgbe_adapter *adapter, struct xdp_frame *xdpf);
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_txrx_common.h"
#line 1878  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
bool ixgbe_cleanup_headers(struct ixgbe_ring *rx_ring, union ixgbe_adv_rx_desc *rx_desc, struct sk_buff *skb);
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_txrx_common.h"
#line 1681  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_process_skb_fields(struct ixgbe_ring *rx_ring, union ixgbe_adv_rx_desc *rx_desc, struct sk_buff *skb);
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_txrx_common.h"
#line 1716  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_rx_skb(struct ixgbe_q_vector *q_vector, struct sk_buff *skb);
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_txrx_common.h"
#line 10333  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_xdp_ring_update_tail(struct ixgbe_ring *ring);
#line 26  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_txrx_common.h"
#line 901  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_irq_rearm_queues(struct ixgbe_adapter *adapter, u64 qmask);
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_txrx_common.h"
#line 10525  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_txrx_ring_disable(struct ixgbe_adapter *adapter, int ring);
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_txrx_common.h"
#line 10563  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_txrx_ring_enable(struct ixgbe_adapter *adapter, int ring);
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_txrx_common.h"
#line 31 
struct xdp_umem *ixgbe_xsk_umem(struct ixgbe_adapter *adapter, struct ixgbe_ring *ring);
#line 33 
#line 33 
int ixgbe_xsk_umem_setup(struct ixgbe_adapter *adapter, struct xdp_umem *umem, u16 qid);
#line 36 
#line 36 
void ixgbe_zca_free(struct zero_copy_allocator *alloc, unsigned long handle);
#line 38 
#line 38 
void ixgbe_alloc_rx_buffers_zc(struct ixgbe_ring *rx_ring, u16 count);
#line 39 
#line 39 
int ixgbe_clean_rx_irq_zc(struct ixgbe_q_vector *q_vector, struct ixgbe_ring *rx_ring, int budget);
#line 42 
#line 42 
void ixgbe_xsk_clean_rx_ring(struct ixgbe_ring *rx_ring);
#line 43 
#line 43 
bool ixgbe_clean_xdp_tx_irq(struct ixgbe_q_vector *q_vector, struct ixgbe_ring *tx_ring, int napi_budget);
#line 45 
#line 45 
int ixgbe_xsk_wakeup(struct net_device *dev, u32 qid, u32 flags);
#line 46 
#line 46 
void ixgbe_xsk_clean_tx_ring(struct ixgbe_ring *tx_ring);
#line 49  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
char ixgbe_driver_name[6U] = {(char)'i', (char)'x', (char)'g', (char)'b', (char)'e'};
#line 50  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static char ixgbe_driver_string[47U] = {(char)'I', (char)'n', (char)'t', (char)'e', (char)'l', (char)'(', (char)'R', (char)')', (char)' ', (char)'1', (char)'0', (char)' ', (char)'G', (char)'i', (char)'g', (char)'a', (char)'b', (char)'i', (char)'t', (char)' ', (char)'P', (char)'C', (char)'I', (char)' ', (char)'E', (char)'x', (char)'p', (char)'r', (char)'e', (char)'s', (char)'s', (char)' ', (char)'N', (char)'e', (char)'t', (char)'w', (char)'o', (char)'r', (char)'k', (char)' ', (char)'D', (char)'r', (char)'i', (char)'v', (char)'e', (char)'r'};
#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
char ixgbe_default_device_descr[39U] = {(char)'I', (char)'n', (char)'t', (char)'e', (char)'l', (char)'(', (char)'R', (char)')', (char)' ', (char)'1', (char)'0', (char)' ', (char)'G', (char)'i', (char)'g', (char)'a', (char)'b', (char)'i', (char)'t', (char)' ', (char)'N', (char)'e', (char)'t', (char)'w', (char)'o', (char)'r', (char)'k', (char)' ', (char)'C', (char)'o', (char)'n', (char)'n', (char)'e', (char)'c', (char)'t', (char)'i', (char)'o', (char)'n'};
#line 60  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
char ixgbe_driver_version[8U] = {(char)'5', (char)'.', (char)'1', (char)'.', (char)'0', (char)'-', (char)'k'};
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static char ixgbe_copyright[43U] = {(char)'C', (char)'o', (char)'p', (char)'y', (char)'r', (char)'i', (char)'g', (char)'h', (char)'t', (char)' ', (char)'(', (char)'c', (char)')', (char)' ', (char)'1', (char)'9', (char)'9', (char)'9', (char)'-', (char)'2', (char)'0', (char)'1', (char)'6', (char)' ', (char)'I', (char)'n', (char)'t', (char)'e', (char)'l', (char)' ', (char)'C', (char)'o', (char)'r', (char)'p', (char)'o', (char)'r', (char)'a', (char)'t', (char)'i', (char)'o', (char)'n', (char)'.'};
#line 64  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static char ixgbe_overheat_msg[153U] = {(char)'N', (char)'e', (char)'t', (char)'w', (char)'o', (char)'r', (char)'k', (char)' ', (char)'a', (char)'d', (char)'a', (char)'p', (char)'t', (char)'e', (char)'r', (char)' ', (char)'h', (char)'a', (char)'s', (char)' ', (char)'b', (char)'e', (char)'e', (char)'n', (char)' ', (char)'s', (char)'t', (char)'o', (char)'p', (char)'p', (char)'e', (char)'d', (char)' ', (char)'b', (char)'e', (char)'c', (char)'a', (char)'u', (char)'s', (char)'e', (char)' ', (char)'i', (char)'t', (char)' ', (char)'h', (char)'a', (char)'s', (char)' ', (char)'o', (char)'v', (char)'e', (char)'r', (char)' ', (char)'h', (char)'e', (char)'a', (char)'t', (char)'e', (char)'d', (char)'.', (char)' ', (char)'R', (char)'e', (char)'s', (char)'t', (char)'a', (char)'r', (char)'t', (char)' ', (char)'t', (char)'h', (char)'e', (char)' ', (char)'c', (char)'o', (char)'m', (char)'p', (char)'u', (char)'t', (char)'e', (char)'r', (char)'.', (char)' ', (char)'I', (char)'f', (char)' ', (char)'t', (char)'h', (char)'e', (char)' ', (char)'p', (char)'r', (char)'o', (char)'b', (char)'l', (char)'e', (char)'m', (char)' ', (char)'p', (char)'e', (char)'r', (char)'s', (char)'i', (char)'s', (char)'t', (char)'s', (char)',', (char)' ', (char)'p', (char)'o', (char)'w', (char)'e', (char)'r', (char)' ', (char)'o', (char)'f', (char)'f', (char)' ', (char)'t', (char)'h', (char)'e', (char)' ', (char)'s', (char)'y', (char)'s', (char)'t', (char)'e', (char)'m', (char)' ', (char)'a', (char)'n', (char)'d', (char)' ', (char)'r', (char)'e', (char)'p', (char)'l', (char)'a', (char)'c', (char)'e', (char)' ', (char)'t', (char)'h', (char)'e', (char)' ', (char)'a', (char)'d', (char)'a', (char)'p', (char)'t', (char)'e', (char)'r'};
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct ixgbe_info *ixgbe_info_tbl[8U] = {& ixgbe_82598_info, & ixgbe_82599_info, & ixgbe_X540_info, & ixgbe_X550_info, & ixgbe_X550EM_x_info, & ixgbe_x550em_x_fw_info, & ixgbe_x550em_a_info, & ixgbe_x550em_a_fw_info};
#line 85  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct pci_device_id ixgbe_pci_tbl[48U] = {{.vendor = 32902U, .device = 4278U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 4294U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 4295U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 4296U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 5387U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 4317U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 4332U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 4337U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 4321U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 4340U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 4315U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 5384U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 4343U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 1UL}, {.vendor = 32902U, .device = 4348U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 1UL}, {.vendor = 32902U, .device = 5399U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 1UL}, {.vendor = 32902U, .device = 4347U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 1UL}, {.vendor = 32902U, .device = 5383U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 1UL}, {.vendor = 32902U, .device = 5396U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 1UL}, {.vendor = 32902U, .device = 4345U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 1UL}, {.vendor = 32902U, .device = 5418U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 1UL}, {.vendor = 32902U, .device = 5417U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 1UL}, {.vendor = 32902U, .device = 5404U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 1UL}, {.vendor = 32902U, .device = 4344U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 1UL}, {.vendor = 32902U, .device = 5416U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 2UL}, {.vendor = 32902U, .device = 5453U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 1UL}, {.vendor = 32902U, .device = 5455U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 1UL}, {.vendor = 32902U, .device = 5464U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 1UL}, {.vendor = 32902U, .device = 5463U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 1UL}, {.vendor = 32902U, .device = 5450U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 1UL}, {.vendor = 32902U, .device = 5472U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 2UL}, {.vendor = 32902U, .device = 5475U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 3UL}, {.vendor = 32902U, .device = 5585U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 3UL}, {.vendor = 32902U, .device = 5546U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 4UL}, {.vendor = 32902U, .device = 5552U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 4UL}, {.vendor = 32902U, .device = 5547U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 4UL}, {.vendor = 32902U, .device = 5549U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 4UL}, {.vendor = 32902U, .device = 5548U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 4UL}, {.vendor = 32902U, .device = 5550U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 5UL}, {.vendor = 32902U, .device = 5570U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 6UL}, {.vendor = 32902U, .device = 5571U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 6UL}, {.vendor = 32902U, .device = 5572U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 6UL}, {.vendor = 32902U, .device = 5574U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 6UL}, {.vendor = 32902U, .device = 5575U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 6UL}, {.vendor = 32902U, .device = 5576U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 6UL}, {.vendor = 32902U, .device = 5582U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 6UL}, {.vendor = 32902U, .device = 5604U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 7UL}, {.vendor = 32902U, .device = 5605U, .subvendor = 4294967295U, .subdevice = 4294967295U, .driver_data = 7UL}};
#line 136  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
struct pci_device_id __mod_pci__ixgbe_pci_tbl_device_table[48U];
#line 139 
#line 11568 
static int ixgbe_notify_dca(struct notifier_block *nb, unsigned long event, void *p);
#line 141  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct notifier_block dca_notifier = {.notifier_call = & ixgbe_notify_dca};
#line 149  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static unsigned int max_vfs;
#line 155  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static unsigned int allow_unsupported_sfp;
#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int debug = -1;
#line 170  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct workqueue_struct *ixgbe_wq;
#line 172 
#line 366 
static bool ixgbe_check_cfg_remove(struct ixgbe_hw *hw, struct pci_dev *pdev);
#line 173 
#line 7511 
static void ixgbe_watchdog_link_is_down(struct ixgbe_adapter *adapter);
#line 175 
#line 10383 
static struct net_device_ops ixgbe_netdev_ops;
#line 177  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static bool netif_is_ixgbe(struct net_device *dev)
{
  #line 179 
  return (_Bool)((dev != (struct net_device *)0 && dev->netdev_ops == & ixgbe_netdev_ops) != 0);
}

#line 182  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_read_pci_cfg_word_parent(struct ixgbe_adapter *adapter, u32 reg, u16 *value)
{
  #line 185 
  struct pci_dev *parent_dev;
  #line 186 
  struct pci_bus *parent_bus;
  #line 188 
  parent_bus = ((adapter->pdev)->bus)->parent;
  #line 189 
  if (parent_bus == (struct pci_bus *)0) 
                                         #line 190 
                                         return -1;
  #line 192 
  parent_dev = parent_bus->self;
  #line 193 
  if (parent_dev == (struct pci_dev *)0) 
                                         #line 194 
                                         return -1;
  #line 196 
  if (! pci_is_pcie(parent_dev)) 
                                 #line 197 
                                 return -1;
  #line 199 
  pcie_capability_read_word(parent_dev,(int)reg,value);
  #line 200 
  if ((unsigned int)*value == 65535U) {
    #line 200 
    if ((int)ixgbe_check_cfg_remove(& adapter->hw,parent_dev) != 0) 
                                                                    #line 202 
                                                                    return -1;
  }
  #line 203 
  return 0;
}

#line 206  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static s32 ixgbe_get_parent_bus_info(struct ixgbe_adapter *adapter)
{
  #line 210 
  int err;
  #line 208 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 209 
  u16 link_status = (unsigned short)0U;
  #line 212 
  hw->bus.type = ixgbe_bus_type_pci_express;
  #line 217 
  err = ixgbe_read_pci_cfg_word_parent(adapter,18U,& link_status);
  #line 220 
  if (err != 0) 
                #line 221 
                return err;
  #line 223 
  hw->bus.width = ixgbe_convert_bus_width((unsigned short)((int)link_status));
  #line 224 
  hw->bus.speed = ixgbe_convert_bus_speed((unsigned short)((int)link_status));
  #line 226 
  return 0;
}

#line 238  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static bool ixgbe_pcie_from_parent(struct ixgbe_hw *hw)
{
  #line 240 
  switch ((int)hw->device_id) {
    #line 241 
    case 5450: 
               #line 241 
    ;
    #line 242 
    case 5464: 
               #line 242 
    ;
    #line 243 
    return (_Bool)1;
    #line 244 
    default: 
             #line 244 
    ;
    #line 245 
    return (_Bool)0;
  }
}

#line 249  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_minimum_link(struct ixgbe_adapter *adapter, int expected_gts)
{
  #line 253 
  struct pci_dev *pdev;
  #line 252 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 259 
  if (hw->bus.type == (unsigned int)ixgbe_bus_type_internal) 
                                                             #line 260 
                                                             return;
  #line 263 
  if ((int)ixgbe_pcie_from_parent(& adapter->hw) != 0) 
                                                       #line 264 
                                                       pdev = (((adapter->pdev)->bus)->parent)->self; else 
                                                                    #line 266 
                                                                    pdev = adapter->pdev;
  #line 268 
  pcie_print_link_status(pdev);
  #line 269 
  return;
}

#line 271  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_service_event_schedule(struct ixgbe_adapter *adapter)
{
  #line 273 
  if (! test_bit(2L,& adapter->state)) {
    #line 274 
    if (! test_bit(4L,& adapter->state)) {
      #line 275 
      if (! test_and_set_bit(5L,& adapter->state)) 
                                                   #line 276 
                                                   cif_queue_work(ixgbe_wq,& adapter->service_task);
    }
  }
  #line 277 
  return;
}

#line 279  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_remove_adapter(struct ixgbe_hw *hw)
{
  #line 281 
  struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)hw->back;
  #line 283 
  if (hw->hw_addr == (u8 *)0U) 
                               #line 284 
                               return;
  #line 285 
  hw->hw_addr = (u8 *)0U;
  #line 286 
  _dev_err(& (adapter->pdev)->dev,(char *)"Adapter removed\n");
  #line 287 
  if ((int)test_bit(6L,& adapter->state) != 0) 
                                               #line 288 
                                               ixgbe_service_event_schedule(adapter);
  #line 289 
  return;
}

#line 291  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static u32 ixgbe_check_remove(struct ixgbe_hw *hw, u32 reg)
{
  #line 298 
  union __anonunion___u_2629 __u;
  #line 293 
  u8 *reg_addr;
  #line 294 
  u32 value;
  #line 295 
  int i;
  #line 297 
  __read_once_size((void *)(& hw->hw_addr),(void *)(& __u.__c),8);
  #line 297 
  reg_addr = (__u.__val);
  #line 298 
  if ((int)ixgbe_removed((void *)reg_addr) != 0) 
                                                 #line 299 
                                                 return 4294967295U;
  #line 305 
  i = 0;
  #line 305 
  while (i <= 4) {
    #line 306 
    value = readl((void *)(reg_addr + 8U));
    #line 307 
    if (value != 4294967295U) 
                              #line 308 
                              break;
    #line 309 
    __const_udelay(12885000UL);
    #line 305 
    i ++;
  }
  #line 312 
  if (value == 4294967295U) 
                            #line 313 
                            ixgbe_remove_adapter(hw); else 
                                                           #line 315 
                                                           value = readl((void *)(reg_addr + (unsigned long)reg));
  #line 316 
  return value;
}

#line 332  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
u32 ixgbe_read_reg(struct ixgbe_hw *hw, u32 reg)
{
  #line 335 
  union __anonunion___u_2631 __u;
  #line 335 
  u32 value;
  #line 334 
  __read_once_size((void *)(& hw->hw_addr),(void *)(& __u.__c),8);
  #line 334 
  u8 *reg_addr = (__u.__val);
  #line 337 
  if ((int)ixgbe_removed((void *)reg_addr) != 0) 
                                                 #line 338 
                                                 return 4294967295U;
  #line 339 
  if ((long)(((unsigned long)hw->phy.nw_mng_if_sel & 33554432UL) != 0UL) != 0L) {
    #line 341 
    struct ixgbe_adapter *adapter;
    #line 342 
    int i;
    #line 344 
    i = 0;
    #line 344 
    while (i <= 199) {
      #line 345 
      value = readl((void *)(reg_addr + 17048U));
      #line 346 
      if ((long)(value == 0U) != 0L) 
                                     #line 347 
                                     goto writes_completed;
      #line 348 
      if (value == 4294967295U) {
        #line 349 
        ixgbe_remove_adapter(hw);
        #line 350 
        return 4294967295U;
      }
      #line 352 
      __const_udelay(21475UL);
      #line 344 
      i ++;
    }
    #line 355 
    adapter = (struct ixgbe_adapter *)hw->back;
    #line 356 
    if (((int)adapter->msg_enable & 8192) != 0) 
                                                #line 356 
                                                netdev_warn(adapter->netdev,(char *)"register writes incomplete %08x\n",value);
  }
  #line 359 
  writes_completed: 
                    #line 359 
  ;
  #line 360 
  value = readl((void *)(reg_addr + (unsigned long)reg));
  #line 361 
  if ((long)(value == 4294967295U) != 0L) 
                                          #line 362 
                                          value = ixgbe_check_remove(hw,reg);
  #line 363 
  return value;
}

#line 366  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static bool ixgbe_check_cfg_remove(struct ixgbe_hw *hw, struct pci_dev *pdev)
{
  #line 368 
  u16 value;
  #line 370 
  pci_read_config_word(pdev,0,& value);
  #line 371 
  if ((unsigned int)value == 65535U) {
    #line 372 
    ixgbe_remove_adapter(hw);
    #line 373 
    return (_Bool)1;
  }
  #line 375 
  return (_Bool)0;
}

#line 378  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
u16 ixgbe_read_pci_cfg_word(struct ixgbe_hw *hw, u32 reg)
{
  #line 381 
  u16 value;
  #line 380 
  struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)hw->back;
  #line 383 
  if ((int)ixgbe_removed((void *)hw->hw_addr) != 0) 
                                                    #line 384 
                                                    return (unsigned short)65535U;
  #line 385 
  pci_read_config_word(adapter->pdev,(int)reg,& value);
  #line 386 
  if ((unsigned int)value == 65535U) {
    #line 386 
    if ((int)ixgbe_check_cfg_remove(hw,adapter->pdev) != 0) 
                                                            #line 388 
                                                            return (unsigned short)65535U;
  }
  #line 389 
  return value;
}

#line 393  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static u32 ixgbe_read_pci_cfg_dword(struct ixgbe_hw *hw, u32 reg)
{
  #line 396 
  u32 value;
  #line 395 
  struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)hw->back;
  #line 398 
  if ((int)ixgbe_removed((void *)hw->hw_addr) != 0) 
                                                    #line 399 
                                                    return 4294967295U;
  #line 400 
  pci_read_config_dword(adapter->pdev,(int)reg,& value);
  #line 401 
  if (value == 4294967295U) {
    #line 401 
    if ((int)ixgbe_check_cfg_remove(hw,adapter->pdev) != 0) 
                                                            #line 403 
                                                            return 4294967295U;
  }
  #line 404 
  return value;
}

#line 408  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_write_pci_cfg_word(struct ixgbe_hw *hw, u32 reg, u16 value)
{
  #line 410 
  struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)hw->back;
  #line 412 
  if ((int)ixgbe_removed((void *)hw->hw_addr) != 0) 
                                                    #line 413 
                                                    return;
  #line 414 
  pci_write_config_word(adapter->pdev,(int)reg,(unsigned short)((int)value));
  #line 415 
  return;
}

#line 417  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_service_event_complete(struct ixgbe_adapter *adapter)
{
  #line 419 
  int tmp_0;
  #line 419 
  if (test_bit(5L,& adapter->state)) 
                                     #line 419 
                                     tmp_0 = 0; else 
                                                     #line 419 
                                                     tmp_0 = 1;
  #line 419 
  if ((long)tmp_0 != 0L) {
    #line 420 
    ldv_inline_asm();
    #line 421 
    ldv_inline_asm();
    #line 422 
    ldv_inline_asm();
    #line 419 
    ;
  }
  #line 423 
  cif_clear_bit(5L,& adapter->state);
  #line 424 
  return;
}

#line 431  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct ixgbe_reg_info ixgbe_reg_info_tbl[19U] = {{.name = (char *)"CTRL"}, {.ofs = 8U, .name = (char *)"STATUS"}, {.ofs = 24U, .name = (char *)"CTRL_EXT"}, {.ofs = 2048U, .name = (char *)"EICR"}, {.ofs = 8448U, .name = (char *)"SRRCTL"}, {.ofs = 8704U, .name = (char *)"DRXCTL"}, {.ofs = 4104U, .name = (char *)"RDLEN"}, {.ofs = 4112U, .name = (char *)"RDH"}, {.ofs = 4120U, .name = (char *)"RDT"}, {.ofs = 4136U, .name = (char *)"RXDCTL"}, {.ofs = 4096U, .name = (char *)"RDBAL"}, {.ofs = 4100U, .name = (char *)"RDBAH"}, {.ofs = 24576U, .name = (char *)"TDBAL"}, {.ofs = 24580U, .name = (char *)"TDBAH"}, {.ofs = 24584U, .name = (char *)"TDLEN"}, {.ofs = 24592U, .name = (char *)"TDH"}, {.ofs = 24600U, .name = (char *)"TDT"}, {.ofs = 24616U, .name = (char *)"TXDCTL"}};
#line 467  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_regdump(struct ixgbe_hw *hw, struct ixgbe_reg_info *reginfo)
{
  #line 469 
  int i;
  #line 470 
  char rname[16U];
  #line 471 
  u32 regs[64U];
  #line 473 
  switch (reginfo->ofs) {
    #line 474 
    case (u32)8448: 
                    #line 474 
    ;
    #line 475 
    i = 0;
    #line 475 
    while (i <= 63) {
      #line 476 
      int tmp_0;
      #line 476 
      if (i <= 15) 
                   #line 476 
                   tmp_0 = (i + 2112) * 4;
      else {
        #line 476 
        int tmp;
        #line 476 
        if (i <= 63) 
                     #line 476 
                     tmp = i * 64 + 4116; else 
                                               #line 476 
                                               tmp = (i + -64) * 64 + 53268;
        #line 476 
        tmp_0 = tmp;
      }
      #line 476 
      ;
      #line 476 
      regs[i] = ixgbe_read_reg(hw,(unsigned int)tmp_0);
      #line 475 
      i ++;
    }
    #line 477 
    break;
    #line 478 
    case (u32)8704: 
                    #line 478 
    ;
    #line 479 
    i = 0;
    #line 479 
    while (i <= 63) {
      #line 480 
      int tmp_2;
      #line 480 
      if (i <= 15) 
                   #line 480 
                   tmp_2 = (i + 2176) * 4;
      else {
        #line 480 
        int tmp_1;
        #line 480 
        if (i <= 63) 
                     #line 480 
                     tmp_1 = i * 64 + 4108; else 
                                                 #line 480 
                                                 tmp_1 = (i + -64) * 64 + 53260;
        #line 480 
        tmp_2 = tmp_1;
      }
      #line 480 
      ;
      #line 480 
      regs[i] = ixgbe_read_reg(hw,(unsigned int)tmp_2);
      #line 479 
      i ++;
    }
    #line 481 
    break;
    #line 482 
    case (u32)4104: 
                    #line 482 
    ;
    #line 483 
    i = 0;
    #line 483 
    while (i <= 63) {
      #line 484 
      int tmp_3;
      #line 484 
      if (i <= 63) 
                   #line 484 
                   tmp_3 = i * 64 + 4104; else 
                                               #line 484 
                                               tmp_3 = (i + -64) * 64 + 53256;
      #line 484 
      ;
      #line 484 
      regs[i] = ixgbe_read_reg(hw,(unsigned int)tmp_3);
      #line 483 
      i ++;
    }
    #line 485 
    break;
    #line 486 
    case (u32)4112: 
                    #line 486 
    ;
    #line 487 
    i = 0;
    #line 487 
    while (i <= 63) {
      #line 488 
      int tmp_4;
      #line 488 
      if (i <= 63) 
                   #line 488 
                   tmp_4 = i * 64 + 4112; else 
                                               #line 488 
                                               tmp_4 = (i + -64) * 64 + 53264;
      #line 488 
      ;
      #line 488 
      regs[i] = ixgbe_read_reg(hw,(unsigned int)tmp_4);
      #line 487 
      i ++;
    }
    #line 489 
    break;
    #line 490 
    case (u32)4120: 
                    #line 490 
    ;
    #line 491 
    i = 0;
    #line 491 
    while (i <= 63) {
      #line 492 
      int tmp_5;
      #line 492 
      if (i <= 63) 
                   #line 492 
                   tmp_5 = i * 64 + 4120; else 
                                               #line 492 
                                               tmp_5 = (i + -64) * 64 + 53272;
      #line 492 
      ;
      #line 492 
      regs[i] = ixgbe_read_reg(hw,(unsigned int)tmp_5);
      #line 491 
      i ++;
    }
    #line 493 
    break;
    #line 494 
    case (u32)4136: 
                    #line 494 
    ;
    #line 495 
    i = 0;
    #line 495 
    while (i <= 63) {
      #line 496 
      int tmp_6;
      #line 496 
      if (i <= 63) 
                   #line 496 
                   tmp_6 = i * 64 + 4136; else 
                                               #line 496 
                                               tmp_6 = (i + -64) * 64 + 53288;
      #line 496 
      ;
      #line 496 
      regs[i] = ixgbe_read_reg(hw,(unsigned int)tmp_6);
      #line 495 
      i ++;
    }
    #line 497 
    break;
    #line 498 
    case (u32)4096: 
                    #line 498 
    ;
    #line 499 
    i = 0;
    #line 499 
    while (i <= 63) {
      #line 500 
      int tmp_7;
      #line 500 
      if (i <= 63) 
                   #line 500 
                   tmp_7 = (i + 64) * 64; else 
                                               #line 500 
                                               tmp_7 = (i + 768) * 64;
      #line 500 
      ;
      #line 500 
      regs[i] = ixgbe_read_reg(hw,(unsigned int)tmp_7);
      #line 499 
      i ++;
    }
    #line 501 
    break;
    #line 502 
    case (u32)4100: 
                    #line 502 
    ;
    #line 503 
    i = 0;
    #line 503 
    while (i <= 63) {
      #line 504 
      int tmp_8;
      #line 504 
      if (i <= 63) 
                   #line 504 
                   tmp_8 = i * 64 + 4100; else 
                                               #line 504 
                                               tmp_8 = (i + -64) * 64 + 53252;
      #line 504 
      ;
      #line 504 
      regs[i] = ixgbe_read_reg(hw,(unsigned int)tmp_8);
      #line 503 
      i ++;
    }
    #line 505 
    break;
    #line 506 
    case (u32)24576: 
                     #line 506 
    ;
    #line 507 
    i = 0;
    #line 507 
    while (i <= 63) {
      #line 508 
      regs[i] = ixgbe_read_reg(hw,(unsigned int)((i + 384) * 64));
      #line 507 
      i ++;
    }
    #line 509 
    break;
    #line 510 
    case (u32)24580: 
                     #line 510 
    ;
    #line 511 
    i = 0;
    #line 511 
    while (i <= 63) {
      #line 512 
      regs[i] = ixgbe_read_reg(hw,(unsigned int)(i * 64 + 24580));
      #line 511 
      i ++;
    }
    #line 513 
    break;
    #line 514 
    case (u32)24584: 
                     #line 514 
    ;
    #line 515 
    i = 0;
    #line 515 
    while (i <= 63) {
      #line 516 
      regs[i] = ixgbe_read_reg(hw,(unsigned int)(i * 64 + 24584));
      #line 515 
      i ++;
    }
    #line 517 
    break;
    #line 518 
    case (u32)24592: 
                     #line 518 
    ;
    #line 519 
    i = 0;
    #line 519 
    while (i <= 63) {
      #line 520 
      regs[i] = ixgbe_read_reg(hw,(unsigned int)(i * 64 + 24592));
      #line 519 
      i ++;
    }
    #line 521 
    break;
    #line 522 
    case (u32)24600: 
                     #line 522 
    ;
    #line 523 
    i = 0;
    #line 523 
    while (i <= 63) {
      #line 524 
      regs[i] = ixgbe_read_reg(hw,(unsigned int)(i * 64 + 24600));
      #line 523 
      i ++;
    }
    #line 525 
    break;
    #line 526 
    case (u32)24616: 
                     #line 526 
    ;
    #line 527 
    i = 0;
    #line 527 
    while (i <= 63) {
      #line 528 
      regs[i] = ixgbe_read_reg(hw,(unsigned int)(i * 64 + 24616));
      #line 527 
      i ++;
    }
    #line 529 
    break;
    #line 530 
    default: 
             #line 530 
    ;
    #line 531 
    ;
    #line 531 
    printk((char *)"\001",reginfo->name,ixgbe_read_reg(hw,reginfo->ofs));
    #line 533 
    return;
  }
  #line 536 
  i = 0;
  #line 537 
  while (i <= 63) {
    #line 538 
    int j;
    #line 539 
    char buf[73U];
    #line 540 
    char *p = (char *)(& buf);
    #line 542 
    snprintf((char *)(& rname),16UL,(char *)"%s[%d-%d]",reginfo->name,i,i + 7);
    #line 543 
    j = 0;
    #line 543 
    while (j <= 7) {
      #line 544 
      int tmp_10;
      #line 544 
      tmp_10 = i;
      #line 544 
      i ++;
      #line 544 
      ;
      #line 544 
      p += (unsigned long)sprintf(p,(char *)" %08x",regs[tmp_10]);
      #line 543 
      j ++;
    }
    #line 545 
    printk((char *)"\001",(char *)(& rname),(char *)(& buf));
  }
  #line 547 
  return;
}

#line 550  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_print_buffer(struct ixgbe_ring *ring, int n)
{
  #line 552 
  struct ixgbe_tx_buffer *tx_buffer;
  #line 554 
  tx_buffer = ring->__anonCompField_ixgbe_ring_221.tx_buffer_info + (unsigned long)ring->next_to_clean;
  #line 555 
  printk((char *)"\001",n,(int)ring->next_to_use,(int)ring->next_to_clean,tx_buffer->dma,tx_buffer->len,tx_buffer->next_to_watch,(unsigned long long)tx_buffer->time_stamp);
  #line 556 
  return;
}

#line 566  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_dump(struct ixgbe_adapter *adapter)
{
  #line 570 
  struct ixgbe_reg_info *reginfo;
  #line 572 
  struct ixgbe_ring *ring;
  #line 573 
  struct ixgbe_tx_buffer *tx_buffer;
  #line 574 
  union ixgbe_adv_tx_desc *tx_desc;
  #line 575 
  struct my_u0 *u0;
  #line 576 
  struct ixgbe_ring *rx_ring;
  #line 577 
  union ixgbe_adv_rx_desc *rx_desc;
  #line 578 
  struct ixgbe_rx_buffer *rx_buffer_info;
  #line 568 
  struct net_device *netdev = adapter->netdev;
  #line 569 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 571 
  int n = 0;
  #line 579 
  int i = 0;
  #line 581 
  if (((int)adapter->msg_enable & 8192) == 0) 
                                              #line 582 
                                              return;
  #line 585 
  if (netdev != (struct net_device *)0) {
    #line 586 
    _dev_info(& (adapter->pdev)->dev,(char *)"Net device Info\n");
    #line 587 
    printk((char *)"\001");
    #line 589 
    ;
    #line 589 
    ;
    #line 589 
    printk((char *)"\001",(char *)(& netdev->name),netdev->state,dev_trans_start(netdev));
  }
  #line 596 
  _dev_info(& (adapter->pdev)->dev,(char *)"Register Dump\n");
  #line 597 
  printk((char *)"\001");
  #line 598 
  reginfo = (struct ixgbe_reg_info *)(& ixgbe_reg_info_tbl);
  #line 598 
  while (reginfo->name != (char *)0) {
    #line 600 
    ixgbe_regdump(hw,reginfo);
    #line 599 
    reginfo ++;
  }
  #line 604 
  if (netdev == (struct net_device *)0) 
                                        #line 605 
                                        return;
  else {
    #line 604 
    if (! netif_running(netdev)) 
                                 #line 605 
                                 return;
  }
  #line 607 
  _dev_info(& (adapter->pdev)->dev,(char *)"TX Rings Summary\n");
  #line 608 
  printk((char *)"\001",(char *)"Queue [NTU] [NTC] [bi(ntc)->dma  ]",(char *)"leng",(char *)"ntw",(char *)"timestamp");
  #line 611 
  n = 0;
  #line 611 
  while (adapter->num_tx_queues > n) {
    #line 612 
    ring = adapter->tx_ring[n];
    #line 613 
    ixgbe_print_buffer(ring,n);
    #line 611 
    n ++;
  }
  #line 616 
  n = 0;
  #line 616 
  while (adapter->num_xdp_queues > n) {
    #line 617 
    ring = adapter->xdp_ring[n];
    #line 618 
    ixgbe_print_buffer(ring,n);
    #line 616 
    n ++;
  }
  #line 622 
  if (((int)adapter->msg_enable & 1024) == 0) 
                                              #line 623 
                                              goto rx_ring_summary;
  #line 625 
  _dev_info(& (adapter->pdev)->dev,(char *)"TX Rings Dump\n");
  #line 662 
  n = 0;
  #line 662 
  while (adapter->num_tx_queues > n) {
    #line 663 
    ring = adapter->tx_ring[n];
    #line 664 
    printk((char *)"\001");
    #line 665 
    printk((char *)"\001",(int)ring->queue_index);
    #line 666 
    printk((char *)"\001");
    #line 667 
    printk((char *)"\001",(char *)"T [desc]     [address 63:0  ] ",(char *)"[PlPOIdStDDt Ln] [bi->dma       ] ",(char *)"leng",(char *)"ntw",(char *)"timestamp",(char *)"bi->skb");
    #line 672 
    i = 0;
    #line 672 
    while (ring->desc != (void *)0 && (int)ring->count > i) {
      #line 673 
      tx_desc = (union ixgbe_adv_tx_desc *)ring->desc + (unsigned long)i;
      #line 674 
      tx_buffer = ring->__anonCompField_ixgbe_ring_221.tx_buffer_info + (unsigned long)i;
      #line 675 
      u0 = (struct my_u0 *)tx_desc;
      #line 676 
      if (tx_buffer->len != 0U) {
        #line 677 
        char *ring_desc;
        #line 679 
        if ((int)ring->next_to_use == i && (int)ring->next_to_clean == i) 
          #line 681 
          ring_desc = (char *)" NTC/U";
        else 
          #line 682 
          if ((int)ring->next_to_use == i) 
                                           #line 683 
                                           ring_desc = (char *)" NTU";
          else 
            #line 684 
            if ((int)ring->next_to_clean == i) 
                                               #line 685 
                                               ring_desc = (char *)" NTC"; else 
                                                                    #line 687 
                                                                    ring_desc = (char *)"";
        #line 688 
        printk((char *)"\001",i,u0->a,u0->b,tx_buffer->dma,tx_buffer->len,tx_buffer->next_to_watch,(unsigned long long)tx_buffer->time_stamp,tx_buffer->__anonCompField_ixgbe_tx_buffer_217.skb,ring_desc);
        #line 699 
        if (((int)adapter->msg_enable & 4096) != 0 && tx_buffer->__anonCompField_ixgbe_tx_buffer_217.skb != (struct sk_buff *)0) 
          #line 701 
          print_hex_dump((char *)"\001",(char *)"",1,16,1,(void *)(tx_buffer->__anonCompField_ixgbe_tx_buffer_217.skb)->data,(unsigned long)tx_buffer->len,(_Bool)1);
      }
      #line 672 
      i ++;
    }
    #line 662 
    n ++;
  }
  #line 711 
  rx_ring_summary: 
                   #line 711 
  ;
  #line 712 
  _dev_info(& (adapter->pdev)->dev,(char *)"RX Rings Summary\n");
  #line 713 
  printk((char *)"\001");
  #line 714 
  n = 0;
  #line 714 
  while (adapter->num_rx_queues > n) {
    #line 715 
    rx_ring = adapter->rx_ring[n];
    #line 716 
    printk((char *)"\001",n,(int)rx_ring->next_to_use,(int)rx_ring->next_to_clean);
    #line 714 
    n ++;
  }
  #line 721 
  if (((int)adapter->msg_enable & 2048) == 0) 
                                              #line 722 
                                              return;
  #line 724 
  _dev_info(& (adapter->pdev)->dev,(char *)"RX Rings Dump\n");
  #line 771 
  n = 0;
  #line 771 
  while (adapter->num_rx_queues > n) {
    #line 772 
    rx_ring = adapter->rx_ring[n];
    #line 773 
    printk((char *)"\001");
    #line 774 
    printk((char *)"\001",(int)rx_ring->queue_index);
    #line 775 
    printk((char *)"\001");
    #line 776 
    printk((char *)"\001",(char *)"R  [desc]      [ PktBuf     A0] ",(char *)"[  HeadBuf   DD] [bi->dma       ] [bi->skb       ] ",(char *)"<-- Adv Rx Read format");
    #line 780 
    printk((char *)"\001",(char *)"RWB[desc]      [PcsmIpSHl PtRs] ",(char *)"[vl er S cks ln] ---------------- [bi->skb       ] ",(char *)"<-- Adv Rx Write-Back format");
    #line 785 
    i = 0;
    #line 785 
    while ((int)rx_ring->count > i) {
      {
        #line 786 
        char *ring_desc_0;
        #line 788 
        if ((int)rx_ring->next_to_use == i) 
                                            #line 789 
                                            ring_desc_0 = (char *)" NTU";
        else 
          #line 790 
          if ((int)rx_ring->next_to_clean == i) 
                                                #line 791 
                                                ring_desc_0 = (char *)" NTC"; else 
                                                                    #line 793 
                                                                    ring_desc_0 = (char *)"";
        #line 795 
        rx_buffer_info = rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info + (unsigned long)i;
        #line 796 
        rx_desc = (union ixgbe_adv_rx_desc *)rx_ring->desc + (unsigned long)i;
        #line 797 
        u0 = (struct my_u0 *)rx_desc;
        #line 798 
        if ((unsigned int)rx_desc->wb.upper.length != 0U) 
                                                          #line 800 
                                                          printk((char *)"\001",i,u0->a,u0->b,rx_buffer_info->skb,ring_desc_0);
        else {
          #line 807 
          printk((char *)"\001",i,u0->a,u0->b,rx_buffer_info->dma,rx_buffer_info->skb,ring_desc_0);
          #line 815 
          if (((int)adapter->msg_enable & 4096) != 0 && rx_buffer_info->dma != 0ULL) {
            #line 817 
            ;
            #line 817 
            print_hex_dump((char *)"\001",(char *)"",1,16,1,lowmem_page_address(rx_buffer_info->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page) + (unsigned long)rx_buffer_info->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page_offset,(unsigned long)ixgbe_rx_bufsz(rx_ring),(_Bool)1);
          }
        }
      }
      #line 785 
      i ++;
    }
    #line 771 
    n ++;
  }
  #line 825 
  return;
}

#line 828  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_release_hw_control(struct ixgbe_adapter *adapter)
{
  #line 830 
  u32 ctrl_ext;
  #line 833 
  ctrl_ext = ixgbe_read_reg(& adapter->hw,24U);
  #line 834 
  ixgbe_write_reg_1(& adapter->hw,24U,ctrl_ext & 4026531839U);
  #line 835 
  return;
}

#line 838  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_get_hw_control(struct ixgbe_adapter *adapter)
{
  #line 840 
  u32 ctrl_ext;
  #line 843 
  ctrl_ext = ixgbe_read_reg(& adapter->hw,24U);
  #line 844 
  ixgbe_write_reg_1(& adapter->hw,24U,ctrl_ext | 268435456U);
  #line 845 
  return;
}

#line 856  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_set_ivar(struct ixgbe_adapter *adapter, s8 direction, u8 queue, u8 msix_vector)
{
  #line 859 
  u32 ivar;
  #line 859 
  u32 index;
  #line 860 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 861 
  switch ((unsigned int)hw->mac.type) {
    #line 862 
    case (unsigned int)1: 
                          #line 862 
    ;
    #line 863 
    msix_vector = (unsigned char)((unsigned int)msix_vector | 128U);
    #line 864 
    if ((int)direction == -1) 
                              #line 865 
                              direction = (signed char)0;
    #line 866 
    index = (unsigned int)(((int)direction * 64 + (int)queue) >> 2) & 31U;
    #line 867 
    ivar = ixgbe_read_reg(hw,(index + 576U) * 4U);
    #line 868 
    ivar = (unsigned int)(~ (255 << ((int)queue & 3) * 8)) & ivar;
    #line 869 
    ivar = (unsigned int)((int)msix_vector << ((int)queue & 3) * 8) | ivar;
    #line 870 
    ixgbe_write_reg_1(hw,(index + 576U) * 4U,ivar);
    #line 871 
    break;
    #line 872 
    case (unsigned int)2: 
                          #line 872 
    ;
    #line 873 
    case (unsigned int)3: 
                          #line 873 
    ;
    #line 874 
    case (unsigned int)4: 
                          #line 874 
    ;
    #line 875 
    case (unsigned int)5: 
                          #line 875 
    ;
    #line 876 
    case (unsigned int)6: 
                          #line 876 
    ;
    #line 877 
    if ((int)direction == -1) {
      #line 879 
      msix_vector = (unsigned char)((unsigned int)msix_vector | 128U);
      #line 880 
      index = (unsigned int)(((int)queue & 1) * 8);
      #line 881 
      ivar = ixgbe_read_reg(& adapter->hw,2560U);
      #line 882 
      ivar = (unsigned int)(~ (255 << index)) & ivar;
      #line 883 
      ivar = (unsigned int)((int)msix_vector << index) | ivar;
      #line 884 
      ixgbe_write_reg_1(& adapter->hw,2560U,ivar);
      #line 885 
      break;
    }
    else {
      #line 888 
      msix_vector = (unsigned char)((unsigned int)msix_vector | 128U);
      #line 889 
      index = (unsigned int)((((int)queue & 1) * 2 + (int)direction) * 8);
      #line 890 
      ivar = ixgbe_read_reg(hw,(unsigned int)((((int)queue >> 1) + 576) * 4));
      #line 891 
      ivar = (unsigned int)(~ (255 << index)) & ivar;
      #line 892 
      ivar = (unsigned int)((int)msix_vector << index) | ivar;
      #line 893 
      ixgbe_write_reg_1(hw,(unsigned int)((((int)queue >> 1) + 576) * 4),ivar);
      #line 894 
      break;
    }
    #line 896 
    default: 
             #line 896 
    ;
    #line 897 
    break;
  }
  #line 899 
  return;
}

#line 901  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_irq_rearm_queues(struct ixgbe_adapter *adapter, u64 qmask)
{
  #line 904 
  u32 mask;
  #line 906 
  switch ((unsigned int)adapter->hw.mac.type) {
    #line 907 
    case (unsigned int)1: 
                          #line 907 
    ;
    #line 908 
    mask = (unsigned int)qmask & 65535U;
    #line 909 
    ixgbe_write_reg_1(& adapter->hw,2056U,mask);
    #line 910 
    break;
    #line 911 
    case (unsigned int)2: 
                          #line 911 
    ;
    #line 912 
    case (unsigned int)3: 
                          #line 912 
    ;
    #line 913 
    case (unsigned int)4: 
                          #line 913 
    ;
    #line 914 
    case (unsigned int)5: 
                          #line 914 
    ;
    #line 915 
    case (unsigned int)6: 
                          #line 915 
    ;
    #line 916 
    mask = (unsigned int)qmask;
    #line 917 
    ixgbe_write_reg_1(& adapter->hw,2704U,mask);
    #line 918 
    mask = (unsigned int)(qmask >> 32);
    #line 919 
    ixgbe_write_reg_1(& adapter->hw,2708U,mask);
    #line 920 
    break;
    #line 921 
    default: 
             #line 921 
    ;
    #line 922 
    break;
  }
  #line 924 
  return;
}

#line 926  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_update_xoff_rx_lfc(struct ixgbe_adapter *adapter)
{
  #line 930 
  int i;
  #line 931 
  u32 data;
  #line 928 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 929 
  struct ixgbe_hw_stats *hwstats = & adapter->stats;
  #line 933 
  if (hw->fc.current_mode != (unsigned int)ixgbe_fc_full && hw->fc.current_mode != (unsigned int)ixgbe_fc_rx_pause) 
    #line 935 
    return;
  #line 937 
  switch ((unsigned int)hw->mac.type) {
    #line 938 
    case (unsigned int)1: 
                          #line 938 
    ;
    #line 939 
    data = ixgbe_read_reg(hw,53096U);
    #line 940 
    break;
    #line 941 
    default: 
             #line 941 
    ;
    #line 942 
    data = ixgbe_read_reg(hw,16808U);
  }
  #line 944 
  hwstats->lxoffrxc += (unsigned long long)data;
  #line 947 
  if (data == 0U) 
                  #line 948 
                  return;
  #line 950 
  i = 0;
  #line 950 
  while (adapter->num_tx_queues > i) {
    #line 951 
    cif_clear_bit(8L,& (adapter->tx_ring[i])->state);
    #line 950 
    i ++;
  }
  #line 954 
  i = 0;
  #line 954 
  while (adapter->num_xdp_queues > i) {
    #line 955 
    cif_clear_bit(8L,& (adapter->xdp_ring[i])->state);
    #line 954 
    i ++;
  }
  #line 957 
  return;
}

#line 959  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_update_xoff_received(struct ixgbe_adapter *adapter)
{
  #line 964 
  u8 tc;
  #line 965 
  int i;
  #line 961 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 962 
  struct ixgbe_hw_stats *hwstats = & adapter->stats;
  #line 963 
  u32 xoff[8U] = {0U};
  #line 966 
  bool pfc_en = adapter->dcb_cfg.pfc_mode_enable;
  #line 968 
  if (adapter->ixgbe_ieee_pfc != (struct ieee_pfc *)0) 
                                                       #line 969 
                                                       pfc_en = (_Bool)(((int)pfc_en | ((unsigned int)(adapter->ixgbe_ieee_pfc)->pfc_en != 0U)) != 0);
  #line 971 
  if (((unsigned long)adapter->flags & 4096UL) == 0UL || ! pfc_en) {
    #line 972 
    ixgbe_update_xoff_rx_lfc(adapter);
    #line 973 
    return;
  }
  #line 977 
  i = 0;
  #line 977 
  while (1) {
    #line 977 
    int tmp_0;
    #line 977 
    if (((unsigned long)adapter->flags & 4096UL) != 0UL) 
                                                         #line 977 
                                                         tmp_0 = 8; else 
                                                                    #line 977 
                                                                    tmp_0 = 1;
    #line 977 
    ;
    #line 977 
    if (! (tmp_0 > i)) 
                       #line 977 
                       break;
    {
      #line 978 
      u32 pxoffrxc;
      #line 980 
      switch ((unsigned int)hw->mac.type) {
        #line 981 
        case (unsigned int)1: 
                              #line 981 
        ;
        #line 982 
        pxoffrxc = ixgbe_read_reg(hw,(unsigned int)((i + 13256) * 4));
        #line 983 
        break;
        #line 984 
        default: 
                 #line 984 
        ;
        #line 985 
        pxoffrxc = ixgbe_read_reg(hw,(unsigned int)((i + 4184) * 4));
      }
      #line 987 
      hwstats->pxoffrxc[i] += (unsigned long long)pxoffrxc;
      #line 989 
      tc = (unsigned char)netdev_get_prio_tc_map(adapter->netdev,(unsigned int)i);
      #line 990 
      xoff[(int)tc] += pxoffrxc;
    }
    #line 977 
    i ++;
  }
  #line 994 
  i = 0;
  #line 994 
  while (adapter->num_tx_queues > i) {
    {
      #line 995 
      struct ixgbe_ring *tx_ring = adapter->tx_ring[i];
      #line 997 
      tc = tx_ring->dcb_tc;
      #line 998 
      if (xoff[(int)tc] != 0U) 
                               #line 999 
                               cif_clear_bit(8L,& tx_ring->state);
    }
    #line 994 
    i ++;
  }
  #line 1002 
  i = 0;
  #line 1002 
  while (adapter->num_xdp_queues > i) {
    {
      #line 1003 
      struct ixgbe_ring *xdp_ring = adapter->xdp_ring[i];
      #line 1005 
      tc = xdp_ring->dcb_tc;
      #line 1006 
      if (xoff[(int)tc] != 0U) 
                               #line 1007 
                               cif_clear_bit(8L,& xdp_ring->state);
    }
    #line 1002 
    i ++;
  }
  #line 1009 
  return;
}

#line 1011  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static u64 ixgbe_get_tx_completed(struct ixgbe_ring *ring)
{
  #line 1013 
  return ring->stats.packets;
}

#line 1016  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static u64 ixgbe_get_tx_pending(struct ixgbe_ring *ring)
{
  #line 1018 
  unsigned int head;
  #line 1018 
  unsigned int tail;
  #line 1023 
  unsigned int tmp;
  #line 1020 
  head = (unsigned int)ring->next_to_clean;
  #line 1021 
  tail = (unsigned int)ring->next_to_use;
  #line 1023 
  if (head > tail) 
                   #line 1023 
                   tmp = (unsigned int)ring->count + tail; else 
                                                                #line 1023 
                                                                tmp = tail;
  #line 1023 
  ;
  #line 1023 
  return (unsigned long long)(tmp - head);
}

#line 1026  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static bool ixgbe_check_tx_hang(struct ixgbe_ring *tx_ring)
{
  #line 1028 
  u32 tx_done = (unsigned int)ixgbe_get_tx_completed(tx_ring);
  #line 1029 
  u32 tx_done_old = (unsigned int)tx_ring->__anonCompField_ixgbe_ring_224.tx_stats.tx_done_old;
  #line 1030 
  u32 tx_pending = (unsigned int)ixgbe_get_tx_pending(tx_ring);
  #line 1032 
  cif_clear_bit(7L,& tx_ring->state);
  #line 1046 
  if (tx_done_old == tx_done && tx_pending != 0U) {
    #line 1048 
    return test_and_set_bit(8L,& tx_ring->state);
  }
  #line 1051 
  tx_ring->__anonCompField_ixgbe_ring_224.tx_stats.tx_done_old = (unsigned long long)tx_done;
  #line 1053 
  cif_clear_bit(8L,& tx_ring->state);
  #line 1055 
  return (_Bool)0;
}

#line 1062  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_tx_timeout_reset(struct ixgbe_adapter *adapter)
{
  #line 1066 
  if (! test_bit(2L,& adapter->state)) {
    #line 1067 
    cif_set_bit(10L,& adapter->state);
    #line 1068 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 1068 
                                             netdev_warn(adapter->netdev,(char *)"initiating reset due to tx timeout\n");
    #line 1069 
    ixgbe_service_event_schedule(adapter);
  }
  #line 1071 
  return;
}

#line 1079  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_tx_maxrate(struct net_device *netdev, int queue_index, u32 maxrate)
{
  #line 1082 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 1083 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 1084 
  u32 bcnrc_val = (unsigned int)ixgbe_link_mbps(adapter);
  #line 1086 
  if (maxrate == 0U) 
                     #line 1087 
                     return 0;
  #line 1090 
  bcnrc_val <<= 14;
  #line 1091 
  bcnrc_val /= maxrate;
  #line 1094 
  bcnrc_val &= 268435455U;
  #line 1098 
  bcnrc_val |= 2147483648U;
  #line 1100 
  ixgbe_write_reg_1(hw,18692U,(unsigned int)queue_index);
  #line 1101 
  ixgbe_write_reg_1(hw,18820U,bcnrc_val);
  #line 1103 
  return 0;
}

#line 1112  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector, struct ixgbe_ring *tx_ring, int napi_budget)
{
  #line 1116 
  struct ixgbe_tx_buffer *tx_buffer;
  #line 1117 
  union ixgbe_adv_tx_desc *tx_desc;
  #line 1255 
  int tmp_13;
  #line 1115 
  struct ixgbe_adapter *adapter = q_vector->adapter;
  #line 1118 
  unsigned int total_bytes = 0U;
  #line 1118 
  unsigned int total_packets = 0U;
  #line 1118 
  unsigned int total_ipsec = 0U;
  #line 1119 
  unsigned int budget = (unsigned int)q_vector->tx.work_limit;
  #line 1120 
  unsigned int i = (unsigned int)tx_ring->next_to_clean;
  #line 1122 
  if ((int)test_bit(2L,& adapter->state) != 0) 
                                               #line 1123 
                                               return (_Bool)1;
  #line 1125 
  tx_buffer = tx_ring->__anonCompField_ixgbe_ring_221.tx_buffer_info + (unsigned long)i;
  #line 1126 
  tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc + (unsigned long)i;
  #line 1127 
  i -= (unsigned int)tx_ring->count;
  #line 1129 
  while (1) {
    {
      #line 1130 
      union ixgbe_adv_tx_desc *eop_desc = tx_buffer->next_to_watch;
      #line 1133 
      if (eop_desc == (union ixgbe_adv_tx_desc *)0) 
                                                    #line 1134 
                                                    break;
      #line 1135 
      ldv_inline_asm();
      #line 1140 
      if ((eop_desc->wb.status & 1U) == 0U) 
                                            #line 1141 
                                            break;
      #line 1144 
      tx_buffer->next_to_watch = (union ixgbe_adv_tx_desc *)0;
      #line 1147 
      total_bytes = tx_buffer->bytecount + total_bytes;
      #line 1148 
      total_packets = (unsigned int)tx_buffer->gso_segs + total_packets;
      #line 1149 
      if ((tx_buffer->tx_flags & 64U) != 0U) 
                                             #line 1150 
                                             total_ipsec ++;
      #line 1153 
      if ((int)test_bit(9L,& tx_ring->state) != 0) 
                                                   #line 1154 
                                                   xdp_return_frame(tx_buffer->__anonCompField_ixgbe_tx_buffer_217.xdpf); else 
                                                                    #line 1156 
                                                                    napi_consume_skb(tx_buffer->__anonCompField_ixgbe_tx_buffer_217.skb,napi_budget);
      #line 1159 
      dma_unmap_single_attrs(tx_ring->dev,tx_buffer->dma,(unsigned long)tx_buffer->len,(enum dma_data_direction)DMA_TO_DEVICE,0UL);
      #line 1165 
      tx_buffer->len = 0U;
      #line 1168 
      while (tx_desc != eop_desc) {
        #line 1169 
        tx_buffer ++;
        #line 1170 
        tx_desc ++;
        #line 1171 
        i ++;
        #line 1172 
        if ((long)(i == 0U) != 0L) {
          #line 1173 
          i -= (unsigned int)tx_ring->count;
          #line 1174 
          tx_buffer = tx_ring->__anonCompField_ixgbe_ring_221.tx_buffer_info;
          #line 1175 
          tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc;
        }
        #line 1179 
        if (tx_buffer->len != 0U) {
          #line 1180 
          dma_unmap_page_attrs(tx_ring->dev,tx_buffer->dma,(unsigned long)tx_buffer->len,(enum dma_data_direction)DMA_TO_DEVICE,0UL);
          #line 1184 
          tx_buffer->len = 0U;
        }
      }
      #line 1189 
      tx_buffer ++;
      #line 1190 
      tx_desc ++;
      #line 1191 
      i ++;
      #line 1192 
      if ((long)(i == 0U) != 0L) {
        #line 1193 
        i -= (unsigned int)tx_ring->count;
        #line 1194 
        tx_buffer = tx_ring->__anonCompField_ixgbe_ring_221.tx_buffer_info;
        #line 1195 
        tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc;
      }
      #line 1199 
      __builtin_prefetch((void const *)((void *)tx_desc));
      #line 1202 
      budget --;
    }
    #line 1203 
    if (! ((long)(budget != 0U) != 0L)) 
                                        #line 1129 
                                        break;
  }
  #line 1205 
  i = (unsigned int)tx_ring->count + i;
  #line 1206 
  tx_ring->next_to_clean = (unsigned short)i;
  #line 1207 
  u64_stats_init(& tx_ring->syncp);
  #line 1208 
  tx_ring->stats.bytes += (unsigned long long)total_bytes;
  #line 1209 
  tx_ring->stats.packets += (unsigned long long)total_packets;
  #line 1210 
  u64_stats_init(& tx_ring->syncp);
  #line 1211 
  q_vector->tx.total_bytes += total_bytes;
  #line 1212 
  q_vector->tx.total_packets += total_packets;
  #line 1213 
  adapter->tx_ipsec += (unsigned long long)total_ipsec;
  #line 1215 
  if ((int)test_bit(7L,& tx_ring->state) != 0) {
    #line 1215 
    if ((int)ixgbe_check_tx_hang(tx_ring) != 0) {
      #line 1217 
      struct ixgbe_hw *hw = & adapter->hw;
      #line 1218 
      if (((int)adapter->msg_enable & 1) != 0) {
        #line 1218 
        u32 tmp_1;
        #line 1218 
        u32 tmp_2;
        #line 1218 
        char *tmp_4;
        #line 1218 
        ;
        #line 1218 
        ;
        #line 1218 
        ;
        #line 1218 
        ;
        #line 1218 
        tmp_1 = ixgbe_read_reg(hw,(unsigned int)((int)tx_ring->reg_idx * 64 + 24600));
        #line 1218 
        tmp_2 = ixgbe_read_reg(hw,(unsigned int)((int)tx_ring->reg_idx * 64 + 24592));
        #line 1218 
        ;
        #line 1218 
        if ((int)test_bit(9L,& tx_ring->state) != 0) 
                                                     #line 1218 
                                                     tmp_4 = (char *)"(XDP)"; else 
                                                                    #line 1218 
                                                                    tmp_4 = (char *)"";
        #line 1218 
        ;
        #line 1218 
        netdev_err(adapter->netdev,(char *)"Detected Tx Unit Hang %s\n",tmp_4,(int)tx_ring->queue_index,tmp_2,tmp_1,(int)tx_ring->next_to_use,i,(tx_ring->__anonCompField_ixgbe_ring_221.tx_buffer_info + (unsigned long)i)->time_stamp,jiffies);
      }
      #line 1233 
      if (! test_bit(9L,& tx_ring->state)) 
                                           #line 1234 
                                           netif_stop_subqueue(tx_ring->netdev,(unsigned short)((int)tx_ring->queue_index));
      #line 1237 
      if (((int)adapter->msg_enable & 2) != 0) 
                                               #line 1237 
                                               netdev_info(adapter->netdev,(char *)"tx hang %d detected on queue %d, resetting adapter\n",adapter->tx_timeout_count + 1U,(int)tx_ring->queue_index);
      #line 1242 
      ixgbe_tx_timeout_reset(adapter);
      #line 1245 
      return (_Bool)1;
    }
  }
  #line 1248 
  if ((int)test_bit(9L,& tx_ring->state) != 0) 
                                               #line 1249 
                                               return (_Bool)(budget != 0U);
  #line 1251 
  ;
  #line 1251 
  ;
  #line 1251 
  netdev_tx_completed_queue(txring_txq(tx_ring),total_packets,total_bytes);
  #line 1255 
  if ((long)(total_packets != 0U) != 0L) {
    #line 1255 
    if ((long)((int)netif_carrier_ok(tx_ring->netdev) != 0) != 0L) 
                                                                   #line 1255 
                                                                   tmp_13 = 1; else 
                                                                    #line 1255 
                                                                    tmp_13 = 0;
  }
  else 
       #line 1255 
       tmp_13 = 0;
  #line 1255 
  if (tmp_13 != 0) {
    #line 1255 
    if ((long)((unsigned int)ixgbe_desc_unused(tx_ring) > 41U) != 0L) {
      #line 1257 
      ldv_inline_asm();
      #line 1261 
      if ((int)__netif_subqueue_stopped(tx_ring->netdev,
                                  (unsigned short)((int)tx_ring->queue_index)) != 0) {
        #line 1263 
        if (! test_bit(2L,& adapter->state)) {
          #line 1264 
          netif_wake_subqueue(tx_ring->netdev,(unsigned short)((int)tx_ring->queue_index));
          #line 1266 
          (tx_ring->__anonCompField_ixgbe_ring_224.tx_stats.restart_queue) ++;
        }
      }
    }
  }
  #line 1270 
  return (_Bool)(budget != 0U);
}

#line 1274  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_update_tx_dca(struct ixgbe_adapter *adapter, struct ixgbe_ring *tx_ring, int cpu)
{
  #line 1280 
  u16 reg_offset;
  #line 1278 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 1279 
  u32 txctrl = 0U;
  #line 1282 
  if (((unsigned long)adapter->flags & 256UL) != 0UL) {
    #line 1283 
    txctrl = (unsigned int)dca3_get_tag(tx_ring->dev,cpu);
  }
  #line 1285 
  switch ((unsigned int)hw->mac.type) {
    #line 1286 
    case (unsigned int)1: 
                          #line 1286 
    ;
    #line 1287 
    reg_offset = (unsigned short)((unsigned int)((unsigned short)((int)tx_ring->reg_idx + 7296)) * 4U);
    #line 1288 
    break;
    #line 1289 
    case (unsigned int)2: 
                          #line 1289 
    ;
    #line 1290 
    case (unsigned int)3: 
                          #line 1290 
    ;
    #line 1291 
    reg_offset = (unsigned short)((unsigned int)((unsigned short)tx_ring->reg_idx) * 64U + 24588U);
    #line 1292 
    txctrl <<= 24;
    #line 1293 
    break;
    #line 1294 
    default: 
             #line 1294 
    ;
    #line 1296 
    return;
  }
  #line 1304 
  txctrl |= 8736U;
  #line 1308 
  ixgbe_write_reg_1(hw,(unsigned int)reg_offset,txctrl);
  #line 1309 
  return;
}

#line 1311  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_update_rx_dca(struct ixgbe_adapter *adapter, struct ixgbe_ring *rx_ring, int cpu)
{
  #line 1340 
  int tmp_1;
  #line 1315 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 1316 
  u32 rxctrl = 0U;
  #line 1317 
  u8 reg_idx = rx_ring->reg_idx;
  #line 1319 
  if (((unsigned long)adapter->flags & 256UL) != 0UL) {
    #line 1320 
    rxctrl = (unsigned int)dca3_get_tag(rx_ring->dev,cpu);
  }
  #line 1322 
  switch ((unsigned int)hw->mac.type) {
    #line 1323 
    case (unsigned int)2: 
                          #line 1323 
    ;
    #line 1324 
    case (unsigned int)3: 
                          #line 1324 
    ;
    #line 1325 
    rxctrl <<= 24;
    #line 1326 
    break;
    #line 1327 
    default: 
             #line 1327 
    ;
    #line 1328 
    break;
  }
  #line 1336 
  rxctrl |= 672U;
  #line 1340 
  ;
  #line 1340 
  if ((unsigned int)reg_idx <= 15U) 
                                    #line 1340 
                                    tmp_1 = ((int)reg_idx + 2176) * 4;
  else {
    #line 1340 
    int tmp_0;
    #line 1340 
    if ((unsigned int)reg_idx <= 63U) 
                                      #line 1340 
                                      tmp_0 = (int)reg_idx * 64 + 4108; else 
                                                                    #line 1340 
                                                                    tmp_0 = ((int)reg_idx + -64) * 64 + 53260;
    #line 1340 
    tmp_1 = tmp_0;
  }
  #line 1340 
  ;
  #line 1340 
  ixgbe_write_reg_1(hw,(unsigned int)tmp_1,rxctrl);
  #line 1341 
  return;
}

#line 1343  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_update_dca(struct ixgbe_q_vector *q_vector)
{
  #line 1347 
  int pscr_ret__;
  #line 1346 
  struct ixgbe_ring *ring;
  #line 1345 
  struct ixgbe_adapter *adapter = q_vector->adapter;
  #line 1347 
  __preempt_count_add(1);
  #line 1348 
  ldv_inline_asm();
  #line 1347 
  __this_cpu_preempt_check((char *)"read");
  {
    #line 1347 
    void *__vpp_verify = (void *)0;
    #line 1347 
    void *tmp = __vpp_verify;
  }
  #line 1347 
  switch (4UL) {
    #line 1347 
    int pfo_ret___0;
    #line 1347 
    int pfo_ret___1;
    #line 1347 
    int pfo_ret___2;
    #line 1347 
    int pfo_ret__;
    #line 1347 
    case (unsigned long)1: 
                           #line 1347 
    ;
    #line 1347 
    switch (4UL) {
      #line 1347 
      case (unsigned long)1: 
                             #line 1347 
      ;
      #line 1348 
      ldv_inline_asm();
      #line 1347 
      break;
      #line 1347 
      case (unsigned long)2: 
                             #line 1347 
      ;
      #line 1348 
      ldv_inline_asm();
      #line 1347 
      break;
      #line 1347 
      case (unsigned long)4: 
                             #line 1347 
      ;
      #line 1348 
      ldv_inline_asm();
      #line 1347 
      break;
      #line 1347 
      case (unsigned long)8: 
                             #line 1347 
      ;
      #line 1348 
      ldv_inline_asm();
      #line 1347 
      break;
      #line 1347 
      default: 
               #line 1347 
      ;
      #line 1347 
      __bad_percpu_size();
    }
    #line 1347 
    pscr_ret__ = pfo_ret__;
    #line 1347 
    break;
    #line 1347 
    case (unsigned long)2: 
                           #line 1347 
    ;
    #line 1347 
    switch (4UL) {
      #line 1347 
      case (unsigned long)1: 
                             #line 1347 
      ;
      #line 1348 
      ldv_inline_asm();
      #line 1347 
      break;
      #line 1347 
      case (unsigned long)2: 
                             #line 1347 
      ;
      #line 1348 
      ldv_inline_asm();
      #line 1347 
      break;
      #line 1347 
      case (unsigned long)4: 
                             #line 1347 
      ;
      #line 1348 
      ldv_inline_asm();
      #line 1347 
      break;
      #line 1347 
      case (unsigned long)8: 
                             #line 1347 
      ;
      #line 1348 
      ldv_inline_asm();
      #line 1347 
      break;
      #line 1347 
      default: 
               #line 1347 
      ;
      #line 1347 
      __bad_percpu_size();
    }
    #line 1347 
    pscr_ret__ = pfo_ret___0;
    #line 1347 
    break;
    #line 1347 
    case (unsigned long)4: 
                           #line 1347 
    ;
    #line 1347 
    switch (4UL) {
      #line 1347 
      case (unsigned long)1: 
                             #line 1347 
      ;
      #line 1348 
      ldv_inline_asm();
      #line 1347 
      break;
      #line 1347 
      case (unsigned long)2: 
                             #line 1347 
      ;
      #line 1348 
      ldv_inline_asm();
      #line 1347 
      break;
      #line 1347 
      case (unsigned long)4: 
                             #line 1347 
      ;
      #line 1348 
      ldv_inline_asm();
      #line 1347 
      break;
      #line 1347 
      case (unsigned long)8: 
                             #line 1347 
      ;
      #line 1348 
      ldv_inline_asm();
      #line 1347 
      break;
      #line 1347 
      default: 
               #line 1347 
      ;
      #line 1347 
      __bad_percpu_size();
    }
    #line 1347 
    pscr_ret__ = pfo_ret___1;
    #line 1347 
    break;
    #line 1347 
    case (unsigned long)8: 
                           #line 1347 
    ;
    #line 1347 
    switch (4UL) {
      #line 1347 
      case (unsigned long)1: 
                             #line 1347 
      ;
      #line 1348 
      ldv_inline_asm();
      #line 1347 
      break;
      #line 1347 
      case (unsigned long)2: 
                             #line 1347 
      ;
      #line 1348 
      ldv_inline_asm();
      #line 1347 
      break;
      #line 1347 
      case (unsigned long)4: 
                             #line 1347 
      ;
      #line 1348 
      ldv_inline_asm();
      #line 1347 
      break;
      #line 1347 
      case (unsigned long)8: 
                             #line 1347 
      ;
      #line 1348 
      ldv_inline_asm();
      #line 1347 
      break;
      #line 1347 
      default: 
               #line 1347 
      ;
      #line 1347 
      __bad_percpu_size();
    }
    #line 1347 
    pscr_ret__ = pfo_ret___2;
    #line 1347 
    break;
    #line 1347 
    default: 
             #line 1347 
    ;
    #line 1347 
    __bad_size_call_parameter();
    #line 1347 
    break;
  }
  #line 1347 
  int cpu = pscr_ret__;
  #line 1349 
  if (q_vector->cpu == cpu) 
                            #line 1350 
                            goto out_no_update;
  #line 1352 
  ring = q_vector->tx.ring;
  #line 1352 
  while (ring != (struct ixgbe_ring *)0) {
    #line 1353 
    ixgbe_update_tx_dca(adapter,ring,cpu);
    #line 1352 
    ring = ring->next;
  }
  #line 1355 
  ring = q_vector->rx.ring;
  #line 1355 
  while (ring != (struct ixgbe_ring *)0) {
    #line 1356 
    ixgbe_update_rx_dca(adapter,ring,cpu);
    #line 1355 
    ring = ring->next;
  }
  #line 1358 
  q_vector->cpu = cpu;
  #line 1359 
  out_no_update: 
                 #line 1359 
  ;
  #line 1362 
  ldv_inline_asm();
  #line 1360 
  __preempt_count_sub(1);
  #line 1362 
  return;
}

#line 1363  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_setup_dca(struct ixgbe_adapter *adapter)
{
  #line 1365 
  int i;
  #line 1368 
  if (((unsigned long)adapter->flags & 256UL) != 0UL) 
                                                      #line 1369 
                                                      ixgbe_write_reg_1(& adapter->hw,69748U,2U); else 
                                                                    #line 1372 
                                                                    ixgbe_write_reg_1(& adapter->hw,69748U,1U);
  #line 1375 
  i = 0;
  #line 1375 
  while (adapter->num_q_vectors > i) {
    #line 1376 
    (adapter->q_vector[i])->cpu = -1;
    #line 1377 
    ixgbe_update_dca(adapter->q_vector[i]);
    #line 1375 
    i ++;
  }
  #line 1379 
  return;
}

#line 1381  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int __ixgbe_notify_dca(struct device *dev, void *data)
{
  #line 1383 
  struct ixgbe_adapter *adapter = dev_get_drvdata(dev);
  #line 1384 
  unsigned long event = *((unsigned long *)data);
  #line 1386 
  if (((unsigned long)adapter->flags & 512UL) == 0UL) 
                                                      #line 1387 
                                                      return 0;
  #line 1389 
  switch (event) {
    #line 1390 
    case (unsigned long)1: 
                           #line 1390 
    ;
    #line 1392 
    if (((unsigned long)adapter->flags & 256UL) != 0UL) 
                                                        #line 1393 
                                                        break;
    #line 1394 
    if (dca_add_requester(dev) == 0) {
      #line 1395 
      adapter->flags |= 256U;
      #line 1396 
      ixgbe_write_reg_1(& adapter->hw,69748U,2U);
      #line 1398 
      break;
    }
    #line 1401 
    case (unsigned long)2: 
                           #line 1401 
    ;
    #line 1402 
    if (((unsigned long)adapter->flags & 256UL) != 0UL) {
      #line 1403 
      dca_remove_requester(dev);
      #line 1404 
      adapter->flags &= 4294967039U;
      #line 1405 
      ixgbe_write_reg_1(& adapter->hw,69748U,1U);
    }
    #line 1408 
    break;
  }
  #line 1411 
  return 0;
}

#line 1422  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static void ixgbe_rx_hash(struct ixgbe_ring *ring, union ixgbe_adv_rx_desc *rx_desc, struct sk_buff *skb)
{
  #line 1426 
  u16 rss_type;
  #line 1437 
  int tmp;
  #line 1428 
  if (((ring->netdev)->features & 274877906944ULL) == 0ULL) 
                                                            #line 1429 
                                                            return;
  #line 1431 
  rss_type = (unsigned short)((unsigned int)rx_desc->wb.lower.lo_dword.hs_rss.pkt_info & 15U);
  #line 1434 
  if ((unsigned int)rss_type == 0U) 
                                    #line 1435 
                                    return;
  #line 1437 
  if (((394UL >> (int)rss_type) & 1UL) != 0UL) 
                                               #line 1437 
                                               tmp = PKT_HASH_TYPE_L4; else 
                                                                    #line 1437 
                                                                    tmp = PKT_HASH_TYPE_L3;
  #line 1437 
  ;
  #line 1437 
  ;
  #line 1437 
  skb_set_hash(skb,rx_desc->wb.lower.hi_dword.rss,(enum pkt_hash_types)tmp);
  #line 1440 
  return;
}

#line 1450  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static bool ixgbe_rx_is_fcoe(struct ixgbe_ring *ring, union ixgbe_adv_rx_desc *rx_desc)
{
  #line 1455 
  int tmp_0;
  #line 1453 
  __le16 pkt_info = rx_desc->wb.lower.lo_dword.hs_rss.pkt_info;
  #line 1455 
  if ((int)test_bit(4L,& ring->state) != 0) 
    #line 1455 
    if (((int)pkt_info & 112) == 32) 
                                     #line 1455 
                                     tmp_0 = 1; else 
                                                     #line 1455 
                                                     tmp_0 = 0;
  else 
       #line 1455 
       tmp_0 = 0;
  #line 1455 
  return (_Bool)(tmp_0 != 0);
}

#line 1468  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static void ixgbe_rx_checksum(struct ixgbe_ring *ring, union ixgbe_adv_rx_desc *rx_desc, struct sk_buff *skb)
{
  #line 1472 
  __le16 pkt_info = rx_desc->wb.lower.lo_dword.hs_rss.pkt_info;
  #line 1473 
  bool encap_pkt = (_Bool)0;
  #line 1475 
  skb_checksum_none_assert(skb);
  #line 1478 
  if (((ring->netdev)->features & 549755813888ULL) == 0ULL) 
                                                            #line 1479 
                                                            return;
  #line 1482 
  if (((int)pkt_info & 2048) != 0) {
    #line 1483 
    encap_pkt = (_Bool)1;
    #line 1484 
    skb->encapsulation = (unsigned char)1U;
  }
  #line 1488 
  if (ixgbe_test_staterr(rx_desc,64U) != 0U) {
    #line 1488 
    if (ixgbe_test_staterr(rx_desc,2147483648U) != 0U) {
      #line 1490 
      (ring->__anonCompField_ixgbe_ring_224.rx_stats.csum_err) ++;
      #line 1491 
      return;
    }
  }
  #line 1494 
  if (ixgbe_test_staterr(rx_desc,32U) == 0U) 
                                             #line 1495 
                                             return;
  #line 1497 
  if (ixgbe_test_staterr(rx_desc,1073741824U) != 0U) {
    #line 1502 
    if (((int)pkt_info & 512) != 0) {
      #line 1502 
      if ((int)test_bit(3L,& ring->state) != 0) 
                                                #line 1504 
                                                return;
    }
    #line 1506 
    (ring->__anonCompField_ixgbe_ring_224.rx_stats.csum_err) ++;
    #line 1507 
    return;
  }
  #line 1511 
  skb->ip_summed = (unsigned char)1U;
  #line 1512 
  if ((int)encap_pkt != 0) {
    #line 1513 
    if (ixgbe_test_staterr(rx_desc,256U) == 0U) 
                                                #line 1514 
                                                return;
    #line 1516 
    if (ixgbe_test_staterr(rx_desc,67108864U) != 0U) {
      #line 1517 
      skb->ip_summed = (unsigned char)0U;
      #line 1518 
      return;
    }
    #line 1521 
    skb->csum_level = (unsigned char)1U;
  }
  #line 1523 
  return;
}

#line 1525  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static unsigned int ixgbe_rx_offset(struct ixgbe_ring *rx_ring)
{
  #line 1527 
  unsigned int tmp_1;
  #line 1527 
  if ((int)test_bit(1L,& rx_ring->state) != 0) {
    #line 1527 
    tmp_1 = (unsigned int)ixgbe_skb_pad();
  }
  else 
       #line 1527 
       tmp_1 = 0U;
  #line 1527 
  return tmp_1;
}

#line 1530  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static bool ixgbe_alloc_mapped_page(struct ixgbe_ring *rx_ring, struct ixgbe_rx_buffer *bi)
{
  #line 1534 
  dma_addr_t dma;
  #line 1533 
  struct page *page = bi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page;
  #line 1537 
  if ((long)(page != (struct page *)0) != 0L) 
                                              #line 1538 
                                              return (_Bool)1;
  #line 1541 
  page = dev_alloc_pages(ixgbe_rx_pg_order(rx_ring));
  #line 1542 
  if ((long)(page == (struct page *)0) != 0L) {
    #line 1543 
    (rx_ring->__anonCompField_ixgbe_ring_224.rx_stats.alloc_rx_page_failed) ++;
    #line 1544 
    return (_Bool)0;
  }
  #line 1548 
  ;
  #line 1548 
  ;
  #line 1548 
  dma = dma_map_page_attrs(rx_ring->dev,page,0UL,4096UL << ixgbe_rx_pg_order(rx_ring),(enum dma_data_direction)DMA_FROM_DEVICE,34UL);
  #line 1557 
  if (dma_mapping_error(rx_ring->dev,dma) != 0) {
    #line 1558 
    ;
    #line 1558 
    __free_pages(page,ixgbe_rx_pg_order(rx_ring));
    #line 1560 
    (rx_ring->__anonCompField_ixgbe_ring_224.rx_stats.alloc_rx_page_failed) ++;
    #line 1561 
    return (_Bool)0;
  }
  #line 1564 
  bi->dma = dma;
  #line 1565 
  bi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page = page;
  #line 1566 
  bi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page_offset = ixgbe_rx_offset(rx_ring);
  #line 1567 
  page_ref_add(page,65534);
  #line 1568 
  bi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.pagecnt_bias = (unsigned short)65535U;
  #line 1569 
  (rx_ring->__anonCompField_ixgbe_ring_224.rx_stats.alloc_rx_page) ++;
  #line 1571 
  return (_Bool)1;
}

#line 1579  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_alloc_rx_buffers(struct ixgbe_ring *rx_ring, u16 cleaned_count)
{
  #line 1581 
  union ixgbe_adv_rx_desc *rx_desc;
  #line 1582 
  struct ixgbe_rx_buffer *bi;
  #line 1584 
  u16 bufsz;
  #line 1583 
  u16 i = rx_ring->next_to_use;
  #line 1587 
  if ((unsigned int)cleaned_count == 0U) 
                                         #line 1588 
                                         return;
  #line 1590 
  rx_desc = (union ixgbe_adv_rx_desc *)rx_ring->desc + (unsigned long)i;
  #line 1591 
  bi = rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info + (unsigned long)i;
  #line 1592 
  i = (unsigned short)((int)i - (int)rx_ring->count);
  #line 1594 
  bufsz = (unsigned short)ixgbe_rx_bufsz(rx_ring);
  #line 1596 
  while (1) {
    {
      #line 1597 
      if (! ixgbe_alloc_mapped_page(rx_ring,bi)) 
                                                 #line 1598 
                                                 break;
      #line 1601 
      dma_sync_single_range_for_device(rx_ring->dev,bi->dma,(unsigned long)bi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page_offset,(unsigned long)bufsz,(enum dma_data_direction)DMA_FROM_DEVICE);
      #line 1609 
      rx_desc->read.pkt_addr = bi->dma + (unsigned long long)bi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page_offset;
      #line 1611 
      rx_desc ++;
      #line 1612 
      bi ++;
      #line 1613 
      i = (u16)((int)i + 1);
      #line 1614 
      if ((long)((unsigned int)i == 0U) != 0L) {
        #line 1615 
        rx_desc = (union ixgbe_adv_rx_desc *)rx_ring->desc;
        #line 1616 
        bi = rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info;
        #line 1617 
        i = (unsigned short)((int)i - (int)rx_ring->count);
      }
      #line 1621 
      rx_desc->wb.upper.length = (unsigned short)0U;
      #line 1623 
      cleaned_count = (u16)((int)cleaned_count - 1);
    }
    #line 1624 
    if (! ((unsigned int)cleaned_count != 0U)) 
                                               #line 1596 
                                               break;
  }
  #line 1626 
  i = (unsigned short)((int)rx_ring->count + (int)i);
  #line 1628 
  if ((int)rx_ring->next_to_use != (int)i) {
    #line 1629 
    rx_ring->next_to_use = i;
    #line 1632 
    rx_ring->__anonCompField_ixgbe_ring_223.next_to_alloc = i;
    #line 1633 
    ldv_inline_asm();
    #line 1640 
    writel((unsigned int)i,(void *)rx_ring->tail);
  }
  #line 1642 
  return;
}

#line 1644  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_set_rsc_gso_size(struct ixgbe_ring *ring, struct sk_buff *skb)
{
  #line 1647 
  u16 hdr_len = (unsigned short)skb_headlen(skb);
  #line 1650 
  ((struct skb_shared_info *)skb_end_pointer(skb))->gso_size = (unsigned short)((((skb->len - (unsigned int)hdr_len) + (unsigned int)((struct ixgbe_cb *)(& skb->cb))->append_cnt) + 4294967295U) / (unsigned int)((struct ixgbe_cb *)(& skb->cb))->append_cnt);
  #line 1652 
  ((struct skb_shared_info *)skb_end_pointer(skb))->gso_type = 1U;
  #line 1653 
  return;
}

#line 1655  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_update_rsc_stats(struct ixgbe_ring *rx_ring, struct sk_buff *skb)
{
  #line 1659 
  if ((unsigned int)((struct ixgbe_cb *)(& skb->cb))->append_cnt == 0U) 
    #line 1660 
    return;
  #line 1662 
  rx_ring->__anonCompField_ixgbe_ring_224.rx_stats.rsc_count += (unsigned long long)((struct ixgbe_cb *)(& skb->cb))->append_cnt;
  #line 1663 
  (rx_ring->__anonCompField_ixgbe_ring_224.rx_stats.rsc_flush) ++;
  #line 1665 
  ixgbe_set_rsc_gso_size(rx_ring,skb);
  #line 1668 
  ((struct ixgbe_cb *)(& skb->cb))->append_cnt = (unsigned short)0U;
  #line 1669 
  return;
}

#line 1681  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_process_skb_fields(struct ixgbe_ring *rx_ring, union ixgbe_adv_rx_desc *rx_desc, struct sk_buff *skb)
{
  #line 1685 
  struct net_device *dev = rx_ring->netdev;
  #line 1686 
  u32 flags = ((rx_ring->q_vector)->adapter)->flags;
  #line 1688 
  ixgbe_update_rsc_stats(rx_ring,skb);
  #line 1690 
  ixgbe_rx_hash(rx_ring,rx_desc,skb);
  #line 1692 
  ixgbe_rx_checksum(rx_ring,rx_desc,skb);
  #line 1694 
  if ((long)(((unsigned long)flags & 33554432UL) != 0UL) != 0L) 
                                                                #line 1695 
                                                                ixgbe_ptp_rx_hwtstamp(rx_ring,rx_desc,skb);
  #line 1697 
  if ((dev->features & 256ULL) != 0ULL) {
    #line 1697 
    if (ixgbe_test_staterr(rx_desc,8U) != 0U) {
      #line 1699 
      u16 vid = rx_desc->wb.upper.vlan;
      #line 1700 
      __vlan_hwaccel_put_tag(skb,(unsigned short)129,(unsigned short)((int)vid));
    }
  }
  #line 1703 
  if (ixgbe_test_staterr(rx_desc,131072U) != 0U) 
                                                 #line 1704 
                                                 ixgbe_ipsec_rx(rx_ring,rx_desc,skb);
  #line 1707 
  if ((int)netif_is_ixgbe(dev) != 0) 
                                     #line 1708 
                                     skb_record_rx_queue(skb,(unsigned short)((int)rx_ring->queue_index));
  else {
    #line 1710 
    ;
    #line 1710 
    macvlan_count_rx((struct macvlan_dev *)netdev_priv(dev),skb->len + 14U,(_Bool)1,(_Bool)0);
  }
  #line 1713 
  skb->protocol = eth_type_trans(skb,dev);
  #line 1714 
  return;
}

#line 1716  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_rx_skb(struct ixgbe_q_vector *q_vector, struct sk_buff *skb)
{
  #line 1719 
  napi_gro_receive(& q_vector->napi,skb);
  #line 1720 
  return;
}

#line 1733  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static bool ixgbe_is_non_eop(struct ixgbe_ring *rx_ring, union ixgbe_adv_rx_desc *rx_desc, struct sk_buff *skb)
{
  #line 1737 
  u32 ntc = (unsigned int)((int)rx_ring->next_to_clean + 1);
  #line 1740 
  if ((unsigned int)rx_ring->count > ntc) 
                                          #line 1740 
                                          ntc = ntc; else 
                                                          #line 1740 
                                                          ntc = 0U;
  #line 1741 
  rx_ring->next_to_clean = (unsigned short)ntc;
  #line 1743 
  __builtin_prefetch((void const *)((void *)((union ixgbe_adv_rx_desc *)rx_ring->desc + (unsigned long)ntc)));
  #line 1746 
  if ((int)test_bit(2L,& rx_ring->state) != 0) {
    #line 1747 
    __le32 rsc_enabled = rx_desc->wb.lower.lo_dword.data & 1966080U;
    #line 1750 
    if ((long)(rsc_enabled != 0U) != 0L) {
      #line 1751 
      u32 rsc_cnt = rsc_enabled;
      #line 1753 
      rsc_cnt >>= 17;
      #line 1754 
      ((struct ixgbe_cb *)(& skb->cb))->append_cnt = (unsigned short)((unsigned int)((int)((struct ixgbe_cb *)(& skb->cb))->append_cnt + (int)((unsigned short)rsc_cnt)) + 65535U);
      #line 1757 
      ntc = rx_desc->wb.upper.status_error;
      #line 1758 
      ntc &= 1048560U;
      #line 1759 
      ntc >>= 4;
    }
  }
  #line 1764 
  if ((long)(ixgbe_test_staterr(rx_desc,2U) != 0U) != 0L) 
                                                          #line 1765 
                                                          return (_Bool)0;
  #line 1768 
  (rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info + (unsigned long)ntc)->skb = skb;
  #line 1769 
  (rx_ring->__anonCompField_ixgbe_ring_224.rx_stats.non_eop_descs) ++;
  #line 1771 
  return (_Bool)1;
}

#line 1786  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_pull_tail(struct ixgbe_ring *rx_ring, struct sk_buff *skb)
{
  #line 1790 
  unsigned char *va;
  #line 1791 
  unsigned int pull_len;
  #line 1789 
  skb_frag_t *frag = & ((struct skb_shared_info *)skb_end_pointer(skb))->frags[0];
  #line 1798 
  va = (unsigned char *)skb_frag_address(frag);
  #line 1804 
  pull_len = eth_get_headlen(skb->__anonCompField_sk_buff_89.__anonCompField___anonunion_521_88.__anonCompField___anonstruct_522_87.dev,(void *)va,256U);
  #line 1807 
  skb_copy_to_linear_data(skb,(void *)va,(pull_len + 7U) & 4294967288U);
  #line 1810 
  skb_frag_size_sub(frag,(int)pull_len);
  #line 1811 
  skb_frag_off_add(frag,(int)pull_len);
  #line 1812 
  skb->data_len -= pull_len;
  #line 1813 
  skb->tail += pull_len;
  #line 1814 
  return;
}

#line 1826  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_dma_sync_frag(struct ixgbe_ring *rx_ring, struct sk_buff *skb)
{
  #line 1829 
  if ((int)test_bit(1L,& rx_ring->state) != 0) {
    #line 1830 
    unsigned long offset = (unsigned long)skb->data & 4095UL;
    #line 1832 
    ;
    #line 1832 
    ;
    #line 1832 
    ;
    #line 1832 
    dma_sync_single_range_for_cpu(rx_ring->dev,((struct ixgbe_cb *)(& skb->cb))->dma,offset,(unsigned long)skb_headlen(skb),(enum dma_data_direction)DMA_FROM_DEVICE);
  }
  else {
    #line 1838 
    skb_frag_t *frag = & ((struct skb_shared_info *)skb_end_pointer(skb))->frags[0];
    #line 1840 
    ;
    #line 1840 
    ;
    #line 1840 
    dma_sync_single_range_for_cpu(rx_ring->dev,((struct ixgbe_cb *)(& skb->cb))->dma,(unsigned long)skb_frag_off(frag),(unsigned long)skb_frag_size(frag),(enum dma_data_direction)DMA_FROM_DEVICE);
  }
  #line 1848 
  if ((long)((int)((struct ixgbe_cb *)(& skb->cb))->page_released != 0) != 0L) {
    #line 1849 
    ;
    #line 1849 
    ;
    #line 1849 
    dma_unmap_page_attrs(rx_ring->dev,((struct ixgbe_cb *)(& skb->cb))->dma,4096UL << ixgbe_rx_pg_order(rx_ring),(enum dma_data_direction)DMA_FROM_DEVICE,34UL);
  }
  #line 1851 
  return;
}

#line 1878  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
bool ixgbe_cleanup_headers(struct ixgbe_ring *rx_ring, union ixgbe_adv_rx_desc *rx_desc, struct sk_buff *skb)
{
  #line 1882 
  struct net_device *netdev = rx_ring->netdev;
  #line 1885 
  if ((int)IS_ERR((void *)skb) != 0) 
                                     #line 1886 
                                     return (_Bool)1;
  #line 1891 
  if (netdev == (struct net_device *)0) 
                                        #line 1891 
                                        goto _LOR;
  else {
    #line 1891 
    if ((long)(ixgbe_test_staterr(rx_desc,989855744U) != 0U) != 0L) 
      #line 1892 
      if ((long)((netdev->features & 8796093022208ULL) == 0ULL) != 0L) {
        #line 1891 
        _LOR: {
                #line 1895 
                dev_kfree_skb_any(skb);
                #line 1896 
                return (_Bool)1;
              }
      }
  }
  #line 1900 
  if (skb_headlen(skb) == 0U) 
                              #line 1901 
                              ixgbe_pull_tail(rx_ring,skb);
  #line 1905 
  if ((int)ixgbe_rx_is_fcoe(rx_ring,rx_desc) != 0) 
                                                   #line 1906 
                                                   return (_Bool)0;
  #line 1910 
  if (eth_skb_pad(skb) != 0) 
                             #line 1911 
                             return (_Bool)1;
  #line 1913 
  return (_Bool)0;
}

#line 1923  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_reuse_rx_page(struct ixgbe_ring *rx_ring, struct ixgbe_rx_buffer *old_buff)
{
  #line 1926 
  struct ixgbe_rx_buffer *new_buff;
  #line 1927 
  u16 nta = rx_ring->__anonCompField_ixgbe_ring_223.next_to_alloc;
  #line 1929 
  new_buff = rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info + (unsigned long)nta;
  #line 1932 
  nta = (u16)((int)nta + 1);
  #line 1933 
  if ((int)rx_ring->count > (int)nta) 
                                      #line 1933 
                                      rx_ring->__anonCompField_ixgbe_ring_223.next_to_alloc = nta; else 
                                                                    #line 1933 
                                                                    rx_ring->__anonCompField_ixgbe_ring_223.next_to_alloc = (unsigned short)0U;
  #line 1939 
  new_buff->dma = old_buff->dma;
  #line 1940 
  new_buff->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page = old_buff->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page;
  #line 1941 
  new_buff->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page_offset = old_buff->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page_offset;
  #line 1942 
  new_buff->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.pagecnt_bias = old_buff->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.pagecnt_bias;
  #line 1943 
  return;
}

#line 1945  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static bool ixgbe_page_is_reserved(struct page *page)
{
  #line 1947 
  int tmp_2;
  #line 1947 
  if (page_to_nid(page) != numa_mem_id()) 
                                          #line 1947 
                                          tmp_2 = 1;
  else {
    #line 1947 
    if ((int)page_is_pfmemalloc(page) != 0) 
                                            #line 1947 
                                            tmp_2 = 1; else 
                                                            #line 1947 
                                                            tmp_2 = 0;
  }
  #line 1947 
  return (_Bool)(tmp_2 != 0);
}

#line 1950  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static bool ixgbe_can_reuse_rx_page(struct ixgbe_rx_buffer *rx_buffer)
{
  #line 1952 
  unsigned int pagecnt_bias = (unsigned int)rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.pagecnt_bias;
  #line 1953 
  struct page *page = rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page;
  #line 1956 
  if ((long)((int)ixgbe_page_is_reserved(page) != 0) != 0L) 
                                                            #line 1957 
                                                            return (_Bool)0;
  #line 1961 
  ;
  #line 1961 
  if ((long)((unsigned int)page_ref_count(page) - pagecnt_bias > 1U) != 0L) 
    #line 1962 
    return (_Bool)0;
  #line 1979 
  if ((long)(pagecnt_bias == 1U) != 0L) {
    #line 1980 
    page_ref_add(page,65534);
    #line 1981 
    rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.pagecnt_bias = (unsigned short)65535U;
  }
  #line 1984 
  return (_Bool)1;
}

#line 2002  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_add_rx_frag(struct ixgbe_ring *rx_ring, struct ixgbe_rx_buffer *rx_buffer, struct sk_buff *skb, unsigned int size)
{
  #line 2008 
  unsigned int truesize = (unsigned int)((4096UL << ixgbe_rx_pg_order(rx_ring)) / 2UL);
  #line 2014 
  ;
  #line 2014 
  ;
  #line 2014 
  ;
  #line 2014 
  ;
  #line 2014 
  ;
  #line 2014 
  skb_add_rx_frag(skb,(int)((struct skb_shared_info *)skb_end_pointer(skb))->nr_frags,rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page,(int)rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page_offset,(int)size,truesize);
  #line 2017 
  rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page_offset ^= truesize;
  #line 2018 
  return;
}

#line 2023  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct ixgbe_rx_buffer *ixgbe_get_rx_buffer(struct ixgbe_ring *rx_ring, union ixgbe_adv_rx_desc *rx_desc, struct sk_buff **skb, unsigned int size)
{
  #line 2028 
  struct ixgbe_rx_buffer *rx_buffer;
  #line 2030 
  rx_buffer = rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info + (unsigned long)rx_ring->next_to_clean;
  #line 2031 
  prefetchw((void *)rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page);
  #line 2032 
  *skb = rx_buffer->skb;
  #line 2038 
  if (ixgbe_test_staterr(rx_desc,2U) == 0U) {
    #line 2039 
    if (*skb == (struct sk_buff *)0) 
                                     #line 2040 
                                     goto skip_sync;
  }
  else 
    #line 2042 
    if (*skb != (struct sk_buff *)0) 
                                     #line 2043 
                                     ixgbe_dma_sync_frag(rx_ring,*skb);
  #line 2047 
  dma_sync_single_range_for_cpu(rx_ring->dev,rx_buffer->dma,(unsigned long)rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page_offset,(unsigned long)size,(enum dma_data_direction)DMA_FROM_DEVICE);
  #line 2052 
  skip_sync: 
             #line 2052 
  ;
  #line 2053 
  rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.pagecnt_bias = (__u16)((int)rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.pagecnt_bias - 1);
  #line 2055 
  return rx_buffer;
}

#line 2058  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_put_rx_buffer(struct ixgbe_ring *rx_ring, struct ixgbe_rx_buffer *rx_buffer, struct sk_buff *skb)
{
  #line 2062 
  if ((int)ixgbe_can_reuse_rx_page(rx_buffer) != 0) 
                                                    #line 2064 
                                                    ixgbe_reuse_rx_page(rx_ring,rx_buffer);
  else {
    #line 2066 
    if (IS_ERR((void *)skb)) {
      #line 2066 
      _LAND: { /* sequence */
               #line 2071 
               ;
               #line 2071 
               ;
             }
      #line 2071 
      dma_unmap_page_attrs(rx_ring->dev,rx_buffer->dma,4096UL << ixgbe_rx_pg_order(rx_ring),(enum dma_data_direction)DMA_FROM_DEVICE,34UL);
    }
    else 
      #line 2066 
      if (((struct ixgbe_cb *)(& skb->cb))->dma == rx_buffer->dma) 
                                                                   #line 2068 
                                                                   ((struct ixgbe_cb *)(& skb->cb))->page_released = (_Bool)1; else 
                                                                    #line 2066 
                                                                    goto _LAND;
    #line 2076 
    __page_frag_cache_drain(rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page,(unsigned int)rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.pagecnt_bias);
  }
  #line 2081 
  rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page = (struct page *)0;
  #line 2082 
  rx_buffer->skb = (struct sk_buff *)0;
  #line 2083 
  return;
}

#line 2085  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct sk_buff *ixgbe_construct_skb(struct ixgbe_ring *rx_ring, struct ixgbe_rx_buffer *rx_buffer, struct xdp_buff *xdp, union ixgbe_adv_rx_desc *rx_desc)
{
  #line 2097 
  struct sk_buff *skb;
  #line 2090 
  unsigned int size = (unsigned int)(xdp->data_end - xdp->data);
  #line 2092 
  unsigned int truesize = (unsigned int)((4096UL << ixgbe_rx_pg_order(rx_ring)) / 2UL);
  #line 2100 
  __builtin_prefetch((void const *)xdp->data);
  #line 2102 
  __builtin_prefetch((void const *)(xdp->data + 64U));
  #line 2121 
  skb = napi_alloc_skb(& (rx_ring->q_vector)->napi,256U);
  #line 2122 
  if ((long)(skb == (struct sk_buff *)0) != 0L) 
                                                #line 2123 
                                                return (struct sk_buff *)0;
  #line 2125 
  if (size > 256U) {
    #line 2126 
    if (ixgbe_test_staterr(rx_desc,2U) == 0U) 
                                              #line 2127 
                                              ((struct ixgbe_cb *)(& skb->cb))->dma = rx_buffer->dma;
    #line 2129 
    ;
    #line 2129 
    ;
    #line 2129 
    ;
    #line 2129 
    ;
    #line 2129 
    ;
    #line 2129 
    skb_add_rx_frag(skb,0,rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page,(int)(xdp->data - lowmem_page_address(rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page)),(int)size,truesize);
    #line 2133 
    rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page_offset ^= truesize;
  }
  else {
    #line 2138 
    ;
    #line 2138 
    ;
    #line 2138 
    memcpy(__skb_put(skb,size),xdp->data,(unsigned long)(size + 7U) & 4294967288UL);
    #line 2140 
    rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.pagecnt_bias = (__u16)((int)rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.pagecnt_bias + 1);
  }
  #line 2143 
  return skb;
}

#line 2146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct sk_buff *ixgbe_build_skb(struct ixgbe_ring *rx_ring, struct ixgbe_rx_buffer *rx_buffer, struct xdp_buff *xdp, union ixgbe_adv_rx_desc *rx_desc)
{
  #line 2159 
  struct sk_buff *skb;
  #line 2151 
  unsigned int metasize = (unsigned int)(xdp->data - xdp->data_meta);
  #line 2153 
  unsigned int truesize = (unsigned int)((4096UL << ixgbe_rx_pg_order(rx_ring)) / 2UL);
  #line 2166 
  __builtin_prefetch((void const *)xdp->data_meta);
  #line 2168 
  __builtin_prefetch((void const *)(xdp->data_meta + 64U));
  #line 2172 
  skb = build_skb(xdp->data_hard_start,truesize);
  #line 2173 
  if ((long)(skb == (struct sk_buff *)0) != 0L) 
                                                #line 2174 
                                                return (struct sk_buff *)0;
  #line 2177 
  skb_reserve(skb,(int)(xdp->data - xdp->data_hard_start));
  #line 2178 
  __skb_put(skb,(unsigned int)(xdp->data_end - xdp->data));
  #line 2179 
  if (metasize != 0U) 
                      #line 2180 
                      skb_metadata_set(skb,(unsigned char)((int)((unsigned char)metasize)));
  #line 2183 
  if (ixgbe_test_staterr(rx_desc,2U) == 0U) 
                                            #line 2184 
                                            ((struct ixgbe_cb *)(& skb->cb))->dma = rx_buffer->dma;
  #line 2188 
  rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page_offset ^= truesize;
  #line 2193 
  return skb;
}

#line 2196  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct sk_buff *ixgbe_run_xdp(struct ixgbe_adapter *adapter, struct ixgbe_ring *rx_ring, struct xdp_buff *xdp)
{
  #line 2207 
  union __anonunion___u_2633 __u;
  #line 2200 
  int err;
  #line 2201 
  struct bpf_prog *xdp_prog;
  #line 2202 
  struct xdp_frame *xdpf;
  #line 2203 
  u32 act;
  #line 2200 
  int result = 0;
  #line 2205 
  rcu_read_lock();
  #line 2206 
  __read_once_size((void *)(& rx_ring->xdp_prog),(void *)(& __u.__c),8);
  #line 2206 
  xdp_prog = (__u.__val);
  #line 2208 
  if (xdp_prog == (struct bpf_prog *)0) 
                                        #line 2209 
                                        goto xdp_out;
  #line 2211 
  prefetchw(xdp->data_hard_start);
  #line 2213 
  act = bpf_prog_run_xdp(xdp_prog,xdp);
  #line 2214 
  switch (act) {
    #line 2215 
    case (u32)2: 
                 #line 2215 
    ;
    #line 2216 
    break;
    #line 2217 
    case (u32)3: 
                 #line 2217 
    ;
    #line 2218 
    xdpf = convert_to_xdp_frame(xdp);
    #line 2219 
    if ((long)(xdpf == (struct xdp_frame *)0) != 0L) {
      #line 2220 
      result = 1;
      #line 2221 
      break;
    }
    #line 2223 
    result = ixgbe_xmit_xdp_ring(adapter,xdpf);
    #line 2224 
    break;
    #line 2225 
    case (u32)4: 
                 #line 2225 
    ;
    #line 2226 
    err = xdp_do_redirect(adapter->netdev,xdp,xdp_prog);
    #line 2227 
    if (err == 0) 
                  #line 2228 
                  result = 4; else 
                                   #line 2230 
                                   result = 1;
    #line 2231 
    break;
    #line 2232 
    default: 
             #line 2232 
    ;
    #line 2233 
    bpf_warn_invalid_xdp_action(act);
    #line 2235 
    case (u32)0: 
                 #line 2235 
    ;
    #line 2236 
    trace_xdp_exception(rx_ring->netdev,xdp_prog,act);
    #line 2238 
    case (u32)1: 
                 #line 2238 
    ;
    #line 2239 
    result = 1;
    #line 2240 
    break;
  }
  #line 2242 
  xdp_out: 
           #line 2242 
  ;
  #line 2243 
  rcu_read_unlock();
  #line 2244 
  return (struct sk_buff *)ERR_PTR((long)(- result));
}

#line 2247  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_rx_buffer_flip(struct ixgbe_ring *rx_ring, struct ixgbe_rx_buffer *rx_buffer, unsigned int size)
{
  #line 2252 
  unsigned int truesize = (unsigned int)((4096UL << ixgbe_rx_pg_order(rx_ring)) / 2UL);
  #line 2254 
  rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page_offset ^= truesize;
  #line 2255 
  return;
}

#line 2277  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_clean_rx_irq(struct ixgbe_q_vector *q_vector, struct ixgbe_ring *rx_ring, int budget)
{
  #line 2284 
  int ddp_bytes;
  #line 2289 
  struct xdp_buff xdp;
  #line 2281 
  unsigned int total_rx_bytes = 0U;
  #line 2281 
  unsigned int total_rx_packets = 0U;
  #line 2282 
  struct ixgbe_adapter *adapter = q_vector->adapter;
  #line 2285 
  unsigned int mss = 0U;
  #line 2287 
  u16 cleaned_count = ixgbe_desc_unused(rx_ring);
  #line 2288 
  unsigned int xdp_xmit = 0U;
  #line 2291 
  xdp.rxq = & rx_ring->xdp_rxq;
  #line 2293 
  while ((long)(total_rx_packets < (unsigned int)budget) != 0L) {
    #line 2294 
    union ixgbe_adv_rx_desc *rx_desc;
    #line 2295 
    struct ixgbe_rx_buffer *rx_buffer;
    #line 2296 
    struct sk_buff *skb;
    #line 2297 
    unsigned int size;
    #line 2300 
    if ((unsigned int)cleaned_count > 15U) {
      #line 2301 
      ixgbe_alloc_rx_buffers(rx_ring,(unsigned short)((int)cleaned_count));
      #line 2302 
      cleaned_count = (unsigned short)0U;
    }
    #line 2305 
    rx_desc = (union ixgbe_adv_rx_desc *)rx_ring->desc + (unsigned long)rx_ring->next_to_clean;
    #line 2306 
    size = (unsigned int)rx_desc->wb.upper.length;
    #line 2307 
    if (size == 0U) 
                    #line 2308 
                    break;
    #line 2309 
    ldv_inline_asm();
    #line 2316 
    rx_buffer = ixgbe_get_rx_buffer(rx_ring,rx_desc,& skb,size);
    #line 2319 
    if (skb == (struct sk_buff *)0) {
      #line 2320 
      xdp.data = lowmem_page_address(rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page) + (unsigned long)rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page_offset;
      #line 2322 
      xdp.data_meta = xdp.data;
      #line 2323 
      xdp.data_hard_start = xdp.data + - ixgbe_rx_offset(rx_ring);
      #line 2325 
      xdp.data_end = xdp.data + (unsigned long)size;
      #line 2327 
      skb = ixgbe_run_xdp(adapter,rx_ring,& xdp);
    }
    #line 2330 
    if ((int)IS_ERR((void *)skb) != 0) {
      #line 2331 
      unsigned int xdp_res = - ((unsigned int)PTR_ERR((void *)skb));
      #line 2333 
      if (((unsigned long)xdp_res & 6UL) != 0UL) {
        #line 2334 
        xdp_xmit |= xdp_res;
        #line 2335 
        ixgbe_rx_buffer_flip(rx_ring,rx_buffer,size);
      }
      else 
           #line 2337 
           rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.pagecnt_bias = (__u16)((int)rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.pagecnt_bias + 1);
      #line 2339 
      total_rx_packets ++;
      #line 2340 
      total_rx_bytes += size;
    }
    else 
      #line 2341 
      if (skb != (struct sk_buff *)0) 
                                      #line 2342 
                                      ixgbe_add_rx_frag(rx_ring,rx_buffer,skb,size);
      else {
        #line 2343 
        if ((int)test_bit(1L,& rx_ring->state) != 0) 
                                                     #line 2344 
                                                     skb = ixgbe_build_skb(rx_ring,rx_buffer,& xdp,rx_desc); else 
                                                                    #line 2347 
                                                                    skb = ixgbe_construct_skb(rx_ring,rx_buffer,& xdp,rx_desc);
      }
    #line 2352 
    if (skb == (struct sk_buff *)0) {
      #line 2353 
      (rx_ring->__anonCompField_ixgbe_ring_224.rx_stats.alloc_rx_buff_failed) ++;
      #line 2354 
      rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.pagecnt_bias = (__u16)((int)rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.pagecnt_bias + 1);
      #line 2355 
      break;
    }
    #line 2358 
    ixgbe_put_rx_buffer(rx_ring,rx_buffer,skb);
    #line 2359 
    cleaned_count = (u16)((int)cleaned_count + 1);
    #line 2362 
    if ((int)ixgbe_is_non_eop(rx_ring,rx_desc,skb) != 0) 
                                                         #line 2363 
                                                         continue;
    #line 2366 
    if ((int)ixgbe_cleanup_headers(rx_ring,rx_desc,skb) != 0) 
                                                              #line 2367 
                                                              continue;
    #line 2370 
    total_rx_bytes = skb->len + total_rx_bytes;
    #line 2373 
    ixgbe_process_skb_fields(rx_ring,rx_desc,skb);
    #line 2377 
    if ((int)ixgbe_rx_is_fcoe(rx_ring,rx_desc) != 0) {
      #line 2378 
      ddp_bytes = ixgbe_fcoe_ddp(adapter,rx_desc,skb);
      #line 2380 
      if (ddp_bytes > 0) {
        #line 2381 
        if (mss == 0U) {
          #line 2382 
          mss = (rx_ring->netdev)->mtu + 4294967250U;
          #line 2386 
          if (mss > 512U) 
                          #line 2387 
                          mss &= 4294966784U;
        }
        #line 2389 
        total_rx_bytes += (unsigned int)ddp_bytes;
        #line 2390 
        total_rx_packets = (((unsigned int)ddp_bytes + mss) + 4294967295U) / mss + total_rx_packets;
      }
      #line 2393 
      if (ddp_bytes == 0) {
        #line 2394 
        dev_kfree_skb_any(skb);
        #line 2395 
        continue;
      }
    }
    #line 2400 
    ixgbe_rx_skb(q_vector,skb);
    #line 2403 
    total_rx_packets ++;
  }
  #line 2406 
  if (((unsigned long)xdp_xmit & 4UL) != 0UL) 
                                              #line 2407 
                                              xdp_do_flush_map();
  #line 2409 
  if (((unsigned long)xdp_xmit & 2UL) != 0UL) {
    #line 2410 
    int pscr_ret__;
    #line 2410 
    __this_cpu_preempt_check((char *)"read");
    {
      #line 2410 
      void *__vpp_verify = (void *)0;
      #line 2410 
      void *tmp_8 = __vpp_verify;
    }
    #line 2410 
    switch (4UL) {
      #line 2410 
      int pfo_ret__;
      #line 2410 
      int pfo_ret___0;
      #line 2410 
      int pfo_ret___1;
      #line 2410 
      int pfo_ret___2;
      #line 2410 
      case (unsigned long)1: 
                             #line 2410 
      ;
      #line 2410 
      switch (4UL) {
        #line 2410 
        case (unsigned long)1: 
                               #line 2410 
        ;
        #line 2411 
        ldv_inline_asm();
        #line 2410 
        break;
        #line 2410 
        case (unsigned long)2: 
                               #line 2410 
        ;
        #line 2411 
        ldv_inline_asm();
        #line 2410 
        break;
        #line 2410 
        case (unsigned long)4: 
                               #line 2410 
        ;
        #line 2411 
        ldv_inline_asm();
        #line 2410 
        break;
        #line 2410 
        case (unsigned long)8: 
                               #line 2410 
        ;
        #line 2411 
        ldv_inline_asm();
        #line 2410 
        break;
        #line 2410 
        default: 
                 #line 2410 
        ;
        #line 2410 
        __bad_percpu_size();
      }
      #line 2410 
      pscr_ret__ = pfo_ret__;
      #line 2410 
      break;
      #line 2410 
      case (unsigned long)2: 
                             #line 2410 
      ;
      #line 2410 
      switch (4UL) {
        #line 2410 
        case (unsigned long)1: 
                               #line 2410 
        ;
        #line 2411 
        ldv_inline_asm();
        #line 2410 
        break;
        #line 2410 
        case (unsigned long)2: 
                               #line 2410 
        ;
        #line 2411 
        ldv_inline_asm();
        #line 2410 
        break;
        #line 2410 
        case (unsigned long)4: 
                               #line 2410 
        ;
        #line 2411 
        ldv_inline_asm();
        #line 2410 
        break;
        #line 2410 
        case (unsigned long)8: 
                               #line 2410 
        ;
        #line 2411 
        ldv_inline_asm();
        #line 2410 
        break;
        #line 2410 
        default: 
                 #line 2410 
        ;
        #line 2410 
        __bad_percpu_size();
      }
      #line 2410 
      pscr_ret__ = pfo_ret___0;
      #line 2410 
      break;
      #line 2410 
      case (unsigned long)4: 
                             #line 2410 
      ;
      #line 2410 
      switch (4UL) {
        #line 2410 
        case (unsigned long)1: 
                               #line 2410 
        ;
        #line 2411 
        ldv_inline_asm();
        #line 2410 
        break;
        #line 2410 
        case (unsigned long)2: 
                               #line 2410 
        ;
        #line 2411 
        ldv_inline_asm();
        #line 2410 
        break;
        #line 2410 
        case (unsigned long)4: 
                               #line 2410 
        ;
        #line 2411 
        ldv_inline_asm();
        #line 2410 
        break;
        #line 2410 
        case (unsigned long)8: 
                               #line 2410 
        ;
        #line 2411 
        ldv_inline_asm();
        #line 2410 
        break;
        #line 2410 
        default: 
                 #line 2410 
        ;
        #line 2410 
        __bad_percpu_size();
      }
      #line 2410 
      pscr_ret__ = pfo_ret___1;
      #line 2410 
      break;
      #line 2410 
      case (unsigned long)8: 
                             #line 2410 
      ;
      #line 2410 
      switch (4UL) {
        #line 2410 
        case (unsigned long)1: 
                               #line 2410 
        ;
        #line 2411 
        ldv_inline_asm();
        #line 2410 
        break;
        #line 2410 
        case (unsigned long)2: 
                               #line 2410 
        ;
        #line 2411 
        ldv_inline_asm();
        #line 2410 
        break;
        #line 2410 
        case (unsigned long)4: 
                               #line 2410 
        ;
        #line 2411 
        ldv_inline_asm();
        #line 2410 
        break;
        #line 2410 
        case (unsigned long)8: 
                               #line 2410 
        ;
        #line 2411 
        ldv_inline_asm();
        #line 2410 
        break;
        #line 2410 
        default: 
                 #line 2410 
        ;
        #line 2410 
        __bad_percpu_size();
      }
      #line 2410 
      pscr_ret__ = pfo_ret___2;
      #line 2410 
      break;
      #line 2410 
      default: 
               #line 2410 
      ;
      #line 2410 
      __bad_size_call_parameter();
      #line 2410 
      break;
    }
    #line 2410 
    struct ixgbe_ring *ring = adapter->xdp_ring[pscr_ret__];
    #line 2413 
    ldv_inline_asm();
    #line 2416 
    writel((unsigned int)ring->next_to_use,(void *)ring->tail);
  }
  #line 2419 
  u64_stats_init(& rx_ring->syncp);
  #line 2420 
  rx_ring->stats.packets += (unsigned long long)total_rx_packets;
  #line 2421 
  rx_ring->stats.bytes += (unsigned long long)total_rx_bytes;
  #line 2422 
  u64_stats_init(& rx_ring->syncp);
  #line 2423 
  q_vector->rx.total_packets += total_rx_packets;
  #line 2424 
  q_vector->rx.total_bytes += total_rx_bytes;
  #line 2426 
  return (int)total_rx_packets;
}

#line 2436  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_msix(struct ixgbe_adapter *adapter)
{
  #line 2438 
  struct ixgbe_q_vector *q_vector;
  #line 2439 
  int v_idx;
  #line 2440 
  u32 mask;
  #line 2480 
  int tmp;
  #line 2443 
  if (adapter->num_vfs > 32U) {
    #line 2444 
    u32 eitrsel = (unsigned int)(1UL << (adapter->num_vfs + 4294967264U)) + 4294967295U;
    #line 2445 
    ixgbe_write_reg_1(& adapter->hw,2196U,eitrsel);
  }
  #line 2452 
  v_idx = 0;
  #line 2452 
  while (adapter->num_q_vectors > v_idx) {
    {
      #line 2453 
      struct ixgbe_ring *ring;
      #line 2454 
      q_vector = adapter->q_vector[v_idx];
      #line 2456 
      ring = q_vector->rx.ring;
      #line 2456 
      while (ring != (struct ixgbe_ring *)0) {
        #line 2457 
        ixgbe_set_ivar(adapter,(signed char)0,(unsigned char)((int)ring->reg_idx),(unsigned char)((int)((unsigned char)v_idx)));
        #line 2456 
        ring = ring->next;
      }
      #line 2459 
      ring = q_vector->tx.ring;
      #line 2459 
      while (ring != (struct ixgbe_ring *)0) {
        #line 2460 
        ixgbe_set_ivar(adapter,(signed char)1,(unsigned char)((int)ring->reg_idx),(unsigned char)((int)((unsigned char)v_idx)));
        #line 2459 
        ring = ring->next;
      }
      #line 2462 
      ixgbe_write_eitr(q_vector);
    }
    #line 2452 
    v_idx ++;
  }
  #line 2465 
  switch ((unsigned int)adapter->hw.mac.type) {
    #line 2466 
    case (unsigned int)1: 
                          #line 2466 
    ;
    #line 2467 
    ixgbe_set_ivar(adapter,(signed char)(-1),(unsigned char)97,(unsigned char)((int)((unsigned char)v_idx)));
    #line 2469 
    break;
    #line 2470 
    case (unsigned int)2: 
                          #line 2470 
    ;
    #line 2471 
    case (unsigned int)3: 
                          #line 2471 
    ;
    #line 2472 
    case (unsigned int)4: 
                          #line 2472 
    ;
    #line 2473 
    case (unsigned int)5: 
                          #line 2473 
    ;
    #line 2474 
    case (unsigned int)6: 
                          #line 2474 
    ;
    #line 2475 
    ixgbe_set_ivar(adapter,(signed char)(-1),(unsigned char)1,(unsigned char)((int)((unsigned char)v_idx)));
    #line 2476 
    break;
    #line 2477 
    default: 
             #line 2477 
    ;
    #line 2478 
    break;
  }
  #line 2480 
  if (v_idx <= 23) 
                   #line 2480 
                   tmp = (v_idx + 520) * 4; else 
                                                 #line 2480 
                                                 tmp = (v_idx + 18600) * 4;
  #line 2480 
  ;
  #line 2480 
  ixgbe_write_reg_1(& adapter->hw,(unsigned int)tmp,1950U);
  #line 2483 
  mask = 3222339583U;
  #line 2484 
  mask &= 2145910783U;
  #line 2488 
  ixgbe_write_reg_1(& adapter->hw,2064U,mask);
  #line 2489 
  return;
}

#line 2504  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_update_itr(struct ixgbe_q_vector *q_vector, struct ixgbe_ring_container *ring_container)
{
  #line 2509 
  unsigned int avg_wire_size;
  #line 2509 
  unsigned int packets;
  #line 2509 
  unsigned int bytes;
  #line 2507 
  unsigned int itr = 138U;
  #line 2510 
  unsigned long next_update = jiffies;
  #line 2515 
  if (ring_container->ring == (struct ixgbe_ring *)0) 
                                                      #line 2516 
                                                      return;
  {
    #line 2523 
    unsigned long __dummy;
    #line 2523 
    unsigned long __dummy2;
    }
  #line 2523 
  if (1 != 0) {
    {
      #line 2523 
      unsigned long __dummy_0;
      #line 2523 
      unsigned long __dummy2_0;
      }
    #line 2523 
    if (1 != 0) 
      #line 2523 
      if ((long)(ring_container->next_update - next_update) < 0L) 
                                                                  #line 2524 
                                                                  goto clear_counts;
  }
  #line 2526 
  packets = ring_container->total_packets;
  #line 2536 
  if (packets == 0U) {
    #line 2537 
    itr = (unsigned int)(((int)q_vector->itr >> 2) + 2);
    #line 2538 
    if (itr > 126U) 
                    #line 2539 
                    itr = 126U;
    #line 2540 
    itr = ((unsigned int)ring_container->itr & 128U) + itr;
    #line 2541 
    goto clear_counts;
  }
  #line 2544 
  bytes = ring_container->total_bytes;
  #line 2550 
  if (packets <= 3U && bytes <= 8999U) {
    #line 2551 
    itr = 128U;
    #line 2552 
    goto adjust_by_size;
  }
  #line 2559 
  if (packets <= 47U) {
    #line 2560 
    itr = (unsigned int)(((int)q_vector->itr >> 2) + 2);
    #line 2561 
    if (itr > 126U) 
                    #line 2562 
                    itr = 126U;
    #line 2563 
    goto clear_counts;
  }
  #line 2569 
  if (packets <= 95U) {
    #line 2570 
    itr = (unsigned int)((int)q_vector->itr >> 2);
    #line 2571 
    goto clear_counts;
  }
  #line 2578 
  if (packets <= 255U) {
    #line 2579 
    itr = (unsigned int)((int)q_vector->itr >> 3);
    #line 2580 
    if (itr <= 9U) 
                   #line 2581 
                   itr = 10U;
    #line 2582 
    goto clear_counts;
  }
  #line 2591 
  itr = 0U;
  #line 2593 
  adjust_by_size: 
                  #line 2593 
  ;
  #line 2599 
  avg_wire_size = bytes / packets;
  #line 2616 
  if (avg_wire_size <= 60U) 
                            #line 2618 
                            avg_wire_size = 5120U;
  else 
    #line 2619 
    if (avg_wire_size <= 316U) {
      #line 2621 
      avg_wire_size *= 40U;
      #line 2622 
      avg_wire_size += 2720U;
    }
    else 
      #line 2623 
      if (avg_wire_size <= 1084U) {
        #line 2625 
        avg_wire_size *= 15U;
        #line 2626 
        avg_wire_size += 11452U;
      }
      else 
        #line 2627 
        if (avg_wire_size <= 1967U) {
          #line 2629 
          avg_wire_size *= 5U;
          #line 2630 
          avg_wire_size += 22420U;
        }
        else 
             #line 2633 
             avg_wire_size = 32256U;
  #line 2639 
  if ((itr & 128U) != 0U) 
                          #line 2640 
                          avg_wire_size >>= 1;
  #line 2649 
  switch ((q_vector->adapter)->link_speed) {
    #line 2650 
    case (u32)128: 
                   #line 2650 
    ;
    #line 2651 
    case (u32)8: 
                 #line 2651 
    ;
    #line 2652 
    default: 
             #line 2652 
    ;
    #line 2653 
    itr = ((avg_wire_size + 511U) / 512U) * 2U + itr;
    #line 2656 
    break;
    #line 2657 
    case (u32)1024: 
                    #line 2657 
    ;
    #line 2658 
    case (u32)32: 
                  #line 2658 
    ;
    #line 2659 
    case (u32)2: 
                 #line 2659 
    ;
    #line 2660 
    if (avg_wire_size > 8064U) 
                               #line 2661 
                               avg_wire_size = 8064U;
    #line 2662 
    itr = ((avg_wire_size + 127U) / 128U) * 2U + itr;
    #line 2665 
    break;
  }
  #line 2668 
  clear_counts: 
                #line 2668 
  ;
  #line 2670 
  ring_container->itr = (unsigned char)itr;
  #line 2673 
  ring_container->next_update = next_update + 1UL;
  #line 2675 
  ring_container->total_bytes = 0U;
  #line 2676 
  ring_container->total_packets = 0U;
  #line 2677 
  return;
}

#line 2687  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_write_eitr(struct ixgbe_q_vector *q_vector)
{
  #line 2713 
  int tmp;
  #line 2689 
  struct ixgbe_adapter *adapter = q_vector->adapter;
  #line 2690 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 2691 
  int v_idx = (int)q_vector->v_idx;
  #line 2692 
  u32 itr_reg = (unsigned int)q_vector->itr & 4088U;
  #line 2694 
  switch ((unsigned int)adapter->hw.mac.type) {
    #line 2695 
    case (unsigned int)1: 
                          #line 2695 
    ;
    #line 2697 
    itr_reg = (itr_reg << 16) | itr_reg;
    #line 2698 
    break;
    #line 2699 
    case (unsigned int)2: 
                          #line 2699 
    ;
    #line 2700 
    case (unsigned int)3: 
                          #line 2700 
    ;
    #line 2701 
    case (unsigned int)4: 
                          #line 2701 
    ;
    #line 2702 
    case (unsigned int)5: 
                          #line 2702 
    ;
    #line 2703 
    case (unsigned int)6: 
                          #line 2703 
    ;
    #line 2708 
    itr_reg |= 2147483648U;
    #line 2709 
    break;
    #line 2710 
    default: 
             #line 2710 
    ;
    #line 2711 
    break;
  }
  #line 2713 
  ;
  #line 2713 
  if (v_idx <= 23) 
                   #line 2713 
                   tmp = (v_idx + 520) * 4; else 
                                                 #line 2713 
                                                 tmp = (v_idx + 18600) * 4;
  #line 2713 
  ;
  #line 2713 
  ixgbe_write_reg_1(hw,(unsigned int)tmp,itr_reg);
  #line 2714 
  return;
}

#line 2716  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_set_itr(struct ixgbe_q_vector *q_vector)
{
  #line 2724 
  u8 __UNIQUE_ID___x572;
  #line 2724 
  int tmp;
  #line 2718 
  u32 new_itr;
  #line 2720 
  ixgbe_update_itr(q_vector,& q_vector->tx);
  #line 2721 
  ixgbe_update_itr(q_vector,& q_vector->rx);
  {
    #line 2724 
    __UNIQUE_ID___x572 = q_vector->rx.itr;
    #line 2724 
    u8 __UNIQUE_ID___y573 = q_vector->tx.itr;
    #line 2724 
    if ((int)__UNIQUE_ID___x572 < (int)__UNIQUE_ID___y573) 
                                                           #line 2724 
                                                           tmp = (int)__UNIQUE_ID___x572; else 
                                                                    #line 2724 
                                                                    tmp = (int)__UNIQUE_ID___y573;
    }
  #line 2724 
  new_itr = (unsigned int)tmp;
  #line 2727 
  new_itr &= 4294967167U;
  #line 2728 
  new_itr <<= 2;
  #line 2730 
  if ((unsigned int)q_vector->itr != new_itr) {
    #line 2732 
    q_vector->itr = (unsigned short)new_itr;
    #line 2734 
    ixgbe_write_eitr(q_vector);
  }
  #line 2736 
  return;
}

#line 2742  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_overtemp_subtask(struct ixgbe_adapter *adapter)
{
  #line 2746 
  s32 rc;
  #line 2744 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 2745 
  u32 eicr = adapter->interrupt_event;
  #line 2748 
  if ((int)test_bit(2L,& adapter->state) != 0) 
                                               #line 2749 
                                               return;
  #line 2751 
  if (((unsigned long)adapter->flags2 & 8UL) == 0UL) 
                                                     #line 2752 
                                                     return;
  #line 2754 
  adapter->flags2 &= 4294967287U;
  #line 2756 
  switch ((int)hw->device_id) {
    #line 2757 
    case 5404: 
               #line 2757 
    ;
    #line 2765 
    if ((eicr & 16777216U) == 0U && (eicr & 1048576U) == 0U) 
                                                             #line 2767 
                                                             return;
    #line 2769 
    if ((eicr & 1048576U) == 0U && hw->mac.ops.check_link != (s32 (*)(struct ixgbe_hw *, ixgbe_link_speed *, bool *, bool ))0) {
      #line 2770 
      u32 speed;
      #line 2771 
      bool link_up = (_Bool)0;
      #line 2773 
      (*(hw->mac.ops.check_link))(hw,& speed,& link_up,(_Bool)0);
      #line 2775 
      if ((int)link_up != 0) 
                             #line 2776 
                             return;
    }
    #line 2780 
    if ((*(hw->phy.ops.check_overtemp))(hw) != -26) 
                                                    #line 2781 
                                                    return;
    #line 2783 
    break;
    #line 2784 
    case 5604: 
               #line 2784 
    ;
    #line 2785 
    case 5605: 
               #line 2785 
    ;
    #line 2786 
    rc = (*(hw->phy.ops.check_overtemp))(hw);
    #line 2787 
    if (rc != -26) 
                   #line 2788 
                   return;
    #line 2789 
    break;
    #line 2790 
    default: 
             #line 2790 
    ;
    #line 2791 
    if (adapter->hw.mac.type > (unsigned int)ixgbe_mac_82599EB) 
                                                                #line 2792 
                                                                return;
    #line 2793 
    if ((*(hw->mvals + 10U) & eicr) == 0U) 
                                           #line 2794 
                                           return;
    #line 2795 
    break;
  }
  #line 2797 
  if (((int)adapter->msg_enable & 1) != 0) 
                                           #line 2797 
                                           netdev_crit(adapter->netdev,(char *)"%s\n",(char *)(& ixgbe_overheat_msg));
  #line 2799 
  adapter->interrupt_event = 0U;
  #line 2800 
  return;
}

#line 2802  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_fan_failure(struct ixgbe_adapter *adapter, u32 eicr)
{
  #line 2804 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 2806 
  if (((unsigned long)adapter->flags & 32768UL) != 0UL && (*(hw->mvals + 11U) & eicr) != 0U) {
    #line 2808 
    if (((int)adapter->msg_enable & 2) != 0) 
                                             #line 2808 
                                             netdev_crit(adapter->netdev,(char *)"Fan has stopped, replace the adapter\n");
    #line 2810 
    ixgbe_write_reg_1(hw,2048U,*(hw->mvals + 11U));
  }
  #line 2812 
  return;
}

#line 2814  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_overtemp_event(struct ixgbe_adapter *adapter, u32 eicr)
{
  #line 2816 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 2818 
  if (((unsigned long)adapter->flags2 & 4UL) == 0UL) 
                                                     #line 2819 
                                                     return;
  #line 2821 
  switch ((unsigned int)adapter->hw.mac.type) {
    #line 2822 
    case (unsigned int)2: 
                          #line 2822 
    ;
    #line 2827 
    if ((*(hw->mvals + 10U) & eicr) != 0U || (eicr & 1048576U) != 0U) {
      #line 2829 
      if (! test_bit(2L,& adapter->state)) {
        #line 2830 
        adapter->interrupt_event = eicr;
        #line 2831 
        adapter->flags2 |= 8U;
        #line 2832 
        ixgbe_service_event_schedule(adapter);
        #line 2833 
        return;
      }
    }
    #line 2835 
    return;
    #line 2836 
    case (unsigned int)6: 
                          #line 2836 
    ;
    #line 2837 
    if ((eicr & 33554432U) != 0U) {
      #line 2838 
      adapter->interrupt_event = eicr;
      #line 2839 
      adapter->flags2 |= 8U;
      #line 2840 
      ixgbe_service_event_schedule(adapter);
      #line 2841 
      ixgbe_write_reg_1(& adapter->hw,2184U,33554432U);
      #line 2843 
      ixgbe_write_reg_1(& adapter->hw,2048U,33554432U);
    }
    #line 2846 
    return;
    #line 2847 
    case (unsigned int)4: 
                          #line 2847 
    ;
    #line 2848 
    case (unsigned int)3: 
                          #line 2848 
    ;
    #line 2849 
    if ((eicr & 8388608U) == 0U) 
                                 #line 2850 
                                 return;
    #line 2851 
    break;
    #line 2852 
    default: 
             #line 2852 
    ;
    #line 2853 
    return;
  }
  #line 2856 
  if (((int)adapter->msg_enable & 1) != 0) 
                                           #line 2856 
                                           netdev_crit(adapter->netdev,(char *)"%s\n",(char *)(& ixgbe_overheat_msg));
  #line 2857 
  return;
}

#line 2859  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static bool ixgbe_is_sfp(struct ixgbe_hw *hw)
{
  #line 2861 
  switch ((unsigned int)hw->mac.type) {
    #line 2862 
    case (unsigned int)1: 
                          #line 2862 
    ;
    #line 2863 
    if (hw->phy.type == (unsigned int)ixgbe_phy_nl) 
                                                    #line 2864 
                                                    return (_Bool)1;
    #line 2865 
    return (_Bool)0;
    #line 2866 
    case (unsigned int)2: 
                          #line 2866 
    ;
    #line 2867 
    case (unsigned int)5: 
                          #line 2867 
    ;
    #line 2868 
    case (unsigned int)6: 
                          #line 2868 
    ;
    #line 2869 
    switch ((unsigned int)(*(hw->mac.ops.get_media_type))(hw)) {
      #line 2870 
      case (unsigned int)1: 
                            #line 2870 
      ;
      #line 2871 
      case (unsigned int)2: 
                            #line 2871 
      ;
      #line 2872 
      return (_Bool)1;
      #line 2873 
      default: 
               #line 2873 
      ;
      #line 2874 
      return (_Bool)0;
    }
    #line 2876 
    default: 
             #line 2876 
    ;
    #line 2877 
    return (_Bool)0;
  }
}

#line 2881  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_sfp_event(struct ixgbe_adapter *adapter, u32 eicr)
{
  #line 2883 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 2884 
  u32 eicr_mask = *(hw->mvals + 12U);
  #line 2886 
  if (! ixgbe_is_sfp(hw)) 
                          #line 2887 
                          return;
  #line 2890 
  if (hw->mac.type > (unsigned int)ixgbe_mac_82599EB) 
                                                      #line 2891 
                                                      eicr_mask = 33554432U;
  #line 2893 
  if ((eicr & eicr_mask) != 0U) {
    #line 2895 
    ixgbe_write_reg_1(hw,2048U,eicr_mask);
    #line 2896 
    if (! test_bit(2L,& adapter->state)) {
      #line 2897 
      adapter->flags2 |= 32U;
      #line 2898 
      adapter->sfp_poll_time = 0UL;
      #line 2899 
      ixgbe_service_event_schedule(adapter);
    }
  }
  #line 2903 
  if (adapter->hw.mac.type == (unsigned int)ixgbe_mac_82599EB && (*(hw->mvals + 11U) & eicr) != 0U) {
    #line 2906 
    ixgbe_write_reg_1(hw,2048U,*(hw->mvals + 11U));
    #line 2907 
    if (! test_bit(2L,& adapter->state)) {
      #line 2908 
      adapter->flags |= 131072U;
      #line 2909 
      ixgbe_service_event_schedule(adapter);
    }
  }
  #line 2912 
  return;
}

#line 2914  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_lsc(struct ixgbe_adapter *adapter)
{
  #line 2916 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 2918 
  (adapter->lsc_int) ++;
  #line 2919 
  adapter->flags |= 65536U;
  #line 2920 
  adapter->link_check_timeout = jiffies;
  #line 2921 
  if (! test_bit(2L,& adapter->state)) {
    #line 2922 
    ixgbe_write_reg_1(hw,2184U,1048576U);
    #line 2923 
    ixgbe_read_reg(hw,8U);
    #line 2924 
    ixgbe_service_event_schedule(adapter);
  }
  #line 2926 
  return;
}

#line 2928  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static void ixgbe_irq_enable_queues(struct ixgbe_adapter *adapter, u64 qmask)
{
  #line 2931 
  u32 mask;
  #line 2932 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 2934 
  switch ((unsigned int)hw->mac.type) {
    #line 2935 
    case (unsigned int)1: 
                          #line 2935 
    ;
    #line 2936 
    mask = (unsigned int)qmask & 65535U;
    #line 2937 
    ixgbe_write_reg_1(hw,2176U,mask);
    #line 2938 
    break;
    #line 2939 
    case (unsigned int)2: 
                          #line 2939 
    ;
    #line 2940 
    case (unsigned int)3: 
                          #line 2940 
    ;
    #line 2941 
    case (unsigned int)4: 
                          #line 2941 
    ;
    #line 2942 
    case (unsigned int)5: 
                          #line 2942 
    ;
    #line 2943 
    case (unsigned int)6: 
                          #line 2943 
    ;
    #line 2944 
    mask = (unsigned int)qmask;
    #line 2945 
    if (mask != 0U) 
                    #line 2946 
                    ixgbe_write_reg_1(hw,2720U,mask);
    #line 2947 
    mask = (unsigned int)(qmask >> 32);
    #line 2948 
    if (mask != 0U) 
                    #line 2949 
                    ixgbe_write_reg_1(hw,2724U,mask);
    #line 2950 
    break;
    #line 2951 
    default: 
             #line 2951 
    ;
    #line 2952 
    break;
  }
  #line 2954 
  return;
}

#line 2992  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static void ixgbe_irq_enable(struct ixgbe_adapter *adapter, bool queues, bool flush)
{
  #line 2995 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 2996 
  u32 mask = 3222274048U;
  #line 2999 
  if (((unsigned long)adapter->flags & 65536UL) != 0UL) 
                                                        #line 3000 
                                                        mask &= 4293918719U;
  #line 3002 
  if (((unsigned long)adapter->flags2 & 4UL) != 0UL) 
    #line 3003 
    switch ((unsigned int)adapter->hw.mac.type) {
      #line 3004 
      case (unsigned int)2: 
                            #line 3004 
      ;
      #line 3005 
      mask = *(hw->mvals + 10U) | mask;
      #line 3006 
      break;
      #line 3007 
      case (unsigned int)3: 
                            #line 3007 
      ;
      #line 3008 
      case (unsigned int)4: 
                            #line 3008 
      ;
      #line 3009 
      case (unsigned int)5: 
                            #line 3009 
      ;
      #line 3010 
      case (unsigned int)6: 
                            #line 3010 
      ;
      #line 3011 
      mask |= 8388608U;
      #line 3012 
      break;
      #line 3013 
      default: 
               #line 3013 
      ;
      #line 3014 
      break;
    }
  #line 3016 
  if (((unsigned long)adapter->flags & 32768UL) != 0UL) 
                                                        #line 3017 
                                                        mask = *(hw->mvals + 11U) | mask;
  #line 3018 
  switch ((unsigned int)adapter->hw.mac.type) {
    #line 3019 
    case (unsigned int)2: 
                          #line 3019 
    ;
    #line 3020 
    mask = *(hw->mvals + 11U) | mask;
    #line 3021 
    mask = *(hw->mvals + 12U) | mask;
    #line 3023 
    case (unsigned int)3: 
                          #line 3023 
    ;
    #line 3024 
    case (unsigned int)4: 
                          #line 3024 
    ;
    #line 3025 
    case (unsigned int)5: 
                          #line 3025 
    ;
    #line 3026 
    case (unsigned int)6: 
                          #line 3026 
    ;
    #line 3027 
    if (((unsigned int)adapter->hw.device_id == 5548U || (unsigned int)adapter->hw.device_id == 5582U) || (unsigned int)adapter->hw.device_id == 5572U) 
      #line 3030 
      mask = *(adapter->hw.mvals + 10U) | mask;
    #line 3031 
    if (adapter->hw.phy.type == (unsigned int)ixgbe_phy_x550em_ext_t) 
      #line 3032 
      mask |= 33554432U;
    #line 3033 
    mask |= 268435456U;
    #line 3034 
    mask |= 524288U;
    #line 3035 
    break;
    #line 3036 
    default: 
             #line 3036 
    ;
    #line 3037 
    break;
  }
  #line 3040 
  if (((unsigned long)adapter->flags & 262144UL) != 0UL && ((unsigned long)adapter->flags2 & 128UL) == 0UL) 
    #line 3042 
    mask |= 65536U;
  #line 3044 
  ixgbe_write_reg_1(& adapter->hw,2176U,mask);
  #line 3045 
  if ((int)queues != 0) 
                        #line 3046 
                        ixgbe_irq_enable_queues(adapter,18446744073709551615ULL);
  #line 3047 
  if ((int)flush != 0) 
                       #line 3048 
                       ixgbe_read_reg(& adapter->hw,8U);
  #line 3049 
  return;
}

#line 3051  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static irqreturn_t ixgbe_msix_other(int irq, void *data)
{
  #line 3055 
  u32 eicr;
  #line 3053 
  struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
  #line 3054 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 3063 
  eicr = ixgbe_read_reg(hw,2056U);
  #line 3072 
  eicr &= 4294901760U;
  #line 3074 
  ixgbe_write_reg_1(hw,2048U,eicr);
  #line 3076 
  if ((eicr & 1048576U) != 0U) 
                               #line 3077 
                               ixgbe_check_lsc(adapter);
  #line 3079 
  if ((eicr & 524288U) != 0U) 
                              #line 3080 
                              ixgbe_msg_task(adapter);
  #line 3082 
  switch ((unsigned int)hw->mac.type) {
    #line 3083 
    case (unsigned int)2: 
                          #line 3083 
    ;
    #line 3084 
    case (unsigned int)3: 
                          #line 3084 
    ;
    #line 3085 
    case (unsigned int)4: 
                          #line 3085 
    ;
    #line 3086 
    case (unsigned int)5: 
                          #line 3086 
    ;
    #line 3087 
    case (unsigned int)6: 
                          #line 3087 
    ;
    #line 3088 
    if (hw->phy.type == (unsigned int)ixgbe_phy_x550em_ext_t && (eicr & 33554432U) != 0U) {
      #line 3090 
      adapter->flags2 |= 2048U;
      #line 3091 
      ixgbe_service_event_schedule(adapter);
      #line 3092 
      ixgbe_write_reg_1(hw,2048U,33554432U);
    }
    #line 3095 
    if ((eicr & 268435456U) != 0U) {
      #line 3096 
      if (((int)adapter->msg_enable & 4) != 0) 
                                               #line 3096 
                                               netdev_info(adapter->netdev,(char *)"Received ECC Err, initiating reset\n");
      #line 3097 
      cif_set_bit(10L,& adapter->state);
      #line 3098 
      ixgbe_service_event_schedule(adapter);
      #line 3099 
      ixgbe_write_reg_1(hw,2048U,268435456U);
    }
    #line 3102 
    if ((eicr & 65536U) != 0U) {
      #line 3104 
      int i;
      #line 3103 
      int reinit_count = 0;
      #line 3105 
      i = 0;
      #line 3105 
      while (adapter->num_tx_queues > i) {
        {
          #line 3106 
          struct ixgbe_ring *ring = adapter->tx_ring[i];
          #line 3107 
          if ((int)test_and_set_bit(5L,& ring->state) != 0) 
                                                            #line 3109 
                                                            reinit_count ++;
        }
        #line 3105 
        i ++;
      }
      #line 3111 
      if (reinit_count != 0) {
        #line 3113 
        ixgbe_write_reg_1(hw,2184U,65536U);
        #line 3114 
        adapter->flags2 |= 128U;
        #line 3115 
        ixgbe_service_event_schedule(adapter);
      }
    }
    #line 3118 
    ixgbe_check_sfp_event(adapter,eicr);
    #line 3119 
    ixgbe_check_overtemp_event(adapter,eicr);
    #line 3120 
    break;
    #line 3121 
    default: 
             #line 3121 
    ;
    #line 3122 
    break;
  }
  #line 3125 
  ixgbe_check_fan_failure(adapter,eicr);
  #line 3127 
  if ((long)((eicr & 16777216U) != 0U) != 0L) 
                                              #line 3128 
                                              ixgbe_ptp_check_pps_event(adapter);
  #line 3131 
  if (! test_bit(2L,& adapter->state)) 
                                       #line 3132 
                                       ixgbe_irq_enable(adapter,(_Bool)0,(_Bool)0);
  #line 3134 
  return IRQ_HANDLED;
}

#line 3137  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static irqreturn_t ixgbe_msix_clean_rings(int irq, void *data)
{
  #line 3139 
  struct ixgbe_q_vector *q_vector = (struct ixgbe_q_vector *)data;
  #line 3143 
  if (q_vector->rx.ring != (struct ixgbe_ring *)0 || q_vector->tx.ring != (struct ixgbe_ring *)0) 
    #line 3144 
    napi_schedule_irqoff(& q_vector->napi);
  #line 3146 
  return IRQ_HANDLED;
}

#line 3156  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_poll(struct napi_struct *napi, int budget)
{
  #line 3159 
  void *__mptr;
  #line 3215 
  int __UNIQUE_ID___x576;
  #line 3215 
  int tmp_10;
  #line 3161 
  struct ixgbe_ring *ring;
  #line 3162 
  int per_ring_budget;
  #line 3159 
  __mptr = (void *)napi;
  #line 3158 
  struct ixgbe_q_vector *q_vector = ((struct ixgbe_q_vector *)(__mptr + 18446744073709551536U));
  #line 3160 
  struct ixgbe_adapter *adapter = q_vector->adapter;
  #line 3162 
  int work_done = 0;
  #line 3163 
  bool clean_complete = (_Bool)1;
  #line 3166 
  if (((unsigned long)adapter->flags & 256UL) != 0UL) 
                                                      #line 3167 
                                                      ixgbe_update_dca(q_vector);
  #line 3170 
  ring = q_vector->tx.ring;
  #line 3170 
  while (ring != (struct ixgbe_ring *)0) {
    {
      #line 3171 
      int tmp_2;
      #line 3171 
      if (ring->xsk_umem != (struct xdp_umem *)0) {
        #line 3171 
        tmp_2 = (int)ixgbe_clean_xdp_tx_irq(q_vector,ring,budget) != 0;
      }
      else {
        #line 3171 
        tmp_2 = (int)ixgbe_clean_tx_irq(q_vector,ring,budget) != 0;
      }
      #line 3171 
      bool wd = (_Bool)(tmp_2 != 0);
      #line 3175 
      if (! wd) 
                #line 3176 
                clean_complete = (_Bool)0;
    }
    #line 3170 
    ring = ring->next;
  }
  #line 3180 
  if (budget <= 0) 
                   #line 3181 
                   return budget;
  #line 3185 
  if ((unsigned int)q_vector->rx.count > 1U) {
    #line 3186 
    int tmp_3;
    #line 3186 
    int __UNIQUE_ID___x574;
    {
      #line 3186 
      __UNIQUE_ID___x574 = budget / (int)q_vector->rx.count;
      #line 3186 
      int __UNIQUE_ID___y575 = 1;
      #line 3186 
      if (__UNIQUE_ID___x574 > __UNIQUE_ID___y575) 
                                                   #line 3186 
                                                   tmp_3 = __UNIQUE_ID___x574; else 
                                                                    #line 3186 
                                                                    tmp_3 = __UNIQUE_ID___y575;
      }
    #line 3186 
    per_ring_budget = tmp_3;
  }
  else 
       #line 3188 
       per_ring_budget = budget;
  #line 3190 
  ring = q_vector->rx.ring;
  #line 3190 
  while (ring != (struct ixgbe_ring *)0) {
    {
      #line 3191 
      int tmp_7;
      #line 3191 
      if (ring->xsk_umem != (struct xdp_umem *)0) 
                                                  #line 3191 
                                                  tmp_7 = ixgbe_clean_rx_irq_zc(q_vector,ring,per_ring_budget); else 
                                                                    #line 3193 
                                                                    tmp_7 = ixgbe_clean_rx_irq(q_vector,ring,per_ring_budget);
      #line 3191 
      int cleaned = tmp_7;
      #line 3197 
      work_done += cleaned;
      #line 3198 
      if (cleaned >= per_ring_budget) 
                                      #line 3199 
                                      clean_complete = (_Bool)0;
    }
    #line 3190 
    ring = ring->next;
  }
  #line 3203 
  if (! clean_complete) 
                        #line 3204 
                        return budget;
  #line 3207 
  if ((long)((int)napi_complete_done(napi,work_done) != 0) != 0L) {
    #line 3208 
    if (((int)adapter->rx_itr_setting & 1) != 0) 
                                                 #line 3209 
                                                 ixgbe_set_itr(q_vector);
    #line 3210 
    if (! test_bit(2L,& adapter->state)) 
                                         #line 3211 
                                         ixgbe_irq_enable_queues(adapter,1ULL << (int)q_vector->v_idx);
  }
  {
    #line 3215 
    __UNIQUE_ID___x576 = work_done;
    #line 3215 
    int __UNIQUE_ID___y577 = budget + -1;
    #line 3215 
    if (__UNIQUE_ID___x576 < __UNIQUE_ID___y577) 
                                                 #line 3215 
                                                 tmp_10 = __UNIQUE_ID___x576; else 
                                                                    #line 3215 
                                                                    tmp_10 = __UNIQUE_ID___y577;
    }
  #line 3215 
  return tmp_10;
}

#line 3225  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_request_msix_irqs(struct ixgbe_adapter *adapter)
{
  #line 3229 
  int vector;
  #line 3229 
  int err;
  #line 3227 
  struct net_device *netdev = adapter->netdev;
  #line 3228 
  unsigned int ri = 0U;
  #line 3228 
  unsigned int ti = 0U;
  #line 3231 
  vector = 0;
  #line 3231 
  while (adapter->num_q_vectors > vector) {
    {
      #line 3232 
      struct ixgbe_q_vector *q_vector = adapter->q_vector[vector];
      #line 3233 
      struct msix_entry *entry = adapter->msix_entries + (unsigned long)vector;
      #line 3235 
      if (q_vector->tx.ring != (struct ixgbe_ring *)0 && q_vector->rx.ring != (struct ixgbe_ring *)0) {
        #line 3237 
        unsigned int tmp;
        #line 3237 
        tmp = ri;
        #line 3237 
        ri ++;
        #line 3236 
        ;
        #line 3236 
        ;
        #line 3236 
        ;
        #line 3236 
        snprintf((char *)(& q_vector->name),25UL,(char *)"%s-TxRx-%u",(char *)(& netdev->name),tmp);
        #line 3238 
        ti ++;
      }
      else 
        #line 3239 
        if (q_vector->rx.ring != (struct ixgbe_ring *)0) {
          #line 3241 
          unsigned int tmp_0;
          #line 3241 
          tmp_0 = ri;
          #line 3241 
          ri ++;
          #line 3240 
          ;
          #line 3240 
          ;
          #line 3240 
          ;
          #line 3240 
          snprintf((char *)(& q_vector->name),25UL,(char *)"%s-rx-%u",(char *)(& netdev->name),tmp_0);
        }
        else 
          #line 3242 
          if (q_vector->tx.ring != (struct ixgbe_ring *)0) {
            #line 3244 
            unsigned int tmp_1;
            #line 3244 
            tmp_1 = ti;
            #line 3244 
            ti ++;
            #line 3243 
            ;
            #line 3243 
            ;
            #line 3243 
            ;
            #line 3243 
            snprintf((char *)(& q_vector->name),25UL,(char *)"%s-tx-%u",(char *)(& netdev->name),tmp_1);
          }
          else 
               #line 3247 
               goto __Cont;
      #line 3249 
      err = cif_request_irq(entry->vector,& ixgbe_msix_clean_rings,0UL,(char *)(& q_vector->name),(void *)q_vector);
      #line 3251 
      if (err != 0) {
        #line 3252 
        if (((int)adapter->msg_enable & 2) != 0) 
                                                 #line 3252 
                                                 netdev_err(adapter->netdev,(char *)"request_irq failed for MSIX interrupt ",err);
        #line 3254 
        goto free_queue_irqs;
      }
      #line 3257 
      if (((unsigned long)adapter->flags & 262144UL) != 0UL) 
                                                             #line 3259 
                                                             irq_set_affinity_hint(entry->vector,& q_vector->affinity_mask);
    }
    #line 3231 
    __Cont: 
            #line 3231 
    vector ++;
  }
  #line 3264 
  err = cif_request_irq((adapter->msix_entries + (unsigned long)vector)->vector,& ixgbe_msix_other,0UL,(char *)(& netdev->name),(void *)adapter);
  #line 3266 
  if (err != 0) {
    #line 3267 
    if (((int)adapter->msg_enable & 2) != 0) 
                                             #line 3267 
                                             netdev_err(adapter->netdev,(char *)"request_irq for msix_other failed: %d\n",err);
    #line 3268 
    goto free_queue_irqs;
  }
  #line 3271 
  return 0;
  #line 3273 
  free_queue_irqs: 
                   #line 3273 
  ;
  #line 3274 
  while (vector != 0) {
    #line 3275 
    vector --;
    #line 3276 
    irq_set_affinity_hint((adapter->msix_entries + (unsigned long)vector)->vector,(struct cpumask *)0);
    #line 3278 
    cif_free_irq((adapter->msix_entries + (unsigned long)vector)->vector,(void *)adapter->q_vector[vector]);
  }
  #line 3281 
  adapter->flags &= 4294967287U;
  #line 3282 
  pci_disable_msix(adapter->pdev);
  #line 3283 
  kfree((void *)adapter->msix_entries);
  #line 3284 
  adapter->msix_entries = (struct msix_entry *)0;
  #line 3285 
  return err;
}

#line 3293  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static irqreturn_t ixgbe_intr(int irq, void *data)
{
  #line 3298 
  u32 eicr;
  #line 3295 
  struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
  #line 3296 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 3297 
  struct ixgbe_q_vector *q_vector = adapter->q_vector[0];
  #line 3304 
  ixgbe_write_reg_1(hw,2184U,4294967295U);
  #line 3308 
  eicr = ixgbe_read_reg(hw,2048U);
  #line 3309 
  if (eicr == 0U) {
    #line 3317 
    if (! test_bit(2L,& adapter->state)) 
                                         #line 3318 
                                         ixgbe_irq_enable(adapter,(_Bool)1,(_Bool)1);
    #line 3319 
    return IRQ_NONE;
  }
  #line 3322 
  if ((eicr & 1048576U) != 0U) 
                               #line 3323 
                               ixgbe_check_lsc(adapter);
  #line 3325 
  switch ((unsigned int)hw->mac.type) {
    #line 3326 
    case (unsigned int)2: 
                          #line 3326 
    ;
    #line 3327 
    ixgbe_check_sfp_event(adapter,eicr);
    #line 3329 
    case (unsigned int)3: 
                          #line 3329 
    ;
    #line 3330 
    case (unsigned int)4: 
                          #line 3330 
    ;
    #line 3331 
    case (unsigned int)5: 
                          #line 3331 
    ;
    #line 3332 
    case (unsigned int)6: 
                          #line 3332 
    ;
    #line 3333 
    if ((eicr & 268435456U) != 0U) {
      #line 3334 
      if (((int)adapter->msg_enable & 4) != 0) 
                                               #line 3334 
                                               netdev_info(adapter->netdev,(char *)"Received ECC Err, initiating reset\n");
      #line 3335 
      cif_set_bit(10L,& adapter->state);
      #line 3336 
      ixgbe_service_event_schedule(adapter);
      #line 3337 
      ixgbe_write_reg_1(hw,2048U,268435456U);
    }
    #line 3339 
    ixgbe_check_overtemp_event(adapter,eicr);
    #line 3340 
    break;
    #line 3341 
    default: 
             #line 3341 
    ;
    #line 3342 
    break;
  }
  #line 3345 
  ixgbe_check_fan_failure(adapter,eicr);
  #line 3346 
  if ((long)((eicr & 16777216U) != 0U) != 0L) 
                                              #line 3347 
                                              ixgbe_ptp_check_pps_event(adapter);
  #line 3350 
  napi_schedule_irqoff(& q_vector->napi);
  #line 3356 
  if (! test_bit(2L,& adapter->state)) 
                                       #line 3357 
                                       ixgbe_irq_enable(adapter,(_Bool)0,(_Bool)0);
  #line 3359 
  return IRQ_HANDLED;
}

#line 3369  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_request_irq(struct ixgbe_adapter *adapter)
{
  #line 3372 
  int err;
  #line 3371 
  struct net_device *netdev = adapter->netdev;
  #line 3374 
  if (((unsigned long)adapter->flags & 8UL) != 0UL) 
                                                    #line 3375 
                                                    err = ixgbe_request_msix_irqs(adapter);
  else 
    #line 3376 
    if (((unsigned long)adapter->flags & 2UL) != 0UL) 
                                                      #line 3377 
                                                      err = cif_request_irq((adapter->pdev)->irq,& ixgbe_intr,0UL,(char *)(& netdev->name),(void *)adapter); else 
                                                                    #line 3380 
                                                                    err = cif_request_irq((adapter->pdev)->irq,& ixgbe_intr,128UL,(char *)(& netdev->name),(void *)adapter);
  #line 3383 
  if (err != 0) 
    #line 3384 
    if (((int)adapter->msg_enable & 2) != 0) 
                                             #line 3384 
                                             netdev_err(adapter->netdev,(char *)"request_irq failed, Error %d\n",err);
  #line 3386 
  return err;
}

#line 3389  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_free_irq(struct ixgbe_adapter *adapter)
{
  #line 3391 
  int vector;
  #line 3393 
  if (((unsigned long)adapter->flags & 8UL) == 0UL) {
    #line 3394 
    cif_free_irq((adapter->pdev)->irq,(void *)adapter);
    #line 3395 
    return;
  }
  #line 3398 
  if (adapter->msix_entries == (struct msix_entry *)0) 
                                                       #line 3399 
                                                       return;
  #line 3401 
  vector = 0;
  #line 3401 
  while (adapter->num_q_vectors > vector) {
    {
      #line 3402 
      struct ixgbe_q_vector *q_vector = adapter->q_vector[vector];
      #line 3403 
      struct msix_entry *entry = adapter->msix_entries + (unsigned long)vector;
      #line 3406 
      if (q_vector->rx.ring == (struct ixgbe_ring *)0 && q_vector->tx.ring == (struct ixgbe_ring *)0) 
        #line 3407 
        goto __Cont;
      #line 3410 
      irq_set_affinity_hint(entry->vector,(struct cpumask *)0);
      #line 3412 
      cif_free_irq(entry->vector,(void *)q_vector);
    }
    #line 3401 
    __Cont: 
            #line 3401 
    vector ++;
  }
  #line 3415 
  cif_free_irq((adapter->msix_entries + (unsigned long)vector)->vector,(void *)adapter);
  #line 3416 
  return;
}

#line 3422  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static void ixgbe_irq_disable(struct ixgbe_adapter *adapter)
{
  #line 3424 
  switch ((unsigned int)adapter->hw.mac.type) {
    #line 3425 
    case (unsigned int)1: 
                          #line 3425 
    ;
    #line 3426 
    ixgbe_write_reg_1(& adapter->hw,2184U,4294967295U);
    #line 3427 
    break;
    #line 3428 
    case (unsigned int)2: 
                          #line 3428 
    ;
    #line 3429 
    case (unsigned int)3: 
                          #line 3429 
    ;
    #line 3430 
    case (unsigned int)4: 
                          #line 3430 
    ;
    #line 3431 
    case (unsigned int)5: 
                          #line 3431 
    ;
    #line 3432 
    case (unsigned int)6: 
                          #line 3432 
    ;
    #line 3433 
    ixgbe_write_reg_1(& adapter->hw,2184U,4294901760U);
    #line 3434 
    ixgbe_write_reg_1(& adapter->hw,2736U,4294967295U);
    #line 3435 
    ixgbe_write_reg_1(& adapter->hw,2740U,4294967295U);
    #line 3436 
    break;
    #line 3437 
    default: 
             #line 3437 
    ;
    #line 3438 
    break;
  }
  #line 3440 
  ixgbe_read_reg(& adapter->hw,8U);
  #line 3441 
  if (((unsigned long)adapter->flags & 8UL) != 0UL) {
    #line 3442 
    int vector;
    #line 3447 
    int tmp;
    #line 3444 
    vector = 0;
    #line 3444 
    while (adapter->num_q_vectors > vector) {
      #line 3445 
      synchronize_irq((adapter->msix_entries + (unsigned long)vector)->vector);
      #line 3444 
      vector ++;
    }
    #line 3447 
    tmp = vector;
    #line 3447 
    vector ++;
    #line 3447 
    ;
    #line 3447 
    synchronize_irq((adapter->msix_entries + (unsigned long)tmp)->vector);
  }
  else 
       #line 3449 
       synchronize_irq((adapter->pdev)->irq);
  #line 3450 
  return;
}

#line 3458  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_msi_and_legacy(struct ixgbe_adapter *adapter)
{
  #line 3460 
  struct ixgbe_q_vector *q_vector = adapter->q_vector[0];
  #line 3462 
  ixgbe_write_eitr(q_vector);
  #line 3464 
  ixgbe_set_ivar(adapter,(signed char)0,(unsigned char)0,(unsigned char)0);
  #line 3465 
  ixgbe_set_ivar(adapter,(signed char)1,(unsigned char)0,(unsigned char)0);
  #line 3467 
  if (((int)adapter->msg_enable & 8192) != 0) 
                                              #line 3467 
                                              netdev_info(adapter->netdev,(char *)"Legacy interrupt IVAR setup done\n");
  #line 3468 
  return;
}

#line 3477  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_configure_tx_ring(struct ixgbe_adapter *adapter, struct ixgbe_ring *ring)
{
  #line 3480 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 3481 
  u64 tdba = ring->dma;
  #line 3482 
  int wait_loop = 10;
  #line 3483 
  u32 txdctl = 33554432U;
  #line 3484 
  u8 reg_idx = ring->reg_idx;
  #line 3486 
  ring->xsk_umem = (struct xdp_umem *)0;
  #line 3487 
  if ((int)test_bit(9L,& ring->state) != 0) 
                                            #line 3488 
                                            ring->xsk_umem = ixgbe_xsk_umem(adapter,ring);
  #line 3491 
  ixgbe_write_reg_1(hw,(unsigned int)((int)reg_idx * 64 + 24616),0U);
  #line 3492 
  ixgbe_read_reg(hw,8U);
  #line 3494 
  ixgbe_write_reg_1(hw,(unsigned int)(((int)reg_idx + 384) * 64),(unsigned int)tdba);
  #line 3496 
  ixgbe_write_reg_1(hw,(unsigned int)((int)reg_idx * 64 + 24580),(unsigned int)(tdba >> 32));
  #line 3497 
  ixgbe_write_reg_1(hw,(unsigned int)((int)reg_idx * 64 + 24584),(unsigned int)ring->count * 16U);
  #line 3499 
  ixgbe_write_reg_1(hw,(unsigned int)((int)reg_idx * 64 + 24592),0U);
  #line 3500 
  ixgbe_write_reg_1(hw,(unsigned int)((int)reg_idx * 64 + 24600),0U);
  #line 3501 
  ring->tail = adapter->io_addr + (unsigned long)((int)reg_idx * 64 + 24600);
  #line 3513 
  if (ring->q_vector == (struct ixgbe_q_vector *)0 || (unsigned int)(ring->q_vector)->itr <= 39U) 
    #line 3514 
    txdctl |= 65536U; else 
                           #line 3516 
                           txdctl |= 524288U;
  #line 3522 
  txdctl |= 288U;
  #line 3526 
  if (((unsigned long)adapter->flags & 262144UL) != 0UL) {
    #line 3527 
    ring->__anonCompField_ixgbe_ring_223.__anonCompField___anonunion_2624_222.atr_sample_rate = (unsigned char)adapter->atr_sample_rate;
    #line 3528 
    ring->__anonCompField_ixgbe_ring_223.__anonCompField___anonunion_2624_222.atr_count = (unsigned char)0U;
    #line 3529 
    cif_set_bit(5L,& ring->state);
  }
  else 
       #line 3531 
       ring->__anonCompField_ixgbe_ring_223.__anonCompField___anonunion_2624_222.atr_sample_rate = (unsigned char)0U;
  #line 3535 
  if (! test_and_set_bit(6L,& ring->state)) {
    #line 3536 
    struct ixgbe_q_vector *q_vector = ring->q_vector;
    #line 3538 
    if (q_vector != (struct ixgbe_q_vector *)0) 
                                                #line 3539 
                                                netif_set_xps_queue(ring->netdev,& q_vector->affinity_mask,(unsigned short)((int)ring->queue_index));
  }
  #line 3544 
  cif_clear_bit(8L,& ring->state);
  #line 3547 
  memset((void *)ring->__anonCompField_ixgbe_ring_221.tx_buffer_info,0,(unsigned long)ring->count * 48UL);
  #line 3551 
  ixgbe_write_reg_1(hw,(unsigned int)((int)reg_idx * 64 + 24616),txdctl);
  #line 3554 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) {
    #line 3554 
    if ((ixgbe_read_reg(hw,17060U) & 1073741824U) == 0U) 
                                                         #line 3556 
                                                         return;
  }
  #line 3559 
  while (1) {
    #line 3560 
    usleep_range(1000UL,2000UL);
    #line 3561 
    txdctl = ixgbe_read_reg(hw,(unsigned int)((int)reg_idx * 64 + 24616));
    #line 3562 
    wait_loop --;
    #line 3562 
    if (wait_loop != 0) {
      #line 3562 
      if (! ((txdctl & 33554432U) == 0U)) 
                                          #line 3559 
                                          break;
    }
    else 
         #line 3559 
         break;
  }
  #line 3563 
  if (wait_loop == 0) {
    #line 3564 
    bool branch;
    #line 3564 
    struct _ddebug __UNIQUE_ID_ddebug578 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_configure_tx_ring", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c", .format = (char *)"Could not enable Tx Queue %d\n", .lineno = (unsigned int)3564U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 3564 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug578.key.dd_key_false.key,(_Bool)0);
    #line 3564 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 3564 
                                                __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug578,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Could not enable Tx Queue %d\n",(int)reg_idx);
  }
  #line 3566 
  return;
}

#line 3567  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_setup_mtqc(struct ixgbe_adapter *adapter)
{
  #line 3570 
  u32 rttdcs;
  #line 3570 
  u32 mtqc;
  #line 3569 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 3571 
  u8 tcs = adapter->hw_tcs;
  #line 3573 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) 
                                                       #line 3574 
                                                       return;
  #line 3577 
  rttdcs = ixgbe_read_reg(hw,18688U);
  #line 3578 
  rttdcs |= 64U;
  #line 3579 
  ixgbe_write_reg_1(hw,18688U,rttdcs);
  #line 3582 
  if (((unsigned long)adapter->flags & 8388608UL) != 0UL) {
    #line 3583 
    mtqc = 2U;
    #line 3584 
    if ((unsigned int)tcs > 4U) 
                                #line 3585 
                                mtqc |= 13U;
    else 
      #line 3586 
      if ((unsigned int)tcs > 1U) 
                                  #line 3587 
                                  mtqc |= 9U;
      else 
        #line 3588 
        if ((unsigned int)adapter->ring_feature[1].mask == 124U) 
                                                                 #line 3590 
                                                                 mtqc |= 8U; else 
                                                                    #line 3592 
                                                                    mtqc |= 4U;
  }
  else 
    #line 3594 
    if ((unsigned int)tcs > 4U) 
                                #line 3595 
                                mtqc = 13U;
    else 
      #line 3596 
      if ((unsigned int)tcs > 1U) 
                                  #line 3597 
                                  mtqc = 9U;
      else {
        #line 3599 
        u8 max_txq = (unsigned char)((int)((unsigned char)adapter->num_tx_queues) + (int)((unsigned char)adapter->num_xdp_queues));
        #line 3601 
        if ((unsigned int)max_txq > 63U) 
                                         #line 3602 
                                         mtqc = 9U; else 
                                                         #line 3604 
                                                         mtqc = 0U;
      }
  #line 3608 
  ixgbe_write_reg_1(hw,33056U,mtqc);
  #line 3611 
  if ((unsigned int)tcs != 0U) {
    #line 3612 
    u32 sectx = ixgbe_read_reg(hw,34832U);
    #line 3613 
    sectx |= 7936U;
    #line 3614 
    ixgbe_write_reg_1(hw,34832U,sectx);
  }
  #line 3618 
  rttdcs &= 4294967231U;
  #line 3619 
  ixgbe_write_reg_1(hw,18688U,rttdcs);
  #line 3620 
  return;
}

#line 3628  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_tx(struct ixgbe_adapter *adapter)
{
  #line 3631 
  u32 dmatxctl;
  #line 3632 
  u32 i;
  #line 3630 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 3634 
  ixgbe_setup_mtqc(adapter);
  #line 3636 
  if (hw->mac.type != (unsigned int)ixgbe_mac_82598EB) {
    #line 3638 
    dmatxctl = ixgbe_read_reg(hw,19072U);
    #line 3639 
    dmatxctl |= 1U;
    #line 3640 
    ixgbe_write_reg_1(hw,19072U,dmatxctl);
  }
  #line 3644 
  i = 0U;
  #line 3644 
  while ((unsigned int)adapter->num_tx_queues > i) {
    #line 3645 
    ixgbe_configure_tx_ring(adapter,adapter->tx_ring[i]);
    #line 3644 
    i ++;
  }
  #line 3646 
  i = 0U;
  #line 3646 
  while ((unsigned int)adapter->num_xdp_queues > i) {
    #line 3647 
    ixgbe_configure_tx_ring(adapter,adapter->xdp_ring[i]);
    #line 3646 
    i ++;
  }
  #line 3648 
  return;
}

#line 3650  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_enable_rx_drop(struct ixgbe_adapter *adapter, struct ixgbe_ring *ring)
{
  #line 3655 
  int tmp_0;
  #line 3659 
  int tmp_3;
  #line 3653 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 3654 
  u8 reg_idx = ring->reg_idx;
  #line 3655 
  if ((unsigned int)reg_idx <= 15U) 
                                    #line 3655 
                                    tmp_0 = ((int)reg_idx + 2112) * 4;
  else {
    #line 3655 
    int tmp;
    #line 3655 
    if ((unsigned int)reg_idx <= 63U) 
                                      #line 3655 
                                      tmp = (int)reg_idx * 64 + 4116; else 
                                                                    #line 3655 
                                                                    tmp = ((int)reg_idx + -64) * 64 + 53268;
    #line 3655 
    tmp_0 = tmp;
  }
  #line 3655 
  ;
  #line 3655 
  u32 srrctl = ixgbe_read_reg(hw,(unsigned int)tmp_0);
  #line 3657 
  srrctl |= 268435456U;
  #line 3659 
  ;
  #line 3659 
  if ((unsigned int)reg_idx <= 15U) 
                                    #line 3659 
                                    tmp_3 = ((int)reg_idx + 2112) * 4;
  else {
    #line 3659 
    int tmp_2;
    #line 3659 
    if ((unsigned int)reg_idx <= 63U) 
                                      #line 3659 
                                      tmp_2 = (int)reg_idx * 64 + 4116; else 
                                                                    #line 3659 
                                                                    tmp_2 = ((int)reg_idx + -64) * 64 + 53268;
    #line 3659 
    tmp_3 = tmp_2;
  }
  #line 3659 
  ;
  #line 3659 
  ixgbe_write_reg_1(hw,(unsigned int)tmp_3,srrctl);
  #line 3660 
  return;
}

#line 3662  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_disable_rx_drop(struct ixgbe_adapter *adapter, struct ixgbe_ring *ring)
{
  #line 3667 
  int tmp_0;
  #line 3671 
  int tmp_3;
  #line 3665 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 3666 
  u8 reg_idx = ring->reg_idx;
  #line 3667 
  if ((unsigned int)reg_idx <= 15U) 
                                    #line 3667 
                                    tmp_0 = ((int)reg_idx + 2112) * 4;
  else {
    #line 3667 
    int tmp;
    #line 3667 
    if ((unsigned int)reg_idx <= 63U) 
                                      #line 3667 
                                      tmp = (int)reg_idx * 64 + 4116; else 
                                                                    #line 3667 
                                                                    tmp = ((int)reg_idx + -64) * 64 + 53268;
    #line 3667 
    tmp_0 = tmp;
  }
  #line 3667 
  ;
  #line 3667 
  u32 srrctl = ixgbe_read_reg(hw,(unsigned int)tmp_0);
  #line 3669 
  srrctl &= 4026531839U;
  #line 3671 
  ;
  #line 3671 
  if ((unsigned int)reg_idx <= 15U) 
                                    #line 3671 
                                    tmp_3 = ((int)reg_idx + 2112) * 4;
  else {
    #line 3671 
    int tmp_2;
    #line 3671 
    if ((unsigned int)reg_idx <= 63U) 
                                      #line 3671 
                                      tmp_2 = (int)reg_idx * 64 + 4116; else 
                                                                    #line 3671 
                                                                    tmp_2 = ((int)reg_idx + -64) * 64 + 53268;
    #line 3671 
    tmp_3 = tmp_2;
  }
  #line 3671 
  ;
  #line 3671 
  ixgbe_write_reg_1(hw,(unsigned int)tmp_3,srrctl);
  #line 3672 
  return;
}

#line 3675  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_set_rx_drop_en(struct ixgbe_adapter *adapter)
{
  #line 3680 
  int i;
  #line 3681 
  bool pfc_en = adapter->dcb_cfg.pfc_mode_enable;
  #line 3683 
  if (adapter->ixgbe_ieee_pfc != (struct ieee_pfc *)0) 
                                                       #line 3684 
                                                       pfc_en = (_Bool)(((int)pfc_en | ((unsigned int)(adapter->ixgbe_ieee_pfc)->pfc_en != 0U)) != 0);
  #line 3695 
  if (adapter->num_vfs != 0U || (adapter->num_rx_queues > 1 && ((unsigned int)adapter->hw.fc.current_mode & 2U) == 0U) && ! pfc_en) {
    #line 3697 
    i = 0;
    #line 3697 
    while (adapter->num_rx_queues > i) {
      #line 3698 
      ixgbe_enable_rx_drop(adapter,adapter->rx_ring[i]);
      #line 3697 
      i ++;
    }
  }
  else {
    #line 3700 
    i = 0;
    #line 3700 
    while (adapter->num_rx_queues > i) {
      #line 3701 
      ixgbe_disable_rx_drop(adapter,adapter->rx_ring[i]);
      #line 3700 
      i ++;
    }
  }
  #line 3703 
  return;
}

#line 3707  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_srrctl(struct ixgbe_adapter *adapter, struct ixgbe_ring *rx_ring)
{
  #line 3711 
  u32 srrctl;
  #line 3753 
  int tmp_1;
  #line 3710 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 3712 
  u8 reg_idx = rx_ring->reg_idx;
  #line 3714 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) {
    #line 3715 
    u16 mask = adapter->ring_feature[2].mask;
    #line 3721 
    reg_idx = (unsigned char)((int)((unsigned char)mask) & (int)reg_idx);
  }
  #line 3725 
  srrctl = 1024U;
  #line 3728 
  if (rx_ring->xsk_umem != (struct xdp_umem *)0) {
    #line 3729 
    u32 xsk_buf_len = (rx_ring->xsk_umem)->chunk_size_nohr + 4294967040U;
    #line 3740 
    if (hw->mac.type != (unsigned int)ixgbe_mac_82599EB) 
                                                         #line 3741 
                                                         srrctl |= 4U; else 
                                                                    #line 3743 
                                                                    srrctl = (xsk_buf_len >> 10) | srrctl;
  }
  else {
    #line 3744 
    if ((int)test_bit(0L,& rx_ring->state) != 0) 
                                                 #line 3745 
                                                 srrctl |= 3U; else 
                                                                    #line 3747 
                                                                    srrctl |= 2U;
  }
  #line 3751 
  srrctl |= 33554432U;
  #line 3753 
  ;
  #line 3753 
  if ((unsigned int)reg_idx <= 15U) 
                                    #line 3753 
                                    tmp_1 = ((int)reg_idx + 2112) * 4;
  else {
    #line 3753 
    int tmp_0;
    #line 3753 
    if ((unsigned int)reg_idx <= 63U) 
                                      #line 3753 
                                      tmp_0 = (int)reg_idx * 64 + 4116; else 
                                                                    #line 3753 
                                                                    tmp_0 = ((int)reg_idx + -64) * 64 + 53268;
    #line 3753 
    tmp_1 = tmp_0;
  }
  #line 3753 
  ;
  #line 3753 
  ixgbe_write_reg_1(hw,(unsigned int)tmp_1,srrctl);
  #line 3754 
  return;
}

#line 3764  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
u32 ixgbe_rss_indir_tbl_entries(struct ixgbe_adapter *adapter)
{
  #line 3766 
  if (adapter->hw.mac.type <= (unsigned int)ixgbe_mac_X540) 
                                                            #line 3767 
                                                            return 128U;
  else 
    #line 3768 
    if (((unsigned long)adapter->flags & 8388608UL) != 0UL) 
                                                            #line 3769 
                                                            return 64U; else 
                                                                    #line 3771 
                                                                    return 512U;
}

#line 3780  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_store_key(struct ixgbe_adapter *adapter)
{
  #line 3783 
  int i;
  #line 3782 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 3785 
  i = 0;
  #line 3785 
  while (i <= 9) {
    #line 3786 
    ixgbe_write_reg_1(hw,(unsigned int)((i + 5920) * 4),*(adapter->rss_key + (unsigned long)i));
    #line 3785 
    i ++;
  }
  #line 3787 
  return;
}

#line 3795  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static int ixgbe_init_rss_key(struct ixgbe_adapter *adapter)
{
  #line 3797 
  u32 *rss_key;
  #line 3799 
  if (adapter->rss_key == (u32 *)0U) {
    #line 3800 
    rss_key = (u32 *)kzalloc(40UL,3264U);
    #line 3801 
    if ((long)(rss_key == (u32 *)0U) != 0L) 
                                            #line 3802 
                                            return -12;
    #line 3804 
    netdev_rss_key_fill((void *)rss_key,40UL);
    #line 3805 
    adapter->rss_key = rss_key;
  }
  #line 3808 
  return 0;
}

#line 3817  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_store_reta(struct ixgbe_adapter *adapter)
{
  #line 3819 
  u32 i;
  #line 3822 
  u32 indices_multi;
  #line 3819 
  u32 reta_entries = ixgbe_rss_indir_tbl_entries(adapter);
  #line 3820 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 3821 
  u32 reta = 0U;
  #line 3823 
  u8 *indir_tbl = (u8 *)(& adapter->rss_indir_tbl);
  #line 3831 
  if (adapter->hw.mac.type == (unsigned int)ixgbe_mac_82598EB) 
                                                               #line 3832 
                                                               indices_multi = 17U; else 
                                                                    #line 3834 
                                                                    indices_multi = 1U;
  #line 3837 
  i = 0U;
  #line 3837 
  while (i < reta_entries) {
    #line 3838 
    reta = ((unsigned int)*(indir_tbl + (unsigned long)i) * indices_multi << (i & 3U) * 8U) | reta;
    #line 3839 
    if ((i & 3U) == 3U) {
      #line 3840 
      if (i <= 127U) 
                     #line 3841 
                     ixgbe_write_reg_1(hw,((i >> 2) + 5888U) * 4U,reta); else 
                                                                    #line 3843 
                                                                    ixgbe_write_reg_1(hw,((i >> 2) + 15232U) * 4U,reta);
      #line 3845 
      reta = 0U;
    }
    #line 3837 
    i ++;
  }
  #line 3848 
  return;
}

#line 3856  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_store_vfreta(struct ixgbe_adapter *adapter)
{
  #line 3858 
  u32 i;
  #line 3858 
  u32 reta_entries = ixgbe_rss_indir_tbl_entries(adapter);
  #line 3859 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 3860 
  u32 vfreta = 0U;
  #line 3863 
  i = 0U;
  #line 3863 
  while (i < reta_entries) {
    {
      #line 3864 
      u16 pool = (unsigned short)adapter->num_rx_pools;
      #line 3866 
      vfreta = ((unsigned int)adapter->rss_indir_tbl[i] << (i & 3U) * 8U) | vfreta;
      #line 3867 
      if ((i & 3U) != 3U) 
                          #line 3868 
                          goto __Cont;
      #line 3870 
      while (1) {
        #line 3870 
        u16 tmp_0;
        #line 3870 
        tmp_0 = pool;
        #line 3870 
        pool = (u16)((int)pool - 1);
        #line 3870 
        ;
        #line 3870 
        if (! ((unsigned int)tmp_0 != 0U)) 
                                           #line 3870 
                                           break;
        #line 3871 
        ixgbe_write_reg_1(hw,((i >> 2) + 25600U) * 4U + (unsigned int)(((int)pool + (int)adapter->ring_feature[1].offset) * 64),vfreta);
      }
      #line 3874 
      vfreta = 0U;
    }
    #line 3863 
    __Cont: 
            #line 3863 
    i ++;
  }
  #line 3876 
  return;
}

#line 3878  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_setup_reta(struct ixgbe_adapter *adapter)
{
  #line 3880 
  u32 i;
  #line 3880 
  u32 j;
  #line 3881 
  u32 reta_entries = ixgbe_rss_indir_tbl_entries(adapter);
  #line 3882 
  u16 rss_i = adapter->ring_feature[2].indices;
  #line 3888 
  if (((unsigned long)adapter->flags & 8388608UL) != 0UL && (unsigned int)rss_i <= 3U) 
    #line 3889 
    rss_i = (unsigned short)4U;
  #line 3892 
  ixgbe_store_key(adapter);
  #line 3895 
  memset((void *)(& adapter->rss_indir_tbl),0,512UL);
  #line 3897 
  i = 0U;
  #line 3897 
  j = 0U;
  #line 3897 
  while (i < reta_entries) {
    #line 3898 
    if ((unsigned int)rss_i == j) 
                                  #line 3899 
                                  j = 0U;
    #line 3901 
    adapter->rss_indir_tbl[i] = (unsigned char)j;
    #line 3897 
    i ++;
    #line 3897 
    j ++;
  }
  #line 3904 
  ixgbe_store_reta(adapter);
  #line 3905 
  return;
}

#line 3907  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_setup_vfreta(struct ixgbe_adapter *adapter)
{
  #line 3911 
  int i;
  #line 3911 
  int j;
  #line 3909 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 3910 
  u16 rss_i = adapter->ring_feature[2].indices;
  #line 3914 
  i = 0;
  #line 3914 
  while (i <= 9) {
    {
      #line 3915 
      u16 pool = (unsigned short)adapter->num_rx_pools;
      #line 3917 
      while (1) {
        #line 3917 
        u16 tmp;
        #line 3917 
        tmp = pool;
        #line 3917 
        pool = (u16)((int)pool - 1);
        #line 3917 
        ;
        #line 3917 
        if (! ((unsigned int)tmp != 0U)) 
                                         #line 3917 
                                         break;
        #line 3918 
        ixgbe_write_reg_1(hw,(unsigned int)(((i + 24576) + ((int)pool + (int)adapter->ring_feature[1].offset) * 16) * 4),*(adapter->rss_key + (unsigned long)i));
      }
    }
    #line 3914 
    i ++;
  }
  #line 3924 
  i = 0;
  #line 3924 
  j = 0;
  #line 3924 
  while (i <= 63) {
    #line 3925 
    if ((int)rss_i == j) 
                         #line 3926 
                         j = 0;
    #line 3928 
    adapter->rss_indir_tbl[i] = (unsigned char)j;
    #line 3924 
    i ++;
    #line 3924 
    j ++;
  }
  #line 3931 
  ixgbe_store_vfreta(adapter);
  #line 3932 
  return;
}

#line 3934  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_setup_mrqc(struct ixgbe_adapter *adapter)
{
  #line 3938 
  u32 rxcsum;
  #line 3936 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 3937 
  u32 mrqc = 0U;
  #line 3937 
  u32 rss_field = 0U;
  #line 3937 
  u32 vfmrqc = 0U;
  #line 3941 
  rxcsum = ixgbe_read_reg(hw,20480U);
  #line 3942 
  rxcsum |= 8192U;
  #line 3943 
  ixgbe_write_reg_1(hw,20480U,rxcsum);
  #line 3945 
  if (adapter->hw.mac.type == (unsigned int)ixgbe_mac_82598EB) {
    #line 3946 
    if ((unsigned int)adapter->ring_feature[2].mask != 0U) 
                                                           #line 3947 
                                                           mrqc = 1U;
  }
  else {
    #line 3949 
    u8 tcs = adapter->hw_tcs;
    #line 3951 
    if (((unsigned long)adapter->flags & 8388608UL) != 0UL) {
      #line 3952 
      if ((unsigned int)tcs > 4U) 
                                  #line 3953 
                                  mrqc = 12U;
      else 
        #line 3954 
        if ((unsigned int)tcs > 1U) 
                                    #line 3955 
                                    mrqc = 13U;
        else 
          #line 3956 
          if ((unsigned int)adapter->ring_feature[1].mask == 124U) 
                                                                   #line 3958 
                                                                   mrqc = 10U; else 
                                                                    #line 3960 
                                                                    mrqc = 11U;
      #line 3965 
      if (hw->mac.type > (unsigned int)ixgbe_mac_X540) 
                                                       #line 3966 
                                                       mrqc |= 32768U;
    }
    else 
      #line 3968 
      if ((unsigned int)tcs > 4U) 
                                  #line 3969 
                                  mrqc = 4U;
      else 
        #line 3970 
        if ((unsigned int)tcs > 1U) 
                                    #line 3971 
                                    mrqc = 5U; else 
                                                    #line 3973 
                                                    mrqc = 1U;
  }
  #line 3978 
  rss_field |= 3342336U;
  #line 3983 
  if (((unsigned long)adapter->flags2 & 256UL) != 0UL) 
                                                       #line 3984 
                                                       rss_field |= 4194304U;
  #line 3985 
  if (((unsigned long)adapter->flags2 & 512UL) != 0UL) 
                                                       #line 3986 
                                                       rss_field |= 8388608U;
  #line 3988 
  if (hw->mac.type > (unsigned int)ixgbe_mac_X540 && ((unsigned long)adapter->flags & 8388608UL) != 0UL) {
    #line 3990 
    u16 pool = (unsigned short)adapter->num_rx_pools;
    #line 3993 
    mrqc |= 8192U;
    #line 3994 
    ixgbe_write_reg_1(hw,22552U,mrqc);
    #line 3997 
    ixgbe_setup_vfreta(adapter);
    #line 3998 
    vfmrqc = 1U;
    #line 3999 
    vfmrqc |= rss_field;
    #line 4001 
    while (1) {
      #line 4001 
      u16 tmp;
      #line 4001 
      tmp = pool;
      #line 4001 
      pool = (u16)((int)pool - 1);
      #line 4001 
      ;
      #line 4001 
      if (! ((unsigned int)tmp != 0U)) 
                                       #line 4001 
                                       break;
      #line 4002 
      ixgbe_write_reg_1(hw,(unsigned int)((((int)pool + (int)adapter->ring_feature[1].offset) + 3328) * 4),vfmrqc);
    }
  }
  else {
    #line 4006 
    ixgbe_setup_reta(adapter);
    #line 4007 
    mrqc |= rss_field;
    #line 4008 
    ixgbe_write_reg_1(hw,22552U,mrqc);
  }
  #line 4010 
  return;
}

#line 4017  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_rscctl(struct ixgbe_adapter *adapter, struct ixgbe_ring *ring)
{
  #line 4021 
  u32 rscctrl;
  #line 4027 
  int tmp_0;
  #line 4035 
  int tmp_1;
  #line 4020 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4022 
  u8 reg_idx = ring->reg_idx;
  #line 4024 
  if (! test_bit(2L,& ring->state)) 
                                    #line 4025 
                                    return;
  #line 4027 
  if ((unsigned int)reg_idx <= 63U) 
                                    #line 4027 
                                    tmp_0 = (int)reg_idx * 64 + 4140; else 
                                                                    #line 4027 
                                                                    tmp_0 = ((int)reg_idx + -64) * 64 + 53292;
  #line 4027 
  ;
  #line 4027 
  rscctrl = ixgbe_read_reg(hw,(unsigned int)tmp_0);
  #line 4028 
  rscctrl |= 1U;
  #line 4034 
  rscctrl |= 12U;
  #line 4035 
  ;
  #line 4035 
  if ((unsigned int)reg_idx <= 63U) 
                                    #line 4035 
                                    tmp_1 = (int)reg_idx * 64 + 4140; else 
                                                                    #line 4035 
                                                                    tmp_1 = ((int)reg_idx + -64) * 64 + 53292;
  #line 4035 
  ;
  #line 4035 
  ixgbe_write_reg_1(hw,(unsigned int)tmp_1,rscctrl);
  #line 4036 
  return;
}

#line 4039  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_rx_desc_queue_enable(struct ixgbe_adapter *adapter, struct ixgbe_ring *ring)
{
  #line 4044 
  u32 rxdctl;
  #line 4042 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4043 
  int wait_loop = 10;
  #line 4045 
  u8 reg_idx = ring->reg_idx;
  #line 4047 
  if ((int)ixgbe_removed((void *)hw->hw_addr) != 0) 
                                                    #line 4048 
                                                    return;
  #line 4050 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) {
    #line 4050 
    if ((ixgbe_read_reg(hw,17060U) & 1073741824U) == 0U) 
                                                         #line 4052 
                                                         return;
  }
  #line 4054 
  while (1) {
    {
      #line 4056 
      int tmp_1;
      #line 4055 
      usleep_range(1000UL,2000UL);
      #line 4056 
      if ((unsigned int)reg_idx <= 63U) 
                                        #line 4056 
                                        tmp_1 = (int)reg_idx * 64 + 4136; else 
                                                                    #line 4056 
                                                                    tmp_1 = ((int)reg_idx + -64) * 64 + 53288;
      #line 4056 
      ;
      #line 4056 
      rxdctl = ixgbe_read_reg(hw,(unsigned int)tmp_1);
    }
    #line 4057 
    wait_loop --;
    #line 4057 
    if (wait_loop != 0) {
      #line 4057 
      if (! ((rxdctl & 33554432U) == 0U)) 
                                          #line 4054 
                                          break;
    }
    else 
         #line 4054 
         break;
  }
  #line 4059 
  if (wait_loop == 0) 
    #line 4060 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 4060 
                                             netdev_err(adapter->netdev,(char *)"RXDCTL.ENABLE on Rx queue %d not set within ",(int)reg_idx);
  #line 4061 
  return;
}

#line 4065  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_configure_rx_ring(struct ixgbe_adapter *adapter, struct ixgbe_ring *ring)
{
  #line 4069 
  union ixgbe_adv_rx_desc *rx_desc;
  #line 4071 
  u32 rxdctl;
  #line 4088 
  int tmp_1;
  #line 4092 
  int tmp_2_2;
  #line 4095 
  int tmp_3;
  #line 4096 
  int tmp_4_0;
  #line 4097 
  int tmp_5;
  #line 4102 
  int tmp_6;
  #line 4103 
  int tmp_7;
  #line 4104 
  int tmp_8;
  #line 4157 
  int tmp_11;
  #line 4068 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4070 
  u64 rdba = ring->dma;
  #line 4072 
  u8 reg_idx = ring->reg_idx;
  #line 4074 
  xdp_rxq_info_unreg_mem_model(& ring->xdp_rxq);
  #line 4075 
  ring->xsk_umem = ixgbe_xsk_umem(adapter,ring);
  #line 4076 
  if (ring->xsk_umem != (struct xdp_umem *)0) {
    #line 4077 
    ring->zca.free = & ixgbe_zca_free;
    {
      #line 4078 
      int __ret_warn_on = xdp_rxq_info_reg_mem_model(& ring->xdp_rxq,
                                 (enum xdp_mem_type)MEM_TYPE_ZERO_COPY,
                                 (void *)(& ring->zca)) != 0;
      #line 4078 
      if ((long)(__ret_warn_on != 0) != 0L) {
        #line 4079 
        ldv_inline_asm();
        #line 4080 
        ldv_inline_asm();
      }
      #line 4078 
      long tmp_2 = (long)(__ret_warn_on != 0);
    }
  }
  else {
    #line 4083 
    int __ret_warn_on_0 = xdp_rxq_info_reg_mem_model(& ring->xdp_rxq,
                                   (enum xdp_mem_type)MEM_TYPE_PAGE_SHARED,
                                   (void *)0) != 0;
    #line 4083 
    if ((long)(__ret_warn_on_0 != 0) != 0L) {
      #line 4084 
      ldv_inline_asm();
      #line 4085 
      ldv_inline_asm();
    }
    #line 4083 
    long tmp_4 = (long)(__ret_warn_on_0 != 0);
  }
  #line 4088 
  if ((unsigned int)reg_idx <= 63U) 
                                    #line 4088 
                                    tmp_1 = (int)reg_idx * 64 + 4136; else 
                                                                    #line 4088 
                                                                    tmp_1 = ((int)reg_idx + -64) * 64 + 53288;
  #line 4088 
  ;
  #line 4088 
  rxdctl = ixgbe_read_reg(hw,(unsigned int)tmp_1);
  #line 4089 
  rxdctl &= 4261412863U;
  #line 4092 
  ;
  #line 4092 
  if ((unsigned int)reg_idx <= 63U) 
                                    #line 4092 
                                    tmp_2_2 = (int)reg_idx * 64 + 4136; else 
                                                                    #line 4092 
                                                                    tmp_2_2 = ((int)reg_idx + -64) * 64 + 53288;
  #line 4092 
  ;
  #line 4092 
  ixgbe_write_reg_1(hw,(unsigned int)tmp_2_2,rxdctl);
  #line 4093 
  ixgbe_read_reg(hw,8U);
  #line 4095 
  ;
  #line 4095 
  if ((unsigned int)reg_idx <= 63U) 
                                    #line 4095 
                                    tmp_3 = ((int)reg_idx + 64) * 64; else 
                                                                    #line 4095 
                                                                    tmp_3 = ((int)reg_idx + 768) * 64;
  #line 4095 
  ;
  #line 4095 
  ixgbe_write_reg_1(hw,(unsigned int)tmp_3,(unsigned int)rdba);
  #line 4096 
  ;
  #line 4096 
  if ((unsigned int)reg_idx <= 63U) 
                                    #line 4096 
                                    tmp_4_0 = (int)reg_idx * 64 + 4100; else 
                                                                    #line 4096 
                                                                    tmp_4_0 = ((int)reg_idx + -64) * 64 + 53252;
  #line 4096 
  ;
  #line 4096 
  ixgbe_write_reg_1(hw,(unsigned int)tmp_4_0,(unsigned int)(rdba >> 32));
  #line 4097 
  ;
  #line 4097 
  if ((unsigned int)reg_idx <= 63U) 
                                    #line 4097 
                                    tmp_5 = (int)reg_idx * 64 + 4104; else 
                                                                    #line 4097 
                                                                    tmp_5 = ((int)reg_idx + -64) * 64 + 53256;
  #line 4097 
  ;
  #line 4097 
  ixgbe_write_reg_1(hw,(unsigned int)tmp_5,(unsigned int)ring->count * 16U);
  #line 4100 
  ixgbe_read_reg(hw,8U);
  #line 4102 
  if ((unsigned int)reg_idx <= 63U) 
                                    #line 4102 
                                    tmp_6 = (int)reg_idx * 64 + 4112; else 
                                                                    #line 4102 
                                                                    tmp_6 = ((int)reg_idx + -64) * 64 + 53264;
  #line 4102 
  ;
  #line 4102 
  ixgbe_write_reg_1(hw,(unsigned int)tmp_6,0U);
  #line 4103 
  if ((unsigned int)reg_idx <= 63U) 
                                    #line 4103 
                                    tmp_7 = (int)reg_idx * 64 + 4120; else 
                                                                    #line 4103 
                                                                    tmp_7 = ((int)reg_idx + -64) * 64 + 53272;
  #line 4103 
  ;
  #line 4103 
  ixgbe_write_reg_1(hw,(unsigned int)tmp_7,0U);
  #line 4104 
  if ((unsigned int)reg_idx <= 63U) 
                                    #line 4104 
                                    tmp_8 = (int)reg_idx * 64 + 4120; else 
                                                                    #line 4104 
                                                                    tmp_8 = ((int)reg_idx + -64) * 64 + 53272;
  #line 4104 
  ring->tail = adapter->io_addr + (unsigned long)tmp_8;
  #line 4106 
  ixgbe_configure_srrctl(adapter,ring);
  #line 4107 
  ixgbe_configure_rscctl(adapter,ring);
  #line 4109 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) {
    #line 4117 
    rxdctl &= 4290772992U;
    #line 4118 
    rxdctl |= 525344U;
  }
  else 
    #line 4121 
    if (hw->mac.type != (unsigned int)ixgbe_mac_82599EB) {
      #line 4122 
      rxdctl &= 4294918144U;
      #line 4129 
      if ((int)test_bit(1L,& ring->state) != 0) {
        #line 4130 
        if (! test_bit(0L,& ring->state)) 
                                          #line 4131 
                                          rxdctl |= 34304U;
      }
    }
  #line 4136 
  if (ring->xsk_umem != (struct xdp_umem *)0 && hw->mac.type != (unsigned int)ixgbe_mac_82599EB) {
    #line 4137 
    u32 xsk_buf_len = (ring->xsk_umem)->chunk_size_nohr + 4294967040U;
    #line 4140 
    rxdctl &= 4294918144U;
    #line 4142 
    rxdctl = (xsk_buf_len | rxdctl) | 32768U;
    #line 4144 
    ring->rx_buf_len = (unsigned short)xsk_buf_len;
  }
  #line 4148 
  memset((void *)ring->__anonCompField_ixgbe_ring_221.rx_buffer_info,0,(unsigned long)ring->count * 32UL);
  #line 4152 
  rx_desc = (union ixgbe_adv_rx_desc *)ring->desc;
  #line 4153 
  rx_desc->wb.upper.length = (unsigned short)0U;
  #line 4156 
  rxdctl |= 33554432U;
  #line 4157 
  ;
  #line 4157 
  if ((unsigned int)reg_idx <= 63U) 
                                    #line 4157 
                                    tmp_11 = (int)reg_idx * 64 + 4136; else 
                                                                    #line 4157 
                                                                    tmp_11 = ((int)reg_idx + -64) * 64 + 53288;
  #line 4157 
  ;
  #line 4157 
  ixgbe_write_reg_1(hw,(unsigned int)tmp_11,rxdctl);
  #line 4159 
  ixgbe_rx_desc_queue_enable(adapter,ring);
  #line 4160 
  if (ring->xsk_umem != (struct xdp_umem *)0) {
    #line 4161 
    ;
    #line 4161 
    ixgbe_alloc_rx_buffers_zc(ring,(unsigned short)((int)ixgbe_desc_unused(ring)));
  }
  else {
    #line 4163 
    ;
    #line 4163 
    ixgbe_alloc_rx_buffers(ring,(unsigned short)((int)ixgbe_desc_unused(ring)));
  }
  #line 4164 
  return;
}

#line 4166  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_setup_psrtype(struct ixgbe_adapter *adapter)
{
  #line 4168 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4169 
  int rss_i = (int)adapter->ring_feature[2].indices;
  #line 4170 
  u16 pool = (unsigned short)adapter->num_rx_pools;
  #line 4173 
  u32 psrtype = 4912U;
  #line 4179 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) 
                                                       #line 4180 
                                                       return;
  #line 4182 
  if (rss_i > 3) 
                 #line 4183 
                 psrtype |= 1073741824U;
  else 
    #line 4184 
    if (rss_i > 1) 
                   #line 4185 
                   psrtype |= 536870912U;
  #line 4187 
  while (1) {
    #line 4187 
    u16 tmp_0;
    #line 4188 
    int tmp;
    #line 4187 
    tmp_0 = pool;
    #line 4187 
    pool = (u16)((int)pool - 1);
    #line 4187 
    ;
    #line 4187 
    if (! ((unsigned int)tmp_0 != 0U)) 
                                       #line 4187 
                                       break;
    #line 4188 
    ;
    #line 4188 
    if ((int)pool + (int)adapter->ring_feature[1].offset <= 15) 
                                                                #line 4188 
                                                                tmp = (((int)pool + (int)adapter->ring_feature[1].offset) + 5408) * 4; else 
                                                                    #line 4188 
                                                                    tmp = (((int)pool + (int)adapter->ring_feature[1].offset) + 14976) * 4;
    #line 4188 
    ;
    #line 4188 
    ixgbe_write_reg_1(hw,(unsigned int)tmp,psrtype);
  }
  #line 4189 
  return;
}

#line 4191  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_virtualization(struct ixgbe_adapter *adapter)
{
  #line 4195 
  u32 reg_offset;
  #line 4195 
  u32 vf_shift;
  #line 4195 
  u32 vmolr;
  #line 4196 
  u32 gcr_ext;
  #line 4196 
  u32 vmdctl;
  #line 4197 
  int i;
  #line 4193 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4194 
  u16 pool = (unsigned short)adapter->num_rx_pools;
  #line 4199 
  if (((unsigned long)adapter->flags & 8388608UL) == 0UL) 
                                                          #line 4200 
                                                          return;
  #line 4202 
  vmdctl = ixgbe_read_reg(hw,20912U);
  #line 4203 
  vmdctl |= 1U;
  #line 4204 
  vmdctl &= 4294959231U;
  #line 4205 
  vmdctl = (unsigned int)((int)adapter->ring_feature[1].offset << 7) | vmdctl;
  #line 4206 
  vmdctl |= 1073741824U;
  #line 4207 
  ixgbe_write_reg_1(hw,20912U,vmdctl);
  #line 4212 
  vmolr = 16777216U;
  #line 4213 
  while (1) {
    #line 4213 
    u16 tmp;
    #line 4213 
    tmp = pool;
    #line 4213 
    pool = (u16)((int)pool - 1);
    #line 4213 
    ;
    #line 4213 
    if (! ((unsigned int)tmp != 0U)) 
                                     #line 4213 
                                     break;
    #line 4214 
    ixgbe_write_reg_1(hw,(unsigned int)((((int)pool + (int)adapter->ring_feature[1].offset) + 15360) * 4),vmolr);
  }
  #line 4216 
  vf_shift = (unsigned int)adapter->ring_feature[1].offset & 31U;
  #line 4217 
  reg_offset = (unsigned int)((unsigned int)adapter->ring_feature[1].offset > 31U);
  #line 4220 
  ixgbe_write_reg_1(hw,(reg_offset + 5240U) * 4U,- ((unsigned int)(1UL << vf_shift)));
  #line 4221 
  ixgbe_write_reg_1(hw,((reg_offset ^ 1U) + 5240U) * 4U,reg_offset + 4294967295U);
  #line 4222 
  ixgbe_write_reg_1(hw,(reg_offset + 8260U) * 4U,- ((unsigned int)(1UL << vf_shift)));
  #line 4223 
  ixgbe_write_reg_1(hw,((reg_offset ^ 1U) + 8260U) * 4U,reg_offset + 4294967295U);
  #line 4224 
  if ((unsigned int)adapter->bridge_mode == 0U) 
                                                #line 4225 
                                                ixgbe_write_reg_1(hw,33312U,1U);
  #line 4228 
  (*(hw->mac.ops.set_vmdq))(hw,0U,(unsigned int)adapter->ring_feature[1].offset);
  #line 4231 
  adapter->flags2 &= 4294959103U;
  #line 4237 
  switch ((int)adapter->ring_feature[1].mask) {
    #line 4238 
    case 120: 
              #line 4238 
    ;
    #line 4239 
    gcr_ext = 1U;
    #line 4240 
    break;
    #line 4241 
    case 124: 
              #line 4241 
    ;
    #line 4242 
    gcr_ext = 2U;
    #line 4243 
    break;
    #line 4244 
    default: 
             #line 4244 
    ;
    #line 4245 
    gcr_ext = 3U;
    #line 4246 
    break;
  }
  #line 4249 
  ixgbe_write_reg_1(hw,69712U,gcr_ext);
  #line 4251 
  i = 0;
  #line 4251 
  while (adapter->num_vfs > (unsigned int)i) {
    #line 4253 
    ixgbe_ndo_set_vf_spoofchk(adapter->netdev,i,(_Bool)((unsigned int)(adapter->vfinfo + (unsigned long)i)->spoofchk_enabled != 0U));
    #line 4257 
    ixgbe_ndo_set_vf_rss_query_en(adapter->netdev,i,(_Bool)((bool)((int)(adapter->vfinfo + (unsigned long)i)->rss_query_enabled) != 0));
    #line 4251 
    i ++;
  }
  #line 4260 
  return;
}

#line 4262  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_set_rx_buffer_len(struct ixgbe_adapter *adapter)
{
  #line 4267 
  struct ixgbe_ring *rx_ring;
  #line 4268 
  int i;
  #line 4269 
  u32 mhadd;
  #line 4269 
  u32 hlreg0;
  #line 4264 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4265 
  struct net_device *netdev = adapter->netdev;
  #line 4266 
  int max_frame = (int)(netdev->mtu + 18U);
  #line 4273 
  if (((unsigned long)adapter->flags & 2097152UL) != 0UL && max_frame <= 3071) 
    #line 4275 
    max_frame = 3072;
  #line 4280 
  if (max_frame <= 1517) 
                         #line 4281 
                         max_frame = 1518;
  #line 4283 
  mhadd = ixgbe_read_reg(hw,17000U);
  #line 4284 
  if (mhadd >> 16 != (unsigned int)max_frame) {
    #line 4285 
    mhadd &= 65535U;
    #line 4286 
    mhadd = (unsigned int)(max_frame << 16) | mhadd;
    #line 4288 
    ixgbe_write_reg_1(hw,17000U,mhadd);
  }
  #line 4291 
  hlreg0 = ixgbe_read_reg(hw,16960U);
  #line 4293 
  hlreg0 |= 4U;
  #line 4294 
  ixgbe_write_reg_1(hw,16960U,hlreg0);
  #line 4300 
  i = 0;
  #line 4300 
  while (adapter->num_rx_queues > i) {
    {
      #line 4301 
      rx_ring = adapter->rx_ring[i];
      #line 4303 
      cif_clear_bit(2L,& rx_ring->state);
      #line 4304 
      cif_clear_bit(0L,& rx_ring->state);
      #line 4305 
      cif_clear_bit(1L,& rx_ring->state);
      #line 4307 
      if (((unsigned long)adapter->flags2 & 2UL) != 0UL) 
                                                         #line 4308 
                                                         cif_set_bit(2L,& rx_ring->state);
      #line 4310 
      if ((int)test_bit(4L,& rx_ring->state) != 0) 
                                                   #line 4311 
                                                   cif_set_bit(0L,& rx_ring->state);
      #line 4313 
      if (((unsigned long)adapter->flags2 & 65536UL) != 0UL) 
                                                             #line 4314 
                                                             goto __Cont;
      #line 4316 
      cif_set_bit(1L,& rx_ring->state);
      #line 4319 
      if (((unsigned long)adapter->flags2 & 2UL) != 0UL) 
                                                         #line 4320 
                                                         cif_set_bit(0L,& rx_ring->state);
      #line 4322 
      if (max_frame > 1518) 
                            #line 4324 
                            cif_set_bit(0L,& rx_ring->state);
    }
    #line 4300 
    __Cont: 
            #line 4300 
    i ++;
  }
  #line 4326 
  return;
}

#line 4329  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_setup_rdrxctl(struct ixgbe_adapter *adapter)
{
  #line 4331 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4332 
  u32 rdrxctl = ixgbe_read_reg(hw,12032U);
  #line 4334 
  switch ((unsigned int)hw->mac.type) {
    #line 4335 
    case (unsigned int)1: 
                          #line 4335 
    ;
    #line 4346 
    rdrxctl |= 32U;
    #line 4347 
    break;
    #line 4348 
    case (unsigned int)4: 
                          #line 4348 
    ;
    #line 4349 
    case (unsigned int)5: 
                          #line 4349 
    ;
    #line 4350 
    case (unsigned int)6: 
                          #line 4350 
    ;
    #line 4351 
    if (adapter->num_vfs != 0U) 
                                #line 4352 
                                rdrxctl |= 4U;
    #line 4354 
    case (unsigned int)2: 
                          #line 4354 
    ;
    #line 4355 
    case (unsigned int)3: 
                          #line 4355 
    ;
    #line 4357 
    ;
    #line 4357 
    ixgbe_write_reg_1(hw,12328U,ixgbe_read_reg(hw,12328U) | 128U);
    #line 4359 
    rdrxctl &= 4290904063U;
    #line 4361 
    rdrxctl |= 100663296U;
    #line 4362 
    rdrxctl |= 2U;
    #line 4363 
    break;
    #line 4364 
    default: 
             #line 4364 
    ;
    #line 4366 
    return;
  }
  #line 4369 
  ixgbe_write_reg_1(hw,12032U,rdrxctl);
  #line 4370 
  return;
}

#line 4378  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_rx(struct ixgbe_adapter *adapter)
{
  #line 4381 
  int i;
  #line 4382 
  u32 rxctrl;
  #line 4382 
  u32 rfctl;
  #line 4380 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4385 
  (*(hw->mac.ops.disable_rx))(hw);
  #line 4387 
  ixgbe_setup_psrtype(adapter);
  #line 4388 
  ixgbe_setup_rdrxctl(adapter);
  #line 4391 
  rfctl = ixgbe_read_reg(hw,20488U);
  #line 4392 
  rfctl &= 4294967263U;
  #line 4393 
  if (((unsigned long)adapter->flags2 & 2UL) == 0UL) 
                                                     #line 4394 
                                                     rfctl |= 32U;
  #line 4397 
  rfctl |= 192U;
  #line 4398 
  ixgbe_write_reg_1(hw,20488U,rfctl);
  #line 4401 
  ixgbe_setup_mrqc(adapter);
  #line 4404 
  ixgbe_set_rx_buffer_len(adapter);
  #line 4410 
  i = 0;
  #line 4410 
  while (adapter->num_rx_queues > i) {
    #line 4411 
    ixgbe_configure_rx_ring(adapter,adapter->rx_ring[i]);
    #line 4410 
    i ++;
  }
  #line 4413 
  rxctrl = ixgbe_read_reg(hw,12288U);
  #line 4415 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) 
                                                       #line 4416 
                                                       rxctrl |= 2U;
  #line 4419 
  rxctrl |= 1U;
  #line 4420 
  (*(hw->mac.ops.enable_rx_dma))(hw,rxctrl);
  #line 4421 
  return;
}

#line 4423  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_vlan_rx_add_vid(struct net_device *netdev, __be16 proto, u16 vid)
{
  #line 4426 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 4427 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4430 
  if ((unsigned int)vid == 0U || ((unsigned long)adapter->flags2 & 8192UL) == 0UL) 
    #line 4431 
    (*(hw->mac.ops.set_vfta))(& adapter->hw,(unsigned int)vid,(unsigned int)adapter->ring_feature[1].offset,(_Bool)1,(_Bool)((unsigned int)vid != 0U));
  #line 4433 
  cif_set_bit((long)vid,(unsigned long *)(& adapter->active_vlans));
  #line 4435 
  return 0;
}

#line 4438  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_find_vlvf_entry(struct ixgbe_hw *hw, u32 vlan)
{
  #line 4440 
  u32 vlvf;
  #line 4441 
  int idx;
  #line 4444 
  if (vlan == 0U) 
                  #line 4445 
                  return 0;
  #line 4448 
  idx = 64;
  #line 4448 
  while (1) {
    #line 4448 
    idx --;
    #line 4448 
    if (! (idx != 0)) 
                      #line 4448 
                      break;
    #line 4449 
    vlvf = ixgbe_read_reg(hw,(unsigned int)((idx + 15424) * 4));
    #line 4450 
    if ((vlvf & 4095U) == vlan) 
                                #line 4451 
                                break;
  }
  #line 4454 
  return idx;
}

#line 4457  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_update_pf_promisc_vlvf(struct ixgbe_adapter *adapter, u32 vid)
{
  #line 4460 
  u32 bits;
  #line 4460 
  u32 word;
  #line 4461 
  int idx;
  #line 4459 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4463 
  idx = ixgbe_find_vlvf_entry(hw,vid);
  #line 4464 
  if (idx == 0) 
                #line 4465 
                return;
  #line 4470 
  word = (unsigned int)(idx * 2 + (int)adapter->ring_feature[1].offset / 32);
  #line 4471 
  bits = ~ ((unsigned int)(1UL << ((int)adapter->ring_feature[1].offset & 31)));
  #line 4472 
  bits = ixgbe_read_reg(hw,(word + 15488U) * 4U) & bits;
  #line 4475 
  if (bits == 0U) {
    #line 4475 
    if (ixgbe_read_reg(hw,((word ^ 1U) + 15488U) * 4U) == 0U) {
      #line 4476 
      if (((unsigned long)adapter->flags2 & 8192UL) == 0UL) 
                                                            #line 4477 
                                                            ixgbe_write_reg_1(hw,(word + 15488U) * 4U,0U);
      #line 4478 
      ixgbe_write_reg_1(hw,(unsigned int)((idx + 15424) * 4),0U);
    }
  }
  #line 4480 
  return;
}

#line 4482  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_vlan_rx_kill_vid(struct net_device *netdev, __be16 proto, u16 vid)
{
  #line 4485 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 4486 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4489 
  if ((unsigned int)vid != 0U && ((unsigned long)adapter->flags2 & 8192UL) == 0UL) 
    #line 4490 
    (*(hw->mac.ops.set_vfta))(hw,(unsigned int)vid,(unsigned int)adapter->ring_feature[1].offset,(_Bool)0,(_Bool)1);
  #line 4492 
  cif_clear_bit((long)vid,(unsigned long *)(& adapter->active_vlans));
  #line 4494 
  return 0;
}

#line 4501  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_vlan_strip_disable(struct ixgbe_adapter *adapter)
{
  #line 4504 
  u32 vlnctrl;
  #line 4505 
  int i;
  #line 4505 
  int j;
  #line 4503 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4507 
  switch ((unsigned int)hw->mac.type) {
    #line 4508 
    case (unsigned int)1: 
                          #line 4508 
    ;
    #line 4509 
    vlnctrl = ixgbe_read_reg(hw,20616U);
    #line 4510 
    vlnctrl &= 2147483647U;
    #line 4511 
    ixgbe_write_reg_1(hw,20616U,vlnctrl);
    #line 4512 
    break;
    #line 4513 
    case (unsigned int)2: 
                          #line 4513 
    ;
    #line 4514 
    case (unsigned int)3: 
                          #line 4514 
    ;
    #line 4515 
    case (unsigned int)4: 
                          #line 4515 
    ;
    #line 4516 
    case (unsigned int)5: 
                          #line 4516 
    ;
    #line 4517 
    case (unsigned int)6: 
                          #line 4517 
    ;
    #line 4518 
    i = 0;
    #line 4518 
    while (adapter->num_rx_queues > i) {
      {
        #line 4525 
        int tmp_0;
        #line 4527 
        int tmp_1;
        #line 4519 
        struct ixgbe_ring *ring = adapter->rx_ring[i];
        #line 4521 
        if (! netif_is_ixgbe(ring->netdev)) 
                                            #line 4522 
                                            goto __Cont;
        #line 4524 
        j = (int)ring->reg_idx;
        #line 4525 
        if (j <= 63) 
                     #line 4525 
                     tmp_0 = j * 64 + 4136; else 
                                                 #line 4525 
                                                 tmp_0 = (j + -64) * 64 + 53288;
        #line 4525 
        ;
        #line 4525 
        vlnctrl = ixgbe_read_reg(hw,(unsigned int)tmp_0);
        #line 4526 
        vlnctrl &= 3221225471U;
        #line 4527 
        ;
        #line 4527 
        if (j <= 63) 
                     #line 4527 
                     tmp_1 = j * 64 + 4136; else 
                                                 #line 4527 
                                                 tmp_1 = (j + -64) * 64 + 53288;
        #line 4527 
        ;
        #line 4527 
        ixgbe_write_reg_1(hw,(unsigned int)tmp_1,vlnctrl);
      }
      #line 4518 
      __Cont: 
              #line 4518 
      i ++;
    }
    #line 4529 
    break;
    #line 4530 
    default: 
             #line 4530 
    ;
    #line 4531 
    break;
  }
  #line 4533 
  return;
}

#line 4539  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_vlan_strip_enable(struct ixgbe_adapter *adapter)
{
  #line 4542 
  u32 vlnctrl;
  #line 4543 
  int i;
  #line 4543 
  int j;
  #line 4541 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4545 
  switch ((unsigned int)hw->mac.type) {
    #line 4546 
    case (unsigned int)1: 
                          #line 4546 
    ;
    #line 4547 
    vlnctrl = ixgbe_read_reg(hw,20616U);
    #line 4548 
    vlnctrl |= 2147483648U;
    #line 4549 
    ixgbe_write_reg_1(hw,20616U,vlnctrl);
    #line 4550 
    break;
    #line 4551 
    case (unsigned int)2: 
                          #line 4551 
    ;
    #line 4552 
    case (unsigned int)3: 
                          #line 4552 
    ;
    #line 4553 
    case (unsigned int)4: 
                          #line 4553 
    ;
    #line 4554 
    case (unsigned int)5: 
                          #line 4554 
    ;
    #line 4555 
    case (unsigned int)6: 
                          #line 4555 
    ;
    #line 4556 
    i = 0;
    #line 4556 
    while (adapter->num_rx_queues > i) {
      {
        #line 4563 
        int tmp_0;
        #line 4565 
        int tmp_1;
        #line 4557 
        struct ixgbe_ring *ring = adapter->rx_ring[i];
        #line 4559 
        if (! netif_is_ixgbe(ring->netdev)) 
                                            #line 4560 
                                            goto __Cont;
        #line 4562 
        j = (int)ring->reg_idx;
        #line 4563 
        if (j <= 63) 
                     #line 4563 
                     tmp_0 = j * 64 + 4136; else 
                                                 #line 4563 
                                                 tmp_0 = (j + -64) * 64 + 53288;
        #line 4563 
        ;
        #line 4563 
        vlnctrl = ixgbe_read_reg(hw,(unsigned int)tmp_0);
        #line 4564 
        vlnctrl |= 1073741824U;
        #line 4565 
        ;
        #line 4565 
        if (j <= 63) 
                     #line 4565 
                     tmp_1 = j * 64 + 4136; else 
                                                 #line 4565 
                                                 tmp_1 = (j + -64) * 64 + 53288;
        #line 4565 
        ;
        #line 4565 
        ixgbe_write_reg_1(hw,(unsigned int)tmp_1,vlnctrl);
      }
      #line 4556 
      __Cont: 
              #line 4556 
      i ++;
    }
    #line 4567 
    break;
    #line 4568 
    default: 
             #line 4568 
    ;
    #line 4569 
    break;
  }
  #line 4571 
  return;
}

#line 4573  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_vlan_promisc_enable(struct ixgbe_adapter *adapter)
{
  #line 4576 
  u32 vlnctrl;
  #line 4576 
  u32 i;
  #line 4575 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4578 
  vlnctrl = ixgbe_read_reg(hw,20616U);
  #line 4580 
  if (((unsigned long)adapter->flags & 16384UL) != 0UL) {
    #line 4582 
    vlnctrl |= 1073741824U;
    #line 4583 
    ixgbe_write_reg_1(hw,20616U,vlnctrl);
  }
  else {
    #line 4585 
    vlnctrl &= 3221225471U;
    #line 4586 
    ixgbe_write_reg_1(hw,20616U,vlnctrl);
    #line 4587 
    return;
  }
  #line 4591 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) 
                                                       #line 4592 
                                                       return;
  #line 4595 
  if (((unsigned long)adapter->flags2 & 8192UL) != 0UL) 
                                                        #line 4596 
                                                        return;
  #line 4599 
  adapter->flags2 |= 8192U;
  #line 4602 
  i = 64U;
  #line 4602 
  while (1) {
    #line 4602 
    i --;
    #line 4602 
    if (! (i != 0U)) 
                     #line 4602 
                     break;
    {
      #line 4603 
      u32 reg_offset = ((i * 2U + (unsigned int)((int)adapter->ring_feature[1].offset / 32)) + 15488U) * 4U;
      #line 4604 
      u32 vlvfb = ixgbe_read_reg(hw,reg_offset);
      #line 4606 
      vlvfb = (unsigned int)(1UL << ((int)adapter->ring_feature[1].offset & 31)) | vlvfb;
      #line 4607 
      ixgbe_write_reg_1(hw,reg_offset,vlvfb);
    }
  }
  #line 4611 
  i = hw->mac.vft_size;
  #line 4611 
  while (1) {
    #line 4611 
    u32 tmp_0;
    #line 4611 
    tmp_0 = i;
    #line 4611 
    i --;
    #line 4611 
    ;
    #line 4611 
    if (! (tmp_0 != 0U)) 
                         #line 4611 
                         break;
    #line 4612 
    ixgbe_write_reg_1(hw,(i + 10240U) * 4U,4294967295U);
  }
  #line 4613 
  return;
}

#line 4616  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_scrub_vfta(struct ixgbe_adapter *adapter, u32 vfta_offset)
{
  #line 4622 
  u32 i;
  #line 4622 
  u32 vid;
  #line 4622 
  u32 word;
  #line 4622 
  u32 bits;
  #line 4618 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4619 
  u32 vfta[8U] = {0U};
  #line 4620 
  u32 vid_start = vfta_offset * 32U;
  #line 4621 
  u32 vid_end = vid_start + 256U;
  #line 4624 
  i = 64U;
  #line 4624 
  while (1) {
    #line 4624 
    i --;
    #line 4624 
    if (! (i != 0U)) 
                     #line 4624 
                     break;
    {
      #line 4625 
      u32 vlvf = ixgbe_read_reg(hw,(i + 15424U) * 4U);
      #line 4628 
      vid = vlvf & 4095U;
      #line 4631 
      if (vid < vid_start || vid >= vid_end) 
                                             #line 4632 
                                             goto __Cont;
      #line 4634 
      if (vlvf != 0U) {
        #line 4636 
        vfta[(vid - vid_start) / 32U] |= (unsigned int)(1UL << (vid & 31U));
        #line 4639 
        if ((int)test_bit((long)vid,(unsigned long *)(& adapter->active_vlans)) != 0) 
          #line 4640 
          goto __Cont;
      }
      #line 4644 
      word = i * 2U + (unsigned int)((int)adapter->ring_feature[1].offset / 32);
      #line 4645 
      bits = ~ ((unsigned int)(1UL << ((int)adapter->ring_feature[1].offset & 31)));
      #line 4646 
      bits = ixgbe_read_reg(hw,(word + 15488U) * 4U) & bits;
      #line 4647 
      ixgbe_write_reg_1(hw,(word + 15488U) * 4U,bits);
    }
    #line 4624 
    __Cont: 
            #line 4624 
    ;
  }
  #line 4651 
  i = 8U;
  #line 4651 
  while (1) {
    #line 4651 
    u32 tmp_2;
    #line 4651 
    tmp_2 = i;
    #line 4651 
    i --;
    #line 4651 
    ;
    #line 4651 
    if (! (tmp_2 != 0U)) 
                         #line 4651 
                         break;
    #line 4652 
    vid = (vfta_offset + i) * 32U;
    #line 4653 
    word = vid / 64U;
    #line 4654 
    bits = vid & 63U;
    #line 4656 
    vfta[i] |= (unsigned int)(adapter->active_vlans[word] >> bits);
    #line 4658 
    ixgbe_write_reg_1(hw,((vfta_offset + i) + 10240U) * 4U,vfta[i]);
  }
  #line 4660 
  return;
}

#line 4662  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_vlan_promisc_disable(struct ixgbe_adapter *adapter)
{
  #line 4665 
  u32 vlnctrl;
  #line 4665 
  u32 i;
  #line 4664 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4668 
  vlnctrl = ixgbe_read_reg(hw,20616U);
  #line 4669 
  vlnctrl |= 1073741824U;
  #line 4670 
  ixgbe_write_reg_1(hw,20616U,vlnctrl);
  #line 4672 
  if (((unsigned long)adapter->flags & 16384UL) == 0UL || hw->mac.type == (unsigned int)ixgbe_mac_82598EB) 
    #line 4674 
    return;
  #line 4677 
  if (((unsigned long)adapter->flags2 & 8192UL) == 0UL) 
                                                        #line 4678 
                                                        return;
  #line 4681 
  adapter->flags2 &= 4294959103U;
  #line 4683 
  i = 0U;
  #line 4683 
  while (hw->mac.vft_size > i) {
    #line 4684 
    ixgbe_scrub_vfta(adapter,i);
    #line 4683 
    i += 8U;
  }
  #line 4685 
  return;
}

#line 4687  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_restore_vlan(struct ixgbe_adapter *adapter)
{
  #line 4689 
  u16 vid = (unsigned short)1U;
  #line 4691 
  ixgbe_vlan_rx_add_vid(adapter->netdev,(unsigned short)129,(unsigned short)0);
  #line 4693 
  vid = (unsigned short)cif_find_next_bit((unsigned long *)(& adapter->active_vlans),4096UL,
                        (unsigned long)vid);
  #line 4693 
  while ((unsigned int)vid <= 4095U) {
    #line 4694 
    ixgbe_vlan_rx_add_vid(adapter->netdev,(unsigned short)129,(unsigned short)((int)vid));
    #line 4693 
    vid = (unsigned short)cif_find_next_bit((unsigned long *)(& adapter->active_vlans),4096UL,
                          (unsigned long)((int)vid + 1));
  }
  #line 4695 
  return;
}

#line 4706  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_write_mc_addr_list(struct net_device *netdev)
{
  #line 4708 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 4709 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4711 
  if (! netif_running(netdev)) 
                               #line 4712 
                               return 0;
  #line 4714 
  if (hw->mac.ops.update_mc_addr_list != (s32 (*)(struct ixgbe_hw *, struct net_device *))0) 
    #line 4715 
    (*(hw->mac.ops.update_mc_addr_list))(hw,netdev); else 
                                                          #line 4717 
                                                          return -12;
  #line 4720 
  ixgbe_restore_vf_multicasts(adapter);
  #line 4723 
  return netdev->mc.count;
}

#line 4727  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_full_sync_mac_table(struct ixgbe_adapter *adapter)
{
  #line 4731 
  int i;
  #line 4729 
  struct ixgbe_mac_addr *mac_table = adapter->mac_table;
  #line 4730 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4733 
  i = 0;
  #line 4733 
  while (hw->mac.num_rar_entries > (unsigned int)i) {
    #line 4734 
    mac_table->state = (unsigned short)((unsigned int)mac_table->state & 65533U);
    #line 4736 
    if (((int)mac_table->state & 4) != 0) 
                                          #line 4737 
                                          (*(hw->mac.ops.set_rar))(hw,(unsigned int)i,(u8 *)(& mac_table->addr),(unsigned int)mac_table->pool,2147483648U); else 
                                                                    #line 4742 
                                                                    (*(hw->mac.ops.clear_rar))(hw,(unsigned int)i);
    #line 4733 
    i ++;
    #line 4733 
    mac_table ++;
  }
  #line 4744 
  return;
}

#line 4747  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_sync_mac_table(struct ixgbe_adapter *adapter)
{
  #line 4751 
  int i;
  #line 4749 
  struct ixgbe_mac_addr *mac_table = adapter->mac_table;
  #line 4750 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4753 
  i = 0;
  #line 4753 
  while (hw->mac.num_rar_entries > (unsigned int)i) {
    #line 4754 
    if (((int)mac_table->state & 2) == 0) 
                                          #line 4755 
                                          goto __Cont;
    #line 4757 
    mac_table->state = (unsigned short)((unsigned int)mac_table->state & 65533U);
    #line 4759 
    if (((int)mac_table->state & 4) != 0) 
                                          #line 4760 
                                          (*(hw->mac.ops.set_rar))(hw,(unsigned int)i,(u8 *)(& mac_table->addr),(unsigned int)mac_table->pool,2147483648U); else 
                                                                    #line 4765 
                                                                    (*(hw->mac.ops.clear_rar))(hw,(unsigned int)i);
    #line 4753 
    __Cont: 
            #line 4753 
    i ++;
    #line 4753 
    mac_table ++;
  }
  #line 4767 
  return;
}

#line 4769  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_flush_sw_mac_table(struct ixgbe_adapter *adapter)
{
  #line 4773 
  int i;
  #line 4771 
  struct ixgbe_mac_addr *mac_table = adapter->mac_table;
  #line 4772 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4775 
  i = 0;
  #line 4775 
  while (hw->mac.num_rar_entries > (unsigned int)i) {
    #line 4776 
    mac_table->state = (unsigned short)((unsigned int)mac_table->state | 2U);
    #line 4777 
    mac_table->state = (unsigned short)((unsigned int)mac_table->state & 65531U);
    #line 4775 
    i ++;
    #line 4775 
    mac_table ++;
  }
  #line 4780 
  ixgbe_sync_mac_table(adapter);
  #line 4781 
  return;
}

#line 4783  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_available_rars(struct ixgbe_adapter *adapter, u16 pool)
{
  #line 4787 
  int i;
  #line 4785 
  struct ixgbe_mac_addr *mac_table = adapter->mac_table;
  #line 4786 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4787 
  int count = 0;
  #line 4789 
  i = 0;
  #line 4789 
  while (hw->mac.num_rar_entries > (unsigned int)i) {
    #line 4791 
    if (((int)mac_table->state & 1) != 0) 
                                          #line 4792 
                                          goto __Cont;
    #line 4795 
    if (((int)mac_table->state & 4) != 0) 
      #line 4796 
      if ((int)mac_table->pool != (int)pool) 
                                             #line 4797 
                                             goto __Cont;
    #line 4800 
    count ++;
    #line 4789 
    __Cont: 
            #line 4789 
    i ++;
    #line 4789 
    mac_table ++;
  }
  #line 4803 
  return count;
}

#line 4807  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_mac_set_default_filter(struct ixgbe_adapter *adapter)
{
  #line 4809 
  struct ixgbe_mac_addr *mac_table = adapter->mac_table;
  #line 4810 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4812 
  memcpy((void *)(& mac_table->addr),(void *)(& hw->mac.addr),6UL);
  #line 4813 
  mac_table->pool = adapter->ring_feature[1].offset;
  #line 4815 
  mac_table->state = (unsigned short)5U;
  #line 4817 
  (*(hw->mac.ops.set_rar))(hw,0U,(u8 *)(& mac_table->addr),(unsigned int)mac_table->pool,2147483648U);
  #line 4818 
  return;
}

#line 4821  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_add_mac_filter(struct ixgbe_adapter *adapter, u8 *addr, u16 pool)
{
  #line 4826 
  int i;
  #line 4824 
  struct ixgbe_mac_addr *mac_table = adapter->mac_table;
  #line 4825 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4828 
  if ((int)is_zero_ether_addr(addr) != 0) 
                                          #line 4829 
                                          return -22;
  #line 4831 
  i = 0;
  #line 4831 
  while (hw->mac.num_rar_entries > (unsigned int)i) {
    #line 4832 
    if (((int)mac_table->state & 4) != 0) 
                                          #line 4833 
                                          goto __Cont;
    #line 4835 
    ether_addr_copy((u8 *)(& mac_table->addr),addr);
    #line 4836 
    mac_table->pool = pool;
    #line 4838 
    mac_table->state = (unsigned short)((unsigned int)mac_table->state | 6U);
    #line 4841 
    ixgbe_sync_mac_table(adapter);
    #line 4843 
    return i;
    #line 4831 
    __Cont: 
            #line 4831 
    i ++;
    #line 4831 
    mac_table ++;
  }
  #line 4846 
  return -12;
}

#line 4849  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_del_mac_filter(struct ixgbe_adapter *adapter, u8 *addr, u16 pool)
{
  #line 4854 
  int i;
  #line 4852 
  struct ixgbe_mac_addr *mac_table = adapter->mac_table;
  #line 4853 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4856 
  if ((int)is_zero_ether_addr(addr) != 0) 
                                          #line 4857 
                                          return -22;
  #line 4860 
  i = 0;
  #line 4860 
  while (hw->mac.num_rar_entries > (unsigned int)i) {
    {
      #line 4862 
      if (((int)mac_table->state & 4) == 0) 
                                            #line 4863 
                                            goto __Cont;
      #line 4865 
      if ((int)mac_table->pool != (int)pool) 
                                             #line 4866 
                                             goto __Cont;
      #line 4868 
      if (! ether_addr_equal(addr,(u8 *)(& mac_table->addr))) 
                                                              #line 4869 
                                                              goto __Cont;
      #line 4871 
      mac_table->state = (unsigned short)((unsigned int)mac_table->state | 2U);
      #line 4872 
      mac_table->state = (unsigned short)((unsigned int)mac_table->state & 65531U);
      #line 4874 
      ixgbe_sync_mac_table(adapter);
      #line 4876 
      return 0;
    }
    #line 4860 
    __Cont: 
            #line 4860 
    i ++;
    #line 4860 
    mac_table ++;
  }
  #line 4879 
  return -12;
}

#line 4882  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_uc_sync(struct net_device *netdev, unsigned char *addr)
{
  #line 4889 
  int __UNIQUE_ID___x583;
  #line 4889 
  int tmp_0;
  #line 4885 
  int ret;
  #line 4884 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 4887 
  ret = ixgbe_add_mac_filter(adapter,addr,(unsigned short)((int)adapter->ring_feature[1].offset));
  {
    #line 4889 
    __UNIQUE_ID___x583 = ret;
    #line 4889 
    int __UNIQUE_ID___y584 = 0;
    #line 4889 
    if (__UNIQUE_ID___x583 < __UNIQUE_ID___y584) 
                                                 #line 4889 
                                                 tmp_0 = __UNIQUE_ID___x583; else 
                                                                    #line 4889 
                                                                    tmp_0 = __UNIQUE_ID___y584;
    }
  #line 4889 
  return tmp_0;
}

#line 4892  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_uc_unsync(struct net_device *netdev, unsigned char *addr)
{
  #line 4894 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 4896 
  ixgbe_del_mac_filter(adapter,addr,(unsigned short)((int)adapter->ring_feature[1].offset));
  #line 4898 
  return 0;
}

#line 4910  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_set_rx_mode(struct net_device *netdev)
{
  #line 4914 
  u32 fctrl;
  #line 4916 
  int count;
  #line 4912 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 4913 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 4914 
  u32 vmolr = 150994944U;
  #line 4915 
  netdev_features_t features = netdev->features;
  #line 4919 
  fctrl = ixgbe_read_reg(hw,20608U);
  #line 4922 
  fctrl &= 4294967293U;
  #line 4923 
  fctrl |= 1024U;
  #line 4924 
  fctrl |= 8192U;
  #line 4925 
  fctrl |= 4096U;
  #line 4928 
  fctrl &= 4294966527U;
  #line 4929 
  if ((netdev->flags & 256U) != 0U) {
    #line 4930 
    hw->addr_ctrl.user_set_promisc = (_Bool)1;
    #line 4931 
    fctrl |= 768U;
    #line 4932 
    vmolr |= 268435456U;
    #line 4933 
    features &= 18446744073709551103ULL;
  }
  else {
    #line 4935 
    if ((netdev->flags & 512U) != 0U) {
      #line 4936 
      fctrl |= 256U;
      #line 4937 
      vmolr |= 268435456U;
    }
    #line 4939 
    hw->addr_ctrl.user_set_promisc = (_Bool)0;
  }
  #line 4947 
  if (__dev_uc_sync(netdev,& ixgbe_uc_sync,& ixgbe_uc_unsync) != 0) {
    #line 4948 
    fctrl |= 512U;
    #line 4949 
    vmolr |= 67108864U;
  }
  #line 4956 
  count = ixgbe_write_mc_addr_list(netdev);
  #line 4957 
  if (count < 0) {
    #line 4958 
    fctrl |= 256U;
    #line 4959 
    vmolr |= 268435456U;
  }
  else 
    #line 4960 
    if (count != 0) 
                    #line 4961 
                    vmolr |= 33554432U;
  #line 4964 
  if (hw->mac.type != (unsigned int)ixgbe_mac_82598EB) {
    #line 4967 
    vmolr = (ixgbe_read_reg(hw,
                       (unsigned int)(((int)adapter->ring_feature[1].offset + 15360) * 4)) & 3925868543U) | vmolr;
    #line 4968 
    ixgbe_write_reg_1(hw,(unsigned int)(((int)adapter->ring_feature[1].offset + 15360) * 4),vmolr);
  }
  #line 4972 
  if ((features & 8796093022208ULL) != 0ULL) {
    #line 4975 
    fctrl |= 5122U;
    #line 4979 
    fctrl &= 4294959103U;
  }
  #line 4983 
  ixgbe_write_reg_1(hw,20608U,fctrl);
  #line 4985 
  if ((features & 256ULL) != 0ULL) 
                                   #line 4986 
                                   ixgbe_vlan_strip_enable(adapter); else 
                                                                    #line 4988 
                                                                    ixgbe_vlan_strip_disable(adapter);
  #line 4990 
  if ((features & 512ULL) != 0ULL) 
                                   #line 4991 
                                   ixgbe_vlan_promisc_disable(adapter); else 
                                                                    #line 4993 
                                                                    ixgbe_vlan_promisc_enable(adapter);
  #line 4994 
  return;
}

#line 4996  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_napi_enable_all(struct ixgbe_adapter *adapter)
{
  #line 4998 
  int q_idx;
  #line 5000 
  q_idx = 0;
  #line 5000 
  while (adapter->num_q_vectors > q_idx) {
    #line 5001 
    napi_enable(& (adapter->q_vector[q_idx])->napi);
    #line 5000 
    q_idx ++;
  }
  #line 5002 
  return;
}

#line 5004  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_napi_disable_all(struct ixgbe_adapter *adapter)
{
  #line 5006 
  int q_idx;
  #line 5008 
  q_idx = 0;
  #line 5008 
  while (adapter->num_q_vectors > q_idx) {
    #line 5009 
    napi_disable(& (adapter->q_vector[q_idx])->napi);
    #line 5008 
    q_idx ++;
  }
  #line 5010 
  return;
}

#line 5012  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_clear_udp_tunnel_port(struct ixgbe_adapter *adapter, u32 mask)
{
  #line 5015 
  u32 vxlanctrl;
  #line 5014 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 5017 
  if (((unsigned long)adapter->flags & 285212672UL) == 0UL) 
                                                            #line 5019 
                                                            return;
  #line 5021 
  vxlanctrl = ixgbe_read_reg(hw,20604U) & ~ mask;
  #line 5022 
  ixgbe_write_reg_1(hw,20604U,vxlanctrl);
  #line 5024 
  if ((mask & 65535U) != 0U) 
                             #line 5025 
                             adapter->vxlan_port = (unsigned short)0U;
  #line 5027 
  if ((mask & 4294901760U) != 0U) 
                                  #line 5028 
                                  adapter->geneve_port = (unsigned short)0U;
  #line 5029 
  return;
}

#line 5040  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_dcb(struct ixgbe_adapter *adapter)
{
  #line 5042 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 5043 
  int max_frame = (int)((adapter->netdev)->mtu + 18U);
  #line 5045 
  if (((unsigned long)adapter->flags & 4096UL) == 0UL) {
    #line 5046 
    if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) 
                                                         #line 5047 
                                                         netif_set_gso_max_size(adapter->netdev,65536U);
    #line 5048 
    return;
  }
  #line 5051 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) 
                                                       #line 5052 
                                                       netif_set_gso_max_size(adapter->netdev,32768U);
  #line 5055 
  if (((adapter->netdev)->features & 68719476736ULL) != 0ULL) {
    #line 5056 
    int __UNIQUE_ID___x585;
    #line 5056 
    int tmp;
    {
      #line 5056 
      __UNIQUE_ID___x585 = max_frame;
      #line 5056 
      int __UNIQUE_ID___y586 = 3072;
      #line 5056 
      if (__UNIQUE_ID___x585 > __UNIQUE_ID___y586) 
                                                   #line 5056 
                                                   tmp = __UNIQUE_ID___x585; else 
                                                                    #line 5056 
                                                                    tmp = __UNIQUE_ID___y586;
      }
    #line 5056 
    max_frame = tmp;
  }
  #line 5060 
  if (((int)adapter->dcbx_cap & 4) != 0) {
    #line 5061 
    ixgbe_dcb_calculate_tc_credits(hw,& adapter->dcb_cfg,max_frame,(unsigned char)0);
    #line 5063 
    ixgbe_dcb_calculate_tc_credits(hw,& adapter->dcb_cfg,max_frame,(unsigned char)1);
    #line 5065 
    ixgbe_dcb_hw_config(hw,& adapter->dcb_cfg);
  }
  else 
    #line 5066 
    if (adapter->ixgbe_ieee_ets != (struct ieee_ets *)0 && adapter->ixgbe_ieee_pfc != (struct ieee_pfc *)0) {
      #line 5067 
      ixgbe_dcb_hw_ets(& adapter->hw,adapter->ixgbe_ieee_ets,max_frame);
      #line 5070 
      ixgbe_dcb_hw_pfc_config(& adapter->hw,(unsigned char)((int)(adapter->ixgbe_ieee_pfc)->pfc_en),(u8 *)(& (adapter->ixgbe_ieee_ets)->prio_tc));
    }
  #line 5076 
  if (hw->mac.type != (unsigned int)ixgbe_mac_82598EB) {
    #line 5077 
    u32 msb = 0U;
    #line 5078 
    u16 rss_i = (unsigned short)((unsigned int)adapter->ring_feature[2].indices + 65535U);
    #line 5080 
    while ((unsigned int)rss_i != 0U) {
      #line 5081 
      msb ++;
      #line 5082 
      rss_i = (unsigned short)((int)rss_i >> 1);
    }
    #line 5086 
    ixgbe_write_reg_1(hw,60528U,msb * 286331153U);
  }
  #line 5088 
  return;
}

#line 5100  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_hpbthresh(struct ixgbe_adapter *adapter, int pb)
{
  #line 5104 
  int link;
  #line 5104 
  int tc;
  #line 5104 
  int kb;
  #line 5104 
  int marker;
  #line 5105 
  u32 dv_id;
  #line 5105 
  u32 rx_pba;
  #line 5102 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 5103 
  struct net_device *dev = adapter->netdev;
  #line 5108 
  link = (int)(dev->mtu + 38U);
  #line 5108 
  tc = link;
  #line 5112 
  if ((dev->features & 68719476736ULL) != 0ULL && tc <= 3071) {
    #line 5114 
    ;
    #line 5114 
    if ((int)ixgbe_fcoe_get_tc(adapter) == pb) 
                                               #line 5115 
                                               tc = 3072;
  }
  #line 5119 
  switch ((unsigned int)hw->mac.type) {
    #line 5120 
    case (unsigned int)3: 
                          #line 5120 
    ;
    #line 5121 
    case (unsigned int)4: 
                          #line 5121 
    ;
    #line 5122 
    case (unsigned int)5: 
                          #line 5122 
    ;
    #line 5123 
    case (unsigned int)6: 
                          #line 5123 
    ;
    #line 5124 
    dv_id = (unsigned int)((((link + 11713) * 288) / 25 + 1) + tc * 16);
    #line 5125 
    break;
    #line 5126 
    default: 
             #line 5126 
    ;
    #line 5127 
    dv_id = (unsigned int)((((link + 6977) * 288) / 25 + 1) + tc * 16);
    #line 5128 
    break;
  }
  #line 5132 
  if (((unsigned long)adapter->flags & 8388608UL) != 0UL) 
                                                          #line 5133 
                                                          dv_id = (unsigned int)(tc * 8) + dv_id;
  #line 5136 
  kb = (int)((dv_id + 8191U) / 8192U);
  #line 5137 
  rx_pba = ixgbe_read_reg(hw,(unsigned int)((pb + 3840) * 4)) >> 10;
  #line 5139 
  marker = (int)(rx_pba - (unsigned int)kb);
  #line 5145 
  if (marker < 0) {
    #line 5146 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 5146 
                                             netdev_warn(adapter->netdev,(char *)"Packet Buffer(%i) can not provide enough",pb);
    #line 5149 
    marker = tc + 1;
  }
  #line 5152 
  return marker;
}

#line 5161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_lpbthresh(struct ixgbe_adapter *adapter, int pb)
{
  #line 5165 
  int tc;
  #line 5166 
  u32 dv_id;
  #line 5163 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 5164 
  struct net_device *dev = adapter->netdev;
  #line 5169 
  tc = (int)(dev->mtu + 18U);
  #line 5173 
  if ((dev->features & 68719476736ULL) != 0ULL && tc <= 3071) {
    #line 5174 
    ;
    #line 5174 
    if (netdev_get_prio_tc_map(dev,(unsigned int)adapter->fcoe.up) == pb) 
      #line 5176 
      tc = 3072;
  }
  #line 5180 
  switch ((unsigned int)hw->mac.type) {
    #line 5181 
    case (unsigned int)3: 
                          #line 5181 
    ;
    #line 5182 
    case (unsigned int)4: 
                          #line 5182 
    ;
    #line 5183 
    case (unsigned int)5: 
                          #line 5183 
    ;
    #line 5184 
    case (unsigned int)6: 
                          #line 5184 
    ;
    #line 5185 
    dv_id = (unsigned int)((tc + 900) * 16 + 1);
    #line 5186 
    break;
    #line 5187 
    default: 
             #line 5187 
    ;
    #line 5188 
    dv_id = (unsigned int)(((tc + 900) * 16 + 1) * 2);
    #line 5189 
    break;
  }
  #line 5193 
  return (int)((dv_id + 8191U) / 8192U);
}

#line 5199  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_pbthresh_setup(struct ixgbe_adapter *adapter)
{
  #line 5203 
  int i;
  #line 5201 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 5202 
  int num_tc = (int)adapter->hw_tcs;
  #line 5205 
  if (num_tc == 0) 
                   #line 5206 
                   num_tc = 1;
  #line 5208 
  i = 0;
  #line 5208 
  while (i < num_tc) {
    {
      #line 5209 
      hw->fc.high_water[i] = (unsigned int)ixgbe_hpbthresh(adapter,i);
      #line 5210 
      hw->fc.low_water[i] = (unsigned int)ixgbe_lpbthresh(adapter,i);
      #line 5213 
      if (hw->fc.low_water[i] > hw->fc.high_water[i]) 
                                                      #line 5214 
                                                      hw->fc.low_water[i] = 0U;
    }
    #line 5208 
    i ++;
  }
  #line 5217 
  while (i <= 7) {
    #line 5218 
    hw->fc.high_water[i] = 0U;
    #line 5217 
    i ++;
  }
  #line 5219 
  return;
}

#line 5221  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_pb(struct ixgbe_adapter *adapter)
{
  #line 5224 
  int hdrm;
  #line 5223 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 5225 
  u8 tc = adapter->hw_tcs;
  #line 5227 
  if (((unsigned long)adapter->flags & 262144UL) != 0UL || ((unsigned long)adapter->flags & 524288UL) != 0UL) 
    #line 5229 
    hdrm = 32 << adapter->fdir_pballoc; else 
                                             #line 5231 
                                             hdrm = 0;
  #line 5233 
  (*(hw->mac.ops.set_rxpba))(hw,(int)tc,(unsigned int)hdrm,0);
  #line 5234 
  ixgbe_pbthresh_setup(adapter);
  #line 5235 
  return;
}

#line 5237  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_fdir_filter_restore(struct ixgbe_adapter *adapter)
{
  #line 5249 
  struct ixgbe_fdir_filter *tmp_1;
  #line 5249 
  void *__mptr;
  #line 5240 
  struct hlist_node *node2;
  #line 5241 
  struct ixgbe_fdir_filter *filter;
  #line 5242 
  u8 queue;
  #line 5239 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 5244 
  cif_spin_lock_fdir_perfect_lock_of_ixgbe_adapter(& adapter->fdir_perfect_lock);
  #line 5246 
  if (hlist_empty(& adapter->fdir_filter_list) == 0) 
                                                     #line 5247 
                                                     ixgbe_fdir_set_input_mask_82599(hw,& adapter->fdir_mask);
  {
    #line 5249 
    struct hlist_node *____ptr = adapter->fdir_filter_list.first;
    #line 5249 
    if (____ptr != (struct hlist_node *)0) {
      #line 5249 
      __mptr = (void *)____ptr;
      #line 5249 
      tmp_1 = ((struct ixgbe_fdir_filter *)__mptr);
    }
    else 
         #line 5249 
         tmp_1 = (struct ixgbe_fdir_filter *)0;
    }
  #line 5249 
  filter = tmp_1;
  #line 5249 
  while (1) {
    #line 5249 
    void *__mptr_0;
    #line 5249 
    struct ixgbe_fdir_filter *tmp_4;
    #line 5249 
    if (filter != (struct ixgbe_fdir_filter *)0) {
      #line 5249 
      node2 = filter->fdir_node.next;
      #line 5249 
      if (! (1 != 0)) 
                      #line 5249 
                      break;
    }
    else 
         #line 5249 
         break;
    #line 5251 
    if (filter->action == 127ULL) 
                                  #line 5252 
                                  queue = (unsigned char)127U;
    else {
      #line 5254 
      u32 ring = (unsigned int)ethtool_get_flow_spec_ring(filter->action);
      #line 5255 
      u8 vf = (unsigned char)ethtool_get_flow_spec_ring_vf(filter->action);
      #line 5257 
      if ((unsigned int)vf == 0U && (unsigned int)adapter->num_rx_queues <= ring) {
        #line 5258 
        if (((int)adapter->msg_enable & 1) != 0) 
                                                 #line 5258 
                                                 netdev_err(adapter->netdev,(char *)"FDIR restore failed without VF, ring: %u\n",ring);
        #line 5260 
        goto __Cont;
      }
      else 
        #line 5261 
        if ((unsigned int)vf != 0U && ((unsigned int)vf > adapter->num_vfs || (unsigned int)adapter->num_rx_queues_per_pool <= ring)) {
          #line 5264 
          if (((int)adapter->msg_enable & 1) != 0) 
                                                   #line 5264 
                                                   netdev_err(adapter->netdev,(char *)"FDIR restore failed with VF, vf: %hhu, ring: %u\n",(int)vf,ring);
          #line 5266 
          goto __Cont;
        }
      #line 5270 
      if ((unsigned int)vf == 0U) 
                                  #line 5271 
                                  queue = (adapter->rx_ring[ring])->reg_idx; else 
                                                                    #line 5273 
                                                                    queue = (unsigned char)(((unsigned int)vf + 255U) * (unsigned int)((unsigned char)adapter->num_rx_queues_per_pool) + (unsigned int)((unsigned char)ring));
    }
    #line 5277 
    ixgbe_fdir_write_perfect_filter_82599(hw,& filter->filter,(unsigned short)((int)filter->sw_idx),(unsigned char)((int)queue));
    #line 5249 
    __Cont: { /* sequence */
              {
                #line 5249 
                struct hlist_node *____ptr_0 = node2;
                #line 5249 
                if (____ptr_0 != (struct hlist_node *)0) {
                  #line 5249 
                  __mptr_0 = (void *)____ptr_0;
                  #line 5249 
                  tmp_4 = ((struct ixgbe_fdir_filter *)__mptr_0);
                }
                else 
                     #line 5249 
                     tmp_4 = (struct ixgbe_fdir_filter *)0;
                }
              #line 5249 
              filter = tmp_4;
            }
  }
  #line 5281 
  cif_spin_unlock_fdir_perfect_lock_of_ixgbe_adapter(& adapter->fdir_perfect_lock);
  #line 5282 
  return;
}

#line 5288  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_clean_rx_ring(struct ixgbe_ring *rx_ring)
{
  #line 5290 
  u16 i = rx_ring->next_to_clean;
  #line 5291 
  struct ixgbe_rx_buffer *rx_buffer = rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info + (unsigned long)i;
  #line 5293 
  if (rx_ring->xsk_umem != (struct xdp_umem *)0) {
    #line 5294 
    ixgbe_xsk_clean_rx_ring(rx_ring);
    #line 5295 
    goto skip_free;
  }
  #line 5299 
  while ((int)rx_ring->__anonCompField_ixgbe_ring_223.next_to_alloc != (int)i) {
    #line 5300 
    if (rx_buffer->skb != (struct sk_buff *)0) {
      #line 5301 
      struct sk_buff *skb = rx_buffer->skb;
      #line 5302 
      if ((int)((struct ixgbe_cb *)(& skb->cb))->page_released != 0) {
        #line 5303 
        ;
        #line 5303 
        ;
        #line 5303 
        dma_unmap_page_attrs(rx_ring->dev,((struct ixgbe_cb *)(& skb->cb))->dma,4096UL << ixgbe_rx_pg_order(rx_ring),(enum dma_data_direction)DMA_FROM_DEVICE,34UL);
      }
      #line 5308 
      consume_skb(skb);
    }
    #line 5314 
    ;
    #line 5314 
    ;
    #line 5314 
    ;
    #line 5314 
    dma_sync_single_range_for_cpu(rx_ring->dev,rx_buffer->dma,(unsigned long)rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page_offset,(unsigned long)ixgbe_rx_bufsz(rx_ring),(enum dma_data_direction)DMA_FROM_DEVICE);
    #line 5321 
    ;
    #line 5321 
    ;
    #line 5321 
    dma_unmap_page_attrs(rx_ring->dev,rx_buffer->dma,4096UL << ixgbe_rx_pg_order(rx_ring),(enum dma_data_direction)DMA_FROM_DEVICE,34UL);
    #line 5325 
    __page_frag_cache_drain(rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page,(unsigned int)rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.pagecnt_bias);
    #line 5328 
    i = (u16)((int)i + 1);
    #line 5329 
    rx_buffer ++;
    #line 5330 
    if ((int)rx_ring->count == (int)i) {
      #line 5331 
      i = (unsigned short)0U;
      #line 5332 
      rx_buffer = rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info;
    }
  }
  #line 5336 
  skip_free: 
             #line 5336 
  ;
  #line 5337 
  rx_ring->__anonCompField_ixgbe_ring_223.next_to_alloc = (unsigned short)0U;
  #line 5338 
  rx_ring->next_to_clean = (unsigned short)0U;
  #line 5339 
  rx_ring->next_to_use = (unsigned short)0U;
  #line 5340 
  return;
}

#line 5342  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_fwd_ring_up(struct ixgbe_adapter *adapter, struct ixgbe_fwd_adapter *accel)
{
  #line 5348 
  int i;
  #line 5348 
  int baseq;
  #line 5348 
  int err;
  #line 5345 
  u16 rss_i = adapter->ring_feature[2].indices;
  #line 5346 
  int num_tc = netdev_get_num_tc(adapter->netdev);
  #line 5347 
  struct net_device *vdev = accel->netdev;
  #line 5350 
  baseq = accel->pool * adapter->num_rx_queues_per_pool;
  {
    #line 5351 
    bool branch;
    #line 5351 
    struct _ddebug __UNIQUE_ID_ddebug587 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_fwd_ring_up", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c", .format = (char *)"pool %i:%i queues %i:%i\n", .lineno = (unsigned int)5351U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 5351 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug587.key.dd_key_false.key,(_Bool)0);
    #line 5351 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 5351 
                                                __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug587,vdev,(char *)"pool %i:%i queues %i:%i\n",accel->pool,adapter->num_rx_pools,baseq,adapter->num_rx_queues_per_pool + baseq);
  }
  #line 5355 
  accel->rx_base_queue = (unsigned int)baseq;
  #line 5356 
  accel->tx_base_queue = (unsigned int)baseq;
  #line 5359 
  i = 0;
  #line 5359 
  while (i < num_tc) {
    #line 5360 
    netdev_bind_sb_channel_queue(adapter->netdev,vdev,(unsigned char)((int)((unsigned char)i)),(unsigned short)((int)rss_i),(unsigned short)((int)((unsigned short)i) * (int)rss_i + (int)((unsigned short)baseq)));
    #line 5359 
    i ++;
  }
  #line 5363 
  i = 0;
  #line 5363 
  while (adapter->num_rx_queues_per_pool > i) {
    #line 5364 
    (adapter->rx_ring[baseq + i])->netdev = vdev;
    #line 5363 
    i ++;
  }
  #line 5365 
  ldv_inline_asm();
  #line 5374 
  err = ixgbe_add_mac_filter(adapter,vdev->dev_addr,(unsigned short)((int)((unsigned short)accel->pool) + (int)adapter->ring_feature[1].offset));
  #line 5376 
  if (err >= 0) 
                #line 5377 
                return 0;
  #line 5380 
  macvlan_release_l2fw_offload(vdev);
  #line 5382 
  i = 0;
  #line 5382 
  while (adapter->num_rx_queues_per_pool > i) {
    #line 5383 
    (adapter->rx_ring[baseq + i])->netdev = (struct net_device *)0;
    #line 5382 
    i ++;
  }
  #line 5385 
  netdev_err(vdev,(char *)"L2FW offload disabled due to L2 filter error\n");
  #line 5388 
  netdev_unbind_sb_channel(adapter->netdev,vdev);
  #line 5389 
  netdev_set_sb_channel(vdev,(unsigned short)0);
  #line 5391 
  cif_clear_bit((long)accel->pool,(unsigned long *)(& adapter->fwd_bitmask));
  #line 5392 
  kfree((void *)accel);
  #line 5394 
  return err;
}

#line 5397  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_macvlan_up(struct net_device *vdev, void *data)
{
  #line 5400 
  struct ixgbe_fwd_adapter *accel;
  #line 5399 
  struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
  #line 5402 
  if (! netif_is_macvlan(vdev)) 
                                #line 5403 
                                return 0;
  #line 5405 
  accel = (struct ixgbe_fwd_adapter *)macvlan_accel_priv(vdev);
  #line 5406 
  if (accel == (struct ixgbe_fwd_adapter *)0) 
                                              #line 5407 
                                              return 0;
  #line 5409 
  ixgbe_fwd_ring_up(adapter,accel);
  #line 5411 
  return 0;
}

#line 5414  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_dfwd(struct ixgbe_adapter *adapter)
{
  #line 5416 
  netdev_walk_all_upper_dev_rcu(adapter->netdev,& ixgbe_macvlan_up,(void *)adapter);
  #line 5418 
  return;
}

#line 5420  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure(struct ixgbe_adapter *adapter)
{
  #line 5422 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 5424 
  ixgbe_configure_pb(adapter);
  #line 5426 
  ixgbe_configure_dcb(adapter);
  #line 5432 
  ixgbe_configure_virtualization(adapter);
  #line 5434 
  ixgbe_set_rx_mode(adapter->netdev);
  #line 5435 
  ixgbe_restore_vlan(adapter);
  #line 5436 
  ixgbe_ipsec_restore(adapter);
  #line 5438 
  switch ((unsigned int)hw->mac.type) {
    #line 5439 
    case (unsigned int)2: 
                          #line 5439 
    ;
    #line 5440 
    case (unsigned int)3: 
                          #line 5440 
    ;
    #line 5441 
    (*(hw->mac.ops.disable_rx_buff))(hw);
    #line 5442 
    break;
    #line 5443 
    default: 
             #line 5443 
    ;
    #line 5444 
    break;
  }
  #line 5447 
  if (((unsigned long)adapter->flags & 262144UL) != 0UL) 
                                                         #line 5448 
                                                         ixgbe_init_fdir_signature_82599(& adapter->hw,adapter->fdir_pballoc);
  else 
    #line 5450 
    if (((unsigned long)adapter->flags & 524288UL) != 0UL) {
      #line 5451 
      ixgbe_init_fdir_perfect_82599(& adapter->hw,adapter->fdir_pballoc);
      #line 5453 
      ixgbe_fdir_filter_restore(adapter);
    }
  #line 5456 
  switch ((unsigned int)hw->mac.type) {
    #line 5457 
    case (unsigned int)2: 
                          #line 5457 
    ;
    #line 5458 
    case (unsigned int)3: 
                          #line 5458 
    ;
    #line 5459 
    (*(hw->mac.ops.enable_rx_buff))(hw);
    #line 5460 
    break;
    #line 5461 
    default: 
             #line 5461 
    ;
    #line 5462 
    break;
  }
  #line 5467 
  if (((unsigned long)adapter->flags & 512UL) != 0UL) 
                                                      #line 5468 
                                                      ixgbe_setup_dca(adapter);
  #line 5473 
  ixgbe_configure_fcoe(adapter);
  #line 5476 
  ixgbe_configure_tx(adapter);
  #line 5477 
  ixgbe_configure_rx(adapter);
  #line 5478 
  ixgbe_configure_dfwd(adapter);
  #line 5479 
  return;
}

#line 5485  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_sfp_link_config(struct ixgbe_adapter *adapter)
{
  #line 5493 
  if (adapter->hw.mac.type == (unsigned int)ixgbe_mac_82598EB) 
                                                               #line 5494 
                                                               adapter->flags2 |= 16U;
  #line 5496 
  adapter->flags2 |= 32U;
  #line 5497 
  adapter->sfp_poll_time = 0UL;
  #line 5498 
  return;
}

#line 5506  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_non_sfp_link_config(struct ixgbe_hw *hw)
{
  #line 5508 
  u32 speed;
  #line 5509 
  bool autoneg;
  #line 5509 
  bool link_up = (_Bool)0;
  #line 5510 
  int ret = -8;
  #line 5512 
  if (hw->mac.ops.check_link != (s32 (*)(struct ixgbe_hw *, ixgbe_link_speed *, bool *, bool ))0) 
    #line 5513 
    ret = (*(hw->mac.ops.check_link))(hw,& speed,& link_up,(_Bool)0);
  #line 5515 
  if (ret != 0) 
                #line 5516 
                return ret;
  #line 5518 
  speed = hw->phy.autoneg_advertised;
  #line 5519 
  if (speed == 0U && hw->mac.ops.get_link_capabilities != (s32 (*)(struct ixgbe_hw *, ixgbe_link_speed *, bool *))0) 
    #line 5520 
    ret = (*(hw->mac.ops.get_link_capabilities))(hw,& speed,& autoneg);
  #line 5522 
  if (ret != 0) 
                #line 5523 
                return ret;
  #line 5525 
  if (hw->mac.ops.setup_link != (s32 (*)(struct ixgbe_hw *, ixgbe_link_speed , bool ))0) 
    #line 5526 
    ret = (*(hw->mac.ops.setup_link))(hw,speed,(_Bool)((bool)((int)link_up) != 0));
  #line 5528 
  return ret;
}

#line 5531  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_setup_gpie(struct ixgbe_adapter *adapter)
{
  #line 5533 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 5534 
  u32 gpie = 0U;
  #line 5536 
  if (((unsigned long)adapter->flags & 8UL) != 0UL) {
    #line 5537 
    gpie = 2147483696U;
    #line 5539 
    gpie |= 1073741824U;
    #line 5544 
    switch ((unsigned int)hw->mac.type) {
      #line 5545 
      case (unsigned int)1: 
                            #line 5545 
      ;
      #line 5546 
      ixgbe_write_reg_1(hw,2192U,65535U);
      #line 5547 
      break;
      #line 5548 
      case (unsigned int)2: 
                            #line 5548 
      ;
      #line 5549 
      case (unsigned int)3: 
                            #line 5549 
      ;
      #line 5550 
      case (unsigned int)4: 
                            #line 5550 
      ;
      #line 5551 
      case (unsigned int)5: 
                            #line 5551 
      ;
      #line 5552 
      case (unsigned int)6: 
                            #line 5552 
      ;
      #line 5553 
      default: 
               #line 5553 
      ;
      #line 5554 
      ixgbe_write_reg_1(hw,2768U,4294967295U);
      #line 5555 
      ixgbe_write_reg_1(hw,2772U,4294967295U);
      #line 5556 
      break;
    }
  }
  else 
       #line 5561 
       ixgbe_write_reg_1(hw,2192U,65535U);
  #line 5567 
  if (((unsigned long)adapter->flags & 8388608UL) != 0UL) {
    #line 5568 
    gpie &= 4294918143U;
    #line 5570 
    switch ((int)adapter->ring_feature[1].mask) {
      #line 5571 
      case 120: 
                #line 5571 
      ;
      #line 5572 
      gpie |= 16384U;
      #line 5573 
      break;
      #line 5574 
      case 124: 
                #line 5574 
      ;
      #line 5575 
      gpie |= 32768U;
      #line 5576 
      break;
      #line 5577 
      default: 
               #line 5577 
      ;
      #line 5578 
      gpie |= 49152U;
      #line 5579 
      break;
    }
  }
  #line 5584 
  if (((unsigned long)adapter->flags2 & 4UL) != 0UL) 
    #line 5585 
    switch ((unsigned int)adapter->hw.mac.type) {
      #line 5586 
      case (unsigned int)2: 
                            #line 5586 
      ;
      #line 5587 
      gpie |= 1U;
      #line 5588 
      break;
      #line 5589 
      default: 
               #line 5589 
      ;
      #line 5590 
      break;
    }
  #line 5595 
  if (((unsigned long)adapter->flags & 32768UL) != 0UL) 
                                                        #line 5596 
                                                        gpie = *(hw->mvals + 8U) | gpie;
  #line 5598 
  switch ((unsigned int)hw->mac.type) {
    #line 5599 
    case (unsigned int)2: 
                          #line 5599 
    ;
    #line 5600 
    gpie |= 6U;
    #line 5601 
    break;
    #line 5602 
    case (unsigned int)5: 
                          #line 5602 
    ;
    #line 5603 
    case (unsigned int)6: 
                          #line 5603 
    ;
    #line 5604 
    gpie |= 2U;
    #line 5605 
    break;
    #line 5606 
    default: 
             #line 5606 
    ;
    #line 5607 
    break;
  }
  #line 5610 
  ixgbe_write_reg_1(hw,2200U,gpie);
  #line 5611 
  return;
}

#line 5613  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_up_complete(struct ixgbe_adapter *adapter)
{
  #line 5616 
  int err;
  #line 5617 
  u32 ctrl_ext;
  #line 5615 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 5619 
  ixgbe_get_hw_control(adapter);
  #line 5620 
  ixgbe_setup_gpie(adapter);
  #line 5622 
  if (((unsigned long)adapter->flags & 8UL) != 0UL) 
                                                    #line 5623 
                                                    ixgbe_configure_msix(adapter); else 
                                                                    #line 5625 
                                                                    ixgbe_configure_msi_and_legacy(adapter);
  #line 5628 
  if (hw->mac.ops.enable_tx_laser != (void (*)(struct ixgbe_hw *))0) 
    #line 5629 
    (*(hw->mac.ops.enable_tx_laser))(hw);
  #line 5631 
  if (hw->phy.ops.set_phy_power != (s32 (*)(struct ixgbe_hw *, bool ))0) 
    #line 5632 
    (*(hw->phy.ops.set_phy_power))(hw,(_Bool)1);
  #line 5635 
  cif_clear_bit(2L,& adapter->state);
  #line 5636 
  ixgbe_napi_enable_all(adapter);
  #line 5638 
  if ((int)ixgbe_is_sfp(hw) != 0) 
                                  #line 5639 
                                  ixgbe_sfp_link_config(adapter);
  else {
    #line 5641 
    err = ixgbe_non_sfp_link_config(hw);
    #line 5642 
    if (err != 0) 
      #line 5643 
      if (((int)adapter->msg_enable & 2) != 0) 
                                               #line 5643 
                                               netdev_err(adapter->netdev,(char *)"link_config FAILED %d\n",err);
  }
  #line 5647 
  ixgbe_read_reg(hw,2048U);
  #line 5648 
  ixgbe_irq_enable(adapter,(_Bool)1,(_Bool)1);
  #line 5654 
  if (((unsigned long)adapter->flags & 32768UL) != 0UL) {
    #line 5655 
    u32 esdp = ixgbe_read_reg(hw,32U);
    #line 5656 
    if ((esdp & 2U) != 0U) 
      #line 5657 
      if (((int)adapter->msg_enable & 1) != 0) 
                                               #line 5657 
                                               netdev_crit(adapter->netdev,(char *)"Fan has stopped, replace the adapter\n");
  }
  #line 5662 
  adapter->flags |= 65536U;
  #line 5663 
  adapter->link_check_timeout = jiffies;
  #line 5664 
  cif_mod_timer(& adapter->service_timer,jiffies);
  #line 5667 
  ctrl_ext = ixgbe_read_reg(hw,24U);
  #line 5668 
  ctrl_ext |= 16384U;
  #line 5669 
  ixgbe_write_reg_1(hw,24U,ctrl_ext);
  #line 5670 
  return;
}

#line 5672  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_reinit_locked(struct ixgbe_adapter *adapter)
{
  {
    #line 5674 
    int __ret_warn_on = ((unsigned long)preempt_count() & 2096896UL) != 0UL;
    #line 5674 
    if ((long)(__ret_warn_on != 0) != 0L) {
      #line 5675 
      ldv_inline_asm();
      #line 5676 
      ldv_inline_asm();
    }
    #line 5674 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  #line 5676 
  netif_trans_update(adapter->netdev);
  #line 5678 
  while (1) {
    #line 5678 
    if (! ((int)test_and_set_bit(1L,& adapter->state) != 0)) 
                                                             #line 5678 
                                                             break;
    #line 5679 
    usleep_range(1000UL,2000UL);
  }
  #line 5680 
  if (adapter->hw.phy.type == (unsigned int)ixgbe_phy_fw) 
                                                          #line 5681 
                                                          ixgbe_watchdog_link_is_down(adapter);
  #line 5682 
  ixgbe_down(adapter);
  #line 5689 
  if (((unsigned long)adapter->flags & 8388608UL) != 0UL) 
                                                          #line 5690 
                                                          msleep(2000U);
  #line 5691 
  ixgbe_up(adapter);
  #line 5692 
  cif_clear_bit(1L,& adapter->state);
  #line 5693 
  return;
}

#line 5695  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_up(struct ixgbe_adapter *adapter)
{
  #line 5698 
  ixgbe_configure(adapter);
  #line 5700 
  ixgbe_up_complete(adapter);
  #line 5701 
  return;
}

#line 5703  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static unsigned long ixgbe_get_completion_timeout(struct ixgbe_adapter *adapter)
{
  #line 5705 
  u16 devctl2;
  #line 5707 
  pcie_capability_read_word(adapter->pdev,40,& devctl2);
  #line 5709 
  switch ((int)devctl2 & 15) {
    #line 5710 
    case 14: 
             #line 5710 
    ;
    #line 5711 
    case 13: 
             #line 5711 
    ;
    #line 5716 
    case 10: 
             #line 5716 
    ;
    #line 5717 
    return 2000000UL;
    #line 5718 
    case 9: 
            #line 5718 
    ;
    #line 5719 
    return 520000UL;
    #line 5720 
    case 6: 
            #line 5720 
    ;
    #line 5721 
    return 130000UL;
    #line 5722 
    case 5: 
            #line 5722 
    ;
    #line 5723 
    return 32000UL;
    #line 5724 
    case 2: 
            #line 5724 
    ;
    #line 5725 
    return 2000UL;
    #line 5726 
    case 1: 
            #line 5726 
    ;
    #line 5727 
    return 100UL;
    #line 5728 
    case 0: 
            #line 5728 
    ;
    #line 5729 
    return 32000UL;
    #line 5730 
    default: 
             #line 5730 
    ;
    #line 5731 
    break;
  }
  #line 5737 
  return 32000UL;
}

#line 5740  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_disable_rx(struct ixgbe_adapter *adapter)
{
  #line 5742 
  unsigned long wait_delay;
  #line 5742 
  unsigned long delay_interval;
  #line 5744 
  int i;
  #line 5744 
  int wait_loop;
  #line 5745 
  u32 rxdctl;
  #line 5743 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 5748 
  (*(hw->mac.ops.disable_rx))(hw);
  #line 5750 
  if ((int)ixgbe_removed((void *)hw->hw_addr) != 0) 
                                                    #line 5751 
                                                    return;
  #line 5754 
  i = 0;
  #line 5754 
  while (adapter->num_rx_queues > i) {
    {
      #line 5758 
      int tmp_0;
      #line 5763 
      int tmp_1;
      #line 5755 
      struct ixgbe_ring *ring = adapter->rx_ring[i];
      #line 5756 
      u8 reg_idx = ring->reg_idx;
      #line 5758 
      if ((unsigned int)reg_idx <= 63U) 
                                        #line 5758 
                                        tmp_0 = (int)reg_idx * 64 + 4136; else 
                                                                    #line 5758 
                                                                    tmp_0 = ((int)reg_idx + -64) * 64 + 53288;
      #line 5758 
      ;
      #line 5758 
      rxdctl = ixgbe_read_reg(hw,(unsigned int)tmp_0);
      #line 5759 
      rxdctl &= 4261412863U;
      #line 5760 
      rxdctl |= 67108864U;
      #line 5763 
      ;
      #line 5763 
      if ((unsigned int)reg_idx <= 63U) 
                                        #line 5763 
                                        tmp_1 = (int)reg_idx * 64 + 4136; else 
                                                                    #line 5763 
                                                                    tmp_1 = ((int)reg_idx + -64) * 64 + 53288;
      #line 5763 
      ;
      #line 5763 
      ixgbe_write_reg_1(hw,(unsigned int)tmp_1,rxdctl);
    }
    #line 5754 
    i ++;
  }
  #line 5767 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) {
    #line 5767 
    if ((ixgbe_read_reg(hw,17060U) & 1073741824U) == 0U) 
                                                         #line 5769 
                                                         return;
  }
  #line 5782 
  delay_interval = ixgbe_get_completion_timeout(adapter) / 100UL;
  #line 5784 
  wait_loop = 10;
  #line 5785 
  wait_delay = delay_interval;
  #line 5787 
  while (1) {
    #line 5787 
    int tmp_6;
    #line 5787 
    tmp_6 = wait_loop;
    #line 5787 
    wait_loop --;
    #line 5787 
    ;
    #line 5787 
    if (! (tmp_6 != 0)) 
                        #line 5787 
                        break;
    #line 5788 
    usleep_range(wait_delay,wait_delay + 10UL);
    #line 5789 
    wait_delay = delay_interval * 2UL + wait_delay;
    #line 5790 
    rxdctl = 0U;
    #line 5797 
    i = 0;
    #line 5797 
    while (adapter->num_rx_queues > i) {
      {
        #line 5801 
        int tmp_4;
        #line 5798 
        struct ixgbe_ring *ring_0 = adapter->rx_ring[i];
        #line 5799 
        u8 reg_idx_0 = ring_0->reg_idx;
        #line 5801 
        if ((unsigned int)reg_idx_0 <= 63U) 
                                            #line 5801 
                                            tmp_4 = (int)reg_idx_0 * 64 + 4136; else 
                                                                    #line 5801 
                                                                    tmp_4 = ((int)reg_idx_0 + -64) * 64 + 53288;
        #line 5801 
        ;
        #line 5801 
        rxdctl = ixgbe_read_reg(hw,(unsigned int)tmp_4) | rxdctl;
      }
      #line 5797 
      i ++;
    }
    #line 5804 
    if ((rxdctl & 33554432U) == 0U) 
                                    #line 5805 
                                    return;
  }
  #line 5808 
  if (((int)adapter->msg_enable & 1) != 0) 
                                           #line 5808 
                                           netdev_err(adapter->netdev,(char *)"RXDCTL.ENABLE for one or more queues not cleared within the polling period\n");
  #line 5809 
  return;
}

#line 5812  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_disable_tx(struct ixgbe_adapter *adapter)
{
  #line 5814 
  unsigned long wait_delay;
  #line 5814 
  unsigned long delay_interval;
  #line 5816 
  int i;
  #line 5816 
  int wait_loop;
  #line 5817 
  u32 txdctl;
  #line 5815 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 5819 
  if ((int)ixgbe_removed((void *)hw->hw_addr) != 0) 
                                                    #line 5820 
                                                    return;
  #line 5823 
  i = 0;
  #line 5823 
  while (adapter->num_tx_queues > i) {
    {
      #line 5824 
      struct ixgbe_ring *ring = adapter->tx_ring[i];
      #line 5825 
      u8 reg_idx = ring->reg_idx;
      #line 5827 
      ixgbe_write_reg_1(hw,(unsigned int)((int)reg_idx * 64 + 24616),67108864U);
    }
    #line 5823 
    i ++;
  }
  #line 5831 
  i = 0;
  #line 5831 
  while (adapter->num_xdp_queues > i) {
    {
      #line 5832 
      struct ixgbe_ring *ring_0 = adapter->xdp_ring[i];
      #line 5833 
      u8 reg_idx_0 = ring_0->reg_idx;
      #line 5835 
      ixgbe_write_reg_1(hw,(unsigned int)((int)reg_idx_0 * 64 + 24616),67108864U);
    }
    #line 5831 
    i ++;
  }
  #line 5843 
  if ((ixgbe_read_reg(hw,17060U) & 1073741824U) == 0U) 
                                                       #line 5844 
                                                       goto dma_engine_disable;
  #line 5857 
  delay_interval = ixgbe_get_completion_timeout(adapter) / 100UL;
  #line 5859 
  wait_loop = 10;
  #line 5860 
  wait_delay = delay_interval;
  #line 5862 
  while (1) {
    #line 5862 
    int tmp_4;
    #line 5862 
    tmp_4 = wait_loop;
    #line 5862 
    wait_loop --;
    #line 5862 
    ;
    #line 5862 
    if (! (tmp_4 != 0)) 
                        #line 5862 
                        break;
    #line 5863 
    usleep_range(wait_delay,wait_delay + 10UL);
    #line 5864 
    wait_delay = delay_interval * 2UL + wait_delay;
    #line 5865 
    txdctl = 0U;
    #line 5872 
    i = 0;
    #line 5872 
    while (adapter->num_tx_queues > i) {
      {
        #line 5873 
        struct ixgbe_ring *ring_1 = adapter->tx_ring[i];
        #line 5874 
        u8 reg_idx_1 = ring_1->reg_idx;
        #line 5876 
        txdctl = ixgbe_read_reg(hw,(unsigned int)((int)reg_idx_1 * 64 + 24616)) | txdctl;
      }
      #line 5872 
      i ++;
    }
    #line 5878 
    i = 0;
    #line 5878 
    while (adapter->num_xdp_queues > i) {
      {
        #line 5879 
        struct ixgbe_ring *ring_2 = adapter->xdp_ring[i];
        #line 5880 
        u8 reg_idx_2 = ring_2->reg_idx;
        #line 5882 
        txdctl = ixgbe_read_reg(hw,(unsigned int)((int)reg_idx_2 * 64 + 24616)) | txdctl;
      }
      #line 5878 
      i ++;
    }
    #line 5885 
    if ((txdctl & 33554432U) == 0U) 
                                    #line 5886 
                                    goto dma_engine_disable;
  }
  #line 5889 
  if (((int)adapter->msg_enable & 1) != 0) 
                                           #line 5889 
                                           netdev_err(adapter->netdev,(char *)"TXDCTL.ENABLE for one or more queues not cleared within the polling period\n");
  #line 5892 
  dma_engine_disable: 
                      #line 5892 
  ;
  #line 5894 
  switch ((unsigned int)hw->mac.type) {
    #line 5895 
    case (unsigned int)2: 
                          #line 5895 
    ;
    #line 5896 
    case (unsigned int)3: 
                          #line 5896 
    ;
    #line 5897 
    case (unsigned int)4: 
                          #line 5897 
    ;
    #line 5898 
    case (unsigned int)5: 
                          #line 5898 
    ;
    #line 5899 
    case (unsigned int)6: 
                          #line 5899 
    ;
    #line 5900 
    ;
    #line 5900 
    ixgbe_write_reg_1(hw,19072U,ixgbe_read_reg(hw,19072U) & 4294967294U);
    #line 5904 
    default: 
             #line 5904 
    ;
    #line 5905 
    break;
  }
  #line 5907 
  return;
}

#line 5909  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_reset(struct ixgbe_adapter *adapter)
{
  #line 5913 
  int err;
  #line 5911 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 5912 
  struct net_device *netdev = adapter->netdev;
  #line 5915 
  if ((int)ixgbe_removed((void *)hw->hw_addr) != 0) 
                                                    #line 5916 
                                                    return;
  #line 5918 
  while (1) {
    #line 5918 
    if (! ((int)test_and_set_bit(7L,& adapter->state) != 0)) 
                                                             #line 5918 
                                                             break;
    #line 5919 
    usleep_range(1000UL,2000UL);
  }
  #line 5922 
  adapter->flags2 &= 4294967247U;
  #line 5924 
  adapter->flags &= 4294836223U;
  #line 5926 
  err = (*(hw->mac.ops.init_hw))(hw);
  #line 5927 
  switch (err) {
    #line 5928 
    case 0: 
            #line 5928 
    ;
    #line 5929 
    case -20: 
              #line 5929 
    ;
    #line 5930 
    case -19: 
              #line 5930 
    ;
    #line 5931 
    break;
    #line 5932 
    case -12: 
              #line 5932 
    ;
    #line 5933 
    _dev_err(& (adapter->pdev)->dev,(char *)"master disable timed out\n");
    #line 5934 
    break;
    #line 5935 
    case -24: 
              #line 5935 
    ;
    #line 5937 
    _dev_warn(& (adapter->pdev)->dev,(char *)"This device is a pre-production adapter/LOM. ");
    #line 5943 
    break;
    #line 5944 
    default: 
             #line 5944 
    ;
    #line 5945 
    _dev_err(& (adapter->pdev)->dev,(char *)"Hardware Error: %d\n",err);
  }
  #line 5948 
  cif_clear_bit(7L,& adapter->state);
  #line 5951 
  ixgbe_flush_sw_mac_table(adapter);
  #line 5952 
  __dev_uc_unsync(netdev,(int (*)(struct net_device *, unsigned char *))0);
  #line 5955 
  ixgbe_mac_set_default_filter(adapter);
  #line 5958 
  if ((unsigned int)hw->mac.san_mac_rar_index != 0U) 
                                                     #line 5959 
                                                     (*(hw->mac.ops.set_vmdq_san_mac))(hw,(unsigned int)adapter->ring_feature[1].offset);
  #line 5961 
  if ((int)test_bit(8L,& adapter->state) != 0) 
                                               #line 5962 
                                               ixgbe_ptp_reset(adapter);
  #line 5964 
  if (hw->phy.ops.set_phy_power != (s32 (*)(struct ixgbe_hw *, bool ))0) {
    #line 5965 
    if (netif_running(adapter->netdev)) 
                                        #line 5968 
                                        (*(hw->phy.ops.set_phy_power))(hw,(_Bool)1);
    else 
      #line 5965 
      if (adapter->wol == 0U) 
                              #line 5966 
                              (*(hw->phy.ops.set_phy_power))(hw,(_Bool)0); else 
                                                                    #line 5968 
                                                                    (*(hw->phy.ops.set_phy_power))(hw,(_Bool)1);
  }
  #line 5969 
  return;
}

#line 5976  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_clean_tx_ring(struct ixgbe_ring *tx_ring)
{
  #line 5978 
  u16 i = tx_ring->next_to_clean;
  #line 5979 
  struct ixgbe_tx_buffer *tx_buffer = tx_ring->__anonCompField_ixgbe_ring_221.tx_buffer_info + (unsigned long)i;
  #line 5981 
  if (tx_ring->xsk_umem != (struct xdp_umem *)0) {
    #line 5982 
    ixgbe_xsk_clean_tx_ring(tx_ring);
    #line 5983 
    goto out;
  }
  #line 5986 
  while ((int)tx_ring->next_to_use != (int)i) {
    #line 5987 
    union ixgbe_adv_tx_desc *eop_desc;
    #line 5987 
    union ixgbe_adv_tx_desc *tx_desc;
    #line 5990 
    if ((int)test_bit(9L,& tx_ring->state) != 0) 
                                                 #line 5991 
                                                 xdp_return_frame(tx_buffer->__anonCompField_ixgbe_tx_buffer_217.xdpf); else 
                                                                    #line 5993 
                                                                    dev_kfree_skb_any(tx_buffer->__anonCompField_ixgbe_tx_buffer_217.skb);
    #line 5996 
    dma_unmap_single_attrs(tx_ring->dev,tx_buffer->dma,(unsigned long)tx_buffer->len,(enum dma_data_direction)DMA_TO_DEVICE,0UL);
    #line 6002 
    eop_desc = tx_buffer->next_to_watch;
    #line 6003 
    tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc + (unsigned long)i;
    #line 6006 
    while (tx_desc != eop_desc) {
      #line 6007 
      tx_buffer ++;
      #line 6008 
      tx_desc ++;
      #line 6009 
      i = (u16)((int)i + 1);
      #line 6010 
      if ((long)((int)tx_ring->count == (int)i) != 0L) {
        #line 6011 
        i = (unsigned short)0U;
        #line 6012 
        tx_buffer = tx_ring->__anonCompField_ixgbe_ring_221.tx_buffer_info;
        #line 6013 
        tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc;
      }
      #line 6017 
      if (tx_buffer->len != 0U) 
                                #line 6018 
                                dma_unmap_page_attrs(tx_ring->dev,tx_buffer->dma,(unsigned long)tx_buffer->len,(enum dma_data_direction)DMA_TO_DEVICE,0UL);
    }
    #line 6025 
    tx_buffer ++;
    #line 6026 
    i = (u16)((int)i + 1);
    #line 6027 
    if ((long)((int)tx_ring->count == (int)i) != 0L) {
      #line 6028 
      i = (unsigned short)0U;
      #line 6029 
      tx_buffer = tx_ring->__anonCompField_ixgbe_ring_221.tx_buffer_info;
    }
  }
  #line 6034 
  if (! test_bit(9L,& tx_ring->state)) {
    #line 6035 
    netdev_tx_reset_queue(txring_txq(tx_ring));
  }
  #line 6037 
  out: 
       #line 6037 
  ;
  #line 6039 
  tx_ring->next_to_use = (unsigned short)0U;
  #line 6040 
  tx_ring->next_to_clean = (unsigned short)0U;
  #line 6041 
  return;
}

#line 6047  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_clean_all_rx_rings(struct ixgbe_adapter *adapter)
{
  #line 6049 
  int i;
  #line 6051 
  i = 0;
  #line 6051 
  while (adapter->num_rx_queues > i) {
    #line 6052 
    ixgbe_clean_rx_ring(adapter->rx_ring[i]);
    #line 6051 
    i ++;
  }
  #line 6053 
  return;
}

#line 6059  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_clean_all_tx_rings(struct ixgbe_adapter *adapter)
{
  #line 6061 
  int i;
  #line 6063 
  i = 0;
  #line 6063 
  while (adapter->num_tx_queues > i) {
    #line 6064 
    ixgbe_clean_tx_ring(adapter->tx_ring[i]);
    #line 6063 
    i ++;
  }
  #line 6065 
  i = 0;
  #line 6065 
  while (adapter->num_xdp_queues > i) {
    #line 6066 
    ixgbe_clean_tx_ring(adapter->xdp_ring[i]);
    #line 6065 
    i ++;
  }
  #line 6067 
  return;
}

#line 6069  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_fdir_filter_exit(struct ixgbe_adapter *adapter)
{
  #line 6076 
  struct ixgbe_fdir_filter *tmp_0;
  #line 6076 
  void *__mptr;
  #line 6071 
  struct hlist_node *node2;
  #line 6072 
  struct ixgbe_fdir_filter *filter;
  #line 6074 
  cif_spin_lock_fdir_perfect_lock_of_ixgbe_adapter(& adapter->fdir_perfect_lock);
  {
    #line 6076 
    struct hlist_node *____ptr = adapter->fdir_filter_list.first;
    #line 6076 
    if (____ptr != (struct hlist_node *)0) {
      #line 6076 
      __mptr = (void *)____ptr;
      #line 6076 
      tmp_0 = ((struct ixgbe_fdir_filter *)__mptr);
    }
    else 
         #line 6076 
         tmp_0 = (struct ixgbe_fdir_filter *)0;
    }
  #line 6076 
  filter = tmp_0;
  #line 6076 
  while (1) {
    #line 6076 
    void *__mptr_0;
    #line 6076 
    struct ixgbe_fdir_filter *tmp_3;
    #line 6076 
    if (filter != (struct ixgbe_fdir_filter *)0) {
      #line 6076 
      node2 = filter->fdir_node.next;
      #line 6076 
      if (! (1 != 0)) 
                      #line 6076 
                      break;
    }
    else 
         #line 6076 
         break;
    #line 6078 
    hlist_del(& filter->fdir_node);
    #line 6079 
    kfree((void *)filter);
    {
      #line 6076 
      struct hlist_node *____ptr_0 = node2;
      #line 6076 
      if (____ptr_0 != (struct hlist_node *)0) {
        #line 6076 
        __mptr_0 = (void *)____ptr_0;
        #line 6076 
        tmp_3 = ((struct ixgbe_fdir_filter *)__mptr_0);
      }
      else 
           #line 6076 
           tmp_3 = (struct ixgbe_fdir_filter *)0;
      }
    #line 6076 
    filter = tmp_3;
  }
  #line 6081 
  adapter->fdir_filter_count = 0;
  #line 6083 
  cif_spin_unlock_fdir_perfect_lock_of_ixgbe_adapter(& adapter->fdir_perfect_lock);
  #line 6084 
  return;
}

#line 6086  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_down(struct ixgbe_adapter *adapter)
{
  #line 6090 
  int i;
  #line 6088 
  struct net_device *netdev = adapter->netdev;
  #line 6089 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 6093 
  if ((int)test_and_set_bit(2L,& adapter->state) != 0) 
                                                       #line 6094 
                                                       return;
  #line 6097 
  netif_tx_stop_all_queues(netdev);
  #line 6100 
  netif_carrier_off(netdev);
  #line 6101 
  netif_tx_disable(netdev);
  #line 6104 
  ixgbe_disable_rx(adapter);
  #line 6107 
  if (adapter->xdp_ring[0] != (struct ixgbe_ring *)0) 
                                                      #line 6108 
                                                      synchronize_rcu();
  #line 6110 
  ixgbe_irq_disable(adapter);
  #line 6112 
  ixgbe_napi_disable_all(adapter);
  #line 6114 
  cif_clear_bit(10L,& adapter->state);
  #line 6115 
  adapter->flags2 &= 4294967167U;
  #line 6116 
  adapter->flags &= 4294901759U;
  #line 6118 
  cif_del_timer_sync(& adapter->service_timer);
  #line 6120 
  if (adapter->num_vfs != 0U) {
    #line 6122 
    ixgbe_write_reg_1(& adapter->hw,2196U,0U);
    #line 6125 
    i = 0;
    #line 6125 
    while (adapter->num_vfs > (unsigned int)i) {
      #line 6126 
      (adapter->vfinfo + (unsigned long)i)->clear_to_send = (_Bool)0;
      #line 6125 
      i ++;
    }
    #line 6129 
    ixgbe_ping_all_vfs(adapter);
    #line 6132 
    ixgbe_disable_tx_rx(adapter);
  }
  #line 6136 
  ixgbe_disable_tx(adapter);
  #line 6138 
  if (pci_channel_offline(adapter->pdev) == 0) 
                                               #line 6139 
                                               ixgbe_reset(adapter);
  #line 6142 
  if (hw->mac.ops.disable_tx_laser != (void (*)(struct ixgbe_hw *))0) 
    #line 6143 
    (*(hw->mac.ops.disable_tx_laser))(hw);
  #line 6145 
  ixgbe_clean_all_tx_rings(adapter);
  #line 6146 
  ixgbe_clean_all_rx_rings(adapter);
  #line 6147 
  return;
}

#line 6153  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_set_eee_capable(struct ixgbe_adapter *adapter)
{
  #line 6155 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 6157 
  switch ((int)hw->device_id) {
    #line 6158 
    case 5604: 
               #line 6158 
    ;
    #line 6159 
    case 5605: 
               #line 6159 
    ;
    #line 6160 
    if (hw->phy.eee_speeds_supported == 0U) 
                                            #line 6161 
                                            break;
    #line 6162 
    adapter->flags2 |= 16384U;
    #line 6163 
    if (hw->phy.eee_speeds_advertised == 0U) 
                                             #line 6164 
                                             break;
    #line 6165 
    adapter->flags2 |= 32768U;
    #line 6166 
    break;
    #line 6167 
    default: 
             #line 6167 
    ;
    #line 6168 
    adapter->flags2 &= 4294950911U;
    #line 6169 
    adapter->flags2 &= 4294934527U;
    #line 6170 
    break;
  }
  #line 6172 
  return;
}

#line 6178  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_tx_timeout(struct net_device *netdev)
{
  #line 6180 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 6183 
  ixgbe_tx_timeout_reset(adapter);
  #line 6184 
  return;
}

#line 6187  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_init_dcb(struct ixgbe_adapter *adapter)
{
  #line 6190 
  struct tc_configuration *tc;
  #line 6191 
  int j;
  #line 6189 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 6193 
  switch ((unsigned int)hw->mac.type) {
    #line 6194 
    case (unsigned int)1: 
                          #line 6194 
    ;
    #line 6195 
    case (unsigned int)2: 
                          #line 6195 
    ;
    #line 6196 
    adapter->dcb_cfg.num_tcs.pg_tcs = (unsigned char)8U;
    #line 6197 
    adapter->dcb_cfg.num_tcs.pfc_tcs = (unsigned char)8U;
    #line 6198 
    break;
    #line 6199 
    case (unsigned int)3: 
                          #line 6199 
    ;
    #line 6200 
    case (unsigned int)4: 
                          #line 6200 
    ;
    #line 6201 
    adapter->dcb_cfg.num_tcs.pg_tcs = (unsigned char)4U;
    #line 6202 
    adapter->dcb_cfg.num_tcs.pfc_tcs = (unsigned char)4U;
    #line 6203 
    break;
    #line 6204 
    case (unsigned int)5: 
                          #line 6204 
    ;
    #line 6205 
    case (unsigned int)6: 
                          #line 6205 
    ;
    #line 6206 
    default: 
             #line 6206 
    ;
    #line 6207 
    adapter->dcb_cfg.num_tcs.pg_tcs = (unsigned char)1U;
    #line 6208 
    adapter->dcb_cfg.num_tcs.pfc_tcs = (unsigned char)1U;
    #line 6209 
    break;
  }
  #line 6213 
  j = 0;
  #line 6213 
  while (j <= 7) {
    #line 6214 
    tc = & adapter->dcb_cfg.tc_config[j];
    #line 6215 
    tc->path[0].bwg_id = (unsigned char)0U;
    #line 6216 
    tc->path[0].bwg_percent = (unsigned char)(((unsigned int)((unsigned char)j) & 1U) + 12U);
    #line 6217 
    tc->path[1].bwg_id = (unsigned char)0U;
    #line 6218 
    tc->path[1].bwg_percent = (unsigned char)(((unsigned int)((unsigned char)j) & 1U) + 12U);
    #line 6219 
    tc->dcb_pfc = pfc_disabled;
    #line 6213 
    j ++;
  }
  #line 6223 
  tc = & adapter->dcb_cfg.tc_config[0];
  #line 6224 
  tc->path[0].up_to_tc_bitmap = (unsigned char)255U;
  #line 6225 
  tc->path[1].up_to_tc_bitmap = (unsigned char)255U;
  #line 6227 
  adapter->dcb_cfg.bw_percentage[0][0] = (unsigned char)100U;
  #line 6228 
  adapter->dcb_cfg.bw_percentage[1][0] = (unsigned char)100U;
  #line 6229 
  adapter->dcb_cfg.pfc_mode_enable = (_Bool)0;
  #line 6230 
  adapter->dcb_set_bitmap = (unsigned char)0U;
  #line 6231 
  if (((unsigned long)adapter->flags & 134217728UL) != 0UL) 
                                                            #line 6232 
                                                            adapter->dcbx_cap = (unsigned char)5U;
  #line 6233 
  memcpy((void *)(& adapter->temp_dcb_cfg),(void *)(& adapter->dcb_cfg),296UL);
  #line 6234 
  return;
}

#line 6247  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_sw_init(struct ixgbe_adapter *adapter, struct ixgbe_info *ii)
{
  #line 6268 
  int __UNIQUE_ID___x589;
  #line 6268 
  int tmp_1;
  #line 6273 
  int __UNIQUE_ID___x591;
  #line 6273 
  int tmp_4;
  #line 6252 
  unsigned int rss;
  #line 6252 
  unsigned int fdir;
  #line 6253 
  u32 fwsm;
  #line 6254 
  int i;
  #line 6250 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 6251 
  struct pci_dev *pdev = adapter->pdev;
  #line 6258 
  hw->vendor_id = pdev->vendor;
  #line 6259 
  hw->device_id = pdev->device;
  #line 6260 
  hw->revision_id = pdev->revision;
  #line 6261 
  hw->subsystem_vendor_id = pdev->subsystem_vendor;
  #line 6262 
  hw->subsystem_device_id = pdev->subsystem_device;
  #line 6265 
  (*(ii->get_invariants))(hw);
  {
    #line 6268 
    __UNIQUE_ID___x589 = (int)ixgbe_max_rss_indices(adapter);
    #line 6268 
    int __UNIQUE_ID___y590 = (int)num_online_cpus();
    #line 6268 
    if (__UNIQUE_ID___x589 < __UNIQUE_ID___y590) 
                                                 #line 6268 
                                                 tmp_1 = __UNIQUE_ID___x589; else 
                                                                    #line 6268 
                                                                    tmp_1 = __UNIQUE_ID___y590;
    }
  #line 6268 
  rss = (unsigned int)tmp_1;
  #line 6269 
  adapter->ring_feature[2].limit = (unsigned short)rss;
  #line 6270 
  adapter->flags2 |= 1U;
  #line 6271 
  adapter->max_q_vectors = 64;
  #line 6272 
  adapter->atr_sample_rate = 20U;
  {
    #line 6273 
    __UNIQUE_ID___x591 = 63;
    #line 6273 
    int __UNIQUE_ID___y592 = (int)num_online_cpus();
    #line 6273 
    if (__UNIQUE_ID___x591 < __UNIQUE_ID___y592) 
                                                 #line 6273 
                                                 tmp_4 = __UNIQUE_ID___x591; else 
                                                                    #line 6273 
                                                                    tmp_4 = __UNIQUE_ID___y592;
    }
  #line 6273 
  fdir = (unsigned int)tmp_4;
  #line 6274 
  adapter->ring_feature[3].limit = (unsigned short)fdir;
  #line 6275 
  adapter->fdir_pballoc = 1U;
  #line 6276 
  adapter->ring_feature[1].limit = (unsigned short)1U;
  #line 6278 
  adapter->flags |= 512U;
  #line 6281 
  adapter->flags |= 134217728U;
  #line 6282 
  adapter->flags &= 4294963199U;
  #line 6285 
  adapter->flags |= 1048576U;
  #line 6286 
  adapter->flags &= 4292870143U;
  #line 6289 
  adapter->fcoe.up = (unsigned char)3U;
  #line 6294 
  adapter->jump_tables[0] = (struct ixgbe_jump_table *)kzalloc(288UL,3264U);
  #line 6296 
  if (adapter->jump_tables[0] == (struct ixgbe_jump_table *)0) 
                                                               #line 6297 
                                                               return -12;
  #line 6298 
  (adapter->jump_tables[0])->mat = (struct ixgbe_mat_field *)(& ixgbe_ipv4_fields);
  #line 6300 
  i = 1;
  #line 6300 
  while (i <= 9) {
    #line 6301 
    adapter->jump_tables[i] = (struct ixgbe_jump_table *)0;
    #line 6300 
    i ++;
  }
  #line 6303 
  adapter->mac_table = (struct ixgbe_mac_addr *)kcalloc((unsigned long)hw->mac.num_rar_entries,10UL,3264U);
  #line 6306 
  if (adapter->mac_table == (struct ixgbe_mac_addr *)0) 
                                                        #line 6307 
                                                        return -12;
  #line 6309 
  if (ixgbe_init_rss_key(adapter) != 0) 
                                        #line 6310 
                                        return -12;
  #line 6312 
  adapter->af_xdp_zc_qps = bitmap_zalloc(64U,3264U);
  #line 6313 
  if (adapter->af_xdp_zc_qps == (unsigned long *)0UL) 
                                                      #line 6314 
                                                      return -12;
  #line 6317 
  switch ((unsigned int)hw->mac.type) {
    #line 6318 
    case (unsigned int)1: 
                          #line 6318 
    ;
    #line 6319 
    adapter->flags2 &= 4294967294U;
    #line 6321 
    if ((unsigned int)hw->device_id == 4296U) 
                                              #line 6322 
                                              adapter->flags |= 32768U;
    #line 6324 
    adapter->max_q_vectors = 16;
    #line 6325 
    adapter->ring_feature[3].limit = (unsigned short)0U;
    #line 6326 
    adapter->atr_sample_rate = 0U;
    #line 6327 
    adapter->fdir_pballoc = 0U;
    #line 6329 
    adapter->flags &= 4293918719U;
    #line 6330 
    adapter->flags &= 4292870143U;
    #line 6332 
    adapter->fcoe.up = (unsigned char)0U;
    #line 6335 
    break;
    #line 6336 
    case (unsigned int)2: 
                          #line 6336 
    ;
    #line 6337 
    if ((unsigned int)hw->device_id == 5404U) 
                                              #line 6338 
                                              adapter->flags2 |= 4U;
    #line 6339 
    break;
    #line 6340 
    case (unsigned int)3: 
                          #line 6340 
    ;
    #line 6341 
    fwsm = ixgbe_read_reg(hw,*(hw->mvals + 6U));
    #line 6342 
    if ((fwsm & 1U) != 0U) 
                           #line 6343 
                           adapter->flags2 |= 4U;
    #line 6344 
    break;
    #line 6345 
    case (unsigned int)6: 
                          #line 6345 
    ;
    #line 6346 
    adapter->flags |= 268435456U;
    #line 6347 
    switch ((int)hw->device_id) {
      #line 6348 
      case 5604: 
                 #line 6348 
      ;
      #line 6349 
      case 5605: 
                 #line 6349 
      ;
      #line 6350 
      adapter->flags2 |= 4U;
      #line 6351 
      break;
      #line 6352 
      default: 
               #line 6352 
      ;
      #line 6353 
      break;
    }
    #line 6356 
    case (unsigned int)5: 
                          #line 6356 
    ;
    #line 6358 
    adapter->flags &= 4160749567U;
    #line 6361 
    adapter->flags &= 4293918719U;
    #line 6363 
    adapter->fcoe.up = (unsigned char)0U;
    #line 6367 
    case (unsigned int)4: 
                          #line 6367 
    ;
    #line 6368 
    if (hw->mac.type == (unsigned int)ixgbe_mac_X550) 
                                                      #line 6369 
                                                      adapter->flags2 |= 4U;
    #line 6371 
    adapter->flags &= 4294966783U;
    #line 6373 
    adapter->flags |= 16777216U;
    #line 6374 
    break;
    #line 6375 
    default: 
             #line 6375 
    ;
    #line 6376 
    break;
  }
  #line 6381 
  spinlock_check(& adapter->fcoe.lock);
  {
    #line 6381 
    struct lock_class_key __key;
    #line 6381 
    __raw_spin_lock_init(& adapter->fcoe.lock.__anonCompField_spinlock_25.rlock,(char *)"&(&adapter->fcoe.lock)->rlock",& __key);
  }
  #line 6385 
  spinlock_check(& adapter->fdir_perfect_lock);
  {
    #line 6385 
    struct lock_class_key __key_0;
    #line 6385 
    __raw_spin_lock_init(& adapter->fdir_perfect_lock.__anonCompField_spinlock_25.rlock,(char *)"&(&adapter->fdir_perfect_lock)->rlock",& __key_0);
  }
  #line 6388 
  ixgbe_init_dcb(adapter);
  #line 6390 
  ixgbe_init_ipsec_offload(adapter);
  #line 6393 
  hw->fc.requested_mode = ixgbe_fc_full;
  #line 6394 
  hw->fc.current_mode = ixgbe_fc_full;
  #line 6395 
  ixgbe_pbthresh_setup(adapter);
  #line 6396 
  hw->fc.pause_time = (unsigned short)65535U;
  #line 6397 
  hw->fc.send_xon = (_Bool)1;
  #line 6398 
  hw->fc.disable_fc_autoneg = ixgbe_device_supports_autoneg_fc(hw);
  #line 6401 
  if (max_vfs != 0U) 
                     #line 6402 
                     _dev_warn(& (adapter->pdev)->dev,(char *)"Enabling SR-IOV VFs using the max_vfs module parameter is deprecated - please use the pci sysfs interface instead.\n");
  #line 6405 
  if (hw->mac.type != (unsigned int)ixgbe_mac_82598EB) 
    #line 6406 
    if (max_vfs > 63U) {
      #line 6407 
      max_vfs = 0U;
      #line 6408 
      _dev_warn(& (adapter->pdev)->dev,(char *)"max_vfs parameter out of range. Not assigning any SR-IOV VFs\n");
    }
  #line 6414 
  adapter->rx_itr_setting = (unsigned short)1U;
  #line 6415 
  adapter->tx_itr_setting = (unsigned short)1U;
  #line 6418 
  adapter->tx_ring_count = 512U;
  #line 6419 
  adapter->rx_ring_count = 512U;
  #line 6422 
  adapter->tx_work_limit = (unsigned short)256U;
  #line 6425 
  if (ixgbe_init_eeprom_params_generic(hw) != 0) {
    #line 6426 
    _dev_err(& (adapter->pdev)->dev,(char *)"EEPROM initialization failed\n");
    #line 6427 
    return -5;
  }
  #line 6431 
  cif_set_bit(0L,(unsigned long *)(& adapter->fwd_bitmask));
  #line 6432 
  cif_set_bit(2L,& adapter->state);
  #line 6434 
  return 0;
}

#line 6443  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_setup_tx_resources(struct ixgbe_ring *tx_ring)
{
  #line 6448 
  int size;
  #line 6445 
  struct device *dev = tx_ring->dev;
  #line 6446 
  int orig_node = dev_to_node(dev);
  #line 6447 
  int ring_node = -1;
  #line 6450 
  size = (int)((unsigned int)tx_ring->count * 48U);
  #line 6452 
  if (tx_ring->q_vector != (struct ixgbe_q_vector *)0) 
                                                       #line 6453 
                                                       ring_node = (tx_ring->q_vector)->numa_node;
  #line 6455 
  tx_ring->__anonCompField_ixgbe_ring_221.tx_buffer_info = (struct ixgbe_tx_buffer *)cif_vmalloc_node((unsigned long)size,ring_node);
  #line 6456 
  if (tx_ring->__anonCompField_ixgbe_ring_221.tx_buffer_info == (struct ixgbe_tx_buffer *)0) 
    #line 6457 
    tx_ring->__anonCompField_ixgbe_ring_221.tx_buffer_info = (struct ixgbe_tx_buffer *)cif_vmalloc((unsigned long)size);
  #line 6458 
  if (tx_ring->__anonCompField_ixgbe_ring_221.tx_buffer_info == (struct ixgbe_tx_buffer *)0) 
    #line 6459 
    goto err;
  #line 6462 
  tx_ring->size = (unsigned int)tx_ring->count * 16U;
  #line 6463 
  tx_ring->size = (tx_ring->size + 4095U) & 4294963200U;
  #line 6465 
  set_dev_node(dev,ring_node);
  #line 6466 
  tx_ring->desc = dma_alloc_coherent(dev,(unsigned long)tx_ring->size,& tx_ring->dma,3264U);
  #line 6470 
  set_dev_node(dev,orig_node);
  #line 6471 
  if (tx_ring->desc == (void *)0) 
                                  #line 6472 
                                  tx_ring->desc = dma_alloc_coherent(dev,(unsigned long)tx_ring->size,& tx_ring->dma,3264U);
  #line 6474 
  if (tx_ring->desc == (void *)0) 
                                  #line 6475 
                                  goto err;
  #line 6477 
  tx_ring->next_to_use = (unsigned short)0U;
  #line 6478 
  tx_ring->next_to_clean = (unsigned short)0U;
  #line 6479 
  return 0;
  #line 6481 
  err: 
       #line 6481 
  ;
  #line 6482 
  cif_vfree((void *)tx_ring->__anonCompField_ixgbe_ring_221.tx_buffer_info);
  #line 6483 
  tx_ring->__anonCompField_ixgbe_ring_221.tx_buffer_info = (struct ixgbe_tx_buffer *)0;
  #line 6484 
  _dev_err(dev,(char *)"Unable to allocate memory for the Tx descriptor ring\n");
  #line 6485 
  return -12;
}

#line 6498  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_setup_all_tx_resources(struct ixgbe_adapter *adapter)
{
  #line 6500 
  int i;
  #line 6500 
  int j = 0;
  #line 6500 
  int err = 0;
  #line 6502 
  i = 0;
  #line 6502 
  while (adapter->num_tx_queues > i) {
    #line 6503 
    err = ixgbe_setup_tx_resources(adapter->tx_ring[i]);
    #line 6504 
    if (err == 0) 
                  #line 6505 
                  goto __Cont;
    #line 6507 
    if (((int)adapter->msg_enable & 2) != 0) 
                                             #line 6507 
                                             netdev_err(adapter->netdev,(char *)"Allocation for Tx Queue %u failed\n",i);
    #line 6508 
    goto err_setup_tx;
    #line 6502 
    __Cont: 
            #line 6502 
    i ++;
  }
  #line 6510 
  j = 0;
  #line 6510 
  while (adapter->num_xdp_queues > j) {
    #line 6511 
    err = ixgbe_setup_tx_resources(adapter->xdp_ring[j]);
    #line 6512 
    if (err == 0) 
                  #line 6513 
                  goto __Cont_0;
    #line 6515 
    if (((int)adapter->msg_enable & 2) != 0) 
                                             #line 6515 
                                             netdev_err(adapter->netdev,(char *)"Allocation for Tx Queue %u failed\n",j);
    #line 6516 
    goto err_setup_tx;
    #line 6510 
    __Cont_0: 
              #line 6510 
    j ++;
  }
  #line 6519 
  return 0;
  #line 6520 
  err_setup_tx: 
                #line 6520 
  ;
  #line 6522 
  while (1) {
    #line 6522 
    int tmp;
    #line 6522 
    tmp = j;
    #line 6522 
    j --;
    #line 6522 
    ;
    #line 6522 
    if (! (tmp != 0)) 
                      #line 6522 
                      break;
    #line 6523 
    ixgbe_free_tx_resources(adapter->xdp_ring[j]);
  }
  #line 6524 
  while (1) {
    #line 6524 
    int tmp_0;
    #line 6524 
    tmp_0 = i;
    #line 6524 
    i --;
    #line 6524 
    ;
    #line 6524 
    if (! (tmp_0 != 0)) 
                        #line 6524 
                        break;
    #line 6525 
    ixgbe_free_tx_resources(adapter->tx_ring[i]);
  }
  #line 6526 
  return err;
}

#line 6536  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_setup_rx_resources(struct ixgbe_adapter *adapter, struct ixgbe_ring *rx_ring)
{
  #line 6542 
  int size;
  #line 6539 
  struct device *dev = rx_ring->dev;
  #line 6540 
  int orig_node = dev_to_node(dev);
  #line 6541 
  int ring_node = -1;
  #line 6544 
  size = (int)((unsigned int)rx_ring->count * 32U);
  #line 6546 
  if (rx_ring->q_vector != (struct ixgbe_q_vector *)0) 
                                                       #line 6547 
                                                       ring_node = (rx_ring->q_vector)->numa_node;
  #line 6549 
  rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info = (struct ixgbe_rx_buffer *)cif_vmalloc_node((unsigned long)size,ring_node);
  #line 6550 
  if (rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info == (struct ixgbe_rx_buffer *)0) 
    #line 6551 
    rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info = (struct ixgbe_rx_buffer *)cif_vmalloc((unsigned long)size);
  #line 6552 
  if (rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info == (struct ixgbe_rx_buffer *)0) 
    #line 6553 
    goto err;
  #line 6556 
  rx_ring->size = (unsigned int)rx_ring->count * 16U;
  #line 6557 
  rx_ring->size = (rx_ring->size + 4095U) & 4294963200U;
  #line 6559 
  set_dev_node(dev,ring_node);
  #line 6560 
  rx_ring->desc = dma_alloc_coherent(dev,(unsigned long)rx_ring->size,& rx_ring->dma,3264U);
  #line 6564 
  set_dev_node(dev,orig_node);
  #line 6565 
  if (rx_ring->desc == (void *)0) 
                                  #line 6566 
                                  rx_ring->desc = dma_alloc_coherent(dev,(unsigned long)rx_ring->size,& rx_ring->dma,3264U);
  #line 6568 
  if (rx_ring->desc == (void *)0) 
                                  #line 6569 
                                  goto err;
  #line 6571 
  rx_ring->next_to_clean = (unsigned short)0U;
  #line 6572 
  rx_ring->next_to_use = (unsigned short)0U;
  #line 6575 
  if (xdp_rxq_info_reg(& rx_ring->xdp_rxq,adapter->netdev,
                         (unsigned int)rx_ring->queue_index) < 0) 
    #line 6577 
    goto err;
  #line 6579 
  rx_ring->xdp_prog = adapter->xdp_prog;
  #line 6581 
  return 0;
  #line 6582 
  err: 
       #line 6582 
  ;
  #line 6583 
  cif_vfree((void *)rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info);
  #line 6584 
  rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info = (struct ixgbe_rx_buffer *)0;
  #line 6585 
  _dev_err(dev,(char *)"Unable to allocate memory for the Rx descriptor ring\n");
  #line 6586 
  return -12;
}

#line 6599  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_setup_all_rx_resources(struct ixgbe_adapter *adapter)
{
  #line 6601 
  int i;
  #line 6601 
  int err = 0;
  #line 6603 
  i = 0;
  #line 6603 
  while (adapter->num_rx_queues > i) {
    #line 6604 
    err = ixgbe_setup_rx_resources(adapter,adapter->rx_ring[i]);
    #line 6605 
    if (err == 0) 
                  #line 6606 
                  goto __Cont;
    #line 6608 
    if (((int)adapter->msg_enable & 2) != 0) 
                                             #line 6608 
                                             netdev_err(adapter->netdev,(char *)"Allocation for Rx Queue %u failed\n",i);
    #line 6609 
    goto err_setup_rx;
    #line 6603 
    __Cont: 
            #line 6603 
    i ++;
  }
  #line 6613 
  err = ixgbe_setup_fcoe_ddp_resources(adapter);
  #line 6614 
  if (err == 0) 
                #line 6616 
                return 0;
  #line 6617 
  err_setup_rx: 
                #line 6617 
  ;
  #line 6619 
  while (1) {
    #line 6619 
    int tmp;
    #line 6619 
    tmp = i;
    #line 6619 
    i --;
    #line 6619 
    ;
    #line 6619 
    if (! (tmp != 0)) 
                      #line 6619 
                      break;
    #line 6620 
    ixgbe_free_rx_resources(adapter->rx_ring[i]);
  }
  #line 6621 
  return err;
}

#line 6630  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_free_tx_resources(struct ixgbe_ring *tx_ring)
{
  #line 6632 
  ixgbe_clean_tx_ring(tx_ring);
  #line 6634 
  cif_vfree((void *)tx_ring->__anonCompField_ixgbe_ring_221.tx_buffer_info);
  #line 6635 
  tx_ring->__anonCompField_ixgbe_ring_221.tx_buffer_info = (struct ixgbe_tx_buffer *)0;
  #line 6638 
  if (tx_ring->desc == (void *)0) 
                                  #line 6639 
                                  return;
  #line 6641 
  dma_free_coherent(tx_ring->dev,(unsigned long)tx_ring->size,tx_ring->desc,tx_ring->dma);
  #line 6644 
  tx_ring->desc = (void *)0;
  #line 6645 
  return;
}

#line 6653  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_free_all_tx_resources(struct ixgbe_adapter *adapter)
{
  #line 6655 
  int i;
  #line 6657 
  i = 0;
  #line 6657 
  while (adapter->num_tx_queues > i) {
    #line 6658 
    if ((adapter->tx_ring[i])->desc != (void *)0) 
                                                  #line 6659 
                                                  ixgbe_free_tx_resources(adapter->tx_ring[i]);
    #line 6657 
    i ++;
  }
  #line 6660 
  i = 0;
  #line 6660 
  while (adapter->num_xdp_queues > i) {
    #line 6661 
    if ((adapter->xdp_ring[i])->desc != (void *)0) 
                                                   #line 6662 
                                                   ixgbe_free_tx_resources(adapter->xdp_ring[i]);
    #line 6660 
    i ++;
  }
  #line 6663 
  return;
}

#line 6671  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_free_rx_resources(struct ixgbe_ring *rx_ring)
{
  #line 6673 
  ixgbe_clean_rx_ring(rx_ring);
  #line 6675 
  rx_ring->xdp_prog = (struct bpf_prog *)0;
  #line 6676 
  xdp_rxq_info_unreg(& rx_ring->xdp_rxq);
  #line 6677 
  cif_vfree((void *)rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info);
  #line 6678 
  rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info = (struct ixgbe_rx_buffer *)0;
  #line 6681 
  if (rx_ring->desc == (void *)0) 
                                  #line 6682 
                                  return;
  #line 6684 
  dma_free_coherent(rx_ring->dev,(unsigned long)rx_ring->size,rx_ring->desc,rx_ring->dma);
  #line 6687 
  rx_ring->desc = (void *)0;
  #line 6688 
  return;
}

#line 6696  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_free_all_rx_resources(struct ixgbe_adapter *adapter)
{
  #line 6698 
  int i;
  #line 6701 
  ixgbe_free_fcoe_ddp_resources(adapter);
  #line 6704 
  i = 0;
  #line 6704 
  while (adapter->num_rx_queues > i) {
    #line 6705 
    if ((adapter->rx_ring[i])->desc != (void *)0) 
                                                  #line 6706 
                                                  ixgbe_free_rx_resources(adapter->rx_ring[i]);
    #line 6704 
    i ++;
  }
  #line 6707 
  return;
}

#line 6716  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_change_mtu(struct net_device *netdev, int new_mtu)
{
  #line 6718 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 6720 
  if (adapter->xdp_prog != (struct bpf_prog *)0) {
    #line 6723 
    int i;
    #line 6721 
    int new_frame_size = new_mtu + 22;
    #line 6725 
    i = 0;
    #line 6725 
    while (adapter->num_rx_queues > i) {
      {
        #line 6726 
        struct ixgbe_ring *ring = adapter->rx_ring[i];
        #line 6728 
        ;
        #line 6728 
        if (ixgbe_rx_bufsz(ring) < (unsigned int)new_frame_size) {
          #line 6729 
          if (((int)adapter->msg_enable & 2) != 0) 
                                                   #line 6729 
                                                   netdev_warn(adapter->netdev,(char *)"Requested MTU size is not supported with XDP\n");
          #line 6730 
          return -22;
        }
      }
      #line 6725 
      i ++;
    }
  }
  #line 6740 
  if ((((unsigned long)adapter->flags & 8388608UL) != 0UL && adapter->hw.mac.type == (unsigned int)ixgbe_mac_82599EB) && new_mtu > 1500) 
    #line 6743 
    if (((int)adapter->msg_enable & 2) != 0) 
                                             #line 6743 
                                             netdev_warn(adapter->netdev,(char *)"Setting MTU > 1500 will disable legacy VFs\n");
  {
    #line 6745 
    bool branch;
    #line 6745 
    struct _ddebug __UNIQUE_ID_ddebug593 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_change_mtu", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c", .format = (char *)"changing MTU from %d to %d\n", .lineno = (unsigned int)6745U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 6745 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug593.key.dd_key_false.key,(_Bool)0);
    #line 6745 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 6745 
                                                __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug593,netdev,(char *)"changing MTU from %d to %d\n",netdev->mtu,new_mtu);
  }
  #line 6749 
  netdev->mtu = (unsigned int)new_mtu;
  #line 6751 
  if ((int)netif_running(netdev) != 0) 
                                       #line 6752 
                                       ixgbe_reinit_locked(adapter);
  #line 6754 
  return 0;
}

#line 6769  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_open(struct net_device *netdev)
{
  #line 6773 
  int err;
  #line 6773 
  int queues;
  #line 6771 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 6772 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 6776 
  if ((int)test_bit(0L,& adapter->state) != 0) 
                                               #line 6777 
                                               return -16;
  #line 6779 
  netif_carrier_off(netdev);
  #line 6782 
  err = ixgbe_setup_all_tx_resources(adapter);
  #line 6783 
  if (err != 0) 
                #line 6784 
                goto err_setup_tx;
  #line 6787 
  err = ixgbe_setup_all_rx_resources(adapter);
  #line 6788 
  if (err != 0) 
                #line 6789 
                goto err_setup_rx;
  #line 6791 
  ixgbe_configure(adapter);
  #line 6793 
  err = ixgbe_request_irq(adapter);
  #line 6794 
  if (err != 0) 
                #line 6795 
                goto err_req_irq;
  #line 6798 
  queues = adapter->num_tx_queues;
  #line 6799 
  err = netif_set_real_num_tx_queues(netdev,(unsigned int)queues);
  #line 6800 
  if (err != 0) 
                #line 6801 
                goto err_set_queues;
  #line 6803 
  queues = adapter->num_rx_queues;
  #line 6804 
  err = netif_set_real_num_rx_queues(netdev,(unsigned int)queues);
  #line 6805 
  if (err != 0) 
                #line 6806 
                goto err_set_queues;
  #line 6808 
  ixgbe_ptp_init(adapter);
  #line 6810 
  ixgbe_up_complete(adapter);
  #line 6812 
  ixgbe_clear_udp_tunnel_port(adapter,4294967295U);
  #line 6813 
  udp_tunnel_get_rx_info(netdev);
  #line 6815 
  return 0;
  #line 6817 
  err_set_queues: 
                  #line 6817 
  ;
  #line 6818 
  ixgbe_free_irq(adapter);
  #line 6819 
  err_req_irq: 
               #line 6819 
  ;
  #line 6820 
  ixgbe_free_all_rx_resources(adapter);
  #line 6821 
  if (hw->phy.ops.set_phy_power != (s32 (*)(struct ixgbe_hw *, bool ))0 && adapter->wol == 0U) 
    #line 6822 
    (*(hw->phy.ops.set_phy_power))(& adapter->hw,(_Bool)0);
  #line 6823 
  err_setup_rx: 
                #line 6823 
  ;
  #line 6824 
  ixgbe_free_all_tx_resources(adapter);
  #line 6825 
  err_setup_tx: 
                #line 6825 
  ;
  #line 6826 
  ixgbe_reset(adapter);
  #line 6828 
  return err;
}

#line 6831  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_close_suspend(struct ixgbe_adapter *adapter)
{
  #line 6833 
  ixgbe_ptp_suspend(adapter);
  #line 6835 
  if (adapter->hw.phy.ops.enter_lplu != (s32 (*)(struct ixgbe_hw *))0) {
    #line 6836 
    adapter->hw.phy.reset_disable = (_Bool)1;
    #line 6837 
    ixgbe_down(adapter);
    #line 6838 
    (*(adapter->hw.phy.ops.enter_lplu))(& adapter->hw);
    #line 6839 
    adapter->hw.phy.reset_disable = (_Bool)0;
  }
  else 
       #line 6841 
       ixgbe_down(adapter);
  #line 6844 
  ixgbe_free_irq(adapter);
  #line 6846 
  ixgbe_free_all_tx_resources(adapter);
  #line 6847 
  ixgbe_free_all_rx_resources(adapter);
  #line 6848 
  return;
}

#line 6861  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_close(struct net_device *netdev)
{
  #line 6863 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 6865 
  ixgbe_ptp_stop(adapter);
  #line 6867 
  if ((int)netif_device_present(netdev) != 0) 
                                              #line 6868 
                                              ixgbe_close_suspend(adapter);
  #line 6870 
  ixgbe_fdir_filter_exit(adapter);
  #line 6872 
  ixgbe_release_hw_control(adapter);
  #line 6874 
  return 0;
}

#line 6878  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_resume(struct pci_dev *pdev)
{
  #line 6882 
  u32 err;
  #line 6880 
  struct ixgbe_adapter *adapter = pci_get_drvdata(pdev);
  #line 6881 
  struct net_device *netdev = adapter->netdev;
  #line 6884 
  adapter->hw.hw_addr = adapter->io_addr;
  #line 6885 
  pci_set_power_state(pdev,0);
  #line 6886 
  pci_restore_state(pdev);
  #line 6891 
  pci_save_state(pdev);
  #line 6893 
  err = (unsigned int)pci_enable_device_mem(pdev);
  #line 6894 
  if (err != 0U) {
    #line 6895 
    _dev_err(& (adapter->pdev)->dev,(char *)"Cannot enable PCI device from suspend\n");
    #line 6896 
    return (int)err;
  }
  #line 6899 
  cif_clear_bit(3L,& adapter->state);
  #line 6900 
  pci_set_master(pdev);
  #line 6902 
  pci_wake_from_d3(pdev,(_Bool)0);
  #line 6904 
  ixgbe_reset(adapter);
  #line 6906 
  ixgbe_write_reg_1(& adapter->hw,22544U,4294967295U);
  #line 6908 
  rtnl_lock();
  #line 6909 
  err = (unsigned int)ixgbe_init_interrupt_scheme(adapter);
  #line 6910 
  if (err == 0U) {
    #line 6910 
    if ((int)netif_running(netdev) != 0) {
      #line 6911 
      err = (unsigned int)ixgbe_open(netdev);
    }
  }
  #line 6914 
  if (err == 0U) 
                 #line 6915 
                 netif_device_attach(netdev);
  #line 6916 
  rtnl_unlock();
  #line 6918 
  return (int)err;
}

#line 6922  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int __ixgbe_shutdown(struct pci_dev *pdev, bool *enable_wake)
{
  #line 6927 
  u32 ctrl;
  #line 6924 
  struct ixgbe_adapter *adapter = pci_get_drvdata(pdev);
  #line 6925 
  struct net_device *netdev = adapter->netdev;
  #line 6926 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 6928 
  u32 wufc = adapter->wol;
  #line 6930 
  int retval = 0;
  #line 6933 
  rtnl_lock();
  #line 6934 
  netif_device_detach(netdev);
  #line 6936 
  if ((int)netif_running(netdev) != 0) 
                                       #line 6937 
                                       ixgbe_close_suspend(adapter);
  #line 6939 
  ixgbe_clear_interrupt_scheme(adapter);
  #line 6940 
  rtnl_unlock();
  #line 6943 
  retval = pci_save_state(pdev);
  #line 6944 
  if (retval != 0) 
                   #line 6945 
                   return retval;
  #line 6948 
  if (hw->mac.ops.stop_link_on_d3 != (void (*)(struct ixgbe_hw *))0) 
    #line 6949 
    (*(hw->mac.ops.stop_link_on_d3))(hw);
  #line 6951 
  if (wufc != 0U) {
    #line 6952 
    u32 fctrl;
    #line 6954 
    ixgbe_set_rx_mode(netdev);
    #line 6957 
    if (hw->mac.ops.enable_tx_laser != (void (*)(struct ixgbe_hw *))0) 
      #line 6958 
      (*(hw->mac.ops.enable_tx_laser))(hw);
    #line 6961 
    fctrl = ixgbe_read_reg(hw,20608U);
    #line 6962 
    fctrl |= 256U;
    #line 6963 
    ixgbe_write_reg_1(hw,20608U,fctrl);
    #line 6965 
    ctrl = ixgbe_read_reg(hw,0U);
    #line 6966 
    ctrl |= 4U;
    #line 6967 
    ixgbe_write_reg_1(hw,0U,ctrl);
    #line 6969 
    ixgbe_write_reg_1(hw,22536U,wufc);
  }
  else {
    #line 6971 
    ixgbe_write_reg_1(hw,22528U,0U);
    #line 6972 
    ixgbe_write_reg_1(hw,22536U,0U);
  }
  #line 6975 
  switch ((unsigned int)hw->mac.type) {
    #line 6976 
    case (unsigned int)1: 
                          #line 6976 
    ;
    #line 6977 
    pci_wake_from_d3(pdev,(_Bool)0);
    #line 6978 
    break;
    #line 6979 
    case (unsigned int)2: 
                          #line 6979 
    ;
    #line 6980 
    case (unsigned int)3: 
                          #line 6980 
    ;
    #line 6981 
    case (unsigned int)4: 
                          #line 6981 
    ;
    #line 6982 
    case (unsigned int)5: 
                          #line 6982 
    ;
    #line 6983 
    case (unsigned int)6: 
                          #line 6983 
    ;
    #line 6984 
    pci_wake_from_d3(pdev,(_Bool)(wufc != 0U));
    #line 6985 
    break;
    #line 6986 
    default: 
             #line 6986 
    ;
    #line 6987 
    break;
  }
  #line 6990 
  *enable_wake = (_Bool)(wufc != 0U);
  #line 6991 
  if (hw->phy.ops.set_phy_power != (s32 (*)(struct ixgbe_hw *, bool ))0 && ! *enable_wake) 
    #line 6992 
    (*(hw->phy.ops.set_phy_power))(hw,(_Bool)0);
  #line 6994 
  ixgbe_release_hw_control(adapter);
  #line 6996 
  if (! test_and_set_bit(3L,& adapter->state)) 
                                               #line 6997 
                                               pci_disable_device(pdev);
  #line 6999 
  return 0;
}

#line 7003  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_suspend(struct pci_dev *pdev, pm_message_t state)
{
  #line 7005 
  int retval;
  #line 7006 
  bool wake;
  #line 7008 
  retval = __ixgbe_shutdown(pdev,& wake);
  #line 7009 
  if (retval != 0) 
                   #line 7010 
                   return retval;
  #line 7012 
  if ((int)wake != 0) 
                      #line 7013 
                      pci_prepare_to_sleep(pdev);
  else {
    #line 7015 
    pci_wake_from_d3(pdev,(_Bool)0);
    #line 7016 
    pci_set_power_state(pdev,3);
  }
  #line 7019 
  return 0;
}

#line 7023  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_shutdown(struct pci_dev *pdev)
{
  #line 7025 
  bool wake;
  #line 7027 
  __ixgbe_shutdown(pdev,& wake);
  #line 7029 
  if (system_state == (unsigned int)SYSTEM_POWER_OFF) {
    #line 7030 
    pci_wake_from_d3(pdev,(_Bool)((bool)((int)wake) != 0));
    #line 7031 
    pci_set_power_state(pdev,3);
  }
  #line 7033 
  return;
}

#line 7039  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_update_stats(struct ixgbe_adapter *adapter)
{
  #line 7045 
  u32 i;
  #line 7045 
  u32 mpc;
  #line 7045 
  u32 bprc;
  #line 7045 
  u32 lxon;
  #line 7045 
  u32 lxoff;
  #line 7045 
  u32 xon_off_tot;
  #line 7041 
  struct net_device *netdev = adapter->netdev;
  #line 7042 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 7043 
  struct ixgbe_hw_stats *hwstats = & adapter->stats;
  #line 7044 
  u64 total_mpc = 0ULL;
  #line 7045 
  u32 missed_rx = 0U;
  #line 7046 
  u64 non_eop_descs = 0ULL;
  #line 7046 
  u64 restart_queue = 0ULL;
  #line 7046 
  u64 tx_busy = 0ULL;
  #line 7047 
  u64 alloc_rx_page_failed = 0ULL;
  #line 7047 
  u64 alloc_rx_buff_failed = 0ULL;
  #line 7048 
  u64 alloc_rx_page = 0ULL;
  #line 7049 
  u64 bytes = 0ULL;
  #line 7049 
  u64 packets = 0ULL;
  #line 7049 
  u64 hw_csum_rx_error = 0ULL;
  #line 7051 
  if ((int)test_bit(2L,& adapter->state) != 0) 
                                               #line 7053 
                                               return;
  else {
    #line 7051 
    if ((int)test_bit(1L,& adapter->state) != 0) 
                                                 #line 7053 
                                                 return;
  }
  #line 7055 
  if (((unsigned long)adapter->flags2 & 2UL) != 0UL) {
    #line 7056 
    u64 rsc_count = 0ULL;
    #line 7057 
    u64 rsc_flush = 0ULL;
    #line 7058 
    i = 0U;
    #line 7058 
    while ((unsigned int)adapter->num_rx_queues > i) {
      #line 7059 
      rsc_count = (adapter->rx_ring[i])->__anonCompField_ixgbe_ring_224.rx_stats.rsc_count + rsc_count;
      #line 7060 
      rsc_flush = (adapter->rx_ring[i])->__anonCompField_ixgbe_ring_224.rx_stats.rsc_flush + rsc_flush;
      #line 7058 
      i ++;
    }
    #line 7062 
    adapter->rsc_total_count = rsc_count;
    #line 7063 
    adapter->rsc_total_flush = rsc_flush;
  }
  #line 7066 
  i = 0U;
  #line 7066 
  while ((unsigned int)adapter->num_rx_queues > i) {
    {
      #line 7067 
      struct ixgbe_ring *rx_ring = adapter->rx_ring[i];
      #line 7068 
      non_eop_descs = rx_ring->__anonCompField_ixgbe_ring_224.rx_stats.non_eop_descs + non_eop_descs;
      #line 7069 
      alloc_rx_page = rx_ring->__anonCompField_ixgbe_ring_224.rx_stats.alloc_rx_page + alloc_rx_page;
      #line 7070 
      alloc_rx_page_failed = rx_ring->__anonCompField_ixgbe_ring_224.rx_stats.alloc_rx_page_failed + alloc_rx_page_failed;
      #line 7071 
      alloc_rx_buff_failed = rx_ring->__anonCompField_ixgbe_ring_224.rx_stats.alloc_rx_buff_failed + alloc_rx_buff_failed;
      #line 7072 
      hw_csum_rx_error = rx_ring->__anonCompField_ixgbe_ring_224.rx_stats.csum_err + hw_csum_rx_error;
      #line 7073 
      bytes = rx_ring->stats.bytes + bytes;
      #line 7074 
      packets = rx_ring->stats.packets + packets;
    }
    #line 7066 
    i ++;
  }
  #line 7076 
  adapter->non_eop_descs = non_eop_descs;
  #line 7077 
  adapter->alloc_rx_page = (unsigned int)alloc_rx_page;
  #line 7078 
  adapter->alloc_rx_page_failed = (unsigned int)alloc_rx_page_failed;
  #line 7079 
  adapter->alloc_rx_buff_failed = (unsigned int)alloc_rx_buff_failed;
  #line 7080 
  adapter->hw_csum_rx_error = hw_csum_rx_error;
  #line 7081 
  netdev->stats.rx_bytes = (unsigned long)bytes;
  #line 7082 
  netdev->stats.rx_packets = (unsigned long)packets;
  #line 7084 
  bytes = 0ULL;
  #line 7085 
  packets = 0ULL;
  #line 7087 
  i = 0U;
  #line 7087 
  while ((unsigned int)adapter->num_tx_queues > i) {
    {
      #line 7088 
      struct ixgbe_ring *tx_ring = adapter->tx_ring[i];
      #line 7089 
      restart_queue = tx_ring->__anonCompField_ixgbe_ring_224.tx_stats.restart_queue + restart_queue;
      #line 7090 
      tx_busy = tx_ring->__anonCompField_ixgbe_ring_224.tx_stats.tx_busy + tx_busy;
      #line 7091 
      bytes = tx_ring->stats.bytes + bytes;
      #line 7092 
      packets = tx_ring->stats.packets + packets;
    }
    #line 7087 
    i ++;
  }
  #line 7094 
  i = 0U;
  #line 7094 
  while ((unsigned int)adapter->num_xdp_queues > i) {
    {
      #line 7095 
      struct ixgbe_ring *xdp_ring = adapter->xdp_ring[i];
      #line 7097 
      restart_queue = xdp_ring->__anonCompField_ixgbe_ring_224.tx_stats.restart_queue + restart_queue;
      #line 7098 
      tx_busy = xdp_ring->__anonCompField_ixgbe_ring_224.tx_stats.tx_busy + tx_busy;
      #line 7099 
      bytes = xdp_ring->stats.bytes + bytes;
      #line 7100 
      packets = xdp_ring->stats.packets + packets;
    }
    #line 7094 
    i ++;
  }
  #line 7102 
  adapter->restart_queue = restart_queue;
  #line 7103 
  adapter->tx_busy = tx_busy;
  #line 7104 
  netdev->stats.tx_bytes = (unsigned long)bytes;
  #line 7105 
  netdev->stats.tx_packets = (unsigned long)packets;
  #line 7107 
  hwstats->crcerrs += (unsigned long long)ixgbe_read_reg(hw,16384U);
  #line 7110 
  i = 0U;
  #line 7110 
  while (i <= 7U) {
    {
      #line 7112 
      mpc = ixgbe_read_reg(hw,(i + 4072U) * 4U);
      #line 7113 
      missed_rx += mpc;
      #line 7114 
      hwstats->mpc[i] += (unsigned long long)mpc;
      #line 7115 
      total_mpc = hwstats->mpc[i] + total_mpc;
      #line 7116 
      hwstats->pxontxc[i] += (unsigned long long)ixgbe_read_reg(hw,(i + 4032U) * 4U);
      #line 7117 
      hwstats->pxofftxc[i] += (unsigned long long)ixgbe_read_reg(hw,(i + 4040U) * 4U);
      #line 7118 
      switch ((unsigned int)hw->mac.type) {
        #line 7119 
        case (unsigned int)1: 
                              #line 7119 
        ;
        #line 7120 
        hwstats->rnbc[i] += (unsigned long long)ixgbe_read_reg(hw,(i + 4080U) * 4U);
        #line 7121 
        hwstats->qbtc[i] += (unsigned long long)ixgbe_read_reg(hw,i * 64U + 24628U);
        #line 7122 
        hwstats->qbrc[i] += (unsigned long long)ixgbe_read_reg(hw,i * 64U + 4148U);
        #line 7124 
        hwstats->pxonrxc[i] += (unsigned long long)ixgbe_read_reg(hw,(i + 13248U) * 4U);
        #line 7125 
        break;
        #line 7126 
        case (unsigned int)2: 
                              #line 7126 
        ;
        #line 7127 
        case (unsigned int)3: 
                              #line 7127 
        ;
        #line 7128 
        case (unsigned int)4: 
                              #line 7128 
        ;
        #line 7129 
        case (unsigned int)5: 
                              #line 7129 
        ;
        #line 7130 
        case (unsigned int)6: 
                              #line 7130 
        ;
        #line 7132 
        hwstats->pxonrxc[i] += (unsigned long long)ixgbe_read_reg(hw,(i + 4176U) * 4U);
        #line 7133 
        break;
        #line 7134 
        default: 
                 #line 7134 
        ;
        #line 7135 
        break;
      }
    }
    #line 7110 
    i ++;
  }
  #line 7140 
  i = 0U;
  #line 7140 
  while (i <= 15U) {
    {
      #line 7141 
      hwstats->qptc[i] += (unsigned long long)ixgbe_read_reg(hw,i * 64U + 24624U);
      #line 7142 
      hwstats->qprc[i] += (unsigned long long)ixgbe_read_reg(hw,i * 64U + 4144U);
      #line 7146 
      if ((unsigned int)hw->mac.type + 4294967294U <= 4U) {
        #line 7148 
        hwstats->qbtc[i] += (unsigned long long)ixgbe_read_reg(hw,(i + 4320U) * 8U);
        #line 7149 
        ixgbe_read_reg(hw,i * 8U + 34564U);
        #line 7150 
        hwstats->qbrc[i] += (unsigned long long)ixgbe_read_reg(hw,i * 64U + 4148U);
        #line 7151 
        ixgbe_read_reg(hw,i * 64U + 4152U);
      }
    }
    #line 7140 
    i ++;
  }
  #line 7155 
  hwstats->gprc += (unsigned long long)ixgbe_read_reg(hw,16500U);
  #line 7157 
  hwstats->gprc -= (unsigned long long)missed_rx;
  #line 7159 
  ixgbe_update_xoff_received(adapter);
  #line 7162 
  switch ((unsigned int)hw->mac.type) {
    #line 7163 
    case (unsigned int)1: 
                          #line 7163 
    ;
    #line 7164 
    hwstats->lxonrxc += (unsigned long long)ixgbe_read_reg(hw,53088U);
    #line 7165 
    hwstats->gorc += (unsigned long long)ixgbe_read_reg(hw,16524U);
    #line 7166 
    hwstats->gotc += (unsigned long long)ixgbe_read_reg(hw,16532U);
    #line 7167 
    hwstats->tor += (unsigned long long)ixgbe_read_reg(hw,16580U);
    #line 7168 
    break;
    #line 7169 
    case (unsigned int)3: 
                          #line 7169 
    ;
    #line 7170 
    case (unsigned int)4: 
                          #line 7170 
    ;
    #line 7171 
    case (unsigned int)5: 
                          #line 7171 
    ;
    #line 7172 
    case (unsigned int)6: 
                          #line 7172 
    ;
    #line 7174 
    hwstats->o2bgptc += (unsigned long long)ixgbe_read_reg(hw,16836U);
    #line 7175 
    hwstats->o2bspc += (unsigned long long)ixgbe_read_reg(hw,34736U);
    #line 7176 
    hwstats->b2ospc += (unsigned long long)ixgbe_read_reg(hw,16832U);
    #line 7177 
    hwstats->b2ogprc += (unsigned long long)ixgbe_read_reg(hw,12176U);
    #line 7179 
    case (unsigned int)2: 
                          #line 7179 
    ;
    #line 7180 
    i = 0U;
    #line 7180 
    while (i <= 15U) {
      #line 7182 
      adapter->hw_rx_no_dma_resources += (unsigned long long)ixgbe_read_reg(hw,i * 64U + 5168U);
      #line 7180 
      i ++;
    }
    #line 7183 
    hwstats->gorc += (unsigned long long)ixgbe_read_reg(hw,16520U);
    #line 7184 
    ixgbe_read_reg(hw,16524U);
    #line 7185 
    hwstats->gotc += (unsigned long long)ixgbe_read_reg(hw,16528U);
    #line 7186 
    ixgbe_read_reg(hw,16532U);
    #line 7187 
    hwstats->tor += (unsigned long long)ixgbe_read_reg(hw,16576U);
    #line 7188 
    ixgbe_read_reg(hw,16580U);
    #line 7189 
    hwstats->lxonrxc += (unsigned long long)ixgbe_read_reg(hw,16804U);
    #line 7190 
    hwstats->fdirmatch += (unsigned long long)ixgbe_read_reg(hw,61016U);
    #line 7191 
    hwstats->fdirmiss += (unsigned long long)ixgbe_read_reg(hw,61020U);
    #line 7193 
    hwstats->fccrc += (unsigned long long)ixgbe_read_reg(hw,20760U);
    #line 7194 
    hwstats->fcoerpdc += (unsigned long long)ixgbe_read_reg(hw,9244U);
    #line 7195 
    hwstats->fcoeprc += (unsigned long long)ixgbe_read_reg(hw,9256U);
    #line 7196 
    hwstats->fcoeptc += (unsigned long long)ixgbe_read_reg(hw,34692U);
    #line 7197 
    hwstats->fcoedwrc += (unsigned long long)ixgbe_read_reg(hw,9260U);
    #line 7198 
    hwstats->fcoedwtc += (unsigned long long)ixgbe_read_reg(hw,34696U);
    #line 7200 
    if (adapter->fcoe.ddp_pool != (struct ixgbe_fcoe_ddp_pool *)0) {
      #line 7202 
      struct ixgbe_fcoe_ddp_pool *ddp_pool;
      #line 7203 
      unsigned int cpu;
      #line 7201 
      struct ixgbe_fcoe *fcoe = & adapter->fcoe;
      #line 7204 
      u64 noddp = 0ULL;
      #line 7204 
      u64 noddp_ext_buff = 0ULL;
      #line 7205 
      cpu = 4294967295U;
      #line 7205 
      while (1) {
        #line 7205 
        cpu = cpumask_next((int)cpu,& __cpu_possible_mask);
        #line 7205 
        if (! (cpu < nr_cpu_ids)) 
                                  #line 7205 
                                  break;
        {
          #line 7206 
          unsigned long __ptr;
          {
            #line 7206 
            void *__vpp_verify = (void *)0;
            #line 7206 
            void *tmp_35 = __vpp_verify;
          }
          #line 7207 
          ldv_inline_asm();
          #line 7206 
          ddp_pool = ((struct ixgbe_fcoe_ddp_pool *)(__per_cpu_offset[cpu] + __ptr));
          #line 7207 
          noddp = ddp_pool->noddp + noddp;
          #line 7208 
          noddp_ext_buff = ddp_pool->noddp_ext_buff + noddp_ext_buff;
        }
      }
      #line 7210 
      hwstats->fcoe_noddp = noddp;
      #line 7211 
      hwstats->fcoe_noddp_ext_buff = noddp_ext_buff;
    }
    #line 7214 
    break;
    #line 7215 
    default: 
             #line 7215 
    ;
    #line 7216 
    break;
  }
  #line 7218 
  bprc = ixgbe_read_reg(hw,16504U);
  #line 7219 
  hwstats->bprc += (unsigned long long)bprc;
  #line 7220 
  hwstats->mprc += (unsigned long long)ixgbe_read_reg(hw,16508U);
  #line 7221 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) 
                                                       #line 7222 
                                                       hwstats->mprc -= (unsigned long long)bprc;
  #line 7223 
  hwstats->roc += (unsigned long long)ixgbe_read_reg(hw,16556U);
  #line 7224 
  hwstats->prc64 += (unsigned long long)ixgbe_read_reg(hw,16476U);
  #line 7225 
  hwstats->prc127 += (unsigned long long)ixgbe_read_reg(hw,16480U);
  #line 7226 
  hwstats->prc255 += (unsigned long long)ixgbe_read_reg(hw,16484U);
  #line 7227 
  hwstats->prc511 += (unsigned long long)ixgbe_read_reg(hw,16488U);
  #line 7228 
  hwstats->prc1023 += (unsigned long long)ixgbe_read_reg(hw,16492U);
  #line 7229 
  hwstats->prc1522 += (unsigned long long)ixgbe_read_reg(hw,16496U);
  #line 7230 
  hwstats->rlec += (unsigned long long)ixgbe_read_reg(hw,16448U);
  #line 7231 
  lxon = ixgbe_read_reg(hw,16224U);
  #line 7232 
  hwstats->lxontxc += (unsigned long long)lxon;
  #line 7233 
  lxoff = ixgbe_read_reg(hw,16232U);
  #line 7234 
  hwstats->lxofftxc += (unsigned long long)lxoff;
  #line 7235 
  hwstats->gptc += (unsigned long long)ixgbe_read_reg(hw,16512U);
  #line 7236 
  hwstats->mptc += (unsigned long long)ixgbe_read_reg(hw,16624U);
  #line 7240 
  xon_off_tot = lxon + lxoff;
  #line 7241 
  hwstats->gptc -= (unsigned long long)xon_off_tot;
  #line 7242 
  hwstats->mptc -= (unsigned long long)xon_off_tot;
  #line 7243 
  hwstats->gotc -= (unsigned long long)(xon_off_tot * 64U);
  #line 7244 
  hwstats->ruc += (unsigned long long)ixgbe_read_reg(hw,16548U);
  #line 7245 
  hwstats->rfc += (unsigned long long)ixgbe_read_reg(hw,16552U);
  #line 7246 
  hwstats->rjc += (unsigned long long)ixgbe_read_reg(hw,16560U);
  #line 7247 
  hwstats->tpr += (unsigned long long)ixgbe_read_reg(hw,16592U);
  #line 7248 
  hwstats->ptc64 += (unsigned long long)ixgbe_read_reg(hw,16600U);
  #line 7249 
  hwstats->ptc64 -= (unsigned long long)xon_off_tot;
  #line 7250 
  hwstats->ptc127 += (unsigned long long)ixgbe_read_reg(hw,16604U);
  #line 7251 
  hwstats->ptc255 += (unsigned long long)ixgbe_read_reg(hw,16608U);
  #line 7252 
  hwstats->ptc511 += (unsigned long long)ixgbe_read_reg(hw,16612U);
  #line 7253 
  hwstats->ptc1023 += (unsigned long long)ixgbe_read_reg(hw,16616U);
  #line 7254 
  hwstats->ptc1522 += (unsigned long long)ixgbe_read_reg(hw,16620U);
  #line 7255 
  hwstats->bptc += (unsigned long long)ixgbe_read_reg(hw,16628U);
  #line 7258 
  netdev->stats.multicast = (unsigned long)hwstats->mprc;
  #line 7261 
  netdev->stats.rx_errors = (unsigned long)(hwstats->crcerrs + hwstats->rlec);
  #line 7262 
  netdev->stats.rx_dropped = 0UL;
  #line 7263 
  netdev->stats.rx_length_errors = (unsigned long)hwstats->rlec;
  #line 7264 
  netdev->stats.rx_crc_errors = (unsigned long)hwstats->crcerrs;
  #line 7265 
  netdev->stats.rx_missed_errors = (unsigned long)total_mpc;
  #line 7266 
  return;
}

#line 7272  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_fdir_reinit_subtask(struct ixgbe_adapter *adapter)
{
  #line 7275 
  int i;
  #line 7274 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 7277 
  if (((unsigned long)adapter->flags2 & 128UL) == 0UL) 
                                                       #line 7278 
                                                       return;
  #line 7280 
  adapter->flags2 &= 4294967167U;
  #line 7283 
  if ((int)test_bit(2L,& adapter->state) != 0) 
                                               #line 7284 
                                               return;
  #line 7287 
  if (((unsigned long)adapter->flags & 262144UL) == 0UL) 
                                                         #line 7288 
                                                         return;
  #line 7290 
  (adapter->fdir_overflow) ++;
  #line 7292 
  if (ixgbe_reinit_fdir_tables_82599(hw) == 0) {
    #line 7293 
    i = 0;
    #line 7293 
    while (adapter->num_tx_queues > i) {
      #line 7294 
      cif_set_bit(5L,& (adapter->tx_ring[i])->state);
      #line 7293 
      i ++;
    }
    #line 7296 
    i = 0;
    #line 7296 
    while (adapter->num_xdp_queues > i) {
      #line 7297 
      cif_set_bit(5L,& (adapter->xdp_ring[i])->state);
      #line 7296 
      i ++;
    }
    #line 7300 
    ixgbe_write_reg_1(hw,2176U,65536U);
  }
  else 
    #line 7302 
    if (((int)adapter->msg_enable & 2) != 0) 
                                             #line 7302 
                                             netdev_err(adapter->netdev,(char *)"failed to finish FDIR re-initialization, ");
  #line 7303 
  return;
}

#line 7316  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_hang_subtask(struct ixgbe_adapter *adapter)
{
  #line 7320 
  int i;
  #line 7318 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 7319 
  u64 eics = 0ULL;
  #line 7323 
  if ((int)test_bit(2L,& adapter->state) != 0) 
                                               #line 7326 
                                               return;
  else {
    #line 7323 
    if ((int)test_bit(4L,& adapter->state) != 0) 
                                                 #line 7326 
                                                 return;
    else {
      #line 7324 
      if ((int)test_bit(1L,& adapter->state) != 0) 
                                                   #line 7326 
                                                   return;
    }
  }
  #line 7329 
  if ((int)netif_carrier_ok(adapter->netdev) != 0) {
    #line 7330 
    i = 0;
    #line 7330 
    while (adapter->num_tx_queues > i) {
      #line 7331 
      cif_set_bit(7L,& (adapter->tx_ring[i])->state);
      #line 7330 
      i ++;
    }
    #line 7332 
    i = 0;
    #line 7332 
    while (adapter->num_xdp_queues > i) {
      #line 7333 
      cif_set_bit(7L,& (adapter->xdp_ring[i])->state);
      #line 7332 
      i ++;
    }
  }
  #line 7336 
  if (((unsigned long)adapter->flags & 8UL) == 0UL) 
                                                    #line 7342 
                                                    ixgbe_write_reg_1(hw,2056U,3221225472U);
  else {
    #line 7346 
    i = 0;
    #line 7346 
    while (adapter->num_q_vectors > i) {
      {
        #line 7347 
        struct ixgbe_q_vector *qv = adapter->q_vector[i];
        #line 7348 
        if (qv->rx.ring != (struct ixgbe_ring *)0 || qv->tx.ring != (struct ixgbe_ring *)0) 
          #line 7349 
          eics = (1ULL << i) | eics;
      }
      #line 7346 
      i ++;
    }
  }
  #line 7354 
  ixgbe_irq_rearm_queues(adapter,eics);
  #line 7355 
  return;
}

#line 7361  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_watchdog_update_link(struct ixgbe_adapter *adapter)
{
  #line 7363 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 7364 
  u32 link_speed = adapter->link_speed;
  #line 7365 
  bool link_up = adapter->link_up;
  #line 7366 
  bool pfc_en = adapter->dcb_cfg.pfc_mode_enable;
  #line 7368 
  if (((unsigned long)adapter->flags & 65536UL) == 0UL) 
                                                        #line 7369 
                                                        return;
  #line 7371 
  if (hw->mac.ops.check_link != (s32 (*)(struct ixgbe_hw *, ixgbe_link_speed *, bool *, bool ))0) 
    #line 7372 
    (*(hw->mac.ops.check_link))(hw,& link_speed,& link_up,(_Bool)0);
  else {
    #line 7375 
    link_speed = 128U;
    #line 7376 
    link_up = (_Bool)1;
  }
  #line 7379 
  if (adapter->ixgbe_ieee_pfc != (struct ieee_pfc *)0) 
                                                       #line 7380 
                                                       pfc_en = (_Bool)(((int)pfc_en | ((unsigned int)(adapter->ixgbe_ieee_pfc)->pfc_en != 0U)) != 0);
  #line 7382 
  if ((int)link_up != 0 && (((unsigned long)adapter->flags & 4096UL) == 0UL || ! pfc_en)) {
    #line 7383 
    (*(hw->mac.ops.fc_enable))(hw);
    #line 7384 
    ixgbe_set_rx_drop_en(adapter);
  }
  #line 7387 
  if ((int)link_up != 0) 
                         #line 7387 
                         goto _LOR;
  else {
    {
      #line 7388 
      unsigned long __dummy;
      #line 7388 
      unsigned long __dummy2;
      }
    #line 7387 
    if (1 != 0) {
      {
        #line 7388 
        unsigned long __dummy_0;
        #line 7388 
        unsigned long __dummy2_0;
        }
      #line 7388 
      if (1 != 0) 
        #line 7388 
        if ((long)((adapter->link_check_timeout - jiffies) + 1000UL) < 0L) {
          #line 7387 
          _LOR: {
                  #line 7390 
                  adapter->flags &= 4294901759U;
                  #line 7391 
                  ixgbe_write_reg_1(hw,2176U,1048576U);
                  #line 7392 
                  ixgbe_read_reg(hw,8U);
                }
        }
    }
  }
  #line 7395 
  adapter->link_up = link_up;
  #line 7396 
  adapter->link_speed = link_speed;
  #line 7397 
  return;
}

#line 7399  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_update_default_up(struct ixgbe_adapter *adapter)
{
  #line 7402 
  struct net_device *netdev = adapter->netdev;
  #line 7403 
  struct dcb_app app = {.selector = (unsigned char)1U, .priority = (unsigned char)0, .protocol = (unsigned short)0U};
  #line 7407 
  u8 up = (unsigned char)0U;
  #line 7409 
  if (((int)adapter->dcbx_cap & 8) != 0) 
                                         #line 7410 
                                         up = dcb_ieee_getapp_mask(netdev,& app);
  #line 7412 
  if ((unsigned int)up > 1U) {
    #line 7412 
    adapter->default_up = (unsigned char)((unsigned int)((unsigned char)ffs((int)up)) + 255U);
  }
  else 
       #line 7412 
       adapter->default_up = (unsigned char)0U;
  #line 7413 
  return;
}

#line 7421  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_watchdog_link_is_up(struct ixgbe_adapter *adapter)
{
  #line 7426 
  char *speed_str;
  #line 7427 
  bool flow_rx;
  #line 7427 
  bool flow_tx;
  #line 7423 
  struct net_device *netdev = adapter->netdev;
  #line 7424 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 7425 
  u32 link_speed = adapter->link_speed;
  #line 7430 
  if ((int)netif_carrier_ok(netdev) != 0) 
                                          #line 7431 
                                          return;
  #line 7433 
  adapter->flags2 &= 4294967279U;
  #line 7435 
  switch ((unsigned int)hw->mac.type) {
    #line 7436 
    case (unsigned int)1: 
                          #line 7436 
    ;
    {
      #line 7437 
      u32 frctl = ixgbe_read_reg(hw,20608U);
      #line 7438 
      u32 rmcs = ixgbe_read_reg(hw,15616U);
      #line 7439 
      flow_rx = (_Bool)((frctl & 32768U) != 0U);
      #line 7440 
      flow_tx = (_Bool)((rmcs & 8U) != 0U);
    }
    #line 7442 
    break;
    #line 7443 
    case (unsigned int)3: 
                          #line 7443 
    ;
    #line 7444 
    case (unsigned int)4: 
                          #line 7444 
    ;
    #line 7445 
    case (unsigned int)5: 
                          #line 7445 
    ;
    #line 7446 
    case (unsigned int)6: 
                          #line 7446 
    ;
    #line 7447 
    case (unsigned int)2: 
                          #line 7447 
    ;
    {
      #line 7448 
      u32 mflcn = ixgbe_read_reg(hw,17044U);
      #line 7449 
      u32 fccfg = ixgbe_read_reg(hw,15616U);
      #line 7450 
      flow_rx = (_Bool)((mflcn & 8U) != 0U);
      #line 7451 
      flow_tx = (_Bool)((fccfg & 8U) != 0U);
    }
    #line 7453 
    break;
    #line 7454 
    default: 
             #line 7454 
    ;
    #line 7455 
    flow_tx = (_Bool)0;
    #line 7456 
    flow_rx = (_Bool)0;
    #line 7457 
    break;
  }
  #line 7460 
  adapter->last_rx_ptp_check = jiffies;
  #line 7462 
  if ((int)test_bit(8L,& adapter->state) != 0) 
                                               #line 7463 
                                               ixgbe_ptp_start_cyclecounter(adapter);
  #line 7465 
  switch (link_speed) {
    #line 7466 
    case (u32)128: 
                   #line 7466 
    ;
    #line 7467 
    speed_str = (char *)"10 Gbps";
    #line 7468 
    break;
    #line 7469 
    case (u32)2048: 
                    #line 7469 
    ;
    #line 7470 
    speed_str = (char *)"5 Gbps";
    #line 7471 
    break;
    #line 7472 
    case (u32)1024: 
                    #line 7472 
    ;
    #line 7473 
    speed_str = (char *)"2.5 Gbps";
    #line 7474 
    break;
    #line 7475 
    case (u32)32: 
                  #line 7475 
    ;
    #line 7476 
    speed_str = (char *)"1 Gbps";
    #line 7477 
    break;
    #line 7478 
    case (u32)8: 
                 #line 7478 
    ;
    #line 7479 
    speed_str = (char *)"100 Mbps";
    #line 7480 
    break;
    #line 7481 
    case (u32)2: 
                 #line 7481 
    ;
    #line 7482 
    speed_str = (char *)"10 Mbps";
    #line 7483 
    break;
    #line 7484 
    default: 
             #line 7484 
    ;
    #line 7485 
    speed_str = (char *)"unknown speed";
    #line 7486 
    break;
  }
  #line 7488 
  if (((int)adapter->msg_enable & 1) != 0) {
    #line 7488 
    char *tmp_6;
    #line 7488 
    char *tmp_7;
    #line 7488 
    if ((int)flow_rx == 0 || (int)flow_tx == 0) {
      #line 7488 
      if (flow_rx) 
                   #line 7488 
                   tmp_6 = (char *)"RX";
      else {
        #line 7488 
        char *tmp_5;
        #line 7488 
        if ((int)flow_tx != 0) 
                               #line 7488 
                               tmp_5 = (char *)"TX"; else 
                                                          #line 7488 
                                                          tmp_5 = (char *)"None";
        #line 7488 
        tmp_6 = tmp_5;
      }
      #line 7488 
      tmp_7 = tmp_6;
    }
    else 
         #line 7488 
         tmp_7 = (char *)"RX/TX";
    #line 7488 
    ;
    #line 7488 
    ;
    #line 7488 
    netdev_info(adapter->netdev,(char *)"NIC Link is Up %s, Flow Control: %s\n",speed_str,tmp_7);
  }
  #line 7493 
  netif_carrier_on(netdev);
  #line 7494 
  ixgbe_check_vf_rate_limit(adapter);
  #line 7497 
  netif_tx_wake_all_queues(adapter->netdev);
  #line 7500 
  ixgbe_update_default_up(adapter);
  #line 7503 
  ixgbe_ping_all_vfs(adapter);
  #line 7504 
  return;
}

#line 7511  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_watchdog_link_is_down(struct ixgbe_adapter *adapter)
{
  #line 7513 
  struct net_device *netdev = adapter->netdev;
  #line 7514 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 7516 
  adapter->link_up = (_Bool)0;
  #line 7517 
  adapter->link_speed = 0U;
  #line 7520 
  if (! netif_carrier_ok(netdev)) 
                                  #line 7521 
                                  return;
  #line 7524 
  if ((int)ixgbe_is_sfp(hw) != 0) 
    #line 7524 
    if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) 
                                                         #line 7525 
                                                         adapter->flags2 |= 16U;
  #line 7527 
  if ((int)test_bit(8L,& adapter->state) != 0) 
                                               #line 7528 
                                               ixgbe_ptp_start_cyclecounter(adapter);
  #line 7530 
  if (((int)adapter->msg_enable & 1) != 0) 
                                           #line 7530 
                                           netdev_info(adapter->netdev,(char *)"NIC Link is Down\n");
  #line 7531 
  netif_carrier_off(netdev);
  #line 7534 
  ixgbe_ping_all_vfs(adapter);
  #line 7535 
  return;
}

#line 7537  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static bool ixgbe_ring_tx_pending(struct ixgbe_adapter *adapter)
{
  #line 7539 
  int i;
  #line 7541 
  i = 0;
  #line 7541 
  while (adapter->num_tx_queues > i) {
    {
      #line 7542 
      struct ixgbe_ring *tx_ring = adapter->tx_ring[i];
      #line 7544 
      if ((int)tx_ring->next_to_use != (int)tx_ring->next_to_clean) 
                                                                    #line 7545 
                                                                    return (_Bool)1;
    }
    #line 7541 
    i ++;
  }
  #line 7548 
  i = 0;
  #line 7548 
  while (adapter->num_xdp_queues > i) {
    {
      #line 7549 
      struct ixgbe_ring *ring = adapter->xdp_ring[i];
      #line 7551 
      if ((int)ring->next_to_use != (int)ring->next_to_clean) 
                                                              #line 7552 
                                                              return (_Bool)1;
    }
    #line 7548 
    i ++;
  }
  #line 7555 
  return (_Bool)0;
}

#line 7558  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static bool ixgbe_vf_tx_pending(struct ixgbe_adapter *adapter)
{
  #line 7564 
  int i;
  #line 7564 
  int j;
  #line 7560 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 7561 
  struct ixgbe_ring_feature *vmdq = & adapter->ring_feature[1];
  #line 7562 
  u32 q_per_pool = (unsigned int)(- ((int)vmdq->mask) & (int)vmdq->mask);
  #line 7566 
  if (adapter->num_vfs == 0U) 
                              #line 7567 
                              return (_Bool)0;
  #line 7570 
  if (hw->mac.type > (unsigned int)ixgbe_mac_X540) 
                                                   #line 7571 
                                                   return (_Bool)0;
  #line 7573 
  i = 0;
  #line 7573 
  while (adapter->num_vfs > (unsigned int)i) {
    #line 7574 
    j = 0;
    #line 7574 
    while ((unsigned int)j < q_per_pool) {
      {
        #line 7575 
        u32 h;
        #line 7575 
        u32 t;
        #line 7577 
        h = ixgbe_read_reg(hw,(q_per_pool * (unsigned int)i + (unsigned int)j) * 64U + 24592U);
        #line 7578 
        t = ixgbe_read_reg(hw,(q_per_pool * (unsigned int)i + (unsigned int)j) * 64U + 24600U);
        #line 7580 
        if (h != t) 
                    #line 7581 
                    return (_Bool)1;
      }
      #line 7574 
      j ++;
    }
    #line 7573 
    i ++;
  }
  #line 7585 
  return (_Bool)0;
}

#line 7592  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_watchdog_flush_tx(struct ixgbe_adapter *adapter)
{
  #line 7594 
  if (! netif_carrier_ok(adapter->netdev)) {
    #line 7595 
    if ((int)ixgbe_ring_tx_pending(adapter) != 0) 
                                                  #line 7595 
                                                  goto _LOR;
    else {
      #line 7595 
      if ((int)ixgbe_vf_tx_pending(adapter) != 0) {
        #line 7595 
        _LOR: {
                #line 7602 
                if (((int)adapter->msg_enable & 1) != 0) 
                                                         #line 7602 
                                                         netdev_warn(adapter->netdev,(char *)"initiating reset to clear Tx work after link loss\n");
                #line 7603 
                cif_set_bit(10L,& adapter->state);
              }
      }
    }
  }
  #line 7605 
  return;
}

#line 7609  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_for_bad_vf(struct ixgbe_adapter *adapter)
{
  #line 7613 
  unsigned int vf;
  #line 7614 
  u32 gpc;
  #line 7611 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 7612 
  struct pci_dev *pdev = adapter->pdev;
  #line 7616 
  if (! netif_carrier_ok(adapter->netdev)) 
                                           #line 7617 
                                           return;
  #line 7619 
  gpc = ixgbe_read_reg(hw,34720U);
  #line 7620 
  if (gpc != 0U) 
                 #line 7621 
                 return;
  #line 7628 
  if (pdev == (struct pci_dev *)0) 
                                   #line 7629 
                                   return;
  #line 7632 
  vf = 0U;
  #line 7632 
  while (adapter->num_vfs > vf) {
    {
      #line 7634 
      u16 status_reg;
      #line 7633 
      struct pci_dev *vfdev = (adapter->vfinfo + (unsigned long)vf)->vfdev;
      #line 7636 
      if (vfdev == (struct pci_dev *)0) 
                                        #line 7637 
                                        goto __Cont;
      #line 7638 
      pci_read_config_word(vfdev,6,& status_reg);
      #line 7639 
      if ((unsigned int)status_reg != 65535U && ((int)status_reg & 8192) != 0) 
        #line 7641 
        pcie_flr(vfdev);
    }
    #line 7632 
    __Cont: 
            #line 7632 
    vf ++;
  }
  #line 7643 
  return;
}

#line 7645  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_spoof_check(struct ixgbe_adapter *adapter)
{
  #line 7647 
  u32 ssvpc;
  #line 7650 
  if (adapter->hw.mac.type == (unsigned int)ixgbe_mac_82598EB || adapter->num_vfs == 0U) 
    #line 7652 
    return;
  #line 7654 
  ssvpc = ixgbe_read_reg(& adapter->hw,34688U);
  #line 7660 
  if (ssvpc == 0U) 
                   #line 7661 
                   return;
  #line 7663 
  if (((int)adapter->msg_enable & 1) != 0) 
                                           #line 7663 
                                           netdev_warn(adapter->netdev,(char *)"%u Spoofed packets detected\n",ssvpc);
  #line 7664 
  return;
}

#line 7681  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_watchdog_subtask(struct ixgbe_adapter *adapter)
{
  #line 7684 
  if ((int)test_bit(2L,& adapter->state) != 0) 
                                               #line 7687 
                                               return;
  else {
    #line 7684 
    if ((int)test_bit(4L,& adapter->state) != 0) 
                                                 #line 7687 
                                                 return;
    else {
      #line 7685 
      if ((int)test_bit(1L,& adapter->state) != 0) 
                                                   #line 7687 
                                                   return;
    }
  }
  #line 7689 
  ixgbe_watchdog_update_link(adapter);
  #line 7691 
  if ((int)adapter->link_up != 0) 
                                  #line 7692 
                                  ixgbe_watchdog_link_is_up(adapter); else 
                                                                    #line 7694 
                                                                    ixgbe_watchdog_link_is_down(adapter);
  #line 7696 
  ixgbe_check_for_bad_vf(adapter);
  #line 7697 
  ixgbe_spoof_check(adapter);
  #line 7698 
  ixgbe_update_stats(adapter);
  #line 7700 
  ixgbe_watchdog_flush_tx(adapter);
  #line 7701 
  return;
}

#line 7707  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_sfp_detection_subtask(struct ixgbe_adapter *adapter)
{
  #line 7710 
  s32 err;
  #line 7709 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 7713 
  if (((unsigned long)adapter->flags2 & 16UL) == 0UL && ((unsigned long)adapter->flags2 & 32UL) == 0UL) 
    #line 7715 
    return;
  {
    #line 7718 
    unsigned long __dummy;
    #line 7718 
    unsigned long __dummy2;
    }
  #line 7717 
  if (1 != 0) {
    {
      #line 7718 
      unsigned long __dummy_0;
      #line 7718 
      unsigned long __dummy2_0;
      }
    #line 7718 
    if (1 != 0) 
      #line 7718 
      if ((long)(jiffies - adapter->sfp_poll_time) < 0L) 
        #line 7717 
        if (adapter->sfp_poll_time != 0UL) 
                                           #line 7719 
                                           return;
  }
  #line 7722 
  if ((int)test_and_set_bit(7L,& adapter->state) != 0) 
                                                       #line 7723 
                                                       return;
  #line 7725 
  adapter->sfp_poll_time = jiffies + 499UL;
  #line 7727 
  err = (*(hw->phy.ops.identify_sfp))(hw);
  #line 7728 
  if (err == -19) 
                  #line 7729 
                  goto sfp_out;
  #line 7731 
  if (err == -20) 
                  #line 7734 
                  adapter->flags2 |= 32U;
  #line 7738 
  if (err != 0) 
                #line 7739 
                goto sfp_out;
  #line 7742 
  if (((unsigned long)adapter->flags2 & 32UL) == 0UL) 
                                                      #line 7743 
                                                      goto sfp_out;
  #line 7745 
  adapter->flags2 &= 4294967263U;
  #line 7752 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) 
                                                       #line 7753 
                                                       err = (*(hw->phy.ops.reset))(hw); else 
                                                                    #line 7755 
                                                                    err = (*(hw->mac.ops.setup_sfp))(hw);
  #line 7757 
  if (err == -19) 
                  #line 7758 
                  goto sfp_out;
  #line 7760 
  adapter->flags |= 131072U;
  #line 7761 
  if (((int)adapter->msg_enable & 2) != 0) 
                                           #line 7761 
                                           netdev_info(adapter->netdev,(char *)"detected SFP+: %d\n",(unsigned int)hw->phy.sfp_type);
  #line 7763 
  sfp_out: 
           #line 7763 
  ;
  #line 7764 
  cif_clear_bit(7L,& adapter->state);
  #line 7766 
  if (err == -19 && (unsigned int)(adapter->netdev)->reg_state == 1U) {
    #line 7768 
    _dev_err(& (adapter->pdev)->dev,(char *)"failed to initialize because an unsupported ");
    #line 7770 
    _dev_err(& (adapter->pdev)->dev,(char *)"Reload the driver after installing a ");
    #line 7772 
    cif_unregister_netdev(adapter->netdev);
  }
  #line 7774 
  return;
}

#line 7780  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_sfp_link_config_subtask(struct ixgbe_adapter *adapter)
{
  #line 7783 
  u32 cap_speed;
  #line 7784 
  u32 speed;
  #line 7782 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 7785 
  bool autoneg = (_Bool)0;
  #line 7787 
  if (((unsigned long)adapter->flags & 131072UL) == 0UL) 
                                                         #line 7788 
                                                         return;
  #line 7791 
  if ((int)test_and_set_bit(7L,& adapter->state) != 0) 
                                                       #line 7792 
                                                       return;
  #line 7794 
  adapter->flags &= 4294836223U;
  #line 7796 
  (*(hw->mac.ops.get_link_capabilities))(hw,& cap_speed,& autoneg);
  #line 7799 
  if (! autoneg && (cap_speed & 128U) != 0U) 
                                             #line 7800 
                                             speed = 128U; else 
                                                                #line 7802 
                                                                speed = cap_speed & 160U;
  #line 7805 
  if (hw->mac.ops.setup_link != (s32 (*)(struct ixgbe_hw *, ixgbe_link_speed , bool ))0) 
    #line 7806 
    (*(hw->mac.ops.setup_link))(hw,speed,(_Bool)1);
  #line 7808 
  adapter->flags |= 65536U;
  #line 7809 
  adapter->link_check_timeout = jiffies;
  #line 7810 
  cif_clear_bit(7L,& adapter->state);
  #line 7811 
  return;
}

#line 7817  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_service_timer(struct timer_list *t)
{
  #line 7819 
  void *__mptr;
  #line 7820 
  unsigned long next_event_offset;
  #line 7819 
  __mptr = (void *)t;
  #line 7819 
  struct ixgbe_adapter *adapter = ((struct ixgbe_adapter *)(__mptr + 18446744073709511168U));
  #line 7823 
  if (((unsigned long)adapter->flags & 65536UL) != 0UL) 
                                                        #line 7824 
                                                        next_event_offset = 25UL; else 
                                                                    #line 7826 
                                                                    next_event_offset = 500UL;
  #line 7829 
  cif_mod_timer(& adapter->service_timer,next_event_offset + jiffies);
  #line 7831 
  ixgbe_service_event_schedule(adapter);
  #line 7832 
  return;
}

#line 7834  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_phy_interrupt_subtask(struct ixgbe_adapter *adapter)
{
  #line 7837 
  u32 status;
  #line 7836 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 7839 
  if (((unsigned long)adapter->flags2 & 2048UL) == 0UL) 
                                                        #line 7840 
                                                        return;
  #line 7842 
  adapter->flags2 &= 4294965247U;
  #line 7844 
  if (hw->phy.ops.handle_lasi == (s32 (*)(struct ixgbe_hw *))0) 
                                                                #line 7845 
                                                                return;
  #line 7847 
  status = (unsigned int)(*(hw->phy.ops.handle_lasi))(& adapter->hw);
  #line 7848 
  if (status != 4294967270U) 
                             #line 7849 
                             return;
  #line 7851 
  if (((int)adapter->msg_enable & 1) != 0) 
                                           #line 7851 
                                           netdev_crit(adapter->netdev,(char *)"%s\n",(char *)(& ixgbe_overheat_msg));
  #line 7852 
  return;
}

#line 7854  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_reset_subtask(struct ixgbe_adapter *adapter)
{
  #line 7856 
  if (! test_and_set_bit(10L,& adapter->state)) 
                                                #line 7857 
                                                return;
  #line 7859 
  rtnl_lock();
  #line 7861 
  if ((int)test_bit(2L,& adapter->state) != 0) 
                                               #line 7861 
                                               goto _LOR;
  else {
    #line 7861 
    if ((int)test_bit(4L,& adapter->state) != 0) 
                                                 #line 7861 
                                                 goto _LOR;
    else {
      #line 7862 
      if ((int)test_bit(1L,& adapter->state) != 0) {
        #line 7861 
        _LOR: {
                #line 7864 
                rtnl_unlock();
                #line 7865 
                return;
              }
      }
    }
  }
  #line 7868 
  ixgbe_dump(adapter);
  #line 7869 
  netdev_err(adapter->netdev,(char *)"Reset adapter\n");
  #line 7870 
  (adapter->tx_timeout_count) ++;
  #line 7872 
  ixgbe_reinit_locked(adapter);
  #line 7873 
  rtnl_unlock();
  #line 7874 
  return;
}

#line 7882  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static bool ixgbe_check_fw_error(struct ixgbe_adapter *adapter)
{
  #line 7885 
  u32 fwsm;
  #line 7884 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 7888 
  fwsm = ixgbe_read_reg(hw,*(hw->mvals + 6U));
  #line 7890 
  if ((fwsm & 33030144U) != 0U || ((unsigned long)fwsm & 32768UL) == 0UL) 
    #line 7892 
    _dev_warn(& (adapter->pdev)->dev,(char *)"Warning firmware error detected FWSM: 0x%08X\n",fwsm);
  #line 7895 
  if (hw->mac.ops.fw_recovery_mode != (bool (*)(struct ixgbe_hw *))0) {
    #line 7895 
    if ((int)(*(hw->mac.ops.fw_recovery_mode))(hw) != 0) {
      #line 7896 
      _dev_err(& (adapter->pdev)->dev,(char *)"Firmware recovery mode detected. Limiting functionality. Refer to the Intel(R) Ethernet Adapters and Devices User Guide for details on firmware recovery mode.\n");
      #line 7897 
      return (_Bool)1;
    }
  }
  #line 7900 
  return (_Bool)0;
}

#line 7907  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_service_task(struct work_struct *work)
{
  #line 7909 
  void *__mptr;
  #line 7909 
  __mptr = (void *)work;
  #line 7909 
  struct ixgbe_adapter *adapter = ((struct ixgbe_adapter *)(__mptr + 18446744073709511080U));
  #line 7912 
  if ((int)ixgbe_removed((void *)adapter->hw.hw_addr) != 0) {
    #line 7913 
    if (! test_bit(2L,& adapter->state)) {
      #line 7914 
      rtnl_lock();
      #line 7915 
      ixgbe_down(adapter);
      #line 7916 
      rtnl_unlock();
    }
    #line 7918 
    ixgbe_service_event_complete(adapter);
    #line 7919 
    return;
  }
  #line 7921 
  if ((int)ixgbe_check_fw_error(adapter) != 0) {
    #line 7922 
    if (! test_bit(2L,& adapter->state)) 
                                         #line 7923 
                                         cif_unregister_netdev(adapter->netdev);
    #line 7924 
    ixgbe_service_event_complete(adapter);
    #line 7925 
    return;
  }
  #line 7927 
  if (((unsigned long)adapter->flags2 & 4096UL) != 0UL) {
    #line 7928 
    rtnl_lock();
    #line 7929 
    adapter->flags2 &= 4294963199U;
    #line 7930 
    udp_tunnel_get_rx_info(adapter->netdev);
    #line 7931 
    rtnl_unlock();
  }
  #line 7933 
  ixgbe_reset_subtask(adapter);
  #line 7934 
  ixgbe_phy_interrupt_subtask(adapter);
  #line 7935 
  ixgbe_sfp_detection_subtask(adapter);
  #line 7936 
  ixgbe_sfp_link_config_subtask(adapter);
  #line 7937 
  ixgbe_check_overtemp_subtask(adapter);
  #line 7938 
  ixgbe_watchdog_subtask(adapter);
  #line 7939 
  ixgbe_fdir_reinit_subtask(adapter);
  #line 7940 
  ixgbe_check_hang_subtask(adapter);
  #line 7942 
  if ((int)test_bit(8L,& adapter->state) != 0) {
    #line 7943 
    ixgbe_ptp_overflow_check(adapter);
    #line 7944 
    if (((unsigned long)adapter->flags & 67108864UL) != 0UL) 
                                                             #line 7945 
                                                             ixgbe_ptp_rx_hang(adapter);
    #line 7946 
    ixgbe_ptp_tx_hang(adapter);
  }
  #line 7949 
  ixgbe_service_event_complete(adapter);
  #line 7950 
  return;
}

#line 7952  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_tso(struct ixgbe_ring *tx_ring, struct ixgbe_tx_buffer *first, u8 *hdr_len, struct ixgbe_ipsec_tx_data *itd)
{
  #line 7957 
  u32 vlan_macip_lens;
  #line 7957 
  u32 type_tucmd;
  #line 7957 
  u32 mss_l4len_idx;
  #line 7963 
  union __anonunion_ip_2636 ip;
  #line 7968 
  union __anonunion_l4_2637 l4;
  #line 7969 
  u32 paylen;
  #line 7969 
  u32 l4_offset;
  #line 7971 
  int err;
  #line 7958 
  struct sk_buff *skb = first->__anonCompField_ixgbe_tx_buffer_217.skb;
  #line 7970 
  u32 fceof_saidx = 0U;
  #line 7973 
  if ((unsigned int)skb->ip_summed != 3U) 
                                          #line 7974 
                                          return 0;
  #line 7976 
  if (! skb_is_gso(skb)) 
                         #line 7977 
                         return 0;
  #line 7979 
  err = skb_cow_head(skb,0U);
  #line 7980 
  if (err < 0) 
               #line 7981 
               return err;
  #line 7983 
  if ((int)eth_p_mpls((unsigned short)((int)first->protocol)) != 0) 
                                                                    #line 7984 
                                                                    ip.hdr = skb_inner_network_header(skb); else 
                                                                    #line 7986 
                                                                    ip.hdr = skb_network_header(skb);
  #line 7987 
  l4.hdr = skb_checksum_start(skb);
  #line 7990 
  ;
  #line 7990 
  if ((((struct skb_shared_info *)skb_end_pointer(skb))->gso_type & 131072U) != 0U) 
    #line 7990 
    type_tucmd = 0U; else 
                          #line 7990 
                          type_tucmd = 2048U;
  #line 7994 
  if ((unsigned int)(ip.v4)->version == 4U) {
    #line 7995 
    unsigned char *csum_start = skb_checksum_start(skb);
    #line 7996 
    unsigned char *trans_start = ip.hdr + (unsigned long)((int)(ip.v4)->ihl * 4);
    #line 7997 
    int len = (int)(csum_start - trans_start);
    #line 8003 
    ;
    #line 8003 
    if ((((struct skb_shared_info *)skb_end_pointer(skb))->gso_type & 4096U) != 0U) {
      #line 8003 
      (ip.v4)->check = csum_fold(csum_partial((void *)trans_start,len,0U));
    }
    else 
         #line 8003 
         (ip.v4)->check = (unsigned short)0U;
    #line 8006 
    type_tucmd |= 1024U;
    #line 8008 
    (ip.v4)->tot_len = (unsigned short)0U;
    #line 8009 
    first->tx_flags |= 50U;
  }
  else {
    #line 8013 
    (ip.v6)->payload_len = (unsigned short)0U;
    #line 8014 
    first->tx_flags |= 34U;
  }
  #line 8019 
  l4_offset = (unsigned int)(l4.hdr - skb->data);
  #line 8022 
  paylen = skb->len - l4_offset;
  #line 8024 
  if ((type_tucmd & 2048U) != 0U) {
    #line 8026 
    *hdr_len = (unsigned char)((unsigned int)((unsigned char)(l4.tcp)->doff) * 4U + (unsigned int)((unsigned char)l4_offset));
    #line 8027 
    ;
    #line 8027 
    csum_replace_by_diff(& (l4.tcp)->check,__builtin_bswap32(paylen));
  }
  else {
    #line 8031 
    *hdr_len = (unsigned char)((unsigned int)((unsigned char)l4_offset) + 8U);
    #line 8032 
    ;
    #line 8032 
    csum_replace_by_diff(& (l4.udp)->check,__builtin_bswap32(paylen));
  }
  #line 8037 
  first->gso_segs = ((struct skb_shared_info *)skb_end_pointer(skb))->gso_segs;
  #line 8038 
  first->bytecount += (unsigned int)(((int)first->gso_segs + -1) * (int)*hdr_len);
  #line 8041 
  mss_l4len_idx = ((unsigned int)*hdr_len - l4_offset) << 8;
  #line 8042 
  mss_l4len_idx = (unsigned int)((int)((struct skb_shared_info *)skb_end_pointer(skb))->gso_size << 16) | mss_l4len_idx;
  #line 8044 
  fceof_saidx = (unsigned int)itd->sa_idx | fceof_saidx;
  #line 8045 
  type_tucmd = (itd->flags | (unsigned int)itd->trailer_len) | type_tucmd;
  #line 8048 
  vlan_macip_lens = (unsigned int)(l4.hdr - ip.hdr);
  #line 8049 
  vlan_macip_lens = (unsigned int)(((ip.hdr - skb->data) << 9) | (long)vlan_macip_lens);
  #line 8050 
  vlan_macip_lens = (first->tx_flags & 4294901760U) | vlan_macip_lens;
  #line 8052 
  ixgbe_tx_ctxtdesc(tx_ring,vlan_macip_lens,fceof_saidx,type_tucmd,mss_l4len_idx);
  #line 8055 
  return 1;
}

#line 8058  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static bool ixgbe_ipv6_csum_is_sctp(struct sk_buff *skb)
{
  #line 8060 
  unsigned int offset = 0U;
  #line 8062 
  ipv6_find_hdr(skb,& offset,132,(unsigned short *)0U,(int *)0);
  #line 8064 
  ;
  #line 8064 
  return (_Bool)((unsigned int)skb_checksum_start_offset(skb) == offset);
}

#line 8067  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_tx_csum(struct ixgbe_ring *tx_ring, struct ixgbe_tx_buffer *first, struct ixgbe_ipsec_tx_data *itd)
{
  #line 8071 
  struct sk_buff *skb = first->__anonCompField_ixgbe_tx_buffer_217.skb;
  #line 8072 
  u32 vlan_macip_lens = 0U;
  #line 8073 
  u32 fceof_saidx = 0U;
  #line 8074 
  u32 type_tucmd = 0U;
  #line 8076 
  if ((unsigned int)skb->ip_summed != 3U) {
    #line 8077 
    csum_failed: 
                 #line 8077 
    ;
    #line 8078 
    if ((first->tx_flags & 9U) == 0U) 
                                      #line 8080 
                                      return;
    #line 8081 
    goto no_csum;
  }
  #line 8084 
  switch ((int)skb->__anonCompField_sk_buff_95.__anonCompField___anonunion_528_94.csum_offset) {
    #line 8085 
    case 16: 
             #line 8085 
    ;
    #line 8086 
    type_tucmd = 2048U;
    #line 8088 
    case 6: 
            #line 8088 
    ;
    #line 8089 
    break;
    #line 8090 
    case 8: 
            #line 8090 
    ;
    #line 8092 
    if ((unsigned int)first->protocol == 8U) {
      #line 8092 
      ;
      #line 8092 
      if ((unsigned int)ip_hdr(skb)->protocol == 132U) 
                                                       #line 8092 
                                                       goto _LOR; else 
                                                                    #line 8092 
                                                                    goto _LAND;
    }
    else {
      #line 8092 
      _LAND: 
             #line 8093 
      ;
      #line 8093 
      if ((unsigned int)first->protocol == 56710U) {
        #line 8094 
        if ((int)ixgbe_ipv6_csum_is_sctp(skb) != 0) {
          #line 8092 
          _LOR: {
                  #line 8096 
                  type_tucmd = 4096U;
                  #line 8097 
                  break;
                }
        }
      }
    }
    #line 8100 
    default: 
             #line 8100 
    ;
    #line 8101 
    skb_checksum_help(skb);
    #line 8102 
    goto csum_failed;
  }
  #line 8106 
  first->tx_flags |= 32U;
  #line 8107 
  vlan_macip_lens = (unsigned int)(skb_checksum_start_offset(skb) - skb_network_offset(skb));
  #line 8109 
  no_csum: 
           #line 8109 
  ;
  #line 8111 
  vlan_macip_lens = (unsigned int)(skb_network_offset(skb) << 9) | vlan_macip_lens;
  #line 8112 
  vlan_macip_lens = (first->tx_flags & 4294901760U) | vlan_macip_lens;
  #line 8114 
  fceof_saidx = (unsigned int)itd->sa_idx | fceof_saidx;
  #line 8115 
  type_tucmd = (itd->flags | (unsigned int)itd->trailer_len) | type_tucmd;
  #line 8117 
  ixgbe_tx_ctxtdesc(tx_ring,vlan_macip_lens,fceof_saidx,type_tucmd,0U);
  #line 8118 
  return;
}

#line 8125  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static u32 ixgbe_tx_cmd_type(struct sk_buff *skb, u32 tx_flags)
{
  #line 8128 
  u32 cmd_type = 573571072U;
  #line 8133 
  cmd_type = (tx_flags & 1U) * 1073741824U | cmd_type;
  #line 8137 
  cmd_type = (tx_flags & 2U) * 1073741824U | cmd_type;
  #line 8141 
  cmd_type = (tx_flags & 4U) * 131072U | cmd_type;
  #line 8145 
  cmd_type = (unsigned int)skb->no_fcs * 33554432U ^ cmd_type;
  #line 8147 
  return cmd_type;
}

#line 8150  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_tx_olinfo_status(union ixgbe_adv_tx_desc *tx_desc, u32 tx_flags, unsigned int paylen)
{
  #line 8153 
  u32 olinfo_status = paylen << 14;
  #line 8156 
  olinfo_status = (tx_flags & 32U) * 16U | olinfo_status;
  #line 8161 
  olinfo_status = (tx_flags & 16U) * 16U | olinfo_status;
  #line 8166 
  olinfo_status = (tx_flags & 64U) * 16U | olinfo_status;
  #line 8174 
  olinfo_status = (tx_flags & 8U) * 16U | olinfo_status;
  #line 8178 
  tx_desc->read.olinfo_status = olinfo_status;
  #line 8179 
  return;
}

#line 8181  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int __ixgbe_maybe_stop_tx(struct ixgbe_ring *tx_ring, u16 size)
{
  #line 8183 
  netif_stop_subqueue(tx_ring->netdev,(unsigned short)((int)tx_ring->queue_index));
  #line 8184 
  ldv_inline_asm();
  #line 8194 
  ;
  #line 8194 
  if ((long)((int)ixgbe_desc_unused(tx_ring) < (int)size) != 0L) 
                                                                 #line 8195 
                                                                 return -16;
  #line 8198 
  netif_start_subqueue(tx_ring->netdev,(unsigned short)((int)tx_ring->queue_index));
  #line 8199 
  (tx_ring->__anonCompField_ixgbe_ring_224.tx_stats.restart_queue) ++;
  #line 8200 
  return 0;
}

#line 8203  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static int ixgbe_maybe_stop_tx(struct ixgbe_ring *tx_ring, u16 size)
{
  #line 8205 
  ;
  #line 8205 
  if ((long)((int)ixgbe_desc_unused(tx_ring) >= (int)size) != 0L) 
                                                                  #line 8206 
                                                                  return 0;
  #line 8208 
  return __ixgbe_maybe_stop_tx(tx_ring,(unsigned short)((int)size));
}

#line 8211  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_tx_map(struct ixgbe_ring *tx_ring, struct ixgbe_tx_buffer *first, u8 hdr_len)
{
  #line 8216 
  struct ixgbe_tx_buffer *tx_buffer;
  #line 8217 
  union ixgbe_adv_tx_desc *tx_desc;
  #line 8218 
  skb_frag_t *frag;
  #line 8219 
  dma_addr_t dma;
  #line 8220 
  unsigned int data_len;
  #line 8220 
  unsigned int size;
  #line 8215 
  struct sk_buff *skb = first->__anonCompField_ixgbe_tx_buffer_217.skb;
  #line 8221 
  u32 tx_flags = first->tx_flags;
  #line 8222 
  u32 cmd_type = ixgbe_tx_cmd_type(skb,tx_flags);
  #line 8223 
  u16 i = tx_ring->next_to_use;
  #line 8225 
  tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc + (unsigned long)i;
  #line 8227 
  ixgbe_tx_olinfo_status(tx_desc,tx_flags,skb->len - (unsigned int)hdr_len);
  #line 8229 
  size = skb_headlen(skb);
  #line 8230 
  data_len = skb->data_len;
  #line 8233 
  if ((tx_flags & 256U) != 0U) 
    #line 8234 
    if (data_len <= 7U) {
      #line 8235 
      size = (size + data_len) + 4294967288U;
      #line 8236 
      data_len = 0U;
    }
    else 
         #line 8238 
         data_len += 4294967288U;
  #line 8243 
  dma = dma_map_single_attrs(tx_ring->dev,(void *)skb->data,(unsigned long)size,(enum dma_data_direction)DMA_TO_DEVICE,0UL);
  #line 8245 
  tx_buffer = first;
  #line 8247 
  frag = & ((struct skb_shared_info *)skb_end_pointer(skb))->frags[0];
  #line 8247 
  while (1) {
    {
      #line 8289 
      unsigned int __UNIQUE_ID___x594;
      #line 8289 
      unsigned int tmp_3;
      #line 8248 
      if (dma_mapping_error(tx_ring->dev,dma) != 0) 
                                                    #line 8249 
                                                    goto dma_error;
      #line 8252 
      tx_buffer->len = size;
      #line 8253 
      tx_buffer->dma = dma;
      #line 8255 
      tx_desc->read.buffer_addr = dma;
      #line 8257 
      while ((long)(size > 16384U) != 0L) {
        #line 8258 
        tx_desc->read.cmd_type_len = cmd_type ^ 16384U;
        #line 8261 
        i = (u16)((int)i + 1);
        #line 8262 
        tx_desc ++;
        #line 8263 
        if ((int)tx_ring->count == (int)i) {
          #line 8264 
          tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc;
          #line 8265 
          i = (unsigned short)0U;
        }
        #line 8267 
        tx_desc->read.olinfo_status = 0U;
        #line 8269 
        dma += 16384ULL;
        #line 8270 
        size += 4294950912U;
        #line 8272 
        tx_desc->read.buffer_addr = dma;
      }
      #line 8275 
      if ((long)(data_len == 0U) != 0L) 
                                        #line 8276 
                                        break;
      #line 8278 
      tx_desc->read.cmd_type_len = cmd_type ^ size;
      #line 8280 
      i = (u16)((int)i + 1);
      #line 8281 
      tx_desc ++;
      #line 8282 
      if ((int)tx_ring->count == (int)i) {
        #line 8283 
        tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc;
        #line 8284 
        i = (unsigned short)0U;
      }
      #line 8286 
      tx_desc->read.olinfo_status = 0U;
      {
        #line 8289 
        __UNIQUE_ID___x594 = data_len;
        #line 8289 
        unsigned int __UNIQUE_ID___y595 = skb_frag_size(frag);
        #line 8289 
        if (__UNIQUE_ID___x594 < __UNIQUE_ID___y595) 
                                                     #line 8289 
                                                     tmp_3 = __UNIQUE_ID___x594; else 
                                                                    #line 8289 
                                                                    tmp_3 = __UNIQUE_ID___y595;
        }
      #line 8289 
      size = tmp_3;
      #line 8293 
      data_len -= size;
      #line 8295 
      dma = skb_frag_dma_map(tx_ring->dev,frag,0UL,(unsigned long)size,(enum dma_data_direction)DMA_TO_DEVICE);
      #line 8298 
      tx_buffer = tx_ring->__anonCompField_ixgbe_ring_221.tx_buffer_info + (unsigned long)i;
    }
    #line 8247 
    frag ++;
  }
  #line 8302 
  cmd_type = (size | cmd_type) | 150994944U;
  #line 8303 
  tx_desc->read.cmd_type_len = cmd_type;
  #line 8305 
  ;
  #line 8305 
  netdev_tx_sent_queue(txring_txq(tx_ring),first->bytecount);
  #line 8308 
  first->time_stamp = jiffies;
  #line 8310 
  skb_tx_timestamp(skb);
  #line 8311 
  ldv_inline_asm();
  #line 8323 
  first->next_to_watch = tx_desc;
  #line 8325 
  i = (u16)((int)i + 1);
  #line 8326 
  if ((int)tx_ring->count == (int)i) 
                                     #line 8327 
                                     i = (unsigned short)0U;
  #line 8329 
  tx_ring->next_to_use = i;
  #line 8331 
  ixgbe_maybe_stop_tx(tx_ring,(unsigned short)21);
  #line 8333 
  if ((int)netif_xmit_stopped(txring_txq(tx_ring)) != 0) 
                                                         #line 8334 
                                                         writel((unsigned int)i,(void *)tx_ring->tail);
  else {
    #line 8333 
    if (! netdev_xmit_more()) 
                              #line 8334 
                              writel((unsigned int)i,(void *)tx_ring->tail);
  }
  #line 8337 
  return 0;
  #line 8338 
  dma_error: 
             #line 8338 
  ;
  #line 8339 
  _dev_err(tx_ring->dev,(char *)"TX DMA map failed\n");
  #line 8342 
  while (1) {
    #line 8343 
    tx_buffer = tx_ring->__anonCompField_ixgbe_ring_221.tx_buffer_info + (unsigned long)i;
    #line 8344 
    if (tx_buffer->len != 0U) 
                              #line 8345 
                              dma_unmap_page_attrs(tx_ring->dev,tx_buffer->dma,(unsigned long)tx_buffer->len,(enum dma_data_direction)DMA_TO_DEVICE,0UL);
    #line 8349 
    tx_buffer->len = 0U;
    #line 8350 
    if (tx_buffer == first) 
                            #line 8351 
                            break;
    #line 8352 
    if ((unsigned int)i == 0U) 
                               #line 8353 
                               i = (unsigned short)((int)tx_ring->count + (int)i);
    #line 8354 
    i = (u16)((int)i - 1);
  }
  #line 8357 
  dev_kfree_skb_any(first->__anonCompField_ixgbe_tx_buffer_217.skb);
  #line 8358 
  first->__anonCompField_ixgbe_tx_buffer_217.skb = (struct sk_buff *)0;
  #line 8360 
  tx_ring->next_to_use = i;
  #line 8362 
  return -1;
}

#line 8365  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_atr(struct ixgbe_ring *ring, struct ixgbe_tx_buffer *first)
{
  #line 8375 
  union __anonunion_hdr_2639 hdr;
  #line 8376 
  struct tcphdr *th;
  #line 8377 
  unsigned int hlen;
  #line 8378 
  struct sk_buff *skb;
  #line 8379 
  __be16 vlan_id;
  #line 8380 
  int l4_proto;
  #line 8368 
  struct ixgbe_q_vector *q_vector = ring->q_vector;
  #line 8369 
  union ixgbe_atr_hash_dword input = {.dword = 0U};
  #line 8370 
  union ixgbe_atr_hash_dword common = {.dword = 0U};
  #line 8383 
  if (q_vector == (struct ixgbe_q_vector *)0) 
                                              #line 8384 
                                              return;
  #line 8387 
  if ((unsigned int)ring->__anonCompField_ixgbe_ring_223.__anonCompField___anonunion_2624_222.atr_sample_rate == 0U) 
    #line 8388 
    return;
  #line 8390 
  ring->__anonCompField_ixgbe_ring_223.__anonCompField___anonunion_2624_222.atr_count = (u8)((int)ring->__anonCompField_ixgbe_ring_223.__anonCompField___anonunion_2624_222.atr_count + 1);
  #line 8393 
  if ((unsigned int)first->protocol != 8U && (unsigned int)first->protocol != 56710U) 
    #line 8395 
    return;
  #line 8398 
  skb = first->__anonCompField_ixgbe_tx_buffer_217.skb;
  #line 8399 
  hdr.network = skb_network_header(skb);
  #line 8400 
  if ((long)(hdr.network <= skb->data) != 0L) 
                                              #line 8401 
                                              return;
  #line 8402 
  if (((unsigned int)skb->encapsulation != 0U && (unsigned int)first->protocol == 8U) && (unsigned int)(hdr.ipv4)->protocol == 17U) {
    #line 8405 
    struct ixgbe_adapter *adapter = q_vector->adapter;
    #line 8407 
    ;
    #line 8407 
    if ((long)(skb_tail_pointer(skb) < hdr.network + 50U) != 0L) 
                                                                 #line 8409 
                                                                 return;
    #line 8412 
    if ((unsigned int)adapter->vxlan_port != 0U) {
      #line 8412 
      ;
      #line 8412 
      if ((int)udp_hdr(skb)->dest == (int)adapter->vxlan_port) 
                                                               #line 8414 
                                                               hdr.network = skb_inner_network_header(skb);
    }
    #line 8416 
    if ((unsigned int)adapter->geneve_port != 0U) {
      #line 8416 
      ;
      #line 8416 
      if ((int)udp_hdr(skb)->dest == (int)adapter->geneve_port) 
                                                                #line 8418 
                                                                hdr.network = skb_inner_network_header(skb);
    }
  }
  #line 8424 
  ;
  #line 8424 
  if ((long)(skb_tail_pointer(skb) < hdr.network + 40U) != 0L) 
                                                               #line 8425 
                                                               return;
  #line 8428 
  switch ((int)(hdr.ipv4)->version) {
    #line 8429 
    case 4: 
            #line 8429 
    ;
    #line 8431 
    hlen = (unsigned int)((int)*(hdr.network) << 2) & 60U;
    #line 8432 
    l4_proto = (int)(hdr.ipv4)->protocol;
    #line 8433 
    break;
    #line 8434 
    case 6: 
            #line 8434 
    ;
    #line 8435 
    hlen = (unsigned int)(hdr.network - skb->data);
    #line 8436 
    l4_proto = ipv6_find_hdr(skb,& hlen,6,(unsigned short *)0U,(int *)0);
    #line 8437 
    hlen -= (unsigned int)(hdr.network - skb->data);
    #line 8438 
    break;
    #line 8439 
    default: 
             #line 8439 
    ;
    #line 8440 
    return;
  }
  #line 8443 
  if (l4_proto != 6) 
                     #line 8444 
                     return;
  #line 8446 
  ;
  #line 8446 
  if ((long)(skb_tail_pointer(skb) < hdr.network + ((unsigned long)hlen + 20UL)) != 0L) 
    #line 8448 
    return;
  #line 8450 
  th = (struct tcphdr *)(hdr.network + (unsigned long)hlen);
  #line 8453 
  if ((unsigned int)th->fin != 0U) 
                                   #line 8454 
                                   return;
  #line 8457 
  if ((unsigned int)th->syn == 0U && (int)ring->__anonCompField_ixgbe_ring_223.__anonCompField___anonunion_2624_222.atr_count < (int)ring->__anonCompField_ixgbe_ring_223.__anonCompField___anonunion_2624_222.atr_sample_rate) 
    #line 8458 
    return;
  #line 8461 
  ring->__anonCompField_ixgbe_ring_223.__anonCompField___anonunion_2624_222.atr_count = (unsigned char)0U;
  #line 8463 
  vlan_id = __builtin_bswap16((unsigned short)((int)((unsigned short)(first->tx_flags >> 16))));
  #line 8472 
  input.formatted.vlan_id = vlan_id;
  #line 8478 
  if ((first->tx_flags & 129U) != 0U) 
                                      #line 8479 
                                      common.port.src = (unsigned short)((unsigned int)((int)common.port.src ^ (int)th->dest) ^ 129U); else 
                                                                    #line 8481 
                                                                    common.port.src = (unsigned short)((int)common.port.src ^ ((int)th->dest ^ (int)first->protocol));
  #line 8482 
  common.port.dst = (unsigned short)((int)common.port.dst ^ (int)th->source);
  #line 8484 
  switch ((int)(hdr.ipv4)->version) {
    #line 8485 
    case 4: 
            #line 8485 
    ;
    #line 8486 
    input.formatted.flow_type = (unsigned char)2U;
    #line 8487 
    common.ip ^= (hdr.ipv4)->saddr ^ (hdr.ipv4)->daddr;
    #line 8488 
    break;
    #line 8489 
    case 6: 
            #line 8489 
    ;
    #line 8490 
    input.formatted.flow_type = (unsigned char)6U;
    #line 8491 
    common.ip ^= (((((((hdr.ipv6)->saddr.in6_u.u6_addr32[0] ^ (hdr.ipv6)->saddr.in6_u.u6_addr32[1]) ^ (hdr.ipv6)->saddr.in6_u.u6_addr32[2]) ^ (hdr.ipv6)->saddr.in6_u.u6_addr32[3]) ^ (hdr.ipv6)->daddr.in6_u.u6_addr32[0]) ^ (hdr.ipv6)->daddr.in6_u.u6_addr32[1]) ^ (hdr.ipv6)->daddr.in6_u.u6_addr32[2]) ^ (hdr.ipv6)->daddr.in6_u.u6_addr32[3];
    #line 8499 
    break;
    #line 8500 
    default: 
             #line 8500 
    ;
    #line 8501 
    break;
  }
  #line 8504 
  ;
  #line 8504 
  if (hdr.network != skb_network_header(skb)) 
                                              #line 8505 
                                              input.formatted.flow_type = (unsigned char)((unsigned int)input.formatted.flow_type | 16U);
  #line 8508 
  ixgbe_fdir_add_signature_filter_82599(& (q_vector->adapter)->hw,input,common,(unsigned char)((int)ring->queue_index));
  #line 8510 
  return;
}

#line 8513  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static u16 ixgbe_select_queue(struct net_device *dev, struct sk_buff *skb, struct net_device *sb_dev)
{
  #line 8516 
  struct ixgbe_adapter *adapter;
  #line 8517 
  struct ixgbe_ring_feature *f;
  #line 8518 
  int txq;
  #line 8520 
  if (sb_dev != (struct net_device *)0) {
    #line 8521 
    u8 tc = (unsigned char)netdev_get_prio_tc_map(dev,skb->priority);
    #line 8522 
    struct net_device *vdev = sb_dev;
    #line 8524 
    txq = (int)vdev->tc_to_txq[(int)tc].offset;
    #line 8525 
    ;
    #line 8526 
    txq = (int)(reciprocal_scale(skb_get_hash(skb),
                         (unsigned int)vdev->tc_to_txq[(int)tc].count) + (unsigned int)txq);
    #line 8528 
    return (unsigned short)txq;
  }
  #line 8535 
  switch ((int)vlan_get_protocol(skb)) {
    #line 8536 
    case 1673: 
               #line 8536 
    ;
    #line 8537 
    case 5257: 
               #line 8537 
    ;
    #line 8538 
    adapter = (struct ixgbe_adapter *)netdev_priv(dev);
    #line 8540 
    if (sb_dev == (struct net_device *)0 && ((unsigned long)adapter->flags & 2097152UL) != 0UL) 
      #line 8541 
      break;
    #line 8543 
    default: 
             #line 8543 
    ;
    #line 8544 
    return netdev_pick_tx(dev,skb,sb_dev);
  }
  #line 8547 
  f = & adapter->ring_feature[4];
  #line 8549 
  if ((int)skb_rx_queue_recorded(skb) != 0) {
    #line 8549 
    txq = (int)skb_get_rx_queue(skb);
  }
  else {
    #line 8550 
    int pscr_ret__;
    #line 8550 
    __this_cpu_preempt_check((char *)"read");
    {
      #line 8550 
      void *__vpp_verify = (void *)0;
      #line 8550 
      void *tmp_7 = __vpp_verify;
    }
    #line 8550 
    switch (4UL) {
      #line 8550 
      int pfo_ret___1;
      #line 8550 
      int pfo_ret___2;
      #line 8550 
      int pfo_ret__;
      #line 8550 
      int pfo_ret___0;
      #line 8550 
      case (unsigned long)1: 
                             #line 8550 
      ;
      #line 8550 
      switch (4UL) {
        #line 8550 
        case (unsigned long)1: 
                               #line 8550 
        ;
        #line 8551 
        ldv_inline_asm();
        #line 8550 
        break;
        #line 8550 
        case (unsigned long)2: 
                               #line 8550 
        ;
        #line 8551 
        ldv_inline_asm();
        #line 8550 
        break;
        #line 8550 
        case (unsigned long)4: 
                               #line 8550 
        ;
        #line 8551 
        ldv_inline_asm();
        #line 8550 
        break;
        #line 8550 
        case (unsigned long)8: 
                               #line 8550 
        ;
        #line 8551 
        ldv_inline_asm();
        #line 8550 
        break;
        #line 8550 
        default: 
                 #line 8550 
        ;
        #line 8550 
        __bad_percpu_size();
      }
      #line 8550 
      pscr_ret__ = pfo_ret__;
      #line 8550 
      break;
      #line 8550 
      case (unsigned long)2: 
                             #line 8550 
      ;
      #line 8550 
      switch (4UL) {
        #line 8550 
        case (unsigned long)1: 
                               #line 8550 
        ;
        #line 8551 
        ldv_inline_asm();
        #line 8550 
        break;
        #line 8550 
        case (unsigned long)2: 
                               #line 8550 
        ;
        #line 8551 
        ldv_inline_asm();
        #line 8550 
        break;
        #line 8550 
        case (unsigned long)4: 
                               #line 8550 
        ;
        #line 8551 
        ldv_inline_asm();
        #line 8550 
        break;
        #line 8550 
        case (unsigned long)8: 
                               #line 8550 
        ;
        #line 8551 
        ldv_inline_asm();
        #line 8550 
        break;
        #line 8550 
        default: 
                 #line 8550 
        ;
        #line 8550 
        __bad_percpu_size();
      }
      #line 8550 
      pscr_ret__ = pfo_ret___0;
      #line 8550 
      break;
      #line 8550 
      case (unsigned long)4: 
                             #line 8550 
      ;
      #line 8550 
      switch (4UL) {
        #line 8550 
        case (unsigned long)1: 
                               #line 8550 
        ;
        #line 8551 
        ldv_inline_asm();
        #line 8550 
        break;
        #line 8550 
        case (unsigned long)2: 
                               #line 8550 
        ;
        #line 8551 
        ldv_inline_asm();
        #line 8550 
        break;
        #line 8550 
        case (unsigned long)4: 
                               #line 8550 
        ;
        #line 8551 
        ldv_inline_asm();
        #line 8550 
        break;
        #line 8550 
        case (unsigned long)8: 
                               #line 8550 
        ;
        #line 8551 
        ldv_inline_asm();
        #line 8550 
        break;
        #line 8550 
        default: 
                 #line 8550 
        ;
        #line 8550 
        __bad_percpu_size();
      }
      #line 8550 
      pscr_ret__ = pfo_ret___1;
      #line 8550 
      break;
      #line 8550 
      case (unsigned long)8: 
                             #line 8550 
      ;
      #line 8550 
      switch (4UL) {
        #line 8550 
        case (unsigned long)1: 
                               #line 8550 
        ;
        #line 8551 
        ldv_inline_asm();
        #line 8550 
        break;
        #line 8550 
        case (unsigned long)2: 
                               #line 8550 
        ;
        #line 8551 
        ldv_inline_asm();
        #line 8550 
        break;
        #line 8550 
        case (unsigned long)4: 
                               #line 8550 
        ;
        #line 8551 
        ldv_inline_asm();
        #line 8550 
        break;
        #line 8550 
        case (unsigned long)8: 
                               #line 8550 
        ;
        #line 8551 
        ldv_inline_asm();
        #line 8550 
        break;
        #line 8550 
        default: 
                 #line 8550 
        ;
        #line 8550 
        __bad_percpu_size();
      }
      #line 8550 
      pscr_ret__ = pfo_ret___2;
      #line 8550 
      break;
      #line 8550 
      default: 
               #line 8550 
      ;
      #line 8550 
      __bad_size_call_parameter();
      #line 8550 
      break;
    }
    #line 8549 
    txq = pscr_ret__;
  }
  #line 8552 
  while ((int)f->indices <= txq) 
                                 #line 8553 
                                 txq -= (int)f->indices;
  #line 8555 
  return (unsigned short)((int)f->offset + (int)((unsigned short)txq));
}

#line 8559  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_xmit_xdp_ring(struct ixgbe_adapter *adapter, struct xdp_frame *xdpf)
{
  #line 8562 
  int pscr_ret__;
  #line 8563 
  struct ixgbe_tx_buffer *tx_buffer;
  #line 8564 
  union ixgbe_adv_tx_desc *tx_desc;
  #line 8565 
  u32 len;
  #line 8565 
  u32 cmd_type;
  #line 8566 
  dma_addr_t dma;
  #line 8567 
  u16 i;
  #line 8562 
  __this_cpu_preempt_check((char *)"read");
  {
    #line 8562 
    void *__vpp_verify = (void *)0;
    #line 8562 
    void *tmp = __vpp_verify;
  }
  #line 8562 
  switch (4UL) {
    #line 8562 
    int pfo_ret__;
    #line 8562 
    int pfo_ret___0;
    #line 8562 
    int pfo_ret___1;
    #line 8562 
    int pfo_ret___2;
    #line 8562 
    case (unsigned long)1: 
                           #line 8562 
    ;
    #line 8562 
    switch (4UL) {
      #line 8562 
      case (unsigned long)1: 
                             #line 8562 
      ;
      #line 8563 
      ldv_inline_asm();
      #line 8562 
      break;
      #line 8562 
      case (unsigned long)2: 
                             #line 8562 
      ;
      #line 8563 
      ldv_inline_asm();
      #line 8562 
      break;
      #line 8562 
      case (unsigned long)4: 
                             #line 8562 
      ;
      #line 8563 
      ldv_inline_asm();
      #line 8562 
      break;
      #line 8562 
      case (unsigned long)8: 
                             #line 8562 
      ;
      #line 8563 
      ldv_inline_asm();
      #line 8562 
      break;
      #line 8562 
      default: 
               #line 8562 
      ;
      #line 8562 
      __bad_percpu_size();
    }
    #line 8562 
    pscr_ret__ = pfo_ret__;
    #line 8562 
    break;
    #line 8562 
    case (unsigned long)2: 
                           #line 8562 
    ;
    #line 8562 
    switch (4UL) {
      #line 8562 
      case (unsigned long)1: 
                             #line 8562 
      ;
      #line 8563 
      ldv_inline_asm();
      #line 8562 
      break;
      #line 8562 
      case (unsigned long)2: 
                             #line 8562 
      ;
      #line 8563 
      ldv_inline_asm();
      #line 8562 
      break;
      #line 8562 
      case (unsigned long)4: 
                             #line 8562 
      ;
      #line 8563 
      ldv_inline_asm();
      #line 8562 
      break;
      #line 8562 
      case (unsigned long)8: 
                             #line 8562 
      ;
      #line 8563 
      ldv_inline_asm();
      #line 8562 
      break;
      #line 8562 
      default: 
               #line 8562 
      ;
      #line 8562 
      __bad_percpu_size();
    }
    #line 8562 
    pscr_ret__ = pfo_ret___0;
    #line 8562 
    break;
    #line 8562 
    case (unsigned long)4: 
                           #line 8562 
    ;
    #line 8562 
    switch (4UL) {
      #line 8562 
      case (unsigned long)1: 
                             #line 8562 
      ;
      #line 8563 
      ldv_inline_asm();
      #line 8562 
      break;
      #line 8562 
      case (unsigned long)2: 
                             #line 8562 
      ;
      #line 8563 
      ldv_inline_asm();
      #line 8562 
      break;
      #line 8562 
      case (unsigned long)4: 
                             #line 8562 
      ;
      #line 8563 
      ldv_inline_asm();
      #line 8562 
      break;
      #line 8562 
      case (unsigned long)8: 
                             #line 8562 
      ;
      #line 8563 
      ldv_inline_asm();
      #line 8562 
      break;
      #line 8562 
      default: 
               #line 8562 
      ;
      #line 8562 
      __bad_percpu_size();
    }
    #line 8562 
    pscr_ret__ = pfo_ret___1;
    #line 8562 
    break;
    #line 8562 
    case (unsigned long)8: 
                           #line 8562 
    ;
    #line 8562 
    switch (4UL) {
      #line 8562 
      case (unsigned long)1: 
                             #line 8562 
      ;
      #line 8563 
      ldv_inline_asm();
      #line 8562 
      break;
      #line 8562 
      case (unsigned long)2: 
                             #line 8562 
      ;
      #line 8563 
      ldv_inline_asm();
      #line 8562 
      break;
      #line 8562 
      case (unsigned long)4: 
                             #line 8562 
      ;
      #line 8563 
      ldv_inline_asm();
      #line 8562 
      break;
      #line 8562 
      case (unsigned long)8: 
                             #line 8562 
      ;
      #line 8563 
      ldv_inline_asm();
      #line 8562 
      break;
      #line 8562 
      default: 
               #line 8562 
      ;
      #line 8562 
      __bad_percpu_size();
    }
    #line 8562 
    pscr_ret__ = pfo_ret___2;
    #line 8562 
    break;
    #line 8562 
    default: 
             #line 8562 
    ;
    #line 8562 
    __bad_size_call_parameter();
    #line 8562 
    break;
  }
  #line 8562 
  struct ixgbe_ring *ring = adapter->xdp_ring[pscr_ret__];
  #line 8569 
  len = (unsigned int)xdpf->len;
  #line 8571 
  if ((long)((unsigned int)ixgbe_desc_unused(ring) == 0U) != 0L) 
                                                                 #line 8572 
                                                                 return 1;
  #line 8574 
  dma = dma_map_single_attrs(ring->dev,xdpf->data,(unsigned long)len,(enum dma_data_direction)DMA_TO_DEVICE,0UL);
  #line 8575 
  if (dma_mapping_error(ring->dev,dma) != 0) 
                                             #line 8576 
                                             return 1;
  #line 8579 
  tx_buffer = ring->__anonCompField_ixgbe_ring_221.tx_buffer_info + (unsigned long)ring->next_to_use;
  #line 8580 
  tx_buffer->bytecount = len;
  #line 8581 
  tx_buffer->gso_segs = (unsigned short)1U;
  #line 8582 
  tx_buffer->protocol = (unsigned short)0U;
  #line 8584 
  i = ring->next_to_use;
  #line 8585 
  tx_desc = (union ixgbe_adv_tx_desc *)ring->desc + (unsigned long)i;
  #line 8587 
  tx_buffer->len = len;
  #line 8588 
  tx_buffer->dma = dma;
  #line 8589 
  tx_buffer->__anonCompField_ixgbe_tx_buffer_217.xdpf = xdpf;
  #line 8591 
  tx_desc->read.buffer_addr = dma;
  #line 8594 
  cmd_type = 573571072U;
  #line 8597 
  cmd_type = (len | cmd_type) | 150994944U;
  #line 8598 
  tx_desc->read.cmd_type_len = cmd_type;
  #line 8599 
  tx_desc->read.olinfo_status = len << 14;
  #line 8601 
  ldv_inline_asm();
  #line 8606 
  i = (u16)((int)i + 1);
  #line 8607 
  if ((int)ring->count == (int)i) 
                                  #line 8608 
                                  i = (unsigned short)0U;
  #line 8610 
  tx_buffer->next_to_watch = tx_desc;
  #line 8611 
  ring->next_to_use = i;
  #line 8613 
  return 2;
}

#line 8616  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
netdev_tx_t ixgbe_xmit_frame_ring(struct sk_buff *skb, struct ixgbe_adapter *adapter, struct ixgbe_ring *tx_ring)
{
  #line 8620 
  struct ixgbe_tx_buffer *first;
  #line 8621 
  int tso;
  #line 8623 
  unsigned short f;
  #line 8622 
  u32 tx_flags = 0U;
  #line 8624 
  u16 count = (unsigned short)((skb_headlen(skb) + 16383U) / 16384U);
  #line 8625 
  struct ixgbe_ipsec_tx_data ipsec_tx = {.flags = 0U, .trailer_len = (unsigned short)0, .sa_idx = (unsigned short)0};
  #line 8626 
  __be16 protocol = skb->protocol;
  #line 8627 
  u8 hdr_len = (unsigned char)0U;
  #line 8636 
  f = (unsigned short)0U;
  #line 8636 
  while (1) {
    #line 8636 
    ;
    #line 8636 
    if (! ((int)((unsigned short)((struct skb_shared_info *)skb_end_pointer(skb))->nr_frags) > (int)f)) 
      #line 8636 
      break;
    #line 8638 
    count = (unsigned short)((int)((unsigned short)((skb_frag_size(& ((struct skb_shared_info *)skb_end_pointer(skb))->frags[(int)f]) + 16383U) / 16384U)) + (int)count);
    #line 8636 
    f = (unsigned short)((int)f + 1);
  }
  #line 8640 
  if (ixgbe_maybe_stop_tx(tx_ring,
                            (unsigned short)((int)((unsigned int)count + 3U))) != 0) {
    #line 8641 
    (tx_ring->__anonCompField_ixgbe_ring_224.tx_stats.tx_busy) ++;
    #line 8642 
    return NETDEV_TX_BUSY;
  }
  #line 8646 
  first = tx_ring->__anonCompField_ixgbe_ring_221.tx_buffer_info + (unsigned long)tx_ring->next_to_use;
  #line 8647 
  first->__anonCompField_ixgbe_tx_buffer_217.skb = skb;
  #line 8648 
  first->bytecount = skb->len;
  #line 8649 
  first->gso_segs = (unsigned short)1U;
  #line 8652 
  if ((unsigned int)skb->vlan_present != 0U) {
    #line 8653 
    tx_flags = (unsigned int)((int)skb->vlan_tci << 16) | tx_flags;
    #line 8654 
    tx_flags |= 1U;
  }
  else 
    #line 8656 
    if ((unsigned int)protocol == 129U) {
      #line 8657 
      struct vlan_hdr *vhdr;
      #line 8657 
      struct vlan_hdr _vhdr;
      #line 8658 
      vhdr = (struct vlan_hdr *)skb_header_pointer(skb,14,4,(void *)(& _vhdr));
      #line 8659 
      if (vhdr == (struct vlan_hdr *)0) 
                                        #line 8660 
                                        goto out_drop;
      #line 8662 
      tx_flags = (unsigned int)((int)__builtin_bswap16((unsigned short)((int)vhdr->h_vlan_TCI)) << 16) | tx_flags;
      #line 8664 
      tx_flags |= 128U;
    }
  #line 8666 
  protocol = vlan_get_protocol(skb);
  #line 8668 
  ;
  #line 8668 
  if ((long)(((int)((struct skb_shared_info *)skb_end_pointer(skb))->tx_flags & 1) != 0) != 0L) 
    #line 8668 
    if (adapter->ptp_clock != (struct ptp_clock *)0) 
      #line 8670 
      if (adapter->tstamp_config.tx_type == 1) {
        #line 8671 
        if (test_and_set_bit_lock(9L,& adapter->state)) 
                                                        #line 8681 
                                                        (adapter->tx_hwtstamp_skipped) ++;
        else {
          #line 8673 
          ((struct skb_shared_info *)skb_end_pointer(skb))->tx_flags = (unsigned char)((unsigned int)((struct skb_shared_info *)skb_end_pointer(skb))->tx_flags | 4U);
          #line 8674 
          tx_flags |= 4U;
          #line 8677 
          adapter->ptp_tx_skb = skb_get(skb);
          #line 8678 
          adapter->ptp_tx_start = jiffies;
          #line 8679 
          cif_schedule_work(& adapter->ptp_tx_work);
        }
      }
      else 
           #line 8681 
           (adapter->tx_hwtstamp_skipped) ++;
  #line 8690 
  if (((unsigned long)adapter->flags & 8388608UL) != 0UL) 
                                                          #line 8691 
                                                          tx_flags |= 8U;
  #line 8695 
  if (((unsigned long)adapter->flags & 4096UL) != 0UL && ((tx_flags & 129U) != 0U || skb->priority != 7U)) {
    #line 8698 
    tx_flags &= 536870911U;
    #line 8699 
    tx_flags = (skb->priority << 29) | tx_flags;
    #line 8701 
    if ((tx_flags & 128U) != 0U) {
      #line 8702 
      struct vlan_ethhdr *vhdr_0;
      #line 8704 
      if (skb_cow_head(skb,0U) != 0) 
                                     #line 8705 
                                     goto out_drop;
      #line 8706 
      vhdr_0 = (struct vlan_ethhdr *)skb->data;
      #line 8707 
      vhdr_0->h_vlan_TCI = __builtin_bswap16((unsigned short)((int)((unsigned short)(tx_flags >> 16))));
    }
    else 
         #line 8710 
         tx_flags |= 1U;
  }
  #line 8715 
  first->tx_flags = tx_flags;
  #line 8716 
  first->protocol = protocol;
  #line 8720 
  if ((unsigned int)protocol == 1673U && ((tx_ring->netdev)->features & 17181966336ULL) != 0ULL) {
    #line 8722 
    tso = ixgbe_fso(tx_ring,first,& hdr_len);
    #line 8723 
    if (tso < 0) 
                 #line 8724 
                 goto out_drop;
    #line 8726 
    goto xmit_fcoe;
  }
  #line 8732 
  if (xfrm_offload(skb) != (struct xfrm_offload *)0) {
    #line 8732 
    if (ixgbe_ipsec_tx(tx_ring,first,& ipsec_tx) == 0) 
                                                       #line 8734 
                                                       goto out_drop;
  }
  #line 8736 
  tso = ixgbe_tso(tx_ring,first,& hdr_len,& ipsec_tx);
  #line 8737 
  if (tso < 0) 
               #line 8738 
               goto out_drop;
  else 
    #line 8739 
    if (tso == 0) 
                  #line 8740 
                  ixgbe_tx_csum(tx_ring,first,& ipsec_tx);
  #line 8743 
  if ((int)test_bit(5L,& tx_ring->state) != 0) 
                                               #line 8744 
                                               ixgbe_atr(tx_ring,first);
  #line 8747 
  xmit_fcoe: 
             #line 8747 
  ;
  #line 8749 
  if (ixgbe_tx_map(tx_ring,first,(unsigned char)((int)hdr_len)) != 0) 
    #line 8750 
    goto cleanup_tx_timestamp;
  #line 8752 
  return NETDEV_TX_OK;
  #line 8754 
  out_drop: 
            #line 8754 
  ;
  #line 8755 
  dev_kfree_skb_any(first->__anonCompField_ixgbe_tx_buffer_217.skb);
  #line 8756 
  first->__anonCompField_ixgbe_tx_buffer_217.skb = (struct sk_buff *)0;
  #line 8757 
  cleanup_tx_timestamp: 
                        #line 8757 
  ;
  #line 8758 
  if ((long)((tx_flags & 4U) != 0U) != 0L) {
    #line 8759 
    dev_kfree_skb_any(adapter->ptp_tx_skb);
    #line 8760 
    adapter->ptp_tx_skb = (struct sk_buff *)0;
    #line 8761 
    cancel_work_sync(& adapter->ptp_tx_work);
    #line 8762 
    clear_bit_unlock(9L,& adapter->state);
  }
  #line 8765 
  return NETDEV_TX_OK;
}

#line 8768  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static netdev_tx_t __ixgbe_xmit_frame(struct sk_buff *skb, struct net_device *netdev, struct ixgbe_ring *ring)
{
  #line 8773 
  struct ixgbe_ring *tx_ring;
  #line 8772 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 8779 
  if (skb_put_padto(skb,17U) != 0) 
                                   #line 8780 
                                   return NETDEV_TX_OK;
  #line 8782 
  if (ring == (struct ixgbe_ring *)0) {
    #line 8782 
    tx_ring = adapter->tx_ring[(int)skb_get_queue_mapping(skb)];
  }
  else 
       #line 8782 
       tx_ring = ring;
  #line 8783 
  if ((long)((int)test_bit(10L,& tx_ring->state) != 0) != 0L) 
                                                              #line 8784 
                                                              return NETDEV_TX_BUSY;
  #line 8786 
  return ixgbe_xmit_frame_ring(skb,adapter,tx_ring);
}

#line 8789  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static netdev_tx_t ixgbe_xmit_frame(struct sk_buff *skb, struct net_device *netdev)
{
  #line 8792 
  return __ixgbe_xmit_frame(skb,netdev,(struct ixgbe_ring *)0);
}

#line 8802  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_set_mac(struct net_device *netdev, void *p)
{
  #line 8804 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 8805 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 8806 
  struct sockaddr *addr = (struct sockaddr *)p;
  #line 8808 
  if (! is_valid_ether_addr((u8 *)(& addr->sa_data))) 
                                                      #line 8809 
                                                      return -99;
  #line 8811 
  memcpy((void *)netdev->dev_addr,(void *)(& addr->sa_data),(unsigned long)netdev->addr_len);
  #line 8812 
  memcpy((void *)(& hw->mac.addr),(void *)(& addr->sa_data),(unsigned long)netdev->addr_len);
  #line 8814 
  ixgbe_mac_set_default_filter(adapter);
  #line 8816 
  return 0;
}

#line 8820  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_mdio_read(struct net_device *netdev, int prtad, int devad, u16 addr)
{
  #line 8824 
  u16 value;
  #line 8825 
  int rc;
  #line 8822 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 8823 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 8827 
  if (adapter->mii_bus != (struct mii_bus *)0) {
    #line 8828 
    int regnum = (int)addr;
    #line 8830 
    if (devad != -1) 
                     #line 8831 
                     regnum = ((devad << 16) | 1073741824) | regnum;
    #line 8833 
    return mdiobus_read(adapter->mii_bus,prtad,(unsigned int)regnum);
  }
  #line 8836 
  if (hw->phy.mdio.prtad != prtad) 
                                   #line 8837 
                                   return -22;
  #line 8838 
  rc = (*(hw->phy.ops.read_reg))(hw,(unsigned int)addr,(unsigned int)devad,& value);
  #line 8839 
  if (rc == 0) 
               #line 8840 
               rc = (int)value;
  #line 8841 
  return rc;
}

#line 8844  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_mdio_write(struct net_device *netdev, int prtad, int devad, u16 addr, u16 value)
{
  #line 8847 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 8848 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 8850 
  if (adapter->mii_bus != (struct mii_bus *)0) {
    #line 8851 
    int regnum = (int)addr;
    #line 8853 
    if (devad != -1) 
                     #line 8854 
                     regnum = ((devad << 16) | 1073741824) | regnum;
    #line 8856 
    return mdiobus_write(adapter->mii_bus,prtad,(unsigned int)regnum,
                      (unsigned short)((int)value));
  }
  #line 8859 
  if (hw->phy.mdio.prtad != prtad) 
                                   #line 8860 
                                   return -22;
  #line 8861 
  return (*(hw->phy.ops.write_reg))(hw,(unsigned int)addr,(unsigned int)devad,
                                   (unsigned short)((int)value));
}

#line 8864  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_ioctl(struct net_device *netdev, struct ifreq *req, int cmd)
{
  #line 8866 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 8868 
  switch (cmd) {
    #line 8869 
    case 35248: 
                #line 8869 
    ;
    #line 8870 
    return ixgbe_ptp_set_ts_config(adapter,req);
    #line 8871 
    case 35249: 
                #line 8871 
    ;
    #line 8872 
    return ixgbe_ptp_get_ts_config(adapter,req);
    #line 8873 
    case 35143: 
                #line 8873 
    ;
    #line 8874 
    if (adapter->hw.phy.ops.read_reg == (s32 (*)(struct ixgbe_hw *, u32 , u32 , u16 *))0) 
      #line 8875 
      return -95;
    #line 8877 
    default: 
             #line 8877 
    ;
    #line 8878 
    ;
    #line 8878 
    ;
    #line 8878 
    return mdio_mii_ioctl(& adapter->hw.phy.mdio,if_mii(req),cmd);
  }
}

#line 8889  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_add_sanmac_netdev(struct net_device *dev)
{
  #line 8891 
  int err = 0;
  #line 8892 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 8893 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 8895 
  if ((int)is_valid_ether_addr((u8 *)(& hw->mac.san_addr)) != 0) {
    #line 8896 
    rtnl_lock();
    #line 8897 
    err = dev_addr_add(dev,(unsigned char *)(& hw->mac.san_addr),(unsigned char)2);
    #line 8898 
    rtnl_unlock();
    #line 8901 
    (*(hw->mac.ops.set_vmdq_san_mac))(hw,(unsigned int)adapter->ring_feature[1].offset);
  }
  #line 8903 
  return err;
}

#line 8913  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_del_sanmac_netdev(struct net_device *dev)
{
  #line 8915 
  int err = 0;
  #line 8916 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 8917 
  struct ixgbe_mac_info *mac = & adapter->hw.mac;
  #line 8919 
  if ((int)is_valid_ether_addr((u8 *)(& mac->san_addr)) != 0) {
    #line 8920 
    rtnl_lock();
    #line 8921 
    err = dev_addr_del(dev,(unsigned char *)(& mac->san_addr),(unsigned char)2);
    #line 8922 
    rtnl_unlock();
  }
  #line 8924 
  return err;
}

#line 8927  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_get_ring_stats64(struct rtnl_link_stats64 *stats, struct ixgbe_ring *ring)
{
  #line 8930 
  u64 bytes;
  #line 8930 
  u64 packets;
  #line 8931 
  unsigned int start;
  #line 8933 
  if (ring != (struct ixgbe_ring *)0) {
    #line 8934 
    while (1) {
      #line 8935 
      start = u64_stats_fetch_begin_irq(& ring->syncp);
      #line 8936 
      packets = ring->stats.packets;
      #line 8937 
      bytes = ring->stats.bytes;
      #line 8938 
      if (! ((int)u64_stats_fetch_retry_irq(& ring->syncp,start) != 0)) 
        #line 8934 
        break;
    }
    #line 8939 
    stats->tx_packets += packets;
    #line 8940 
    stats->tx_bytes += bytes;
  }
  #line 8942 
  return;
}

#line 8944  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_get_stats64(struct net_device *netdev, struct rtnl_link_stats64 *stats)
{
  #line 8948 
  int i;
  #line 8947 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 8950 
  rcu_read_lock();
  #line 8951 
  i = 0;
  #line 8951 
  while (adapter->num_rx_queues > i) {
    {
      #line 8953 
      union __anonunion___u_2641 __u;
      #line 8953 
      u64 bytes;
      #line 8953 
      u64 packets;
      #line 8954 
      unsigned int start;
      #line 8952 
      __read_once_size((void *)(& adapter->rx_ring[i]),(void *)(& __u.__c),8);
      #line 8952 
      struct ixgbe_ring *ring = (__u.__val);
      #line 8956 
      if (ring != (struct ixgbe_ring *)0) {
        #line 8957 
        while (1) {
          #line 8958 
          start = u64_stats_fetch_begin_irq(& ring->syncp);
          #line 8959 
          packets = ring->stats.packets;
          #line 8960 
          bytes = ring->stats.bytes;
          #line 8961 
          if (! ((int)u64_stats_fetch_retry_irq(& ring->syncp,start) != 0)) 
            #line 8957 
            break;
        }
        #line 8962 
        stats->rx_packets += packets;
        #line 8963 
        stats->rx_bytes += bytes;
      }
    }
    #line 8951 
    i ++;
  }
  #line 8967 
  i = 0;
  #line 8967 
  while (adapter->num_tx_queues > i) {
    {
      #line 8969 
      union __anonunion___u_2643 __u_0;
      #line 8968 
      __read_once_size((void *)(& adapter->tx_ring[i]),(void *)(& __u_0.__c),8);
      #line 8968 
      struct ixgbe_ring *ring_0 = (__u_0.__val);
      #line 8970 
      ixgbe_get_ring_stats64(stats,ring_0);
    }
    #line 8967 
    i ++;
  }
  #line 8972 
  i = 0;
  #line 8972 
  while (adapter->num_xdp_queues > i) {
    {
      #line 8974 
      union __anonunion___u_2645 __u_1;
      #line 8973 
      __read_once_size((void *)(& adapter->xdp_ring[i]),(void *)(& __u_1.__c),8);
      #line 8973 
      struct ixgbe_ring *ring_1 = (__u_1.__val);
      #line 8975 
      ixgbe_get_ring_stats64(stats,ring_1);
    }
    #line 8972 
    i ++;
  }
  #line 8977 
  rcu_read_unlock();
  #line 8980 
  stats->multicast = (unsigned long long)netdev->stats.multicast;
  #line 8981 
  stats->rx_errors = (unsigned long long)netdev->stats.rx_errors;
  #line 8982 
  stats->rx_length_errors = (unsigned long long)netdev->stats.rx_length_errors;
  #line 8983 
  stats->rx_crc_errors = (unsigned long long)netdev->stats.rx_crc_errors;
  #line 8984 
  stats->rx_missed_errors = (unsigned long long)netdev->stats.rx_missed_errors;
  #line 8985 
  return;
}

#line 8996  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_validate_rtr(struct ixgbe_adapter *adapter, u8 tc)
{
  #line 8999 
  u32 reg;
  #line 8999 
  u32 rsave;
  #line 9000 
  int i;
  #line 8998 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 9005 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) 
                                                       #line 9006 
                                                       return;
  #line 9008 
  reg = ixgbe_read_reg(hw,12320U);
  #line 9009 
  rsave = reg;
  #line 9011 
  i = 0;
  #line 9011 
  while (i <= 7) {
    {
      #line 9012 
      u8 up2tc = (unsigned char)(reg >> i * 3);
      #line 9015 
      if ((int)up2tc > (int)tc) 
                                #line 9016 
                                reg &= 4294967239U;
    }
    #line 9011 
    i ++;
  }
  #line 9019 
  if (reg != rsave) 
                    #line 9020 
                    ixgbe_write_reg_1(hw,12320U,reg);
  #line 9022 
  return;
}

#line 9031  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_set_prio_tc_map(struct ixgbe_adapter *adapter)
{
  #line 9036 
  u8 prio;
  #line 9033 
  struct net_device *dev = adapter->netdev;
  #line 9034 
  struct ixgbe_dcb_config *dcb_cfg = & adapter->dcb_cfg;
  #line 9035 
  struct ieee_ets *ets = adapter->ixgbe_ieee_ets;
  #line 9038 
  prio = (unsigned char)0U;
  #line 9038 
  while ((unsigned int)prio <= 7U) {
    {
      #line 9039 
      u8 tc = (unsigned char)0U;
      #line 9041 
      if (((int)adapter->dcbx_cap & 4) != 0) 
                                             #line 9042 
                                             tc = ixgbe_dcb_get_tc_from_up(dcb_cfg,0,(unsigned char)((int)prio));
      else 
        #line 9043 
        if (ets != (struct ieee_ets *)0) 
                                         #line 9044 
                                         tc = ets->prio_tc[(int)prio];
      #line 9046 
      netdev_set_prio_tc_map(dev,(unsigned char)((int)prio),(unsigned char)((int)tc));
    }
    #line 9038 
    prio = (u8)((int)prio + 1);
  }
  #line 9048 
  return;
}

#line 9051  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_reassign_macvlan_pool(struct net_device *vdev, void *data)
{
  #line 9054 
  struct ixgbe_fwd_adapter *accel;
  #line 9055 
  int pool;
  #line 9053 
  struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
  #line 9058 
  if (! netif_is_macvlan(vdev)) 
                                #line 9059 
                                return 0;
  #line 9062 
  accel = (struct ixgbe_fwd_adapter *)macvlan_accel_priv(vdev);
  #line 9063 
  if (accel == (struct ixgbe_fwd_adapter *)0) 
                                              #line 9064 
                                              return 0;
  #line 9067 
  pool = (int)find_first_zero_bit((unsigned long *)(& adapter->fwd_bitmask),
                            (unsigned long)adapter->num_rx_pools);
  #line 9068 
  if (adapter->num_rx_pools > pool) {
    #line 9069 
    cif_set_bit((long)pool,(unsigned long *)(& adapter->fwd_bitmask));
    #line 9070 
    accel->pool = pool;
    #line 9071 
    return 0;
  }
  #line 9075 
  netdev_err(vdev,(char *)"L2FW offload disabled due to lack of queue resources\n");
  #line 9076 
  macvlan_release_l2fw_offload(vdev);
  #line 9079 
  netdev_unbind_sb_channel(adapter->netdev,vdev);
  #line 9080 
  netdev_set_sb_channel(vdev,(unsigned short)0);
  #line 9082 
  kfree((void *)accel);
  #line 9084 
  return 0;
}

#line 9087  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_defrag_macvlan_pools(struct net_device *dev)
{
  #line 9089 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 9092 
  cif_bitmap_clear((unsigned long *)(& adapter->fwd_bitmask),1U,63U);
  #line 9095 
  netdev_walk_all_upper_dev_rcu(dev,& ixgbe_reassign_macvlan_pool,(void *)adapter);
  #line 9096 
  return;
}

#line 9105  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_setup_tc(struct net_device *dev, u8 tc)
{
  #line 9107 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 9108 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 9111 
  if ((int)adapter->dcb_cfg.num_tcs.pg_tcs < (int)tc) 
                                                      #line 9112 
                                                      return -22;
  #line 9114 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB && (unsigned int)tc + 255U <= 6U) 
    #line 9115 
    return -22;
  #line 9121 
  if ((int)netif_running(dev) != 0) 
                                    #line 9122 
                                    ixgbe_close(dev); else 
                                                           #line 9124 
                                                           ixgbe_reset(adapter);
  #line 9126 
  ixgbe_clear_interrupt_scheme(adapter);
  #line 9129 
  if ((unsigned int)tc != 0U) {
    #line 9130 
    if (adapter->xdp_prog != (struct bpf_prog *)0) {
      #line 9131 
      if (((int)adapter->msg_enable & 2) != 0) 
                                               #line 9131 
                                               netdev_warn(adapter->netdev,(char *)"DCB is not supported with XDP\n");
      #line 9133 
      ixgbe_init_interrupt_scheme(adapter);
      #line 9134 
      if ((int)netif_running(dev) != 0) 
                                        #line 9135 
                                        ixgbe_open(dev);
      #line 9136 
      return -22;
    }
    #line 9139 
    netdev_set_num_tc(dev,(unsigned char)((int)tc));
    #line 9140 
    ixgbe_set_prio_tc_map(adapter);
    #line 9142 
    adapter->hw_tcs = tc;
    #line 9143 
    adapter->flags |= 4096U;
    #line 9145 
    if (adapter->hw.mac.type == (unsigned int)ixgbe_mac_82598EB) {
      #line 9146 
      adapter->last_lfc_mode = adapter->hw.fc.requested_mode;
      #line 9147 
      adapter->hw.fc.requested_mode = ixgbe_fc_none;
    }
  }
  else {
    #line 9150 
    netdev_reset_tc(dev);
    #line 9152 
    if (adapter->hw.mac.type == (unsigned int)ixgbe_mac_82598EB) 
                                                                 #line 9153 
                                                                 adapter->hw.fc.requested_mode = adapter->last_lfc_mode;
    #line 9155 
    adapter->flags &= 4294963199U;
    #line 9156 
    adapter->hw_tcs = tc;
    #line 9158 
    adapter->temp_dcb_cfg.pfc_mode_enable = (_Bool)0;
    #line 9159 
    adapter->dcb_cfg.pfc_mode_enable = (_Bool)0;
  }
  #line 9162 
  ixgbe_validate_rtr(adapter,(unsigned char)((int)tc));
  #line 9165 
  ixgbe_init_interrupt_scheme(adapter);
  #line 9167 
  ixgbe_defrag_macvlan_pools(dev);
  #line 9169 
  if ((int)netif_running(dev) != 0) {
    #line 9170 
    return ixgbe_open(dev);
  }
  #line 9172 
  return 0;
}

#line 9175  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_delete_clsu32(struct ixgbe_adapter *adapter, struct tc_cls_u32_offload *cls)
{
  #line 9181 
  int i;
  #line 9181 
  int j;
  #line 9178 
  u32 hdl = cls->__anonCompField_tc_cls_u32_offload_205.knode.handle;
  #line 9179 
  u32 uhtid = cls->__anonCompField_tc_cls_u32_offload_205.knode.handle >> 20;
  #line 9180 
  u32 loc = cls->__anonCompField_tc_cls_u32_offload_205.knode.handle & 1048575U;
  #line 9181 
  int err = 0;
  #line 9182 
  struct ixgbe_jump_table *jump = (struct ixgbe_jump_table *)0;
  #line 9184 
  if (loc > 2045U) 
                   #line 9185 
                   return -22;
  #line 9187 
  if (uhtid != 2048U && uhtid > 9U) 
                                    #line 9188 
                                    return -22;
  #line 9191 
  if (uhtid != 2048U) {
    #line 9192 
    jump = adapter->jump_tables[uhtid];
    #line 9193 
    if (jump == (struct ixgbe_jump_table *)0) 
                                              #line 9194 
                                              return -22;
    #line 9195 
    if (! test_bit((long)(loc + 4294967295U),
               (unsigned long *)(& jump->child_loc_map))) 
      #line 9196 
      return -22;
    #line 9197 
    cif_clear_bit((long)(loc + 4294967295U),(unsigned long *)(& jump->child_loc_map));
  }
  #line 9201 
  i = 1;
  #line 9201 
  while (i <= 9) {
    #line 9202 
    jump = adapter->jump_tables[i];
    #line 9203 
    if (jump != (struct ixgbe_jump_table *)0 && jump->link_hdl == hdl) {
      #line 9207 
      j = 0;
      #line 9207 
      while (j <= 2044) {
        {
          #line 9208 
          if (! test_bit((long)j,(unsigned long *)(& jump->child_loc_map))) 
            #line 9209 
            goto __Cont;
          #line 9210 
          cif_spin_lock_fdir_perfect_lock_of_ixgbe_adapter(& adapter->fdir_perfect_lock);
          #line 9211 
          err = ixgbe_update_ethtool_fdir_entry(adapter,(struct ixgbe_fdir_filter *)0,(unsigned short)((int)((unsigned int)((unsigned short)j) + 1U)));
          #line 9214 
          cif_spin_unlock_fdir_perfect_lock_of_ixgbe_adapter(& adapter->fdir_perfect_lock);
          #line 9215 
          cif_clear_bit((long)j,(unsigned long *)(& jump->child_loc_map));
        }
        #line 9207 
        __Cont: 
                #line 9207 
        j ++;
      }
      #line 9218 
      kfree((void *)jump->input);
      #line 9219 
      kfree((void *)jump->mask);
      #line 9220 
      kfree((void *)jump);
      #line 9221 
      adapter->jump_tables[i] = (struct ixgbe_jump_table *)0;
      #line 9222 
      return err;
    }
    #line 9201 
    i ++;
  }
  #line 9226 
  cif_spin_lock_fdir_perfect_lock_of_ixgbe_adapter(& adapter->fdir_perfect_lock);
  #line 9227 
  err = ixgbe_update_ethtool_fdir_entry(adapter,(struct ixgbe_fdir_filter *)0,(unsigned short)((int)((unsigned short)loc)));
  #line 9228 
  cif_spin_unlock_fdir_perfect_lock_of_ixgbe_adapter(& adapter->fdir_perfect_lock);
  #line 9229 
  return err;
}

#line 9232  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_configure_clsu32_add_hnode(struct ixgbe_adapter *adapter, struct tc_cls_u32_offload *cls)
{
  #line 9235 
  u32 uhtid = cls->__anonCompField_tc_cls_u32_offload_205.hnode.handle >> 20;
  #line 9237 
  if (uhtid > 9U) 
                  #line 9238 
                  return -22;
  #line 9243 
  if (cls->__anonCompField_tc_cls_u32_offload_205.hnode.divisor != 0U) 
    #line 9244 
    return -22;
  #line 9246 
  cif_set_bit((long)(uhtid + 4294967295U),& adapter->tables);
  #line 9247 
  return 0;
}

#line 9250  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_configure_clsu32_del_hnode(struct ixgbe_adapter *adapter, struct tc_cls_u32_offload *cls)
{
  #line 9253 
  u32 uhtid = cls->__anonCompField_tc_cls_u32_offload_205.hnode.handle >> 20;
  #line 9255 
  if (uhtid > 9U) 
                  #line 9256 
                  return -22;
  #line 9258 
  cif_clear_bit((long)(uhtid + 4294967295U),& adapter->tables);
  #line 9259 
  return 0;
}

#line 9270  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int get_macvlan_queue(struct net_device *upper, void *_data)
{
  #line 9272 
  if ((int)netif_is_macvlan(upper) != 0) {
    #line 9273 
    struct ixgbe_fwd_adapter *vadapter = macvlan_accel_priv(upper);
    #line 9274 
    struct upper_walk_data *data = (struct upper_walk_data *)_data;
    #line 9275 
    struct ixgbe_adapter *adapter = data->adapter;
    #line 9276 
    int ifindex = data->ifindex;
    #line 9278 
    if (vadapter != (struct ixgbe_fwd_adapter *)0 && upper->ifindex == ifindex) {
      #line 9279 
      data->queue = (adapter->rx_ring[vadapter->rx_base_queue])->reg_idx;
      #line 9280 
      data->action = (unsigned long long)data->queue;
      #line 9281 
      return 1;
    }
  }
  #line 9285 
  return 0;
}

#line 9288  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int handle_redirect_action(struct ixgbe_adapter *adapter, int ifindex, u8 *queue, u64 *action)
{
  #line 9292 
  unsigned int vf;
  #line 9293 
  struct upper_walk_data data;
  #line 9294 
  struct net_device *upper;
  #line 9291 
  struct ixgbe_ring_feature *vmdq = & adapter->ring_feature[1];
  #line 9292 
  unsigned int num_vfs = adapter->num_vfs;
  #line 9297 
  vf = 0U;
  #line 9297 
  while (vf < num_vfs) {
    #line 9298 
    upper = (struct net_device *)pci_get_drvdata((adapter->vfinfo + (unsigned long)vf)->vfdev);
    #line 9299 
    if (upper->ifindex == ifindex) {
      #line 9300 
      *queue = (unsigned char)((int)((unsigned char)(- ((int)vmdq->mask) & (int)vmdq->mask)) * (int)((unsigned char)vf));
      #line 9301 
      *action = (unsigned long long)(vf + 1U);
      #line 9302 
      *action <<= 32;
      #line 9303 
      return 0;
    }
    #line 9297 
    vf ++;
  }
  #line 9308 
  data.adapter = adapter;
  #line 9309 
  data.ifindex = ifindex;
  #line 9310 
  data.action = 0ULL;
  #line 9311 
  data.queue = (unsigned char)0U;
  #line 9312 
  if (netdev_walk_all_upper_dev_rcu(adapter->netdev,& get_macvlan_queue,
                                      (void *)(& data)) != 0) {
    #line 9314 
    *action = data.action;
    #line 9315 
    *queue = data.queue;
    #line 9317 
    return 0;
  }
  #line 9320 
  return -22;
}

#line 9323  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int parse_tc_actions(struct ixgbe_adapter *adapter, struct tcf_exts *exts, u64 *action, u8 *queue)
{
  #line 9326 
  struct tc_action *a;
  #line 9327 
  int i;
  #line 9329 
  if (! tcf_exts_has_actions(exts)) 
                                    #line 9330 
                                    return -22;
  #line 9332 
  i = 0;
  #line 9332 
  while (1) {
    #line 9332 
    if (i <= 31) {
      #line 9332 
      a = *(exts->actions + (unsigned long)i);
      #line 9332 
      if (! (a != (struct tc_action *)0)) 
                                          #line 9332 
                                          break;
    }
    else 
         #line 9332 
         break;
    {
      #line 9334 
      if ((int)is_tcf_gact_shot(a) != 0) {
        #line 9335 
        *action = 127ULL;
        #line 9336 
        *queue = (unsigned char)127U;
        #line 9337 
        return 0;
      }
      #line 9341 
      if ((int)is_tcf_mirred_egress_redirect(a) != 0) {
        #line 9342 
        struct net_device *dev = tcf_mirred_dev(a);
        #line 9344 
        if (dev == (struct net_device *)0) 
                                           #line 9345 
                                           return -22;
        #line 9346 
        return handle_redirect_action(adapter,dev->ifindex,queue,action);
      }
      #line 9350 
      return -22;
    }
    #line 9332 
    i ++;
  }
  #line 9353 
  return -22;
}

#line 9363  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_clsu32_build_input(struct ixgbe_fdir_filter *input, union ixgbe_atr_input *mask, struct tc_cls_u32_offload *cls, struct ixgbe_mat_field *field_ptr, struct ixgbe_nexthdr *nexthdr)
{
  #line 9369 
  int i;
  #line 9369 
  int j;
  #line 9369 
  int off;
  #line 9370 
  __be32 val;
  #line 9370 
  __be32 m;
  #line 9371 
  bool found_entry = (_Bool)0;
  #line 9371 
  bool found_jump_field = (_Bool)0;
  #line 9373 
  i = 0;
  #line 9373 
  while ((int)(cls->__anonCompField_tc_cls_u32_offload_205.knode.sel)->nkeys > i) {
    #line 9374 
    off = (cls->__anonCompField_tc_cls_u32_offload_205.knode.sel)->keys[i].off;
    #line 9375 
    val = (cls->__anonCompField_tc_cls_u32_offload_205.knode.sel)->keys[i].val;
    #line 9376 
    m = (cls->__anonCompField_tc_cls_u32_offload_205.knode.sel)->keys[i].mask;
    #line 9378 
    j = 0;
    #line 9378 
    while ((field_ptr + (unsigned long)j)->val != (int (*)(struct ixgbe_fdir_filter *, union ixgbe_atr_input *, u32 , u32 ))0) {
      #line 9379 
      if ((field_ptr + (unsigned long)j)->off == (unsigned int)off) {
        #line 9380 
        (*((field_ptr + (unsigned long)j)->val))(input,mask,val,m);
        #line 9382 
        input->filter.formatted.flow_type = (unsigned char)((int)input->filter.formatted.flow_type | (int)((unsigned char)(field_ptr + (unsigned long)j)->type));
        #line 9384 
        found_entry = (_Bool)1;
        #line 9385 
        break;
      }
      #line 9378 
      j ++;
    }
    #line 9388 
    if (nexthdr != (struct ixgbe_nexthdr *)0) 
      #line 9389 
      if ((nexthdr->off == (unsigned int)(cls->__anonCompField_tc_cls_u32_offload_205.knode.sel)->keys[i].off && nexthdr->val == (cls->__anonCompField_tc_cls_u32_offload_205.knode.sel)->keys[i].val) && nexthdr->mask == (cls->__anonCompField_tc_cls_u32_offload_205.knode.sel)->keys[i].mask) 
        #line 9394 
        found_jump_field = (_Bool)1; else 
                                          #line 9396 
                                          goto __Cont;
    #line 9373 
    __Cont: 
            #line 9373 
    i ++;
  }
  #line 9400 
  if (nexthdr != (struct ixgbe_nexthdr *)0 && ! found_jump_field) 
                                                                  #line 9401 
                                                                  return -22;
  #line 9403 
  if (! found_entry) 
                     #line 9404 
                     return 0;
  #line 9406 
  mask->formatted.flow_type = (unsigned char)7U;
  #line 9409 
  if ((unsigned int)input->filter.formatted.flow_type == 0U) 
                                                             #line 9410 
                                                             mask->formatted.flow_type = (unsigned char)((unsigned int)mask->formatted.flow_type & 4U);
  #line 9412 
  return 0;
}

#line 9415  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_configure_clsu32(struct ixgbe_adapter *adapter, struct tc_cls_u32_offload *cls)
{
  #line 9421 
  struct ixgbe_mat_field *field_ptr;
  #line 9425 
  int i;
  #line 9426 
  u8 queue;
  #line 9427 
  u32 uhtid;
  #line 9427 
  u32 link_uhtid;
  #line 9418 
  __be16 protocol = cls->common.protocol;
  #line 9419 
  u32 loc = cls->__anonCompField_tc_cls_u32_offload_205.knode.handle & 1048575U;
  #line 9420 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 9422 
  struct ixgbe_fdir_filter *input = (struct ixgbe_fdir_filter *)0;
  #line 9423 
  union ixgbe_atr_input *mask = (union ixgbe_atr_input *)0;
  #line 9424 
  struct ixgbe_jump_table *jump = (struct ixgbe_jump_table *)0;
  #line 9425 
  int err = -22;
  #line 9429 
  uhtid = cls->__anonCompField_tc_cls_u32_offload_205.knode.handle >> 20;
  #line 9430 
  link_uhtid = cls->__anonCompField_tc_cls_u32_offload_205.knode.link_handle >> 20;
  #line 9439 
  if ((unsigned int)protocol != 8U) 
                                    #line 9440 
                                    return err;
  #line 9442 
  if ((unsigned int)((1024 << adapter->fdir_pballoc) + -2) <= loc) {
    #line 9443 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 9443 
                                             netdev_err(adapter->netdev,(char *)"Location out of range\n");
    #line 9444 
    return err;
  }
  #line 9454 
  if (uhtid == 2048U) 
                      #line 9455 
                      field_ptr = (adapter->jump_tables[0])->mat;
  else {
    #line 9457 
    if (uhtid > 9U) 
                    #line 9458 
                    return err;
    #line 9459 
    if (adapter->jump_tables[uhtid] == (struct ixgbe_jump_table *)0) 
      #line 9460 
      return err;
    #line 9461 
    field_ptr = (adapter->jump_tables[uhtid])->mat;
  }
  #line 9464 
  if (field_ptr == (struct ixgbe_mat_field *)0) 
                                                #line 9465 
                                                return err;
  #line 9473 
  if (link_uhtid != 0U) {
    #line 9474 
    struct ixgbe_nexthdr *nexthdr = (struct ixgbe_nexthdr *)(& ixgbe_ipv4_jumps);
    #line 9476 
    if (link_uhtid > 9U) 
                         #line 9477 
                         return err;
    #line 9479 
    if (! test_bit((long)(link_uhtid + 4294967295U),& adapter->tables)) 
      #line 9480 
      return err;
    #line 9487 
    if (adapter->jump_tables[link_uhtid] != (struct ixgbe_jump_table *)0 && (adapter->jump_tables[link_uhtid])->link_hdl != 0U) {
      #line 9489 
      if (((int)adapter->msg_enable & 1) != 0) 
                                               #line 9489 
                                               netdev_err(adapter->netdev,(char *)"Link filter exists for link: %x\n",link_uhtid);
      #line 9491 
      return err;
    }
    #line 9494 
    i = 0;
    #line 9494 
    while ((nexthdr + (unsigned long)i)->jump != (struct ixgbe_mat_field *)0) {
      #line 9495 
      if (((nexthdr + (unsigned long)i)->o != (unsigned int)(cls->__anonCompField_tc_cls_u32_offload_205.knode.sel)->offoff || (nexthdr + (unsigned long)i)->s != (unsigned int)(cls->__anonCompField_tc_cls_u32_offload_205.knode.sel)->offshift) || (nexthdr + (unsigned long)i)->m != (unsigned int)(cls->__anonCompField_tc_cls_u32_offload_205.knode.sel)->offmask) 
        #line 9499 
        return err;
      #line 9501 
      jump = (struct ixgbe_jump_table *)kzalloc(288UL,3264U);
      #line 9502 
      if (jump == (struct ixgbe_jump_table *)0) 
                                                #line 9503 
                                                return -12;
      #line 9504 
      input = (struct ixgbe_fdir_filter *)kzalloc(72UL,3264U);
      #line 9505 
      if (input == (struct ixgbe_fdir_filter *)0) {
        #line 9506 
        err = -12;
        #line 9507 
        goto free_jump;
      }
      #line 9509 
      mask = (union ixgbe_atr_input *)kzalloc(44UL,3264U);
      #line 9510 
      if (mask == (union ixgbe_atr_input *)0) {
        #line 9511 
        err = -12;
        #line 9512 
        goto free_input;
      }
      #line 9514 
      jump->input = input;
      #line 9515 
      jump->mask = mask;
      #line 9516 
      jump->link_hdl = cls->__anonCompField_tc_cls_u32_offload_205.knode.handle;
      #line 9518 
      err = ixgbe_clsu32_build_input(input,mask,cls,field_ptr,nexthdr + (unsigned long)i);
      #line 9520 
      if (err == 0) {
        #line 9521 
        jump->mat = (nexthdr + (unsigned long)i)->jump;
        #line 9522 
        adapter->jump_tables[link_uhtid] = jump;
        #line 9523 
        break;
      }
      else {
        #line 9525 
        kfree((void *)mask);
        #line 9526 
        kfree((void *)input);
        #line 9527 
        kfree((void *)jump);
      }
      #line 9494 
      i ++;
    }
    #line 9530 
    return 0;
  }
  #line 9533 
  input = (struct ixgbe_fdir_filter *)kzalloc(72UL,3264U);
  #line 9534 
  if (input == (struct ixgbe_fdir_filter *)0) 
                                              #line 9535 
                                              return -12;
  #line 9536 
  mask = (union ixgbe_atr_input *)kzalloc(44UL,3264U);
  #line 9537 
  if (mask == (union ixgbe_atr_input *)0) {
    #line 9538 
    err = -12;
    #line 9539 
    goto free_input;
  }
  #line 9542 
  if (uhtid != 2048U && adapter->jump_tables[uhtid] != (struct ixgbe_jump_table *)0) {
    #line 9543 
    if ((adapter->jump_tables[uhtid])->input != (struct ixgbe_fdir_filter *)0) 
      #line 9544 
      memcpy((void *)input,(void *)(adapter->jump_tables[uhtid])->input,72UL);
    #line 9546 
    if ((adapter->jump_tables[uhtid])->mask != (union ixgbe_atr_input *)0) 
      #line 9547 
      memcpy((void *)mask,(void *)(adapter->jump_tables[uhtid])->mask,44UL);
    #line 9553 
    i = 1;
    #line 9553 
    while (i <= 9) {
      {
        #line 9554 
        struct ixgbe_jump_table *link = adapter->jump_tables[i];
        #line 9556 
        if (link != (struct ixgbe_jump_table *)0) {
          #line 9556 
          if ((int)test_bit((long)(loc + 4294967295U),
                 (unsigned long *)(& link->child_loc_map)) != 0) {
            #line 9557 
            if (((int)adapter->msg_enable & 1) != 0) 
                                                     #line 9557 
                                                     netdev_err(adapter->netdev,(char *)"Filter exists in location: %x\n",loc);
            #line 9559 
            err = -22;
            #line 9560 
            goto err_out;
          }
        }
      }
      #line 9553 
      i ++;
    }
  }
  #line 9564 
  err = ixgbe_clsu32_build_input(input,mask,cls,field_ptr,(struct ixgbe_nexthdr *)0);
  #line 9565 
  if (err != 0) 
                #line 9566 
                goto err_out;
  #line 9568 
  err = parse_tc_actions(adapter,cls->__anonCompField_tc_cls_u32_offload_205.knode.exts,& input->action,& queue);
  #line 9570 
  if (err < 0) 
               #line 9571 
               goto err_out;
  #line 9573 
  input->sw_idx = (unsigned short)loc;
  #line 9575 
  cif_spin_lock_fdir_perfect_lock_of_ixgbe_adapter(& adapter->fdir_perfect_lock);
  #line 9577 
  if (hlist_empty(& adapter->fdir_filter_list) != 0) {
    #line 9578 
    memcpy((void *)(& adapter->fdir_mask),(void *)mask,44UL);
    #line 9579 
    err = ixgbe_fdir_set_input_mask_82599(hw,mask);
    #line 9580 
    if (err != 0) 
                  #line 9581 
                  goto err_out_w_lock;
  }
  else {
    #line 9582 
    if (memcmp((void *)(& adapter->fdir_mask),(void *)mask,44UL) != 0) {
      #line 9583 
      err = -22;
      #line 9584 
      goto err_out_w_lock;
    }
  }
  #line 9587 
  ixgbe_atr_compute_perfect_hash_82599(& input->filter,mask);
  #line 9588 
  err = ixgbe_fdir_write_perfect_filter_82599(hw,& input->filter,(unsigned short)((int)input->sw_idx),(unsigned char)((int)queue));
  #line 9590 
  if (err == 0) 
                #line 9591 
                ixgbe_update_ethtool_fdir_entry(adapter,input,(unsigned short)((int)input->sw_idx));
  #line 9592 
  cif_spin_unlock_fdir_perfect_lock_of_ixgbe_adapter(& adapter->fdir_perfect_lock);
  #line 9594 
  if (uhtid != 2048U && adapter->jump_tables[uhtid] != (struct ixgbe_jump_table *)0) 
    #line 9595 
    cif_set_bit((long)(loc + 4294967295U),(unsigned long *)(& (adapter->jump_tables[uhtid])->child_loc_map));
  #line 9597 
  kfree((void *)mask);
  #line 9598 
  return err;
  #line 9599 
  err_out_w_lock: 
                  #line 9599 
  ;
  #line 9600 
  cif_spin_unlock_fdir_perfect_lock_of_ixgbe_adapter(& adapter->fdir_perfect_lock);
  #line 9601 
  err_out: 
           #line 9601 
  ;
  #line 9602 
  kfree((void *)mask);
  #line 9603 
  free_input: 
              #line 9603 
  ;
  #line 9604 
  kfree((void *)input);
  #line 9605 
  free_jump: 
             #line 9605 
  ;
  #line 9606 
  kfree((void *)jump);
  #line 9607 
  return err;
}

#line 9610  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_setup_tc_cls_u32(struct ixgbe_adapter *adapter, struct tc_cls_u32_offload *cls_u32)
{
  #line 9613 
  switch ((unsigned int)cls_u32->command) {
    #line 9614 
    case (unsigned int)0: 
                          #line 9614 
    ;
    #line 9615 
    case (unsigned int)1: 
                          #line 9615 
    ;
    #line 9616 
    return ixgbe_configure_clsu32(adapter,cls_u32);
    #line 9617 
    case (unsigned int)2: 
                          #line 9617 
    ;
    #line 9618 
    return ixgbe_delete_clsu32(adapter,cls_u32);
    #line 9619 
    case (unsigned int)3: 
                          #line 9619 
    ;
    #line 9620 
    case (unsigned int)4: 
                          #line 9620 
    ;
    #line 9621 
    return ixgbe_configure_clsu32_add_hnode(adapter,cls_u32);
    #line 9622 
    case (unsigned int)5: 
                          #line 9622 
    ;
    #line 9623 
    return ixgbe_configure_clsu32_del_hnode(adapter,cls_u32);
    #line 9624 
    default: 
             #line 9624 
    ;
    #line 9625 
    return -95;
  }
}

#line 9629  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_setup_tc_block_cb(enum tc_setup_type type, void *type_data, void *cb_priv)
{
  #line 9632 
  struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)cb_priv;
  #line 9634 
  if (! tc_cls_can_offload_and_chain0(adapter->netdev,
                                    (struct flow_cls_common_offload *)type_data)) 
    #line 9635 
    return -95;
  #line 9637 
  switch ((unsigned int)type) {
    #line 9638 
    case (unsigned int)1: 
                          #line 9638 
    ;
    #line 9639 
    return ixgbe_setup_tc_cls_u32(adapter,
                               (struct tc_cls_u32_offload *)type_data);
    #line 9640 
    default: 
             #line 9640 
    ;
    #line 9641 
    return -95;
  }
}

#line 9645  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_setup_tc_mqprio(struct net_device *dev, struct tc_mqprio_qopt *mqprio)
{
  #line 9648 
  mqprio->hw = (unsigned char)1U;
  #line 9649 
  return ixgbe_setup_tc(dev,(unsigned char)((int)mqprio->num_tc));
}

#line 9652  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct list_head ixgbe_block_cb_list = {.next = & ixgbe_block_cb_list, .prev = & ixgbe_block_cb_list};
#line 9654  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int __ixgbe_setup_tc(struct net_device *dev, enum tc_setup_type type, void *type_data)
{
  #line 9657 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 9659 
  switch ((unsigned int)type) {
    #line 9660 
    case (unsigned int)5: 
                          #line 9660 
    ;
    #line 9661 
    return flow_block_cb_setup_simple((struct flow_block_offload *)type_data,
                                   & ixgbe_block_cb_list,
                                   & ixgbe_setup_tc_block_cb,(void *)adapter,
                                   (void *)adapter,(_Bool)1);
    #line 9665 
    case (unsigned int)0: 
                          #line 9665 
    ;
    #line 9666 
    return ixgbe_setup_tc_mqprio(dev,(struct tc_mqprio_qopt *)type_data);
    #line 9667 
    default: 
             #line 9667 
    ;
    #line 9668 
    return -95;
  }
}

#line 9673  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_sriov_reinit(struct ixgbe_adapter *adapter)
{
  #line 9675 
  struct net_device *netdev = adapter->netdev;
  #line 9677 
  rtnl_lock();
  #line 9678 
  ixgbe_setup_tc(netdev,(unsigned char)((int)adapter->hw_tcs));
  #line 9679 
  rtnl_unlock();
  #line 9680 
  return;
}

#line 9683  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_do_reset(struct net_device *netdev)
{
  #line 9685 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 9687 
  if ((int)netif_running(netdev) != 0) 
                                       #line 9688 
                                       ixgbe_reinit_locked(adapter); else 
                                                                    #line 9690 
                                                                    ixgbe_reset(adapter);
  #line 9691 
  return;
}

#line 9693  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static netdev_features_t ixgbe_fix_features(struct net_device *netdev, netdev_features_t features)
{
  #line 9696 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 9699 
  if ((features & 549755813888ULL) == 0ULL) 
                                            #line 9700 
                                            features &= 18446744073709518847ULL;
  #line 9703 
  if (((unsigned long)adapter->flags2 & 1UL) == 0UL) 
                                                     #line 9704 
                                                     features &= 18446744073709518847ULL;
  #line 9706 
  if (adapter->xdp_prog != (struct bpf_prog *)0 && (features & 32768ULL) != 0ULL) {
    #line 9707 
    _dev_err(& (adapter->pdev)->dev,(char *)"LRO is not supported with XDP\n");
    #line 9708 
    features &= 18446744073709518847ULL;
  }
  #line 9711 
  return features;
}

#line 9714  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_reset_l2fw_offload(struct ixgbe_adapter *adapter)
{
  #line 9716 
  int __UNIQUE_ID___x596;
  #line 9716 
  int tmp_1;
  {
    #line 9716 
    __UNIQUE_ID___x596 = (int)ixgbe_max_rss_indices(adapter);
    #line 9716 
    int __UNIQUE_ID___y597 = (int)num_online_cpus();
    #line 9716 
    if (__UNIQUE_ID___x596 < __UNIQUE_ID___y597) 
                                                 #line 9716 
                                                 tmp_1 = __UNIQUE_ID___x596; else 
                                                                    #line 9716 
                                                                    tmp_1 = __UNIQUE_ID___y597;
    }
  #line 9716 
  int rss = tmp_1;
  #line 9720 
  if ((unsigned int)adapter->ring_feature[1].offset == 0U) 
                                                           #line 9721 
                                                           adapter->flags &= 4286562303U;
  #line 9724 
  adapter->ring_feature[2].limit = (unsigned short)rss;
  #line 9725 
  adapter->ring_feature[1].limit = (unsigned short)1U;
  #line 9727 
  ixgbe_setup_tc(adapter->netdev,(unsigned char)((int)adapter->hw_tcs));
  #line 9728 
  return;
}

#line 9730  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_set_features(struct net_device *netdev, netdev_features_t features)
{
  #line 9733 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 9734 
  netdev_features_t changed = netdev->features ^ features;
  #line 9735 
  bool need_reset = (_Bool)0;
  #line 9738 
  if ((features & 32768ULL) == 0ULL) {
    #line 9739 
    if (((unsigned long)adapter->flags2 & 2UL) != 0UL) 
                                                       #line 9740 
                                                       need_reset = (_Bool)1;
    #line 9741 
    adapter->flags2 &= 4294967293U;
  }
  else 
    #line 9742 
    if (((unsigned long)adapter->flags2 & 1UL) != 0UL && ((unsigned long)adapter->flags2 & 2UL) == 0UL) 
      #line 9744 
      if ((unsigned int)adapter->rx_itr_setting == 1U || (unsigned int)adapter->rx_itr_setting > 24U) {
        #line 9746 
        adapter->flags2 |= 2U;
        #line 9747 
        need_reset = (_Bool)1;
      }
      else 
        #line 9748 
        if (((changed ^ features) & 32768ULL) != 0ULL) 
          #line 9749 
          if (((int)adapter->msg_enable & 2) != 0) 
                                                   #line 9749 
                                                   netdev_info(adapter->netdev,(char *)"rx-usecs set too low, ");
  #line 9758 
  if ((features & 137438953472ULL) != 0ULL || (features & 281474976710656ULL) != 0ULL) {
    #line 9760 
    if (((unsigned long)adapter->flags & 524288UL) == 0UL) 
                                                           #line 9761 
                                                           need_reset = (_Bool)1;
    #line 9763 
    adapter->flags &= 4294705151U;
    #line 9764 
    adapter->flags |= 524288U;
  }
  else {
    #line 9767 
    if (((unsigned long)adapter->flags & 524288UL) != 0UL) 
                                                           #line 9768 
                                                           need_reset = (_Bool)1;
    #line 9770 
    adapter->flags &= 4294443007U;
    #line 9773 
    if (! (((((unsigned long)adapter->flags & 8388608UL) != 0UL || (unsigned int)adapter->hw_tcs > 1U) || (unsigned int)adapter->ring_feature[2].limit <= 1U) || adapter->atr_sample_rate == 0U)) 
      #line 9782 
      adapter->flags |= 262144U;
  }
  #line 9785 
  if ((changed & 8796093022208ULL) != 0ULL) 
                                            #line 9786 
                                            need_reset = (_Bool)1;
  #line 9788 
  netdev->features = features;
  #line 9790 
  if (((unsigned long)adapter->flags & 16777216UL) != 0UL) 
    #line 9791 
    if ((features & 549755813888ULL) != 0ULL) 
                                              #line 9792 
                                              adapter->flags2 |= 4096U;
    else {
      #line 9794 
      u32 port_mask = 65535U;
      #line 9796 
      ixgbe_clear_udp_tunnel_port(adapter,port_mask);
    }
  #line 9800 
  if (((unsigned long)adapter->flags & 268435456UL) != 0UL) 
    #line 9801 
    if ((features & 549755813888ULL) != 0ULL) 
                                              #line 9802 
                                              adapter->flags2 |= 4096U;
    else {
      #line 9804 
      u32 port_mask_0 = 4294901760U;
      #line 9806 
      ixgbe_clear_udp_tunnel_port(adapter,port_mask_0);
    }
  #line 9810 
  if ((changed & 140737488355328ULL) != 0ULL && adapter->num_rx_pools > 1) 
    #line 9811 
    ixgbe_reset_l2fw_offload(adapter);
  else 
    #line 9812 
    if ((int)need_reset != 0) 
                              #line 9813 
                              ixgbe_do_reset(netdev);
    else 
      #line 9814 
      if ((changed & 768ULL) != 0ULL) 
                                      #line 9816 
                                      ixgbe_set_rx_mode(netdev);
  #line 9818 
  return 1;
}

#line 9826  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_add_udp_tunnel_port(struct net_device *dev, struct udp_tunnel_info *ti)
{
  #line 9833 
  u32 reg;
  #line 9829 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 9830 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 9831 
  __be16 port = ti->port;
  #line 9832 
  u32 port_shift = 0U;
  #line 9835 
  if ((unsigned int)ti->sa_family != 2U) 
                                         #line 9836 
                                         return;
  #line 9838 
  switch ((int)ti->type) {
    #line 9839 
    case 0: 
            #line 9839 
    ;
    #line 9840 
    if (((unsigned long)adapter->flags & 16777216UL) == 0UL) 
                                                             #line 9841 
                                                             return;
    #line 9843 
    if ((int)adapter->vxlan_port == (int)port) 
                                               #line 9844 
                                               return;
    #line 9846 
    if ((unsigned int)adapter->vxlan_port != 0U) {
      #line 9847 
      ;
      #line 9847 
      netdev_info(dev,(char *)"VXLAN port %d set, not adding port %d\n",(int)__builtin_bswap16((unsigned short)((int)adapter->vxlan_port)),(int)__builtin_bswap16((unsigned short)((int)port)));
      #line 9851 
      return;
    }
    #line 9854 
    adapter->vxlan_port = port;
    #line 9855 
    break;
    #line 9856 
    case 1: 
            #line 9856 
    ;
    #line 9857 
    if (((unsigned long)adapter->flags & 268435456UL) == 0UL) 
                                                              #line 9858 
                                                              return;
    #line 9860 
    if ((int)adapter->geneve_port == (int)port) 
                                                #line 9861 
                                                return;
    #line 9863 
    if ((unsigned int)adapter->geneve_port != 0U) {
      #line 9864 
      ;
      #line 9864 
      netdev_info(dev,(char *)"GENEVE port %d set, not adding port %d\n",(int)__builtin_bswap16((unsigned short)((int)adapter->geneve_port)),(int)__builtin_bswap16((unsigned short)((int)port)));
      #line 9868 
      return;
    }
    #line 9871 
    port_shift = 16U;
    #line 9872 
    adapter->geneve_port = port;
    #line 9873 
    break;
    #line 9874 
    default: 
             #line 9874 
    ;
    #line 9875 
    return;
  }
  #line 9878 
  reg = ixgbe_read_reg(hw,20604U) | (unsigned int)((int)__builtin_bswap16((unsigned short)((int)port)) << port_shift);
  #line 9879 
  ixgbe_write_reg_1(hw,20604U,reg);
  #line 9880 
  return;
}

#line 9887  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_del_udp_tunnel_port(struct net_device *dev, struct udp_tunnel_info *ti)
{
  #line 9891 
  u32 port_mask;
  #line 9890 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 9893 
  if ((unsigned int)ti->type > 1U) 
                                   #line 9895 
                                   return;
  #line 9897 
  if ((unsigned int)ti->sa_family != 2U) 
                                         #line 9898 
                                         return;
  #line 9900 
  switch ((int)ti->type) {
    #line 9901 
    case 0: 
            #line 9901 
    ;
    #line 9902 
    if (((unsigned long)adapter->flags & 16777216UL) == 0UL) 
                                                             #line 9903 
                                                             return;
    #line 9905 
    if ((int)adapter->vxlan_port != (int)ti->port) {
      #line 9906 
      ;
      #line 9906 
      netdev_info(dev,(char *)"VXLAN port %d not found\n",(int)__builtin_bswap16((unsigned short)((int)ti->port)));
      #line 9908 
      return;
    }
    #line 9911 
    port_mask = 65535U;
    #line 9912 
    break;
    #line 9913 
    case 1: 
            #line 9913 
    ;
    #line 9914 
    if (((unsigned long)adapter->flags & 268435456UL) == 0UL) 
                                                              #line 9915 
                                                              return;
    #line 9917 
    if ((int)adapter->geneve_port != (int)ti->port) {
      #line 9918 
      ;
      #line 9918 
      netdev_info(dev,(char *)"GENEVE port %d not found\n",(int)__builtin_bswap16((unsigned short)((int)ti->port)));
      #line 9920 
      return;
    }
    #line 9923 
    port_mask = 4294901760U;
    #line 9924 
    break;
    #line 9925 
    default: 
             #line 9925 
    ;
    #line 9926 
    return;
  }
  #line 9929 
  ixgbe_clear_udp_tunnel_port(adapter,port_mask);
  #line 9930 
  adapter->flags2 |= 4096U;
  #line 9931 
  return;
}

#line 9933  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_ndo_fdb_add(struct ndmsg *ndm, struct nlattr **tb, struct net_device *dev, unsigned char *addr, u16 vid, u16 flags, struct netlink_ext_ack *extack)
{
  #line 9940 
  if ((int)is_unicast_ether_addr(addr) != 0) 
                                             #line 9940 
                                             goto _LOR;
  else {
    #line 9940 
    if ((int)is_link_local_ether_addr(addr) != 0) {
      #line 9940 
      _LOR: {
              #line 9941 
              struct ixgbe_adapter *adapter = netdev_priv(dev);
              #line 9942 
              u16 pool = adapter->ring_feature[1].offset;
              #line 9944 
              ;
              #line 9944 
              if (dev->uc.count >= ixgbe_available_rars(adapter,(unsigned short)((int)pool))) 
                #line 9945 
                return -12;
            }
    }
  }
  #line 9948 
  return ndo_dflt_fdb_add(ndm,tb,dev,addr,(unsigned short)((int)vid),
                         (unsigned short)((int)flags));
}

#line 9958  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_configure_bridge_mode(struct ixgbe_adapter *adapter, __u16 mode)
{
  #line 9962 
  unsigned int p;
  #line 9962 
  unsigned int num_pools;
  #line 9963 
  u32 vmdctl;
  #line 9961 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 9965 
  switch ((int)mode) {
    #line 9966 
    case 1: 
            #line 9966 
    ;
    #line 9968 
    ixgbe_write_reg_1(& adapter->hw,33312U,0U);
    #line 9974 
    vmdctl = ixgbe_read_reg(hw,22556U);
    #line 9975 
    vmdctl |= 1073741824U;
    #line 9976 
    ixgbe_write_reg_1(hw,22556U,vmdctl);
    #line 9981 
    num_pools = adapter->num_vfs + (unsigned int)adapter->num_rx_pools;
    #line 9982 
    p = 0U;
    #line 9982 
    while (p < num_pools) {
      #line 9983 
      if (hw->mac.ops.set_source_address_pruning != (void (*)(struct ixgbe_hw *, bool , unsigned int ))0) 
        #line 9984 
        (*(hw->mac.ops.set_source_address_pruning))(hw,(_Bool)1,p);
      #line 9982 
      p ++;
    }
    #line 9988 
    break;
    #line 9989 
    case 0: 
            #line 9989 
    ;
    #line 9991 
    ixgbe_write_reg_1(& adapter->hw,33312U,1U);
    #line 9997 
    vmdctl = ixgbe_read_reg(hw,22556U);
    #line 9998 
    if (adapter->num_vfs == 0U) 
                                #line 9999 
                                vmdctl &= 3221225471U;
    #line 10000 
    ixgbe_write_reg_1(hw,22556U,vmdctl);
    #line 10005 
    num_pools = adapter->num_vfs + (unsigned int)adapter->num_rx_pools;
    #line 10006 
    p = 0U;
    #line 10006 
    while (p < num_pools) {
      #line 10007 
      if (hw->mac.ops.set_source_address_pruning != (void (*)(struct ixgbe_hw *, bool , unsigned int ))0) 
        #line 10008 
        (*(hw->mac.ops.set_source_address_pruning))(hw,(_Bool)0,p);
      #line 10006 
      p ++;
    }
    #line 10012 
    break;
    #line 10013 
    default: 
             #line 10013 
    ;
    #line 10014 
    return -22;
  }
  #line 10017 
  adapter->bridge_mode = mode;
  #line 10019 
  if (((int)adapter->msg_enable & 1) != 0) {
    #line 10019 
    char *tmp;
    #line 10019 
    if ((unsigned int)mode == 1U) 
                                  #line 10019 
                                  tmp = (char *)"VEPA"; else 
                                                             #line 10019 
                                                             tmp = (char *)"VEB";
    #line 10019 
    ;
    #line 10019 
    netdev_info(adapter->netdev,(char *)"enabling bridge mode: %s\n",tmp);
  }
  #line 10022 
  return 0;
}

#line 10025  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_ndo_bridge_setlink(struct net_device *dev, struct nlmsghdr *nlh, u16 flags, struct netlink_ext_ack *extack)
{
  #line 10030 
  struct nlattr *attr;
  #line 10030 
  struct nlattr *br_spec;
  #line 10031 
  int rem;
  #line 10029 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 10033 
  if (((unsigned long)adapter->flags & 8388608UL) == 0UL) 
                                                          #line 10034 
                                                          return -95;
  #line 10036 
  br_spec = nlmsg_find_attr(nlh,16,26);
  #line 10037 
  if (br_spec == (struct nlattr *)0) 
                                     #line 10038 
                                     return -22;
  #line 10040 
  attr = (struct nlattr *)nla_data(br_spec);
  #line 10040 
  rem = nla_len(br_spec);
  #line 10040 
  while (1) {
    #line 10040 
    if (! (nla_ok(attr,rem) != 0)) 
                                   #line 10040 
                                   break;
    {
      #line 10041 
      int status;
      #line 10042 
      __u16 mode;
      #line 10044 
      if (nla_type(attr) != 1) 
                               #line 10045 
                               goto __Cont;
      #line 10047 
      if ((unsigned int)nla_len(attr) <= 1U) 
                                             #line 10048 
                                             return -22;
      #line 10050 
      mode = nla_get_u16(attr);
      #line 10051 
      status = ixgbe_configure_bridge_mode(adapter,(unsigned short)((int)mode));
      #line 10052 
      if (status != 0) 
                       #line 10053 
                       return status;
      #line 10055 
      break;
    }
    #line 10040 
    __Cont: 
            #line 10040 
    attr = nla_next(attr,& rem);
  }
  #line 10058 
  return 0;
}

#line 10061  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_ndo_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq, struct net_device *dev, u32 filter_mask, int nlflags)
{
  #line 10065 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 10067 
  if (((unsigned long)adapter->flags & 8388608UL) == 0UL) 
                                                          #line 10068 
                                                          return 0;
  #line 10070 
  return ndo_dflt_bridge_getlink(skb,pid,seq,dev,
                                (unsigned short)((int)adapter->bridge_mode),
                                0U,0U,nlflags,filter_mask,
                                (int (*)(struct sk_buff *,
                                         struct net_device *, u32 ))0);
}

#line 10075  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void *ixgbe_fwd_add(struct net_device *pdev, struct net_device *vdev)
{
  #line 10078 
  struct ixgbe_fwd_adapter *accel;
  #line 10079 
  int tmp_0;
  #line 10080 
  int pool;
  #line 10080 
  int err;
  #line 10077 
  struct ixgbe_adapter *adapter = netdev_priv(pdev);
  #line 10079 
  tmp_0 = (int)adapter->hw_tcs != 0;
  #line 10079 
  if (! tmp_0) 
               #line 10079 
               tmp_0 = 1;
  #line 10079 
  int tcs = tmp_0;
  #line 10082 
  if (adapter->xdp_prog != (struct bpf_prog *)0) {
    #line 10083 
    if (((int)adapter->msg_enable & 2) != 0) 
                                             #line 10083 
                                             netdev_warn(adapter->netdev,(char *)"L2FW offload is not supported with XDP\n");
    #line 10084 
    return ERR_PTR(-22L);
  }
  #line 10091 
  if (! macvlan_supports_dest_filter(vdev)) {
    #line 10092 
    return ERR_PTR(-124L);
  }
  #line 10098 
  if ((int)netif_is_multiqueue(vdev) != 0) {
    #line 10099 
    return ERR_PTR(-34L);
  }
  #line 10101 
  pool = (int)find_first_zero_bit((unsigned long *)(& adapter->fwd_bitmask),
                            (unsigned long)adapter->num_rx_pools);
  #line 10102 
  if (adapter->num_rx_pools == pool) {
    #line 10104 
    u16 reserved_pools;
    #line 10103 
    u16 used_pools = (unsigned short)((int)((unsigned short)adapter->num_vfs) + (int)((unsigned short)adapter->num_rx_pools));
    #line 10106 
    if (((unsigned long)adapter->flags & 4096UL) != 0UL && adapter->num_rx_pools >= 64 / tcs || adapter->num_rx_pools > 63) {
      #line 10109 
      return ERR_PTR(-16L);
    }
    #line 10115 
    if ((unsigned int)used_pools > 63U) {
      #line 10116 
      return ERR_PTR(-16L);
    }
    #line 10119 
    adapter->flags |= 8404992U;
    #line 10126 
    if ((unsigned int)used_pools <= 31U && adapter->num_rx_pools <= 15) {
      #line 10127 
      unsigned short __UNIQUE_ID___x598;
      #line 10127 
      int tmp_9;
      {
        #line 10127 
        __UNIQUE_ID___x598 = (unsigned short)(32U - (unsigned int)used_pools);
        #line 10127 
        unsigned short __UNIQUE_ID___y599 = (unsigned short)(16U - (unsigned int)((unsigned short)adapter->num_rx_pools));
        #line 10127 
        if ((int)__UNIQUE_ID___x598 < (int)__UNIQUE_ID___y599) 
                                                               #line 10127 
                                                               tmp_9 = (int)__UNIQUE_ID___x598; else 
                                                                    #line 10127 
                                                                    tmp_9 = (int)__UNIQUE_ID___y599;
        }
      #line 10127 
      reserved_pools = (unsigned short)tmp_9;
    }
    else 
      #line 10130 
      if (adapter->num_rx_pools <= 31) {
        #line 10131 
        unsigned short __UNIQUE_ID___x600;
        #line 10131 
        int tmp_11;
        {
          #line 10131 
          __UNIQUE_ID___x600 = (unsigned short)(64U - (unsigned int)used_pools);
          #line 10131 
          unsigned short __UNIQUE_ID___y601 = (unsigned short)(32U - (unsigned int)((unsigned short)adapter->num_rx_pools));
          #line 10131 
          if ((int)__UNIQUE_ID___x600 < (int)__UNIQUE_ID___y601) 
                                                                 #line 10131 
                                                                 tmp_11 = (int)__UNIQUE_ID___x600; else 
                                                                    #line 10131 
                                                                    tmp_11 = (int)__UNIQUE_ID___y601;
          }
        #line 10131 
        reserved_pools = (unsigned short)tmp_11;
      }
      else 
           #line 10135 
           reserved_pools = (unsigned short)(64U - (unsigned int)used_pools);
    #line 10138 
    if ((unsigned int)reserved_pools == 0U) {
      #line 10139 
      return ERR_PTR(-16L);
    }
    #line 10141 
    adapter->ring_feature[1].limit = (unsigned short)((int)adapter->ring_feature[1].limit + (int)reserved_pools);
    #line 10144 
    err = ixgbe_setup_tc(pdev,(unsigned char)((int)adapter->hw_tcs));
    #line 10145 
    if (err != 0) {
      #line 10146 
      return ERR_PTR((long)err);
    }
    #line 10148 
    if (adapter->num_rx_pools <= pool) {
      #line 10149 
      return ERR_PTR(-12L);
    }
  }
  #line 10152 
  accel = (struct ixgbe_fwd_adapter *)kzalloc(536UL,3264U);
  #line 10153 
  if (accel == (struct ixgbe_fwd_adapter *)0) {
    #line 10154 
    return ERR_PTR(-12L);
  }
  #line 10156 
  cif_set_bit((long)pool,(unsigned long *)(& adapter->fwd_bitmask));
  #line 10157 
  netdev_set_sb_channel(vdev,(unsigned short)((int)((unsigned short)pool)));
  #line 10158 
  accel->pool = pool;
  #line 10159 
  accel->netdev = vdev;
  #line 10161 
  if (! netif_running(pdev)) 
                             #line 10162 
                             return (void *)accel;
  #line 10164 
  err = ixgbe_fwd_ring_up(adapter,accel);
  #line 10165 
  if (err != 0) {
    #line 10166 
    return ERR_PTR((long)err);
  }
  #line 10168 
  return (void *)accel;
}

#line 10171  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_fwd_del(struct net_device *pdev, void *priv)
{
  #line 10176 
  unsigned int i;
  #line 10173 
  struct ixgbe_fwd_adapter *accel = (struct ixgbe_fwd_adapter *)priv;
  #line 10174 
  struct ixgbe_adapter *adapter = netdev_priv(pdev);
  #line 10175 
  unsigned int rxbase = accel->rx_base_queue;
  #line 10179 
  ixgbe_del_mac_filter(adapter,(accel->netdev)->dev_addr,(unsigned short)((int)((unsigned short)accel->pool) + (int)adapter->ring_feature[1].offset));
  #line 10185 
  usleep_range(10000UL,20000UL);
  #line 10187 
  i = 0U;
  #line 10187 
  while ((unsigned int)adapter->num_rx_queues_per_pool > i) {
    {
      #line 10188 
      struct ixgbe_ring *ring = adapter->rx_ring[rxbase + i];
      #line 10189 
      struct ixgbe_q_vector *qv = ring->q_vector;
      #line 10194 
      if ((int)netif_running(adapter->netdev) != 0) 
                                                    #line 10195 
                                                    napi_synchronize(& qv->napi);
      #line 10196 
      ring->netdev = (struct net_device *)0;
    }
    #line 10187 
    i ++;
  }
  #line 10200 
  netdev_unbind_sb_channel(pdev,accel->netdev);
  #line 10201 
  netdev_set_sb_channel(accel->netdev,(unsigned short)0);
  #line 10203 
  cif_clear_bit((long)accel->pool,(unsigned long *)(& adapter->fwd_bitmask));
  #line 10204 
  kfree((void *)accel);
  #line 10205 
  return;
}

#line 10211  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static netdev_features_t ixgbe_features_check(struct sk_buff *skb, struct net_device *dev, netdev_features_t features)
{
  #line 10214 
  unsigned int network_hdr_len;
  #line 10214 
  unsigned int mac_hdr_len;
  #line 10217 
  mac_hdr_len = (unsigned int)(skb_network_header(skb) - skb->data);
  #line 10218 
  if ((long)(mac_hdr_len > 127U) != 0L) 
                                        #line 10219 
                                        return features & 18446744030758764407ULL;
  #line 10226 
  network_hdr_len = (unsigned int)(skb_checksum_start(skb) - skb_network_header(skb));
  #line 10227 
  if ((long)(network_hdr_len > 511U) != 0L) 
                                            #line 10228 
                                            return features & 18446744030758764535ULL;
  #line 10239 
  if ((unsigned int)skb->encapsulation != 0U && (features & 524288ULL) == 0ULL) {
    #line 10241 
    if (secpath_exists(skb) == 0) 
                                  #line 10243 
                                  features &= 18446744073709486079ULL;
  }
  #line 10246 
  return features;
}

#line 10249  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_xdp_setup(struct net_device *dev, struct bpf_prog *prog)
{
  #line 10276 
  struct bpf_prog *__ret;
  #line 10251 
  int i;
  #line 10253 
  struct bpf_prog *old_prog;
  #line 10254 
  bool need_reset;
  #line 10251 
  int frame_size = (int)(dev->mtu + 22U);
  #line 10252 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 10256 
  if (((unsigned long)adapter->flags & 8388608UL) != 0UL) 
                                                          #line 10257 
                                                          return -22;
  #line 10259 
  if (((unsigned long)adapter->flags & 4096UL) != 0UL) 
                                                       #line 10260 
                                                       return -22;
  #line 10263 
  i = 0;
  #line 10263 
  while (adapter->num_rx_queues > i) {
    {
      #line 10264 
      struct ixgbe_ring *ring = adapter->rx_ring[i];
      #line 10266 
      if ((int)test_bit(2L,& ring->state) != 0) 
                                                #line 10267 
                                                return -22;
      #line 10269 
      ;
      #line 10269 
      if (ixgbe_rx_bufsz(ring) < (unsigned int)frame_size) 
                                                           #line 10270 
                                                           return -22;
    }
    #line 10263 
    i ++;
  }
  #line 10273 
  if (nr_cpu_ids > 64U) 
                        #line 10274 
                        return -12;
  {
    #line 10276 
    struct bpf_prog **__ai_ptr = & adapter->xdp_prog;
    #line 10276 
    kasan_check_read((void *)__ai_ptr,8U);
    #line 10276 
    __ret = prog;
    #line 10276 
    switch (8UL) {
      #line 10276 
      case (unsigned long)1: 
                             #line 10276 
      ;
      #line 10277 
      ldv_inline_asm();
      #line 10276 
      break;
      #line 10276 
      case (unsigned long)2: 
                             #line 10276 
      ;
      #line 10277 
      ldv_inline_asm();
      #line 10276 
      break;
      #line 10276 
      case (unsigned long)4: 
                             #line 10276 
      ;
      #line 10277 
      ldv_inline_asm();
      #line 10276 
      break;
      #line 10276 
      case (unsigned long)8: 
                             #line 10276 
      ;
      #line 10277 
      ldv_inline_asm();
      #line 10276 
      break;
      #line 10276 
      default: 
               #line 10276 
      ;
      #line 10276 
      __xchg_wrong_size();
    }
    }
  #line 10276 
  old_prog = __ret;
  #line 10277 
  need_reset = (_Bool)(((prog != (struct bpf_prog *)0) ^ (old_prog != (struct bpf_prog *)0)) != 0);
  #line 10280 
  if ((int)need_reset != 0) {
    #line 10281 
    int err;
    #line 10283 
    if (prog == (struct bpf_prog *)0) 
                                      #line 10285 
                                      synchronize_rcu();
    #line 10286 
    err = ixgbe_setup_tc(dev,(unsigned char)((int)adapter->hw_tcs));
    #line 10288 
    if (err != 0) {
      {
        #line 10289 
        uintptr_t _r_a_p__v = (unsigned long)old_prog;
        #line 10291 
        ldv_inline_asm();
        {
          #line 10290 
          union __anonunion___u_2649 __u = {.__val = (struct bpf_prog *)_r_a_p__v};
          #line 10289 
          __write_once_size((void *)(& adapter->xdp_prog),(void *)(& __u.__c),8);
          #line 10289 
          struct bpf_prog *tmp_6 = __u.__val;
        }
      }
      #line 10290 
      return -22;
    }
  }
  else {
    #line 10293 
    i = 0;
    #line 10293 
    while (adapter->num_rx_queues > i) {
      {
        #line 10294 
        struct bpf_prog **__ai_ptr_0 = & (adapter->rx_ring[i])->xdp_prog;
        #line 10294 
        kasan_check_read((void *)__ai_ptr_0,8U);
        {
          #line 10294 
          struct bpf_prog *__ret_0 = adapter->xdp_prog;
          #line 10294 
          switch (8UL) {
            #line 10294 
            case (unsigned long)1: 
                                   #line 10294 
            ;
            #line 10295 
            ldv_inline_asm();
            #line 10294 
            break;
            #line 10294 
            case (unsigned long)2: 
                                   #line 10294 
            ;
            #line 10295 
            ldv_inline_asm();
            #line 10294 
            break;
            #line 10294 
            case (unsigned long)4: 
                                   #line 10294 
            ;
            #line 10295 
            ldv_inline_asm();
            #line 10294 
            break;
            #line 10294 
            case (unsigned long)8: 
                                   #line 10294 
            ;
            #line 10295 
            ldv_inline_asm();
            #line 10294 
            break;
            #line 10294 
            default: 
                     #line 10294 
            ;
            #line 10294 
            __xchg_wrong_size();
          }
          #line 10294 
          struct bpf_prog *tmp_8 = __ret_0;
        }
      }
      #line 10293 
      i ++;
    }
  }
  #line 10298 
  if (old_prog != (struct bpf_prog *)0) 
                                        #line 10299 
                                        bpf_prog_put(old_prog);
  #line 10304 
  if ((int)need_reset != 0 && prog != (struct bpf_prog *)0) {
    #line 10305 
    i = 0;
    #line 10305 
    while (adapter->num_rx_queues > i) {
      #line 10306 
      if ((adapter->xdp_ring[i])->xsk_umem != (struct xdp_umem *)0) 
                                                                    #line 10307 
                                                                    ixgbe_xsk_wakeup(adapter->netdev,(unsigned int)i,1U);
      #line 10305 
      i ++;
    }
  }
  #line 10310 
  return 0;
}

#line 10313  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_xdp(struct net_device *dev, struct netdev_bpf *xdp)
{
  #line 10315 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 10317 
  switch ((unsigned int)xdp->command) {
    #line 10318 
    case (unsigned int)0: 
                          #line 10318 
    ;
    #line 10319 
    return ixgbe_xdp_setup(dev,
                        xdp->__anonCompField_netdev_bpf_159.__anonCompField___anonunion_676_156.prog);
    #line 10320 
    case (unsigned int)2: 
                          #line 10320 
    ;
    #line 10321 
    if (adapter->xdp_prog != (struct bpf_prog *)0) 
                                                   #line 10321 
                                                   xdp->__anonCompField_netdev_bpf_159.__anonCompField___anonunion_676_157.prog_id = ((adapter->xdp_prog)->aux)->id; else 
                                                                    #line 10321 
                                                                    xdp->__anonCompField_netdev_bpf_159.__anonCompField___anonunion_676_157.prog_id = 0U;
    #line 10323 
    return 0;
    #line 10324 
    case (unsigned int)6: 
                          #line 10324 
    ;
    #line 10325 
    return ixgbe_xsk_umem_setup(adapter,
                             xdp->__anonCompField_netdev_bpf_159.xsk.umem,
                             (unsigned short)((int)xdp->__anonCompField_netdev_bpf_159.xsk.queue_id));
    #line 10328 
    default: 
             #line 10328 
    ;
    #line 10329 
    return -22;
  }
}

#line 10333  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_xdp_ring_update_tail(struct ixgbe_ring *ring)
{
  #line 10335 
  ldv_inline_asm();
  #line 10339 
  writel((unsigned int)ring->next_to_use,(void *)ring->tail);
  #line 10340 
  return;
}

#line 10342  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_xdp_xmit(struct net_device *dev, int n, struct xdp_frame **frames, u32 flags)
{
  #line 10346 
  struct ixgbe_ring *ring;
  #line 10348 
  int i;
  #line 10345 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 10347 
  int drops = 0;
  #line 10350 
  if ((long)((int)test_bit(2L,& adapter->state) != 0) != 0L) 
                                                             #line 10351 
                                                             return -100;
  #line 10353 
  if ((long)((flags & 4294967294U) != 0U) != 0L) 
                                                 #line 10354 
                                                 return -22;
  #line 10359 
  if (adapter->xdp_prog != (struct bpf_prog *)0) {
    #line 10359 
    int pscr_ret__;
    #line 10359 
    __this_cpu_preempt_check((char *)"read");
    {
      #line 10359 
      void *__vpp_verify = (void *)0;
      #line 10359 
      void *tmp_2 = __vpp_verify;
    }
    #line 10359 
    switch (4UL) {
      #line 10359 
      int pfo_ret___2;
      #line 10359 
      int pfo_ret__;
      #line 10359 
      int pfo_ret___0;
      #line 10359 
      int pfo_ret___1;
      #line 10359 
      case (unsigned long)1: 
                             #line 10359 
      ;
      #line 10359 
      switch (4UL) {
        #line 10359 
        case (unsigned long)1: 
                               #line 10359 
        ;
        #line 10360 
        ldv_inline_asm();
        #line 10359 
        break;
        #line 10359 
        case (unsigned long)2: 
                               #line 10359 
        ;
        #line 10360 
        ldv_inline_asm();
        #line 10359 
        break;
        #line 10359 
        case (unsigned long)4: 
                               #line 10359 
        ;
        #line 10360 
        ldv_inline_asm();
        #line 10359 
        break;
        #line 10359 
        case (unsigned long)8: 
                               #line 10359 
        ;
        #line 10360 
        ldv_inline_asm();
        #line 10359 
        break;
        #line 10359 
        default: 
                 #line 10359 
        ;
        #line 10359 
        __bad_percpu_size();
      }
      #line 10359 
      pscr_ret__ = pfo_ret__;
      #line 10359 
      break;
      #line 10359 
      case (unsigned long)2: 
                             #line 10359 
      ;
      #line 10359 
      switch (4UL) {
        #line 10359 
        case (unsigned long)1: 
                               #line 10359 
        ;
        #line 10360 
        ldv_inline_asm();
        #line 10359 
        break;
        #line 10359 
        case (unsigned long)2: 
                               #line 10359 
        ;
        #line 10360 
        ldv_inline_asm();
        #line 10359 
        break;
        #line 10359 
        case (unsigned long)4: 
                               #line 10359 
        ;
        #line 10360 
        ldv_inline_asm();
        #line 10359 
        break;
        #line 10359 
        case (unsigned long)8: 
                               #line 10359 
        ;
        #line 10360 
        ldv_inline_asm();
        #line 10359 
        break;
        #line 10359 
        default: 
                 #line 10359 
        ;
        #line 10359 
        __bad_percpu_size();
      }
      #line 10359 
      pscr_ret__ = pfo_ret___0;
      #line 10359 
      break;
      #line 10359 
      case (unsigned long)4: 
                             #line 10359 
      ;
      #line 10359 
      switch (4UL) {
        #line 10359 
        case (unsigned long)1: 
                               #line 10359 
        ;
        #line 10360 
        ldv_inline_asm();
        #line 10359 
        break;
        #line 10359 
        case (unsigned long)2: 
                               #line 10359 
        ;
        #line 10360 
        ldv_inline_asm();
        #line 10359 
        break;
        #line 10359 
        case (unsigned long)4: 
                               #line 10359 
        ;
        #line 10360 
        ldv_inline_asm();
        #line 10359 
        break;
        #line 10359 
        case (unsigned long)8: 
                               #line 10359 
        ;
        #line 10360 
        ldv_inline_asm();
        #line 10359 
        break;
        #line 10359 
        default: 
                 #line 10359 
        ;
        #line 10359 
        __bad_percpu_size();
      }
      #line 10359 
      pscr_ret__ = pfo_ret___1;
      #line 10359 
      break;
      #line 10359 
      case (unsigned long)8: 
                             #line 10359 
      ;
      #line 10359 
      switch (4UL) {
        #line 10359 
        case (unsigned long)1: 
                               #line 10359 
        ;
        #line 10360 
        ldv_inline_asm();
        #line 10359 
        break;
        #line 10359 
        case (unsigned long)2: 
                               #line 10359 
        ;
        #line 10360 
        ldv_inline_asm();
        #line 10359 
        break;
        #line 10359 
        case (unsigned long)4: 
                               #line 10359 
        ;
        #line 10360 
        ldv_inline_asm();
        #line 10359 
        break;
        #line 10359 
        case (unsigned long)8: 
                               #line 10359 
        ;
        #line 10360 
        ldv_inline_asm();
        #line 10359 
        break;
        #line 10359 
        default: 
                 #line 10359 
        ;
        #line 10359 
        __bad_percpu_size();
      }
      #line 10359 
      pscr_ret__ = pfo_ret___2;
      #line 10359 
      break;
      #line 10359 
      default: 
               #line 10359 
      ;
      #line 10359 
      __bad_size_call_parameter();
      #line 10359 
      break;
    }
    #line 10359 
    ring = adapter->xdp_ring[pscr_ret__];
  }
  else 
       #line 10359 
       ring = (struct ixgbe_ring *)0;
  #line 10360 
  if ((long)(ring == (struct ixgbe_ring *)0) != 0L) 
                                                    #line 10361 
                                                    return -6;
  #line 10363 
  if ((long)((int)test_bit(10L,& ring->state) != 0) != 0L) 
                                                           #line 10364 
                                                           return -6;
  #line 10366 
  i = 0;
  #line 10366 
  while (i < n) {
    {
      #line 10368 
      int err;
      #line 10367 
      struct xdp_frame *xdpf = *(frames + (unsigned long)i);
      #line 10370 
      err = ixgbe_xmit_xdp_ring(adapter,xdpf);
      #line 10371 
      if (err != 2) {
        #line 10372 
        xdp_return_frame_rx_napi(xdpf);
        #line 10373 
        drops ++;
      }
    }
    #line 10366 
    i ++;
  }
  #line 10377 
  if ((long)((flags & 1U) != 0U) != 0L) 
                                        #line 10378 
                                        ixgbe_xdp_ring_update_tail(ring);
  #line 10380 
  return n - drops;
}

#line 10383  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct net_device_ops ixgbe_netdev_ops = {.ndo_open = & ixgbe_open, .ndo_stop = & ixgbe_close, .ndo_start_xmit = & ixgbe_xmit_frame, .ndo_features_check = & ixgbe_features_check, .ndo_select_queue = & ixgbe_select_queue, .ndo_set_rx_mode = & ixgbe_set_rx_mode, .ndo_set_mac_address = & ixgbe_set_mac, .ndo_validate_addr = & eth_validate_addr, .ndo_do_ioctl = & ixgbe_ioctl, .ndo_change_mtu = & ixgbe_change_mtu, .ndo_tx_timeout = & ixgbe_tx_timeout, .ndo_get_stats64 = & ixgbe_get_stats64, .ndo_vlan_rx_add_vid = & ixgbe_vlan_rx_add_vid, .ndo_vlan_rx_kill_vid = & ixgbe_vlan_rx_kill_vid, .ndo_set_vf_mac = & ixgbe_ndo_set_vf_mac, .ndo_set_vf_vlan = & ixgbe_ndo_set_vf_vlan, .ndo_set_vf_rate = & ixgbe_ndo_set_vf_bw, .ndo_set_vf_spoofchk = & ixgbe_ndo_set_vf_spoofchk, .ndo_set_vf_trust = & ixgbe_ndo_set_vf_trust, .ndo_get_vf_config = & ixgbe_ndo_get_vf_config, .ndo_set_vf_rss_query_en = & ixgbe_ndo_set_vf_rss_query_en, .ndo_setup_tc = & __ixgbe_setup_tc, .ndo_fcoe_enable = & ixgbe_fcoe_enable, .ndo_fcoe_disable = & ixgbe_fcoe_disable, .ndo_fcoe_ddp_setup = & ixgbe_fcoe_ddp_get, .ndo_fcoe_ddp_done = & ixgbe_fcoe_ddp_put, .ndo_fcoe_ddp_target = & ixgbe_fcoe_ddp_target, .ndo_fcoe_get_hbainfo = & ixgbe_fcoe_get_hbainfo, .ndo_fcoe_get_wwn = & ixgbe_fcoe_get_wwn, .ndo_fix_features = & ixgbe_fix_features, .ndo_set_features = & ixgbe_set_features, .ndo_fdb_add = & ixgbe_ndo_fdb_add, .ndo_bridge_setlink = & ixgbe_ndo_bridge_setlink, .ndo_bridge_getlink = & ixgbe_ndo_bridge_getlink, .ndo_udp_tunnel_add = & ixgbe_add_udp_tunnel_port, .ndo_udp_tunnel_del = & ixgbe_del_udp_tunnel_port, .ndo_dfwd_add_station = & ixgbe_fwd_add, .ndo_dfwd_del_station = & ixgbe_fwd_del, .ndo_set_tx_maxrate = & ixgbe_tx_maxrate, .ndo_bpf = & ixgbe_xdp, .ndo_xdp_xmit = & ixgbe_xdp_xmit, .ndo_xsk_wakeup = & ixgbe_xsk_wakeup};
#line 10430  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_disable_txr_hw(struct ixgbe_adapter *adapter, struct ixgbe_ring *tx_ring)
{
  #line 10433 
  unsigned long wait_delay;
  #line 10433 
  unsigned long delay_interval;
  #line 10436 
  int wait_loop;
  #line 10437 
  u32 txdctl;
  #line 10434 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 10435 
  u8 reg_idx = tx_ring->reg_idx;
  #line 10439 
  ixgbe_write_reg_1(hw,(unsigned int)((int)reg_idx * 64 + 24616),67108864U);
  #line 10442 
  delay_interval = ixgbe_get_completion_timeout(adapter) / 100UL;
  #line 10444 
  wait_loop = 10;
  #line 10445 
  wait_delay = delay_interval;
  #line 10447 
  while (1) {
    #line 10447 
    int tmp_0;
    #line 10447 
    tmp_0 = wait_loop;
    #line 10447 
    wait_loop --;
    #line 10447 
    ;
    #line 10447 
    if (! (tmp_0 != 0)) 
                        #line 10447 
                        break;
    #line 10448 
    usleep_range(wait_delay,wait_delay + 10UL);
    #line 10449 
    wait_delay = delay_interval * 2UL + wait_delay;
    #line 10450 
    txdctl = ixgbe_read_reg(hw,(unsigned int)((int)reg_idx * 64 + 24616));
    #line 10452 
    if ((txdctl & 33554432U) == 0U) 
                                    #line 10453 
                                    return;
  }
  #line 10456 
  if (((int)adapter->msg_enable & 1) != 0) 
                                           #line 10456 
                                           netdev_err(adapter->netdev,(char *)"TXDCTL.ENABLE not cleared within the polling period\n");
  #line 10457 
  return;
}

#line 10459  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_disable_txr(struct ixgbe_adapter *adapter, struct ixgbe_ring *tx_ring)
{
  #line 10462 
  cif_set_bit(10L,& tx_ring->state);
  #line 10463 
  ixgbe_disable_txr_hw(adapter,tx_ring);
  #line 10464 
  return;
}

#line 10466  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_disable_rxr_hw(struct ixgbe_adapter *adapter, struct ixgbe_ring *rx_ring)
{
  #line 10469 
  unsigned long wait_delay;
  #line 10469 
  unsigned long delay_interval;
  #line 10472 
  int wait_loop;
  #line 10473 
  u32 rxdctl;
  #line 10475 
  int tmp;
  #line 10480 
  int tmp_0;
  #line 10470 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 10471 
  u8 reg_idx = rx_ring->reg_idx;
  #line 10475 
  if ((unsigned int)reg_idx <= 63U) 
                                    #line 10475 
                                    tmp = (int)reg_idx * 64 + 4136; else 
                                                                    #line 10475 
                                                                    tmp = ((int)reg_idx + -64) * 64 + 53288;
  #line 10475 
  ;
  #line 10475 
  rxdctl = ixgbe_read_reg(hw,(unsigned int)tmp);
  #line 10476 
  rxdctl &= 4261412863U;
  #line 10477 
  rxdctl |= 67108864U;
  #line 10480 
  ;
  #line 10480 
  if ((unsigned int)reg_idx <= 63U) 
                                    #line 10480 
                                    tmp_0 = (int)reg_idx * 64 + 4136; else 
                                                                    #line 10480 
                                                                    tmp_0 = ((int)reg_idx + -64) * 64 + 53288;
  #line 10480 
  ;
  #line 10480 
  ixgbe_write_reg_1(hw,(unsigned int)tmp_0,rxdctl);
  #line 10483 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) {
    #line 10483 
    if ((ixgbe_read_reg(hw,17060U) & 1073741824U) == 0U) 
                                                         #line 10485 
                                                         return;
  }
  #line 10488 
  delay_interval = ixgbe_get_completion_timeout(adapter) / 100UL;
  #line 10490 
  wait_loop = 10;
  #line 10491 
  wait_delay = delay_interval;
  #line 10493 
  while (1) {
    #line 10493 
    int tmp_4;
    #line 10493 
    tmp_4 = wait_loop;
    #line 10493 
    wait_loop --;
    #line 10493 
    ;
    #line 10493 
    if (! (tmp_4 != 0)) 
                        #line 10493 
                        break;
    {
      #line 10496 
      int tmp_3;
      #line 10494 
      usleep_range(wait_delay,wait_delay + 10UL);
      #line 10495 
      wait_delay = delay_interval * 2UL + wait_delay;
      #line 10496 
      if ((unsigned int)reg_idx <= 63U) 
                                        #line 10496 
                                        tmp_3 = (int)reg_idx * 64 + 4136; else 
                                                                    #line 10496 
                                                                    tmp_3 = ((int)reg_idx + -64) * 64 + 53288;
      #line 10496 
      ;
      #line 10496 
      rxdctl = ixgbe_read_reg(hw,(unsigned int)tmp_3);
      #line 10498 
      if ((rxdctl & 33554432U) == 0U) 
                                      #line 10499 
                                      return;
    }
  }
  #line 10502 
  if (((int)adapter->msg_enable & 1) != 0) 
                                           #line 10502 
                                           netdev_err(adapter->netdev,(char *)"RXDCTL.ENABLE not cleared within the polling period\n");
  #line 10503 
  return;
}

#line 10505  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_reset_txr_stats(struct ixgbe_ring *tx_ring)
{
  #line 10507 
  memset((void *)(& tx_ring->stats),0,16UL);
  #line 10508 
  memset((void *)(& tx_ring->__anonCompField_ixgbe_ring_224.tx_stats),0,24UL);
  #line 10509 
  return;
}

#line 10511  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_reset_rxr_stats(struct ixgbe_ring *rx_ring)
{
  #line 10513 
  memset((void *)(& rx_ring->stats),0,16UL);
  #line 10514 
  memset((void *)(& rx_ring->__anonCompField_ixgbe_ring_224.rx_stats),0,56UL);
  #line 10515 
  return;
}

#line 10525  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_txrx_ring_disable(struct ixgbe_adapter *adapter, int ring)
{
  #line 10527 
  struct ixgbe_ring *rx_ring;
  #line 10527 
  struct ixgbe_ring *tx_ring;
  #line 10527 
  struct ixgbe_ring *xdp_ring;
  #line 10529 
  rx_ring = adapter->rx_ring[ring];
  #line 10530 
  tx_ring = adapter->tx_ring[ring];
  #line 10531 
  xdp_ring = adapter->xdp_ring[ring];
  #line 10533 
  ixgbe_disable_txr(adapter,tx_ring);
  #line 10534 
  if (xdp_ring != (struct ixgbe_ring *)0) 
                                          #line 10535 
                                          ixgbe_disable_txr(adapter,xdp_ring);
  #line 10536 
  ixgbe_disable_rxr_hw(adapter,rx_ring);
  #line 10538 
  if (xdp_ring != (struct ixgbe_ring *)0) 
                                          #line 10539 
                                          synchronize_rcu();
  #line 10542 
  napi_disable(& (rx_ring->q_vector)->napi);
  #line 10544 
  ixgbe_clean_tx_ring(tx_ring);
  #line 10545 
  if (xdp_ring != (struct ixgbe_ring *)0) 
                                          #line 10546 
                                          ixgbe_clean_tx_ring(xdp_ring);
  #line 10547 
  ixgbe_clean_rx_ring(rx_ring);
  #line 10549 
  ixgbe_reset_txr_stats(tx_ring);
  #line 10550 
  if (xdp_ring != (struct ixgbe_ring *)0) 
                                          #line 10551 
                                          ixgbe_reset_txr_stats(xdp_ring);
  #line 10552 
  ixgbe_reset_rxr_stats(rx_ring);
  #line 10553 
  return;
}

#line 10563  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_txrx_ring_enable(struct ixgbe_adapter *adapter, int ring)
{
  #line 10565 
  struct ixgbe_ring *rx_ring;
  #line 10565 
  struct ixgbe_ring *tx_ring;
  #line 10565 
  struct ixgbe_ring *xdp_ring;
  #line 10567 
  rx_ring = adapter->rx_ring[ring];
  #line 10568 
  tx_ring = adapter->tx_ring[ring];
  #line 10569 
  xdp_ring = adapter->xdp_ring[ring];
  #line 10572 
  napi_enable(& (rx_ring->q_vector)->napi);
  #line 10574 
  ixgbe_configure_tx_ring(adapter,tx_ring);
  #line 10575 
  if (xdp_ring != (struct ixgbe_ring *)0) 
                                          #line 10576 
                                          ixgbe_configure_tx_ring(adapter,xdp_ring);
  #line 10577 
  ixgbe_configure_rx_ring(adapter,rx_ring);
  #line 10579 
  cif_clear_bit(10L,& tx_ring->state);
  #line 10580 
  if (xdp_ring != (struct ixgbe_ring *)0) 
                                          #line 10581 
                                          cif_clear_bit(10L,& xdp_ring->state);
  #line 10582 
  return;
}

#line 10593  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static int ixgbe_enumerate_functions(struct ixgbe_adapter *adapter)
{
  #line 10605 
  void *__mptr;
  #line 10595 
  struct pci_dev *entry;
  #line 10595 
  struct pci_dev *pdev = adapter->pdev;
  #line 10596 
  int physfns = 0;
  #line 10602 
  if ((int)ixgbe_pcie_from_parent(& adapter->hw) != 0) 
                                                       #line 10603 
                                                       physfns = 4;
  #line 10605 
  __mptr = (void *)((adapter->pdev)->bus)->devices.next;
  #line 10605 
  entry = ((struct pci_dev *)__mptr);
  #line 10605 
  while (& entry->bus_list != & ((adapter->pdev)->bus)->devices) {
    #line 10605 
    void *__mptr_0;
    #line 10607 
    if ((unsigned int)entry->is_virtfn != 0U) 
                                              #line 10608 
                                              goto __Cont;
    #line 10616 
    if ((int)entry->vendor != (int)pdev->vendor || (int)entry->device != (int)pdev->device) 
      #line 10618 
      return -1;
    #line 10620 
    physfns ++;
    #line 10605 
    __Cont: { /* sequence */
              #line 10605 
              __mptr_0 = (void *)entry->bus_list.next;
              #line 10605 
              entry = ((struct pci_dev *)__mptr_0);
            }
  }
  #line 10623 
  return physfns;
}

#line 10636  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
bool ixgbe_wol_supported(struct ixgbe_adapter *adapter, u16 device_id, u16 subdevice_id)
{
  #line 10639 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 10640 
  u16 wol_cap = (unsigned short)((unsigned int)adapter->eeprom_cap & 12U);
  #line 10643 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) 
                                                       #line 10644 
                                                       return (_Bool)0;
  #line 10647 
  if (hw->mac.type > (unsigned int)ixgbe_mac_82599EB) 
    #line 10648 
    if ((unsigned int)wol_cap == 4U || (unsigned int)wol_cap == 8U && (unsigned int)hw->bus.func == 0U) 
      #line 10651 
      return (_Bool)1;
  #line 10655 
  switch ((int)device_id) {
    #line 10656 
    case 4347: 
               #line 10656 
    ;
    #line 10658 
    switch ((int)subdevice_id) {
      #line 10659 
      case 6096: 
                 #line 10659 
      ;
      #line 10660 
      case 8537: 
                 #line 10660 
      ;
      #line 10661 
      case 4209: 
                 #line 10661 
      ;
      #line 10662 
      case 8: 
              #line 10662 
      ;
      #line 10664 
      if ((unsigned int)hw->bus.func != 0U) 
                                            #line 10665 
                                            break;
      #line 10667 
      case 8475: 
                 #line 10667 
      ;
      #line 10668 
      case 4521: 
                 #line 10668 
      ;
      #line 10669 
      case 8050: 
                 #line 10669 
      ;
      #line 10670 
      case 1136: 
                 #line 10670 
      ;
      #line 10671 
      case 13: 
               #line 10671 
      ;
      #line 10672 
      case 35190: 
                  #line 10672 
      ;
      #line 10673 
      case 1774: 
                 #line 10673 
      ;
      #line 10674 
      return (_Bool)1;
    }
    #line 10676 
    break;
    #line 10677 
    case 5463: 
               #line 10677 
    ;
    #line 10679 
    switch ((int)subdevice_id) {
      #line 10680 
      case 1: 
              #line 10680 
      ;
      #line 10681 
      return (_Bool)1;
    }
    #line 10683 
    break;
    #line 10684 
    case 4344: 
               #line 10684 
    ;
    #line 10686 
    if ((unsigned int)subdevice_id != 12U) 
                                           #line 10687 
                                           return (_Bool)1;
    #line 10688 
    break;
    #line 10689 
    case 4343: 
               #line 10689 
    ;
    #line 10690 
    return (_Bool)1;
    #line 10691 
    default: 
             #line 10691 
    ;
    #line 10692 
    break;
  }
  #line 10695 
  return (_Bool)0;
}

#line 10705  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_set_fw_version(struct ixgbe_adapter *adapter)
{
  #line 10708 
  struct ixgbe_nvm_version nvm_ver;
  #line 10707 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 10710 
  ixgbe_get_oem_prod_version(hw,& nvm_ver);
  #line 10711 
  if ((int)nvm_ver.oem_valid != 0) {
    #line 10712 
    snprintf((char *)(& adapter->eeprom_id),32UL,(char *)"%x.%x.%x",(int)nvm_ver.oem_major,(int)nvm_ver.oem_minor,(int)nvm_ver.oem_release);
    #line 10715 
    return;
  }
  #line 10718 
  ixgbe_get_etk_id(hw,& nvm_ver);
  #line 10719 
  ixgbe_get_orom_version(hw,& nvm_ver);
  #line 10721 
  if ((int)nvm_ver.or_valid != 0) {
    #line 10722 
    snprintf((char *)(& adapter->eeprom_id),32UL,(char *)"0x%08x, %d.%d.%d",nvm_ver.etk_id,(int)nvm_ver.or_major,(int)nvm_ver.or_build,(int)nvm_ver.or_patch);
    #line 10725 
    return;
  }
  #line 10729 
  snprintf((char *)(& adapter->eeprom_id),32UL,(char *)"0x%08x",nvm_ver.etk_id);
  #line 10731 
  return;
}

#line 10744  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_probe(struct pci_dev *pdev, struct pci_device_id *ent)
{
  #line 10746 
  struct net_device *netdev;
  #line 10748 
  struct ixgbe_hw *hw;
  #line 10750 
  int i;
  #line 10750 
  int err;
  #line 10750 
  int pci_using_dac;
  #line 10750 
  int expected_gts;
  #line 10752 
  u8 part_str[11U];
  #line 10755 
  u16 device_caps;
  #line 10757 
  u32 eec;
  #line 10821 
  unsigned long tmp_3;
  #line 11199 
  int tmp_26;
  #line 10747 
  struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)0;
  #line 10749 
  struct ixgbe_info *ii = ixgbe_info_tbl[ent->driver_data];
  #line 10751 
  unsigned int indices = 64U;
  #line 10753 
  bool disable_dev = (_Bool)0;
  #line 10762 
  if ((unsigned int)pdev->is_virtfn != 0U) {
    {
      #line 10763 
      int __ret_warn_on = 1;
      #line 10763 
      if ((long)(__ret_warn_on != 0) != 0L) {
        #line 10763 
        ;
        #line 10763 
        ;
        #line 10763 
        __warn_printk((char *)"\001",pci_name(pdev),(int)pdev->vendor,(int)pdev->device);
        #line 10764 
        ldv_inline_asm();
        #line 10765 
        ldv_inline_asm();
      }
      #line 10763 
      long tmp_2 = (long)(__ret_warn_on != 0);
    }
    #line 10765 
    return -22;
  }
  #line 10768 
  err = pci_enable_device_mem(pdev);
  #line 10769 
  if (err != 0) 
                #line 10770 
                return err;
  #line 10772 
  if (dma_set_mask_and_coherent(& pdev->dev,18446744073709551615ULL) == 0) 
    #line 10773 
    pci_using_dac = 1;
  else {
    #line 10775 
    err = dma_set_mask_and_coherent(& pdev->dev,4294967295ULL);
    #line 10776 
    if (err != 0) {
      #line 10777 
      _dev_err(& pdev->dev,(char *)"No usable DMA configuration, aborting\n");
      #line 10779 
      goto err_dma;
    }
    #line 10781 
    pci_using_dac = 0;
  }
  #line 10784 
  err = pci_request_mem_regions(pdev,(char *)(& ixgbe_driver_name));
  #line 10785 
  if (err != 0) {
    #line 10786 
    _dev_err(& pdev->dev,(char *)"pci_request_selected_regions failed 0x%x\n",err);
    #line 10788 
    goto err_pci_reg;
  }
  #line 10791 
  pci_enable_pcie_error_reporting(pdev);
  #line 10793 
  pci_set_master(pdev);
  #line 10794 
  pci_save_state(pdev);
  #line 10796 
  if (ii->mac == (unsigned int)ixgbe_mac_82598EB) 
                                                  #line 10799 
                                                  indices = 32U;
  #line 10805 
  netdev = cif_alloc_etherdev_mqs(143360,indices,indices);
  #line 10806 
  if (netdev == (struct net_device *)0) {
    #line 10807 
    err = -12;
    #line 10808 
    goto err_alloc_etherdev;
  }
  #line 10811 
  netdev->dev.parent = & pdev->dev;
  #line 10813 
  adapter = (struct ixgbe_adapter *)netdev_priv(netdev);
  #line 10815 
  adapter->netdev = netdev;
  #line 10816 
  adapter->pdev = pdev;
  #line 10817 
  hw = & adapter->hw;
  #line 10818 
  hw->back = (void *)adapter;
  #line 10819 
  adapter->msg_enable = (unsigned short)netif_msg_init(debug,7);
  #line 10821 
  if (pdev->resource[0].start != 0ULL || pdev->resource[0].end != pdev->resource[0].start) 
    #line 10821 
    tmp_3 = (unsigned long)((pdev->resource[0].end - pdev->resource[0].start) + 1ULL); else 
                                                                    #line 10821 
                                                                    tmp_3 = 0UL;
  #line 10821 
  ;
  #line 10821 
  hw->hw_addr = (u8 *)ioremap(pdev->resource[0].start,tmp_3);
  #line 10823 
  adapter->io_addr = hw->hw_addr;
  #line 10824 
  if (hw->hw_addr == (u8 *)0U) {
    #line 10825 
    err = -5;
    #line 10826 
    goto err_ioremap;
  }
  #line 10829 
  netdev->netdev_ops = & ixgbe_netdev_ops;
  #line 10830 
  ixgbe_set_ethtool_ops(netdev);
  #line 10831 
  netdev->watchdog_timeo = 1250;
  #line 10832 
  ;
  #line 10832 
  strlcpy((char *)(& netdev->name),pci_name(pdev),16UL);
  #line 10835 
  hw->mac.ops = *(ii->mac_ops);
  #line 10836 
  hw->mac.type = ii->mac;
  #line 10837 
  hw->mvals = ii->mvals;
  #line 10838 
  if (ii->link_ops != (struct ixgbe_link_operations *)0) 
                                                         #line 10839 
                                                         hw->link.ops = *(ii->link_ops);
  #line 10842 
  hw->eeprom.ops = *(ii->eeprom_ops);
  #line 10843 
  eec = ixgbe_read_reg(hw,*(hw->mvals));
  #line 10844 
  if ((int)ixgbe_removed((void *)hw->hw_addr) != 0) {
    #line 10845 
    err = -5;
    #line 10846 
    goto err_ioremap;
  }
  #line 10849 
  if (((unsigned long)eec & 256UL) == 0UL) 
                                           #line 10850 
                                           hw->eeprom.ops.read = & ixgbe_read_eeprom_bit_bang_generic;
  #line 10853 
  hw->phy.ops = *(ii->phy_ops);
  #line 10854 
  hw->phy.sfp_type = ixgbe_sfp_type_unknown;
  #line 10856 
  hw->phy.mdio.prtad = -1;
  #line 10857 
  hw->phy.mdio.mmds = 0U;
  #line 10858 
  hw->phy.mdio.mode_support = 6U;
  #line 10859 
  hw->phy.mdio.dev = netdev;
  #line 10860 
  hw->phy.mdio.mdio_read = & ixgbe_mdio_read;
  #line 10861 
  hw->phy.mdio.mdio_write = & ixgbe_mdio_write;
  #line 10864 
  err = ixgbe_sw_init(adapter,ii);
  #line 10865 
  if (err != 0) 
                #line 10866 
                goto err_sw_init;
  #line 10869 
  if (hw->mac.ops.init_swfw_sync != (void (*)(struct ixgbe_hw *))0) 
                                                                    #line 10870 
                                                                    (*(hw->mac.ops.init_swfw_sync))(hw);
  #line 10873 
  switch ((unsigned int)adapter->hw.mac.type) {
    #line 10874 
    case (unsigned int)2: 
                          #line 10874 
    ;
    #line 10875 
    case (unsigned int)3: 
                          #line 10875 
    ;
    #line 10876 
    case (unsigned int)4: 
                          #line 10876 
    ;
    #line 10877 
    case (unsigned int)5: 
                          #line 10877 
    ;
    #line 10878 
    case (unsigned int)6: 
                          #line 10878 
    ;
    #line 10879 
    ixgbe_write_reg_1(& adapter->hw,22544U,4294967295U);
    #line 10880 
    break;
    #line 10881 
    default: 
             #line 10881 
    ;
    #line 10882 
    break;
  }
  #line 10889 
  if (((unsigned long)adapter->flags & 32768UL) != 0UL) {
    #line 10890 
    u32 esdp = ixgbe_read_reg(hw,32U);
    #line 10891 
    if ((esdp & 2U) != 0U) 
      #line 10892 
      if (((int)adapter->msg_enable & 2) != 0) 
                                               #line 10892 
                                               netdev_crit(adapter->netdev,(char *)"Fan has stopped, replace the adapter\n");
  }
  #line 10895 
  if (allow_unsupported_sfp != 0U) 
                                   #line 10896 
                                   hw->allow_unsupported_sfp = (_Bool)(allow_unsupported_sfp != 0U);
  #line 10899 
  hw->phy.reset_if_overtemp = (_Bool)1;
  #line 10900 
  err = (*(hw->mac.ops.reset_hw))(hw);
  #line 10901 
  hw->phy.reset_if_overtemp = (_Bool)0;
  #line 10902 
  ixgbe_set_eee_capable(adapter);
  #line 10903 
  if (err == -20) 
                  #line 10904 
                  err = 0;
  else 
    #line 10905 
    if (err == -19) {
      #line 10906 
      _dev_err(& (adapter->pdev)->dev,(char *)"failed to load because an unsupported SFP+ or QSFP module type was detected.\n");
      #line 10907 
      _dev_err(& (adapter->pdev)->dev,(char *)"Reload the driver after installing a supported module.\n");
      #line 10908 
      goto err_sw_init;
    }
    else 
      #line 10909 
      if (err != 0) {
        #line 10910 
        _dev_err(& (adapter->pdev)->dev,(char *)"HW Init failed: %d\n",err);
        #line 10911 
        goto err_sw_init;
      }
  #line 10916 
  if (adapter->hw.mac.type == (unsigned int)ixgbe_mac_82598EB) 
                                                               #line 10917 
                                                               goto skip_sriov;
  #line 10919 
  ixgbe_init_mbx_params_pf(hw);
  #line 10920 
  hw->mbx.ops = ii->mbx_ops;
  #line 10921 
  pci_sriov_set_totalvfs(pdev,(unsigned short)63);
  #line 10922 
  ixgbe_enable_sriov(adapter,max_vfs);
  #line 10923 
  skip_sriov: 
              #line 10923 
  ;
  #line 10926 
  netdev->features = 824634834953ULL;
  #line 10940 
  netdev->gso_partial_features = 264241152ULL;
  #line 10941 
  netdev->features |= 532676608ULL;
  #line 10944 
  if (hw->mac.type > (unsigned int)ixgbe_mac_82598EB) 
                                                      #line 10945 
                                                      netdev->features |= 42949672960ULL;
  #line 10952 
  if (adapter->ipsec != (struct ixgbe_ipsec *)0) 
                                                 #line 10953 
                                                 netdev->features |= 1688852007747584ULL;
  #line 10956 
  netdev->hw_features = (netdev->hw_features | netdev->features) | 149533581378432ULL;
  #line 10963 
  if (hw->mac.type > (unsigned int)ixgbe_mac_82598EB) 
                                                      #line 10964 
                                                      netdev->hw_features |= 281612415664128ULL;
  #line 10967 
  if (pci_using_dac != 0) 
                          #line 10968 
                          netdev->features |= 32ULL;
  #line 10970 
  netdev->vlan_features = (netdev->vlan_features | netdev->features) | 524288ULL;
  #line 10971 
  netdev->hw_enc_features |= netdev->vlan_features;
  #line 10972 
  netdev->mpls_features |= 1114121ULL;
  #line 10976 
  netdev->mpls_features |= 264241152ULL;
  #line 10979 
  netdev->features |= 896ULL;
  #line 10983 
  netdev->priv_flags |= 4096U;
  #line 10984 
  netdev->priv_flags |= 16384U;
  #line 10987 
  netdev->min_mtu = 68U;
  #line 10988 
  netdev->max_mtu = 9710U;
  #line 10991 
  if (((unsigned long)adapter->flags & 134217728UL) != 0UL) 
                                                            #line 10992 
                                                            netdev->dcbnl_ops = & ixgbe_dcbnl_ops;
  #line 10996 
  if (((unsigned long)adapter->flags & 1048576UL) != 0UL) {
    #line 11006 
    int tmp_9;
    #line 11006 
    int __UNIQUE_ID___x603;
    #line 10997 
    unsigned int fcoe_l;
    #line 10999 
    if (hw->mac.ops.get_device_caps != (s32 (*)(struct ixgbe_hw *, u16 *))0) {
      #line 11000 
      (*(hw->mac.ops.get_device_caps))(hw,& device_caps);
      #line 11001 
      if (((int)device_caps & 2) != 0) 
                                       #line 11002 
                                       adapter->flags &= 4293918719U;
    }
    {
      #line 11006 
      __UNIQUE_ID___x603 = 8;
      #line 11006 
      int __UNIQUE_ID___y604 = (int)num_online_cpus();
      #line 11006 
      if (__UNIQUE_ID___x603 < __UNIQUE_ID___y604) 
                                                   #line 11006 
                                                   tmp_9 = __UNIQUE_ID___x603; else 
                                                                    #line 11006 
                                                                    tmp_9 = __UNIQUE_ID___y604;
      }
    #line 11006 
    fcoe_l = (unsigned int)tmp_9;
    #line 11007 
    adapter->ring_feature[4].limit = (unsigned short)fcoe_l;
    #line 11009 
    netdev->features |= 17181966336ULL;
    #line 11012 
    netdev->vlan_features |= 85901443072ULL;
  }
  #line 11017 
  if (((unsigned long)adapter->flags2 & 1UL) != 0UL) 
                                                     #line 11018 
                                                     netdev->hw_features |= 32768ULL;
  #line 11019 
  if (((unsigned long)adapter->flags2 & 2UL) != 0UL) 
                                                     #line 11020 
                                                     netdev->features |= 32768ULL;
  #line 11022 
  if ((int)ixgbe_check_fw_error(adapter) != 0) {
    #line 11023 
    err = -5;
    #line 11024 
    goto err_sw_init;
  }
  #line 11028 
  if ((*(hw->eeprom.ops.validate_checksum))(hw,(u16 *)0U) < 0) {
    #line 11029 
    _dev_err(& (adapter->pdev)->dev,(char *)"The EEPROM Checksum Is Not Valid\n");
    #line 11030 
    err = -5;
    #line 11031 
    goto err_sw_init;
  }
  #line 11034 
  eth_platform_get_mac_address(& (adapter->pdev)->dev,(u8 *)(& adapter->hw.mac.perm_addr));
  #line 11037 
  memcpy((void *)netdev->dev_addr,(void *)(& hw->mac.perm_addr),(unsigned long)netdev->addr_len);
  #line 11039 
  if (! is_valid_ether_addr(netdev->dev_addr)) {
    #line 11040 
    _dev_err(& (adapter->pdev)->dev,(char *)"invalid MAC address\n");
    #line 11041 
    err = -5;
    #line 11042 
    goto err_sw_init;
  }
  #line 11046 
  ether_addr_copy((u8 *)(& hw->mac.addr),(u8 *)(& hw->mac.perm_addr));
  #line 11047 
  ixgbe_mac_set_default_filter(adapter);
  {
    #line 11049 
    struct lock_class_key __key;
    #line 11049 
    init_timer_key(& adapter->service_timer,& ixgbe_service_timer,0U,(char *)"(&adapter->service_timer)",& __key);
  }
  #line 11051 
  if ((int)ixgbe_removed((void *)hw->hw_addr) != 0) {
    #line 11052 
    err = -5;
    #line 11053 
    goto err_sw_init;
  }
  {
    #line 11055 
    struct lock_class_key __key_0;
    #line 11055 
    __init_work(& adapter->service_task,0);
    #line 11055 
    atomic_long_t __constr_expr_45 = {.counter = 137438953408LL};
    #line 11055 
    adapter->service_task.data = __constr_expr_45;
    #line 11055 
    lockdep_init_map(& adapter->service_task.lockdep_map,(char *)"(work_completion)",& __key_0,0);
    #line 11055 
    INIT_LIST_HEAD(& adapter->service_task.entry);
    #line 11055 
    adapter->service_task.func = & ixgbe_service_task;
  }
  #line 11056 
  cif_set_bit(6L,& adapter->state);
  #line 11057 
  cif_clear_bit(5L,& adapter->state);
  #line 11059 
  err = ixgbe_init_interrupt_scheme(adapter);
  #line 11060 
  if (err != 0) 
                #line 11061 
                goto err_sw_init;
  #line 11063 
  i = 0;
  #line 11063 
  while (adapter->num_rx_queues > i) {
    #line 11064 
    u64_stats_init(& (adapter->rx_ring[i])->syncp);
    #line 11063 
    i ++;
  }
  #line 11065 
  i = 0;
  #line 11065 
  while (adapter->num_tx_queues > i) {
    #line 11066 
    u64_stats_init(& (adapter->tx_ring[i])->syncp);
    #line 11065 
    i ++;
  }
  #line 11067 
  i = 0;
  #line 11067 
  while (adapter->num_xdp_queues > i) {
    #line 11068 
    u64_stats_init(& (adapter->xdp_ring[i])->syncp);
    #line 11067 
    i ++;
  }
  #line 11071 
  adapter->wol = 0U;
  #line 11072 
  (*(hw->eeprom.ops.read))(hw,(unsigned short)44,& adapter->eeprom_cap);
  #line 11073 
  hw->wol_enabled = ixgbe_wol_supported(adapter,(unsigned short)((int)pdev->device),(unsigned short)((int)pdev->subsystem_device));
  #line 11075 
  if ((int)hw->wol_enabled != 0) 
                                 #line 11076 
                                 adapter->wol = 2U;
  #line 11078 
  device_set_wakeup_enable(& (adapter->pdev)->dev,(_Bool)(adapter->wol != 0U));
  #line 11081 
  ixgbe_set_fw_version(adapter);
  #line 11084 
  if ((int)ixgbe_pcie_from_parent(hw) != 0) 
                                            #line 11085 
                                            ixgbe_get_parent_bus_info(adapter); else 
                                                                    #line 11087 
                                                                    (*(hw->mac.ops.get_bus_info))(hw);
  #line 11094 
  switch ((unsigned int)hw->mac.type) {
    #line 11096 
    int tmp_17;
    #line 11096 
    int __UNIQUE_ID___x605;
    #line 11095 
    case (unsigned int)1: 
                          #line 11095 
    ;
    {
      #line 11096 
      __UNIQUE_ID___x605 = ixgbe_enumerate_functions(adapter) * 10;
      #line 11096 
      int __UNIQUE_ID___y606 = 16;
      #line 11096 
      if (__UNIQUE_ID___x605 < __UNIQUE_ID___y606) 
                                                   #line 11096 
                                                   tmp_17 = __UNIQUE_ID___x605; else 
                                                                    #line 11096 
                                                                    tmp_17 = __UNIQUE_ID___y606;
      }
    #line 11096 
    expected_gts = tmp_17;
    #line 11097 
    break;
    #line 11098 
    default: 
             #line 11098 
    ;
    #line 11099 
    expected_gts = ixgbe_enumerate_functions(adapter) * 10;
    #line 11100 
    break;
  }
  #line 11104 
  if (expected_gts > 0) 
                        #line 11105 
                        ixgbe_check_minimum_link(adapter,expected_gts);
  #line 11107 
  err = ixgbe_read_pba_string_generic(hw,(u8 *)(& part_str),11U);
  #line 11108 
  if (err != 0) 
                #line 11109 
                strlcpy((char *)(& part_str),(char *)"Unknown",11UL);
  #line 11110 
  if ((int)ixgbe_is_sfp(hw) != 0) 
    #line 11110 
    if (hw->phy.sfp_type != (unsigned int)ixgbe_sfp_type_not_present) 
      #line 11111 
      _dev_info(& (adapter->pdev)->dev,(char *)"MAC: %d, PHY: %d, SFP+: %d, PBA No: %s\n",(unsigned int)hw->mac.type,(unsigned int)hw->phy.type,(unsigned int)hw->phy.sfp_type,(u8 *)(& part_str)); else 
                                                                    #line 11115 
                                                                    _dev_info(& (adapter->pdev)->dev,(char *)"MAC: %d, PHY: %d, PBA No: %s\n",(unsigned int)hw->mac.type,(unsigned int)hw->phy.type,(u8 *)(& part_str));
  else 
       #line 11115 
       _dev_info(& (adapter->pdev)->dev,(char *)"MAC: %d, PHY: %d, PBA No: %s\n",(unsigned int)hw->mac.type,(unsigned int)hw->phy.type,(u8 *)(& part_str));
  #line 11118 
  _dev_info(& (adapter->pdev)->dev,(char *)"%pM\n",netdev->dev_addr);
  #line 11121 
  err = (*(hw->mac.ops.start_hw))(hw);
  #line 11122 
  if (err == -24) 
                  #line 11124 
                  _dev_warn(& (adapter->pdev)->dev,(char *)"This device is a pre-production adapter/LOM. ");
  #line 11131 
  strcpy((char *)(& netdev->name),(char *)"eth%d");
  #line 11132 
  pci_set_drvdata(pdev,(void *)adapter);
  #line 11133 
  err = cif_register_netdev(netdev);
  #line 11134 
  if (err != 0) 
                #line 11135 
                goto err_register;
  #line 11139 
  if (hw->mac.ops.disable_tx_laser != (void (*)(struct ixgbe_hw *))0) 
    #line 11140 
    (*(hw->mac.ops.disable_tx_laser))(hw);
  #line 11143 
  netif_carrier_off(netdev);
  #line 11146 
  if (dca_add_requester(& pdev->dev) == 0) {
    #line 11147 
    adapter->flags |= 256U;
    #line 11148 
    ixgbe_setup_dca(adapter);
  }
  #line 11151 
  if (((unsigned long)adapter->flags & 8388608UL) != 0UL) {
    #line 11152 
    if (((int)adapter->msg_enable & 2) != 0) 
                                             #line 11152 
                                             netdev_info(adapter->netdev,(char *)"IOV is enabled with %d VFs\n",adapter->num_vfs);
    #line 11153 
    i = 0;
    #line 11153 
    while (adapter->num_vfs > (unsigned int)i) {
      #line 11154 
      ixgbe_vf_configuration(pdev,(unsigned int)(i | 268435456));
      #line 11153 
      i ++;
    }
  }
  #line 11160 
  if (hw->mac.ops.set_fw_drv_ver != (s32 (*)(struct ixgbe_hw *, u8 , u8 , u8 , u8 , u16 , char *))0) 
    #line 11161 
    (*(hw->mac.ops.set_fw_drv_ver))(hw,(unsigned char)255,(unsigned char)255,(unsigned char)255,(unsigned char)255,(unsigned short)7,(char *)(& ixgbe_driver_version));
  #line 11166 
  ixgbe_add_sanmac_netdev(netdev);
  #line 11168 
  _dev_info(& (adapter->pdev)->dev,(char *)"%s\n",(char *)(& ixgbe_default_device_descr));
  #line 11171 
  if (ixgbe_sysfs_init(adapter) != 0) 
    #line 11172 
    if (((int)adapter->msg_enable & 2) != 0) 
                                             #line 11172 
                                             netdev_err(adapter->netdev,(char *)"failed to allocate sysfs resources\n");
  #line 11175 
  ixgbe_dbg_adapter_init(adapter);
  #line 11178 
  if ((int)ixgbe_mng_enabled(hw) != 0) {
    #line 11178 
    if ((int)ixgbe_is_sfp(hw) != 0) 
      #line 11178 
      if (hw->mac.ops.setup_link != (s32 (*)(struct ixgbe_hw *, ixgbe_link_speed , bool ))0) 
        #line 11179 
        (*(hw->mac.ops.setup_link))(hw,160U,(_Bool)1);
  }
  #line 11183 
  ixgbe_mii_bus_init(hw);
  #line 11185 
  return 0;
  #line 11187 
  err_register: 
                #line 11187 
  ;
  #line 11188 
  ixgbe_release_hw_control(adapter);
  #line 11189 
  ixgbe_clear_interrupt_scheme(adapter);
  #line 11190 
  err_sw_init: 
               #line 11190 
  ;
  #line 11191 
  ixgbe_disable_sriov(adapter);
  #line 11192 
  adapter->flags2 &= 4294967279U;
  #line 11193 
  iounmap((void *)adapter->io_addr);
  #line 11194 
  kfree((void *)adapter->jump_tables[0]);
  #line 11195 
  kfree((void *)adapter->mac_table);
  #line 11196 
  kfree((void *)adapter->rss_key);
  #line 11197 
  bitmap_free(adapter->af_xdp_zc_qps);
  #line 11198 
  err_ioremap: 
               #line 11198 
  ;
  #line 11199 
  if ((int)test_and_set_bit(3L,& adapter->state) != 0) 
                                                       #line 11199 
                                                       tmp_26 = 0; else 
                                                                    #line 11199 
                                                                    tmp_26 = 1;
  #line 11199 
  disable_dev = (_Bool)(tmp_26 != 0);
  #line 11200 
  cif_free_netdev(netdev);
  #line 11201 
  err_alloc_etherdev: 
                      #line 11201 
  ;
  #line 11202 
  pci_release_mem_regions(pdev);
  #line 11203 
  err_pci_reg: 
               #line 11203 
  ;
  #line 11204 
  err_dma: 
           #line 11204 
  ;
  #line 11205 
  if (adapter == (struct ixgbe_adapter *)0 || (int)disable_dev != 0) 
    #line 11206 
    pci_disable_device(pdev);
  #line 11207 
  return err;
}

#line 11219  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_remove(struct pci_dev *pdev)
{
  #line 11222 
  struct net_device *netdev;
  #line 11223 
  bool disable_dev;
  #line 11224 
  int i;
  #line 11287 
  int tmp_1;
  #line 11221 
  struct ixgbe_adapter *adapter = pci_get_drvdata(pdev);
  #line 11227 
  if (adapter == (struct ixgbe_adapter *)0) 
                                            #line 11228 
                                            return;
  #line 11230 
  netdev = adapter->netdev;
  #line 11231 
  ixgbe_dbg_adapter_exit(adapter);
  #line 11233 
  cif_set_bit(4L,& adapter->state);
  #line 11234 
  cancel_work_sync(& adapter->service_task);
  #line 11236 
  if (adapter->mii_bus != (struct mii_bus *)0) 
                                               #line 11237 
                                               mdiobus_unregister(adapter->mii_bus);
  #line 11240 
  if (((unsigned long)adapter->flags & 256UL) != 0UL) {
    #line 11241 
    adapter->flags &= 4294967039U;
    #line 11242 
    dca_remove_requester(& pdev->dev);
    #line 11243 
    ixgbe_write_reg_1(& adapter->hw,69748U,1U);
  }
  #line 11249 
  ixgbe_sysfs_exit(adapter);
  #line 11253 
  ixgbe_del_sanmac_netdev(netdev);
  #line 11256 
  ixgbe_disable_sriov(adapter);
  #line 11258 
  if ((unsigned int)netdev->reg_state == 1U) 
                                             #line 11259 
                                             cif_unregister_netdev(netdev);
  #line 11261 
  ixgbe_stop_ipsec_offload(adapter);
  #line 11262 
  ixgbe_clear_interrupt_scheme(adapter);
  #line 11264 
  ixgbe_release_hw_control(adapter);
  #line 11267 
  kfree((void *)adapter->ixgbe_ieee_pfc);
  #line 11268 
  kfree((void *)adapter->ixgbe_ieee_ets);
  #line 11271 
  iounmap((void *)adapter->io_addr);
  #line 11272 
  pci_release_mem_regions(pdev);
  #line 11274 
  _dev_info(& (adapter->pdev)->dev,(char *)"complete\n");
  #line 11276 
  i = 0;
  #line 11276 
  while (i <= 9) {
    #line 11277 
    if (adapter->jump_tables[i] != (struct ixgbe_jump_table *)0) {
      #line 11278 
      kfree((void *)(adapter->jump_tables[i])->input);
      #line 11279 
      kfree((void *)(adapter->jump_tables[i])->mask);
    }
    #line 11281 
    kfree((void *)adapter->jump_tables[i]);
    #line 11276 
    i ++;
  }
  #line 11284 
  kfree((void *)adapter->mac_table);
  #line 11285 
  kfree((void *)adapter->rss_key);
  #line 11286 
  bitmap_free(adapter->af_xdp_zc_qps);
  #line 11287 
  if ((int)test_and_set_bit(3L,& adapter->state) != 0) 
                                                       #line 11287 
                                                       tmp_1 = 0; else 
                                                                    #line 11287 
                                                                    tmp_1 = 1;
  #line 11287 
  disable_dev = (_Bool)(tmp_1 != 0);
  #line 11288 
  cif_free_netdev(netdev);
  #line 11290 
  pci_disable_pcie_error_reporting(pdev);
  #line 11292 
  if ((int)disable_dev != 0) 
                             #line 11293 
                             pci_disable_device(pdev);
  #line 11294 
  return;
}

#line 11304  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static pci_ers_result_t ixgbe_io_error_detected(struct pci_dev *pdev, pci_channel_state_t state)
{
  #line 11312 
  struct pci_dev *bdev;
  #line 11312 
  struct pci_dev *vfdev;
  #line 11313 
  u32 dw0;
  #line 11313 
  u32 dw1;
  #line 11313 
  u32 dw2;
  #line 11313 
  u32 dw3;
  #line 11314 
  int vf;
  #line 11314 
  int pos;
  #line 11315 
  u16 req_id;
  #line 11315 
  u16 pf_func;
  #line 11307 
  struct ixgbe_adapter *adapter = pci_get_drvdata(pdev);
  #line 11308 
  struct net_device *netdev = adapter->netdev;
  #line 11311 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 11317 
  if (adapter->hw.mac.type == (unsigned int)ixgbe_mac_82598EB || adapter->num_vfs == 0U) 
    #line 11319 
    goto skip_bad_vf_detection;
  #line 11321 
  bdev = (pdev->bus)->self;
  #line 11322 
  while (1) {
    #line 11322 
    if (bdev != (struct pci_dev *)0) {
      #line 11322 
      if (! (pci_pcie_type(bdev) != 4)) 
                                        #line 11322 
                                        break;
    }
    else 
         #line 11322 
         break;
    #line 11323 
    bdev = (bdev->bus)->self;
  }
  #line 11325 
  if (bdev == (struct pci_dev *)0) 
                                   #line 11326 
                                   goto skip_bad_vf_detection;
  #line 11328 
  pos = pci_find_ext_capability(bdev,1);
  #line 11329 
  if (pos == 0) 
                #line 11330 
                goto skip_bad_vf_detection;
  #line 11332 
  dw0 = ixgbe_read_pci_cfg_dword(hw,(unsigned int)(pos + 28));
  #line 11333 
  dw1 = ixgbe_read_pci_cfg_dword(hw,(unsigned int)(pos + 32));
  #line 11334 
  dw2 = ixgbe_read_pci_cfg_dword(hw,(unsigned int)(pos + 36));
  #line 11335 
  dw3 = ixgbe_read_pci_cfg_dword(hw,(unsigned int)(pos + 40));
  #line 11336 
  if ((int)ixgbe_removed((void *)hw->hw_addr) != 0) 
                                                    #line 11337 
                                                    goto skip_bad_vf_detection;
  #line 11339 
  req_id = (unsigned short)(dw1 >> 16);
  #line 11341 
  if (((int)req_id & 128) == 0) 
                                #line 11342 
                                goto skip_bad_vf_detection;
  #line 11344 
  pf_func = (unsigned short)((unsigned int)req_id & 1U);
  #line 11345 
  if ((((unsigned int)pf_func ^ pdev->devfn) & 1U) == 0U) {
    #line 11346 
    unsigned int device_id;
    #line 11348 
    vf = ((int)req_id >> 1) & 63;
    #line 11349 
    _dev_err(& (adapter->pdev)->dev,(char *)"VF %d has caused a PCIe error\n",vf);
    #line 11350 
    _dev_err(& (adapter->pdev)->dev,(char *)"TLP: dw0: %8.8x\tdw1: %8.8x\tdw2: ",dw0,dw1,dw2,dw3);
    #line 11353 
    switch ((unsigned int)adapter->hw.mac.type) {
      #line 11354 
      case (unsigned int)2: 
                            #line 11354 
      ;
      #line 11355 
      device_id = 4333U;
      #line 11356 
      break;
      #line 11357 
      case (unsigned int)3: 
                            #line 11357 
      ;
      #line 11358 
      device_id = 5397U;
      #line 11359 
      break;
      #line 11360 
      case (unsigned int)4: 
                            #line 11360 
      ;
      #line 11361 
      device_id = 5477U;
      #line 11362 
      break;
      #line 11363 
      case (unsigned int)5: 
                            #line 11363 
      ;
      #line 11364 
      device_id = 5544U;
      #line 11365 
      break;
      #line 11366 
      case (unsigned int)6: 
                            #line 11366 
      ;
      #line 11367 
      device_id = 5573U;
      #line 11368 
      break;
      #line 11369 
      default: 
               #line 11369 
      ;
      #line 11370 
      device_id = 0U;
      #line 11371 
      break;
    }
    #line 11375 
    vfdev = pci_get_device(32902U,device_id,(struct pci_dev *)0);
    #line 11376 
    while (vfdev != (struct pci_dev *)0) {
      #line 11377 
      if (vfdev->devfn == ((unsigned int)req_id & 255U)) 
                                                         #line 11378 
                                                         break;
      #line 11379 
      vfdev = pci_get_device(32902U,device_id,vfdev);
    }
    #line 11387 
    if (vfdev != (struct pci_dev *)0) {
      #line 11388 
      pcie_flr(vfdev);
      #line 11390 
      pci_dev_put(vfdev);
    }
  }
  #line 11400 
  (adapter->vferr_refcount) ++;
  #line 11402 
  return 5U;
  #line 11404 
  skip_bad_vf_detection: 
                         #line 11404 
  ;
  #line 11406 
  if (! test_bit(6L,& adapter->state)) 
                                       #line 11407 
                                       return 4U;
  #line 11409 
  if (! netif_device_present(netdev)) 
                                      #line 11410 
                                      return 4U;
  #line 11412 
  rtnl_lock();
  #line 11413 
  netif_device_detach(netdev);
  #line 11415 
  if ((int)netif_running(netdev) != 0) 
                                       #line 11416 
                                       ixgbe_close_suspend(adapter);
  #line 11418 
  if (state == 3U) {
    #line 11419 
    rtnl_unlock();
    #line 11420 
    return 4U;
  }
  #line 11423 
  if (! test_and_set_bit(3L,& adapter->state)) 
                                               #line 11424 
                                               pci_disable_device(pdev);
  #line 11425 
  rtnl_unlock();
  #line 11428 
  return 3U;
}

#line 11437  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static pci_ers_result_t ixgbe_io_slot_reset(struct pci_dev *pdev)
{
  #line 11440 
  pci_ers_result_t result;
  #line 11439 
  struct ixgbe_adapter *adapter = pci_get_drvdata(pdev);
  #line 11442 
  if (pci_enable_device_mem(pdev) != 0) {
    #line 11443 
    if (((int)adapter->msg_enable & 2) != 0) 
                                             #line 11443 
                                             netdev_err(adapter->netdev,(char *)"Cannot re-enable PCI device after reset.\n");
    #line 11444 
    result = 4U;
  }
  else {
    #line 11447 
    cif_clear_bit(3L,& adapter->state);
    #line 11448 
    adapter->hw.hw_addr = adapter->io_addr;
    #line 11449 
    pci_set_master(pdev);
    #line 11450 
    pci_restore_state(pdev);
    #line 11451 
    pci_save_state(pdev);
    #line 11453 
    pci_wake_from_d3(pdev,(_Bool)0);
    #line 11455 
    ixgbe_reset(adapter);
    #line 11456 
    ixgbe_write_reg_1(& adapter->hw,22544U,4294967295U);
    #line 11457 
    result = 5U;
  }
  #line 11460 
  return result;
}

#line 11470  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_io_resume(struct pci_dev *pdev)
{
  #line 11472 
  struct ixgbe_adapter *adapter = pci_get_drvdata(pdev);
  #line 11473 
  struct net_device *netdev = adapter->netdev;
  #line 11476 
  if (adapter->vferr_refcount != 0U) {
    #line 11477 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 11477 
                                             netdev_info(adapter->netdev,(char *)"Resuming after VF err\n");
    #line 11478 
    (adapter->vferr_refcount) --;
    #line 11479 
    return;
  }
  #line 11483 
  rtnl_lock();
  #line 11484 
  if ((int)netif_running(netdev) != 0) 
                                       #line 11485 
                                       ixgbe_open(netdev);
  #line 11487 
  netif_device_attach(netdev);
  #line 11488 
  rtnl_unlock();
  #line 11489 
  return;
}

#line 11491  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct pci_error_handlers ixgbe_err_handler = {.error_detected = (pci_ers_result_t (*)(struct pci_dev *, enum pci_channel_state ))(& ixgbe_io_error_detected), .slot_reset = & ixgbe_io_slot_reset, .resume = & ixgbe_io_resume};
#line 11497  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct pci_driver ixgbe_driver = {.name = (char *)(& ixgbe_driver_name), .id_table = (struct pci_device_id *)(& ixgbe_pci_tbl), .probe = & ixgbe_probe, .remove = & ixgbe_remove, .suspend = & ixgbe_suspend, .resume = & ixgbe_resume, .shutdown = & ixgbe_shutdown, .sriov_configure = & ixgbe_pci_sriov_configure, .err_handler = & ixgbe_err_handler};
#line 11517  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_init_module(void)
{
  #line 11519 
  int ret;
  #line 11520 
  printk((char *)"\001",(char *)(& ixgbe_driver_string),(char *)(& ixgbe_driver_version));
  #line 11521 
  printk((char *)"\001",(char *)(& ixgbe_copyright));
  #line 11523 
  ixgbe_wq = alloc_workqueue((char *)"%s",917514U,1,(char *)(& ixgbe_driver_name));
  #line 11524 
  if (ixgbe_wq == (struct workqueue_struct *)0) {
    #line 11525 
    printk((char *)"\001",(char *)(& ixgbe_driver_name));
    #line 11526 
    return -12;
  }
  #line 11529 
  ixgbe_dbg_init();
  #line 11531 
  ret = cif___pci_register_driver(& ixgbe_driver,& __this_module,(char *)"ixgbe");
  #line 11532 
  if (ret != 0) {
    #line 11533 
    destroy_workqueue(ixgbe_wq);
    #line 11534 
    ixgbe_dbg_exit();
    #line 11535 
    return ret;
  }
  #line 11539 
  dca_register_notify(& dca_notifier);
  #line 11542 
  return 0;
}

#line 11553  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_exit_module(void)
{
  #line 11556 
  dca_unregister_notify(& dca_notifier);
  #line 11558 
  cif_pci_unregister_driver(& ixgbe_driver);
  #line 11560 
  ixgbe_dbg_exit();
  #line 11561 
  if (ixgbe_wq != (struct workqueue_struct *)0) {
    #line 11562 
    destroy_workqueue(ixgbe_wq);
    #line 11563 
    ixgbe_wq = (struct workqueue_struct *)0;
  }
  #line 11565 
  return;
}

#line 11568  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_notify_dca(struct notifier_block *nb, unsigned long event, void *p)
{
  #line 11571 
  int ret_val;
  #line 11576 
  int tmp;
  #line 11573 
  ret_val = driver_for_each_device(& ixgbe_driver.driver,(struct device *)0,(void *)(& event),& __ixgbe_notify_dca);
  #line 11576 
  if (ret_val != 0) 
                    #line 11576 
                    tmp = 32770; else 
                                      #line 11576 
                                      tmp = 0;
  #line 11576 
  return tmp;
}

#line 93  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
int (*emg_alias_eth_validate_addr)(struct net_device *) = & eth_validate_addr;
#line 94  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
struct pci_driver *emg_alias_ixgbe_driver = & ixgbe_driver;
#line 95  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
struct pci_device_id (*emg_alias_ixgbe_pci_tbl)[48U] = & ixgbe_pci_tbl;
#line 98 
#line 98 
int emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2);
#line 99 
#line 99 
struct net_device *emg_alloc_etherdev_mqs(int arg0, unsigned int arg1, unsigned int arg2);
#line 100 
#line 100 
int emg_del_timer_sync(struct timer_list *arg0);
#line 101 
#line 101 
void *emg_free_irq(unsigned int arg0, void *arg1);
#line 102 
#line 102 
void emg_free_netdev(struct net_device *arg0);
#line 103 
#line 103 
int emg_mod_timer(struct timer_list *arg0, unsigned long arg1);
#line 104 
#line 104 
void emg_pci_unregister_driver(struct pci_driver *arg0);
#line 105 
#line 105 
_Bool emg_queue_work(struct workqueue_struct *arg0, struct work_struct *arg1);
#line 106 
#line 106 
int emg_register_netdev(struct net_device *arg0);
#line 107 
#line 107 
int emg_request_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), unsigned long arg2, char *arg3, void *arg4);
#line 108 
#line 108 
_Bool emg_schedule_work(struct work_struct *arg0);
#line 109 
#line 109 
void emg_unregister_netdev(struct net_device *arg0);
#line 113  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
int emg_wrapper___ixgbe_setup_tc(struct net_device *arg0, enum tc_setup_type arg1, void *arg2)
{
  #line 114 
  return __ixgbe_setup_tc(arg0,arg1,arg2);
}

#line 118  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
void emg_wrapper_ixgbe_add_udp_tunnel_port(struct net_device *arg0, struct udp_tunnel_info *arg1)
{
  #line 119 
  ixgbe_add_udp_tunnel_port(arg0,arg1);
  #line 120 
  return;
}

#line 123  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
int emg_wrapper_ixgbe_change_mtu(struct net_device *arg0, int arg1)
{
  #line 124 
  return ixgbe_change_mtu(arg0,arg1);
}

#line 128  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
int emg_wrapper_ixgbe_close(struct net_device *arg0)
{
  #line 129 
  return ixgbe_close(arg0);
}

#line 133  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
void emg_wrapper_ixgbe_del_udp_tunnel_port(struct net_device *arg0, struct udp_tunnel_info *arg1)
{
  #line 134 
  ixgbe_del_udp_tunnel_port(arg0,arg1);
  #line 135 
  return;
}

#line 138  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
int emg_wrapper_ixgbe_fcoe_disable(struct net_device *arg0)
{
  #line 139 
  return ixgbe_fcoe_disable(arg0);
}

#line 143  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
int emg_wrapper_ixgbe_fcoe_enable(struct net_device *arg0)
{
  #line 144 
  return ixgbe_fcoe_enable(arg0);
}

#line 148  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
unsigned long long emg_wrapper_ixgbe_features_check(struct sk_buff *arg0, struct net_device *arg1, unsigned long long arg2)
{
  #line 149 
  return ixgbe_features_check(arg0,arg1,arg2);
}

#line 153  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
unsigned long long emg_wrapper_ixgbe_fix_features(struct net_device *arg0, unsigned long long arg1)
{
  #line 154 
  return ixgbe_fix_features(arg0,arg1);
}

#line 158  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
void *emg_wrapper_ixgbe_fwd_add(struct net_device *arg0, struct net_device *arg1)
{
  #line 159 
  return ixgbe_fwd_add(arg0,arg1);
}

#line 163  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
void emg_wrapper_ixgbe_fwd_del(struct net_device *arg0, void *arg1)
{
  #line 164 
  ixgbe_fwd_del(arg0,arg1);
  #line 165 
  return;
}

#line 168  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
void emg_wrapper_ixgbe_get_stats64(struct net_device *arg0, struct rtnl_link_stats64 *arg1)
{
  #line 169 
  ixgbe_get_stats64(arg0,arg1);
  #line 170 
  return;
}

#line 173  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
enum irqreturn emg_wrapper_ixgbe_intr(int arg0, void *arg1)
{
  #line 174 
  return ixgbe_intr(arg0,arg1);
}

#line 178  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
int emg_wrapper_ixgbe_ioctl(struct net_device *arg0, struct ifreq *arg1, int arg2)
{
  #line 179 
  return ixgbe_ioctl(arg0,arg1,arg2);
}

#line 183  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
enum irqreturn emg_wrapper_ixgbe_msix_clean_rings(int arg0, void *arg1)
{
  #line 184 
  return ixgbe_msix_clean_rings(arg0,arg1);
}

#line 188  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
enum irqreturn emg_wrapper_ixgbe_msix_other(int arg0, void *arg1)
{
  #line 189 
  return ixgbe_msix_other(arg0,arg1);
}

#line 193  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
int emg_wrapper_ixgbe_ndo_bridge_getlink(struct sk_buff *arg0, unsigned int arg1, unsigned int arg2, struct net_device *arg3, unsigned int arg4, int arg5)
{
  #line 194 
  return ixgbe_ndo_bridge_getlink(arg0,arg1,arg2,arg3,arg4,arg5);
}

#line 198  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
int emg_wrapper_ixgbe_ndo_bridge_setlink(struct net_device *arg0, struct nlmsghdr *arg1, unsigned short arg2, struct netlink_ext_ack *arg3)
{
  #line 199 
  return ixgbe_ndo_bridge_setlink(arg0,arg1,(unsigned short)((int)arg2),arg3);
}

#line 203  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
int emg_wrapper_ixgbe_ndo_fdb_add(struct ndmsg *arg0, struct nlattr **arg1, struct net_device *arg2, unsigned char *arg3, unsigned short arg4, unsigned short arg5, struct netlink_ext_ack *arg6)
{
  #line 204 
  return ixgbe_ndo_fdb_add(arg0,arg1,arg2,arg3,(unsigned short)((int)arg4),
                        (unsigned short)((int)arg5),arg6);
}

#line 208  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
int emg_wrapper_ixgbe_open(struct net_device *arg0)
{
  #line 209 
  return ixgbe_open(arg0);
}

#line 213  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
int emg_wrapper_ixgbe_probe(struct pci_dev *arg0, struct pci_device_id *arg1)
{
  #line 214 
  return ixgbe_probe(arg0,arg1);
}

#line 218  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
void emg_wrapper_ixgbe_remove(struct pci_dev *arg0)
{
  #line 219 
  ixgbe_remove(arg0);
  #line 220 
  return;
}

#line 223  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
int emg_wrapper_ixgbe_resume(struct pci_dev *arg0)
{
  #line 224 
  return ixgbe_resume(arg0);
}

#line 228  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
unsigned short emg_wrapper_ixgbe_select_queue(struct net_device *arg0, struct sk_buff *arg1, struct net_device *arg2)
{
  #line 229 
  return ixgbe_select_queue(arg0,arg1,arg2);
}

#line 233  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
int emg_wrapper_ixgbe_set_features(struct net_device *arg0, unsigned long long arg1)
{
  #line 234 
  return ixgbe_set_features(arg0,arg1);
}

#line 238  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
int emg_wrapper_ixgbe_set_mac(struct net_device *arg0, void *arg1)
{
  #line 239 
  return ixgbe_set_mac(arg0,arg1);
}

#line 243  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
void emg_wrapper_ixgbe_shutdown(struct pci_dev *arg0)
{
  #line 244 
  ixgbe_shutdown(arg0);
  #line 245 
  return;
}

#line 248  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
int emg_wrapper_ixgbe_suspend(struct pci_dev *arg0, struct pm_message arg1)
{
  #line 249 
  return ixgbe_suspend(arg0,arg1);
}

#line 253  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
int emg_wrapper_ixgbe_tx_maxrate(struct net_device *arg0, int arg1, unsigned int arg2)
{
  #line 254 
  return ixgbe_tx_maxrate(arg0,arg1,arg2);
}

#line 258  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
void emg_wrapper_ixgbe_tx_timeout(struct net_device *arg0)
{
  #line 259 
  ixgbe_tx_timeout(arg0);
  #line 260 
  return;
}

#line 263  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
int emg_wrapper_ixgbe_vlan_rx_add_vid(struct net_device *arg0, unsigned short arg1, unsigned short arg2)
{
  #line 264 
  return ixgbe_vlan_rx_add_vid(arg0,(unsigned short)((int)arg1),
                            (unsigned short)((int)arg2));
}

#line 268  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
int emg_wrapper_ixgbe_vlan_rx_kill_vid(struct net_device *arg0, unsigned short arg1, unsigned short arg2)
{
  #line 269 
  return ixgbe_vlan_rx_kill_vid(arg0,(unsigned short)((int)arg1),
                             (unsigned short)((int)arg2));
}

#line 273  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
int emg_wrapper_ixgbe_xdp(struct net_device *arg0, struct netdev_bpf *arg1)
{
  #line 274 
  return ixgbe_xdp(arg0,arg1);
}

#line 278  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
int emg_wrapper_ixgbe_xdp_xmit(struct net_device *arg0, int arg1, struct xdp_frame **arg2, unsigned int arg3)
{
  #line 279 
  return ixgbe_xdp_xmit(arg0,arg1,arg2,arg3);
}

#line 283  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
enum netdev_tx emg_wrapper_ixgbe_xmit_frame(struct sk_buff *arg0, struct net_device *arg1)
{
  #line 284 
  return ixgbe_xmit_frame(arg0,arg1);
}

#line 288  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
void emg_ixgbe_exit_module(void)
{
  #line 289 
  ixgbe_exit_module();
  #line 290 
  return;
}

#line 292  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
int emg_ixgbe_init_module(void)
{
  #line 293 
  return ixgbe_init_module();
}

#line 304  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static unsigned long cif_find_next_bit(unsigned long *addr, unsigned long size, unsigned long offset)
{
  #line 307 
  return ldv_find_next_bit(addr,size,offset);
}

#line 311  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void cif_set_bit(long nr, unsigned long *addr)
{
  #line 314 
  ldv_set_bit(nr,addr);
  #line 315 
  return;
}

#line 318  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void cif_clear_bit(long nr, unsigned long *addr)
{
  #line 321 
  ldv_clear_bit(nr,addr);
  #line 322 
  return;
}

#line 325  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void INIT_LIST_HEAD(struct list_head *list)
{
  #line 328 
  ldv_init_list_head(list);
  #line 329 
  return;
}

#line 353  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void atomic_add(int i, atomic_t *v)
{
  #line 356 
  ldv_atomic_add(i,v);
  #line 357 
  return;
}

#line 395  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void *ERR_PTR(long error)
{
  #line 398 
  return ldv_err_ptr(error);
}

#line 402  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static long PTR_ERR(void *ptr)
{
  #line 405 
  return ldv_ptr_err(ptr);
}

#line 409  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static bool IS_ERR(void *ptr)
{
  #line 412 
  return ldv_is_err(ptr);
}

#line 495  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static bool cif_queue_work(struct workqueue_struct *wq, struct work_struct *work)
{
  #line 499 
  return emg_queue_work(wq,work);
}

#line 655  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void *kcalloc(size_t n, size_t size, gfp_t flags)
{
  #line 658 
  return ldv_kcalloc(n,size,flags);
}

#line 676  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void *kzalloc(size_t size, gfp_t flags)
{
  #line 679 
  return ldv_kzalloc(size,flags);
}

#line 737  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void cif_spin_lock__xmit_lock_of_netdev_queue(spinlock_t *lock)
{
  #line 740 
  ldv_spin_model_lock((char *)"_xmit_lock_of_netdev_queue");
  #line 742 
  spin_lock(lock);
  #line 743 
  return;
}

#line 777  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void cif_spin_unlock__xmit_lock_of_netdev_queue(spinlock_t *lock)
{
  #line 780 
  ldv_spin_model_unlock((char *)"_xmit_lock_of_netdev_queue");
  #line 782 
  spin_unlock(lock);
  #line 783 
  return;
}

#line 883  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static bool cif_schedule_work(struct work_struct *work)
{
  #line 887 
  return emg_schedule_work(work);
}

#line 1051  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static int cif_request_irq(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char *name, void *dev)
{
  #line 1055 
  return emg_request_irq(irq,handler,flags,name,dev);
}

#line 1059  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void *cif_free_irq(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  #line 1063 
  return emg_free_irq(ldv_func_arg1,ldv_func_arg2);
}

#line 1067  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void cif_spin_lock_fdir_perfect_lock_of_ixgbe_adapter(spinlock_t *lock)
{
  #line 1070 
  ldv_spin_model_lock((char *)"fdir_perfect_lock_of_ixgbe_adapter");
  #line 1072 
  spin_lock(lock);
  #line 1073 
  return;
}

#line 1076  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void cif_spin_unlock_fdir_perfect_lock_of_ixgbe_adapter(spinlock_t *lock)
{
  #line 1079 
  ldv_spin_model_unlock((char *)"fdir_perfect_lock_of_ixgbe_adapter");
  #line 1081 
  spin_unlock(lock);
  #line 1082 
  return;
}

#line 1085  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static int cif_mod_timer(struct timer_list *timer, unsigned long expires)
{
  #line 1089 
  return emg_mod_timer(timer,expires);
}

#line 1093  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static int cif_del_timer_sync(struct timer_list *timer)
{
  #line 1097 
  return emg_del_timer_sync(timer);
}

#line 1101  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void *cif_vmalloc_node(unsigned long size, int node)
{
  #line 1104 
  return ldv_vmalloc(size);
}

#line 1108  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void *cif_vmalloc(unsigned long size)
{
  #line 1111 
  return ldv_vmalloc(size);
}

#line 1115  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void cif_vfree(void *addr)
{
  #line 1118 
  ldv_vfree(addr);
  #line 1119 
  return;
}

#line 1122  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void cif_unregister_netdev(struct net_device *dev)
{
  #line 1126 
  emg_unregister_netdev(dev);
  #line 1127 
  return;
}

#line 1130  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void cif_bitmap_clear(unsigned long *map, unsigned int start, unsigned int nbits)
{
  #line 1133 
  ldv_bitmap_clear(map,start,(int)nbits);
  #line 1134 
  return;
}

#line 1137  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static struct net_device *cif_alloc_etherdev_mqs(int sizeof_priv, unsigned int txqs, unsigned int rxqs)
{
  #line 1141 
  return emg_alloc_etherdev_mqs(sizeof_priv,txqs,rxqs);
}

#line 1145  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static int cif_register_netdev(struct net_device *dev)
{
  #line 1149 
  return emg_register_netdev(dev);
}

#line 1153  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void cif_free_netdev(struct net_device *dev)
{
  #line 1157 
  emg_free_netdev(dev);
  #line 1158 
  return;
}

#line 1161  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static int cif___pci_register_driver(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char *mod_name)
{
  #line 1165 
  return emg___pci_register_driver(ldv_func_arg1,ldv_func_arg2,mod_name);
}

#line 1169  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_main.i.aux"
static void cif_pci_unregister_driver(struct pci_driver *dev)
{
  #line 1173 
  emg_pci_unregister_driver(dev);
  #line 1174 
  return;
}

#line 6  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/delay.h"
#line 6 
void __bad_udelay(void);
#line 9 
#line 9 
void __udelay(unsigned long);
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.h"
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
s32 ixgbe_read_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size, u16 mbx_id);
#line 99  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.h"
#line 41  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
s32 ixgbe_write_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size, u16 mbx_id);
#line 100  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.h"
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
s32 ixgbe_check_for_msg(struct ixgbe_hw *hw, u16 mbx_id);
#line 101  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.h"
#line 78  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
s32 ixgbe_check_for_ack(struct ixgbe_hw *hw, u16 mbx_id);
#line 102  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.h"
#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
s32 ixgbe_check_for_rst(struct ixgbe_hw *hw, u16 mbx_id);
#line 107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.h"
#line 426  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
struct ixgbe_mbx_operations mbx_ops_generic;
#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static void ixgbe_write_reg_2(struct ixgbe_hw *hw, u32 reg, u32 value)
{
  #line 147 
  union __anonunion___u_3369 __u;
  #line 146 
  __read_once_size((void *)(& hw->hw_addr),(void *)(& __u.__c),8);
  #line 146 
  u8 *reg_addr = (__u.__val);
  #line 148 
  if ((int)ixgbe_removed((void *)reg_addr) != 0) 
                                                 #line 149 
                                                 return;
  #line 150 
  writel(value,(void *)(reg_addr + (unsigned long)reg));
  #line 151 
  return;
}

#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
s32 ixgbe_read_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size, u16 mbx_id)
{
  #line 20 
  struct ixgbe_mbx_info *mbx = & hw->mbx;
  #line 23 
  if ((int)mbx->size < (int)size) 
                                  #line 24 
                                  size = mbx->size;
  #line 26 
  if (mbx->ops == (struct ixgbe_mbx_operations *)0) 
                                                    #line 27 
                                                    return -100;
  #line 29 
  return (*((mbx->ops)->read))(hw,msg,(unsigned short)((int)size),
                            (unsigned short)((int)mbx_id));
}

#line 41  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
s32 ixgbe_write_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size, u16 mbx_id)
{
  #line 43 
  struct ixgbe_mbx_info *mbx = & hw->mbx;
  #line 45 
  if ((int)mbx->size < (int)size) 
                                  #line 46 
                                  return -100;
  #line 48 
  if (mbx->ops == (struct ixgbe_mbx_operations *)0) 
                                                    #line 49 
                                                    return -100;
  #line 51 
  return (*((mbx->ops)->write))(hw,msg,(unsigned short)((int)size),
                             (unsigned short)((int)mbx_id));
}

#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
s32 ixgbe_check_for_msg(struct ixgbe_hw *hw, u16 mbx_id)
{
  #line 63 
  struct ixgbe_mbx_info *mbx = & hw->mbx;
  #line 65 
  if (mbx->ops == (struct ixgbe_mbx_operations *)0) 
                                                    #line 66 
                                                    return -100;
  #line 68 
  return (*((mbx->ops)->check_for_msg))(hw,(unsigned short)((int)mbx_id));
}

#line 78  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
s32 ixgbe_check_for_ack(struct ixgbe_hw *hw, u16 mbx_id)
{
  #line 80 
  struct ixgbe_mbx_info *mbx = & hw->mbx;
  #line 82 
  if (mbx->ops == (struct ixgbe_mbx_operations *)0) 
                                                    #line 83 
                                                    return -100;
  #line 85 
  return (*((mbx->ops)->check_for_ack))(hw,(unsigned short)((int)mbx_id));
}

#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
s32 ixgbe_check_for_rst(struct ixgbe_hw *hw, u16 mbx_id)
{
  #line 97 
  struct ixgbe_mbx_info *mbx = & hw->mbx;
  #line 99 
  if (mbx->ops == (struct ixgbe_mbx_operations *)0) 
                                                    #line 100 
                                                    return -100;
  #line 102 
  return (*((mbx->ops)->check_for_rst))(hw,(unsigned short)((int)mbx_id));
}

#line 112  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_poll_for_msg(struct ixgbe_hw *hw, u16 mbx_id)
{
  #line 114 
  struct ixgbe_mbx_info *mbx = & hw->mbx;
  #line 115 
  int countdown = (int)mbx->timeout;
  #line 117 
  if (countdown == 0 || mbx->ops == (struct ixgbe_mbx_operations *)0) 
    #line 118 
    return -100;
  #line 120 
  while (1) {
    #line 120 
    if (! ((*((mbx->ops)->check_for_msg))(hw,(unsigned short)((int)mbx_id)) != 0)) 
      #line 120 
      break;
    #line 121 
    countdown --;
    #line 122 
    if (countdown == 0) 
                        #line 123 
                        return -100;
    #line 124 
    if (0 != 0) 
      #line 124 
      if (mbx->usec_delay > 19999U) 
                                    #line 124 
                                    __bad_udelay(); else 
                                                         #line 124 
                                                         __const_udelay((unsigned long)mbx->usec_delay * 4295UL);
    else 
         #line 124 
         __udelay((unsigned long)mbx->usec_delay);
  }
  #line 127 
  return 0;
}

#line 137  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_poll_for_ack(struct ixgbe_hw *hw, u16 mbx_id)
{
  #line 139 
  struct ixgbe_mbx_info *mbx = & hw->mbx;
  #line 140 
  int countdown = (int)mbx->timeout;
  #line 142 
  if (countdown == 0 || mbx->ops == (struct ixgbe_mbx_operations *)0) 
    #line 143 
    return -100;
  #line 145 
  while (1) {
    #line 145 
    if (! ((*((mbx->ops)->check_for_ack))(hw,(unsigned short)((int)mbx_id)) != 0)) 
      #line 145 
      break;
    #line 146 
    countdown --;
    #line 147 
    if (countdown == 0) 
                        #line 148 
                        return -100;
    #line 149 
    if (0 != 0) 
      #line 149 
      if (mbx->usec_delay > 19999U) 
                                    #line 149 
                                    __bad_udelay(); else 
                                                         #line 149 
                                                         __const_udelay((unsigned long)mbx->usec_delay * 4295UL);
    else 
         #line 149 
         __udelay((unsigned long)mbx->usec_delay);
  }
  #line 152 
  return 0;
}

#line 165  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_read_posted_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size, u16 mbx_id)
{
  #line 169 
  s32 ret_val;
  #line 168 
  struct ixgbe_mbx_info *mbx = & hw->mbx;
  #line 171 
  if (mbx->ops == (struct ixgbe_mbx_operations *)0) 
                                                    #line 172 
                                                    return -100;
  #line 174 
  ret_val = ixgbe_poll_for_msg(hw,(unsigned short)((int)mbx_id));
  #line 175 
  if (ret_val != 0) 
                    #line 176 
                    return ret_val;
  #line 179 
  return (*((mbx->ops)->read))(hw,msg,(unsigned short)((int)size),
                            (unsigned short)((int)mbx_id));
}

#line 192  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_write_posted_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size, u16 mbx_id)
{
  #line 196 
  s32 ret_val;
  #line 195 
  struct ixgbe_mbx_info *mbx = & hw->mbx;
  #line 199 
  if (mbx->ops == (struct ixgbe_mbx_operations *)0 || mbx->timeout == 0U) 
    #line 200 
    return -100;
  #line 203 
  ret_val = (*((mbx->ops)->write))(hw,msg,(unsigned short)((int)size),(unsigned short)((int)mbx_id));
  #line 204 
  if (ret_val != 0) 
                    #line 205 
                    return ret_val;
  #line 208 
  return ixgbe_poll_for_ack(hw,(unsigned short)((int)mbx_id));
}

#line 211  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_check_for_bit_pf(struct ixgbe_hw *hw, u32 mask, s32 index)
{
  #line 213 
  u32 mbvficr = ixgbe_read_reg(hw,(unsigned int)((index + 452) * 4));
  #line 215 
  if ((mbvficr & mask) != 0U) {
    #line 216 
    ixgbe_write_reg_2(hw,(unsigned int)((index + 452) * 4),mask);
    #line 217 
    return 0;
  }
  #line 220 
  return -100;
}

#line 230  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_check_for_msg_pf(struct ixgbe_hw *hw, u16 vf_number)
{
  #line 232 
  s32 index = (int)vf_number >> 4;
  #line 233 
  u32 vf_bit = (unsigned int)vf_number & 15U;
  #line 235 
  if (ixgbe_check_for_bit_pf(hw,(unsigned int)(1 << vf_bit),index) == 0) {
    #line 237 
    (hw->mbx.stats.reqs) ++;
    #line 238 
    return 0;
  }
  #line 241 
  return -100;
}

#line 251  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_check_for_ack_pf(struct ixgbe_hw *hw, u16 vf_number)
{
  #line 253 
  s32 index = (int)vf_number >> 4;
  #line 254 
  u32 vf_bit = (unsigned int)vf_number & 15U;
  #line 256 
  if (ixgbe_check_for_bit_pf(hw,(unsigned int)(65536 << vf_bit),index) == 0) {
    #line 258 
    (hw->mbx.stats.acks) ++;
    #line 259 
    return 0;
  }
  #line 262 
  return -100;
}

#line 272  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_check_for_rst_pf(struct ixgbe_hw *hw, u16 vf_number)
{
  #line 274 
  u32 reg_offset = (unsigned int)((unsigned int)vf_number > 31U);
  #line 275 
  u32 vf_shift = (unsigned int)vf_number & 31U;
  #line 276 
  u32 vflre = 0U;
  #line 278 
  switch ((unsigned int)hw->mac.type) {
    #line 280 
    unsigned int tmp;
    #line 279 
    case (unsigned int)2: 
                          #line 279 
    ;
    #line 280 
    if ((reg_offset & 1U) != 0U) 
                                 #line 280 
                                 tmp = 448U; else 
                                                  #line 280 
                                                  tmp = 1536U;
    #line 280 
    ;
    #line 280 
    vflre = ixgbe_read_reg(hw,tmp);
    #line 281 
    break;
    #line 282 
    case (unsigned int)3: 
                          #line 282 
    ;
    #line 283 
    case (unsigned int)4: 
                          #line 283 
    ;
    #line 284 
    case (unsigned int)5: 
                          #line 284 
    ;
    #line 285 
    case (unsigned int)6: 
                          #line 285 
    ;
    #line 286 
    vflre = ixgbe_read_reg(hw,(reg_offset + 448U) * 4U);
    #line 287 
    break;
    #line 288 
    default: 
             #line 288 
    ;
    #line 289 
    break;
  }
  #line 292 
  if ((((unsigned long)vflre >> vf_shift) & 1UL) != 0UL) {
    #line 293 
    ixgbe_write_reg_2(hw,(reg_offset + 448U) * 4U,(unsigned int)(1UL << vf_shift));
    #line 294 
    (hw->mbx.stats.rsts) ++;
    #line 295 
    return 0;
  }
  #line 298 
  return -100;
}

#line 308  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_obtain_mbx_lock_pf(struct ixgbe_hw *hw, u16 vf_number)
{
  #line 310 
  u32 p2v_mailbox;
  #line 313 
  ixgbe_write_reg_2(hw,(unsigned int)(((int)vf_number + 4800) * 4),8U);
  #line 316 
  p2v_mailbox = ixgbe_read_reg(hw,(unsigned int)(((int)vf_number + 4800) * 4));
  #line 317 
  if ((p2v_mailbox & 8U) != 0U) 
                                #line 318 
                                return 0;
  #line 320 
  return -100;
}

#line 332  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_write_mbx_pf(struct ixgbe_hw *hw, u32 *msg, u16 size, u16 vf_number)
{
  #line 335 
  s32 ret_val;
  #line 336 
  u16 i;
  #line 339 
  ret_val = ixgbe_obtain_mbx_lock_pf(hw,(unsigned short)((int)vf_number));
  #line 340 
  if (ret_val != 0) 
                    #line 341 
                    return ret_val;
  #line 344 
  ixgbe_check_for_msg_pf(hw,(unsigned short)((int)vf_number));
  #line 345 
  ixgbe_check_for_ack_pf(hw,(unsigned short)((int)vf_number));
  #line 348 
  i = (unsigned short)0U;
  #line 348 
  while ((int)i < (int)size) {
    #line 349 
    ixgbe_write_reg_2(hw,(unsigned int)(((int)vf_number + 1216) * 64 + ((int)i << 2)),*(msg + (unsigned long)i));
    #line 348 
    i = (u16)((int)i + 1);
  }
  #line 352 
  ixgbe_write_reg_2(hw,(unsigned int)(((int)vf_number + 4800) * 4),1U);
  #line 355 
  (hw->mbx.stats.msgs_tx) ++;
  #line 357 
  return 0;
}

#line 371  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_read_mbx_pf(struct ixgbe_hw *hw, u32 *msg, u16 size, u16 vf_number)
{
  #line 374 
  s32 ret_val;
  #line 375 
  u16 i;
  #line 378 
  ret_val = ixgbe_obtain_mbx_lock_pf(hw,(unsigned short)((int)vf_number));
  #line 379 
  if (ret_val != 0) 
                    #line 380 
                    return ret_val;
  #line 383 
  i = (unsigned short)0U;
  #line 383 
  while ((int)i < (int)size) {
    #line 384 
    *(msg + (unsigned long)i) = ixgbe_read_reg(hw,(unsigned int)(((int)vf_number + 1216) * 64 + ((int)i << 2)));
    #line 383 
    i = (u16)((int)i + 1);
  }
  #line 387 
  ixgbe_write_reg_2(hw,(unsigned int)(((int)vf_number + 4800) * 4),2U);
  #line 390 
  (hw->mbx.stats.msgs_rx) ++;
  #line 392 
  return 0;
}

#line 402  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
void ixgbe_init_mbx_params_pf(struct ixgbe_hw *hw)
{
  #line 404 
  struct ixgbe_mbx_info *mbx = & hw->mbx;
  #line 406 
  if ((((hw->mac.type != (unsigned int)ixgbe_mac_82599EB && hw->mac.type != (unsigned int)ixgbe_mac_X550) && hw->mac.type != (unsigned int)ixgbe_mac_X550EM_x) && hw->mac.type != (unsigned int)ixgbe_mac_x550em_a) && hw->mac.type != (unsigned int)ixgbe_mac_X540) 
    #line 411 
    return;
  #line 413 
  mbx->timeout = 0U;
  #line 414 
  mbx->usec_delay = 0U;
  #line 416 
  mbx->stats.msgs_tx = 0U;
  #line 417 
  mbx->stats.msgs_rx = 0U;
  #line 418 
  mbx->stats.reqs = 0U;
  #line 419 
  mbx->stats.acks = 0U;
  #line 420 
  mbx->stats.rsts = 0U;
  #line 422 
  mbx->size = (unsigned short)16U;
  #line 423 
  return;
}

#line 426  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
struct ixgbe_mbx_operations mbx_ops_generic = {.read = & ixgbe_read_mbx_pf, .write = & ixgbe_write_mbx_pf, .read_posted = & ixgbe_read_posted_mbx, .write_posted = & ixgbe_write_posted_mbx, .check_for_msg = & ixgbe_check_for_msg_pf, .check_for_ack = & ixgbe_check_for_ack_pf, .check_for_rst = & ixgbe_check_for_rst_pf};
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
#line 121  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_lib.i.aux"
static void cif_set_bit_0(long nr, unsigned long *addr);
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/cmpxchg_64.h"
__inline static int arch_atomic_read_0(atomic_t *v)
{
  #line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/atomic.h"
  union __anonunion___u_3447 __u;
  #line 31 
  __read_once_size((void *)(& v->counter),(void *)(& __u.__c),4);
  #line 31 
  return (__u.__val);
}

#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/atomic-instrumented.h"
__inline static int atomic_read_0(atomic_t *v)
{
  #line 26 
  kasan_check_read((void *)v,4U);
  #line 27 
  return arch_atomic_read_0(v);
}

#line 110  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
__inline static unsigned int num_online_cpus_0(void)
{
  #line 112 
  return (unsigned int)atomic_read_0(& __num_online_cpus);
}

#line 247 
#line 247 
unsigned int cpumask_local_spread(unsigned int, int);
#line 325  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
__inline static void cpumask_set_cpu(unsigned int cpu, struct cpumask *dstp)
{
  #line 327 
  ;
  #line 327 
  cif_set_bit_0((long)cpumask_check(cpu),(unsigned long *)(& dstp->bits));
  #line 328 
  return;
}

#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcutree.h"
#line 36 
void kfree_call_rcu(struct callback_head *, void (*)(struct callback_head *));
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/topology.h"
#line 48 
int __cpu_to_node(int);
#line 257  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/overflow.h"
#line 257 
extern int ( /* missing proto */ __builtin_mul_overflow)(unsigned long x_0, unsigned long x_1, size_t *x_2);
#line 297 
#line 297 
extern int ( /* missing proto */ __builtin_add_overflow)(unsigned long x_0, unsigned long x_1, size_t *x_2);
#line 291  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/overflow.h"
__inline static size_t __ab_c_size(size_t a, size_t b, size_t c)
{
  #line 295 
  size_t __a;
  #line 295 
  size_t __b;
  #line 295 
  size_t *__d;
  #line 297 
  size_t __a_0;
  #line 297 
  size_t __b_0;
  #line 297 
  size_t *__d_0;
  #line 293 
  size_t bytes;
  {
    #line 295 
    __a = a;
    #line 295 
    __b = b;
    #line 295 
    __d = & bytes;
    #line 295 
    int tmp = & __a == __d;
    }
  #line 295 
  if (__builtin_mul_overflow(__a,__b,__d) != 0) 
                                                #line 296 
                                                return 18446744073709551615UL;
  {
    #line 297 
    __a_0 = bytes;
    #line 297 
    __b_0 = c;
    #line 297 
    __d_0 = & bytes;
    #line 297 
    int tmp_3 = & __a_0 == __d_0;
    }
  #line 297 
  if (__builtin_add_overflow(__a_0,__b_0,__d_0) != 0) 
                                                      #line 298 
                                                      return 18446744073709551615UL;
  #line 300 
  return bytes;
}

#line 320  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 320 
extern struct kmem_cache *kmalloc_caches[3U][14U];
#line 322  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
__inline static enum kmalloc_cache_type kmalloc_type(gfp_t flags)
{
  #line 336 
  int tmp;
  #line 329 
  if ((long)((flags & 17U) == 0U) != 0L) 
                                         #line 330 
                                         return KMALLOC_NORMAL;
  #line 336 
  if ((flags & 1U) != 0U) 
                          #line 336 
                          tmp = KMALLOC_DMA; else 
                                                  #line 336 
                                                  tmp = KMALLOC_RECLAIM;
  #line 336 
  return (enum kmalloc_cache_type)tmp;
}

#line 350  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
__inline static unsigned int kmalloc_index(size_t size)
{
  #line 352 
  if (size == 0UL) 
                   #line 353 
                   return 0U;
  #line 355 
  if (size <= 8UL) 
                   #line 356 
                   return 3U;
  #line 358 
  if (size + 18446744073709551551UL <= 31UL) 
                                             #line 359 
                                             return 1U;
  #line 360 
  if (size + 18446744073709551487UL <= 63UL) 
                                             #line 361 
                                             return 2U;
  #line 362 
  if (size <= 8UL) 
                   #line 362 
                   return 3U;
  #line 363 
  if (size <= 16UL) 
                    #line 363 
                    return 4U;
  #line 364 
  if (size <= 32UL) 
                    #line 364 
                    return 5U;
  #line 365 
  if (size <= 64UL) 
                    #line 365 
                    return 6U;
  #line 366 
  if (size <= 128UL) 
                     #line 366 
                     return 7U;
  #line 367 
  if (size <= 256UL) 
                     #line 367 
                     return 8U;
  #line 368 
  if (size <= 512UL) 
                     #line 368 
                     return 9U;
  #line 369 
  if (size <= 1024UL) 
                      #line 369 
                      return 10U;
  #line 370 
  if (size <= 2048UL) 
                      #line 370 
                      return 11U;
  #line 371 
  if (size <= 4096UL) 
                      #line 371 
                      return 12U;
  #line 372 
  if (size <= 8192UL) 
                      #line 372 
                      return 13U;
  #line 373 
  if (size <= 16384UL) 
                       #line 373 
                       return 14U;
  #line 374 
  if (size <= 32768UL) 
                       #line 374 
                       return 15U;
  #line 375 
  if (size <= 65536UL) 
                       #line 375 
                       return 16U;
  #line 376 
  if (size <= 131072UL) 
                        #line 376 
                        return 17U;
  #line 377 
  if (size <= 262144UL) 
                        #line 377 
                        return 18U;
  #line 378 
  if (size <= 524288UL) 
                        #line 378 
                        return 19U;
  #line 379 
  if (size <= 1048576UL) 
                         #line 379 
                         return 20U;
  #line 380 
  if (size <= 2097152UL) 
                         #line 380 
                         return 21U;
  #line 381 
  if (size <= 4194304UL) 
                         #line 381 
                         return 22U;
  #line 382 
  if (size <= 8388608UL) 
                         #line 382 
                         return 23U;
  #line 383 
  if (size <= 16777216UL) 
                          #line 383 
                          return 24U;
  #line 384 
  if (size <= 33554432UL) 
                          #line 384 
                          return 25U;
  #line 385 
  if (size <= 67108864UL) 
                          #line 385 
                          return 26U;
  #line 387 
  ldv_inline_asm();
  #line 388 
  ldv_inline_asm();
  #line 389 
  ldv_inline_asm();
  #line 386 
  ;
  #line 389 
  return 4294967295U;
}

#line 417 
#line 417 
void *__kmalloc_node(size_t, gfp_t, int);
#line 435 
#line 435 
void *kmem_cache_alloc_node_trace(struct kmem_cache *, gfp_t, int, size_t);
#line 564  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
__inline static void *kmalloc_node(size_t size, gfp_t flags, int node)
{
  #line 567 
  if (0 != 0 && size <= 8192UL) {
    #line 569 
    unsigned int i = kmalloc_index(size);
    #line 571 
    if (i == 0U) 
                 #line 572 
                 return (void *)16;
    #line 574 
    ;
    #line 574 
    ;
    #line 574 
    ;
    #line 574 
    ;
    #line 574 
    return kmem_cache_alloc_node_trace(kmalloc_caches[(unsigned int)kmalloc_type(flags)][i],
                                    flags,node,size);
  }
  #line 579 
  return __kmalloc_node(size,flags,node);
}

#line 607 
#line 465  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_lib.i.aux"
static void *kcalloc_0(size_t n, size_t size, gfp_t flags);
#line 668  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 486  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_lib.i.aux"
static void *kzalloc_0(size_t size, gfp_t flags);
#line 679  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
__inline static void *kzalloc_node(size_t size, gfp_t flags, int node)
{
  #line 681 
  return kmalloc_node(size,flags | 256U,node);
}

#line 1431  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
#line 1431 
void pci_disable_msi(struct pci_dev *);
#line 1436 
#line 1436 
int pci_enable_msi(struct pci_dev *);
#line 1437 
#line 1437 
int pci_enable_msix_range(struct pci_dev *, struct msix_entry *, int, int);
#line 494  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
#line 494 
bool napi_hash_del(struct napi_struct *);
#line 2111 
#line 2111 
int netdev_set_tc_queue(struct net_device *, u8, u16, u16);
#line 2234 
#line 2234 
void netif_napi_add(struct net_device *, struct napi_struct *, int (*)(struct napi_struct *, int ), int);
#line 2263 
#line 2263 
void netif_napi_del(struct napi_struct *);
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static bool ixgbe_cache_ring_dcb_sriov(struct ixgbe_adapter *adapter)
{
  #line 23 
  int i;
  #line 24 
  u16 reg_idx;
  #line 24 
  u16 pool;
  #line 20 
  struct ixgbe_ring_feature *fcoe = & adapter->ring_feature[4];
  #line 22 
  struct ixgbe_ring_feature *vmdq = & adapter->ring_feature[1];
  #line 25 
  u8 tcs = adapter->hw_tcs;
  #line 28 
  if ((unsigned int)tcs <= 1U) 
                               #line 29 
                               return (_Bool)0;
  #line 32 
  if (((unsigned long)adapter->flags & 8388608UL) == 0UL) 
                                                          #line 33 
                                                          return (_Bool)0;
  #line 36 
  reg_idx = (unsigned short)((int)vmdq->offset * (int)((unsigned short)(- ((int)vmdq->mask) & (int)vmdq->mask)));
  #line 37 
  i = 0;
  #line 37 
  pool = (unsigned short)0U;
  #line 37 
  while (adapter->num_rx_queues > i) {
    #line 39 
    if (((int)reg_idx & ~ ((int)vmdq->mask)) >= (int)tcs) {
      #line 40 
      pool = (u16)((int)pool + 1);
      #line 41 
      reg_idx = (unsigned short)(((unsigned int)((int)reg_idx - (int)vmdq->mask) + 65535U) & (unsigned int)vmdq->mask);
    }
    #line 43 
    (adapter->rx_ring[i])->reg_idx = (unsigned char)reg_idx;
    #line 44 
    if ((unsigned int)pool == 0U) 
                                  #line 44 
                                  (adapter->rx_ring[i])->netdev = adapter->netdev; else 
                                                                    #line 44 
                                                                    (adapter->rx_ring[i])->netdev = (struct net_device *)0;
    #line 37 
    i ++;
    #line 37 
    reg_idx = (u16)((int)reg_idx + 1);
  }
  #line 47 
  reg_idx = (unsigned short)((int)vmdq->offset * (int)((unsigned short)(- ((int)vmdq->mask) & (int)vmdq->mask)));
  #line 48 
  i = 0;
  #line 48 
  while (adapter->num_tx_queues > i) {
    #line 50 
    if (((int)reg_idx & ~ ((int)vmdq->mask)) >= (int)tcs) 
                                                          #line 51 
                                                          reg_idx = (unsigned short)(((unsigned int)((int)reg_idx - (int)vmdq->mask) + 65535U) & (unsigned int)vmdq->mask);
    #line 52 
    (adapter->tx_ring[i])->reg_idx = (unsigned char)reg_idx;
    #line 48 
    i ++;
    #line 48 
    reg_idx = (u16)((int)reg_idx + 1);
  }
  #line 57 
  if (((unsigned long)adapter->flags & 2097152UL) == 0UL) 
                                                          #line 58 
                                                          return (_Bool)1;
  #line 61 
  if ((int)fcoe->offset < (int)((unsigned short)tcs)) 
                                                      #line 62 
                                                      return (_Bool)1;
  #line 65 
  if ((unsigned int)fcoe->indices != 0U) {
    #line 66 
    u16 queues_per_pool = (unsigned short)(- ((int)vmdq->mask) & (int)vmdq->mask);
    #line 67 
    u8 fcoe_tc = ixgbe_fcoe_get_tc(adapter);
    #line 69 
    reg_idx = (unsigned short)(((int)vmdq->offset + (int)vmdq->indices) * (int)queues_per_pool);
    #line 70 
    i = (int)fcoe->offset;
    #line 70 
    while (adapter->num_rx_queues > i) {
      #line 71 
      reg_idx = (unsigned short)((int)((unsigned short)(((unsigned int)((int)reg_idx - (int)vmdq->mask) + 65535U) & (unsigned int)vmdq->mask)) + (int)((unsigned short)fcoe_tc));
      #line 72 
      (adapter->rx_ring[i])->reg_idx = (unsigned char)reg_idx;
      #line 73 
      (adapter->rx_ring[i])->netdev = adapter->netdev;
      #line 74 
      reg_idx = (u16)((int)reg_idx + 1);
      #line 70 
      i ++;
    }
    #line 77 
    reg_idx = (unsigned short)(((int)vmdq->offset + (int)vmdq->indices) * (int)queues_per_pool);
    #line 78 
    i = (int)fcoe->offset;
    #line 78 
    while (adapter->num_tx_queues > i) {
      #line 79 
      reg_idx = (unsigned short)((int)((unsigned short)(((unsigned int)((int)reg_idx - (int)vmdq->mask) + 65535U) & (unsigned int)vmdq->mask)) + (int)((unsigned short)fcoe_tc));
      #line 80 
      (adapter->tx_ring[i])->reg_idx = (unsigned char)reg_idx;
      #line 81 
      reg_idx = (u16)((int)reg_idx + 1);
      #line 78 
      i ++;
    }
  }
  #line 86 
  return (_Bool)1;
}

#line 90  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_get_first_reg_idx(struct ixgbe_adapter *adapter, u8 tc, unsigned int *tx, unsigned int *rx)
{
  #line 93 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 94 
  u8 num_tcs = adapter->hw_tcs;
  #line 96 
  *tx = 0U;
  #line 97 
  *rx = 0U;
  #line 99 
  switch ((unsigned int)hw->mac.type) {
    #line 100 
    case (unsigned int)1: 
                          #line 100 
    ;
    #line 102 
    *tx = (unsigned int)((int)tc << 2);
    #line 103 
    *rx = (unsigned int)((int)tc << 3);
    #line 104 
    break;
    #line 105 
    case (unsigned int)2: 
                          #line 105 
    ;
    #line 106 
    case (unsigned int)3: 
                          #line 106 
    ;
    #line 107 
    case (unsigned int)4: 
                          #line 107 
    ;
    #line 108 
    case (unsigned int)5: 
                          #line 108 
    ;
    #line 109 
    case (unsigned int)6: 
                          #line 109 
    ;
    #line 110 
    if ((unsigned int)num_tcs > 4U) {
      #line 116 
      *rx = (unsigned int)((int)tc << 4);
      #line 117 
      if ((unsigned int)tc <= 2U) 
                                  #line 118 
                                  *tx = (unsigned int)((int)tc << 5);
      else 
        #line 119 
        if ((unsigned int)tc <= 4U) 
                                    #line 120 
                                    *tx = (unsigned int)(((int)tc + 2) << 4); else 
                                                                    #line 122 
                                                                    *tx = (unsigned int)(((int)tc + 8) << 3);
    }
    else {
      #line 129 
      *rx = (unsigned int)((int)tc << 5);
      #line 130 
      if ((unsigned int)tc <= 1U) 
                                  #line 131 
                                  *tx = (unsigned int)((int)tc << 6); else 
                                                                    #line 133 
                                                                    *tx = (unsigned int)(((int)tc + 4) << 4);
    }
    #line 135 
    default: 
             #line 135 
    ;
    #line 136 
    break;
  }
  #line 138 
  return;
}

#line 147  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static bool ixgbe_cache_ring_dcb(struct ixgbe_adapter *adapter)
{
  #line 150 
  unsigned int tx_idx;
  #line 150 
  unsigned int rx_idx;
  #line 151 
  int tc;
  #line 151 
  int offset;
  #line 151 
  int rss_i;
  #line 151 
  int i;
  #line 149 
  u8 num_tcs = adapter->hw_tcs;
  #line 154 
  if ((unsigned int)num_tcs <= 1U) 
                                   #line 155 
                                   return (_Bool)0;
  #line 157 
  rss_i = (int)adapter->ring_feature[2].indices;
  #line 159 
  tc = 0;
  #line 159 
  offset = 0;
  #line 159 
  while ((int)num_tcs > tc) {
    #line 160 
    ixgbe_get_first_reg_idx(adapter,(unsigned char)((int)((unsigned char)tc)),& tx_idx,& rx_idx);
    #line 161 
    i = 0;
    #line 161 
    while (i < rss_i) {
      #line 162 
      (adapter->tx_ring[offset + i])->reg_idx = (unsigned char)tx_idx;
      #line 163 
      (adapter->rx_ring[offset + i])->reg_idx = (unsigned char)rx_idx;
      #line 164 
      (adapter->rx_ring[offset + i])->netdev = adapter->netdev;
      #line 165 
      (adapter->tx_ring[offset + i])->dcb_tc = (unsigned char)tc;
      #line 166 
      (adapter->rx_ring[offset + i])->dcb_tc = (unsigned char)tc;
      #line 161 
      i ++;
      #line 161 
      tx_idx ++;
      #line 161 
      rx_idx ++;
    }
    #line 159 
    tc ++;
    #line 159 
    offset += rss_i;
  }
  #line 170 
  return (_Bool)1;
}

#line 182  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static bool ixgbe_cache_ring_sriov(struct ixgbe_adapter *adapter)
{
  #line 189 
  u16 reg_idx;
  #line 189 
  u16 pool;
  #line 190 
  int i;
  #line 185 
  struct ixgbe_ring_feature *fcoe = & adapter->ring_feature[4];
  #line 187 
  struct ixgbe_ring_feature *vmdq = & adapter->ring_feature[1];
  #line 188 
  struct ixgbe_ring_feature *rss = & adapter->ring_feature[2];
  #line 193 
  if (((unsigned long)adapter->flags & 16384UL) == 0UL) 
                                                        #line 194 
                                                        return (_Bool)0;
  #line 197 
  pool = (unsigned short)0U;
  #line 198 
  reg_idx = (unsigned short)((int)vmdq->offset * (int)((unsigned short)(- ((int)vmdq->mask) & (int)vmdq->mask)));
  #line 199 
  i = 0;
  #line 199 
  while (adapter->num_rx_queues > i) {
    #line 202 
    if ((unsigned int)fcoe->offset != 0U && (int)fcoe->offset < i) 
                                                                   #line 203 
                                                                   break;
    #line 206 
    if (((int)reg_idx & ~ ((int)vmdq->mask)) >= (int)rss->indices) {
      #line 207 
      pool = (u16)((int)pool + 1);
      #line 208 
      reg_idx = (unsigned short)(((unsigned int)((int)reg_idx - (int)vmdq->mask) + 65535U) & (unsigned int)vmdq->mask);
    }
    #line 210 
    (adapter->rx_ring[i])->reg_idx = (unsigned char)reg_idx;
    #line 211 
    if ((unsigned int)pool == 0U) 
                                  #line 211 
                                  (adapter->rx_ring[i])->netdev = adapter->netdev; else 
                                                                    #line 211 
                                                                    (adapter->rx_ring[i])->netdev = (struct net_device *)0;
    #line 199 
    i ++;
    #line 199 
    reg_idx = (u16)((int)reg_idx + 1);
  }
  #line 216 
  while (adapter->num_rx_queues > i) {
    #line 217 
    (adapter->rx_ring[i])->reg_idx = (unsigned char)reg_idx;
    #line 218 
    (adapter->rx_ring[i])->netdev = adapter->netdev;
    #line 216 
    i ++;
    #line 216 
    reg_idx = (u16)((int)reg_idx + 1);
  }
  #line 222 
  reg_idx = (unsigned short)((int)vmdq->offset * (int)((unsigned short)(- ((int)vmdq->mask) & (int)vmdq->mask)));
  #line 223 
  i = 0;
  #line 223 
  while (adapter->num_tx_queues > i) {
    #line 226 
    if ((unsigned int)fcoe->offset != 0U && (int)fcoe->offset < i) 
                                                                   #line 227 
                                                                   break;
    #line 230 
    if (((int)rss->mask & (int)reg_idx) >= (int)rss->indices) 
                                                              #line 231 
                                                              reg_idx = (unsigned short)(((unsigned int)((int)reg_idx - (int)vmdq->mask) + 65535U) & (unsigned int)vmdq->mask);
    #line 232 
    (adapter->tx_ring[i])->reg_idx = (unsigned char)reg_idx;
    #line 223 
    i ++;
    #line 223 
    reg_idx = (u16)((int)reg_idx + 1);
  }
  #line 237 
  while (adapter->num_tx_queues > i) {
    #line 238 
    (adapter->tx_ring[i])->reg_idx = (unsigned char)reg_idx;
    #line 237 
    i ++;
    #line 237 
    reg_idx = (u16)((int)reg_idx + 1);
  }
  #line 242 
  return (_Bool)1;
}

#line 252  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static bool ixgbe_cache_ring_rss(struct ixgbe_adapter *adapter)
{
  #line 254 
  int i;
  #line 254 
  int reg_idx;
  #line 256 
  i = 0;
  #line 256 
  while (adapter->num_rx_queues > i) {
    #line 257 
    (adapter->rx_ring[i])->reg_idx = (unsigned char)i;
    #line 258 
    (adapter->rx_ring[i])->netdev = adapter->netdev;
    #line 256 
    i ++;
  }
  #line 260 
  i = 0;
  #line 260 
  reg_idx = 0;
  #line 260 
  while (adapter->num_tx_queues > i) {
    #line 261 
    (adapter->tx_ring[i])->reg_idx = (unsigned char)reg_idx;
    #line 260 
    i ++;
    #line 260 
    reg_idx ++;
  }
  #line 262 
  i = 0;
  #line 262 
  while (adapter->num_xdp_queues > i) {
    #line 263 
    (adapter->xdp_ring[i])->reg_idx = (unsigned char)reg_idx;
    #line 262 
    i ++;
    #line 262 
    reg_idx ++;
  }
  #line 265 
  return (_Bool)1;
}

#line 279  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_cache_ring_register(struct ixgbe_adapter *adapter)
{
  #line 282 
  (adapter->rx_ring[0])->reg_idx = (unsigned char)0U;
  #line 283 
  (adapter->tx_ring[0])->reg_idx = (unsigned char)0U;
  #line 286 
  if ((int)ixgbe_cache_ring_dcb_sriov(adapter) != 0) 
                                                     #line 287 
                                                     return;
  #line 289 
  if ((int)ixgbe_cache_ring_dcb(adapter) != 0) 
                                               #line 290 
                                               return;
  #line 293 
  if ((int)ixgbe_cache_ring_sriov(adapter) != 0) 
                                                 #line 294 
                                                 return;
  #line 296 
  ixgbe_cache_ring_rss(adapter);
  #line 297 
  return;
}

#line 299  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static int ixgbe_xdp_queues(struct ixgbe_adapter *adapter)
{
  #line 301 
  int tmp;
  #line 301 
  if (adapter->xdp_prog != (struct bpf_prog *)0) 
                                                 #line 301 
                                                 tmp = (int)nr_cpu_ids; else 
                                                                    #line 301 
                                                                    tmp = 0;
  #line 301 
  return tmp;
}

#line 321  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static bool ixgbe_set_dcb_sriov_queues(struct ixgbe_adapter *adapter)
{
  #line 340 
  unsigned short __UNIQUE_ID___x443;
  #line 340 
  int tmp;
  #line 323 
  int i;
  #line 324 
  u16 vmdq_i = adapter->ring_feature[1].limit;
  #line 325 
  u16 vmdq_m = (unsigned short)0U;
  #line 327 
  u16 fcoe_i = (unsigned short)0U;
  #line 329 
  u8 tcs = adapter->hw_tcs;
  #line 332 
  if ((unsigned int)tcs <= 1U) 
                               #line 333 
                               return (_Bool)0;
  #line 336 
  if (((unsigned long)adapter->flags & 8388608UL) == 0UL) 
                                                          #line 337 
                                                          return (_Bool)0;
  {
    #line 340 
    __UNIQUE_ID___x443 = vmdq_i;
    #line 340 
    unsigned short __UNIQUE_ID___y444 = (unsigned short)(64 / (int)tcs);
    #line 340 
    if ((int)__UNIQUE_ID___x443 < (int)__UNIQUE_ID___y444) 
                                                           #line 340 
                                                           tmp = (int)__UNIQUE_ID___x443; else 
                                                                    #line 340 
                                                                    tmp = (int)__UNIQUE_ID___y444;
    }
  #line 340 
  vmdq_i = (unsigned short)tmp;
  #line 343 
  vmdq_i = (unsigned short)((int)adapter->ring_feature[1].offset + (int)vmdq_i);
  #line 346 
  if ((unsigned int)tcs > 4U) {
    #line 347 
    unsigned short __UNIQUE_ID___x445;
    #line 347 
    int tmp_1;
    {
      #line 347 
      __UNIQUE_ID___x445 = vmdq_i;
      #line 347 
      unsigned short __UNIQUE_ID___y446 = (unsigned short)16U;
      #line 347 
      if ((int)__UNIQUE_ID___x445 < (int)__UNIQUE_ID___y446) 
                                                             #line 347 
                                                             tmp_1 = (int)__UNIQUE_ID___x445; else 
                                                                    #line 347 
                                                                    tmp_1 = (int)__UNIQUE_ID___y446;
      }
    #line 347 
    vmdq_i = (unsigned short)tmp_1;
    #line 348 
    vmdq_m = (unsigned short)120U;
  }
  else {
    #line 351 
    unsigned short __UNIQUE_ID___x447;
    #line 351 
    int tmp_3;
    {
      #line 351 
      __UNIQUE_ID___x447 = vmdq_i;
      #line 351 
      unsigned short __UNIQUE_ID___y448 = (unsigned short)32U;
      #line 351 
      if ((int)__UNIQUE_ID___x447 < (int)__UNIQUE_ID___y448) 
                                                             #line 351 
                                                             tmp_3 = (int)__UNIQUE_ID___x447; else 
                                                                    #line 351 
                                                                    tmp_3 = (int)__UNIQUE_ID___y448;
      }
    #line 351 
    vmdq_i = (unsigned short)tmp_3;
    #line 352 
    vmdq_m = (unsigned short)124U;
  }
  #line 357 
  fcoe_i = (unsigned short)((int)((unsigned short)(128 / (- ((int)vmdq_m) & (int)vmdq_m))) - (int)vmdq_i);
  #line 361 
  vmdq_i = (unsigned short)((int)vmdq_i - (int)adapter->ring_feature[1].offset);
  #line 364 
  adapter->ring_feature[1].indices = vmdq_i;
  #line 365 
  adapter->ring_feature[1].mask = vmdq_m;
  #line 371 
  adapter->ring_feature[2].indices = (unsigned short)1U;
  #line 372 
  adapter->ring_feature[2].mask = (unsigned short)0U;
  #line 375 
  adapter->flags &= 4294705151U;
  #line 377 
  adapter->num_rx_pools = (int)vmdq_i;
  #line 378 
  adapter->num_rx_queues_per_pool = (int)tcs;
  #line 380 
  adapter->num_tx_queues = (int)vmdq_i * (int)tcs;
  #line 381 
  adapter->num_xdp_queues = 0;
  #line 382 
  adapter->num_rx_queues = (int)vmdq_i * (int)tcs;
  #line 385 
  if (((unsigned long)adapter->flags & 2097152UL) != 0UL) {
    #line 391 
    unsigned short __UNIQUE_ID___x449;
    #line 391 
    int tmp_5;
    #line 386 
    struct ixgbe_ring_feature *fcoe;
    #line 388 
    fcoe = & adapter->ring_feature[4];
    {
      #line 391 
      __UNIQUE_ID___x449 = fcoe_i;
      #line 391 
      unsigned short __UNIQUE_ID___y450 = fcoe->limit;
      #line 391 
      if ((int)__UNIQUE_ID___x449 < (int)__UNIQUE_ID___y450) 
                                                             #line 391 
                                                             tmp_5 = (int)__UNIQUE_ID___x449; else 
                                                                    #line 391 
                                                                    tmp_5 = (int)__UNIQUE_ID___y450;
      }
    #line 391 
    fcoe_i = (unsigned short)tmp_5;
    #line 393 
    if ((unsigned int)fcoe_i != 0U) {
      #line 395 
      fcoe->indices = fcoe_i;
      #line 396 
      fcoe->offset = (unsigned short)((int)((unsigned short)tcs) * (int)vmdq_i);
      #line 399 
      adapter->num_tx_queues += (int)fcoe_i;
      #line 400 
      adapter->num_rx_queues += (int)fcoe_i;
    }
    else 
      #line 401 
      if ((unsigned int)tcs > 1U) {
        #line 403 
        fcoe->indices = (unsigned short)1U;
        #line 404 
        fcoe->offset = (unsigned short)ixgbe_fcoe_get_tc(adapter);
      }
      else {
        #line 406 
        adapter->flags &= 4292870143U;
        #line 408 
        fcoe->indices = (unsigned short)0U;
        #line 409 
        fcoe->offset = (unsigned short)0U;
      }
  }
  #line 415 
  i = 0;
  #line 415 
  while ((int)tcs > i) {
    #line 416 
    netdev_set_tc_queue(adapter->netdev,(unsigned char)((int)((unsigned char)i)),(unsigned short)1,(unsigned short)((int)((unsigned short)i)));
    #line 415 
    i ++;
  }
  #line 418 
  return (_Bool)1;
}

#line 421  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static bool ixgbe_set_dcb_queues(struct ixgbe_adapter *adapter)
{
  #line 453 
  int __UNIQUE_ID___x457;
  #line 453 
  int tmp_5;
  #line 424 
  struct ixgbe_ring_feature *f;
  #line 425 
  int rss_i;
  #line 425 
  int rss_m;
  #line 425 
  int i;
  #line 426 
  int tcs;
  #line 423 
  struct net_device *dev = adapter->netdev;
  #line 429 
  tcs = (int)adapter->hw_tcs;
  #line 432 
  if (tcs <= 1) 
                #line 433 
                return (_Bool)0;
  #line 436 
  rss_i = (int)(dev->num_tx_queues / (unsigned int)tcs);
  #line 437 
  if (adapter->hw.mac.type == (unsigned int)ixgbe_mac_82598EB) {
    #line 439 
    unsigned short __UNIQUE_ID___x451;
    #line 439 
    int tmp;
    {
      #line 439 
      __UNIQUE_ID___x451 = (unsigned short)rss_i;
      #line 439 
      unsigned short __UNIQUE_ID___y452 = (unsigned short)4U;
      #line 439 
      if ((int)__UNIQUE_ID___x451 < (int)__UNIQUE_ID___y452) 
                                                             #line 439 
                                                             tmp = (int)__UNIQUE_ID___x451; else 
                                                                    #line 439 
                                                                    tmp = (int)__UNIQUE_ID___y452;
      }
    #line 439 
    rss_i = tmp;
    #line 440 
    rss_m = 3;
  }
  else 
    #line 441 
    if (tcs > 4) {
      #line 443 
      unsigned short __UNIQUE_ID___x453;
      #line 443 
      int tmp_1;
      {
        #line 443 
        __UNIQUE_ID___x453 = (unsigned short)rss_i;
        #line 443 
        unsigned short __UNIQUE_ID___y454 = (unsigned short)8U;
        #line 443 
        if ((int)__UNIQUE_ID___x453 < (int)__UNIQUE_ID___y454) 
                                                               #line 443 
                                                               tmp_1 = (int)__UNIQUE_ID___x453; else 
                                                                    #line 443 
                                                                    tmp_1 = (int)__UNIQUE_ID___y454;
        }
      #line 443 
      rss_i = tmp_1;
      #line 444 
      rss_m = 7;
    }
    else {
      #line 447 
      unsigned short __UNIQUE_ID___x455;
      #line 447 
      int tmp_3;
      {
        #line 447 
        __UNIQUE_ID___x455 = (unsigned short)rss_i;
        #line 447 
        unsigned short __UNIQUE_ID___y456 = (unsigned short)16U;
        #line 447 
        if ((int)__UNIQUE_ID___x455 < (int)__UNIQUE_ID___y456) 
                                                               #line 447 
                                                               tmp_3 = (int)__UNIQUE_ID___x455; else 
                                                                    #line 447 
                                                                    tmp_3 = (int)__UNIQUE_ID___y456;
        }
      #line 447 
      rss_i = tmp_3;
      #line 448 
      rss_m = 15;
    }
  #line 452 
  f = & adapter->ring_feature[2];
  {
    #line 453 
    __UNIQUE_ID___x457 = rss_i;
    #line 453 
    int __UNIQUE_ID___y458 = (int)f->limit;
    #line 453 
    if (__UNIQUE_ID___x457 < __UNIQUE_ID___y458) 
                                                 #line 453 
                                                 tmp_5 = __UNIQUE_ID___x457; else 
                                                                    #line 453 
                                                                    tmp_5 = __UNIQUE_ID___y458;
    }
  #line 453 
  rss_i = tmp_5;
  #line 454 
  f->indices = (unsigned short)rss_i;
  #line 455 
  f->mask = (unsigned short)rss_m;
  #line 458 
  adapter->flags &= 4294705151U;
  #line 466 
  if (((unsigned long)adapter->flags & 2097152UL) != 0UL) {
    #line 470 
    unsigned short __UNIQUE_ID___x459;
    #line 470 
    int tmp_8;
    #line 467 
    u8 tc = ixgbe_fcoe_get_tc(adapter);
    #line 469 
    f = & adapter->ring_feature[4];
    {
      #line 470 
      __UNIQUE_ID___x459 = (unsigned short)rss_i;
      #line 470 
      unsigned short __UNIQUE_ID___y460 = f->limit;
      #line 470 
      if ((int)__UNIQUE_ID___x459 < (int)__UNIQUE_ID___y460) 
                                                             #line 470 
                                                             tmp_8 = (int)__UNIQUE_ID___x459; else 
                                                                    #line 470 
                                                                    tmp_8 = (int)__UNIQUE_ID___y460;
      }
    #line 470 
    f->indices = (unsigned short)tmp_8;
    #line 471 
    f->offset = (unsigned short)((int)((unsigned short)tc) * (int)((unsigned short)rss_i));
  }
  #line 475 
  i = 0;
  #line 475 
  while (i < tcs) {
    #line 476 
    netdev_set_tc_queue(dev,(unsigned char)((int)((unsigned char)i)),(unsigned short)((int)((unsigned short)rss_i)),(unsigned short)((int)((unsigned short)rss_i) * (int)((unsigned short)i)));
    #line 475 
    i ++;
  }
  #line 478 
  adapter->num_tx_queues = rss_i * tcs;
  #line 479 
  adapter->num_xdp_queues = 0;
  #line 480 
  adapter->num_rx_queues = rss_i * tcs;
  #line 482 
  return (_Bool)1;
}

#line 495  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static bool ixgbe_set_sriov_queues(struct ixgbe_adapter *adapter)
{
  #line 510 
  unsigned short __UNIQUE_ID___x461;
  #line 510 
  int tmp;
  #line 516 
  unsigned short __UNIQUE_ID___x463;
  #line 516 
  int tmp_1;
  #line 497 
  u16 vmdq_i = adapter->ring_feature[1].limit;
  #line 498 
  u16 vmdq_m = (unsigned short)0U;
  #line 499 
  u16 rss_i = adapter->ring_feature[2].limit;
  #line 500 
  u16 rss_m = (unsigned short)0U;
  #line 502 
  u16 fcoe_i = (unsigned short)0U;
  #line 506 
  if (((unsigned long)adapter->flags & 8388608UL) == 0UL) 
                                                          #line 507 
                                                          return (_Bool)0;
  {
    #line 510 
    __UNIQUE_ID___x461 = rss_i;
    #line 510 
    unsigned short __UNIQUE_ID___y462 = (unsigned short)(64 / (int)vmdq_i);
    #line 510 
    if ((int)__UNIQUE_ID___x461 < (int)__UNIQUE_ID___y462) 
                                                           #line 510 
                                                           tmp = (int)__UNIQUE_ID___x461; else 
                                                                    #line 510 
                                                                    tmp = (int)__UNIQUE_ID___y462;
    }
  #line 510 
  rss_i = (unsigned short)tmp;
  #line 513 
  vmdq_i = (unsigned short)((int)adapter->ring_feature[1].offset + (int)vmdq_i);
  {
    #line 516 
    __UNIQUE_ID___x463 = (unsigned short)64U;
    #line 516 
    unsigned short __UNIQUE_ID___y464 = vmdq_i;
    #line 516 
    if ((int)__UNIQUE_ID___x463 < (int)__UNIQUE_ID___y464) 
                                                           #line 516 
                                                           tmp_1 = (int)__UNIQUE_ID___x463; else 
                                                                    #line 516 
                                                                    tmp_1 = (int)__UNIQUE_ID___y464;
    }
  #line 516 
  vmdq_i = (unsigned short)tmp_1;
  #line 519 
  if ((unsigned int)vmdq_i > 32U) {
    #line 522 
    int tmp_3;
    #line 522 
    unsigned short __UNIQUE_ID___x465;
    #line 520 
    vmdq_m = (unsigned short)126U;
    #line 521 
    rss_m = (unsigned short)1U;
    {
      #line 522 
      __UNIQUE_ID___x465 = rss_i;
      #line 522 
      unsigned short __UNIQUE_ID___y466 = (unsigned short)2U;
      #line 522 
      if ((int)__UNIQUE_ID___x465 < (int)__UNIQUE_ID___y466) 
                                                             #line 522 
                                                             tmp_3 = (int)__UNIQUE_ID___x465; else 
                                                                    #line 522 
                                                                    tmp_3 = (int)__UNIQUE_ID___y466;
      }
    #line 522 
    rss_i = (unsigned short)tmp_3;
  }
  else {
    #line 525 
    vmdq_m = (unsigned short)124U;
    #line 526 
    rss_m = (unsigned short)3U;
    #line 528 
    if ((unsigned int)rss_i <= 3U) {
      #line 528 
      unsigned int tmp_5;
      #line 528 
      if ((unsigned int)rss_i > 1U) 
                                    #line 528 
                                    tmp_5 = 2U; else 
                                                     #line 528 
                                                     tmp_5 = 1U;
      #line 528 
      rss_i = (unsigned short)tmp_5;
    }
    else 
         #line 528 
         rss_i = (unsigned short)4U;
  }
  #line 533 
  fcoe_i = (unsigned short)(128U - (unsigned int)((int)((unsigned short)(- ((int)vmdq_m) & (int)vmdq_m)) * (int)vmdq_i));
  #line 537 
  vmdq_i = (unsigned short)((int)vmdq_i - (int)adapter->ring_feature[1].offset);
  #line 540 
  adapter->ring_feature[1].indices = vmdq_i;
  #line 541 
  adapter->ring_feature[1].mask = vmdq_m;
  #line 544 
  adapter->ring_feature[2].indices = rss_i;
  #line 545 
  adapter->ring_feature[2].mask = rss_m;
  #line 547 
  adapter->num_rx_pools = (int)vmdq_i;
  #line 548 
  adapter->num_rx_queues_per_pool = (int)rss_i;
  #line 550 
  adapter->num_rx_queues = (int)vmdq_i * (int)rss_i;
  #line 551 
  adapter->num_tx_queues = (int)vmdq_i * (int)rss_i;
  #line 552 
  adapter->num_xdp_queues = 0;
  #line 555 
  adapter->flags &= 4294705151U;
  #line 563 
  if (((unsigned long)adapter->flags & 2097152UL) != 0UL) {
    #line 569 
    unsigned short __UNIQUE_ID___x467;
    #line 569 
    int tmp_6;
    #line 564 
    struct ixgbe_ring_feature *fcoe;
    #line 566 
    fcoe = & adapter->ring_feature[4];
    {
      #line 569 
      __UNIQUE_ID___x467 = fcoe_i;
      #line 569 
      unsigned short __UNIQUE_ID___y468 = fcoe->limit;
      #line 569 
      if ((int)__UNIQUE_ID___x467 < (int)__UNIQUE_ID___y468) 
                                                             #line 569 
                                                             tmp_6 = (int)__UNIQUE_ID___x467; else 
                                                                    #line 569 
                                                                    tmp_6 = (int)__UNIQUE_ID___y468;
      }
    #line 569 
    fcoe_i = (unsigned short)tmp_6;
    #line 571 
    if ((unsigned int)vmdq_i > 1U && (unsigned int)fcoe_i != 0U) {
      #line 573 
      fcoe->indices = fcoe_i;
      #line 574 
      fcoe->offset = (unsigned short)((int)vmdq_i * (int)rss_i);
    }
    else {
      #line 577 
      unsigned short __UNIQUE_ID___x469;
      #line 577 
      int tmp_9;
      #line 584 
      unsigned short __UNIQUE_ID___x471;
      #line 584 
      int tmp_11;
      {
        #line 577 
        __UNIQUE_ID___x469 = (unsigned short)((int)fcoe_i + (int)rss_i);
        #line 577 
        unsigned short __UNIQUE_ID___y470 = (unsigned short)num_online_cpus_0();
        #line 577 
        if ((int)__UNIQUE_ID___x469 < (int)__UNIQUE_ID___y470) 
                                                               #line 577 
                                                               tmp_9 = (int)__UNIQUE_ID___x469; else 
                                                                    #line 577 
                                                                    tmp_9 = (int)__UNIQUE_ID___y470;
        }
      #line 577 
      fcoe_i = (unsigned short)tmp_9;
      #line 580 
      if (((unsigned long)adapter->flags & 8UL) == 0UL) 
                                                        #line 581 
                                                        fcoe_i = rss_i;
      {
        #line 584 
        __UNIQUE_ID___x471 = fcoe_i;
        #line 584 
        unsigned short __UNIQUE_ID___y472 = fcoe->limit;
        #line 584 
        if ((int)__UNIQUE_ID___x471 < (int)__UNIQUE_ID___y472) 
                                                               #line 584 
                                                               tmp_11 = (int)__UNIQUE_ID___x471; else 
                                                                    #line 584 
                                                                    tmp_11 = (int)__UNIQUE_ID___y472;
        }
      #line 584 
      fcoe->indices = (unsigned short)tmp_11;
      #line 585 
      fcoe->offset = (unsigned short)((int)fcoe_i - (int)fcoe->indices);
      #line 587 
      fcoe_i = (unsigned short)((int)fcoe_i - (int)rss_i);
    }
    #line 591 
    adapter->num_tx_queues += (int)fcoe_i;
    #line 592 
    adapter->num_rx_queues += (int)fcoe_i;
  }
  #line 601 
  if ((unsigned int)vmdq_i > 1U) 
                                 #line 602 
                                 netdev_set_num_tc(adapter->netdev,(unsigned char)1);
  #line 605 
  netdev_set_tc_queue(adapter->netdev,(unsigned char)0,(unsigned short)((int)((unsigned short)adapter->num_rx_queues_per_pool)),(unsigned short)0);
  #line 608 
  return (_Bool)1;
}

#line 619  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static bool ixgbe_set_rss_queues(struct ixgbe_adapter *adapter)
{
  #line 622 
  struct ixgbe_ring_feature *f;
  #line 623 
  u16 rss_i;
  #line 621 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 626 
  f = & adapter->ring_feature[2];
  #line 627 
  rss_i = f->limit;
  #line 629 
  f->indices = rss_i;
  #line 631 
  if (hw->mac.type <= (unsigned int)ixgbe_mac_X540) 
                                                    #line 632 
                                                    f->mask = (unsigned short)15U; else 
                                                                    #line 634 
                                                                    f->mask = (unsigned short)63U;
  #line 637 
  adapter->flags &= 4294705151U;
  #line 644 
  if ((unsigned int)rss_i > 1U && adapter->atr_sample_rate != 0U) {
    #line 645 
    f = & adapter->ring_feature[3];
    #line 647 
    f->indices = (f->limit);
    #line 647 
    rss_i = (f->limit);
    #line 649 
    if (((unsigned long)adapter->flags & 524288UL) == 0UL) 
                                                           #line 650 
                                                           adapter->flags |= 262144U;
  }
  #line 662 
  if (((unsigned long)adapter->flags & 2097152UL) != 0UL) {
    #line 670 
    int tmp_3;
    #line 677 
    unsigned short __UNIQUE_ID___x477;
    #line 677 
    int tmp_5;
    #line 679 
    unsigned short __UNIQUE_ID___x479;
    #line 679 
    int tmp_7;
    #line 669 
    unsigned short __UNIQUE_ID___x473;
    #line 669 
    int tmp_1;
    #line 670 
    unsigned short __UNIQUE_ID___x475;
    #line 664 
    u16 fcoe_i;
    #line 663 
    struct net_device *dev = adapter->netdev;
    #line 666 
    f = & adapter->ring_feature[4];
    {
      #line 669 
      __UNIQUE_ID___x473 = (unsigned short)((int)f->limit + (int)rss_i);
      #line 669 
      unsigned short __UNIQUE_ID___y474 = (unsigned short)num_online_cpus_0();
      #line 669 
      if ((int)__UNIQUE_ID___x473 < (int)__UNIQUE_ID___y474) 
                                                             #line 669 
                                                             tmp_1 = (int)__UNIQUE_ID___x473; else 
                                                                    #line 669 
                                                                    tmp_1 = (int)__UNIQUE_ID___y474;
      }
    #line 669 
    fcoe_i = (unsigned short)tmp_1;
    {
      #line 670 
      __UNIQUE_ID___x475 = fcoe_i;
      #line 670 
      unsigned short __UNIQUE_ID___y476 = (unsigned short)dev->num_tx_queues;
      #line 670 
      if ((int)__UNIQUE_ID___x475 < (int)__UNIQUE_ID___y476) 
                                                             #line 670 
                                                             tmp_3 = (int)__UNIQUE_ID___x475; else 
                                                                    #line 670 
                                                                    tmp_3 = (int)__UNIQUE_ID___y476;
      }
    #line 670 
    fcoe_i = (unsigned short)tmp_3;
    #line 673 
    if (((unsigned long)adapter->flags & 8UL) == 0UL) 
                                                      #line 674 
                                                      fcoe_i = rss_i;
    {
      #line 677 
      __UNIQUE_ID___x477 = fcoe_i;
      #line 677 
      unsigned short __UNIQUE_ID___y478 = f->limit;
      #line 677 
      if ((int)__UNIQUE_ID___x477 < (int)__UNIQUE_ID___y478) 
                                                             #line 677 
                                                             tmp_5 = (int)__UNIQUE_ID___x477; else 
                                                                    #line 677 
                                                                    tmp_5 = (int)__UNIQUE_ID___y478;
      }
    #line 677 
    f->indices = (unsigned short)tmp_5;
    #line 678 
    f->offset = (unsigned short)((int)fcoe_i - (int)f->indices);
    {
      #line 679 
      __UNIQUE_ID___x479 = fcoe_i;
      #line 679 
      unsigned short __UNIQUE_ID___y480 = rss_i;
      #line 679 
      if ((int)__UNIQUE_ID___x479 > (int)__UNIQUE_ID___y480) 
                                                             #line 679 
                                                             tmp_7 = (int)__UNIQUE_ID___x479; else 
                                                                    #line 679 
                                                                    tmp_7 = (int)__UNIQUE_ID___y480;
      }
    #line 679 
    rss_i = (unsigned short)tmp_7;
  }
  #line 683 
  adapter->num_rx_queues = (int)rss_i;
  #line 684 
  adapter->num_tx_queues = (int)rss_i;
  #line 685 
  adapter->num_xdp_queues = ixgbe_xdp_queues(adapter);
  #line 687 
  return (_Bool)1;
}

#line 701  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_set_num_queues(struct ixgbe_adapter *adapter)
{
  #line 704 
  adapter->num_rx_queues = 1;
  #line 705 
  adapter->num_tx_queues = 1;
  #line 706 
  adapter->num_xdp_queues = 0;
  #line 707 
  adapter->num_rx_pools = 1;
  #line 708 
  adapter->num_rx_queues_per_pool = 1;
  #line 711 
  if ((int)ixgbe_set_dcb_sriov_queues(adapter) != 0) 
                                                     #line 712 
                                                     return;
  #line 714 
  if ((int)ixgbe_set_dcb_queues(adapter) != 0) 
                                               #line 715 
                                               return;
  #line 718 
  if ((int)ixgbe_set_sriov_queues(adapter) != 0) 
                                                 #line 719 
                                                 return;
  #line 721 
  ixgbe_set_rss_queues(adapter);
  #line 722 
  return;
}

#line 732  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static int ixgbe_acquire_msix_vectors(struct ixgbe_adapter *adapter)
{
  #line 748 
  int __UNIQUE_ID___x485;
  #line 748 
  int tmp_4;
  #line 759 
  int __UNIQUE_ID___x487;
  #line 759 
  int tmp_6;
  #line 740 
  int __UNIQUE_ID___x481;
  #line 801 
  int __UNIQUE_ID___x489;
  #line 740 
  int tmp;
  #line 801 
  int tmp_9;
  #line 741 
  int __UNIQUE_ID___x483;
  #line 741 
  int tmp_1;
  #line 735 
  int i;
  #line 735 
  int vectors;
  #line 735 
  int vector_threshold;
  #line 734 
  struct ixgbe_hw *hw = & adapter->hw;
  {
    #line 740 
    __UNIQUE_ID___x481 = adapter->num_rx_queues;
    #line 740 
    int __UNIQUE_ID___y482 = adapter->num_tx_queues;
    #line 740 
    if (__UNIQUE_ID___x481 > __UNIQUE_ID___y482) 
                                                 #line 740 
                                                 tmp = __UNIQUE_ID___x481; else 
                                                                    #line 740 
                                                                    tmp = __UNIQUE_ID___y482;
    }
  #line 740 
  vectors = tmp;
  {
    #line 741 
    __UNIQUE_ID___x483 = vectors;
    #line 741 
    int __UNIQUE_ID___y484 = adapter->num_xdp_queues;
    #line 741 
    if (__UNIQUE_ID___x483 > __UNIQUE_ID___y484) 
                                                 #line 741 
                                                 tmp_1 = __UNIQUE_ID___x483; else 
                                                                    #line 741 
                                                                    tmp_1 = __UNIQUE_ID___y484;
    }
  #line 741 
  vectors = tmp_1;
  {
    #line 748 
    __UNIQUE_ID___x485 = vectors;
    #line 748 
    int __UNIQUE_ID___y486 = (int)num_online_cpus_0();
    #line 748 
    if (__UNIQUE_ID___x485 < __UNIQUE_ID___y486) 
                                                 #line 748 
                                                 tmp_4 = __UNIQUE_ID___x485; else 
                                                                    #line 748 
                                                                    tmp_4 = __UNIQUE_ID___y486;
    }
  #line 748 
  vectors = tmp_4;
  #line 751 
  vectors ++;
  {
    #line 759 
    __UNIQUE_ID___x487 = vectors;
    #line 759 
    int __UNIQUE_ID___y488 = (int)hw->mac.max_msix_vectors;
    #line 759 
    if (__UNIQUE_ID___x487 < __UNIQUE_ID___y488) 
                                                 #line 759 
                                                 tmp_6 = __UNIQUE_ID___x487; else 
                                                                    #line 759 
                                                                    tmp_6 = __UNIQUE_ID___y488;
    }
  #line 759 
  vectors = tmp_6;
  #line 764 
  vector_threshold = 2;
  #line 766 
  adapter->msix_entries = (struct msix_entry *)kcalloc_0((unsigned long)vectors,8UL,3264U);
  #line 769 
  if (adapter->msix_entries == (struct msix_entry *)0) 
                                                       #line 770 
                                                       return -12;
  #line 772 
  i = 0;
  #line 772 
  while (i < vectors) {
    #line 773 
    (adapter->msix_entries + (unsigned long)i)->entry = (unsigned short)i;
    #line 772 
    i ++;
  }
  #line 775 
  vectors = pci_enable_msix_range(adapter->pdev,adapter->msix_entries,vector_threshold,vectors);
  #line 778 
  if (vectors < 0) {
    #line 782 
    _dev_warn(& (adapter->pdev)->dev,(char *)"Failed to allocate MSI-X interrupts. Err: %d\n",vectors);
    #line 785 
    adapter->flags &= 4294967287U;
    #line 786 
    kfree((void *)adapter->msix_entries);
    #line 787 
    adapter->msix_entries = (struct msix_entry *)0;
    #line 789 
    return vectors;
  }
  #line 795 
  adapter->flags |= 8U;
  #line 800 
  vectors += -1;
  {
    #line 801 
    __UNIQUE_ID___x489 = vectors;
    #line 801 
    int __UNIQUE_ID___y490 = adapter->max_q_vectors;
    #line 801 
    if (__UNIQUE_ID___x489 < __UNIQUE_ID___y490) 
                                                 #line 801 
                                                 tmp_9 = __UNIQUE_ID___x489; else 
                                                                    #line 801 
                                                                    tmp_9 = __UNIQUE_ID___y490;
    }
  #line 801 
  adapter->num_q_vectors = tmp_9;
  #line 803 
  return 0;
}

#line 806  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_add_ring(struct ixgbe_ring *ring, struct ixgbe_ring_container *head)
{
  #line 809 
  ring->next = head->ring;
  #line 810 
  head->ring = ring;
  #line 811 
  head->count = (u8)((int)head->count + 1);
  #line 812 
  head->next_update = jiffies + 1UL;
  #line 813 
  return;
}

#line 829  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static int ixgbe_alloc_q_vector(struct ixgbe_adapter *adapter, int v_count, int v_idx, int txr_count, int txr_idx, int xdp_count, int xdp_idx, int rxr_count, int rxr_idx)
{
  #line 836 
  struct ixgbe_q_vector *q_vector;
  #line 837 
  struct ixgbe_ring *ring;
  #line 839 
  int ring_count;
  #line 835 
  int node = dev_to_node(& (adapter->pdev)->dev);
  #line 838 
  int cpu = -1;
  #line 840 
  u8 tcs = adapter->hw_tcs;
  #line 842 
  ring_count = (txr_count + rxr_count) + xdp_count;
  #line 845 
  if ((unsigned int)tcs <= 1U && ((unsigned long)adapter->flags & 8388608UL) == 0UL) {
    #line 846 
    u16 rss_i = adapter->ring_feature[2].indices;
    #line 847 
    if ((unsigned int)rss_i > 1U && adapter->atr_sample_rate != 0U) {
      #line 848 
      cpu = (int)cpumask_local_spread((unsigned int)v_idx,node);
      #line 849 
      node = __cpu_to_node(cpu);
    }
  }
  #line 854 
  ;
  #line 854 
  q_vector = (struct ixgbe_q_vector *)kzalloc_node(__ab_c_size((unsigned long)ring_count,4096UL,4096UL),
                     3264U,node);
  #line 856 
  if (q_vector == (struct ixgbe_q_vector *)0) {
    #line 857 
    q_vector = (struct ixgbe_q_vector *)kzalloc_0(__ab_c_size((unsigned long)ring_count,4096UL,4096UL),3264U);
  }
  #line 859 
  if (q_vector == (struct ixgbe_q_vector *)0) 
                                              #line 860 
                                              return -12;
  #line 863 
  if (cpu != -1) 
                 #line 864 
                 cpumask_set_cpu((unsigned int)cpu,& q_vector->affinity_mask);
  #line 865 
  q_vector->numa_node = node;
  #line 869 
  q_vector->cpu = -1;
  #line 873 
  netif_napi_add(adapter->netdev,& q_vector->napi,& ixgbe_poll,64);
  #line 877 
  adapter->q_vector[v_idx] = q_vector;
  #line 878 
  q_vector->adapter = adapter;
  #line 879 
  q_vector->v_idx = (unsigned short)v_idx;
  #line 882 
  q_vector->tx.work_limit = adapter->tx_work_limit;
  #line 885 
  q_vector->tx.itr = (unsigned char)254U;
  #line 887 
  q_vector->rx.itr = (unsigned char)254U;
  #line 891 
  if (txr_count != 0 && rxr_count == 0) 
    #line 893 
    if ((unsigned int)adapter->tx_itr_setting == 1U) 
                                                     #line 894 
                                                     q_vector->itr = (unsigned short)336U; else 
                                                                    #line 896 
                                                                    q_vector->itr = adapter->tx_itr_setting;
  else 
    #line 899 
    if ((unsigned int)adapter->rx_itr_setting == 1U) 
                                                     #line 900 
                                                     q_vector->itr = (unsigned short)200U; else 
                                                                    #line 902 
                                                                    q_vector->itr = adapter->rx_itr_setting;
  #line 906 
  ring = (struct ixgbe_ring *)(& q_vector->ring);
  #line 908 
  while (txr_count != 0) {
    #line 910 
    ring->dev = & (adapter->pdev)->dev;
    #line 911 
    ring->netdev = adapter->netdev;
    #line 914 
    ring->q_vector = q_vector;
    #line 917 
    ixgbe_add_ring(ring,& q_vector->tx);
    #line 920 
    ring->count = (unsigned short)adapter->tx_ring_count;
    #line 921 
    ring->queue_index = (unsigned char)txr_idx;
    #line 924 
    adapter->tx_ring[txr_idx] = ring;
    #line 927 
    txr_count --;
    #line 928 
    txr_idx += v_count;
    #line 931 
    ring ++;
  }
  #line 934 
  while (xdp_count != 0) {
    #line 936 
    ring->dev = & (adapter->pdev)->dev;
    #line 937 
    ring->netdev = adapter->netdev;
    #line 940 
    ring->q_vector = q_vector;
    #line 943 
    ixgbe_add_ring(ring,& q_vector->tx);
    #line 946 
    ring->count = (unsigned short)adapter->tx_ring_count;
    #line 947 
    ring->queue_index = (unsigned char)xdp_idx;
    #line 948 
    cif_set_bit_0(9L,& ring->state);
    #line 951 
    adapter->xdp_ring[xdp_idx] = ring;
    #line 954 
    xdp_count --;
    #line 955 
    xdp_idx ++;
    #line 958 
    ring ++;
  }
  #line 961 
  while (rxr_count != 0) {
    #line 963 
    ring->dev = & (adapter->pdev)->dev;
    #line 964 
    ring->netdev = adapter->netdev;
    #line 967 
    ring->q_vector = q_vector;
    #line 970 
    ixgbe_add_ring(ring,& q_vector->rx);
    #line 976 
    if (adapter->hw.mac.type == (unsigned int)ixgbe_mac_82599EB) 
                                                                 #line 977 
                                                                 cif_set_bit_0(3L,& ring->state);
    #line 980 
    if (((adapter->netdev)->features & 68719476736ULL) != 0ULL) {
      #line 981 
      struct ixgbe_ring_feature *f;
      #line 982 
      f = & adapter->ring_feature[4];
      #line 983 
      if ((int)f->offset <= rxr_idx && (int)f->offset + (int)f->indices > rxr_idx) 
        #line 985 
        cif_set_bit_0(4L,& ring->state);
    }
    #line 990 
    ring->count = (unsigned short)adapter->rx_ring_count;
    #line 991 
    ring->queue_index = (unsigned char)rxr_idx;
    #line 994 
    adapter->rx_ring[rxr_idx] = ring;
    #line 997 
    rxr_count --;
    #line 998 
    rxr_idx += v_count;
    #line 1001 
    ring ++;
  }
  #line 1004 
  return 0;
}

#line 1016  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_free_q_vector(struct ixgbe_adapter *adapter, int v_idx)
{
  #line 1019 
  struct ixgbe_ring *ring;
  #line 1018 
  struct ixgbe_q_vector *q_vector = adapter->q_vector[v_idx];
  #line 1021 
  ring = q_vector->tx.ring;
  #line 1021 
  while (ring != (struct ixgbe_ring *)0) {
    #line 1022 
    if ((int)test_bit(9L,& ring->state) != 0) 
                                              #line 1023 
                                              adapter->xdp_ring[(int)ring->queue_index] = (struct ixgbe_ring *)0; else 
                                                                    #line 1025 
                                                                    adapter->tx_ring[(int)ring->queue_index] = (struct ixgbe_ring *)0;
    #line 1021 
    ring = ring->next;
  }
  #line 1028 
  ring = q_vector->rx.ring;
  #line 1028 
  while (ring != (struct ixgbe_ring *)0) {
    #line 1029 
    adapter->rx_ring[(int)ring->queue_index] = (struct ixgbe_ring *)0;
    #line 1028 
    ring = ring->next;
  }
  #line 1031 
  adapter->q_vector[v_idx] = (struct ixgbe_q_vector *)0;
  #line 1032 
  napi_hash_del(& q_vector->napi);
  #line 1033 
  netif_napi_del(& q_vector->napi);
  {
    #line 1039 
    struct ixgbe_q_vector *___p = q_vector;
    #line 1039 
    if (___p != (struct ixgbe_q_vector *)0) 
                                            #line 1039 
                                            kfree_call_rcu(& ___p->rcu,(void (*)(struct callback_head *))1504);
  }
  #line 1042 
  return;
}

#line 1049  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static int ixgbe_alloc_q_vectors(struct ixgbe_adapter *adapter)
{
  #line 1056 
  int err;
  #line 1056 
  int i;
  #line 1051 
  int q_vectors = adapter->num_q_vectors;
  #line 1052 
  int rxr_remaining = adapter->num_rx_queues;
  #line 1053 
  int txr_remaining = adapter->num_tx_queues;
  #line 1054 
  int xdp_remaining = adapter->num_xdp_queues;
  #line 1055 
  int rxr_idx = 0;
  #line 1055 
  int txr_idx = 0;
  #line 1055 
  int xdp_idx = 0;
  #line 1055 
  int v_idx = 0;
  #line 1059 
  if (((unsigned long)adapter->flags & 8UL) == 0UL) 
                                                    #line 1060 
                                                    q_vectors = 1;
  #line 1062 
  if ((rxr_remaining + txr_remaining) + xdp_remaining <= q_vectors) 
    #line 1063 
    while (rxr_remaining != 0) {
      #line 1064 
      err = ixgbe_alloc_q_vector(adapter,q_vectors,v_idx,0,0,0,0,1,rxr_idx);
      #line 1067 
      if (err != 0) 
                    #line 1068 
                    goto err_out;
      #line 1071 
      rxr_remaining --;
      #line 1072 
      rxr_idx ++;
      #line 1063 
      v_idx ++;
    }
  #line 1076 
  while (v_idx < q_vectors) {
    {
      #line 1077 
      int rqpv = (((q_vectors - v_idx) + rxr_remaining) + -1) / (q_vectors - v_idx);
      #line 1078 
      int tqpv = (((q_vectors - v_idx) + txr_remaining) + -1) / (q_vectors - v_idx);
      #line 1079 
      int xqpv = (((q_vectors - v_idx) + xdp_remaining) + -1) / (q_vectors - v_idx);
      #line 1081 
      err = ixgbe_alloc_q_vector(adapter,q_vectors,v_idx,tqpv,txr_idx,xqpv,xdp_idx,rqpv,rxr_idx);
      #line 1086 
      if (err != 0) 
                    #line 1087 
                    goto err_out;
      #line 1090 
      rxr_remaining -= rqpv;
      #line 1091 
      txr_remaining -= tqpv;
      #line 1092 
      xdp_remaining -= xqpv;
      #line 1093 
      rxr_idx ++;
      #line 1094 
      txr_idx ++;
      #line 1095 
      xdp_idx += xqpv;
    }
    #line 1076 
    v_idx ++;
  }
  #line 1098 
  i = 0;
  #line 1098 
  while (adapter->num_rx_queues > i) {
    #line 1099 
    if (adapter->rx_ring[i] != (struct ixgbe_ring *)0) 
                                                       #line 1100 
                                                       (adapter->rx_ring[i])->ring_idx = (unsigned short)i;
    #line 1098 
    i ++;
  }
  #line 1103 
  i = 0;
  #line 1103 
  while (adapter->num_tx_queues > i) {
    #line 1104 
    if (adapter->tx_ring[i] != (struct ixgbe_ring *)0) 
                                                       #line 1105 
                                                       (adapter->tx_ring[i])->ring_idx = (unsigned short)i;
    #line 1103 
    i ++;
  }
  #line 1108 
  i = 0;
  #line 1108 
  while (adapter->num_xdp_queues > i) {
    #line 1109 
    if (adapter->xdp_ring[i] != (struct ixgbe_ring *)0) 
                                                        #line 1110 
                                                        (adapter->xdp_ring[i])->ring_idx = (unsigned short)i;
    #line 1108 
    i ++;
  }
  #line 1113 
  return 0;
  #line 1115 
  err_out: 
           #line 1115 
  ;
  #line 1116 
  adapter->num_tx_queues = 0;
  #line 1117 
  adapter->num_xdp_queues = 0;
  #line 1118 
  adapter->num_rx_queues = 0;
  #line 1119 
  adapter->num_q_vectors = 0;
  #line 1121 
  while (1) {
    #line 1121 
    int tmp;
    #line 1121 
    tmp = v_idx;
    #line 1121 
    v_idx --;
    #line 1121 
    ;
    #line 1121 
    if (! (tmp != 0)) 
                      #line 1121 
                      break;
    #line 1122 
    ixgbe_free_q_vector(adapter,v_idx);
  }
  #line 1124 
  return -12;
}

#line 1135  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_free_q_vectors(struct ixgbe_adapter *adapter)
{
  #line 1137 
  int v_idx = adapter->num_q_vectors;
  #line 1139 
  adapter->num_tx_queues = 0;
  #line 1140 
  adapter->num_xdp_queues = 0;
  #line 1141 
  adapter->num_rx_queues = 0;
  #line 1142 
  adapter->num_q_vectors = 0;
  #line 1144 
  while (1) {
    #line 1144 
    int tmp;
    #line 1144 
    tmp = v_idx;
    #line 1144 
    v_idx --;
    #line 1144 
    ;
    #line 1144 
    if (! (tmp != 0)) 
                      #line 1144 
                      break;
    #line 1145 
    ixgbe_free_q_vector(adapter,v_idx);
  }
  #line 1146 
  return;
}

#line 1148  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_reset_interrupt_capability(struct ixgbe_adapter *adapter)
{
  #line 1150 
  if (((unsigned long)adapter->flags & 8UL) != 0UL) {
    #line 1151 
    adapter->flags &= 4294967287U;
    #line 1152 
    pci_disable_msix(adapter->pdev);
    #line 1153 
    kfree((void *)adapter->msix_entries);
    #line 1154 
    adapter->msix_entries = (struct msix_entry *)0;
  }
  else 
    #line 1155 
    if (((unsigned long)adapter->flags & 2UL) != 0UL) {
      #line 1156 
      adapter->flags &= 4294967293U;
      #line 1157 
      pci_disable_msi(adapter->pdev);
    }
  #line 1159 
  return;
}

#line 1168  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_set_interrupt_capability(struct ixgbe_adapter *adapter)
{
  #line 1170 
  int err;
  #line 1173 
  if (ixgbe_acquire_msix_vectors(adapter) == 0) 
                                                #line 1174 
                                                return;
  #line 1182 
  if ((unsigned int)adapter->hw_tcs > 1U) {
    #line 1183 
    _dev_warn(& (adapter->pdev)->dev,(char *)"Number of DCB TCs exceeds number of available queues. Disabling DCB support.\n");
    #line 1184 
    netdev_reset_tc(adapter->netdev);
    #line 1186 
    if (adapter->hw.mac.type == (unsigned int)ixgbe_mac_82598EB) 
                                                                 #line 1187 
                                                                 adapter->hw.fc.requested_mode = adapter->last_lfc_mode;
    #line 1189 
    adapter->flags &= 4294963199U;
    #line 1190 
    adapter->temp_dcb_cfg.pfc_mode_enable = (_Bool)0;
    #line 1191 
    adapter->dcb_cfg.pfc_mode_enable = (_Bool)0;
  }
  #line 1194 
  adapter->hw_tcs = (unsigned char)0U;
  #line 1195 
  adapter->dcb_cfg.num_tcs.pg_tcs = (unsigned char)1U;
  #line 1196 
  adapter->dcb_cfg.num_tcs.pfc_tcs = (unsigned char)1U;
  #line 1199 
  _dev_warn(& (adapter->pdev)->dev,(char *)"Disabling SR-IOV support\n");
  #line 1200 
  ixgbe_disable_sriov(adapter);
  #line 1203 
  _dev_warn(& (adapter->pdev)->dev,(char *)"Disabling RSS support\n");
  #line 1204 
  adapter->ring_feature[2].limit = (unsigned short)1U;
  #line 1209 
  ixgbe_set_num_queues(adapter);
  #line 1210 
  adapter->num_q_vectors = 1;
  #line 1212 
  err = pci_enable_msi(adapter->pdev);
  #line 1213 
  if (err != 0) 
                #line 1214 
                _dev_warn(& (adapter->pdev)->dev,(char *)"Failed to allocate MSI interrupt, falling back to legacy. Error: %d\n",err); else 
                                                                    #line 1217 
                                                                    adapter->flags |= 2U;
  #line 1218 
  return;
}

#line 1230  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
int ixgbe_init_interrupt_scheme(struct ixgbe_adapter *adapter)
{
  #line 1232 
  int err;
  #line 1248 
  char *tmp;
  #line 1235 
  ixgbe_set_num_queues(adapter);
  #line 1238 
  ixgbe_set_interrupt_capability(adapter);
  #line 1240 
  err = ixgbe_alloc_q_vectors(adapter);
  #line 1241 
  if (err != 0) {
    #line 1242 
    _dev_err(& (adapter->pdev)->dev,(char *)"Unable to allocate memory for queue vectors\n");
    #line 1243 
    goto err_alloc_q_vectors;
  }
  #line 1246 
  ixgbe_cache_ring_register(adapter);
  #line 1248 
  ;
  #line 1248 
  ;
  #line 1248 
  ;
  #line 1248 
  if (adapter->num_rx_queues > 1) 
                                  #line 1248 
                                  tmp = (char *)"Enabled"; else 
                                                                #line 1248 
                                                                tmp = (char *)"Disabled";
  #line 1248 
  ;
  #line 1248 
  _dev_info(& (adapter->pdev)->dev,(char *)"Multiqueue %s: Rx Queue count = %u, Tx Queue count = %u XDP Queue count = %u\n",tmp,adapter->num_rx_queues,adapter->num_tx_queues,adapter->num_xdp_queues);
  #line 1253 
  cif_set_bit_0(2L,& adapter->state);
  #line 1255 
  return 0;
  #line 1257 
  err_alloc_q_vectors: 
                       #line 1257 
  ;
  #line 1258 
  ixgbe_reset_interrupt_capability(adapter);
  #line 1259 
  return err;
}

#line 1269  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
void ixgbe_clear_interrupt_scheme(struct ixgbe_adapter *adapter)
{
  #line 1271 
  adapter->num_tx_queues = 0;
  #line 1272 
  adapter->num_xdp_queues = 0;
  #line 1273 
  adapter->num_rx_queues = 0;
  #line 1275 
  ixgbe_free_q_vectors(adapter);
  #line 1276 
  ixgbe_reset_interrupt_capability(adapter);
  #line 1277 
  return;
}

#line 1279  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
void ixgbe_tx_ctxtdesc(struct ixgbe_ring *tx_ring, u32 vlan_macip_lens, u32 fceof_saidx, u32 type_tucmd, u32 mss_l4len_idx)
{
  #line 1282 
  struct ixgbe_adv_tx_context_desc *context_desc;
  #line 1283 
  u16 i = tx_ring->next_to_use;
  #line 1285 
  context_desc = (struct ixgbe_adv_tx_context_desc *)tx_ring->desc + (unsigned long)i;
  #line 1287 
  i = (u16)((int)i + 1);
  #line 1288 
  if ((int)tx_ring->count > (int)i) 
                                    #line 1288 
                                    tx_ring->next_to_use = i; else 
                                                                   #line 1288 
                                                                   tx_ring->next_to_use = (unsigned short)0U;
  #line 1291 
  type_tucmd |= 538968064U;
  #line 1293 
  context_desc->vlan_macip_lens = vlan_macip_lens;
  #line 1294 
  context_desc->fceof_saidx = fceof_saidx;
  #line 1295 
  context_desc->type_tucmd_mlhl = type_tucmd;
  #line 1296 
  context_desc->mss_l4len_idx = mss_l4len_idx;
  #line 1297 
  return;
}

#line 121  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_lib.i.aux"
static void cif_set_bit_0(long nr, unsigned long *addr)
{
  #line 124 
  ldv_set_bit(nr,addr);
  #line 125 
  return;
}

#line 465  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_lib.i.aux"
static void *kcalloc_0(size_t n, size_t size, gfp_t flags)
{
  #line 468 
  return ldv_kcalloc(n,size,flags);
}

#line 486  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_lib.i.aux"
static void *kzalloc_0(size_t size, gfp_t flags)
{
  #line 489 
  return ldv_kzalloc(size,flags);
}

/* compiler builtin: 
   unsigned long __builtin_object_size(void *, int);   */
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
#line 121  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ptp.i.aux"
static void cif_set_bit_1(long nr, unsigned long *addr);
#line 26  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
#line 135  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ptp.i.aux"
static void INIT_LIST_HEAD_0(struct list_head *list);
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/math64.h"
__inline static u64 div_u64_rem(u64 dividend, u32 divisor, u32 *remainder)
{
  #line 26 
  *remainder = (unsigned int)(dividend % (unsigned long long)divisor);
  #line 27 
  return dividend / (unsigned long long)divisor;
}

#line 123  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/math64.h"
__inline static u64 div_u64(u64 dividend, u32 divisor)
{
  #line 125 
  u32 remainder;
  #line 126 
  return div_u64_rem(dividend,divisor,& remainder);
}

#line 133  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/time64.h"
__inline static s64 timespec64_to_ns(struct timespec64 *ts)
{
  #line 135 
  return ts->tv_sec * 1000000000LL + (long long)ts->tv_nsec;
}

#line 144 
#line 144 
struct timespec64 ns_to_timespec64(s64);
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/err.h"
#line 212  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ptp.i.aux"
static long PTR_ERR_0(void *ptr);
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/err.h"
#line 219  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ptp.i.aux"
static bool IS_ERR_0(void *ptr);
#line 39  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/err.h"
#line 226  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ptp.i.aux"
static bool IS_ERR_OR_NULL(void *ptr);
#line 112  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/thread_info.h"
#line 112 
void __check_object_size(void *, unsigned long, bool);
#line 115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/thread_info.h"
__inline static void check_object_size(void *ptr, unsigned long n, bool to_user)
{
  #line 118 
  if (0 == 0) 
              #line 119 
              __check_object_size(ptr,n,(_Bool)((bool)((int)to_user) != 0));
  #line 120 
  return;
}

#line 128 
#line 128 
void __bad_copy_from(void);
#line 130 
#line 130 
void __bad_copy_to(void);
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/thread_info.h"
__inline static void copy_overflow(int size, unsigned long count)
{
  #line 134 
  int __ret_warn_on = 1;
  #line 134 
  if ((long)(__ret_warn_on != 0) != 0L) {
    #line 134 
    __warn_printk((char *)"Buffer overflow detected (%d < %lu)!\n",size,count);
    #line 135 
    ldv_inline_asm();
    #line 136 
    ldv_inline_asm();
  }
  #line 134 
  long tmp = (long)(__ret_warn_on != 0);
  #line 136 
  return;
}

#line 138  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/thread_info.h"
__inline static bool check_copy_size(void *addr, size_t bytes, bool is_source)
{
  #line 150 
  int __ret_warn_on;
  #line 140 
  int sz = (int)__builtin_object_size(addr,0);
  #line 141 
  if ((long)(sz >= 0) != 0L && (long)((unsigned long)sz < bytes) != 0L) {
    #line 142 
    if (0 == 0) 
                #line 143 
                copy_overflow(sz,bytes);
    else 
      #line 144 
      if ((int)is_source != 0) 
                               #line 145 
                               __bad_copy_from(); else 
                                                       #line 147 
                                                       __bad_copy_to();
    #line 148 
    return (_Bool)0;
  }
  #line 150 
  __ret_warn_on = bytes > 2147483647UL;
  #line 150 
  if ((long)(__ret_warn_on != 0) != 0L) {
    #line 151 
    ldv_inline_asm();
    #line 152 
    ldv_inline_asm();
  }
  #line 150 
  if ((long)((long)(__ret_warn_on != 0)) != 0L) 
                                                #line 151 
                                                return (_Bool)0;
  #line 152 
  check_object_size(addr,bytes,(_Bool)((bool)((int)is_source) != 0));
  #line 153 
  return (_Bool)1;
}

#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_api_smp.h"
#line 43 
void _raw_spin_unlock_irqrestore(raw_spinlock_t *, unsigned long);
#line 391  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock.h"
static void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
  {
    #line 393 
    unsigned long __dummy;
    #line 393 
    unsigned long __dummy2;
    }
  #line 393 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_25.rlock,flags);
  #line 395 
  return;
}

#line 395 
#line 703  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ptp.i.aux"
static void cif_spin_unlock_irqrestore_tmreg_lock_of_ixgbe_adapter(spinlock_t *lock, unsigned long flags);
#line 33 
#line 33 
void __ldv_spin_lock(spinlock_t *);
#line 35 
#line 694 
static void cif___ldv_spin_lock_tmreg_lock_of_ixgbe_adapter(spinlock_t *lock);
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/err.h"
#line 24 
bool ldv_is_err_or_null(void *ptr);
#line 97  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ktime.h"
__inline static s64 ktime_to_ns(ktime_t kt)
{
  #line 99 
  return kt;
}

#line 265  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ktime.h"
__inline static ktime_t ns_to_ktime(u64 ns)
{
  #line 267 
  return (long long)ns;
}

#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timekeeping.h"
#line 43 
void ktime_get_real_ts64(struct timespec64 *);
#line 68 
#line 68 
ktime_t ktime_get_with_offset(enum tk_offsets);
#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timekeeping.h"
__inline static ktime_t ktime_get_real(void)
{
  #line 79 
  return ktime_get_with_offset((enum tk_offsets)TK_OFFS_REAL);
}

#line 554  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/workqueue.h"
#line 712  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ptp.i.aux"
static bool cif_schedule_work_0(struct work_struct *work);
#line 121  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uaccess.h"
#line 121 
unsigned long _copy_from_user(void *, void *, unsigned long);
#line 137 
#line 137 
unsigned long _copy_to_user(void *, void *, unsigned long);
#line 141  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uaccess.h"
__inline static unsigned long copy_from_user(void *to, void *from, unsigned long n)
{
  #line 143 
  if ((long)((int)check_copy_size(to,n,(_Bool)0) != 0) != 0L) 
                                                              #line 144 
                                                              n = _copy_from_user(to,from,n);
  #line 145 
  return n;
}

#line 149  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uaccess.h"
__inline static unsigned long copy_to_user(void *to, void *from, unsigned long n)
{
  #line 151 
  if ((long)((int)check_copy_size(from,n,(_Bool)1) != 0) != 0L) 
                                                                #line 152 
                                                                n = _copy_to_user(to,from,n);
  #line 153 
  return n;
}

#line 1405  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static struct skb_shared_hwtstamps *skb_hwtstamps(struct sk_buff *skb)
{
  #line 1407 
  return & ((struct skb_shared_info *)skb_end_pointer(skb))->hwtstamps;
}

#line 2156  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void skb_reset_tail_pointer(struct sk_buff *skb)
{
  #line 2158 
  skb->tail = (unsigned int)(skb->data - skb->head);
  #line 2159 
  return;
}

#line 2161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void skb_set_tail_pointer(struct sk_buff *skb, int offset)
{
  #line 2163 
  skb_reset_tail_pointer(skb);
  #line 2164 
  skb->tail += (unsigned int)offset;
  #line 2165 
  return;
}

#line 2637 
#line 2637 
int ___pskb_trim(struct sk_buff *, unsigned int);
#line 2639  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void __skb_set_length(struct sk_buff *skb, unsigned int len)
{
  #line 2641 
  int __ret_warn_on;
  {
    #line 2641 
    __ret_warn_on = (int)skb_is_nonlinear(skb) != 0;
    #line 2641 
    if ((long)(__ret_warn_on != 0) != 0L) {
      #line 2642 
      ldv_inline_asm();
      #line 2643 
      ldv_inline_asm();
    }
    }
  #line 2641 
  if ((long)((long)(__ret_warn_on != 0)) != 0L) 
                                                #line 2642 
                                                return;
  #line 2643 
  skb->len = len;
  #line 2644 
  skb_set_tail_pointer(skb,(int)len);
  #line 2645 
  return;
}

#line 2647  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void __skb_trim(struct sk_buff *skb, unsigned int len)
{
  #line 2649 
  __skb_set_length(skb,len);
  #line 2650 
  return;
}

#line 2654  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static int __pskb_trim(struct sk_buff *skb, unsigned int len)
{
  #line 2656 
  if (skb->data_len != 0U) {
    #line 2657 
    return ___pskb_trim(skb,len);
  }
  #line 2658 
  __skb_trim(skb,len);
  #line 2659 
  return 0;
}

#line 84  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timecounter.h"
__inline static void timecounter_adjtime(struct timecounter *tc, s64 delta)
{
  #line 86 
  tc->nsec += (unsigned long long)delta;
  #line 87 
  return;
}

#line 99 
#line 99 
void timecounter_init(struct timecounter *, struct cyclecounter *, u64);
#line 111 
#line 111 
u64 timecounter_read(struct timecounter *);
#line 127 
#line 127 
u64 timecounter_cyc2time(struct timecounter *, u64);
#line 186  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ptp_clock_kernel.h"
#line 186 
struct ptp_clock *ptp_clock_register(struct ptp_clock_info *, struct device *);
#line 195 
#line 195 
int ptp_clock_unregister(struct ptp_clock *);
#line 204 
#line 204 
void ptp_clock_event(struct ptp_clock *, struct ptp_clock_event *);
#line 266  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ptp_clock_kernel.h"
__inline static void ptp_read_system_prets(struct ptp_system_timestamp *sts)
{
  #line 268 
  if (sts != (struct ptp_system_timestamp *)0) 
                                               #line 269 
                                               ktime_get_real_ts64(& sts->pre_ts);
  #line 270 
  return;
}

#line 272  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ptp_clock_kernel.h"
__inline static void ptp_read_system_postts(struct ptp_system_timestamp *sts)
{
  #line 274 
  if (sts != (struct ptp_system_timestamp *)0) 
                                               #line 275 
                                               ktime_get_real_ts64(& sts->post_ts);
  #line 276 
  return;
}

#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static void ixgbe_write_reg_3(struct ixgbe_hw *hw, u32 reg, u32 value)
{
  #line 147 
  union __anonunion___u_4833 __u;
  #line 146 
  __read_once_size((void *)(& hw->hw_addr),(void *)(& __u.__c),8);
  #line 146 
  u8 *reg_addr = (__u.__val);
  #line 148 
  if ((int)ixgbe_removed((void *)reg_addr) != 0) 
                                                 #line 149 
                                                 return;
  #line 150 
  writel(value,(void *)(reg_addr + (unsigned long)reg));
  #line 151 
  return;
}

#line 157  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static void ixgbe_ptp_setup_sdp_X540(struct ixgbe_adapter *adapter)
{
  #line 161 
  u32 esdp;
  #line 161 
  u32 tsauxc;
  #line 161 
  u32 clktiml;
  #line 161 
  u32 clktimh;
  #line 161 
  u32 trgttiml;
  #line 161 
  u32 trgttimh;
  #line 161 
  u32 rem;
  #line 162 
  u64 clock_period;
  #line 163 
  unsigned long flags;
  #line 159 
  struct cyclecounter *cc = & adapter->hw_cc;
  #line 160 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 162 
  u64 ns = 0ULL;
  #line 162 
  u64 clock_edge = 0ULL;
  #line 166 
  ixgbe_write_reg_3(hw,35872U,0U);
  #line 167 
  ixgbe_read_reg(hw,8U);
  #line 169 
  if (((unsigned long)adapter->flags2 & 1024UL) == 0UL) 
                                                        #line 170 
                                                        return;
  #line 172 
  esdp = ixgbe_read_reg(hw,32U);
  #line 177 
  esdp |= 65792U;
  #line 183 
  tsauxc = 76U;
  #line 190 
  clock_period = div_u64(500000000ULL << cc->shift,cc->mult);
  #line 191 
  clktiml = (unsigned int)clock_period;
  #line 192 
  clktimh = (unsigned int)(clock_period >> 32);
  #line 195 
  cif___ldv_spin_lock_tmreg_lock_of_ixgbe_adapter(& adapter->tmreg_lock);
  #line 196 
  ns = timecounter_read(& adapter->hw_tc);
  #line 197 
  clock_edge = adapter->hw_tc.cycle_last;
  #line 198 
  cif_spin_unlock_irqrestore_tmreg_lock_of_ixgbe_adapter(& adapter->tmreg_lock,flags);
  #line 201 
  div_u64_rem(ns,1000000000U,& rem);
  #line 206 
  rem = 1000000000U - rem;
  #line 209 
  clock_edge = div_u64((unsigned long long)rem << cc->shift,cc->mult) + clock_edge;
  #line 210 
  trgttiml = (unsigned int)clock_edge;
  #line 211 
  trgttimh = (unsigned int)(clock_edge >> 32);
  #line 213 
  ixgbe_write_reg_3(hw,35892U,clktiml);
  #line 214 
  ixgbe_write_reg_3(hw,35896U,clktimh);
  #line 215 
  ixgbe_write_reg_3(hw,35876U,trgttiml);
  #line 216 
  ixgbe_write_reg_3(hw,35880U,trgttimh);
  #line 218 
  ixgbe_write_reg_3(hw,32U,esdp);
  #line 219 
  ixgbe_write_reg_3(hw,35872U,tsauxc);
  #line 221 
  ixgbe_read_reg(hw,8U);
  #line 222 
  return;
}

#line 236  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static void ixgbe_ptp_setup_sdp_X550(struct ixgbe_adapter *adapter)
{
  #line 238 
  u32 esdp;
  #line 238 
  u32 tsauxc;
  #line 238 
  u32 freqout;
  #line 238 
  u32 trgttiml;
  #line 238 
  u32 trgttimh;
  #line 238 
  u32 rem;
  #line 238 
  u32 tssdp;
  #line 242 
  struct timespec64 ts;
  #line 243 
  unsigned long flags;
  #line 239 
  struct cyclecounter *cc = & adapter->hw_cc;
  #line 240 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 241 
  u64 ns = 0ULL;
  #line 241 
  u64 clock_edge = 0ULL;
  #line 246 
  ixgbe_write_reg_3(hw,35872U,0U);
  #line 247 
  ixgbe_read_reg(hw,8U);
  #line 249 
  if (((unsigned long)adapter->flags2 & 1024UL) == 0UL) 
                                                        #line 250 
                                                        return;
  #line 252 
  esdp = ixgbe_read_reg(hw,32U);
  #line 257 
  esdp |= 65792U;
  #line 264 
  tsauxc = 1073741909U;
  #line 268 
  tssdp = 384U;
  #line 275 
  freqout = (unsigned int)div_u64(500000000ULL << cc->shift,cc->mult);
  #line 278 
  cif___ldv_spin_lock_tmreg_lock_of_ixgbe_adapter(& adapter->tmreg_lock);
  #line 279 
  ns = timecounter_read(& adapter->hw_tc);
  #line 280 
  clock_edge = adapter->hw_tc.cycle_last;
  #line 281 
  cif_spin_unlock_irqrestore_tmreg_lock_of_ixgbe_adapter(& adapter->tmreg_lock,flags);
  #line 284 
  div_u64_rem(ns,1000000000U,& rem);
  #line 289 
  rem = 1000000000U - rem;
  #line 292 
  clock_edge = div_u64((unsigned long long)rem << cc->shift,cc->mult) + clock_edge;
  #line 301 
  ts = ns_to_timespec64((long long)clock_edge);
  #line 302 
  trgttiml = (unsigned int)ts.tv_nsec;
  #line 303 
  trgttimh = (unsigned int)ts.tv_sec;
  #line 305 
  ixgbe_write_reg_3(hw,35892U,freqout);
  #line 306 
  ixgbe_write_reg_3(hw,35876U,trgttiml);
  #line 307 
  ixgbe_write_reg_3(hw,35880U,trgttimh);
  #line 309 
  ixgbe_write_reg_3(hw,32U,esdp);
  #line 310 
  ixgbe_write_reg_3(hw,60U,tssdp);
  #line 311 
  ixgbe_write_reg_3(hw,35872U,tsauxc);
  #line 313 
  ixgbe_read_reg(hw,8U);
  #line 314 
  return;
}

#line 326  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static u64 ixgbe_ptp_read_X550(struct cyclecounter *cc)
{
  #line 329 
  void *__mptr;
  #line 331 
  struct timespec64 ts;
  #line 329 
  __mptr = (void *)cc;
  #line 328 
  struct ixgbe_adapter *adapter = ((struct ixgbe_adapter *)(__mptr + 18446744073709412024U));
  #line 330 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 348 
  ixgbe_read_reg(hw,35928U);
  #line 349 
  ts.tv_nsec = (long)ixgbe_read_reg(hw,35852U);
  #line 350 
  ts.tv_sec = (long long)ixgbe_read_reg(hw,35856U);
  #line 352 
  return (unsigned long long)timespec64_to_ns(& ts);
}

#line 363  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static u64 ixgbe_ptp_read_82599(struct cyclecounter *cc)
{
  #line 366 
  void *__mptr;
  #line 366 
  __mptr = (void *)cc;
  #line 365 
  struct ixgbe_adapter *adapter = ((struct ixgbe_adapter *)(__mptr + 18446744073709412024U));
  #line 367 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 368 
  u64 stamp = 0ULL;
  #line 370 
  stamp = (unsigned long long)ixgbe_read_reg(hw,35852U) | stamp;
  #line 371 
  stamp = ((unsigned long long)ixgbe_read_reg(hw,35856U) << 32) | stamp;
  #line 373 
  return stamp;
}

#line 393  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static void ixgbe_ptp_convert_to_hwtstamp(struct ixgbe_adapter *adapter, struct skb_shared_hwtstamps *hwtstamp, u64 timestamp)
{
  #line 397 
  unsigned long flags;
  #line 398 
  struct timespec64 systime;
  #line 399 
  u64 ns;
  #line 401 
  memset((void *)hwtstamp,0,8UL);
  #line 403 
  switch ((unsigned int)adapter->hw.mac.type) {
    #line 412 
    case (unsigned int)4: 
                          #line 412 
    ;
    #line 413 
    case (unsigned int)5: 
                          #line 413 
    ;
    #line 414 
    case (unsigned int)6: 
                          #line 414 
    ;
    #line 420 
    systime.tv_sec = (long long)(timestamp >> 32);
    #line 421 
    systime.tv_nsec = (long)timestamp & 4294967295L;
    #line 423 
    timestamp = (unsigned long long)timespec64_to_ns(& systime);
    #line 424 
    break;
    #line 425 
    default: 
             #line 425 
    ;
    #line 426 
    break;
  }
  #line 429 
  cif___ldv_spin_lock_tmreg_lock_of_ixgbe_adapter(& adapter->tmreg_lock);
  #line 430 
  ns = timecounter_cyc2time(& adapter->hw_tc,timestamp);
  #line 431 
  cif_spin_unlock_irqrestore_tmreg_lock_of_ixgbe_adapter(& adapter->tmreg_lock,flags);
  #line 433 
  hwtstamp->hwtstamp = ns_to_ktime(ns);
  #line 434 
  return;
}

#line 444  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static int ixgbe_ptp_adjfreq_82599(struct ptp_clock_info *ptp, s32 ppb)
{
  #line 447 
  void *__mptr;
  #line 460 
  union __anonunion___u_4848 __u;
  #line 449 
  u64 freq;
  #line 449 
  u64 incval;
  #line 450 
  u32 diff;
  #line 447 
  __mptr = (void *)ptp;
  #line 446 
  struct ixgbe_adapter *adapter = ((struct ixgbe_adapter *)(__mptr + 18446744073709412368U));
  #line 448 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 451 
  int neg_adj = 0;
  #line 453 
  if (ppb < 0) {
    #line 454 
    neg_adj = 1;
    #line 455 
    ppb = - ppb;
  }
  #line 457 
  ldv_inline_asm();
  #line 459 
  __read_once_size((void *)(& adapter->base_incval),(void *)(& __u.__c),4);
  #line 459 
  incval = (unsigned long long)(__u.__val);
  #line 461 
  freq = incval;
  #line 462 
  freq = (unsigned long long)ppb * freq;
  #line 463 
  diff = (unsigned int)div_u64(freq,1000000000U);
  #line 465 
  if (neg_adj != 0) 
                    #line 465 
                    incval -= (unsigned long long)diff; else 
                                                             #line 465 
                                                             incval = (unsigned long long)diff + incval;
  #line 467 
  switch ((unsigned int)hw->mac.type) {
    #line 468 
    case (unsigned int)3: 
                          #line 468 
    ;
    #line 469 
    if (incval > 4294967295ULL) 
                                #line 470 
                                _dev_warn(& (adapter->pdev)->dev,(char *)"PTP ppb adjusted SYSTIME rate overflowed!\n");
    #line 471 
    ixgbe_write_reg_3(hw,35860U,(unsigned int)incval);
    #line 472 
    break;
    #line 473 
    case (unsigned int)2: 
                          #line 473 
    ;
    #line 474 
    if (incval > 16777215ULL) 
                              #line 475 
                              _dev_warn(& (adapter->pdev)->dev,(char *)"PTP ppb adjusted SYSTIME rate overflowed!\n");
    #line 476 
    ixgbe_write_reg_3(hw,35860U,((unsigned int)incval & 16777215U) | 16777216U);
    #line 479 
    break;
    #line 480 
    default: 
             #line 480 
    ;
    #line 481 
    break;
  }
  #line 484 
  return 0;
}

#line 495  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static int ixgbe_ptp_adjfreq_X550(struct ptp_clock_info *ptp, s32 ppb)
{
  #line 498 
  void *__mptr;
  #line 502 
  u32 inca;
  #line 498 
  __mptr = (void *)ptp;
  #line 497 
  struct ixgbe_adapter *adapter = ((struct ixgbe_adapter *)(__mptr + 18446744073709412368U));
  #line 499 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 500 
  int neg_adj = 0;
  #line 501 
  u64 rate = 53687091200ULL;
  #line 504 
  if (ppb < 0) {
    #line 505 
    neg_adj = 1;
    #line 506 
    ppb = - ppb;
  }
  #line 508 
  rate = (unsigned long long)ppb * rate;
  #line 509 
  rate = div_u64(rate,1000000000U);
  #line 512 
  if (rate > 2147483646ULL) 
                            #line 513 
                            _dev_warn(& (adapter->pdev)->dev,(char *)"PTP ppb adjusted SYSTIME rate overflowed!\n");
  #line 515 
  inca = (unsigned int)rate & 2147483647U;
  #line 516 
  if (neg_adj != 0) 
                    #line 517 
                    inca |= 2147483648U;
  #line 519 
  ixgbe_write_reg_3(hw,35860U,inca);
  #line 521 
  return 0;
}

#line 531  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static int ixgbe_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)
{
  #line 534 
  void *__mptr;
  #line 535 
  unsigned long flags;
  #line 534 
  __mptr = (void *)ptp;
  #line 533 
  struct ixgbe_adapter *adapter = ((struct ixgbe_adapter *)(__mptr + 18446744073709412368U));
  #line 537 
  cif___ldv_spin_lock_tmreg_lock_of_ixgbe_adapter(& adapter->tmreg_lock);
  #line 538 
  timecounter_adjtime(& adapter->hw_tc,delta);
  #line 539 
  cif_spin_unlock_irqrestore_tmreg_lock_of_ixgbe_adapter(& adapter->tmreg_lock,flags);
  #line 541 
  if (adapter->ptp_setup_sdp != (void (*)(struct ixgbe_adapter *))0) 
    #line 542 
    (*(adapter->ptp_setup_sdp))(adapter);
  #line 544 
  return 0;
}

#line 556  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static int ixgbe_ptp_gettimex(struct ptp_clock_info *ptp, struct timespec64 *ts, struct ptp_system_timestamp *sts)
{
  #line 561 
  void *__mptr;
  #line 563 
  unsigned long flags;
  #line 564 
  u64 ns;
  #line 564 
  u64 stamp;
  #line 561 
  __mptr = (void *)ptp;
  #line 560 
  struct ixgbe_adapter *adapter = ((struct ixgbe_adapter *)(__mptr + 18446744073709412368U));
  #line 562 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 566 
  cif___ldv_spin_lock_tmreg_lock_of_ixgbe_adapter(& adapter->tmreg_lock);
  #line 568 
  switch ((unsigned int)adapter->hw.mac.type) {
    #line 569 
    case (unsigned int)4: 
                          #line 569 
    ;
    #line 570 
    case (unsigned int)5: 
                          #line 570 
    ;
    #line 571 
    case (unsigned int)6: 
                          #line 571 
    ;
    #line 577 
    ptp_read_system_prets(sts);
    #line 578 
    ixgbe_read_reg(hw,35928U);
    #line 579 
    ptp_read_system_postts(sts);
    #line 580 
    ts->tv_nsec = (long)ixgbe_read_reg(hw,35852U);
    #line 581 
    ts->tv_sec = (long long)ixgbe_read_reg(hw,35856U);
    #line 582 
    stamp = (unsigned long long)timespec64_to_ns(ts);
    #line 583 
    break;
    #line 584 
    default: 
             #line 584 
    ;
    #line 585 
    ptp_read_system_prets(sts);
    #line 586 
    stamp = (unsigned long long)ixgbe_read_reg(hw,35852U);
    #line 587 
    ptp_read_system_postts(sts);
    #line 588 
    stamp = ((unsigned long long)ixgbe_read_reg(hw,35856U) << 32) | stamp;
    #line 589 
    break;
  }
  #line 592 
  ns = timecounter_cyc2time(& adapter->hw_tc,stamp);
  #line 594 
  cif_spin_unlock_irqrestore_tmreg_lock_of_ixgbe_adapter(& adapter->tmreg_lock,flags);
  #line 596 
  *ts = ns_to_timespec64((long long)ns);
  #line 598 
  return 0;
}

#line 609  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static int ixgbe_ptp_settime(struct ptp_clock_info *ptp, struct timespec64 *ts)
{
  #line 613 
  void *__mptr;
  #line 614 
  unsigned long flags;
  #line 613 
  __mptr = (void *)ptp;
  #line 612 
  struct ixgbe_adapter *adapter = ((struct ixgbe_adapter *)(__mptr + 18446744073709412368U));
  #line 615 
  u64 ns = (unsigned long long)timespec64_to_ns(ts);
  #line 618 
  cif___ldv_spin_lock_tmreg_lock_of_ixgbe_adapter(& adapter->tmreg_lock);
  #line 619 
  timecounter_init(& adapter->hw_tc,& adapter->hw_cc,ns);
  #line 620 
  cif_spin_unlock_irqrestore_tmreg_lock_of_ixgbe_adapter(& adapter->tmreg_lock,flags);
  #line 622 
  if (adapter->ptp_setup_sdp != (void (*)(struct ixgbe_adapter *))0) 
    #line 623 
    (*(adapter->ptp_setup_sdp))(adapter);
  #line 624 
  return 0;
}

#line 636  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static int ixgbe_ptp_feature_enable(struct ptp_clock_info *ptp, struct ptp_clock_request *rq, int on)
{
  #line 640 
  void *__mptr;
  #line 640 
  __mptr = (void *)ptp;
  #line 639 
  struct ixgbe_adapter *adapter = ((struct ixgbe_adapter *)(__mptr + 18446744073709412368U));
  #line 648 
  if (rq->type != (unsigned int)PTP_CLK_REQ_PPS || adapter->ptp_setup_sdp == (void (*)(struct ixgbe_adapter *))0) 
    #line 649 
    return -524;
  #line 651 
  if (on != 0) 
               #line 652 
               adapter->flags2 |= 1024U; else 
                                              #line 654 
                                              adapter->flags2 &= 4294966271U;
  #line 656 
  (*(adapter->ptp_setup_sdp))(adapter);
  #line 657 
  return 0;
}

#line 667  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_check_pps_event(struct ixgbe_adapter *adapter)
{
  #line 670 
  struct ptp_clock_event event;
  #line 669 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 672 
  event.type = 2;
  #line 678 
  if (adapter->ptp_clock == (struct ptp_clock *)0) 
                                                   #line 679 
                                                   return;
  #line 681 
  switch ((unsigned int)hw->mac.type) {
    #line 682 
    case (unsigned int)3: 
                          #line 682 
    ;
    #line 683 
    ptp_clock_event(adapter->ptp_clock,& event);
    #line 684 
    break;
    #line 685 
    default: 
             #line 685 
    ;
    #line 686 
    break;
  }
  #line 688 
  return;
}

#line 698  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_overflow_check(struct ixgbe_adapter *adapter)
{
  #line 700 
  int tmp_1;
  #line 702 
  unsigned long flags;
  {
    #line 700 
    unsigned long __dummy;
    #line 700 
    unsigned long __dummy2;
    }
  #line 700 
  if (1 != 0) {
    {
      #line 700 
      unsigned long __dummy_0;
      #line 700 
      unsigned long __dummy2_0;
      }
    #line 700 
    if (1 != 0) 
      #line 700 
      if ((long)((adapter->last_overflow_check - jiffies) + 7500UL) < 0L) 
        #line 700 
        tmp_1 = 1; else 
                        #line 700 
                        tmp_1 = 0;
    else 
         #line 700 
         tmp_1 = 0;
  }
  else 
       #line 700 
       tmp_1 = 0;
  #line 700 
  bool timeout = (_Bool)(tmp_1 != 0);
  #line 704 
  if ((int)timeout != 0) {
    #line 706 
    cif___ldv_spin_lock_tmreg_lock_of_ixgbe_adapter(& adapter->tmreg_lock);
    #line 707 
    timecounter_read(& adapter->hw_tc);
    #line 708 
    cif_spin_unlock_irqrestore_tmreg_lock_of_ixgbe_adapter(& adapter->tmreg_lock,flags);
    #line 710 
    adapter->last_overflow_check = jiffies;
  }
  #line 712 
  return;
}

#line 723  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_rx_hang(struct ixgbe_adapter *adapter)
{
  #line 727 
  struct ixgbe_ring *rx_ring;
  #line 728 
  unsigned long rx_event;
  #line 729 
  int n;
  #line 725 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 726 
  u32 tsyncrxctl = ixgbe_read_reg(hw,20872U);
  #line 734 
  if ((tsyncrxctl & 1U) == 0U) {
    #line 735 
    adapter->last_rx_ptp_check = jiffies;
    #line 736 
    return;
  }
  #line 740 
  rx_event = adapter->last_rx_ptp_check;
  #line 741 
  n = 0;
  #line 741 
  while (adapter->num_rx_queues > n) {
    {
      #line 742 
      rx_ring = adapter->rx_ring[n];
      {
        #line 743 
        unsigned long __dummy;
        #line 743 
        unsigned long __dummy2;
        }
      #line 743 
      if (1 != 0) {
        {
          #line 743 
          unsigned long __dummy_0;
          #line 743 
          unsigned long __dummy2_0;
          }
        #line 743 
        if (1 != 0) 
          #line 743 
          if ((long)(rx_event - rx_ring->last_rx_timestamp) < 0L) 
                                                                  #line 744 
                                                                  rx_event = rx_ring->last_rx_timestamp;
      }
    }
    #line 741 
    n ++;
  }
  {
    #line 748 
    unsigned long __dummy_1;
    #line 748 
    unsigned long __dummy2_1;
    }
  #line 748 
  if (1 != 0) {
    {
      #line 748 
      unsigned long __dummy_2;
      #line 748 
      unsigned long __dummy2_2;
      }
    #line 748 
    if (1 != 0) 
      #line 748 
      if ((long)((rx_event - jiffies) + 1250UL) < 0L) {
        #line 749 
        ixgbe_read_reg(hw,20900U);
        #line 750 
        adapter->last_rx_ptp_check = jiffies;
        #line 752 
        (adapter->rx_hwtstamp_cleared) ++;
        #line 753 
        if (((int)adapter->msg_enable & 1) != 0) 
                                                 #line 753 
                                                 netdev_warn(adapter->netdev,(char *)"clearing RX Timestamp hang\n");
      }
  }
  #line 755 
  return;
}

#line 765  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static void ixgbe_ptp_clear_tx_timestamp(struct ixgbe_adapter *adapter)
{
  #line 767 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 769 
  ixgbe_read_reg(hw,35848U);
  #line 770 
  if (adapter->ptp_tx_skb != (struct sk_buff *)0) {
    #line 771 
    dev_kfree_skb_any(adapter->ptp_tx_skb);
    #line 772 
    adapter->ptp_tx_skb = (struct sk_buff *)0;
  }
  #line 774 
  clear_bit_unlock(9L,& adapter->state);
  #line 775 
  return;
}

#line 781  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_tx_hang(struct ixgbe_adapter *adapter)
{
  #line 783 
  int tmp_1;
  {
    #line 783 
    unsigned long __dummy;
    #line 783 
    unsigned long __dummy2;
    }
  #line 783 
  if (1 != 0) {
    {
      #line 783 
      unsigned long __dummy_0;
      #line 783 
      unsigned long __dummy2_0;
      }
    #line 783 
    if (1 != 0) 
      #line 783 
      if ((long)((adapter->ptp_tx_start - jiffies) + 250UL) < 0L) 
                                                                  #line 783 
                                                                  tmp_1 = 1; else 
                                                                    #line 783 
                                                                    tmp_1 = 0;
    else 
         #line 783 
         tmp_1 = 0;
  }
  else 
       #line 783 
       tmp_1 = 0;
  #line 783 
  bool timeout = (_Bool)(tmp_1 != 0);
  #line 786 
  if (adapter->ptp_tx_skb == (struct sk_buff *)0) 
                                                  #line 787 
                                                  return;
  #line 789 
  if (! test_bit(9L,& adapter->state)) 
                                       #line 790 
                                       return;
  #line 796 
  if ((int)timeout != 0) {
    #line 797 
    cancel_work_sync(& adapter->ptp_tx_work);
    #line 798 
    ixgbe_ptp_clear_tx_timestamp(adapter);
    #line 799 
    (adapter->tx_hwtstamp_timeouts) ++;
    #line 800 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 800 
                                             netdev_warn(adapter->netdev,(char *)"clearing Tx timestamp hang\n");
  }
  #line 802 
  return;
}

#line 812  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static void ixgbe_ptp_tx_hwtstamp(struct ixgbe_adapter *adapter)
{
  #line 816 
  struct skb_shared_hwtstamps shhwtstamps;
  #line 814 
  struct sk_buff *skb = adapter->ptp_tx_skb;
  #line 815 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 817 
  u64 regval = 0ULL;
  #line 819 
  regval = (unsigned long long)ixgbe_read_reg(hw,35844U) | regval;
  #line 820 
  regval = ((unsigned long long)ixgbe_read_reg(hw,35848U) << 32) | regval;
  #line 821 
  ixgbe_ptp_convert_to_hwtstamp(adapter,& shhwtstamps,regval);
  #line 828 
  adapter->ptp_tx_skb = (struct sk_buff *)0;
  #line 829 
  clear_bit_unlock(9L,& adapter->state);
  #line 832 
  skb_tstamp_tx(skb,& shhwtstamps);
  #line 833 
  dev_kfree_skb_any(skb);
  #line 834 
  return;
}

#line 844  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static void ixgbe_ptp_tx_hwtstamp_work(struct work_struct *work)
{
  #line 846 
  void *__mptr;
  #line 849 
  int tmp_2;
  #line 851 
  u32 tsynctxctl;
  #line 846 
  __mptr = (void *)work;
  #line 846 
  struct ixgbe_adapter *adapter = ((struct ixgbe_adapter *)(__mptr + 18446744073709412232U));
  #line 848 
  struct ixgbe_hw *hw = & adapter->hw;
  {
    #line 849 
    unsigned long __dummy;
    #line 849 
    unsigned long __dummy2;
    }
  #line 849 
  if (1 != 0) {
    {
      #line 849 
      unsigned long __dummy_0;
      #line 849 
      unsigned long __dummy2_0;
      }
    #line 849 
    if (1 != 0) 
      #line 849 
      if ((long)((adapter->ptp_tx_start - jiffies) + 250UL) < 0L) 
                                                                  #line 849 
                                                                  tmp_2 = 1; else 
                                                                    #line 849 
                                                                    tmp_2 = 0;
    else 
         #line 849 
         tmp_2 = 0;
  }
  else 
       #line 849 
       tmp_2 = 0;
  #line 849 
  bool timeout = (_Bool)(tmp_2 != 0);
  #line 854 
  if (adapter->ptp_tx_skb == (struct sk_buff *)0) {
    #line 855 
    ixgbe_ptp_clear_tx_timestamp(adapter);
    #line 856 
    return;
  }
  #line 860 
  tsynctxctl = ixgbe_read_reg(hw,35840U);
  #line 861 
  if ((tsynctxctl & 1U) != 0U) {
    #line 862 
    ixgbe_ptp_tx_hwtstamp(adapter);
    #line 863 
    return;
  }
  #line 866 
  if ((int)timeout != 0) {
    #line 867 
    ixgbe_ptp_clear_tx_timestamp(adapter);
    #line 868 
    (adapter->tx_hwtstamp_timeouts) ++;
    #line 869 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 869 
                                             netdev_warn(adapter->netdev,(char *)"clearing Tx Timestamp hang\n");
  }
  else 
       #line 872 
       cif_schedule_work_0(& adapter->ptp_tx_work);
  #line 873 
  return;
}

#line 885  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_rx_pktstamp(struct ixgbe_q_vector *q_vector, struct sk_buff *skb)
{
  #line 888 
  __le64 regval;
  #line 891 
  skb_copy_bits(skb,(int)(skb->len + 4294967288U),(void *)(& regval),8);
  #line 893 
  __pskb_trim(skb,skb->len + 4294967288U);
  #line 901 
  ;
  #line 901 
  ;
  #line 901 
  ixgbe_ptp_convert_to_hwtstamp(q_vector->adapter,skb_hwtstamps(skb),regval);
  #line 903 
  return;
}

#line 914  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_rx_rgtstamp(struct ixgbe_q_vector *q_vector, struct sk_buff *skb)
{
  #line 917 
  struct ixgbe_adapter *adapter;
  #line 918 
  struct ixgbe_hw *hw;
  #line 920 
  u32 tsyncrxctl;
  #line 919 
  u64 regval = 0ULL;
  #line 923 
  if (q_vector == (struct ixgbe_q_vector *)0 || q_vector->adapter == (struct ixgbe_adapter *)0) 
    #line 924 
    return;
  #line 926 
  adapter = q_vector->adapter;
  #line 927 
  hw = & adapter->hw;
  #line 933 
  tsyncrxctl = ixgbe_read_reg(hw,20872U);
  #line 934 
  if ((tsyncrxctl & 1U) == 0U) 
                               #line 935 
                               return;
  #line 937 
  regval = (unsigned long long)ixgbe_read_reg(hw,20968U) | regval;
  #line 938 
  regval = ((unsigned long long)ixgbe_read_reg(hw,20900U) << 32) | regval;
  #line 940 
  ;
  #line 940 
  ;
  #line 940 
  ixgbe_ptp_convert_to_hwtstamp(adapter,skb_hwtstamps(skb),regval);
  #line 941 
  return;
}

#line 952  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
int ixgbe_ptp_get_ts_config(struct ixgbe_adapter *adapter, struct ifreq *ifr)
{
  #line 957 
  int tmp_0;
  #line 954 
  struct hwtstamp_config *config = & adapter->tstamp_config;
  #line 957 
  if (copy_to_user(ifr->ifr_ifru.ifru_data,(void *)config,12UL) != 0UL) 
    #line 957 
    tmp_0 = -14; else 
                      #line 957 
                      tmp_0 = 0;
  #line 957 
  return tmp_0;
}

#line 985  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static int ixgbe_ptp_set_timestamp_mode(struct ixgbe_adapter *adapter, struct hwtstamp_config *config)
{
  #line 993 
  u32 regval;
  #line 988 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 989 
  u32 tsync_tx_ctl = 16U;
  #line 990 
  u32 tsync_rx_ctl = 16U;
  #line 991 
  u32 tsync_rx_mtrl = 20905984U;
  #line 992 
  bool is_l2 = (_Bool)0;
  #line 996 
  if (config->flags != 0) 
                          #line 997 
                          return -22;
  #line 999 
  switch (config->tx_type) {
    #line 1000 
    case 0: 
            #line 1000 
    ;
    #line 1001 
    tsync_tx_ctl = 0U;
    #line 1002 
    case 1: 
            #line 1002 
    ;
    #line 1003 
    break;
    #line 1004 
    default: 
             #line 1004 
    ;
    #line 1005 
    return -34;
  }
  #line 1008 
  switch (config->rx_filter) {
    #line 1009 
    case 0: 
            #line 1009 
    ;
    #line 1010 
    tsync_rx_ctl = 0U;
    #line 1011 
    tsync_rx_mtrl = 0U;
    #line 1012 
    adapter->flags &= 4194303999U;
    #line 1014 
    break;
    #line 1015 
    case 4: 
            #line 1015 
    ;
    #line 1016 
    tsync_rx_ctl |= 2U;
    #line 1017 
    tsync_rx_mtrl = tsync_rx_mtrl;
    #line 1018 
    adapter->flags |= 100663296U;
    #line 1020 
    break;
    #line 1021 
    case 5: 
            #line 1021 
    ;
    #line 1022 
    tsync_rx_ctl |= 2U;
    #line 1023 
    tsync_rx_mtrl |= 1U;
    #line 1024 
    adapter->flags |= 100663296U;
    #line 1026 
    break;
    #line 1027 
    case 12: 
             #line 1027 
    ;
    #line 1028 
    case 9: 
            #line 1028 
    ;
    #line 1029 
    case 6: 
            #line 1029 
    ;
    #line 1030 
    case 13: 
             #line 1030 
    ;
    #line 1031 
    case 10: 
             #line 1031 
    ;
    #line 1032 
    case 7: 
            #line 1032 
    ;
    #line 1033 
    case 14: 
             #line 1033 
    ;
    #line 1034 
    case 11: 
             #line 1034 
    ;
    #line 1035 
    case 8: 
            #line 1035 
    ;
    #line 1036 
    tsync_rx_ctl |= 10U;
    #line 1037 
    is_l2 = (_Bool)1;
    #line 1038 
    config->rx_filter = 12;
    #line 1039 
    adapter->flags |= 100663296U;
    #line 1041 
    break;
    #line 1042 
    case 3: 
            #line 1042 
    ;
    #line 1043 
    case 15: 
             #line 1043 
    ;
    #line 1044 
    case 1: 
            #line 1044 
    ;
    #line 1048 
    if (hw->mac.type > (unsigned int)ixgbe_mac_X540) {
      #line 1049 
      tsync_rx_ctl |= 8U;
      #line 1050 
      config->rx_filter = 1;
      #line 1051 
      adapter->flags |= 33554432U;
      #line 1052 
      break;
    }
    #line 1055 
    default: 
             #line 1055 
    ;
    #line 1062 
    adapter->flags &= 4194303999U;
    #line 1064 
    config->rx_filter = 0;
    #line 1065 
    return -34;
  }
  #line 1068 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) {
    #line 1069 
    adapter->flags &= 4194303999U;
    #line 1071 
    if ((tsync_rx_ctl | tsync_tx_ctl) != 0U) 
                                             #line 1072 
                                             return -34;
    #line 1073 
    return 0;
  }
  #line 1080 
  switch ((unsigned int)hw->mac.type) {
    #line 1081 
    case (unsigned int)4: 
                          #line 1081 
    ;
    #line 1082 
    case (unsigned int)5: 
                          #line 1082 
    ;
    #line 1083 
    case (unsigned int)6: 
                          #line 1083 
    ;
    #line 1088 
    if (config->rx_filter == 0) 
                                #line 1089 
                                break;
    #line 1091 
    tsync_rx_ctl = 8388632U;
    #line 1094 
    config->rx_filter = 1;
    #line 1095 
    adapter->flags |= 33554432U;
    #line 1096 
    adapter->flags &= 4227858431U;
    #line 1097 
    is_l2 = (_Bool)1;
    #line 1098 
    break;
    #line 1099 
    default: 
             #line 1099 
    ;
    #line 1100 
    break;
  }
  #line 1104 
  if ((int)is_l2 != 0) 
                       #line 1105 
                       ixgbe_write_reg_3(hw,20788U,3221260535U); else 
                                                                   #line 1110 
                                                                   ixgbe_write_reg_3(hw,20788U,0U);
  #line 1113 
  regval = ixgbe_read_reg(hw,35840U);
  #line 1114 
  regval &= 4294967279U;
  #line 1115 
  regval |= tsync_tx_ctl;
  #line 1116 
  ixgbe_write_reg_3(hw,35840U,regval);
  #line 1119 
  regval = ixgbe_read_reg(hw,20872U);
  #line 1120 
  regval &= 4294967265U;
  #line 1121 
  regval |= tsync_rx_ctl;
  #line 1122 
  ixgbe_write_reg_3(hw,20872U,regval);
  #line 1125 
  ixgbe_write_reg_3(hw,20768U,tsync_rx_mtrl);
  #line 1127 
  ixgbe_read_reg(hw,8U);
  #line 1130 
  ixgbe_ptp_clear_tx_timestamp(adapter);
  #line 1131 
  ixgbe_read_reg(hw,20900U);
  #line 1133 
  return 0;
}

#line 1144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
int ixgbe_ptp_set_ts_config(struct ixgbe_adapter *adapter, struct ifreq *ifr)
{
  #line 1146 
  struct hwtstamp_config config;
  #line 1147 
  int err;
  #line 1161 
  int tmp_1;
  #line 1149 
  if (copy_from_user((void *)(& config),ifr->ifr_ifru.ifru_data,12UL) != 0UL) 
    #line 1150 
    return -14;
  #line 1152 
  err = ixgbe_ptp_set_timestamp_mode(adapter,& config);
  #line 1153 
  if (err != 0) 
                #line 1154 
                return err;
  #line 1157 
  memcpy((void *)(& adapter->tstamp_config),(void *)(& config),12UL);
  #line 1161 
  if (copy_to_user(ifr->ifr_ifru.ifru_data,(void *)(& config),12UL) != 0UL) 
    #line 1161 
    tmp_1 = -14; else 
                      #line 1161 
                      tmp_1 = 0;
  #line 1161 
  return tmp_1;
}

#line 1164  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static void ixgbe_ptp_link_speed_adjust(struct ixgbe_adapter *adapter, u32 *shift, u32 *incval)
{
  #line 1181 
  switch (adapter->link_speed) {
    #line 1182 
    case (u32)8: 
                 #line 1182 
    ;
    #line 1183 
    *shift = 21U;
    #line 1184 
    *incval = 1342177280U;
    #line 1185 
    break;
    #line 1186 
    case (u32)32: 
                  #line 1186 
    ;
    #line 1187 
    *shift = 24U;
    #line 1188 
    *incval = 1073741824U;
    #line 1189 
    break;
    #line 1190 
    case (u32)128: 
                   #line 1190 
    ;
    #line 1191 
    default: 
             #line 1191 
    ;
    #line 1192 
    *shift = 28U;
    #line 1193 
    *incval = 1717986918U;
    #line 1194 
    break;
  }
  #line 1196 
  return;
}

#line 1208  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_start_cyclecounter(struct ixgbe_adapter *adapter)
{
  #line 1211 
  struct cyclecounter cc;
  #line 1212 
  unsigned long flags;
  #line 1210 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 1213 
  u32 incval = 0U;
  #line 1214 
  u32 tsauxc = 0U;
  #line 1215 
  u32 fuse0 = 0U;
  #line 1228 
  cc.mask = 18446744073709551615ULL;
  #line 1229 
  cc.mult = 1U;
  #line 1230 
  cc.shift = 0U;
  #line 1232 
  switch ((unsigned int)hw->mac.type) {
    #line 1233 
    case (unsigned int)5: 
                          #line 1233 
    ;
    #line 1240 
    fuse0 = ixgbe_read_reg(hw,69976U);
    #line 1241 
    if (((unsigned long)fuse0 & 32UL) == 0UL) {
      #line 1242 
      cc.mult = 3U;
      #line 1243 
      cc.shift = 2U;
    }
    #line 1246 
    case (unsigned int)6: 
                          #line 1246 
    ;
    #line 1247 
    case (unsigned int)4: 
                          #line 1247 
    ;
    #line 1248 
    cc.read = & ixgbe_ptp_read_X550;
    #line 1251 
    ixgbe_write_reg_3(hw,35928U,0U);
    #line 1252 
    ixgbe_write_reg_3(hw,35852U,0U);
    #line 1253 
    ixgbe_write_reg_3(hw,35856U,0U);
    #line 1254 
    tsauxc = ixgbe_read_reg(hw,35872U);
    #line 1255 
    ixgbe_write_reg_3(hw,35872U,tsauxc & 2147483647U);
    #line 1257 
    ixgbe_write_reg_3(hw,35944U,2U);
    #line 1258 
    ixgbe_write_reg_3(hw,2176U,16777216U);
    #line 1260 
    ixgbe_read_reg(hw,8U);
    #line 1261 
    break;
    #line 1262 
    case (unsigned int)3: 
                          #line 1262 
    ;
    #line 1263 
    cc.read = & ixgbe_ptp_read_82599;
    #line 1265 
    ixgbe_ptp_link_speed_adjust(adapter,& cc.shift,& incval);
    #line 1266 
    ixgbe_write_reg_3(hw,35860U,incval);
    #line 1267 
    break;
    #line 1268 
    case (unsigned int)2: 
                          #line 1268 
    ;
    #line 1269 
    cc.read = & ixgbe_ptp_read_82599;
    #line 1271 
    ixgbe_ptp_link_speed_adjust(adapter,& cc.shift,& incval);
    #line 1272 
    incval >>= 7;
    #line 1273 
    cc.shift += 4294967289U;
    #line 1274 
    ixgbe_write_reg_3(hw,35860U,incval | 16777216U);
    #line 1276 
    break;
    #line 1277 
    default: 
             #line 1277 
    ;
    #line 1279 
    return;
  }
  {
    #line 1284 
    union __anonunion___u_4850 __u = {.__val = incval};
    #line 1283 
    __write_once_size((void *)(& adapter->base_incval),(void *)(& __u.__c),4);
    #line 1283 
    u32 tmp = __u.__val;
  }
  #line 1285 
  ldv_inline_asm();
  #line 1287 
  cif___ldv_spin_lock_tmreg_lock_of_ixgbe_adapter(& adapter->tmreg_lock);
  #line 1288 
  memcpy((void *)(& adapter->hw_cc),(void *)(& cc),24UL);
  #line 1289 
  cif_spin_unlock_irqrestore_tmreg_lock_of_ixgbe_adapter(& adapter->tmreg_lock,flags);
  #line 1290 
  return;
}

#line 1304  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_reset(struct ixgbe_adapter *adapter)
{
  #line 1307 
  unsigned long flags;
  #line 1306 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 1310 
  ixgbe_ptp_set_timestamp_mode(adapter,& adapter->tstamp_config);
  #line 1313 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) 
                                                       #line 1314 
                                                       return;
  #line 1316 
  ixgbe_ptp_start_cyclecounter(adapter);
  #line 1318 
  cif___ldv_spin_lock_tmreg_lock_of_ixgbe_adapter(& adapter->tmreg_lock);
  #line 1319 
  ;
  #line 1319 
  ;
  #line 1319 
  timecounter_init(& adapter->hw_tc,& adapter->hw_cc,(unsigned long long)ktime_to_ns(ktime_get_real()));
  #line 1321 
  cif_spin_unlock_irqrestore_tmreg_lock_of_ixgbe_adapter(& adapter->tmreg_lock,flags);
  #line 1323 
  adapter->last_overflow_check = jiffies;
  #line 1328 
  if (adapter->ptp_setup_sdp != (void (*)(struct ixgbe_adapter *))0) 
    #line 1329 
    (*(adapter->ptp_setup_sdp))(adapter);
  #line 1330 
  return;
}

#line 1342  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static long ixgbe_ptp_create_clock(struct ixgbe_adapter *adapter)
{
  #line 1345 
  long err;
  #line 1344 
  struct net_device *netdev = adapter->netdev;
  #line 1348 
  if (! IS_ERR_OR_NULL((void *)adapter->ptp_clock)) 
                                                    #line 1349 
                                                    return 0L;
  #line 1351 
  switch ((unsigned int)adapter->hw.mac.type) {
    #line 1352 
    case (unsigned int)3: 
                          #line 1352 
    ;
    #line 1353 
    snprintf((char *)(& adapter->ptp_caps.name),16UL,(char *)"%s",(char *)(& netdev->name));
    #line 1356 
    adapter->ptp_caps.owner = & __this_module;
    #line 1357 
    adapter->ptp_caps.max_adj = 250000000;
    #line 1358 
    adapter->ptp_caps.n_alarm = 0;
    #line 1359 
    adapter->ptp_caps.n_ext_ts = 0;
    #line 1360 
    adapter->ptp_caps.n_per_out = 0;
    #line 1361 
    adapter->ptp_caps.pps = 1;
    #line 1362 
    adapter->ptp_caps.adjfreq = & ixgbe_ptp_adjfreq_82599;
    #line 1363 
    adapter->ptp_caps.adjtime = & ixgbe_ptp_adjtime;
    #line 1364 
    adapter->ptp_caps.gettimex64 = & ixgbe_ptp_gettimex;
    #line 1365 
    adapter->ptp_caps.settime64 = & ixgbe_ptp_settime;
    #line 1366 
    adapter->ptp_caps.enable = & ixgbe_ptp_feature_enable;
    #line 1367 
    adapter->ptp_setup_sdp = & ixgbe_ptp_setup_sdp_X540;
    #line 1368 
    break;
    #line 1369 
    case (unsigned int)2: 
                          #line 1369 
    ;
    #line 1370 
    snprintf((char *)(& adapter->ptp_caps.name),16UL,(char *)"%s",(char *)(& netdev->name));
    #line 1373 
    adapter->ptp_caps.owner = & __this_module;
    #line 1374 
    adapter->ptp_caps.max_adj = 250000000;
    #line 1375 
    adapter->ptp_caps.n_alarm = 0;
    #line 1376 
    adapter->ptp_caps.n_ext_ts = 0;
    #line 1377 
    adapter->ptp_caps.n_per_out = 0;
    #line 1378 
    adapter->ptp_caps.pps = 0;
    #line 1379 
    adapter->ptp_caps.adjfreq = & ixgbe_ptp_adjfreq_82599;
    #line 1380 
    adapter->ptp_caps.adjtime = & ixgbe_ptp_adjtime;
    #line 1381 
    adapter->ptp_caps.gettimex64 = & ixgbe_ptp_gettimex;
    #line 1382 
    adapter->ptp_caps.settime64 = & ixgbe_ptp_settime;
    #line 1383 
    adapter->ptp_caps.enable = & ixgbe_ptp_feature_enable;
    #line 1384 
    break;
    #line 1385 
    case (unsigned int)4: 
                          #line 1385 
    ;
    #line 1386 
    case (unsigned int)5: 
                          #line 1386 
    ;
    #line 1387 
    case (unsigned int)6: 
                          #line 1387 
    ;
    #line 1388 
    snprintf((char *)(& adapter->ptp_caps.name),16UL,(char *)"%s",(char *)(& netdev->name));
    #line 1389 
    adapter->ptp_caps.owner = & __this_module;
    #line 1390 
    adapter->ptp_caps.max_adj = 30000000;
    #line 1391 
    adapter->ptp_caps.n_alarm = 0;
    #line 1392 
    adapter->ptp_caps.n_ext_ts = 0;
    #line 1393 
    adapter->ptp_caps.n_per_out = 0;
    #line 1394 
    adapter->ptp_caps.pps = 1;
    #line 1395 
    adapter->ptp_caps.adjfreq = & ixgbe_ptp_adjfreq_X550;
    #line 1396 
    adapter->ptp_caps.adjtime = & ixgbe_ptp_adjtime;
    #line 1397 
    adapter->ptp_caps.gettimex64 = & ixgbe_ptp_gettimex;
    #line 1398 
    adapter->ptp_caps.settime64 = & ixgbe_ptp_settime;
    #line 1399 
    adapter->ptp_caps.enable = & ixgbe_ptp_feature_enable;
    #line 1400 
    adapter->ptp_setup_sdp = & ixgbe_ptp_setup_sdp_X550;
    #line 1401 
    break;
    #line 1402 
    default: 
             #line 1402 
    ;
    #line 1403 
    adapter->ptp_clock = (struct ptp_clock *)0;
    #line 1404 
    adapter->ptp_setup_sdp = (void (*)(struct ixgbe_adapter *))0;
    #line 1405 
    return -95L;
  }
  #line 1408 
  adapter->ptp_clock = ptp_clock_register(& adapter->ptp_caps,& (adapter->pdev)->dev);
  #line 1410 
  if ((int)IS_ERR_0((void *)adapter->ptp_clock) != 0) {
    #line 1411 
    err = PTR_ERR_0((void *)adapter->ptp_clock);
    #line 1412 
    adapter->ptp_clock = (struct ptp_clock *)0;
    #line 1413 
    _dev_err(& (adapter->pdev)->dev,(char *)"ptp_clock_register failed\n");
    #line 1414 
    return err;
  }
  else 
    #line 1415 
    if (adapter->ptp_clock != (struct ptp_clock *)0) 
                                                     #line 1416 
                                                     _dev_info(& (adapter->pdev)->dev,(char *)"registered PHC device on %s\n",(char *)(& netdev->name));
  #line 1422 
  adapter->tstamp_config.rx_filter = 0;
  #line 1423 
  adapter->tstamp_config.tx_type = 0;
  #line 1425 
  return 0L;
}

#line 1436  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_init(struct ixgbe_adapter *adapter)
{
  #line 1442 
  spinlock_check(& adapter->tmreg_lock);
  {
    #line 1442 
    struct lock_class_key __key;
    #line 1442 
    __raw_spin_lock_init(& adapter->tmreg_lock.__anonCompField_spinlock_25.rlock,(char *)"&(&adapter->tmreg_lock)->rlock",& __key);
  }
  #line 1445 
  if (ixgbe_ptp_create_clock(adapter) != 0L) 
                                             #line 1446 
                                             return;
  {
    #line 1449 
    struct lock_class_key __key_0;
    #line 1449 
    __init_work(& adapter->ptp_tx_work,0);
    #line 1449 
    atomic_long_t __constr_expr_34 = {.counter = 137438953408LL};
    #line 1449 
    adapter->ptp_tx_work.data = __constr_expr_34;
    #line 1449 
    lockdep_init_map(& adapter->ptp_tx_work.lockdep_map,(char *)"(work_completion)",& __key_0,0);
    #line 1449 
    INIT_LIST_HEAD_0(& adapter->ptp_tx_work.entry);
    #line 1449 
    adapter->ptp_tx_work.func = & ixgbe_ptp_tx_hwtstamp_work;
  }
  #line 1452 
  ixgbe_ptp_reset(adapter);
  #line 1455 
  cif_set_bit_1(8L,& adapter->state);
  #line 1457 
  return;
}

#line 1467  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_suspend(struct ixgbe_adapter *adapter)
{
  #line 1470 
  if (! test_and_set_bit(8L,& adapter->state)) 
                                               #line 1471 
                                               return;
  #line 1473 
  adapter->flags2 &= 4294966271U;
  #line 1474 
  if (adapter->ptp_setup_sdp != (void (*)(struct ixgbe_adapter *))0) 
    #line 1475 
    (*(adapter->ptp_setup_sdp))(adapter);
  #line 1478 
  cancel_work_sync(& adapter->ptp_tx_work);
  #line 1479 
  ixgbe_ptp_clear_tx_timestamp(adapter);
  #line 1480 
  return;
}

#line 1489  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_stop(struct ixgbe_adapter *adapter)
{
  #line 1492 
  ixgbe_ptp_suspend(adapter);
  #line 1495 
  if (adapter->ptp_clock != (struct ptp_clock *)0) {
    #line 1496 
    ptp_clock_unregister(adapter->ptp_clock);
    #line 1497 
    adapter->ptp_clock = (struct ptp_clock *)0;
    #line 1498 
    _dev_info(& (adapter->pdev)->dev,(char *)"removed PHC on %s\n",(char *)(& (adapter->netdev)->name));
  }
  #line 1500 
  return;
}

#line 121  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ptp.i.aux"
static void cif_set_bit_1(long nr, unsigned long *addr)
{
  #line 124 
  ldv_set_bit(nr,addr);
  #line 125 
  return;
}

#line 135  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ptp.i.aux"
static void INIT_LIST_HEAD_0(struct list_head *list)
{
  #line 138 
  ldv_init_list_head(list);
  #line 139 
  return;
}

#line 212  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ptp.i.aux"
static long PTR_ERR_0(void *ptr)
{
  #line 215 
  return ldv_ptr_err(ptr);
}

#line 219  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ptp.i.aux"
static bool IS_ERR_0(void *ptr)
{
  #line 222 
  return ldv_is_err(ptr);
}

#line 226  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ptp.i.aux"
static bool IS_ERR_OR_NULL(void *ptr)
{
  #line 229 
  return ldv_is_err_or_null(ptr);
}

#line 694  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ptp.i.aux"
static void cif___ldv_spin_lock_tmreg_lock_of_ixgbe_adapter(spinlock_t *lock)
{
  #line 697 
  ldv_spin_model_lock((char *)"tmreg_lock_of_ixgbe_adapter");
  #line 699 
  __ldv_spin_lock(lock);
  #line 700 
  return;
}

#line 703  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ptp.i.aux"
static void cif_spin_unlock_irqrestore_tmreg_lock_of_ixgbe_adapter(spinlock_t *lock, unsigned long flags)
{
  #line 706 
  ldv_spin_model_unlock((char *)"tmreg_lock_of_ixgbe_adapter");
  #line 708 
  spin_unlock_irqrestore(lock,flags);
  #line 709 
  return;
}

#line 712  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ptp.i.aux"
static bool cif_schedule_work_0(struct work_struct *work)
{
  #line 716 
  return emg_schedule_work(work);
}

#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/err.h"
#line 212  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_sysfs.i.aux"
static long PTR_ERR_1(void *ptr);
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/err.h"
#line 219  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_sysfs.i.aux"
static bool IS_ERR_1(void *ptr);
#line 27  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/device.h"
#line 27 
void *ldv_devm_kzalloc(size_t size, gfp_t flags);
#line 937  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
#line 687  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_sysfs.i.aux"
static void *cif_devm_kzalloc(struct device *dev, size_t size, gfp_t flags);
#line 402  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/hwmon.h"
#line 402 
struct device *devm_hwmon_device_register_with_groups(struct device *, char *, void *, struct attribute_group **);
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c"
static ssize_t ixgbe_hwmon_show_location(struct device *dev, struct device_attribute *attr, char *buf)
{
  #line 21 
  void *__mptr;
  #line 21 
  __mptr = (void *)attr;
  #line 21 
  struct hwmon_attr *ixgbe_attr = ((struct hwmon_attr *)__mptr);
  #line 23 
  return (long)sprintf(buf,(char *)"loc%u\n",(int)(ixgbe_attr->sensor)->location);
}

#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c"
static ssize_t ixgbe_hwmon_show_temp(struct device *dev, struct device_attribute *attr, char *buf)
{
  #line 31 
  void *__mptr;
  #line 33 
  unsigned int value;
  #line 31 
  __mptr = (void *)attr;
  #line 31 
  struct hwmon_attr *ixgbe_attr = ((struct hwmon_attr *)__mptr);
  #line 36 
  (*((ixgbe_attr->hw)->mac.ops.get_thermal_sensor_data))(ixgbe_attr->hw);
  #line 38 
  value = (unsigned int)(ixgbe_attr->sensor)->temp;
  #line 41 
  value *= 1000U;
  #line 43 
  return (long)sprintf(buf,(char *)"%u\n",value);
}

#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c"
static ssize_t ixgbe_hwmon_show_cautionthresh(struct device *dev, struct device_attribute *attr, char *buf)
{
  #line 50 
  void *__mptr;
  #line 50 
  __mptr = (void *)attr;
  #line 50 
  struct hwmon_attr *ixgbe_attr = ((struct hwmon_attr *)__mptr);
  #line 52 
  unsigned int value = (unsigned int)(ixgbe_attr->sensor)->caution_thresh;
  #line 55 
  value *= 1000U;
  #line 57 
  return (long)sprintf(buf,(char *)"%u\n",value);
}

#line 60  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c"
static ssize_t ixgbe_hwmon_show_maxopthresh(struct device *dev, struct device_attribute *attr, char *buf)
{
  #line 64 
  void *__mptr;
  #line 64 
  __mptr = (void *)attr;
  #line 64 
  struct hwmon_attr *ixgbe_attr = ((struct hwmon_attr *)__mptr);
  #line 66 
  unsigned int value = (unsigned int)(ixgbe_attr->sensor)->max_op_thresh;
  #line 69 
  value *= 1000U;
  #line 71 
  return (long)sprintf(buf,(char *)"%u\n",value);
}

#line 84  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c"
static int ixgbe_add_hwmon_attr(struct ixgbe_adapter *adapter, unsigned int offset, int type)
{
  #line 86 
  int rc;
  #line 87 
  unsigned int n_attr;
  #line 88 
  struct hwmon_attr *ixgbe_attr;
  #line 90 
  n_attr = (adapter->ixgbe_hwmon_buff)->n_hwmon;
  #line 91 
  ixgbe_attr = & (adapter->ixgbe_hwmon_buff)->hwmon_list[n_attr];
  #line 93 
  switch (type) {
    #line 94 
    case 0: 
            #line 94 
    ;
    #line 95 
    ixgbe_attr->dev_attr.show = & ixgbe_hwmon_show_location;
    #line 96 
    snprintf((char *)(& ixgbe_attr->name),12UL,(char *)"temp%u_label",offset + 1U);
    #line 98 
    break;
    #line 99 
    case 1: 
            #line 99 
    ;
    #line 100 
    ixgbe_attr->dev_attr.show = & ixgbe_hwmon_show_temp;
    #line 101 
    snprintf((char *)(& ixgbe_attr->name),12UL,(char *)"temp%u_input",offset + 1U);
    #line 103 
    break;
    #line 104 
    case 2: 
            #line 104 
    ;
    #line 105 
    ixgbe_attr->dev_attr.show = & ixgbe_hwmon_show_cautionthresh;
    #line 106 
    snprintf((char *)(& ixgbe_attr->name),12UL,(char *)"temp%u_max",offset + 1U);
    #line 108 
    break;
    #line 109 
    case 3: 
            #line 109 
    ;
    #line 110 
    ixgbe_attr->dev_attr.show = & ixgbe_hwmon_show_maxopthresh;
    #line 111 
    snprintf((char *)(& ixgbe_attr->name),12UL,(char *)"temp%u_crit",offset + 1U);
    #line 113 
    break;
    #line 114 
    default: 
             #line 114 
    ;
    #line 115 
    rc = -1;
    #line 116 
    return rc;
  }
  #line 120 
  ixgbe_attr->sensor = & adapter->hw.mac.thermal_sensor_data.sensor[offset];
  #line 122 
  ixgbe_attr->hw = & adapter->hw;
  #line 123 
  ixgbe_attr->dev_attr.store = (ssize_t (*)(struct device *, struct device_attribute *, char *, size_t ))0;
  #line 124 
  ixgbe_attr->dev_attr.attr.mode = (unsigned short)292U;
  #line 125 
  ixgbe_attr->dev_attr.attr.name = (char *)(& ixgbe_attr->name);
  {
    #line 126 
    struct lock_class_key __key;
    #line 126 
    ixgbe_attr->dev_attr.attr.key = & __key;
  }
  #line 128 
  (adapter->ixgbe_hwmon_buff)->attrs[n_attr] = & ixgbe_attr->dev_attr.attr;
  #line 130 
  ((adapter->ixgbe_hwmon_buff)->n_hwmon) ++;
  #line 132 
  return 0;
}

#line 135  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c"
static void ixgbe_sysfs_del_adapter(struct ixgbe_adapter *adapter)
{
  #line 137 
  return;
}

#line 140  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c"
void ixgbe_sysfs_exit(struct ixgbe_adapter *adapter)
{
  #line 142 
  ixgbe_sysfs_del_adapter(adapter);
  #line 143 
  return;
}

#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c"
int ixgbe_sysfs_init(struct ixgbe_adapter *adapter)
{
  #line 148 
  struct hwmon_buff *ixgbe_hwmon;
  #line 149 
  struct device *hwmon_dev;
  #line 150 
  unsigned int i;
  #line 151 
  int rc = 0;
  #line 154 
  if (adapter->hw.mac.ops.init_thermal_sensor_thresh == (s32 (*)(struct ixgbe_hw *))0) 
    #line 155 
    goto exit;
  #line 159 
  if ((*(adapter->hw.mac.ops.init_thermal_sensor_thresh))(& adapter->hw) != 0) 
    #line 160 
    goto exit;
  #line 162 
  ixgbe_hwmon = (struct hwmon_buff *)cif_devm_kzalloc(& (adapter->pdev)->dev,1224UL,3264U);
  #line 164 
  if (ixgbe_hwmon == (struct hwmon_buff *)0) {
    #line 165 
    rc = -12;
    #line 166 
    goto exit;
  }
  #line 168 
  adapter->ixgbe_hwmon_buff = ixgbe_hwmon;
  #line 170 
  i = 0U;
  #line 170 
  while (i <= 2U) {
    #line 175 
    if ((unsigned int)adapter->hw.mac.thermal_sensor_data.sensor[i].location == 0U) 
      #line 176 
      goto __Cont;
    #line 179 
    rc = ixgbe_add_hwmon_attr(adapter,i,2);
    #line 180 
    if (rc != 0) 
                 #line 181 
                 goto exit;
    #line 182 
    rc = ixgbe_add_hwmon_attr(adapter,i,0);
    #line 183 
    if (rc != 0) 
                 #line 184 
                 goto exit;
    #line 185 
    rc = ixgbe_add_hwmon_attr(adapter,i,1);
    #line 186 
    if (rc != 0) 
                 #line 187 
                 goto exit;
    #line 188 
    rc = ixgbe_add_hwmon_attr(adapter,i,3);
    #line 189 
    if (rc != 0) 
                 #line 190 
                 goto exit;
    #line 170 
    __Cont: 
            #line 170 
    i ++;
  }
  #line 193 
  ixgbe_hwmon->groups[0] = & ixgbe_hwmon->group;
  #line 194 
  ixgbe_hwmon->group.attrs = (struct attribute **)(& ixgbe_hwmon->attrs);
  #line 196 
  hwmon_dev = devm_hwmon_device_register_with_groups(& (adapter->pdev)->dev,(char *)"ixgbe",(void *)ixgbe_hwmon,(struct attribute_group **)(& ixgbe_hwmon->groups));
  #line 200 
  if ((int)IS_ERR_1((void *)hwmon_dev) != 0) {
    #line 201 
    rc = (int)PTR_ERR_1((void *)hwmon_dev);
  }
  #line 202 
  exit: 
        #line 202 
  ;
  #line 203 
  return rc;
}

#line 212  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_sysfs.i.aux"
static long PTR_ERR_1(void *ptr)
{
  #line 215 
  return ldv_ptr_err(ptr);
}

#line 219  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_sysfs.i.aux"
static bool IS_ERR_1(void *ptr)
{
  #line 222 
  return ldv_is_err(ptr);
}

#line 687  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_sysfs.i.aux"
static void *cif_devm_kzalloc(struct device *dev, size_t size, gfp_t flags)
{
  #line 690 
  return ldv_devm_kzalloc(size,flags);
}

#line 10  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
#line 10 
u16 ixgbe_get_pcie_msix_count_generic(struct ixgbe_hw *hw);
#line 12 
#line 12 
s32 ixgbe_init_hw_generic(struct ixgbe_hw *hw);
#line 13 
#line 13 
s32 ixgbe_start_hw_generic(struct ixgbe_hw *hw);
#line 15 
#line 15 
s32 ixgbe_clear_hw_cntrs_generic(struct ixgbe_hw *hw);
#line 18 
#line 18 
s32 ixgbe_get_mac_addr_generic(struct ixgbe_hw *hw, u8 *mac_addr);
#line 21 
#line 21 
s32 ixgbe_get_bus_info_generic(struct ixgbe_hw *hw);
#line 22 
#line 22 
void ixgbe_set_lan_id_multi_port_pcie(struct ixgbe_hw *hw);
#line 23 
#line 23 
s32 ixgbe_stop_adapter_generic(struct ixgbe_hw *hw);
#line 25 
#line 25 
s32 ixgbe_led_on_generic(struct ixgbe_hw *hw, u32 index);
#line 26 
#line 26 
s32 ixgbe_led_off_generic(struct ixgbe_hw *hw, u32 index);
#line 27 
#line 27 
s32 ixgbe_init_led_link_act_generic(struct ixgbe_hw *hw);
#line 30 
#line 30 
s32 ixgbe_write_eeprom_generic(struct ixgbe_hw *hw, u16 offset, u16 data);
#line 31 
#line 31 
s32 ixgbe_write_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw, u16 offset, u16 words, u16 *data);
#line 33 
#line 33 
s32 ixgbe_read_eerd_generic(struct ixgbe_hw *hw, u16 offset, u16 *data);
#line 34 
#line 34 
s32 ixgbe_read_eerd_buffer_generic(struct ixgbe_hw *hw, u16 offset, u16 words, u16 *data);
#line 43 
#line 43 
s32 ixgbe_calc_eeprom_checksum_generic(struct ixgbe_hw *hw);
#line 44 
#line 44 
s32 ixgbe_validate_eeprom_checksum_generic(struct ixgbe_hw *hw, u16 *checksum_val);
#line 46 
#line 46 
s32 ixgbe_update_eeprom_checksum_generic(struct ixgbe_hw *hw);
#line 48 
#line 48 
s32 ixgbe_set_rar_generic(struct ixgbe_hw *hw, u32 index, u8 *addr, u32 vmdq, u32 enable_addr);
#line 50 
#line 50 
s32 ixgbe_clear_rar_generic(struct ixgbe_hw *hw, u32 index);
#line 51 
#line 51 
s32 ixgbe_init_rx_addrs_generic(struct ixgbe_hw *hw);
#line 52 
#line 52 
s32 ixgbe_update_mc_addr_list_generic(struct ixgbe_hw *hw, struct net_device *netdev);
#line 54 
#line 54 
s32 ixgbe_enable_mc_generic(struct ixgbe_hw *hw);
#line 55 
#line 55 
s32 ixgbe_disable_mc_generic(struct ixgbe_hw *hw);
#line 58 
#line 58 
s32 ixgbe_enable_rx_dma_generic(struct ixgbe_hw *hw, u32 regval);
#line 60 
#line 60 
s32 ixgbe_setup_fc_generic(struct ixgbe_hw *hw);
#line 62 
#line 62 
void ixgbe_fc_autoneg(struct ixgbe_hw *hw);
#line 64 
#line 64 
s32 ixgbe_acquire_swfw_sync(struct ixgbe_hw *hw, u32 mask);
#line 65 
#line 65 
void ixgbe_release_swfw_sync(struct ixgbe_hw *hw, u32 mask);
#line 80 
#line 80 
s32 prot_autoc_read_generic(struct ixgbe_hw *hw, bool *locked, u32 *reg_val);
#line 81 
#line 81 
s32 prot_autoc_write_generic(struct ixgbe_hw *hw, u32 reg_val, bool locked);
#line 83 
#line 83 
s32 ixgbe_blink_led_start_generic(struct ixgbe_hw *hw, u32 index);
#line 84 
#line 84 
s32 ixgbe_blink_led_stop_generic(struct ixgbe_hw *hw, u32 index);
#line 103 
#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
u32 ixgbe_mvals_8259X[23U];
#line 123  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
#line 123 
void ixgbe_disable_rx_generic(struct ixgbe_hw *hw);
#line 124 
#line 124 
void ixgbe_enable_rx_generic(struct ixgbe_hw *hw);
#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static void ixgbe_write_reg_4(struct ixgbe_hw *hw, u32 reg, u32 value)
{
  #line 147 
  union __anonunion___u_6301 __u;
  #line 146 
  __read_once_size((void *)(& hw->hw_addr),(void *)(& __u.__c),8);
  #line 146 
  u8 *reg_addr = (__u.__val);
  #line 148 
  if ((int)ixgbe_removed((void *)reg_addr) != 0) 
                                                 #line 149 
                                                 return;
  #line 150 
  writel(value,(void *)(reg_addr + (unsigned long)reg));
  #line 151 
  return;
}

#line 126  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h"
#line 126 
s32 ixgbe_identify_phy_generic(struct ixgbe_hw *hw);
#line 127 
#line 127 
s32 ixgbe_reset_phy_generic(struct ixgbe_hw *hw);
#line 128 
#line 128 
s32 ixgbe_read_phy_reg_generic(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type, u16 *phy_data);
#line 130 
#line 130 
s32 ixgbe_write_phy_reg_generic(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type, u16 phy_data);
#line 132 
#line 132 
s32 ixgbe_read_phy_reg_mdi(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type, u16 *phy_data);
#line 134 
#line 134 
s32 ixgbe_write_phy_reg_mdi(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type, u16 phy_data);
#line 136 
#line 136 
s32 ixgbe_setup_phy_link_generic(struct ixgbe_hw *hw);
#line 137 
#line 137 
s32 ixgbe_setup_phy_link_speed_generic(struct ixgbe_hw *hw, ixgbe_link_speed speed, bool autoneg_wait_to_complete);
#line 140 
#line 140 
s32 ixgbe_get_copper_link_capabilities_generic(struct ixgbe_hw *hw, ixgbe_link_speed *speed, bool *autoneg);
#line 146 
#line 146 
s32 ixgbe_check_phy_link_tnx(struct ixgbe_hw *hw, ixgbe_link_speed *speed, bool *link_up);
#line 149 
#line 149 
s32 ixgbe_setup_phy_link_tnx(struct ixgbe_hw *hw);
#line 151 
#line 151 
s32 ixgbe_reset_phy_nl(struct ixgbe_hw *hw);
#line 153 
#line 153 
s32 ixgbe_identify_module_generic(struct ixgbe_hw *hw);
#line 155 
#line 155 
s32 ixgbe_get_sfp_init_sequence_offsets(struct ixgbe_hw *hw, u16 *list_offset, u16 *data_offset);
#line 158 
#line 158 
s32 ixgbe_tn_check_overtemp(struct ixgbe_hw *hw);
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
#line 627 
static s32 ixgbe_setup_copper_link_82598(struct ixgbe_hw *hw, ixgbe_link_speed speed, bool autoneg_wait_to_complete);
#line 21 
#line 1022 
static s32 ixgbe_read_i2c_eeprom_82598(struct ixgbe_hw *hw, u8 byte_offset, u8 *eeprom_data);
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static void ixgbe_set_pcie_completion_timeout(struct ixgbe_hw *hw)
{
  #line 37 
  u16 pcie_devctl2;
  #line 36 
  u32 gcr = ixgbe_read_reg(hw,69632U);
  #line 39 
  if ((int)ixgbe_removed((void *)hw->hw_addr) != 0) 
                                                    #line 40 
                                                    return;
  #line 43 
  if ((gcr & 61440U) != 0U) 
                            #line 44 
                            goto out;
  #line 50 
  if ((gcr & 262144U) == 0U) {
    #line 51 
    gcr |= 4096U;
    #line 52 
    goto out;
  }
  #line 60 
  pcie_devctl2 = ixgbe_read_pci_cfg_word(hw,200U);
  #line 61 
  pcie_devctl2 = (unsigned short)((unsigned int)pcie_devctl2 | 5U);
  #line 62 
  ixgbe_write_pci_cfg_word(hw,200U,(unsigned short)((int)pcie_devctl2));
  #line 63 
  out: 
       #line 63 
  ;
  #line 65 
  gcr &= 4294901759U;
  #line 66 
  ixgbe_write_reg_4(hw,69632U,gcr);
  #line 67 
  return;
}

#line 69  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_get_invariants_82598(struct ixgbe_hw *hw)
{
  #line 71 
  struct ixgbe_mac_info *mac = & hw->mac;
  #line 74 
  ixgbe_identify_phy_generic(hw);
  #line 76 
  mac->mcft_size = 128U;
  #line 77 
  mac->vft_size = 128U;
  #line 78 
  mac->num_rar_entries = 16U;
  #line 79 
  mac->rx_pb_size = 512U;
  #line 80 
  mac->max_rx_queues = 64U;
  #line 81 
  mac->max_tx_queues = 32U;
  #line 82 
  mac->max_msix_vectors = ixgbe_get_pcie_msix_count_generic(hw);
  #line 84 
  return 0;
}

#line 96  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_init_phy_ops_82598(struct ixgbe_hw *hw)
{
  #line 100 
  s32 ret_val;
  #line 101 
  u16 list_offset;
  #line 101 
  u16 data_offset;
  #line 98 
  struct ixgbe_mac_info *mac = & hw->mac;
  #line 99 
  struct ixgbe_phy_info *phy = & hw->phy;
  #line 104 
  (*(phy->ops.identify))(hw);
  #line 107 
  if ((*(mac->ops.get_media_type))(hw) == (unsigned int)ixgbe_media_type_copper) {
    #line 108 
    mac->ops.setup_link = & ixgbe_setup_copper_link_82598;
    #line 109 
    mac->ops.get_link_capabilities = & ixgbe_get_copper_link_capabilities_generic;
  }
  #line 113 
  switch ((unsigned int)hw->phy.type) {
    #line 114 
    case (unsigned int)2: 
                          #line 114 
    ;
    #line 115 
    phy->ops.setup_link = & ixgbe_setup_phy_link_tnx;
    #line 116 
    phy->ops.check_link = & ixgbe_check_phy_link_tnx;
    #line 117 
    break;
    #line 118 
    case (unsigned int)12: 
                           #line 118 
    ;
    #line 119 
    phy->ops.reset = & ixgbe_reset_phy_nl;
    #line 122 
    ret_val = (*(phy->ops.identify_sfp))(hw);
    #line 123 
    if (ret_val != 0) 
                      #line 124 
                      return ret_val;
    #line 125 
    if (hw->phy.sfp_type == (unsigned int)ixgbe_sfp_type_unknown) 
                                                                  #line 126 
                                                                  return -19;
    #line 129 
    ret_val = ixgbe_get_sfp_init_sequence_offsets(hw,& list_offset,& data_offset);
    #line 132 
    if (ret_val != 0) 
                      #line 133 
                      return -19;
    #line 134 
    break;
    #line 135 
    default: 
             #line 135 
    ;
    #line 136 
    break;
  }
  #line 139 
  return 0;
}

#line 151  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_start_hw_82598(struct ixgbe_hw *hw)
{
  #line 153 
  s32 ret_val;
  #line 155 
  ret_val = ixgbe_start_hw_generic(hw);
  #line 156 
  if (ret_val != 0) 
                    #line 157 
                    return ret_val;
  #line 160 
  ixgbe_set_pcie_completion_timeout(hw);
  #line 162 
  return 0;
}

#line 173  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_get_link_capabilities_82598(struct ixgbe_hw *hw, ixgbe_link_speed *speed, bool *autoneg)
{
  #line 177 
  u32 autoc = 0U;
  #line 184 
  if ((int)hw->mac.orig_link_settings_stored != 0) 
                                                   #line 185 
                                                   autoc = hw->mac.orig_autoc; else 
                                                                    #line 187 
                                                                    autoc = ixgbe_read_reg(hw,17056U);
  #line 189 
  switch (autoc & 57344U) {
    #line 190 
    case (unsigned int)0: 
                          #line 190 
    ;
    #line 191 
    *speed = 32U;
    #line 192 
    *autoneg = (_Bool)0;
    #line 193 
    break;
    #line 195 
    case (unsigned int)8192: 
                             #line 195 
    ;
    #line 196 
    *speed = 128U;
    #line 197 
    *autoneg = (_Bool)0;
    #line 198 
    break;
    #line 200 
    case (unsigned int)16384: 
                              #line 200 
    ;
    #line 201 
    *speed = 32U;
    #line 202 
    *autoneg = (_Bool)1;
    #line 203 
    break;
    #line 205 
    case (unsigned int)32768: 
                              #line 205 
    ;
    #line 206 
    case (unsigned int)49152: 
                              #line 206 
    ;
    #line 207 
    *speed = 0U;
    #line 208 
    if ((autoc & 2147483648U) != 0U) 
                                     #line 209 
                                     *speed |= 128U;
    #line 210 
    if ((autoc & 1073741824U) != 0U) 
                                     #line 211 
                                     *speed |= 32U;
    #line 212 
    *autoneg = (_Bool)1;
    #line 213 
    break;
    #line 215 
    default: 
             #line 215 
    ;
    #line 216 
    return -8;
  }
  #line 219 
  return 0;
}

#line 228  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static enum ixgbe_media_type ixgbe_get_media_type_82598(struct ixgbe_hw *hw)
{
  #line 231 
  switch ((unsigned int)hw->phy.type) {
    #line 232 
    case (unsigned int)9: 
                          #line 232 
    ;
    #line 233 
    case (unsigned int)2: 
                          #line 233 
    ;
    #line 234 
    return ixgbe_media_type_copper;
    #line 236 
    default: 
             #line 236 
    ;
    #line 237 
    break;
  }
  #line 241 
  switch ((int)hw->device_id) {
    #line 242 
    case 4278: 
               #line 242 
    ;
    #line 243 
    case 5384: 
               #line 243 
    ;
    #line 245 
    return ixgbe_media_type_backplane;
    #line 247 
    case 4294: 
               #line 247 
    ;
    #line 248 
    case 4295: 
               #line 248 
    ;
    #line 249 
    case 4337: 
               #line 249 
    ;
    #line 250 
    case 4321: 
               #line 250 
    ;
    #line 251 
    case 4340: 
               #line 251 
    ;
    #line 252 
    case 4315: 
               #line 252 
    ;
    #line 253 
    return ixgbe_media_type_fiber;
    #line 255 
    case 4317: 
               #line 255 
    ;
    #line 256 
    case 4332: 
               #line 256 
    ;
    #line 257 
    return ixgbe_media_type_cx4;
    #line 259 
    case 4296: 
               #line 259 
    ;
    #line 260 
    case 5387: 
               #line 260 
    ;
    #line 261 
    return ixgbe_media_type_copper;
    #line 263 
    default: 
             #line 263 
    ;
    #line 264 
    return ixgbe_media_type_unknown;
  }
}

#line 274  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_fc_enable_82598(struct ixgbe_hw *hw)
{
  #line 276 
  u32 fctrl_reg;
  #line 277 
  u32 rmcs_reg;
  #line 278 
  u32 reg;
  #line 279 
  u32 fcrtl;
  #line 279 
  u32 fcrth;
  #line 281 
  int i;
  #line 282 
  bool link_up;
  #line 280 
  u32 link_speed = 0U;
  #line 285 
  if ((unsigned int)hw->fc.pause_time == 0U) 
                                             #line 286 
                                             return -13;
  #line 289 
  i = 0;
  #line 289 
  while (i <= 7) {
    #line 290 
    if (((unsigned int)hw->fc.current_mode & 2U) != 0U && hw->fc.high_water[i] != 0U) 
      #line 292 
      if (hw->fc.low_water[i] == 0U || hw->fc.low_water[i] >= hw->fc.high_water[i]) {
        {
          #line 294 
          bool branch;
          #line 294 
          struct _ddebug __UNIQUE_ID_ddebug443 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_fc_enable_82598", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c", .format = (char *)"Invalid water mark configuration\n", .lineno = (unsigned int)294U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
          #line 294 
          branch = arch_static_branch(& __UNIQUE_ID_ddebug443.key.dd_key_false.key,(_Bool)0);
          #line 294 
          if ((long)((long)((int)branch != 0)) != 0L) 
                                                      #line 294 
                                                      __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug443,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Invalid water mark configuration\n");
        }
        #line 295 
        return -13;
      }
    #line 289 
    i ++;
  }
  #line 305 
  (*(hw->mac.ops.check_link))(hw,& link_speed,& link_up,(_Bool)0);
  #line 306 
  if ((int)link_up != 0 && link_speed == 32U) 
    #line 307 
    switch ((unsigned int)hw->fc.requested_mode) {
      #line 308 
      case (unsigned int)3: 
                            #line 308 
      ;
      #line 309 
      hw->fc.requested_mode = ixgbe_fc_tx_pause;
      #line 310 
      break;
      #line 311 
      case (unsigned int)1: 
                            #line 311 
      ;
      #line 312 
      hw->fc.requested_mode = ixgbe_fc_none;
      #line 313 
      break;
      #line 314 
      default: 
               #line 314 
      ;
      #line 316 
      break;
    }
  #line 321 
  (*(hw->mac.ops.fc_autoneg))(hw);
  #line 324 
  fctrl_reg = ixgbe_read_reg(hw,20608U);
  #line 325 
  fctrl_reg &= 4294918143U;
  #line 327 
  rmcs_reg = ixgbe_read_reg(hw,15616U);
  #line 328 
  rmcs_reg &= 4294967271U;
  #line 340 
  switch ((unsigned int)hw->fc.current_mode) {
    #line 341 
    case (unsigned int)0: 
                          #line 341 
    ;
    #line 346 
    break;
    #line 347 
    case (unsigned int)1: 
                          #line 347 
    ;
    #line 356 
    fctrl_reg |= 32768U;
    #line 357 
    break;
    #line 358 
    case (unsigned int)2: 
                          #line 358 
    ;
    #line 363 
    rmcs_reg |= 8U;
    #line 364 
    break;
    #line 365 
    case (unsigned int)3: 
                          #line 365 
    ;
    #line 367 
    fctrl_reg |= 32768U;
    #line 368 
    rmcs_reg |= 8U;
    #line 369 
    break;
    #line 370 
    default: 
             #line 370 
    ;
    {
      #line 371 
      bool branch_0;
      #line 371 
      struct _ddebug __UNIQUE_ID_ddebug444 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_fc_enable_82598", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c", .format = (char *)"Flow control param set incorrectly\n", .lineno = (unsigned int)371U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 371 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug444.key.dd_key_false.key,(_Bool)0);
      #line 371 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 371 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug444,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Flow control param set incorrectly\n");
    }
    #line 372 
    return -4;
  }
  #line 376 
  fctrl_reg |= 8192U;
  #line 377 
  ixgbe_write_reg_4(hw,20608U,fctrl_reg);
  #line 378 
  ixgbe_write_reg_4(hw,15616U,rmcs_reg);
  #line 381 
  i = 0;
  #line 381 
  while (i <= 7) {
    #line 382 
    if (((unsigned int)hw->fc.current_mode & 2U) != 0U && hw->fc.high_water[i] != 0U) {
      #line 384 
      fcrtl = (hw->fc.low_water[i] << 10) | 2147483648U;
      #line 385 
      fcrth = (hw->fc.high_water[i] << 10) | 2147483648U;
      #line 386 
      ixgbe_write_reg_4(hw,(unsigned int)((i + 1604) * 8),fcrtl);
      #line 387 
      ixgbe_write_reg_4(hw,(unsigned int)((i + 1612) * 8),fcrth);
    }
    else {
      #line 389 
      ixgbe_write_reg_4(hw,(unsigned int)((i + 1604) * 8),0U);
      #line 390 
      ixgbe_write_reg_4(hw,(unsigned int)((i + 1612) * 8),0U);
    }
    #line 381 
    i ++;
  }
  #line 396 
  reg = (unsigned int)((int)hw->fc.pause_time * 65537);
  #line 397 
  i = 0;
  #line 397 
  while (i <= 3) {
    #line 398 
    ixgbe_write_reg_4(hw,(unsigned int)((i + 3200) * 4),reg);
    #line 397 
    i ++;
  }
  #line 401 
  ixgbe_write_reg_4(hw,12960U,(unsigned int)hw->fc.pause_time / 2U);
  #line 403 
  return 0;
}

#line 414  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_start_mac_link_82598(struct ixgbe_hw *hw, bool autoneg_wait_to_complete)
{
  #line 417 
  u32 autoc_reg;
  #line 418 
  u32 links_reg;
  #line 419 
  u32 i;
  #line 420 
  s32 status = 0;
  #line 423 
  autoc_reg = ixgbe_read_reg(hw,17056U);
  #line 424 
  autoc_reg |= 4096U;
  #line 425 
  ixgbe_write_reg_4(hw,17056U,autoc_reg);
  #line 428 
  if ((int)autoneg_wait_to_complete != 0) 
    #line 429 
    if ((autoc_reg & 57344U) == 32768U || (autoc_reg & 57344U) == 49152U) {
      #line 433 
      links_reg = 0U;
      #line 434 
      i = 0U;
      #line 434 
      while (i <= 44U) {
        #line 435 
        links_reg = ixgbe_read_reg(hw,17060U);
        #line 436 
        if ((links_reg & 2147483648U) != 0U) 
                                             #line 437 
                                             break;
        #line 438 
        msleep(100U);
        #line 434 
        i ++;
      }
      #line 440 
      if ((links_reg & 2147483648U) == 0U) {
        #line 441 
        status = -14;
        {
          #line 442 
          bool branch;
          #line 442 
          struct _ddebug __UNIQUE_ID_ddebug445 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_start_mac_link_82598", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c", .format = (char *)"Autonegotiation did not complete.\n", .lineno = (unsigned int)442U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
          #line 442 
          branch = arch_static_branch(& __UNIQUE_ID_ddebug445.key.dd_key_false.key,(_Bool)0);
          #line 442 
          if ((long)((long)((int)branch != 0)) != 0L) 
                                                      #line 442 
                                                      __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug445,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Autonegotiation did not complete.\n");
        }
      }
    }
  #line 448 
  msleep(50U);
  #line 450 
  return status;
}

#line 460  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_validate_link_ready(struct ixgbe_hw *hw)
{
  #line 462 
  u32 timeout;
  #line 463 
  u16 an_reg;
  #line 465 
  if ((unsigned int)hw->device_id != 5387U) 
                                            #line 466 
                                            return 0;
  #line 468 
  timeout = 0U;
  #line 468 
  while (timeout <= 49U) {
    #line 470 
    (*(hw->phy.ops.read_reg))(hw,1U,7U,& an_reg);
    #line 472 
    if (((int)an_reg & 32) != 0 && ((int)an_reg & 4) != 0) 
                                                           #line 474 
                                                           break;
    #line 476 
    msleep(100U);
    #line 469 
    timeout ++;
  }
  #line 479 
  if (timeout == 50U) {
    {
      #line 480 
      bool branch;
      #line 480 
      struct _ddebug __UNIQUE_ID_ddebug446 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_validate_link_ready", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c", .format = (char *)"Link was indicated but link is down\n", .lineno = (unsigned int)480U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 480 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug446.key.dd_key_false.key,(_Bool)0);
      #line 480 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 480 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug446,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Link was indicated but link is down\n");
    }
    #line 481 
    return -8;
  }
  #line 484 
  return 0;
}

#line 496  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_check_mac_link_82598(struct ixgbe_hw *hw, ixgbe_link_speed *speed, bool *link_up, bool link_up_wait_to_complete)
{
  #line 500 
  u32 links_reg;
  #line 501 
  u32 i;
  #line 502 
  u16 link_reg;
  #line 502 
  u16 adapt_comp_reg;
  #line 510 
  if (hw->phy.type == (unsigned int)ixgbe_phy_nl) {
    #line 511 
    (*(hw->phy.ops.read_reg))(hw,51103U,1U,& link_reg);
    #line 512 
    (*(hw->phy.ops.read_reg))(hw,51103U,1U,& link_reg);
    #line 513 
    (*(hw->phy.ops.read_reg))(hw,49164U,1U,& adapt_comp_reg);
    #line 515 
    if ((int)link_up_wait_to_complete != 0) {
      #line 516 
      i = 0U;
      #line 516 
      while (i <= 89U) {
        #line 517 
        if (((int)link_reg & 1) != 0 && ((int)adapt_comp_reg & 1) == 0) {
          #line 519 
          *link_up = (_Bool)1;
          #line 520 
          break;
        }
        else 
             #line 522 
             *link_up = (_Bool)0;
        #line 524 
        msleep(100U);
        #line 525 
        (*(hw->phy.ops.read_reg))(hw,51103U,1U,& link_reg);
        #line 528 
        (*(hw->phy.ops.read_reg))(hw,49164U,1U,& adapt_comp_reg);
        #line 516 
        i ++;
      }
    }
    else 
      #line 533 
      if (((int)link_reg & 1) != 0 && ((int)adapt_comp_reg & 1) == 0) 
        #line 534 
        *link_up = (_Bool)1; else 
                                  #line 536 
                                  *link_up = (_Bool)0;
    #line 539 
    if (! *link_up) 
                    #line 540 
                    return 0;
  }
  #line 543 
  links_reg = ixgbe_read_reg(hw,17060U);
  #line 544 
  if ((int)link_up_wait_to_complete != 0) {
    #line 545 
    i = 0U;
    #line 545 
    while (i <= 89U) {
      #line 546 
      if ((links_reg & 1073741824U) != 0U) {
        #line 547 
        *link_up = (_Bool)1;
        #line 548 
        break;
      }
      else 
           #line 550 
           *link_up = (_Bool)0;
      #line 552 
      msleep(100U);
      #line 553 
      links_reg = ixgbe_read_reg(hw,17060U);
      #line 545 
      i ++;
    }
  }
  else 
    #line 556 
    if ((links_reg & 1073741824U) != 0U) 
                                         #line 557 
                                         *link_up = (_Bool)1; else 
                                                                   #line 559 
                                                                   *link_up = (_Bool)0;
  #line 562 
  if ((links_reg & 536870912U) != 0U) 
                                      #line 563 
                                      *speed = 128U; else 
                                                          #line 565 
                                                          *speed = 32U;
  #line 567 
  if ((unsigned int)hw->device_id == 5387U && (int)*link_up != 0) {
    #line 567 
    if (ixgbe_validate_link_ready(hw) != 0) 
                                            #line 569 
                                            *link_up = (_Bool)0;
  }
  #line 571 
  return 0;
}

#line 582  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_setup_mac_link_82598(struct ixgbe_hw *hw, ixgbe_link_speed speed, bool autoneg_wait_to_complete)
{
  #line 586 
  bool autoneg = (_Bool)0;
  #line 587 
  ixgbe_link_speed link_capabilities = 0U;
  #line 588 
  u32 curr_autoc = ixgbe_read_reg(hw,17056U);
  #line 589 
  u32 autoc = curr_autoc;
  #line 590 
  u32 link_mode = autoc & 57344U;
  #line 593 
  ixgbe_get_link_capabilities_82598(hw,& link_capabilities,& autoneg);
  #line 594 
  speed &= link_capabilities;
  #line 596 
  if (speed == 0U) 
                   #line 597 
                   return -8;
  else 
    #line 600 
    if (link_mode == 32768U || link_mode == 49152U) {
      #line 602 
      autoc &= 1073741823U;
      #line 603 
      if ((speed & 128U) != 0U) 
                                #line 604 
                                autoc |= 2147483648U;
      #line 605 
      if ((speed & 32U) != 0U) 
                               #line 606 
                               autoc |= 1073741824U;
      #line 607 
      if (autoc != curr_autoc) 
                               #line 608 
                               ixgbe_write_reg_4(hw,17056U,autoc);
    }
  #line 615 
  return ixgbe_start_mac_link_82598(hw,
                                   (_Bool)((bool)((int)autoneg_wait_to_complete) != 0));
}

#line 627  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_setup_copper_link_82598(struct ixgbe_hw *hw, ixgbe_link_speed speed, bool autoneg_wait_to_complete)
{
  #line 631 
  s32 status;
  #line 634 
  status = (*(hw->phy.ops.setup_link_speed))(hw,speed,(_Bool)((bool)((int)autoneg_wait_to_complete) != 0));
  #line 637 
  ixgbe_start_mac_link_82598(hw,(_Bool)((bool)((int)autoneg_wait_to_complete) != 0));
  #line 639 
  return status;
}

#line 650  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_reset_hw_82598(struct ixgbe_hw *hw)
{
  #line 652 
  s32 status;
  #line 654 
  u32 ctrl;
  #line 655 
  u32 gheccr;
  #line 656 
  u32 i;
  #line 657 
  u32 autoc;
  #line 658 
  u8 analog_val;
  #line 653 
  s32 phy_status = 0;
  #line 661 
  status = (*(hw->mac.ops.stop_adapter))(hw);
  #line 662 
  if (status != 0) 
                   #line 663 
                   return status;
  #line 670 
  (*(hw->mac.ops.read_analog_reg8))(hw,36U,& analog_val);
  #line 671 
  if (((int)analog_val & 16) != 0) {
    #line 673 
    (*(hw->mac.ops.read_analog_reg8))(hw,36U,& analog_val);
    #line 675 
    analog_val = (unsigned char)((unsigned int)analog_val & 239U);
    #line 676 
    (*(hw->mac.ops.write_analog_reg8))(hw,36U,(unsigned char)((int)analog_val));
    #line 679 
    (*(hw->mac.ops.read_analog_reg8))(hw,11U,& analog_val);
    #line 681 
    analog_val = (unsigned char)((unsigned int)analog_val & 15U);
    #line 682 
    (*(hw->mac.ops.write_analog_reg8))(hw,11U,(unsigned char)((int)analog_val));
    #line 685 
    (*(hw->mac.ops.read_analog_reg8))(hw,12U,& analog_val);
    #line 687 
    analog_val = (unsigned char)((unsigned int)analog_val & 15U);
    #line 688 
    (*(hw->mac.ops.write_analog_reg8))(hw,12U,(unsigned char)((int)analog_val));
    #line 691 
    (*(hw->mac.ops.read_analog_reg8))(hw,13U,& analog_val);
    #line 693 
    analog_val = (unsigned char)((unsigned int)analog_val & 15U);
    #line 694 
    (*(hw->mac.ops.write_analog_reg8))(hw,13U,(unsigned char)((int)analog_val));
  }
  #line 699 
  if (! hw->phy.reset_disable) {
    #line 703 
    phy_status = (*(hw->phy.ops.init))(hw);
    #line 704 
    if (phy_status == -19) 
                           #line 705 
                           return phy_status;
    #line 706 
    if (phy_status == -20) 
                           #line 707 
                           goto mac_reset_top;
    #line 709 
    (*(hw->phy.ops.reset))(hw);
  }
  #line 712 
  mac_reset_top: 
                 #line 712 
  ;
  #line 717 
  ctrl = ixgbe_read_reg(hw,0U) | 67108864U;
  #line 718 
  ixgbe_write_reg_4(hw,0U,ctrl);
  #line 719 
  ixgbe_read_reg(hw,8U);
  #line 720 
  usleep_range(1000UL,1200UL);
  #line 723 
  i = 0U;
  #line 723 
  while (i <= 9U) {
    #line 724 
    ctrl = ixgbe_read_reg(hw,0U);
    #line 725 
    if ((ctrl & 67108864U) == 0U) 
                                  #line 726 
                                  break;
    #line 727 
    __const_udelay(4295UL);
    #line 723 
    i ++;
  }
  #line 729 
  if ((ctrl & 67108864U) != 0U) {
    #line 730 
    status = -15;
    {
      #line 731 
      bool branch;
      #line 731 
      struct _ddebug __UNIQUE_ID_ddebug447 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_reset_hw_82598", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c", .format = (char *)"Reset polling failed to complete.\n", .lineno = (unsigned int)731U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 731 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug447.key.dd_key_false.key,(_Bool)0);
      #line 731 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 731 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug447,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Reset polling failed to complete.\n");
    }
  }
  #line 734 
  msleep(50U);
  #line 741 
  if (((int)hw->mac.flags & 1) != 0) {
    #line 742 
    hw->mac.flags = (unsigned char)((unsigned int)hw->mac.flags & 254U);
    #line 743 
    goto mac_reset_top;
  }
  #line 746 
  gheccr = ixgbe_read_reg(hw,69808U);
  #line 747 
  gheccr &= 4292607423U;
  #line 748 
  ixgbe_write_reg_4(hw,69808U,gheccr);
  #line 755 
  autoc = ixgbe_read_reg(hw,17056U);
  #line 756 
  if (! hw->mac.orig_link_settings_stored) {
    #line 757 
    hw->mac.orig_autoc = autoc;
    #line 758 
    hw->mac.orig_link_settings_stored = (_Bool)1;
  }
  else 
    #line 759 
    if (hw->mac.orig_autoc != autoc) 
                                     #line 760 
                                     ixgbe_write_reg_4(hw,17056U,hw->mac.orig_autoc);
  #line 764 
  (*(hw->mac.ops.get_mac_addr))(hw,(u8 *)(& hw->mac.perm_addr));
  #line 770 
  (*(hw->mac.ops.init_rx_addrs))(hw);
  #line 772 
  if (phy_status != 0) 
                       #line 773 
                       status = phy_status;
  #line 775 
  return status;
}

#line 784  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_set_vmdq_82598(struct ixgbe_hw *hw, u32 rar, u32 vmdq)
{
  #line 786 
  u32 rar_high;
  #line 795 
  u32 tmp_0;
  #line 798 
  u32 tmp_1;
  #line 787 
  u32 rar_entries = hw->mac.num_rar_entries;
  #line 790 
  if (rar >= rar_entries) {
    {
      #line 791 
      bool branch;
      #line 791 
      struct _ddebug __UNIQUE_ID_ddebug448 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_set_vmdq_82598", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c", .format = (char *)"RAR index %d is out of range.\n", .lineno = (unsigned int)791U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 791 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug448.key.dd_key_false.key,(_Bool)0);
      #line 791 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 791 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug448,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"RAR index %d is out of range.\n",rar);
    }
    #line 792 
    return -32;
  }
  #line 795 
  if (rar <= 15U) 
                  #line 795 
                  tmp_0 = rar * 8U + 21508U; else 
                                                  #line 795 
                                                  tmp_0 = rar * 8U + 41476U;
  #line 795 
  ;
  #line 795 
  rar_high = ixgbe_read_reg(hw,tmp_0);
  #line 796 
  rar_high &= 4291035135U;
  #line 797 
  rar_high = ((vmdq << 18) & 3932160U) | rar_high;
  #line 798 
  ;
  #line 798 
  if (rar <= 15U) 
                  #line 798 
                  tmp_1 = rar * 8U + 21508U; else 
                                                  #line 798 
                                                  tmp_1 = rar * 8U + 41476U;
  #line 798 
  ;
  #line 798 
  ixgbe_write_reg_4(hw,tmp_1,rar_high);
  #line 799 
  return 0;
}

#line 808  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_clear_vmdq_82598(struct ixgbe_hw *hw, u32 rar, u32 vmdq)
{
  #line 810 
  u32 rar_high;
  #line 820 
  u32 tmp_0;
  #line 811 
  u32 rar_entries = hw->mac.num_rar_entries;
  #line 815 
  if (rar >= rar_entries) {
    {
      #line 816 
      bool branch;
      #line 816 
      struct _ddebug __UNIQUE_ID_ddebug449 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_clear_vmdq_82598", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c", .format = (char *)"RAR index %d is out of range.\n", .lineno = (unsigned int)816U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 816 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug449.key.dd_key_false.key,(_Bool)0);
      #line 816 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 816 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug449,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"RAR index %d is out of range.\n",rar);
    }
    #line 817 
    return -32;
  }
  #line 820 
  if (rar <= 15U) 
                  #line 820 
                  tmp_0 = rar * 8U + 21508U; else 
                                                  #line 820 
                                                  tmp_0 = rar * 8U + 41476U;
  #line 820 
  ;
  #line 820 
  rar_high = ixgbe_read_reg(hw,tmp_0);
  #line 821 
  if ((rar_high & 3932160U) != 0U) {
    #line 823 
    u32 tmp_1;
    #line 822 
    rar_high &= 4291035135U;
    #line 823 
    ;
    #line 823 
    if (rar <= 15U) 
                    #line 823 
                    tmp_1 = rar * 8U + 21508U; else 
                                                    #line 823 
                                                    tmp_1 = rar * 8U + 41476U;
    #line 823 
    ;
    #line 823 
    ixgbe_write_reg_4(hw,tmp_1,rar_high);
  }
  #line 826 
  return 0;
}

#line 839  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_set_vfta_82598(struct ixgbe_hw *hw, u32 vlan, u32 vind, bool vlan_on, bool vlvf_bypass)
{
  #line 842 
  u32 regindex;
  #line 843 
  u32 bitindex;
  #line 844 
  u32 bits;
  #line 845 
  u32 vftabyte;
  #line 847 
  if (vlan > 4095U) 
                    #line 848 
                    return -5;
  #line 851 
  regindex = (vlan >> 5) & 127U;
  #line 854 
  vftabyte = (vlan >> 3) & 3U;
  #line 855 
  bitindex = (vlan << 2) & 28U;
  #line 858 
  bits = ixgbe_read_reg(hw,((vftabyte + 81U) * 128U + regindex) * 4U);
  #line 859 
  bits = (unsigned int)(~ (15 << bitindex)) & bits;
  #line 860 
  bits = (vind << bitindex) | bits;
  #line 861 
  ixgbe_write_reg_4(hw,((vftabyte + 81U) * 128U + regindex) * 4U,bits);
  #line 864 
  bitindex = vlan & 31U;
  #line 866 
  bits = ixgbe_read_reg(hw,(regindex + 10240U) * 4U);
  #line 867 
  if ((int)vlan_on != 0) 
                         #line 869 
                         bits = (unsigned int)(1UL << bitindex) | bits; else 
                                                                    #line 872 
                                                                    bits = ~ ((unsigned int)(1UL << bitindex)) & bits;
  #line 873 
  ixgbe_write_reg_4(hw,(regindex + 10240U) * 4U,bits);
  #line 875 
  return 0;
}

#line 884  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_clear_vfta_82598(struct ixgbe_hw *hw)
{
  #line 886 
  u32 offset;
  #line 887 
  u32 vlanbyte;
  #line 889 
  offset = 0U;
  #line 889 
  while (hw->mac.vft_size > offset) {
    #line 890 
    ixgbe_write_reg_4(hw,(offset + 10240U) * 4U,0U);
    #line 889 
    offset ++;
  }
  #line 892 
  vlanbyte = 0U;
  #line 892 
  while (vlanbyte <= 3U) {
    #line 893 
    offset = 0U;
    #line 893 
    while (hw->mac.vft_size > offset) {
      #line 894 
      ixgbe_write_reg_4(hw,((vlanbyte + 81U) * 128U + offset) * 4U,0U);
      #line 893 
      offset ++;
    }
    #line 892 
    vlanbyte ++;
  }
  #line 897 
  return 0;
}

#line 908  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_read_analog_reg8_82598(struct ixgbe_hw *hw, u32 reg, u8 *val)
{
  #line 910 
  u32 atlas_ctl;
  #line 912 
  ixgbe_write_reg_4(hw,18432U,(reg << 8) | 65536U);
  #line 914 
  ixgbe_read_reg(hw,8U);
  #line 915 
  __const_udelay(42950UL);
  #line 916 
  atlas_ctl = ixgbe_read_reg(hw,18432U);
  #line 917 
  *val = (unsigned char)atlas_ctl;
  #line 919 
  return 0;
}

#line 930  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_write_analog_reg8_82598(struct ixgbe_hw *hw, u32 reg, u8 val)
{
  #line 932 
  u32 atlas_ctl;
  #line 934 
  atlas_ctl = (reg << 8) | (unsigned int)val;
  #line 935 
  ixgbe_write_reg_4(hw,18432U,atlas_ctl);
  #line 936 
  ixgbe_read_reg(hw,8U);
  #line 937 
  __const_udelay(42950UL);
  #line 939 
  return 0;
}

#line 951  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_read_i2c_phy_82598(struct ixgbe_hw *hw, u8 dev_addr, u8 byte_offset, u8 *eeprom_data)
{
  #line 958 
  u16 gssr;
  #line 959 
  u32 i;
  #line 954 
  s32 status = 0;
  #line 955 
  u16 sfp_addr = (unsigned short)0U;
  #line 956 
  u16 sfp_data = (unsigned short)0U;
  #line 957 
  u16 sfp_stat = (unsigned short)0U;
  #line 961 
  if ((ixgbe_read_reg(hw,8U) & 4U) != 0U) 
                                          #line 962 
                                          gssr = (unsigned short)4U; else 
                                                                    #line 964 
                                                                    gssr = (unsigned short)2U;
  #line 966 
  if ((*(hw->mac.ops.acquire_swfw_sync))(hw,(unsigned int)gssr) != 0) 
    #line 967 
    return -16;
  #line 969 
  if (hw->phy.type == (unsigned int)ixgbe_phy_nl) {
    #line 975 
    sfp_addr = (unsigned short)(((int)((unsigned short)dev_addr) << 8U) + (int)((unsigned short)byte_offset));
    #line 976 
    sfp_addr = (unsigned short)((unsigned int)sfp_addr | 256U);
    #line 977 
    (*(hw->phy.ops.write_reg_mdi))(hw,49930U,1U,(unsigned short)((int)sfp_addr));
    #line 983 
    i = 0U;
    #line 983 
    while (i <= 99U) {
      #line 984 
      (*(hw->phy.ops.read_reg_mdi))(hw,49932U,1U,& sfp_stat);
      #line 988 
      sfp_stat = (unsigned short)((unsigned int)sfp_stat & 3U);
      #line 989 
      if ((unsigned int)sfp_stat != 3U) 
                                        #line 990 
                                        break;
      #line 991 
      usleep_range(10000UL,20000UL);
      #line 983 
      i ++;
    }
    #line 994 
    if ((unsigned int)sfp_stat != 1U) {
      {
        #line 995 
        bool branch;
        #line 995 
        struct _ddebug __UNIQUE_ID_ddebug450 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_read_i2c_phy_82598", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c", .format = (char *)"EEPROM read did not pass.\n", .lineno = (unsigned int)995U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 995 
        branch = arch_static_branch(& __UNIQUE_ID_ddebug450.key.dd_key_false.key,(_Bool)0);
        #line 995 
        if ((long)((long)((int)branch != 0)) != 0L) 
                                                    #line 995 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug450,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"EEPROM read did not pass.\n");
      }
      #line 996 
      status = -20;
      #line 997 
      goto out;
    }
    #line 1001 
    (*(hw->phy.ops.read_reg_mdi))(hw,49931U,1U,& sfp_data);
    #line 1004 
    *eeprom_data = (unsigned char)((int)sfp_data >> 8);
  }
  else 
       #line 1006 
       status = -3;
  #line 1009 
  out: 
       #line 1009 
  ;
  #line 1010 
  (*(hw->mac.ops.release_swfw_sync))(hw,(unsigned int)gssr);
  #line 1011 
  return status;
}

#line 1022  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_read_i2c_eeprom_82598(struct ixgbe_hw *hw, u8 byte_offset, u8 *eeprom_data)
{
  #line 1025 
  return ixgbe_read_i2c_phy_82598(hw,(unsigned char)160,
                               (unsigned char)((int)byte_offset),eeprom_data);
}

#line 1037  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_read_i2c_sff8472_82598(struct ixgbe_hw *hw, u8 byte_offset, u8 *sff8472_data)
{
  #line 1040 
  return ixgbe_read_i2c_phy_82598(hw,(unsigned char)162,
                               (unsigned char)((int)byte_offset),
                               sff8472_data);
}

#line 1052  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static void ixgbe_set_lan_id_multi_port_pcie_82598(struct ixgbe_hw *hw)
{
  #line 1054 
  struct ixgbe_bus_info *bus = & hw->bus;
  #line 1055 
  u16 pci_gen = (unsigned short)0U;
  #line 1056 
  u16 pci_ctrl2 = (unsigned short)0U;
  #line 1058 
  ixgbe_set_lan_id_multi_port_pcie(hw);
  #line 1061 
  (*(hw->eeprom.ops.read))(hw,(unsigned short)6,& pci_gen);
  #line 1062 
  if ((unsigned int)pci_gen + 65535U <= 65533U) {
    #line 1064 
    (*(hw->eeprom.ops.read))(hw,(unsigned short)((int)((unsigned int)pci_gen + 5U)),& pci_ctrl2);
    #line 1067 
    if ((((int)pci_ctrl2 & 2) != 0 && ((int)pci_ctrl2 & 1) == 0) && ((int)pci_ctrl2 & 8) == 0) 
      #line 1071 
      bus->func = (unsigned char)0U;
  }
  #line 1073 
  return;
}

#line 1083  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static void ixgbe_set_rxpba_82598(struct ixgbe_hw *hw, int num_pb, u32 headroom, int strategy)
{
  #line 1086 
  u32 rxpktsize = 65536U;
  #line 1087 
  u8 i = (unsigned char)0U;
  #line 1089 
  if (num_pb == 0) 
                   #line 1090 
                   return;
  #line 1093 
  switch (strategy) {
    #line 1094 
    case 1: 
            #line 1094 
    ;
    #line 1096 
    rxpktsize = 81920U;
    #line 1097 
    while ((unsigned int)i <= 3U) {
      #line 1098 
      ixgbe_write_reg_4(hw,(unsigned int)(((int)i + 3840) * 4),rxpktsize);
      #line 1097 
      i = (u8)((int)i + 1);
    }
    #line 1100 
    rxpktsize = 49152U;
    #line 1102 
    case 0: 
            #line 1102 
    ;
    #line 1103 
    default: 
             #line 1103 
    ;
    #line 1105 
    while ((unsigned int)i <= 7U) {
      #line 1106 
      ixgbe_write_reg_4(hw,(unsigned int)(((int)i + 3840) * 4),rxpktsize);
      #line 1105 
      i = (u8)((int)i + 1);
    }
    #line 1107 
    break;
  }
  #line 1111 
  i = (unsigned char)0U;
  #line 1111 
  while ((unsigned int)i <= 7U) {
    #line 1112 
    ixgbe_write_reg_4(hw,(unsigned int)(((int)i + 13056) * 4),40960U);
    #line 1111 
    i = (u8)((int)i + 1);
  }
  #line 1113 
  return;
}

#line 1115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static struct ixgbe_mac_operations mac_ops_82598 = {.init_hw = & ixgbe_init_hw_generic, .reset_hw = & ixgbe_reset_hw_82598, .start_hw = & ixgbe_start_hw_82598, .clear_hw_cntrs = & ixgbe_clear_hw_cntrs_generic, .get_media_type = & ixgbe_get_media_type_82598, .get_mac_addr = & ixgbe_get_mac_addr_generic, .stop_adapter = & ixgbe_stop_adapter_generic, .get_bus_info = & ixgbe_get_bus_info_generic, .set_lan_id = & ixgbe_set_lan_id_multi_port_pcie_82598, .read_analog_reg8 = & ixgbe_read_analog_reg8_82598, .write_analog_reg8 = & ixgbe_write_analog_reg8_82598, .enable_rx_dma = & ixgbe_enable_rx_dma_generic, .acquire_swfw_sync = & ixgbe_acquire_swfw_sync, .release_swfw_sync = & ixgbe_release_swfw_sync, .prot_autoc_read = & prot_autoc_read_generic, .prot_autoc_write = & prot_autoc_write_generic, .setup_link = & ixgbe_setup_mac_link_82598, .check_link = & ixgbe_check_mac_link_82598, .get_link_capabilities = & ixgbe_get_link_capabilities_82598, .set_rxpba = & ixgbe_set_rxpba_82598, .led_on = & ixgbe_led_on_generic, .led_off = & ixgbe_led_off_generic, .blink_led_start = & ixgbe_blink_led_start_generic, .blink_led_stop = & ixgbe_blink_led_stop_generic, .init_led_link_act = & ixgbe_init_led_link_act_generic, .set_rar = & ixgbe_set_rar_generic, .clear_rar = & ixgbe_clear_rar_generic, .set_vmdq = & ixgbe_set_vmdq_82598, .clear_vmdq = & ixgbe_clear_vmdq_82598, .init_rx_addrs = & ixgbe_init_rx_addrs_generic, .update_mc_addr_list = & ixgbe_update_mc_addr_list_generic, .enable_mc = & ixgbe_enable_mc_generic, .disable_mc = & ixgbe_disable_mc_generic, .clear_vfta = & ixgbe_clear_vfta_82598, .set_vfta = & ixgbe_set_vfta_82598, .fc_enable = & ixgbe_fc_enable_82598, .setup_fc = & ixgbe_setup_fc_generic, .fc_autoneg = & ixgbe_fc_autoneg, .disable_rx = & ixgbe_disable_rx_generic, .enable_rx = & ixgbe_enable_rx_generic};
#line 1162  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static struct ixgbe_eeprom_operations eeprom_ops_82598 = {.init_params = & ixgbe_init_eeprom_params_generic, .read = & ixgbe_read_eerd_generic, .read_buffer = & ixgbe_read_eerd_buffer_generic, .write = & ixgbe_write_eeprom_generic, .write_buffer = & ixgbe_write_eeprom_buffer_bit_bang_generic, .validate_checksum = & ixgbe_validate_eeprom_checksum_generic, .update_checksum = & ixgbe_update_eeprom_checksum_generic, .calc_checksum = & ixgbe_calc_eeprom_checksum_generic};
#line 1173  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static struct ixgbe_phy_operations phy_ops_82598 = {.identify = & ixgbe_identify_phy_generic, .identify_sfp = & ixgbe_identify_module_generic, .init = & ixgbe_init_phy_ops_82598, .reset = & ixgbe_reset_phy_generic, .read_reg = & ixgbe_read_phy_reg_generic, .write_reg = & ixgbe_write_phy_reg_generic, .read_reg_mdi = & ixgbe_read_phy_reg_mdi, .write_reg_mdi = & ixgbe_write_phy_reg_mdi, .setup_link = & ixgbe_setup_phy_link_generic, .setup_link_speed = & ixgbe_setup_phy_link_speed_generic, .read_i2c_sff8472 = & ixgbe_read_i2c_sff8472_82598, .read_i2c_eeprom = & ixgbe_read_i2c_eeprom_82598, .check_overtemp = & ixgbe_tn_check_overtemp};
#line 1189  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
struct ixgbe_info ixgbe_82598_info = {.mac = ixgbe_mac_82598EB, .get_invariants = & ixgbe_get_invariants_82598, .mac_ops = & mac_ops_82598, .eeprom_ops = & eeprom_ops_82598, .phy_ops = & phy_ops_82598, .mvals = (u32 *)(& ixgbe_mvals_8259X)};
#line 7  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_fcoe.i.aux"
#line 7 
void ldv_atomic_inc(atomic_t *v);
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
#line 121  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_fcoe.i.aux"
static void cif_set_bit_2(long nr, unsigned long *addr);
#line 123  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/atomic.h"
__inline static bool arch_atomic_dec_and_test(atomic_t *v)
{
  #line 125 
  bool c;
  #line 126 
  ldv_inline_asm();
  #line 125 
  return c;
}

#line 237  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/atomic-instrumented.h"
#line 184  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_fcoe.i.aux"
static void atomic_inc(atomic_t *v);
#line 745  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/atomic-instrumented.h"
__inline static bool atomic_dec_and_test(atomic_t *v)
{
  #line 747 
  kasan_check_read((void *)v,4U);
  #line 748 
  return arch_atomic_dec_and_test(v);
}

#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_api_smp.h"
#line 28 
void _raw_spin_lock_bh(raw_spinlock_t *);
#line 40 
#line 40 
void _raw_spin_unlock_bh(raw_spinlock_t *);
#line 341  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock.h"
static void spin_lock_bh(spinlock_t *lock)
{
  #line 343 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_25.rlock);
  #line 344 
  return;
}

#line 345 
#line 687  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_fcoe.i.aux"
static void cif_spin_lock_bh_lock_of_ixgbe_fcoe(spinlock_t *lock);
#line 381  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock.h"
static void spin_unlock_bh(spinlock_t *lock)
{
  #line 383 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_25.rlock);
  #line 384 
  return;
}

#line 385 
#line 696  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_fcoe.i.aux"
static void cif_spin_unlock_bh_lock_of_ixgbe_fcoe(spinlock_t *lock);
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
#line 24 
void *ldv_kmalloc(size_t size, gfp_t flags);
#line 135  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/percpu.h"
#line 135 
void *__alloc_percpu(size_t, size_t);
#line 136 
#line 136 
void free_percpu(void *);
#line 542  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 451  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_fcoe.i.aux"
static void *kmalloc(size_t size, gfp_t flags);
#line 1083  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
#line 1083 
int pci_read_config_byte(struct pci_dev *, int, u8 *);
#line 256  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/scatterlist.h"
#line 256 
struct scatterlist *sg_next(struct scatterlist *);
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dmapool.h"
#line 21 
struct dma_pool *dma_pool_create(char *, struct device *, size_t, size_t, size_t);
#line 24 
#line 24 
void dma_pool_destroy(struct dma_pool *);
#line 26 
#line 26 
void *dma_pool_alloc(struct dma_pool *, gfp_t, dma_addr_t *);
#line 28 
#line 28 
void dma_pool_free(struct dma_pool *, void *, dma_addr_t);
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-debug.h"
#line 33 
void debug_dma_map_sg(struct device *, struct scatterlist *, int, int, int);
#line 36 
#line 36 
void debug_dma_unmap_sg(struct device *, struct scatterlist *, int, int);
#line 203  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
#line 203 
int dma_direct_map_sg(struct device *, struct scatterlist *, int, enum dma_data_direction, unsigned long);
#line 230 
#line 230 
void dma_direct_unmap_sg(struct device *, struct scatterlist *, int, enum dma_data_direction, unsigned long);
#line 308  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static int dma_map_sg_attrs(struct device *dev, struct scatterlist *sg, int nents, enum dma_data_direction dir, unsigned long attrs)
{
  #line 313 
  int ents;
  #line 312 
  struct dma_map_ops *ops = get_dma_ops(dev);
  #line 315 
  if ((long)(valid_dma_direction((int)dir) == 0) != 0L) {
    #line 316 
    ldv_inline_asm();
    #line 317 
    ldv_inline_asm();
    #line 318 
    ldv_inline_asm();
    #line 315 
    ;
  }
  #line 316 
  if ((int)dma_is_direct(ops) != 0) 
                                    #line 317 
                                    ents = dma_direct_map_sg(dev,sg,nents,dir,attrs); else 
                                                                    #line 319 
                                                                    ents = (*(ops->map_sg))(dev,sg,nents,dir,attrs);
  #line 320 
  if ((long)(ents < 0) != 0L) {
    #line 321 
    ldv_inline_asm();
    #line 322 
    ldv_inline_asm();
    #line 323 
    ldv_inline_asm();
    #line 320 
    ;
  }
  #line 321 
  debug_dma_map_sg(dev,sg,nents,ents,(int)dir);
  #line 323 
  return ents;
}

#line 326  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static void dma_unmap_sg_attrs(struct device *dev, struct scatterlist *sg, int nents, enum dma_data_direction dir, unsigned long attrs)
{
  #line 330 
  struct dma_map_ops *ops = get_dma_ops(dev);
  #line 332 
  if ((long)(valid_dma_direction((int)dir) == 0) != 0L) {
    #line 333 
    ldv_inline_asm();
    #line 334 
    ldv_inline_asm();
    #line 335 
    ldv_inline_asm();
    #line 332 
    ;
  }
  #line 333 
  debug_dma_unmap_sg(dev,sg,nents,(int)dir);
  #line 334 
  if ((int)dma_is_direct(ops) != 0) 
                                    #line 335 
                                    dma_direct_unmap_sg(dev,sg,nents,dir,attrs);
  else 
    #line 336 
    if (ops->unmap_sg != (void (*)(struct device *, struct scatterlist *, int , enum dma_data_direction , unsigned long ))0) 
      #line 337 
      (*(ops->unmap_sg))(dev,sg,nents,dir,attrs);
  #line 338 
  return;
}

#line 2189  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
#line 2189 
void *skb_put(struct sk_buff *, unsigned int);
#line 2463  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void skb_reset_transport_header(struct sk_buff *skb)
{
  #line 2465 
  skb->transport_header = (unsigned short)(skb->data - skb->head);
  #line 2466 
  return;
}

#line 2468  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void skb_set_transport_header(struct sk_buff *skb, int offset)
{
  #line 2471 
  skb_reset_transport_header(skb);
  #line 2472 
  skb->transport_header = (unsigned short)((int)skb->transport_header + (int)((unsigned short)offset));
  #line 2473 
  return;
}

#line 2480  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void skb_reset_network_header(struct sk_buff *skb)
{
  #line 2482 
  skb->network_header = (unsigned short)(skb->data - skb->head);
  #line 2483 
  return;
}

#line 2485  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void skb_set_network_header(struct sk_buff *skb, int offset)
{
  #line 2487 
  skb_reset_network_header(skb);
  #line 2488 
  skb->network_header = (unsigned short)((int)skb->network_header + (int)((unsigned short)offset));
  #line 2489 
  return;
}

#line 2491  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static unsigned char *skb_mac_header(struct sk_buff *skb)
{
  #line 2493 
  return skb->head + (unsigned long)skb->mac_header;
}

#line 2559  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static int skb_transport_offset(struct sk_buff *skb)
{
  #line 2561 
  ;
  #line 2561 
  return (int)(skb_transport_header(skb) - skb->data);
}

#line 3248  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static int __skb_linearize(struct sk_buff *skb)
{
  #line 3250 
  int tmp_0;
  #line 3250 
  if (__pskb_pull_tail(skb,(int)skb->data_len) != (void *)0) 
                                                             #line 3250 
                                                             tmp_0 = 0; else 
                                                                    #line 3250 
                                                                    tmp_0 = -12;
  #line 3250 
  return tmp_0;
}

#line 3260  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static int skb_linearize(struct sk_buff *skb)
{
  #line 3262 
  int tmp_1;
  #line 3262 
  if ((int)skb_is_nonlinear(skb) != 0) 
                                       #line 3262 
                                       tmp_1 = __skb_linearize(skb); else 
                                                                    #line 3262 
                                                                    tmp_1 = 0;
  #line 3262 
  return tmp_1;
}

#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_ether.h"
__inline static struct ethhdr *eth_hdr(struct sk_buff *skb)
{
  #line 24 
  return (struct ethhdr *)skb_mac_header(skb);
}

#line 4260  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
#line 4260 
void netdev_features_change(struct net_device *);
#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static void ixgbe_write_reg_5(struct ixgbe_hw *hw, u32 reg, u32 value)
{
  #line 147 
  union __anonunion___u_7032 __u;
  #line 146 
  __read_once_size((void *)(& hw->hw_addr),(void *)(& __u.__c),8);
  #line 146 
  u8 *reg_addr = (__u.__val);
  #line 148 
  if ((int)ixgbe_removed((void *)reg_addr) != 0) 
                                                 #line 149 
                                                 return;
  #line 150 
  writel(value,(void *)(reg_addr + (unsigned long)reg));
  #line 151 
  return;
}

#line 26  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/scsi/fc_frame.h"
__inline static u32 ntoh24(u8 *p)
{
  #line 28 
  return (unsigned int)((((int)*p << 16) | ((int)*(p + 1U) << 8)) | (int)*(p + 2U));
}

#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
__inline static void ixgbe_fcoe_clear_ddp(struct ixgbe_fcoe_ddp *ddp)
{
  #line 24 
  ddp->len = 0;
  #line 25 
  ddp->err = 1U;
  #line 26 
  ddp->udl = (u64 *)0ULL;
  #line 27 
  ddp->udp = 0ULL;
  #line 28 
  ddp->sgl = (struct scatterlist *)0;
  #line 29 
  ddp->sgc = 0U;
  #line 30 
  return;
}

#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fcoe_ddp_put(struct net_device *netdev, u16 xid)
{
  #line 45 
  int len;
  #line 46 
  struct ixgbe_fcoe *fcoe;
  #line 47 
  struct ixgbe_adapter *adapter;
  #line 48 
  struct ixgbe_fcoe_ddp *ddp;
  #line 49 
  struct ixgbe_hw *hw;
  #line 50 
  u32 fcbuff;
  #line 52 
  if (netdev == (struct net_device *)0) 
                                        #line 53 
                                        return 0;
  #line 55 
  if ((unsigned int)xid >= netdev->fcoe_ddp_xid) 
                                                 #line 56 
                                                 return 0;
  #line 58 
  adapter = (struct ixgbe_adapter *)netdev_priv(netdev);
  #line 59 
  fcoe = & adapter->fcoe;
  #line 60 
  ddp = & fcoe->ddp[(int)xid];
  #line 61 
  if (ddp->udl == (u64 *)0ULL) 
                               #line 62 
                               return 0;
  #line 64 
  hw = & adapter->hw;
  #line 65 
  len = ddp->len;
  #line 67 
  if (ddp->err == 0U) 
                      #line 68 
                      goto skip_ddpinv;
  #line 70 
  if (hw->mac.type == (unsigned int)ixgbe_mac_X550) {
    #line 73 
    ixgbe_write_reg_5(hw,(unsigned int)(((int)xid + 10240) * 16),0U);
    #line 74 
    ixgbe_write_reg_5(hw,(unsigned int)((int)xid * 16 + 163852),(unsigned int)xid | 16384U);
    #line 78 
    ixgbe_write_reg_5(hw,(unsigned int)((int)xid * 16 + 131080),0U);
    #line 81 
    ixgbe_write_reg_5(hw,(unsigned int)((int)xid * 16 + 131084),(unsigned int)xid | 16384U);
    #line 85 
    ixgbe_write_reg_5(hw,(unsigned int)((int)xid * 16 + 131084),(unsigned int)xid | 32768U);
    #line 87 
    fcbuff = ixgbe_read_reg(hw,(unsigned int)((int)xid * 16 + 131080));
  }
  else {
    #line 90 
    cif_spin_lock_bh_lock_of_ixgbe_fcoe(& fcoe->lock);
    #line 91 
    ixgbe_write_reg_5(hw,20744U,0U);
    #line 92 
    ixgbe_write_reg_5(hw,20752U,(unsigned int)xid | 16384U);
    #line 94 
    ixgbe_write_reg_5(hw,9240U,0U);
    #line 95 
    ixgbe_write_reg_5(hw,9248U,(unsigned int)xid | 16384U);
    #line 99 
    ixgbe_write_reg_5(hw,9248U,(unsigned int)xid | 32768U);
    #line 101 
    fcbuff = ixgbe_read_reg(hw,9240U);
    #line 102 
    cif_spin_unlock_bh_lock_of_ixgbe_fcoe(& fcoe->lock);
  }
  #line 105 
  if (((unsigned long)fcbuff & 1UL) != 0UL) 
                                            #line 106 
                                            usleep_range(100UL,150UL);
  #line 108 
  skip_ddpinv: 
               #line 108 
  ;
  #line 109 
  if (ddp->sgl != (struct scatterlist *)0) 
                                           #line 110 
                                           dma_unmap_sg_attrs(& (adapter->pdev)->dev,ddp->sgl,(int)ddp->sgc,(enum dma_data_direction)DMA_FROM_DEVICE,0UL);
  #line 112 
  if (ddp->pool != (struct dma_pool *)0) {
    #line 113 
    dma_pool_free(ddp->pool,(void *)ddp->udl,ddp->udp);
    #line 114 
    ddp->pool = (struct dma_pool *)0;
  }
  #line 117 
  ixgbe_fcoe_clear_ddp(ddp);
  #line 119 
  return len;
}

#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
static int ixgbe_fcoe_ddp_setup(struct net_device *netdev, u16 xid, struct scatterlist *sgl, unsigned int sgc, int target_mode)
{
  #line 181 
  unsigned long __ptr;
  #line 181 
  int pscr_ret__;
  #line 136 
  struct ixgbe_adapter *adapter;
  #line 137 
  struct ixgbe_hw *hw;
  #line 138 
  struct ixgbe_fcoe *fcoe;
  #line 139 
  struct ixgbe_fcoe_ddp *ddp;
  #line 140 
  struct ixgbe_fcoe_ddp_pool *ddp_pool;
  #line 141 
  struct scatterlist *sg;
  #line 142 
  unsigned int i;
  #line 142 
  unsigned int j;
  #line 142 
  unsigned int dmacount;
  #line 143 
  unsigned int len;
  #line 146 
  unsigned int lastsize;
  #line 149 
  u32 fcbuff;
  #line 149 
  u32 fcdmarw;
  #line 149 
  u32 fcfltrw;
  #line 149 
  u32 fcrxctl;
  #line 144 
  unsigned int bufflen = 4096U;
  #line 145 
  unsigned int firstoff = 0U;
  #line 147 
  unsigned int thisoff = 0U;
  #line 148 
  unsigned int thislen = 0U;
  #line 150 
  dma_addr_t addr = 0ULL;
  #line 152 
  if (netdev == (struct net_device *)0 || sgl == (struct scatterlist *)0) 
    #line 153 
    return 0;
  #line 155 
  adapter = (struct ixgbe_adapter *)netdev_priv(netdev);
  #line 156 
  if ((unsigned int)xid >= netdev->fcoe_ddp_xid) {
    #line 157 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 157 
                                             netdev_warn(adapter->netdev,(char *)"xid=0x%x out-of-range\n",(int)xid);
    #line 158 
    return 0;
  }
  #line 162 
  if ((int)test_bit(2L,& adapter->state) != 0) 
                                               #line 164 
                                               return 0;
  else {
    #line 162 
    if ((int)test_bit(1L,& adapter->state) != 0) 
                                                 #line 164 
                                                 return 0;
  }
  #line 166 
  fcoe = & adapter->fcoe;
  #line 167 
  ddp = & fcoe->ddp[(int)xid];
  #line 168 
  if (ddp->sgl != (struct scatterlist *)0) {
    #line 169 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 169 
                                             netdev_err(adapter->netdev,(char *)"xid 0x%x w/ non-null sgl=%p nents=%d\n",(int)xid,ddp->sgl,ddp->sgc);
    #line 171 
    return 0;
  }
  #line 173 
  ixgbe_fcoe_clear_ddp(ddp);
  #line 176 
  if (fcoe->ddp_pool == (struct ixgbe_fcoe_ddp_pool *)0) {
    #line 177 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 177 
                                             netdev_warn(adapter->netdev,(char *)"No ddp_pool resources allocated\n");
    #line 178 
    return 0;
  }
  {
    #line 181 
    void *__vpp_verify = (void *)0;
    #line 181 
    void *tmp_2 = __vpp_verify;
  }
  #line 182 
  ldv_inline_asm();
  #line 181 
  __preempt_count_add(1);
  #line 182 
  ldv_inline_asm();
  #line 181 
  __this_cpu_preempt_check((char *)"read");
  {
    #line 181 
    void *__vpp_verify_0 = (void *)0;
    #line 181 
    void *tmp_4 = __vpp_verify_0;
  }
  #line 181 
  switch (4UL) {
    #line 181 
    int pfo_ret__;
    #line 181 
    int pfo_ret___0;
    #line 181 
    int pfo_ret___1;
    #line 181 
    int pfo_ret___2;
    #line 181 
    case (unsigned long)1: 
                           #line 181 
    ;
    #line 181 
    switch (4UL) {
      #line 181 
      case (unsigned long)1: 
                             #line 181 
      ;
      #line 182 
      ldv_inline_asm();
      #line 181 
      break;
      #line 181 
      case (unsigned long)2: 
                             #line 181 
      ;
      #line 182 
      ldv_inline_asm();
      #line 181 
      break;
      #line 181 
      case (unsigned long)4: 
                             #line 181 
      ;
      #line 182 
      ldv_inline_asm();
      #line 181 
      break;
      #line 181 
      case (unsigned long)8: 
                             #line 181 
      ;
      #line 182 
      ldv_inline_asm();
      #line 181 
      break;
      #line 181 
      default: 
               #line 181 
      ;
      #line 181 
      __bad_percpu_size();
    }
    #line 181 
    pscr_ret__ = pfo_ret__;
    #line 181 
    break;
    #line 181 
    case (unsigned long)2: 
                           #line 181 
    ;
    #line 181 
    switch (4UL) {
      #line 181 
      case (unsigned long)1: 
                             #line 181 
      ;
      #line 182 
      ldv_inline_asm();
      #line 181 
      break;
      #line 181 
      case (unsigned long)2: 
                             #line 181 
      ;
      #line 182 
      ldv_inline_asm();
      #line 181 
      break;
      #line 181 
      case (unsigned long)4: 
                             #line 181 
      ;
      #line 182 
      ldv_inline_asm();
      #line 181 
      break;
      #line 181 
      case (unsigned long)8: 
                             #line 181 
      ;
      #line 182 
      ldv_inline_asm();
      #line 181 
      break;
      #line 181 
      default: 
               #line 181 
      ;
      #line 181 
      __bad_percpu_size();
    }
    #line 181 
    pscr_ret__ = pfo_ret___0;
    #line 181 
    break;
    #line 181 
    case (unsigned long)4: 
                           #line 181 
    ;
    #line 181 
    switch (4UL) {
      #line 181 
      case (unsigned long)1: 
                             #line 181 
      ;
      #line 182 
      ldv_inline_asm();
      #line 181 
      break;
      #line 181 
      case (unsigned long)2: 
                             #line 181 
      ;
      #line 182 
      ldv_inline_asm();
      #line 181 
      break;
      #line 181 
      case (unsigned long)4: 
                             #line 181 
      ;
      #line 182 
      ldv_inline_asm();
      #line 181 
      break;
      #line 181 
      case (unsigned long)8: 
                             #line 181 
      ;
      #line 182 
      ldv_inline_asm();
      #line 181 
      break;
      #line 181 
      default: 
               #line 181 
      ;
      #line 181 
      __bad_percpu_size();
    }
    #line 181 
    pscr_ret__ = pfo_ret___1;
    #line 181 
    break;
    #line 181 
    case (unsigned long)8: 
                           #line 181 
    ;
    #line 181 
    switch (4UL) {
      #line 181 
      case (unsigned long)1: 
                             #line 181 
      ;
      #line 182 
      ldv_inline_asm();
      #line 181 
      break;
      #line 181 
      case (unsigned long)2: 
                             #line 181 
      ;
      #line 182 
      ldv_inline_asm();
      #line 181 
      break;
      #line 181 
      case (unsigned long)4: 
                             #line 181 
      ;
      #line 182 
      ldv_inline_asm();
      #line 181 
      break;
      #line 181 
      case (unsigned long)8: 
                             #line 181 
      ;
      #line 182 
      ldv_inline_asm();
      #line 181 
      break;
      #line 181 
      default: 
               #line 181 
      ;
      #line 181 
      __bad_percpu_size();
    }
    #line 181 
    pscr_ret__ = pfo_ret___2;
    #line 181 
    break;
    #line 181 
    default: 
             #line 181 
    ;
    #line 181 
    __bad_size_call_parameter();
    #line 181 
    break;
  }
  #line 181 
  ;
  #line 181 
  ddp_pool = ((struct ixgbe_fcoe_ddp_pool *)(__per_cpu_offset[pscr_ret__] + __ptr));
  #line 182 
  if (ddp_pool->pool == (struct dma_pool *)0) {
    #line 183 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 183 
                                             netdev_warn(adapter->netdev,(char *)"xid=0x%x no ddp pool for fcoe\n",(int)xid);
    #line 184 
    goto out_noddp;
  }
  #line 188 
  dmacount = (unsigned int)dma_map_sg_attrs(& (adapter->pdev)->dev,sgl,(int)sgc,
                          (enum dma_data_direction)DMA_FROM_DEVICE,0UL);
  #line 189 
  if (dmacount == 0U) {
    #line 190 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 190 
                                             netdev_err(adapter->netdev,(char *)"xid 0x%x DMA map error\n",(int)xid);
    #line 191 
    goto out_noddp;
  }
  #line 195 
  ddp->udl = (u64 *)dma_pool_alloc(ddp_pool->pool,3264U,& ddp->udp);
  #line 196 
  if (ddp->udl == (u64 *)0ULL) {
    #line 197 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 197 
                                             netdev_err(adapter->netdev,(char *)"failed allocated ddp context\n");
    #line 198 
    goto out_noddp_unmap;
  }
  #line 200 
  ddp->pool = ddp_pool->pool;
  #line 201 
  ddp->sgl = sgl;
  #line 202 
  ddp->sgc = sgc;
  #line 204 
  j = 0U;
  #line 205 
  i = 0U;
  #line 205 
  sg = sgl;
  #line 205 
  while (i < dmacount) {
    #line 206 
    addr = sg->dma_address;
    #line 207 
    len = sg->dma_length;
    #line 208 
    while (len != 0U) {
      #line 217 
      unsigned int __UNIQUE_ID___x489;
      #line 217 
      unsigned int tmp_13;
      #line 210 
      if (j > 255U) {
        #line 211 
        (ddp_pool->noddp) ++;
        #line 212 
        goto out_noddp_free;
      }
      #line 216 
      thisoff = (unsigned int)addr & 4095U;
      {
        #line 217 
        __UNIQUE_ID___x489 = 4096U - thisoff;
        #line 217 
        unsigned int __UNIQUE_ID___y490 = len;
        #line 217 
        if (__UNIQUE_ID___x489 < __UNIQUE_ID___y490) 
                                                     #line 217 
                                                     tmp_13 = __UNIQUE_ID___x489; else 
                                                                    #line 217 
                                                                    tmp_13 = __UNIQUE_ID___y490;
        }
      #line 217 
      thislen = tmp_13;
      #line 222 
      if (j != 0U && thisoff != 0U) 
                                    #line 223 
                                    goto out_noddp_free;
      #line 229 
      if ((dmacount + 4294967295U != i || thislen != len) && thislen + thisoff != 4096U) 
        #line 231 
        goto out_noddp_free;
      #line 233 
      *(ddp->udl + (unsigned long)j) = addr - (unsigned long long)thisoff;
      #line 235 
      if (j == 0U) 
                   #line 236 
                   firstoff = thisoff;
      #line 237 
      len -= thislen;
      #line 238 
      addr = (unsigned long long)thislen + addr;
      #line 239 
      j ++;
    }
    #line 205 
    i ++;
    #line 205 
    sg = sg_next(sg);
  }
  #line 243 
  lastsize = thisoff + thislen;
  #line 249 
  if (lastsize == 4096U) {
    #line 250 
    if (j > 255U) {
      #line 251 
      (ddp_pool->noddp_ext_buff) ++;
      #line 252 
      goto out_noddp_free;
    }
    #line 255 
    *(ddp->udl + (unsigned long)j) = fcoe->extra_ddp_buffer_dma;
    #line 256 
    j ++;
    #line 257 
    lastsize = 1U;
  }
  #line 261 
  ldv_inline_asm();
  #line 259 
  __preempt_count_sub(1);
  #line 261 
  fcbuff = 0U;
  #line 262 
  fcbuff = ((j << 8) & 65535U) | fcbuff;
  #line 263 
  fcbuff = (firstoff << 16) | fcbuff;
  #line 265 
  if (target_mode != 0) 
                        #line 266 
                        fcbuff |= 128U;
  #line 267 
  fcbuff |= 1U;
  #line 269 
  fcdmarw = (unsigned int)xid;
  #line 270 
  fcdmarw |= 16384U;
  #line 271 
  fcdmarw = (lastsize << 16) | fcdmarw;
  #line 273 
  fcfltrw = (unsigned int)xid;
  #line 274 
  fcfltrw |= 16384U;
  #line 277 
  hw = & adapter->hw;
  #line 281 
  if (target_mode != 0) {
    #line 281 
    if (! test_bit(1L,& fcoe->mode)) {
      #line 282 
      cif_set_bit_2(1L,& fcoe->mode);
      #line 283 
      fcrxctl = ixgbe_read_reg(hw,20736U);
      #line 284 
      fcrxctl |= 8U;
      #line 285 
      ixgbe_write_reg_5(hw,20736U,fcrxctl);
    }
  }
  #line 288 
  if (hw->mac.type == (unsigned int)ixgbe_mac_X550) {
    #line 291 
    ixgbe_write_reg_5(hw,(unsigned int)(((int)xid + 8192) * 16),(unsigned int)ddp->udp);
    #line 293 
    ixgbe_write_reg_5(hw,(unsigned int)((int)xid * 16 + 131076),(unsigned int)(ddp->udp >> 32));
    #line 294 
    ixgbe_write_reg_5(hw,(unsigned int)((int)xid * 16 + 131080),fcbuff);
    #line 295 
    ixgbe_write_reg_5(hw,(unsigned int)((int)xid * 16 + 131084),fcdmarw);
    #line 297 
    ixgbe_write_reg_5(hw,(unsigned int)(((int)xid + 10240) * 16),1U);
    #line 298 
    ixgbe_write_reg_5(hw,(unsigned int)((int)xid * 16 + 163844),0U);
    #line 299 
    ixgbe_write_reg_5(hw,(unsigned int)((int)xid * 16 + 163852),fcfltrw);
  }
  else {
    #line 302 
    cif_spin_lock_bh_lock_of_ixgbe_fcoe(& fcoe->lock);
    #line 304 
    ixgbe_write_reg_5(hw,9232U,(unsigned int)ddp->udp);
    #line 305 
    ixgbe_write_reg_5(hw,9236U,(unsigned int)(ddp->udp >> 32));
    #line 306 
    ixgbe_write_reg_5(hw,9240U,fcbuff);
    #line 307 
    ixgbe_write_reg_5(hw,9248U,fcdmarw);
    #line 309 
    ixgbe_write_reg_5(hw,20952U,0U);
    #line 310 
    ixgbe_write_reg_5(hw,20744U,1U);
    #line 311 
    ixgbe_write_reg_5(hw,20752U,fcfltrw);
    #line 313 
    cif_spin_unlock_bh_lock_of_ixgbe_fcoe(& fcoe->lock);
  }
  #line 316 
  return 1;
  #line 318 
  out_noddp_free: 
                  #line 318 
  ;
  #line 319 
  dma_pool_free(ddp->pool,(void *)ddp->udl,ddp->udp);
  #line 320 
  ixgbe_fcoe_clear_ddp(ddp);
  #line 322 
  out_noddp_unmap: 
                   #line 322 
  ;
  #line 323 
  dma_unmap_sg_attrs(& (adapter->pdev)->dev,sgl,(int)sgc,(enum dma_data_direction)DMA_FROM_DEVICE,0UL);
  #line 324 
  out_noddp: 
             #line 324 
  ;
  #line 327 
  ldv_inline_asm();
  #line 325 
  __preempt_count_sub(1);
  #line 326 
  return 0;
}

#line 343  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fcoe_ddp_get(struct net_device *netdev, u16 xid, struct scatterlist *sgl, unsigned int sgc)
{
  #line 346 
  return ixgbe_fcoe_ddp_setup(netdev,(unsigned short)((int)xid),sgl,sgc,0);
}

#line 364  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fcoe_ddp_target(struct net_device *netdev, u16 xid, struct scatterlist *sgl, unsigned int sgc)
{
  #line 367 
  return ixgbe_fcoe_ddp_setup(netdev,(unsigned short)((int)xid),sgl,sgc,1);
}

#line 382  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fcoe_ddp(struct ixgbe_adapter *adapter, union ixgbe_adv_rx_desc *rx_desc, struct sk_buff *skb)
{
  #line 387 
  struct ixgbe_fcoe *fcoe;
  #line 388 
  struct ixgbe_fcoe_ddp *ddp;
  #line 389 
  struct fc_frame_header *fh;
  #line 390 
  struct fcoe_crc_eof *crc;
  #line 392 
  __le32 ddp_err;
  #line 393 
  int ddp_max;
  #line 394 
  u32 fctl;
  #line 395 
  u16 xid;
  #line 386 
  int rc = -22;
  #line 391 
  __le32 fcerr = ixgbe_test_staterr(rx_desc,7340032U);
  #line 397 
  if (fcerr == 1048576U) 
                         #line 398 
                         skb->ip_summed = (unsigned char)0U; else 
                                                                  #line 400 
                                                                  skb->ip_summed = (unsigned char)1U;
  #line 402 
  ;
  #line 402 
  if ((unsigned int)eth_hdr(skb)->h_proto == 129U) 
                                                   #line 403 
                                                   fh = (struct fc_frame_header *)(skb->data + 18UL); else 
                                                                    #line 406 
                                                                    fh = (struct fc_frame_header *)(skb->data + 14UL);
  #line 409 
  fctl = ntoh24((u8 *)(& fh->fh_f_ctl));
  #line 410 
  if ((fctl & 8388608U) != 0U) 
                               #line 411 
                               xid = __builtin_bswap16((unsigned short)((int)fh->fh_ox_id)); else 
                                                                    #line 413 
                                                                    xid = __builtin_bswap16((unsigned short)((int)fh->fh_rx_id));
  #line 415 
  ddp_max = 512;
  #line 417 
  if (adapter->hw.mac.type == (unsigned int)ixgbe_mac_X550) 
                                                            #line 418 
                                                            ddp_max = 2048;
  #line 419 
  if ((int)xid >= ddp_max) 
                           #line 420 
                           return -22;
  #line 422 
  fcoe = & adapter->fcoe;
  #line 423 
  ddp = & fcoe->ddp[(int)xid];
  #line 424 
  if (ddp->udl == (u64 *)0ULL) 
                               #line 425 
                               return -22;
  #line 427 
  ddp_err = ixgbe_test_staterr(rx_desc,2154823680U);
  #line 429 
  if (ddp_err != 0U) 
                     #line 430 
                     return -22;
  #line 432 
  switch (ixgbe_test_staterr(rx_desc,48U)) {
    #line 434 
    case (__le32)48: 
                     #line 434 
    ;
    #line 436 
    ddp->len = (int)rx_desc->wb.lower.hi_dword.rss;
    #line 437 
    rc = 0;
    #line 438 
    break;
    #line 440 
    case (__le32)32: 
                     #line 440 
    ;
    #line 441 
    dma_unmap_sg_attrs(& (adapter->pdev)->dev,ddp->sgl,(int)ddp->sgc,(enum dma_data_direction)DMA_FROM_DEVICE,0UL);
    #line 443 
    ddp->err = ddp_err;
    #line 444 
    ddp->sgl = (struct scatterlist *)0;
    #line 445 
    ddp->sgc = 0U;
    #line 448 
    case (__le32)16: 
                     #line 448 
    ;
    #line 450 
    ddp->len = (int)rx_desc->wb.lower.hi_dword.rss;
    #line 451 
    if (ddp->len != 0) 
                       #line 452 
                       rc = ddp->len;
    #line 453 
    break;
    #line 455 
    case (__le32)0: 
                    #line 455 
    ;
    #line 456 
    default: 
             #line 456 
    ;
    #line 457 
    break;
  }
  #line 467 
  if ((unsigned int)fh->fh_r_ctl == 1U && (fctl & 524288U) != 0U) {
    #line 469 
    skb_linearize(skb);
    #line 470 
    crc = (struct fcoe_crc_eof *)skb_put(skb,8U);
    #line 471 
    crc->fcoe_eof = (unsigned char)66U;
  }
  #line 474 
  return rc;
}

#line 487  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fso(struct ixgbe_ring *tx_ring, struct ixgbe_tx_buffer *first, u8 *hdr_len)
{
  #line 492 
  struct fc_frame_header *fh;
  #line 493 
  u32 vlan_macip_lens;
  #line 495 
  u32 mss_l4len_idx;
  #line 497 
  u8 sof;
  #line 497 
  u8 eof;
  #line 491 
  struct sk_buff *skb = first->__anonCompField_ixgbe_tx_buffer_217.skb;
  #line 494 
  u32 fcoe_sof_eof = 0U;
  #line 496 
  u32 type_tucmd = 32768U;
  #line 499 
  if ((int)skb_is_gso(skb) != 0) {
    #line 499 
    ;
    #line 499 
    if (((struct skb_shared_info *)skb_end_pointer(skb))->gso_type != 32U) {
      #line 500 
      ;
      #line 500 
      _dev_err(tx_ring->dev,(char *)"Wrong gso type %d:expecting SKB_GSO_FCOE\n",((struct skb_shared_info *)skb_end_pointer(skb))->gso_type);
      #line 502 
      return -22;
    }
  }
  #line 506 
  skb_set_network_header(skb,(int)skb->mac_len);
  #line 507 
  skb_set_transport_header(skb,(int)((unsigned int)skb->mac_len + 14U));
  #line 511 
  sof = ((struct fcoe_hdr *)skb_network_header(skb))->fcoe_sof;
  #line 512 
  switch ((int)sof) {
    #line 513 
    case 45: 
             #line 513 
    ;
    #line 514 
    fcoe_sof_eof = 32768U;
    #line 515 
    break;
    #line 516 
    case 46: 
             #line 516 
    ;
    #line 517 
    fcoe_sof_eof = 36864U;
    #line 519 
    break;
    #line 520 
    case 53: 
             #line 520 
    ;
    #line 521 
    break;
    #line 522 
    case 54: 
             #line 522 
    ;
    #line 523 
    fcoe_sof_eof = 4096U;
    #line 524 
    break;
    #line 525 
    default: 
             #line 525 
    ;
    #line 526 
    _dev_warn(tx_ring->dev,(char *)"unknown sof = 0x%x\n",(int)sof);
    #line 527 
    return -22;
  }
  #line 531 
  skb_copy_bits(skb,(int)(skb->len + 4294967292U),(void *)(& eof),1);
  #line 533 
  switch ((int)eof) {
    #line 534 
    case 65: 
             #line 534 
    ;
    #line 535 
    fcoe_sof_eof = fcoe_sof_eof;
    #line 536 
    break;
    #line 537 
    case 66: 
             #line 537 
    ;
    #line 539 
    if ((int)skb_is_gso(skb) != 0) 
                                   #line 540 
                                   fcoe_sof_eof |= 16384U; else 
                                                                #line 543 
                                                                fcoe_sof_eof |= 1024U;
    #line 544 
    break;
    #line 545 
    case 73: 
             #line 545 
    ;
    #line 546 
    fcoe_sof_eof |= 2048U;
    #line 547 
    break;
    #line 548 
    case 80: 
             #line 548 
    ;
    #line 549 
    fcoe_sof_eof |= 3072U;
    #line 550 
    break;
    #line 551 
    default: 
             #line 551 
    ;
    #line 552 
    _dev_warn(tx_ring->dev,(char *)"unknown eof = 0x%x\n",(int)eof);
    #line 553 
    return -22;
  }
  #line 557 
  fh = (struct fc_frame_header *)skb_transport_header(skb);
  #line 558 
  if (((int)fh->fh_f_ctl[2] & 8) != 0) 
                                       #line 559 
                                       fcoe_sof_eof |= 8192U;
  #line 562 
  *hdr_len = (unsigned char)8U;
  #line 565 
  if ((int)skb_is_gso(skb) != 0) {
    #line 567 
    *hdr_len = (unsigned char)((int)*hdr_len + (int)((unsigned char)((unsigned long)skb_transport_offset(skb) + 24UL)));
    #line 569 
    first->gso_segs = (unsigned short)((((skb->len - (unsigned int)*hdr_len) + (unsigned int)((struct skb_shared_info *)skb_end_pointer(skb))->gso_size) + 4294967295U) / (unsigned int)((struct skb_shared_info *)skb_end_pointer(skb))->gso_size);
    #line 571 
    first->bytecount += (unsigned int)(((int)first->gso_segs + -1) * (int)*hdr_len);
    #line 572 
    first->tx_flags |= 2U;
    #line 574 
    type_tucmd |= 6144U;
  }
  #line 578 
  first->tx_flags |= 264U;
  #line 581 
  mss_l4len_idx = (unsigned int)((int)((struct skb_shared_info *)skb_end_pointer(skb))->gso_size << 16);
  #line 584 
  vlan_macip_lens = (unsigned int)skb_transport_offset(skb) + 24U;
  #line 587 
  vlan_macip_lens = (unsigned int)((skb_transport_offset(skb) + -4) << 9) | vlan_macip_lens;
  #line 588 
  vlan_macip_lens = (first->tx_flags & 4294901760U) | vlan_macip_lens;
  #line 591 
  ixgbe_tx_ctxtdesc(tx_ring,vlan_macip_lens,fcoe_sof_eof,type_tucmd,mss_l4len_idx);
  #line 594 
  return 0;
}

#line 597  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
static void ixgbe_fcoe_dma_pool_free(struct ixgbe_fcoe *fcoe, unsigned int cpu)
{
  #line 601 
  unsigned long __ptr;
  #line 599 
  struct ixgbe_fcoe_ddp_pool *ddp_pool;
  {
    #line 601 
    void *__vpp_verify = (void *)0;
    #line 601 
    void *tmp = __vpp_verify;
  }
  #line 602 
  ldv_inline_asm();
  #line 601 
  ddp_pool = ((struct ixgbe_fcoe_ddp_pool *)(__per_cpu_offset[cpu] + __ptr));
  #line 602 
  dma_pool_destroy(ddp_pool->pool);
  #line 603 
  ddp_pool->pool = (struct dma_pool *)0;
  #line 604 
  return;
}

#line 606  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
static int ixgbe_fcoe_dma_pool_alloc(struct ixgbe_fcoe *fcoe, struct device *dev, unsigned int cpu)
{
  #line 621 
  unsigned long __ptr;
  #line 610 
  struct ixgbe_fcoe_ddp_pool *ddp_pool;
  #line 611 
  struct dma_pool *pool;
  #line 612 
  char pool_name[32U];
  #line 614 
  snprintf((char *)(& pool_name),32UL,(char *)"ixgbe_fcoe_ddp_%u",cpu);
  #line 616 
  pool = dma_pool_create((char *)(& pool_name),dev,2048UL,16UL,4096UL);
  #line 618 
  if (pool == (struct dma_pool *)0) 
                                    #line 619 
                                    return -12;
  {
    #line 621 
    void *__vpp_verify = (void *)0;
    #line 621 
    void *tmp = __vpp_verify;
  }
  #line 622 
  ldv_inline_asm();
  #line 621 
  ddp_pool = ((struct ixgbe_fcoe_ddp_pool *)(__per_cpu_offset[cpu] + __ptr));
  #line 622 
  ddp_pool->pool = pool;
  #line 623 
  ddp_pool->noddp = 0ULL;
  #line 624 
  ddp_pool->noddp_ext_buff = 0ULL;
  #line 626 
  return 0;
}

#line 637  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
void ixgbe_configure_fcoe(struct ixgbe_adapter *adapter)
{
  #line 641 
  int i;
  #line 641 
  int fcoe_q;
  #line 641 
  int fcoe_i;
  #line 642 
  int fcreta_size;
  #line 643 
  u32 etqf;
  #line 639 
  struct ixgbe_ring_feature *fcoe = & adapter->ring_feature[4];
  #line 640 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 641 
  int fcoe_q_h = 0;
  #line 646 
  if (((adapter->netdev)->features & 17179869184ULL) == 0ULL) 
                                                              #line 647 
                                                              return;
  #line 650 
  etqf = 2281736454U;
  #line 651 
  if (((unsigned long)adapter->flags & 8388608UL) != 0UL) {
    #line 652 
    etqf |= 67108864U;
    #line 653 
    etqf = (unsigned int)((int)adapter->ring_feature[1].offset << 20) | etqf;
  }
  #line 655 
  ixgbe_write_reg_5(hw,20784U,etqf);
  #line 656 
  ixgbe_write_reg_5(hw,60424U,0U);
  #line 659 
  if (((unsigned long)adapter->flags & 2097152UL) == 0UL) 
                                                          #line 660 
                                                          return;
  #line 663 
  fcreta_size = 8;
  #line 664 
  if (adapter->hw.mac.type == (unsigned int)ixgbe_mac_X550) 
                                                            #line 665 
                                                            fcreta_size = 32;
  #line 667 
  i = 0;
  #line 667 
  while (i < fcreta_size) {
    #line 668 
    if (adapter->hw.mac.type == (unsigned int)ixgbe_mac_X550) {
      #line 669 
      int fcoe_i_h = (int)fcoe->offset + (i + fcreta_size) % (int)fcoe->indices;
      #line 671 
      fcoe_q_h = (int)(adapter->rx_ring[fcoe_i_h])->reg_idx;
      #line 672 
      fcoe_q_h = (fcoe_q_h << 16) & 8323072;
    }
    #line 676 
    fcoe_i = (int)fcoe->offset + i % (int)fcoe->indices;
    #line 677 
    fcoe_i &= 127;
    #line 678 
    fcoe_q = (int)(adapter->rx_ring[fcoe_i])->reg_idx;
    #line 679 
    fcoe_q |= fcoe_q_h;
    #line 680 
    ixgbe_write_reg_5(hw,(unsigned int)((i + 15172) * 4),(unsigned int)fcoe_q);
    #line 667 
    i ++;
  }
  #line 682 
  ixgbe_write_reg_5(hw,60672U,1U);
  #line 685 
  etqf = 2147518740U;
  #line 686 
  if (((unsigned long)adapter->flags & 8388608UL) != 0UL) {
    #line 687 
    etqf |= 67108864U;
    #line 688 
    etqf = (unsigned int)((int)adapter->ring_feature[1].offset << 20) | etqf;
  }
  #line 690 
  ixgbe_write_reg_5(hw,20792U,etqf);
  #line 693 
  fcoe_q = (int)(adapter->rx_ring[(int)fcoe->offset])->reg_idx;
  #line 694 
  ixgbe_write_reg_5(hw,60432U,(unsigned int)(fcoe_q << 16) | 2147483648U);
  #line 699 
  ixgbe_write_reg_5(hw,20736U,128U);
  #line 700 
  return;
}

#line 712  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
void ixgbe_free_fcoe_ddp_resources(struct ixgbe_adapter *adapter)
{
  #line 715 
  int cpu;
  #line 715 
  int i;
  #line 715 
  int ddp_max;
  #line 714 
  struct ixgbe_fcoe *fcoe = & adapter->fcoe;
  #line 718 
  if (fcoe->ddp_pool == (struct ixgbe_fcoe_ddp_pool *)0) 
                                                         #line 719 
                                                         return;
  #line 721 
  ddp_max = 512;
  #line 723 
  if (adapter->hw.mac.type == (unsigned int)ixgbe_mac_X550) 
                                                            #line 724 
                                                            ddp_max = 2048;
  #line 726 
  i = 0;
  #line 726 
  while (i < ddp_max) {
    #line 727 
    ixgbe_fcoe_ddp_put(adapter->netdev,(unsigned short)((int)((unsigned short)i)));
    #line 726 
    i ++;
  }
  #line 729 
  cpu = -1;
  #line 729 
  while (1) {
    #line 729 
    cpu = (int)cpumask_next(cpu,& __cpu_possible_mask);
    #line 729 
    if (! ((unsigned int)cpu < nr_cpu_ids)) 
                                            #line 729 
                                            break;
    #line 730 
    ixgbe_fcoe_dma_pool_free(fcoe,(unsigned int)cpu);
  }
  #line 732 
  dma_unmap_single_attrs(& (adapter->pdev)->dev,fcoe->extra_ddp_buffer_dma,4096UL,(enum dma_data_direction)DMA_FROM_DEVICE,0UL);
  #line 736 
  kfree(fcoe->extra_ddp_buffer);
  #line 738 
  fcoe->extra_ddp_buffer = (void *)0;
  #line 739 
  fcoe->extra_ddp_buffer_dma = 0ULL;
  #line 740 
  return;
}

#line 750  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_setup_fcoe_ddp_resources(struct ixgbe_adapter *adapter)
{
  #line 754 
  void *buffer;
  #line 755 
  dma_addr_t dma;
  #line 756 
  unsigned int cpu;
  #line 752 
  struct ixgbe_fcoe *fcoe = & adapter->fcoe;
  #line 753 
  struct device *dev = & (adapter->pdev)->dev;
  #line 759 
  if (fcoe->ddp_pool == (struct ixgbe_fcoe_ddp_pool *)0) 
                                                         #line 760 
                                                         return 0;
  #line 763 
  buffer = kmalloc(4096UL,3264U);
  #line 764 
  if (buffer == (void *)0) 
                           #line 765 
                           return -12;
  #line 767 
  dma = dma_map_single_attrs(dev,buffer,4096UL,(enum dma_data_direction)DMA_FROM_DEVICE,0UL);
  #line 768 
  if (dma_mapping_error(dev,dma) != 0) {
    #line 769 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 769 
                                             netdev_err(adapter->netdev,(char *)"failed to map extra DDP buffer\n");
    #line 770 
    kfree(buffer);
    #line 771 
    return -12;
  }
  #line 774 
  fcoe->extra_ddp_buffer = buffer;
  #line 775 
  fcoe->extra_ddp_buffer_dma = dma;
  #line 778 
  cpu = 4294967295U;
  #line 778 
  while (1) {
    #line 778 
    cpu = cpumask_next((int)cpu,& __cpu_possible_mask);
    #line 778 
    if (! (cpu < nr_cpu_ids)) 
                              #line 778 
                              break;
    {
      #line 779 
      int err = ixgbe_fcoe_dma_pool_alloc(fcoe,dev,cpu);
      #line 780 
      if (err == 0) 
                    #line 781 
                    goto __Cont;
      #line 783 
      if (((int)adapter->msg_enable & 1) != 0) 
                                               #line 783 
                                               netdev_err(adapter->netdev,(char *)"failed to alloc DDP pool on cpu:%d\n",cpu);
      #line 784 
      ixgbe_free_fcoe_ddp_resources(adapter);
      #line 785 
      return -12;
    }
    #line 778 
    __Cont: 
            #line 778 
    ;
  }
  #line 788 
  return 0;
}

#line 791  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
static int ixgbe_fcoe_ddp_enable(struct ixgbe_adapter *adapter)
{
  #line 793 
  struct ixgbe_fcoe *fcoe = & adapter->fcoe;
  #line 795 
  if (((unsigned long)adapter->flags & 1048576UL) == 0UL) 
                                                          #line 796 
                                                          return -22;
  #line 798 
  fcoe->ddp_pool = (struct ixgbe_fcoe_ddp_pool *)__alloc_percpu(24UL,8UL);
  #line 800 
  if (fcoe->ddp_pool == (struct ixgbe_fcoe_ddp_pool *)0) {
    #line 801 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 801 
                                             netdev_err(adapter->netdev,(char *)"failed to allocate percpu DDP resources\n");
    #line 802 
    return -12;
  }
  #line 805 
  (adapter->netdev)->fcoe_ddp_xid = 511U;
  #line 807 
  if (adapter->hw.mac.type == (unsigned int)ixgbe_mac_X550) 
                                                            #line 808 
                                                            (adapter->netdev)->fcoe_ddp_xid = 2047U;
  #line 810 
  return 0;
}

#line 813  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
static void ixgbe_fcoe_ddp_disable(struct ixgbe_adapter *adapter)
{
  #line 815 
  struct ixgbe_fcoe *fcoe = & adapter->fcoe;
  #line 817 
  (adapter->netdev)->fcoe_ddp_xid = 0U;
  #line 819 
  if (fcoe->ddp_pool == (struct ixgbe_fcoe_ddp_pool *)0) 
                                                         #line 820 
                                                         return;
  #line 822 
  free_percpu((void *)fcoe->ddp_pool);
  #line 823 
  fcoe->ddp_pool = (struct ixgbe_fcoe_ddp_pool *)0;
  #line 824 
  return;
}

#line 834  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fcoe_enable(struct net_device *netdev)
{
  #line 836 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 837 
  struct ixgbe_fcoe *fcoe = & adapter->fcoe;
  #line 839 
  atomic_inc(& fcoe->refcnt);
  #line 841 
  if (((unsigned long)adapter->flags & 1048576UL) == 0UL) 
                                                          #line 842 
                                                          return -22;
  #line 844 
  if (((unsigned long)adapter->flags & 2097152UL) != 0UL) 
                                                          #line 845 
                                                          return -22;
  #line 847 
  if (((int)adapter->msg_enable & 1) != 0) 
                                           #line 847 
                                           netdev_info(adapter->netdev,(char *)"Enabling FCoE offload features.\n");
  #line 849 
  if (((unsigned long)adapter->flags & 8388608UL) != 0UL) 
    #line 850 
    if (((int)adapter->msg_enable & 2) != 0) 
                                             #line 850 
                                             netdev_warn(adapter->netdev,(char *)"Enabling FCoE on PF will disable legacy VFs\n");
  #line 852 
  if ((int)netif_running(netdev) != 0) 
                                       #line 853 
                                       (*((netdev->netdev_ops)->ndo_stop))(netdev);
  #line 856 
  ixgbe_fcoe_ddp_enable(adapter);
  #line 859 
  adapter->flags |= 2097152U;
  #line 860 
  netdev->features |= 68719476736ULL;
  #line 861 
  netdev_features_change(netdev);
  #line 864 
  ixgbe_clear_interrupt_scheme(adapter);
  #line 865 
  ixgbe_init_interrupt_scheme(adapter);
  #line 867 
  if ((int)netif_running(netdev) != 0) 
                                       #line 868 
                                       (*((netdev->netdev_ops)->ndo_open))(netdev);
  #line 870 
  return 0;
}

#line 881  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fcoe_disable(struct net_device *netdev)
{
  #line 883 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 885 
  if (! atomic_dec_and_test(& adapter->fcoe.refcnt)) 
                                                     #line 886 
                                                     return -22;
  #line 888 
  if (((unsigned long)adapter->flags & 2097152UL) == 0UL) 
                                                          #line 889 
                                                          return -22;
  #line 891 
  if (((int)adapter->msg_enable & 1) != 0) 
                                           #line 891 
                                           netdev_info(adapter->netdev,(char *)"Disabling FCoE offload features.\n");
  #line 892 
  if ((int)netif_running(netdev) != 0) 
                                       #line 893 
                                       (*((netdev->netdev_ops)->ndo_stop))(netdev);
  #line 896 
  ixgbe_fcoe_ddp_disable(adapter);
  #line 899 
  adapter->flags &= 4292870143U;
  #line 900 
  netdev->features &= 18446744004990074879ULL;
  #line 902 
  netdev_features_change(netdev);
  #line 905 
  ixgbe_clear_interrupt_scheme(adapter);
  #line 906 
  ixgbe_init_interrupt_scheme(adapter);
  #line 908 
  if ((int)netif_running(netdev) != 0) 
                                       #line 909 
                                       (*((netdev->netdev_ops)->ndo_open))(netdev);
  #line 911 
  return 0;
}

#line 926  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fcoe_get_wwn(struct net_device *netdev, u64 *wwn, int type)
{
  #line 928 
  u16 prefix = (unsigned short)65535U;
  #line 929 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 930 
  struct ixgbe_mac_info *mac = & adapter->hw.mac;
  #line 932 
  switch (type) {
    #line 933 
    case 0: 
            #line 933 
    ;
    #line 934 
    prefix = mac->wwnn_prefix;
    #line 935 
    break;
    #line 936 
    case 1: 
            #line 936 
    ;
    #line 937 
    prefix = mac->wwpn_prefix;
    #line 938 
    break;
    #line 939 
    default: 
             #line 939 
    ;
    #line 940 
    break;
  }
  #line 943 
  if ((unsigned int)prefix != 65535U) {
    #line 943 
    if ((int)is_valid_ether_addr((u8 *)(& mac->san_addr)) != 0) {
      #line 945 
      *wwn = (((((((unsigned long long)prefix << 48) | ((unsigned long long)mac->san_addr[0] << 40)) | ((unsigned long long)mac->san_addr[1] << 32)) | ((unsigned long long)mac->san_addr[2] << 24)) | ((unsigned long long)mac->san_addr[3] << 16)) | ((unsigned long long)mac->san_addr[4] << 8)) | (unsigned long long)mac->san_addr[5];
      #line 952 
      return 0;
    }
  }
  #line 954 
  return -22;
}

#line 966  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fcoe_get_hbainfo(struct net_device *netdev, struct netdev_fcoe_hbainfo *info)
{
  #line 971 
  int i;
  #line 971 
  int pos;
  #line 972 
  u8 buf[8U];
  #line 969 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 970 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 974 
  if (info == (struct netdev_fcoe_hbainfo *)0) 
                                               #line 975 
                                               return -22;
  #line 978 
  if (((unsigned long)adapter->flags & 2097152UL) == 0UL) 
                                                          #line 979 
                                                          return -22;
  #line 982 
  snprintf((char *)(& info->manufacturer),64UL,(char *)"Intel Corporation");
  #line 988 
  pos = pci_find_ext_capability(adapter->pdev,3);
  #line 989 
  if (pos != 0) {
    #line 990 
    pos += 4;
    #line 991 
    i = 0;
    #line 991 
    while (i <= 7) {
      #line 992 
      pci_read_config_byte(adapter->pdev,pos + i,& buf[i]);
      #line 991 
      i ++;
    }
    #line 994 
    snprintf((char *)(& info->serial_number),64UL,(char *)"%02X%02X%02X%02X%02X%02X%02X%02X",(int)buf[7],(int)buf[6],(int)buf[5],(int)buf[4],(int)buf[3],(int)buf[2],(int)buf[1],(int)buf[0]);
  }
  else 
       #line 999 
       snprintf((char *)(& info->serial_number),64UL,(char *)"Unknown");
  #line 1003 
  snprintf((char *)(& info->hardware_version),64UL,(char *)"Rev %d",(int)hw->revision_id);
  #line 1007 
  snprintf((char *)(& info->driver_version),64UL,(char *)"%s v%s",(char *)(& ixgbe_driver_name),(char *)(& ixgbe_driver_version));
  #line 1013 
  strlcpy((char *)(& info->firmware_version),(char *)(& adapter->eeprom_id),64UL);
  #line 1017 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82599EB) 
                                                       #line 1018 
                                                       snprintf((char *)(& info->model),256UL,(char *)"Intel 82599");
  else 
    #line 1021 
    if (hw->mac.type == (unsigned int)ixgbe_mac_X550) 
                                                      #line 1022 
                                                      snprintf((char *)(& info->model),256UL,(char *)"Intel X550"); else 
                                                                    #line 1026 
                                                                    snprintf((char *)(& info->model),256UL,(char *)"Intel X540");
  #line 1032 
  snprintf((char *)(& info->model_description),256UL,(char *)"%s",(char *)(& ixgbe_default_device_descr));
  #line 1037 
  return 0;
}

#line 1046  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
u8 ixgbe_fcoe_get_tc(struct ixgbe_adapter *adapter)
{
  #line 1049 
  return (unsigned char)netdev_get_prio_tc_map(adapter->netdev,(unsigned int)adapter->fcoe.up);
}

#line 121  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_fcoe.i.aux"
static void cif_set_bit_2(long nr, unsigned long *addr)
{
  #line 124 
  ldv_set_bit(nr,addr);
  #line 125 
  return;
}

#line 184  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_fcoe.i.aux"
static void atomic_inc(atomic_t *v)
{
  #line 187 
  ldv_atomic_inc(v);
  #line 188 
  return;
}

#line 451  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_fcoe.i.aux"
static void *kmalloc(size_t size, gfp_t flags)
{
  #line 454 
  return ldv_kmalloc(size,flags);
}

#line 687  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_fcoe.i.aux"
static void cif_spin_lock_bh_lock_of_ixgbe_fcoe(spinlock_t *lock)
{
  #line 690 
  ldv_spin_model_lock((char *)"lock_of_ixgbe_fcoe");
  #line 692 
  spin_lock_bh(lock);
  #line 693 
  return;
}

#line 696  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_fcoe.i.aux"
static void cif_spin_unlock_bh_lock_of_ixgbe_fcoe(spinlock_t *lock)
{
  #line 699 
  ldv_spin_model_unlock((char *)"lock_of_ixgbe_fcoe");
  #line 701 
  spin_unlock_bh(lock);
  #line 702 
  return;
}

#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
#line 323  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
static void cif_set_bit_3(long nr, unsigned long *addr);
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
#line 330  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
static void cif_clear_bit_0(long nr, unsigned long *addr);
#line 204  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernel.h"
#line 204 
void __might_sleep(char *, int, int);
#line 741  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void INIT_HLIST_NODE(struct hlist_node *h)
{
  #line 743 
  h->next = (struct hlist_node *)0;
  #line 744 
  h->pprev = (struct hlist_node **)0;
  #line 745 
  return;
}

#line 752  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static int hlist_empty_0(struct hlist_head *h)
{
  #line 755 
  union __anonunion___u_7084 __u;
  #line 754 
  __read_once_size((void *)(& h->first),(void *)(& __u.__c),8);
  #line 754 
  return (__u.__val) == (struct hlist_node *)0;
}

#line 757  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void __hlist_del_0(struct hlist_node *n)
{
  #line 759 
  struct hlist_node *next = n->next;
  #line 760 
  struct hlist_node **pprev = n->pprev;
  {
    #line 763 
    union __anonunion___u_7086 __u = {.__val = next};
    #line 762 
    __write_once_size((void *)pprev,(void *)(& __u.__c),8);
    #line 762 
    struct hlist_node *tmp = __u.__val;
  }
  #line 763 
  if (next != (struct hlist_node *)0) 
                                      #line 764 
                                      next->pprev = pprev;
  #line 765 
  return;
}

#line 767  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void hlist_del_0(struct hlist_node *n)
{
  #line 769 
  __hlist_del_0(n);
  #line 770 
  n->next = (struct hlist_node *)(-2401263026318606080);
  #line 771 
  n->pprev = (struct hlist_node **)(-2401263026318606046);
  #line 772 
  return;
}

#line 782  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void hlist_add_head(struct hlist_node *n, struct hlist_head *h)
{
  #line 784 
  struct hlist_node *first = h->first;
  #line 785 
  n->next = first;
  #line 786 
  if (first != (struct hlist_node *)0) 
                                       #line 787 
                                       first->pprev = & n->next;
  {
    #line 789 
    union __anonunion___u_7088 __u = {.__val = n};
    #line 788 
    __write_once_size((void *)(& h->first),(void *)(& __u.__c),8);
    #line 788 
    struct hlist_node *tmp = __u.__val;
  }
  #line 789 
  n->pprev = & h->first;
  #line 790 
  return;
}

#line 802  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void hlist_add_behind(struct hlist_node *n, struct hlist_node *prev)
{
  #line 805 
  n->next = prev->next;
  #line 806 
  prev->next = n;
  #line 807 
  n->pprev = & prev->next;
  #line 809 
  if (n->next != (struct hlist_node *)0) 
                                         #line 810 
                                         (n->next)->pprev = & n->next;
  #line 811 
  return;
}

#line 336  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock.h"
static void spin_lock_0(spinlock_t *lock)
{
  #line 338 
  _raw_spin_lock(& lock->__anonCompField_spinlock_25.rlock);
  #line 339 
  return;
}

#line 340 
#line 919  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
static void cif_spin_lock_fdir_perfect_lock_of_ixgbe_adapter_0(spinlock_t *lock);
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock.h"
static void spin_unlock_0(spinlock_t *lock)
{
  #line 378 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_25.rlock);
  #line 379 
  return;
}

#line 380 
#line 928  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
static void cif_spin_unlock_fdir_perfect_lock_of_ixgbe_adapter_0(spinlock_t *lock);
#line 26  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
#line 26 
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags);
#line 253  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/overflow.h"
__inline static size_t array_size(size_t a, size_t b)
{
  #line 257 
  size_t *__d;
  #line 257 
  size_t __a;
  #line 257 
  size_t __b;
  #line 255 
  size_t bytes;
  {
    #line 257 
    __a = a;
    #line 257 
    __b = b;
    #line 257 
    __d = & bytes;
    #line 257 
    int tmp = & __a == __d;
    }
  #line 257 
  if (__builtin_mul_overflow(__a,__b,__d) != 0) 
                                                #line 258 
                                                return 18446744073709551615UL;
  #line 260 
  return bytes;
}

#line 104  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/vmalloc.h"
#line 889  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
static void *cif_vmalloc_0(unsigned long size);
#line 130  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/vmalloc.h"
#line 896  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
static void cif_vfree_0(void *addr);
#line 162  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/interrupt.h"
#line 903  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
static int cif_request_irq_0(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char *name, void *dev);
#line 189  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/interrupt.h"
#line 911  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
static void *cif_free_irq_0(unsigned int ldv_func_arg1, void *ldv_func_arg2);
#line 542  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 587  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
static void *kmalloc_0(size_t size, gfp_t flags);
#line 590  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 594  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
static void *kmalloc_array(size_t n, size_t size, gfp_t flags);
#line 668  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 622  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
static void *kzalloc_1(size_t size, gfp_t flags);
#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pm_wakeup.h"
__inline static bool device_can_wakeup(struct device *dev)
{
  #line 79 
  return (_Bool)((int)dev->power.can_wakeup != 0);
}

#line 60  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/delay.h"
#line 60 
unsigned long msleep_interruptible(unsigned int);
#line 1019  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
#line 1019 
void kfree_skb(struct sk_buff *);
#line 1032 
#line 1032 
struct sk_buff *__alloc_skb(unsigned int, gfp_t, int, int);
#line 1046  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static struct sk_buff *alloc_skb(unsigned int size, gfp_t priority)
{
  #line 1049 
  return __alloc_skb(size,priority,0,-1);
}

#line 86  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ethtool.h"
#line 86 
u32 ethtool_op_get_link(struct net_device *);
#line 87 
#line 87 
int ethtool_op_get_ts_info(struct net_device *, struct ethtool_ts_info *);
#line 173 
#line 173 
void ethtool_convert_legacy_u32_to_link_mode(unsigned long *, u32);
#line 177 
#line 177 
bool ethtool_convert_link_mode_to_legacy_u32(u32 *, unsigned long *);
#line 3341  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netdev_tx_reset_queue_0(struct netdev_queue *q)
{
  #line 3344 
  cif_clear_bit_0(1L,& q->state);
  #line 3345 
  dql_reset(& q->dql);
  #line 3346 
  return;
}

#line 4263 
#line 4263 
struct rtnl_link_stats64 *dev_get_stats(struct net_device *, struct rtnl_link_stats64 *);
#line 81  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/highmem.h"
__inline static void *kmap(struct page *page)
{
  #line 83 
  __might_sleep((char *)"./include/linux/highmem.h",83,0);
  #line 84 
  return lowmem_page_address(page);
}

#line 87  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/highmem.h"
__inline static void kunmap(struct page *page)
{
  #line 89 
  return;
}

#line 213  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ptp_clock_kernel.h"
#line 213 
int ptp_clock_index(struct ptp_clock *);
#line 94  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
#line 94 
s32 ixgbe_fw_phy_activity(struct ixgbe_hw *hw, u16 activity, u32 (*data)[4U]);
#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static void ixgbe_write_reg_6(struct ixgbe_hw *hw, u32 reg, u32 value)
{
  #line 147 
  union __anonunion___u_7785 __u;
  #line 146 
  __read_once_size((void *)(& hw->hw_addr),(void *)(& __u.__c),8);
  #line 146 
  u8 *reg_addr = (__u.__val);
  #line 148 
  if ((int)ixgbe_removed((void *)reg_addr) != 0) 
                                                 #line 149 
                                                 return;
  #line 150 
  writel(value,(void *)(reg_addr + (unsigned long)reg));
  #line 151 
  return;
}

#line 903  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 903 
s32 ixgbe_fdir_erase_perfect_filter_82599(struct ixgbe_hw *hw, union ixgbe_atr_input *input, u16 soft_id);
#line 39  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static struct ixgbe_stats ixgbe_gstrings_stats[64U] = {{.stat_string = {(char)'r', (char)'x', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s'}, .sizeof_stat = 8}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s'}, .sizeof_stat = 8, .stat_offset = 8}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s'}, .sizeof_stat = 8, .stat_offset = 16}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s'}, .sizeof_stat = 8, .stat_offset = 24}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'p', (char)'k', (char)'t', (char)'s', (char)'_', (char)'n', (char)'i', (char)'c'}, .type = 1, .sizeof_stat = 8, .stat_offset = 39096}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'p', (char)'k', (char)'t', (char)'s', (char)'_', (char)'n', (char)'i', (char)'c'}, .type = 1, .sizeof_stat = 8, .stat_offset = 39120}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s', (char)'_', (char)'n', (char)'i', (char)'c'}, .type = 1, .sizeof_stat = 8, .stat_offset = 39128}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s', (char)'_', (char)'n', (char)'i', (char)'c'}, .type = 1, .sizeof_stat = 8, .stat_offset = 39136}, {.stat_string = {(char)'l', (char)'s', (char)'c', (char)'_', (char)'i', (char)'n', (char)'t'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1672}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'b', (char)'u', (char)'s', (char)'y'}, .type = 1, .sizeof_stat = 8, .stat_offset = 40400}, {.stat_string = {(char)'n', (char)'o', (char)'n', (char)'_', (char)'e', (char)'o', (char)'p', (char)'_', (char)'d', (char)'e', (char)'s', (char)'c', (char)'s'}, .type = 1, .sizeof_stat = 8, .stat_offset = 2240}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s'}, .sizeof_stat = 8, .stat_offset = 32}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s'}, .sizeof_stat = 8, .stat_offset = 40}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'d', (char)'r', (char)'o', (char)'p', (char)'p', (char)'e', (char)'d'}, .sizeof_stat = 8, .stat_offset = 48}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'d', (char)'r', (char)'o', (char)'p', (char)'p', (char)'e', (char)'d'}, .sizeof_stat = 8, .stat_offset = 56}, {.stat_string = {(char)'m', (char)'u', (char)'l', (char)'t', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t'}, .sizeof_stat = 8, .stat_offset = 64}, {.stat_string = {(char)'b', (char)'r', (char)'o', (char)'a', (char)'d', (char)'c', (char)'a', (char)'s', (char)'t'}, .type = 1, .sizeof_stat = 8, .stat_offset = 39104}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'n', (char)'o', (char)'_', (char)'b', (char)'u', (char)'f', (char)'f', (char)'e', (char)'r', (char)'_', (char)'c', (char)'o', (char)'u', (char)'n', (char)'t'}, .type = 1, .sizeof_stat = 8, .stat_offset = 39144}, {.stat_string = {(char)'c', (char)'o', (char)'l', (char)'l', (char)'i', (char)'s', (char)'i', (char)'o', (char)'n', (char)'s'}, .sizeof_stat = 8, .stat_offset = 72}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'o', (char)'v', (char)'e', (char)'r', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s'}, .sizeof_stat = 8, .stat_offset = 88}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'c', (char)'r', (char)'c', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s'}, .sizeof_stat = 8, .stat_offset = 96}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'f', (char)'r', (char)'a', (char)'m', (char)'e', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s'}, .sizeof_stat = 8, .stat_offset = 104}, {.stat_string = {(char)'h', (char)'w', (char)'_', (char)'r', (char)'s', (char)'c', (char)'_', (char)'a', (char)'g', (char)'g', (char)'r', (char)'e', (char)'g', (char)'a', (char)'t', (char)'e', (char)'d'}, .type = 1, .sizeof_stat = 8, .stat_offset = 2224}, {.stat_string = {(char)'h', (char)'w', (char)'_', (char)'r', (char)'s', (char)'c', (char)'_', (char)'f', (char)'l', (char)'u', (char)'s', (char)'h', (char)'e', (char)'d'}, .type = 1, .sizeof_stat = 8, .stat_offset = 2232}, {.stat_string = {(char)'f', (char)'d', (char)'i', (char)'r', (char)'_', (char)'m', (char)'a', (char)'t', (char)'c', (char)'h'}, .type = 1, .sizeof_stat = 8, .stat_offset = 40288}, {.stat_string = {(char)'f', (char)'d', (char)'i', (char)'r', (char)'_', (char)'m', (char)'i', (char)'s', (char)'s'}, .type = 1, .sizeof_stat = 8, .stat_offset = 40296}, {.stat_string = {(char)'f', (char)'d', (char)'i', (char)'r', (char)'_', (char)'o', (char)'v', (char)'e', (char)'r', (char)'f', (char)'l', (char)'o', (char)'w'}, .type = 1, .sizeof_stat = 8, .stat_offset = 40624}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'f', (char)'i', (char)'f', (char)'o', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s'}, .sizeof_stat = 8, .stat_offset = 112}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'m', (char)'i', (char)'s', (char)'s', (char)'e', (char)'d', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s'}, .sizeof_stat = 8, .stat_offset = 120}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'a', (char)'b', (char)'o', (char)'r', (char)'t', (char)'e', (char)'d', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s'}, .sizeof_stat = 8, .stat_offset = 128}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'c', (char)'a', (char)'r', (char)'r', (char)'i', (char)'e', (char)'r', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s'}, .sizeof_stat = 8, .stat_offset = 136}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'f', (char)'i', (char)'f', (char)'o', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s'}, .sizeof_stat = 8, .stat_offset = 144}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'h', (char)'e', (char)'a', (char)'r', (char)'t', (char)'b', (char)'e', (char)'a', (char)'t', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s'}, .sizeof_stat = 8, .stat_offset = 152}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'t', (char)'i', (char)'m', (char)'e', (char)'o', (char)'u', (char)'t', (char)'_', (char)'c', (char)'o', (char)'u', (char)'n', (char)'t'}, .type = 1, .sizeof_stat = 4, .stat_offset = 1680}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'r', (char)'e', (char)'s', (char)'t', (char)'a', (char)'r', (char)'t', (char)'_', (char)'q', (char)'u', (char)'e', (char)'u', (char)'e'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1664}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'l', (char)'e', (char)'n', (char)'g', (char)'t', (char)'h', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s'}, .type = 1, .sizeof_stat = 8, .stat_offset = 38752}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'l', (char)'o', (char)'n', (char)'g', (char)'_', (char)'l', (char)'e', (char)'n', (char)'g', (char)'t', (char)'h', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s'}, .type = 1, .sizeof_stat = 8, .stat_offset = 39224}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'s', (char)'h', (char)'o', (char)'r', (char)'t', (char)'_', (char)'l', (char)'e', (char)'n', (char)'g', (char)'t', (char)'h', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s'}, .type = 1, .sizeof_stat = 8, .stat_offset = 39208}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'f', (char)'l', (char)'o', (char)'w', (char)'_', (char)'c', (char)'o', (char)'n', (char)'t', (char)'r', (char)'o', (char)'l', (char)'_', (char)'x', (char)'o', (char)'n'}, .type = 1, .sizeof_stat = 8, .stat_offset = 38760}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'f', (char)'l', (char)'o', (char)'w', (char)'_', (char)'c', (char)'o', (char)'n', (char)'t', (char)'r', (char)'o', (char)'l', (char)'_', (char)'x', (char)'o', (char)'n'}, .type = 1, .sizeof_stat = 8, .stat_offset = 38768}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'f', (char)'l', (char)'o', (char)'w', (char)'_', (char)'c', (char)'o', (char)'n', (char)'t', (char)'r', (char)'o', (char)'l', (char)'_', (char)'x', (char)'o', (char)'f', (char)'f'}, .type = 1, .sizeof_stat = 8, .stat_offset = 38776}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'f', (char)'l', (char)'o', (char)'w', (char)'_', (char)'c', (char)'o', (char)'n', (char)'t', (char)'r', (char)'o', (char)'l', (char)'_', (char)'x', (char)'o', (char)'f', (char)'f'}, .type = 1, .sizeof_stat = 8, .stat_offset = 38784}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'c', (char)'s', (char)'u', (char)'m', (char)'_', (char)'o', (char)'f', (char)'f', (char)'l', (char)'o', (char)'a', (char)'d', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s'}, .type = 1, .sizeof_stat = 8, .stat_offset = 2208}, {.stat_string = {(char)'a', (char)'l', (char)'l', (char)'o', (char)'c', (char)'_', (char)'r', (char)'x', (char)'_', (char)'p', (char)'a', (char)'g', (char)'e'}, .type = 1, .sizeof_stat = 4, .stat_offset = 2248}, {.stat_string = {(char)'a', (char)'l', (char)'l', (char)'o', (char)'c', (char)'_', (char)'r', (char)'x', (char)'_', (char)'p', (char)'a', (char)'g', (char)'e', (char)'_', (char)'f', (char)'a', (char)'i', (char)'l', (char)'e', (char)'d'}, .type = 1, .sizeof_stat = 4, .stat_offset = 2252}, {.stat_string = {(char)'a', (char)'l', (char)'l', (char)'o', (char)'c', (char)'_', (char)'r', (char)'x', (char)'_', (char)'b', (char)'u', (char)'f', (char)'f', (char)'_', (char)'f', (char)'a', (char)'i', (char)'l', (char)'e', (char)'d'}, .type = 1, .sizeof_stat = 4, .stat_offset = 2256}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'n', (char)'o', (char)'_', (char)'d', (char)'m', (char)'a', (char)'_', (char)'r', (char)'e', (char)'s', (char)'o', (char)'u', (char)'r', (char)'c', (char)'e', (char)'s'}, .type = 1, .sizeof_stat = 8, .stat_offset = 2216}, {.stat_string = {(char)'o', (char)'s', (char)'2', (char)'b', (char)'m', (char)'c', (char)'_', (char)'r', (char)'x', (char)'_', (char)'b', (char)'y', (char)'_', (char)'b', (char)'m', (char)'c'}, .type = 1, .sizeof_stat = 8, .stat_offset = 40384}, {.stat_string = {(char)'o', (char)'s', (char)'2', (char)'b', (char)'m', (char)'c', (char)'_', (char)'t', (char)'x', (char)'_', (char)'b', (char)'y', (char)'_', (char)'b', (char)'m', (char)'c'}, .type = 1, .sizeof_stat = 8, .stat_offset = 40368}, {.stat_string = {(char)'o', (char)'s', (char)'2', (char)'b', (char)'m', (char)'c', (char)'_', (char)'t', (char)'x', (char)'_', (char)'b', (char)'y', (char)'_', (char)'h', (char)'o', (char)'s', (char)'t'}, .type = 1, .sizeof_stat = 8, .stat_offset = 40392}, {.stat_string = {(char)'o', (char)'s', (char)'2', (char)'b', (char)'m', (char)'c', (char)'_', (char)'r', (char)'x', (char)'_', (char)'b', (char)'y', (char)'_', (char)'h', (char)'o', (char)'s', (char)'t'}, .type = 1, .sizeof_stat = 8, .stat_offset = 40376}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'h', (char)'w', (char)'t', (char)'s', (char)'t', (char)'a', (char)'m', (char)'p', (char)'_', (char)'t', (char)'i', (char)'m', (char)'e', (char)'o', (char)'u', (char)'t', (char)'s'}, .type = 1, .sizeof_stat = 4, .stat_offset = 139660}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'h', (char)'w', (char)'t', (char)'s', (char)'t', (char)'a', (char)'m', (char)'p', (char)'_', (char)'s', (char)'k', (char)'i', (char)'p', (char)'p', (char)'e', (char)'d'}, .type = 1, .sizeof_stat = 4, .stat_offset = 139664}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'h', (char)'w', (char)'t', (char)'s', (char)'t', (char)'a', (char)'m', (char)'p', (char)'_', (char)'c', (char)'l', (char)'e', (char)'a', (char)'r', (char)'e', (char)'d'}, .type = 1, .sizeof_stat = 4, .stat_offset = 139668}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'i', (char)'p', (char)'s', (char)'e', (char)'c'}, .type = 1, .sizeof_stat = 8, .stat_offset = 568}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'i', (char)'p', (char)'s', (char)'e', (char)'c'}, .type = 1, .sizeof_stat = 8, .stat_offset = 584}, {.stat_string = {(char)'f', (char)'c', (char)'o', (char)'e', (char)'_', (char)'b', (char)'a', (char)'d', (char)'_', (char)'f', (char)'c', (char)'c', (char)'r', (char)'c'}, .type = 1, .sizeof_stat = 8, .stat_offset = 40304}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'f', (char)'c', (char)'o', (char)'e', (char)'_', (char)'d', (char)'r', (char)'o', (char)'p', (char)'p', (char)'e', (char)'d'}, .type = 1, .sizeof_stat = 8, .stat_offset = 40312}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'f', (char)'c', (char)'o', (char)'e', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s'}, .type = 1, .sizeof_stat = 8, .stat_offset = 40320}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'f', (char)'c', (char)'o', (char)'e', (char)'_', (char)'d', (char)'w', (char)'o', (char)'r', (char)'d', (char)'s'}, .type = 1, .sizeof_stat = 8, .stat_offset = 40336}, {.stat_string = {(char)'f', (char)'c', (char)'o', (char)'e', (char)'_', (char)'n', (char)'o', (char)'d', (char)'d', (char)'p'}, .type = 1, .sizeof_stat = 8, .stat_offset = 40352}, {.stat_string = {(char)'f', (char)'c', (char)'o', (char)'e', (char)'_', (char)'n', (char)'o', (char)'d', (char)'d', (char)'p', (char)'_', (char)'e', (char)'x', (char)'t', (char)'_', (char)'b', (char)'u', (char)'f', (char)'f'}, .type = 1, .sizeof_stat = 8, .stat_offset = 40360}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'f', (char)'c', (char)'o', (char)'e', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s'}, .type = 1, .sizeof_stat = 8, .stat_offset = 40328}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'f', (char)'c', (char)'o', (char)'e', (char)'_', (char)'d', (char)'w', (char)'o', (char)'r', (char)'d', (char)'s'}, .type = 1, .sizeof_stat = 8, .stat_offset = 40344}};
#line 129  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static char ixgbe_gstrings_test[5U][32U] = {{(char)'R', (char)'e', (char)'g', (char)'i', (char)'s', (char)'t', (char)'e', (char)'r', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)' ', (char)'(', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')'}, {(char)'E', (char)'e', (char)'p', (char)'r', (char)'o', (char)'m', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)' ', (char)' ', (char)' ', (char)'(', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')'}, {(char)'I', (char)'n', (char)'t', (char)'e', (char)'r', (char)'r', (char)'u', (char)'p', (char)'t', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)'(', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')'}, {(char)'L', (char)'o', (char)'o', (char)'p', (char)'b', (char)'a', (char)'c', (char)'k', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)' ', (char)'(', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')'}, {(char)'L', (char)'i', (char)'n', (char)'k', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)' ', (char)' ', (char)'(', (char)'o', (char)'n', (char)'/', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')'}};
#line 136  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static char ixgbe_priv_flags_strings[2U][32U] = {{(char)'l', (char)'e', (char)'g', (char)'a', (char)'c', (char)'y', (char)'-', (char)'r', (char)'x'}, {(char)'v', (char)'f', (char)'-', (char)'i', (char)'p', (char)'s', (char)'e', (char)'c'}};
#line 152  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static u32 ixgbe_get_supported_10gtypes(struct ixgbe_hw *hw)
{
  #line 154 
  if (hw->phy.media_type != (unsigned int)ixgbe_media_type_backplane) 
    #line 155 
    return 4096U;
  #line 157 
  switch ((int)hw->device_id) {
    #line 158 
    case 4278: 
               #line 158 
    ;
    #line 159 
    case 4343: 
               #line 159 
    ;
    #line 160 
    case 5396: 
               #line 160 
    ;
    #line 161 
    case 5546: 
               #line 161 
    ;
    #line 162 
    return 262144U;
    #line 163 
    case 5384: 
               #line 163 
    ;
    #line 164 
    case 5399: 
               #line 164 
    ;
    #line 165 
    case 5547: 
               #line 165 
    ;
    #line 166 
    case 5552: 
               #line 166 
    ;
    #line 167 
    return 524288U;
    #line 168 
    default: 
             #line 168 
    ;
    #line 169 
    return 786432U;
  }
}

#line 174  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_link_ksettings(struct net_device *netdev, struct ethtool_link_ksettings *cmd)
{
  #line 179 
  ixgbe_link_speed supported_link;
  #line 181 
  u32 supported;
  #line 181 
  u32 advertising;
  #line 177 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 178 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 180 
  bool autoneg = (_Bool)0;
  #line 183 
  ethtool_convert_link_mode_to_legacy_u32(& supported,(unsigned long *)(& cmd->link_modes.supported));
  #line 186 
  (*(hw->mac.ops.get_link_capabilities))(hw,& supported_link,& autoneg);
  #line 189 
  if ((supported_link & 128U) != 0U) {
    #line 190 
    supported = ixgbe_get_supported_10gtypes(hw) | supported;
  }
  #line 191 
  if ((supported_link & 32U) != 0U) {
    #line 192 
    unsigned int tmp_1;
    #line 192 
    if (hw->phy.media_type == (unsigned int)ixgbe_media_type_backplane) 
      #line 192 
      tmp_1 = 131072U; else 
                            #line 192 
                            tmp_1 = 32U;
    #line 192 
    supported = tmp_1 | supported;
  }
  #line 195 
  if ((supported_link & 8U) != 0U) 
                                   #line 196 
                                   supported |= 8U;
  #line 197 
  if ((supported_link & 2U) != 0U) 
                                   #line 198 
                                   supported |= 2U;
  #line 201 
  advertising = supported;
  #line 203 
  if (hw->phy.autoneg_advertised != 0U) {
    #line 204 
    advertising = 0U;
    #line 205 
    if ((hw->phy.autoneg_advertised & 2U) != 0U) 
                                                 #line 206 
                                                 advertising |= 2U;
    #line 207 
    if ((hw->phy.autoneg_advertised & 8U) != 0U) 
                                                 #line 208 
                                                 advertising |= 8U;
    #line 209 
    if ((hw->phy.autoneg_advertised & 128U) != 0U) 
                                                   #line 210 
                                                   advertising = (supported & 790528U) | advertising;
    #line 211 
    if ((hw->phy.autoneg_advertised & 32U) != 0U) 
      #line 212 
      if (((unsigned long)supported & 131072UL) != 0UL) 
                                                        #line 213 
                                                        advertising |= 131072U; else 
                                                                    #line 215 
                                                                    advertising |= 32U;
  }
  else 
    #line 218 
    if ((int)hw->phy.multispeed_fiber != 0 && ! autoneg) 
      #line 219 
      if ((supported_link & 128U) != 0U) 
                                         #line 220 
                                         advertising = 4096U;
  #line 224 
  if ((int)autoneg != 0) {
    #line 225 
    supported |= 64U;
    #line 226 
    advertising |= 64U;
    #line 227 
    cmd->base.autoneg = (unsigned char)1U;
  }
  else 
       #line 229 
       cmd->base.autoneg = (unsigned char)0U;
  #line 232 
  switch ((unsigned int)adapter->hw.phy.type) {
    #line 233 
    case (unsigned int)2: 
                          #line 233 
    ;
    #line 234 
    case (unsigned int)3: 
                          #line 234 
    ;
    #line 235 
    case (unsigned int)7: 
                          #line 235 
    ;
    #line 236 
    case (unsigned int)27: 
                           #line 236 
    ;
    #line 237 
    case (unsigned int)9: 
                          #line 237 
    ;
    #line 238 
    supported |= 128U;
    #line 239 
    advertising |= 128U;
    #line 240 
    cmd->base.port = (unsigned char)0U;
    #line 241 
    break;
    #line 242 
    case (unsigned int)10: 
                           #line 242 
    ;
    #line 243 
    supported |= 1024U;
    #line 244 
    advertising |= 1024U;
    #line 245 
    cmd->base.port = (unsigned char)3U;
    #line 246 
    break;
    #line 247 
    case (unsigned int)12: 
                           #line 247 
    ;
    #line 248 
    case (unsigned int)13: 
                           #line 248 
    ;
    #line 249 
    case (unsigned int)14: 
                           #line 249 
    ;
    #line 250 
    case (unsigned int)17: 
                           #line 250 
    ;
    #line 251 
    case (unsigned int)16: 
                           #line 251 
    ;
    #line 252 
    case (unsigned int)20: 
                           #line 252 
    ;
    #line 253 
    case (unsigned int)19: 
                           #line 253 
    ;
    #line 254 
    case (unsigned int)21: 
                           #line 254 
    ;
    #line 255 
    case (unsigned int)22: 
                           #line 255 
    ;
    #line 256 
    case (unsigned int)23: 
                           #line 256 
    ;
    #line 257 
    case (unsigned int)24: 
                           #line 257 
    ;
    #line 259 
    switch ((unsigned int)adapter->hw.phy.sfp_type) {
      #line 260 
      case (unsigned int)0: 
                            #line 260 
      ;
      #line 261 
      case (unsigned int)3: 
                            #line 261 
      ;
      #line 262 
      case (unsigned int)4: 
                            #line 262 
      ;
      #line 263 
      supported |= 1024U;
      #line 264 
      advertising |= 1024U;
      #line 265 
      cmd->base.port = (unsigned char)5U;
      #line 266 
      break;
      #line 267 
      case (unsigned int)1: 
                            #line 267 
      ;
      #line 268 
      case (unsigned int)2: 
                            #line 268 
      ;
      #line 269 
      case (unsigned int)5: 
                            #line 269 
      ;
      #line 270 
      case (unsigned int)6: 
                            #line 270 
      ;
      #line 271 
      case (unsigned int)11: 
                             #line 271 
      ;
      #line 272 
      case (unsigned int)12: 
                             #line 272 
      ;
      #line 273 
      case (unsigned int)13: 
                             #line 273 
      ;
      #line 274 
      case (unsigned int)14: 
                             #line 274 
      ;
      #line 275 
      supported |= 1024U;
      #line 276 
      advertising |= 1024U;
      #line 277 
      cmd->base.port = (unsigned char)3U;
      #line 278 
      break;
      #line 279 
      case (unsigned int)65534: 
                                #line 279 
      ;
      #line 280 
      supported |= 1024U;
      #line 281 
      advertising |= 1024U;
      #line 282 
      cmd->base.port = (unsigned char)239U;
      #line 283 
      break;
      #line 284 
      case (unsigned int)9: 
                            #line 284 
      ;
      #line 285 
      case (unsigned int)10: 
                             #line 285 
      ;
      #line 286 
      supported |= 128U;
      #line 287 
      advertising |= 128U;
      #line 288 
      cmd->base.port = (unsigned char)0U;
      #line 289 
      break;
      #line 290 
      case (unsigned int)65535: 
                                #line 290 
      ;
      #line 291 
      default: 
               #line 291 
      ;
      #line 292 
      supported |= 1024U;
      #line 293 
      advertising |= 1024U;
      #line 294 
      cmd->base.port = (unsigned char)255U;
      #line 295 
      break;
    }
    #line 297 
    break;
    #line 298 
    case (unsigned int)11: 
                           #line 298 
    ;
    #line 299 
    supported |= 1024U;
    #line 300 
    advertising |= 1024U;
    #line 301 
    cmd->base.port = (unsigned char)239U;
    #line 302 
    break;
    #line 303 
    case (unsigned int)0: 
                          #line 303 
    ;
    #line 304 
    case (unsigned int)28: 
                           #line 304 
    ;
    #line 305 
    case (unsigned int)25: 
                           #line 305 
    ;
    #line 306 
    default: 
             #line 306 
    ;
    #line 307 
    supported |= 1024U;
    #line 308 
    advertising |= 1024U;
    #line 309 
    cmd->base.port = (unsigned char)255U;
    #line 310 
    break;
  }
  #line 314 
  supported |= 8192U;
  #line 316 
  switch ((unsigned int)hw->fc.requested_mode) {
    #line 317 
    case (unsigned int)3: 
                          #line 317 
    ;
    #line 318 
    advertising |= 8192U;
    #line 319 
    break;
    #line 320 
    case (unsigned int)1: 
                          #line 320 
    ;
    #line 321 
    advertising |= 24576U;
    #line 323 
    break;
    #line 324 
    case (unsigned int)2: 
                          #line 324 
    ;
    #line 325 
    advertising |= 16384U;
    #line 326 
    break;
    #line 327 
    default: 
             #line 327 
    ;
    #line 328 
    advertising &= 4294942719U;
  }
  #line 332 
  if ((int)netif_carrier_ok(netdev) != 0) {
    #line 333 
    switch (adapter->link_speed) {
      #line 334 
      case (u32)128: 
                     #line 334 
      ;
      #line 335 
      cmd->base.speed = 10000U;
      #line 336 
      break;
      #line 337 
      case (u32)2048: 
                      #line 337 
      ;
      #line 338 
      cmd->base.speed = 5000U;
      #line 339 
      break;
      #line 340 
      case (u32)1024: 
                      #line 340 
      ;
      #line 341 
      cmd->base.speed = 2500U;
      #line 342 
      break;
      #line 343 
      case (u32)32: 
                    #line 343 
      ;
      #line 344 
      cmd->base.speed = 1000U;
      #line 345 
      break;
      #line 346 
      case (u32)8: 
                   #line 346 
      ;
      #line 347 
      cmd->base.speed = 100U;
      #line 348 
      break;
      #line 349 
      case (u32)2: 
                   #line 349 
      ;
      #line 350 
      cmd->base.speed = 10U;
      #line 351 
      break;
      #line 352 
      default: 
               #line 352 
      ;
      #line 353 
      break;
    }
    #line 355 
    cmd->base.duplex = (unsigned char)1U;
  }
  else {
    #line 357 
    cmd->base.speed = 4294967295U;
    #line 358 
    cmd->base.duplex = (unsigned char)255U;
  }
  #line 361 
  ethtool_convert_legacy_u32_to_link_mode((unsigned long *)(& cmd->link_modes.supported),supported);
  #line 363 
  ethtool_convert_legacy_u32_to_link_mode((unsigned long *)(& cmd->link_modes.advertising),advertising);
  #line 366 
  return 0;
}

#line 369  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_link_ksettings(struct net_device *netdev, struct ethtool_link_ksettings *cmd)
{
  #line 374 
  u32 advertised;
  #line 374 
  u32 old;
  #line 376 
  u32 supported;
  #line 376 
  u32 advertising;
  #line 372 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 373 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 375 
  s32 err = 0;
  #line 378 
  ethtool_convert_link_mode_to_legacy_u32(& supported,(unsigned long *)(& cmd->link_modes.supported));
  #line 380 
  ethtool_convert_link_mode_to_legacy_u32(& advertising,(unsigned long *)(& cmd->link_modes.advertising));
  #line 383 
  if (hw->phy.media_type == (unsigned int)ixgbe_media_type_copper || (int)hw->phy.multispeed_fiber != 0) {
    #line 389 
    if ((~ supported & advertising) != 0U) 
                                           #line 390 
                                           return -22;
    #line 393 
    if ((unsigned int)cmd->base.autoneg == 0U && (int)hw->phy.multispeed_fiber != 0) 
      #line 394 
      if (advertising == 4128U) 
                                #line 397 
                                return -22;
    #line 400 
    old = hw->phy.autoneg_advertised;
    #line 401 
    advertised = 0U;
    #line 402 
    if (((unsigned long)advertising & 4096UL) != 0UL) 
                                                      #line 403 
                                                      advertised |= 128U;
    #line 405 
    if (((unsigned long)advertising & 32UL) != 0UL) 
                                                    #line 406 
                                                    advertised |= 32U;
    #line 408 
    if (((unsigned long)advertising & 8UL) != 0UL) 
                                                   #line 409 
                                                   advertised |= 8U;
    #line 411 
    if (((unsigned long)advertising & 2UL) != 0UL) 
                                                   #line 412 
                                                   advertised |= 2U;
    #line 414 
    if (old == advertised) 
                           #line 415 
                           return err;
    #line 417 
    while (1) {
      #line 417 
      if (! ((int)test_and_set_bit(7L,& adapter->state) != 0)) 
                                                               #line 417 
                                                               break;
      #line 418 
      usleep_range(1000UL,2000UL);
    }
    #line 420 
    hw->mac.autotry_restart = (_Bool)1;
    #line 421 
    err = (*(hw->mac.ops.setup_link))(hw,advertised,(_Bool)1);
    #line 422 
    if (err != 0) {
      #line 423 
      if (((int)adapter->msg_enable & 2) != 0) 
                                               #line 423 
                                               netdev_info(adapter->netdev,(char *)"setup link failed with code %d\n",err);
      #line 424 
      (*(hw->mac.ops.setup_link))(hw,old,(_Bool)1);
    }
    #line 426 
    cif_clear_bit_0(7L,& adapter->state);
  }
  else {
    #line 429 
    u32 speed = cmd->base.speed;
    #line 431 
    if (((unsigned int)cmd->base.autoneg == 1U || advertising != 4096U) || (unsigned int)cmd->base.duplex + speed != 10001U) 
      #line 434 
      return -22;
  }
  #line 437 
  return err;
}

#line 440  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *pause)
{
  #line 443 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 444 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 446 
  if ((int)ixgbe_device_supports_autoneg_fc(hw) != 0) 
    #line 447 
    if (! hw->fc.disable_fc_autoneg) 
                                     #line 448 
                                     pause->autoneg = 1U; else 
                                                               #line 450 
                                                               pause->autoneg = 0U;
  else 
       #line 450 
       pause->autoneg = 0U;
  #line 452 
  if (hw->fc.current_mode == (unsigned int)ixgbe_fc_rx_pause) 
                                                              #line 453 
                                                              pause->rx_pause = 1U;
  else 
    #line 454 
    if (hw->fc.current_mode == (unsigned int)ixgbe_fc_tx_pause) 
                                                                #line 455 
                                                                pause->tx_pause = 1U;
    else 
      #line 456 
      if (hw->fc.current_mode == (unsigned int)ixgbe_fc_full) {
        #line 457 
        pause->rx_pause = 1U;
        #line 458 
        pause->tx_pause = 1U;
      }
  #line 460 
  return;
}

#line 462  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *pause)
{
  #line 465 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 466 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 467 
  struct ixgbe_fc_info fc = hw->fc;
  #line 470 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB && ((unsigned long)adapter->flags & 4096UL) != 0UL) 
    #line 472 
    return -22;
  #line 475 
  if (pause->autoneg == 1U) {
    #line 476 
    if (! ixgbe_device_supports_autoneg_fc(hw)) 
                                                #line 477 
                                                return -22;
  }
  #line 479 
  fc.disable_fc_autoneg = (_Bool)(pause->autoneg != 1U);
  #line 481 
  if (pause->rx_pause != 0U && pause->tx_pause != 0U || pause->autoneg != 0U) 
    #line 482 
    fc.requested_mode = ixgbe_fc_full;
  else 
    #line 483 
    if (pause->rx_pause != 0U && pause->tx_pause == 0U) 
                                                        #line 484 
                                                        fc.requested_mode = ixgbe_fc_rx_pause;
    else 
      #line 485 
      if (pause->rx_pause == 0U && pause->tx_pause != 0U) 
                                                          #line 486 
                                                          fc.requested_mode = ixgbe_fc_tx_pause; else 
                                                                    #line 488 
                                                                    fc.requested_mode = ixgbe_fc_none;
  #line 491 
  if (memcmp((void *)(& fc),(void *)(& hw->fc),80UL) != 0) {
    #line 492 
    hw->fc = fc;
    #line 493 
    if ((int)netif_running(netdev) != 0) 
                                         #line 494 
                                         ixgbe_reinit_locked(adapter); else 
                                                                    #line 496 
                                                                    ixgbe_reset(adapter);
  }
  #line 499 
  return 0;
}

#line 502  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static u32 ixgbe_get_msglevel(struct net_device *netdev)
{
  #line 504 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 505 
  return (unsigned int)adapter->msg_enable;
}

#line 508  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_set_msglevel(struct net_device *netdev, u32 data)
{
  #line 510 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 511 
  adapter->msg_enable = (unsigned short)data;
  #line 512 
  return;
}

#line 514  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_regs_len(struct net_device *netdev)
{
  #line 517 
  return 4580;
}

#line 522  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_regs(struct net_device *netdev, struct ethtool_regs *regs, void *p)
{
  #line 528 
  u8 i;
  #line 525 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 526 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 527 
  u32 *regs_buff = (u32 *)p;
  #line 530 
  memset(p,0,4580UL);
  #line 532 
  regs->version = (((unsigned int)hw->mac.type << 24) | (unsigned int)((int)hw->revision_id << 16)) | (unsigned int)hw->device_id;
  #line 536 
  *regs_buff = ixgbe_read_reg(hw,0U);
  #line 537 
  *(regs_buff + 1U) = ixgbe_read_reg(hw,8U);
  #line 538 
  *(regs_buff + 2U) = ixgbe_read_reg(hw,24U);
  #line 539 
  *(regs_buff + 3U) = ixgbe_read_reg(hw,32U);
  #line 540 
  *(regs_buff + 4U) = ixgbe_read_reg(hw,40U);
  #line 541 
  *(regs_buff + 5U) = ixgbe_read_reg(hw,512U);
  #line 542 
  *(regs_buff + 6U) = ixgbe_read_reg(hw,72U);
  #line 543 
  *(regs_buff + 7U) = ixgbe_read_reg(hw,76U);
  #line 546 
  *(regs_buff + 8U) = ixgbe_read_reg(hw,*(hw->mvals));
  #line 547 
  *(regs_buff + 9U) = ixgbe_read_reg(hw,65556U);
  #line 548 
  *(regs_buff + 10U) = ixgbe_read_reg(hw,*(hw->mvals + 1U));
  #line 549 
  *(regs_buff + 11U) = ixgbe_read_reg(hw,65808U);
  #line 550 
  *(regs_buff + 12U) = ixgbe_read_reg(hw,65812U);
  #line 551 
  *(regs_buff + 13U) = ixgbe_read_reg(hw,65816U);
  #line 552 
  *(regs_buff + 14U) = ixgbe_read_reg(hw,65820U);
  #line 553 
  *(regs_buff + 15U) = ixgbe_read_reg(hw,65824U);
  #line 554 
  *(regs_buff + 16U) = ixgbe_read_reg(hw,65852U);
  #line 555 
  *(regs_buff + 17U) = ixgbe_read_reg(hw,*(hw->mvals + 2U));
  #line 560 
  *(regs_buff + 18U) = ixgbe_read_reg(hw,2056U);
  #line 561 
  *(regs_buff + 19U) = ixgbe_read_reg(hw,2056U);
  #line 562 
  *(regs_buff + 20U) = ixgbe_read_reg(hw,2176U);
  #line 563 
  *(regs_buff + 21U) = ixgbe_read_reg(hw,2184U);
  #line 564 
  *(regs_buff + 22U) = ixgbe_read_reg(hw,2064U);
  #line 565 
  *(regs_buff + 23U) = ixgbe_read_reg(hw,2192U);
  #line 566 
  *(regs_buff + 24U) = ixgbe_read_reg(hw,2080U);
  #line 567 
  *(regs_buff + 25U) = ixgbe_read_reg(hw,2304U);
  #line 568 
  *(regs_buff + 26U) = ixgbe_read_reg(hw,0U);
  #line 569 
  *(regs_buff + 27U) = ixgbe_read_reg(hw,8192U);
  #line 570 
  *(regs_buff + 28U) = ixgbe_read_reg(hw,69736U);
  #line 571 
  *(regs_buff + 29U) = ixgbe_read_reg(hw,2200U);
  #line 574 
  *(regs_buff + 30U) = ixgbe_read_reg(hw,12296U);
  #line 575 
  i = (unsigned char)0U;
  #line 575 
  while ((unsigned int)i <= 3U) {
    #line 576 
    *(regs_buff + (unsigned long)((int)i + 31)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 3200) * 4));
    #line 575 
    i = (u8)((int)i + 1);
  }
  #line 577 
  i = (unsigned char)0U;
  #line 577 
  while ((unsigned int)i <= 7U) {
    #line 578 
    switch ((unsigned int)hw->mac.type) {
      #line 579 
      case (unsigned int)1: 
                            #line 579 
      ;
      #line 580 
      *(regs_buff + (unsigned long)((int)i + 35)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 1604) * 8));
      #line 581 
      *(regs_buff + (unsigned long)((int)i + 43)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 1612) * 8));
      #line 582 
      break;
      #line 583 
      case (unsigned int)2: 
                            #line 583 
      ;
      #line 584 
      case (unsigned int)3: 
                            #line 584 
      ;
      #line 585 
      case (unsigned int)4: 
                            #line 585 
      ;
      #line 586 
      case (unsigned int)5: 
                            #line 586 
      ;
      #line 587 
      case (unsigned int)6: 
                            #line 587 
      ;
      #line 588 
      *(regs_buff + (unsigned long)((int)i + 35)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 3208) * 4));
      #line 589 
      *(regs_buff + (unsigned long)((int)i + 43)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 3224) * 4));
      #line 590 
      break;
      #line 591 
      default: 
               #line 591 
      ;
      #line 592 
      break;
    }
    #line 577 
    i = (u8)((int)i + 1);
  }
  #line 595 
  *(regs_buff + 51U) = ixgbe_read_reg(hw,12960U);
  #line 596 
  *(regs_buff + 52U) = ixgbe_read_reg(hw,52736U);
  #line 599 
  i = (unsigned char)0U;
  #line 599 
  while ((unsigned int)i <= 63U) {
    #line 600 
    int tmp_0;
    #line 600 
    if ((unsigned int)i <= 63U) 
                                #line 600 
                                tmp_0 = ((int)i + 64) * 64; else 
                                                                 #line 600 
                                                                 tmp_0 = ((int)i + 768) * 64;
    #line 600 
    ;
    #line 600 
    *(regs_buff + (unsigned long)((int)i + 53)) = ixgbe_read_reg(hw,(unsigned int)tmp_0);
    #line 599 
    i = (u8)((int)i + 1);
  }
  #line 601 
  i = (unsigned char)0U;
  #line 601 
  while ((unsigned int)i <= 63U) {
    #line 602 
    int tmp_1;
    #line 602 
    if ((unsigned int)i <= 63U) 
                                #line 602 
                                tmp_1 = (int)i * 64 + 4100; else 
                                                                 #line 602 
                                                                 tmp_1 = ((int)i + -64) * 64 + 53252;
    #line 602 
    ;
    #line 602 
    *(regs_buff + (unsigned long)((int)i + 117)) = ixgbe_read_reg(hw,(unsigned int)tmp_1);
    #line 601 
    i = (u8)((int)i + 1);
  }
  #line 603 
  i = (unsigned char)0U;
  #line 603 
  while ((unsigned int)i <= 63U) {
    #line 604 
    int tmp_2;
    #line 604 
    if ((unsigned int)i <= 63U) 
                                #line 604 
                                tmp_2 = (int)i * 64 + 4104; else 
                                                                 #line 604 
                                                                 tmp_2 = ((int)i + -64) * 64 + 53256;
    #line 604 
    ;
    #line 604 
    *(regs_buff + (unsigned long)((int)i + 181)) = ixgbe_read_reg(hw,(unsigned int)tmp_2);
    #line 603 
    i = (u8)((int)i + 1);
  }
  #line 605 
  i = (unsigned char)0U;
  #line 605 
  while ((unsigned int)i <= 63U) {
    #line 606 
    int tmp_3;
    #line 606 
    if ((unsigned int)i <= 63U) 
                                #line 606 
                                tmp_3 = (int)i * 64 + 4112; else 
                                                                 #line 606 
                                                                 tmp_3 = ((int)i + -64) * 64 + 53264;
    #line 606 
    ;
    #line 606 
    *(regs_buff + (unsigned long)((int)i + 245)) = ixgbe_read_reg(hw,(unsigned int)tmp_3);
    #line 605 
    i = (u8)((int)i + 1);
  }
  #line 607 
  i = (unsigned char)0U;
  #line 607 
  while ((unsigned int)i <= 63U) {
    #line 608 
    int tmp_4;
    #line 608 
    if ((unsigned int)i <= 63U) 
                                #line 608 
                                tmp_4 = (int)i * 64 + 4120; else 
                                                                 #line 608 
                                                                 tmp_4 = ((int)i + -64) * 64 + 53272;
    #line 608 
    ;
    #line 608 
    *(regs_buff + (unsigned long)((int)i + 309)) = ixgbe_read_reg(hw,(unsigned int)tmp_4);
    #line 607 
    i = (u8)((int)i + 1);
  }
  #line 609 
  i = (unsigned char)0U;
  #line 609 
  while ((unsigned int)i <= 63U) {
    #line 610 
    int tmp_5;
    #line 610 
    if ((unsigned int)i <= 63U) 
                                #line 610 
                                tmp_5 = (int)i * 64 + 4136; else 
                                                                 #line 610 
                                                                 tmp_5 = ((int)i + -64) * 64 + 53288;
    #line 610 
    ;
    #line 610 
    *(regs_buff + (unsigned long)((int)i + 373)) = ixgbe_read_reg(hw,(unsigned int)tmp_5);
    #line 609 
    i = (u8)((int)i + 1);
  }
  #line 611 
  i = (unsigned char)0U;
  #line 611 
  while ((unsigned int)i <= 15U) {
    #line 612 
    int tmp_7;
    #line 612 
    if ((unsigned int)i <= 15U) 
                                #line 612 
                                tmp_7 = ((int)i + 2112) * 4;
    else {
      #line 612 
      int tmp_6;
      #line 612 
      if ((unsigned int)i <= 63U) 
                                  #line 612 
                                  tmp_6 = (int)i * 64 + 4116; else 
                                                                   #line 612 
                                                                   tmp_6 = ((int)i + -64) * 64 + 53268;
      #line 612 
      tmp_7 = tmp_6;
    }
    #line 612 
    ;
    #line 612 
    *(regs_buff + (unsigned long)((int)i + 437)) = ixgbe_read_reg(hw,(unsigned int)tmp_7);
    #line 611 
    i = (u8)((int)i + 1);
  }
  #line 613 
  i = (unsigned char)0U;
  #line 613 
  while ((unsigned int)i <= 15U) {
    #line 614 
    int tmp_9;
    #line 614 
    if ((unsigned int)i <= 15U) 
                                #line 614 
                                tmp_9 = ((int)i + 2176) * 4;
    else {
      #line 614 
      int tmp_8;
      #line 614 
      if ((unsigned int)i <= 63U) 
                                  #line 614 
                                  tmp_8 = (int)i * 64 + 4108; else 
                                                                   #line 614 
                                                                   tmp_8 = ((int)i + -64) * 64 + 53260;
      #line 614 
      tmp_9 = tmp_8;
    }
    #line 614 
    ;
    #line 614 
    *(regs_buff + (unsigned long)((int)i + 453)) = ixgbe_read_reg(hw,(unsigned int)tmp_9);
    #line 613 
    i = (u8)((int)i + 1);
  }
  #line 615 
  *(regs_buff + 469U) = ixgbe_read_reg(hw,12032U);
  #line 616 
  i = (unsigned char)0U;
  #line 616 
  while ((unsigned int)i <= 7U) {
    #line 617 
    *(regs_buff + (unsigned long)((int)i + 470)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 3840) * 4));
    #line 616 
    i = (u8)((int)i + 1);
  }
  #line 618 
  *(regs_buff + 478U) = ixgbe_read_reg(hw,12288U);
  #line 619 
  *(regs_buff + 479U) = ixgbe_read_reg(hw,15620U);
  #line 622 
  *(regs_buff + 480U) = ixgbe_read_reg(hw,20480U);
  #line 623 
  *(regs_buff + 481U) = ixgbe_read_reg(hw,20488U);
  #line 624 
  i = (unsigned char)0U;
  #line 624 
  while ((unsigned int)i <= 15U) {
    #line 625 
    int tmp_10;
    #line 625 
    if ((unsigned int)i <= 15U) 
                                #line 625 
                                tmp_10 = ((int)i + 2688) * 8; else 
                                                                   #line 625 
                                                                   tmp_10 = ((int)i + 5184) * 8;
    #line 625 
    ;
    #line 625 
    *(regs_buff + (unsigned long)((int)i + 482)) = ixgbe_read_reg(hw,(unsigned int)tmp_10);
    #line 624 
    i = (u8)((int)i + 1);
  }
  #line 626 
  i = (unsigned char)0U;
  #line 626 
  while ((unsigned int)i <= 15U) {
    #line 627 
    int tmp_11;
    #line 627 
    if ((unsigned int)i <= 15U) 
                                #line 627 
                                tmp_11 = (int)i * 8 + 21508; else 
                                                                  #line 627 
                                                                  tmp_11 = (int)i * 8 + 41476;
    #line 627 
    ;
    #line 627 
    *(regs_buff + (unsigned long)((int)i + 498)) = ixgbe_read_reg(hw,(unsigned int)tmp_11);
    #line 626 
    i = (u8)((int)i + 1);
  }
  #line 628 
  *(regs_buff + 514U) = ixgbe_read_reg(hw,21632U);
  #line 629 
  *(regs_buff + 515U) = ixgbe_read_reg(hw,20608U);
  #line 630 
  *(regs_buff + 516U) = ixgbe_read_reg(hw,20616U);
  #line 631 
  *(regs_buff + 517U) = ixgbe_read_reg(hw,20624U);
  #line 632 
  *(regs_buff + 518U) = ixgbe_read_reg(hw,22552U);
  #line 633 
  *(regs_buff + 519U) = ixgbe_read_reg(hw,22556U);
  #line 634 
  i = (unsigned char)0U;
  #line 634 
  while ((unsigned int)i <= 7U) {
    #line 635 
    *(regs_buff + (unsigned long)((int)i + 520)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 5792) * 4));
    #line 634 
    i = (u8)((int)i + 1);
  }
  #line 636 
  i = (unsigned char)0U;
  #line 636 
  while ((unsigned int)i <= 7U) {
    #line 637 
    *(regs_buff + (unsigned long)((int)i + 528)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 5800) * 4));
    #line 636 
    i = (u8)((int)i + 1);
  }
  #line 638 
  *(regs_buff + 536U) = ixgbe_read_reg(hw,23232U);
  #line 641 
  i = (unsigned char)0U;
  #line 641 
  while ((unsigned int)i <= 31U) {
    #line 642 
    *(regs_buff + (unsigned long)((int)i + 537)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 384) * 64));
    #line 641 
    i = (u8)((int)i + 1);
  }
  #line 643 
  i = (unsigned char)0U;
  #line 643 
  while ((unsigned int)i <= 31U) {
    #line 644 
    *(regs_buff + (unsigned long)((int)i + 569)) = ixgbe_read_reg(hw,(unsigned int)((int)i * 64 + 24580));
    #line 643 
    i = (u8)((int)i + 1);
  }
  #line 645 
  i = (unsigned char)0U;
  #line 645 
  while ((unsigned int)i <= 31U) {
    #line 646 
    *(regs_buff + (unsigned long)((int)i + 601)) = ixgbe_read_reg(hw,(unsigned int)((int)i * 64 + 24584));
    #line 645 
    i = (u8)((int)i + 1);
  }
  #line 647 
  i = (unsigned char)0U;
  #line 647 
  while ((unsigned int)i <= 31U) {
    #line 648 
    *(regs_buff + (unsigned long)((int)i + 633)) = ixgbe_read_reg(hw,(unsigned int)((int)i * 64 + 24592));
    #line 647 
    i = (u8)((int)i + 1);
  }
  #line 649 
  i = (unsigned char)0U;
  #line 649 
  while ((unsigned int)i <= 31U) {
    #line 650 
    *(regs_buff + (unsigned long)((int)i + 665)) = ixgbe_read_reg(hw,(unsigned int)((int)i * 64 + 24600));
    #line 649 
    i = (u8)((int)i + 1);
  }
  #line 651 
  i = (unsigned char)0U;
  #line 651 
  while ((unsigned int)i <= 31U) {
    #line 652 
    *(regs_buff + (unsigned long)((int)i + 697)) = ixgbe_read_reg(hw,(unsigned int)((int)i * 64 + 24616));
    #line 651 
    i = (u8)((int)i + 1);
  }
  #line 653 
  i = (unsigned char)0U;
  #line 653 
  while ((unsigned int)i <= 31U) {
    #line 654 
    *(regs_buff + (unsigned long)((int)i + 729)) = ixgbe_read_reg(hw,(unsigned int)((int)i * 64 + 24632));
    #line 653 
    i = (u8)((int)i + 1);
  }
  #line 655 
  i = (unsigned char)0U;
  #line 655 
  while ((unsigned int)i <= 31U) {
    #line 656 
    *(regs_buff + (unsigned long)((int)i + 761)) = ixgbe_read_reg(hw,(unsigned int)((int)i * 64 + 24636));
    #line 655 
    i = (u8)((int)i + 1);
  }
  #line 657 
  *(regs_buff + 793U) = ixgbe_read_reg(hw,32256U);
  #line 658 
  i = (unsigned char)0U;
  #line 658 
  while ((unsigned int)i <= 15U) {
    #line 659 
    *(regs_buff + (unsigned long)((int)i + 794)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 7296) * 4));
    #line 658 
    i = (u8)((int)i + 1);
  }
  #line 660 
  *(regs_buff + 810U) = ixgbe_read_reg(hw,51968U);
  #line 661 
  i = (unsigned char)0U;
  #line 661 
  while ((unsigned int)i <= 7U) {
    #line 662 
    *(regs_buff + (unsigned long)((int)i + 811)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 13056) * 4));
    #line 661 
    i = (u8)((int)i + 1);
  }
  #line 663 
  *(regs_buff + 819U) = ixgbe_read_reg(hw,52496U);
  #line 666 
  *(regs_buff + 820U) = ixgbe_read_reg(hw,22528U);
  #line 667 
  *(regs_buff + 821U) = ixgbe_read_reg(hw,22536U);
  #line 668 
  *(regs_buff + 822U) = ixgbe_read_reg(hw,22544U);
  #line 669 
  *(regs_buff + 823U) = ixgbe_read_reg(hw,22584U);
  #line 670 
  *(regs_buff + 824U) = ixgbe_read_reg(hw,22592U);
  #line 671 
  *(regs_buff + 825U) = ixgbe_read_reg(hw,22656U);
  #line 672 
  *(regs_buff + 826U) = ixgbe_read_reg(hw,22784U);
  #line 673 
  *(regs_buff + 827U) = ixgbe_read_reg(hw,23040U);
  #line 674 
  *(regs_buff + 828U) = ixgbe_read_reg(hw,36864U);
  #line 677 
  *(regs_buff + 829U) = ixgbe_read_reg(hw,15616U);
  #line 678 
  *(regs_buff + 831U) = ixgbe_read_reg(hw,52480U);
  #line 680 
  switch ((unsigned int)hw->mac.type) {
    #line 681 
    case (unsigned int)1: 
                          #line 681 
    ;
    #line 682 
    *(regs_buff + 830U) = ixgbe_read_reg(hw,32576U);
    #line 683 
    *(regs_buff + 832U) = ixgbe_read_reg(hw,20640U);
    #line 684 
    i = (unsigned char)0U;
    #line 684 
    while ((unsigned int)i <= 7U) {
      #line 685 
      *(regs_buff + (unsigned long)((int)i + 833)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 3848) * 4));
      #line 684 
      i = (u8)((int)i + 1);
    }
    #line 687 
    i = (unsigned char)0U;
    #line 687 
    while ((unsigned int)i <= 7U) {
      #line 688 
      *(regs_buff + (unsigned long)((int)i + 841)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 3856) * 4));
      #line 687 
      i = (u8)((int)i + 1);
    }
    #line 690 
    i = (unsigned char)0U;
    #line 690 
    while ((unsigned int)i <= 7U) {
      #line 691 
      *(regs_buff + (unsigned long)((int)i + 849)) = ixgbe_read_reg(hw,(unsigned int)((int)i * 64 + 24620));
      #line 690 
      i = (u8)((int)i + 1);
    }
    #line 693 
    i = (unsigned char)0U;
    #line 693 
    while ((unsigned int)i <= 7U) {
      #line 694 
      *(regs_buff + (unsigned long)((int)i + 857)) = ixgbe_read_reg(hw,(unsigned int)((int)i * 64 + 25132));
      #line 693 
      i = (u8)((int)i + 1);
    }
    #line 696 
    break;
    #line 697 
    case (unsigned int)2: 
                          #line 697 
    ;
    #line 698 
    case (unsigned int)3: 
                          #line 698 
    ;
    #line 699 
    case (unsigned int)4: 
                          #line 699 
    ;
    #line 700 
    case (unsigned int)5: 
                          #line 700 
    ;
    #line 701 
    case (unsigned int)6: 
                          #line 701 
    ;
    #line 702 
    *(regs_buff + 830U) = ixgbe_read_reg(hw,18688U);
    #line 703 
    *(regs_buff + 832U) = ixgbe_read_reg(hw,9264U);
    #line 704 
    i = (unsigned char)0U;
    #line 704 
    while ((unsigned int)i <= 7U) {
      #line 705 
      *(regs_buff + (unsigned long)((int)i + 833)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 2128) * 4));
      #line 704 
      i = (u8)((int)i + 1);
    }
    #line 707 
    i = (unsigned char)0U;
    #line 707 
    while ((unsigned int)i <= 7U) {
      #line 708 
      *(regs_buff + (unsigned long)((int)i + 841)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 2136) * 4));
      #line 707 
      i = (u8)((int)i + 1);
    }
    #line 710 
    i = (unsigned char)0U;
    #line 710 
    while ((unsigned int)i <= 7U) {
      #line 711 
      *(regs_buff + (unsigned long)((int)i + 849)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 4676) * 4));
      #line 710 
      i = (u8)((int)i + 1);
    }
    #line 713 
    i = (unsigned char)0U;
    #line 713 
    while ((unsigned int)i <= 7U) {
      #line 714 
      *(regs_buff + (unsigned long)((int)i + 857)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 4684) * 4));
      #line 713 
      i = (u8)((int)i + 1);
    }
    #line 716 
    break;
    #line 717 
    default: 
             #line 717 
    ;
    #line 718 
    break;
  }
  #line 721 
  i = (unsigned char)0U;
  #line 721 
  while ((unsigned int)i <= 7U) {
    #line 722 
    *(regs_buff + (unsigned long)((int)i + 865)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 13128) * 4));
    #line 721 
    i = (u8)((int)i + 1);
  }
  #line 724 
  i = (unsigned char)0U;
  #line 724 
  while ((unsigned int)i <= 7U) {
    #line 725 
    *(regs_buff + (unsigned long)((int)i + 873)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 13136) * 4));
    #line 724 
    i = (u8)((int)i + 1);
  }
  #line 729 
  *(regs_buff + 881U) = (unsigned int)adapter->stats.crcerrs;
  #line 730 
  *(regs_buff + 882U) = (unsigned int)adapter->stats.illerrc;
  #line 731 
  *(regs_buff + 883U) = (unsigned int)adapter->stats.errbc;
  #line 732 
  *(regs_buff + 884U) = (unsigned int)adapter->stats.mspdc;
  #line 733 
  i = (unsigned char)0U;
  #line 733 
  while ((unsigned int)i <= 7U) {
    #line 734 
    *(regs_buff + (unsigned long)((int)i + 885)) = (unsigned int)adapter->stats.mpc[(int)i];
    #line 733 
    i = (u8)((int)i + 1);
  }
  #line 735 
  *(regs_buff + 893U) = (unsigned int)adapter->stats.mlfc;
  #line 736 
  *(regs_buff + 894U) = (unsigned int)adapter->stats.mrfc;
  #line 737 
  *(regs_buff + 895U) = (unsigned int)adapter->stats.rlec;
  #line 738 
  *(regs_buff + 896U) = (unsigned int)adapter->stats.lxontxc;
  #line 739 
  *(regs_buff + 897U) = (unsigned int)adapter->stats.lxonrxc;
  #line 740 
  *(regs_buff + 898U) = (unsigned int)adapter->stats.lxofftxc;
  #line 741 
  *(regs_buff + 899U) = (unsigned int)adapter->stats.lxoffrxc;
  #line 742 
  i = (unsigned char)0U;
  #line 742 
  while ((unsigned int)i <= 7U) {
    #line 743 
    *(regs_buff + (unsigned long)((int)i + 900)) = (unsigned int)adapter->stats.pxontxc[(int)i];
    #line 742 
    i = (u8)((int)i + 1);
  }
  #line 744 
  i = (unsigned char)0U;
  #line 744 
  while ((unsigned int)i <= 7U) {
    #line 745 
    *(regs_buff + (unsigned long)((int)i + 908)) = (unsigned int)adapter->stats.pxonrxc[(int)i];
    #line 744 
    i = (u8)((int)i + 1);
  }
  #line 746 
  i = (unsigned char)0U;
  #line 746 
  while ((unsigned int)i <= 7U) {
    #line 747 
    *(regs_buff + (unsigned long)((int)i + 916)) = (unsigned int)adapter->stats.pxofftxc[(int)i];
    #line 746 
    i = (u8)((int)i + 1);
  }
  #line 748 
  i = (unsigned char)0U;
  #line 748 
  while ((unsigned int)i <= 7U) {
    #line 749 
    *(regs_buff + (unsigned long)((int)i + 924)) = (unsigned int)adapter->stats.pxoffrxc[(int)i];
    #line 748 
    i = (u8)((int)i + 1);
  }
  #line 750 
  *(regs_buff + 932U) = (unsigned int)adapter->stats.prc64;
  #line 751 
  *(regs_buff + 933U) = (unsigned int)adapter->stats.prc127;
  #line 752 
  *(regs_buff + 934U) = (unsigned int)adapter->stats.prc255;
  #line 753 
  *(regs_buff + 935U) = (unsigned int)adapter->stats.prc511;
  #line 754 
  *(regs_buff + 936U) = (unsigned int)adapter->stats.prc1023;
  #line 755 
  *(regs_buff + 937U) = (unsigned int)adapter->stats.prc1522;
  #line 756 
  *(regs_buff + 938U) = (unsigned int)adapter->stats.gprc;
  #line 757 
  *(regs_buff + 939U) = (unsigned int)adapter->stats.bprc;
  #line 758 
  *(regs_buff + 940U) = (unsigned int)adapter->stats.mprc;
  #line 759 
  *(regs_buff + 941U) = (unsigned int)adapter->stats.gptc;
  #line 760 
  *(regs_buff + 942U) = (unsigned int)adapter->stats.gorc;
  #line 761 
  *(regs_buff + 943U) = (unsigned int)(adapter->stats.gorc >> 32);
  #line 762 
  *(regs_buff + 944U) = (unsigned int)adapter->stats.gotc;
  #line 763 
  *(regs_buff + 945U) = (unsigned int)(adapter->stats.gotc >> 32);
  #line 764 
  i = (unsigned char)0U;
  #line 764 
  while ((unsigned int)i <= 7U) {
    #line 765 
    *(regs_buff + (unsigned long)((int)i + 946)) = (unsigned int)adapter->stats.rnbc[(int)i];
    #line 764 
    i = (u8)((int)i + 1);
  }
  #line 766 
  *(regs_buff + 954U) = (unsigned int)adapter->stats.ruc;
  #line 767 
  *(regs_buff + 955U) = (unsigned int)adapter->stats.rfc;
  #line 768 
  *(regs_buff + 956U) = (unsigned int)adapter->stats.roc;
  #line 769 
  *(regs_buff + 957U) = (unsigned int)adapter->stats.rjc;
  #line 770 
  *(regs_buff + 958U) = (unsigned int)adapter->stats.mngprc;
  #line 771 
  *(regs_buff + 959U) = (unsigned int)adapter->stats.mngpdc;
  #line 772 
  *(regs_buff + 960U) = (unsigned int)adapter->stats.mngptc;
  #line 773 
  *(regs_buff + 961U) = (unsigned int)adapter->stats.tor;
  #line 774 
  *(regs_buff + 962U) = (unsigned int)(adapter->stats.tor >> 32);
  #line 775 
  *(regs_buff + 963U) = (unsigned int)adapter->stats.tpr;
  #line 776 
  *(regs_buff + 964U) = (unsigned int)adapter->stats.tpt;
  #line 777 
  *(regs_buff + 965U) = (unsigned int)adapter->stats.ptc64;
  #line 778 
  *(regs_buff + 966U) = (unsigned int)adapter->stats.ptc127;
  #line 779 
  *(regs_buff + 967U) = (unsigned int)adapter->stats.ptc255;
  #line 780 
  *(regs_buff + 968U) = (unsigned int)adapter->stats.ptc511;
  #line 781 
  *(regs_buff + 969U) = (unsigned int)adapter->stats.ptc1023;
  #line 782 
  *(regs_buff + 970U) = (unsigned int)adapter->stats.ptc1522;
  #line 783 
  *(regs_buff + 971U) = (unsigned int)adapter->stats.mptc;
  #line 784 
  *(regs_buff + 972U) = (unsigned int)adapter->stats.bptc;
  #line 785 
  *(regs_buff + 973U) = (unsigned int)adapter->stats.xec;
  #line 786 
  i = (unsigned char)0U;
  #line 786 
  while ((unsigned int)i <= 15U) {
    #line 787 
    *(regs_buff + (unsigned long)((int)i + 974)) = (unsigned int)adapter->stats.qprc[(int)i];
    #line 786 
    i = (u8)((int)i + 1);
  }
  #line 788 
  i = (unsigned char)0U;
  #line 788 
  while ((unsigned int)i <= 15U) {
    #line 789 
    *(regs_buff + (unsigned long)((int)i + 990)) = (unsigned int)adapter->stats.qptc[(int)i];
    #line 788 
    i = (u8)((int)i + 1);
  }
  #line 790 
  i = (unsigned char)0U;
  #line 790 
  while ((unsigned int)i <= 15U) {
    #line 791 
    *(regs_buff + (unsigned long)((int)i + 1006)) = (unsigned int)adapter->stats.qbrc[(int)i];
    #line 790 
    i = (u8)((int)i + 1);
  }
  #line 792 
  i = (unsigned char)0U;
  #line 792 
  while ((unsigned int)i <= 15U) {
    #line 793 
    *(regs_buff + (unsigned long)((int)i + 1022)) = (unsigned int)adapter->stats.qbtc[(int)i];
    #line 792 
    i = (u8)((int)i + 1);
  }
  #line 796 
  *(regs_buff + 1038U) = ixgbe_read_reg(hw,16896U);
  #line 797 
  *(regs_buff + 1039U) = ixgbe_read_reg(hw,16904U);
  #line 798 
  *(regs_buff + 1040U) = ixgbe_read_reg(hw,16908U);
  #line 799 
  *(regs_buff + 1041U) = ixgbe_read_reg(hw,16912U);
  #line 800 
  *(regs_buff + 1042U) = ixgbe_read_reg(hw,16916U);
  #line 801 
  *(regs_buff + 1043U) = ixgbe_read_reg(hw,16920U);
  #line 802 
  *(regs_buff + 1044U) = ixgbe_read_reg(hw,16924U);
  #line 803 
  *(regs_buff + 1045U) = ixgbe_read_reg(hw,16928U);
  #line 804 
  *(regs_buff + 1046U) = ixgbe_read_reg(hw,16932U);
  #line 805 
  *(regs_buff + 1047U) = ixgbe_read_reg(hw,16960U);
  #line 806 
  *(regs_buff + 1048U) = ixgbe_read_reg(hw,16964U);
  #line 807 
  *(regs_buff + 1049U) = ixgbe_read_reg(hw,16968U);
  #line 808 
  *(regs_buff + 1050U) = ixgbe_read_reg(hw,16972U);
  #line 809 
  *(regs_buff + 1051U) = ixgbe_read_reg(hw,16976U);
  #line 810 
  *(regs_buff + 1052U) = ixgbe_read_reg(hw,16980U);
  #line 811 
  *(regs_buff + 1053U) = ixgbe_read_reg(hw,16984U);
  #line 812 
  *(regs_buff + 1054U) = ixgbe_read_reg(hw,16988U);
  #line 813 
  *(regs_buff + 1055U) = ixgbe_read_reg(hw,16992U);
  #line 814 
  *(regs_buff + 1056U) = ixgbe_read_reg(hw,16996U);
  #line 815 
  *(regs_buff + 1057U) = ixgbe_read_reg(hw,17000U);
  #line 816 
  *(regs_buff + 1058U) = ixgbe_read_reg(hw,17004U);
  #line 817 
  *(regs_buff + 1059U) = ixgbe_read_reg(hw,17032U);
  #line 818 
  *(regs_buff + 1060U) = ixgbe_read_reg(hw,17036U);
  #line 819 
  *(regs_buff + 1061U) = ixgbe_read_reg(hw,17040U);
  #line 820 
  *(regs_buff + 1062U) = ixgbe_read_reg(hw,17048U);
  #line 821 
  *(regs_buff + 1063U) = ixgbe_read_reg(hw,17052U);
  #line 822 
  *(regs_buff + 1064U) = ixgbe_read_reg(hw,17056U);
  #line 823 
  *(regs_buff + 1065U) = ixgbe_read_reg(hw,17060U);
  #line 824 
  *(regs_buff + 1066U) = ixgbe_read_reg(hw,17064U);
  #line 825 
  *(regs_buff + 1067U) = ixgbe_read_reg(hw,17068U);
  #line 826 
  *(regs_buff + 1068U) = ixgbe_read_reg(hw,17072U);
  #line 827 
  *(regs_buff + 1069U) = ixgbe_read_reg(hw,17076U);
  #line 828 
  *(regs_buff + 1070U) = ixgbe_read_reg(hw,18432U);
  #line 831 
  *(regs_buff + 1071U) = ixgbe_read_reg(hw,11296U);
  #line 832 
  i = (unsigned char)0U;
  #line 832 
  while ((unsigned int)i <= 7U) {
    #line 833 
    *(regs_buff + (unsigned long)((int)i + 1072)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 2816) * 4));
    #line 832 
    i = (u8)((int)i + 1);
  }
  #line 834 
  *(regs_buff + 1080U) = ixgbe_read_reg(hw,12040U);
  #line 835 
  i = (unsigned char)0U;
  #line 835 
  while ((unsigned int)i <= 3U) {
    #line 836 
    *(regs_buff + (unsigned long)((int)i + 1081)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 3012) * 4));
    #line 835 
    i = (u8)((int)i + 1);
  }
  #line 837 
  *(regs_buff + 1085U) = ixgbe_read_reg(hw,12064U);
  #line 838 
  *(regs_buff + 1086U) = ixgbe_read_reg(hw,31776U);
  #line 839 
  i = (unsigned char)0U;
  #line 839 
  while ((unsigned int)i <= 7U) {
    #line 840 
    *(regs_buff + (unsigned long)((int)i + 1087)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 7936) * 4));
    #line 839 
    i = (u8)((int)i + 1);
  }
  #line 841 
  *(regs_buff + 1095U) = ixgbe_read_reg(hw,32520U);
  #line 842 
  i = (unsigned char)0U;
  #line 842 
  while ((unsigned int)i <= 3U) {
    #line 843 
    *(regs_buff + (unsigned long)((int)i + 1096)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 8132) * 4));
    #line 842 
    i = (u8)((int)i + 1);
  }
  #line 844 
  *(regs_buff + 1100U) = ixgbe_read_reg(hw,32544U);
  #line 845 
  *(regs_buff + 1101U) = ixgbe_read_reg(hw,50688U);
  #line 846 
  i = (unsigned char)0U;
  #line 846 
  while ((unsigned int)i <= 3U) {
    #line 847 
    *(regs_buff + (unsigned long)((int)i + 1102)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 12676) * 4));
    #line 846 
    i = (u8)((int)i + 1);
  }
  #line 848 
  *(regs_buff + 1106U) = ixgbe_read_reg(hw,13824U);
  #line 849 
  i = (unsigned char)0U;
  #line 849 
  while ((unsigned int)i <= 3U) {
    #line 850 
    *(regs_buff + (unsigned long)((int)i + 1107)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 3460) * 4));
    #line 849 
    i = (u8)((int)i + 1);
  }
  #line 851 
  i = (unsigned char)0U;
  #line 851 
  while ((unsigned int)i <= 7U) {
    #line 852 
    *(regs_buff + (unsigned long)((int)i + 1111)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 17444) * 4));
    #line 851 
    i = (u8)((int)i + 1);
  }
  #line 853 
  *(regs_buff + 1119U) = ixgbe_read_reg(hw,20644U);
  #line 854 
  *(regs_buff + 1120U) = ixgbe_read_reg(hw,17080U);
  #line 855 
  *(regs_buff + 1121U) = ixgbe_read_reg(hw,17088U);
  #line 856 
  *(regs_buff + 1122U) = ixgbe_read_reg(hw,17092U);
  #line 857 
  *(regs_buff + 1123U) = ixgbe_read_reg(hw,17096U);
  #line 858 
  *(regs_buff + 1124U) = ixgbe_read_reg(hw,17100U);
  #line 859 
  *(regs_buff + 1125U) = ixgbe_read_reg(hw,69740U);
  #line 860 
  *(regs_buff + 1126U) = ixgbe_read_reg(hw,49920U);
  #line 861 
  *(regs_buff + 1127U) = ixgbe_read_reg(hw,13056U);
  #line 864 
  *(regs_buff + 1128U) = ixgbe_read_reg(hw,17044U);
  #line 867 
  *(regs_buff + 1129U) = ixgbe_read_reg(hw,12320U);
  #line 868 
  *(regs_buff + 1130U) = ixgbe_read_reg(hw,51200U);
  #line 869 
  i = (unsigned char)0U;
  #line 869 
  while ((unsigned int)i <= 3U) {
    #line 870 
    *(regs_buff + (unsigned long)((int)i + 1131)) = ixgbe_read_reg(hw,(unsigned int)(((int)i + 8376) * 4));
    #line 869 
    i = (u8)((int)i + 1);
  }
  #line 871 
  *(regs_buff + 1135U) = ixgbe_read_reg(hw,18816U);
  #line 873 
  *(regs_buff + 1136U) = ixgbe_read_reg(hw,18828U);
  #line 877 
  *(regs_buff + 1137U) = ixgbe_read_reg(hw,35584U);
  #line 878 
  *(regs_buff + 1138U) = ixgbe_read_reg(hw,19088U);
  #line 881 
  *(regs_buff + 1139U) = ixgbe_read_reg(hw,34816U);
  #line 882 
  *(regs_buff + 1140U) = ixgbe_read_reg(hw,34820U);
  #line 883 
  *(regs_buff + 1141U) = ixgbe_read_reg(hw,34824U);
  #line 884 
  *(regs_buff + 1142U) = ixgbe_read_reg(hw,34832U);
  #line 885 
  *(regs_buff + 1143U) = ixgbe_read_reg(hw,36096U);
  #line 886 
  *(regs_buff + 1144U) = ixgbe_read_reg(hw,36100U);
  #line 887 
  return;
}

#line 889  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_eeprom_len(struct net_device *netdev)
{
  #line 891 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 892 
  return (int)adapter->hw.eeprom.word_size * 2;
}

#line 895  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_eeprom(struct net_device *netdev, struct ethtool_eeprom *eeprom, u8 *bytes)
{
  #line 900 
  u16 *eeprom_buff;
  #line 901 
  int first_word;
  #line 901 
  int last_word;
  #line 901 
  int eeprom_len;
  #line 903 
  u16 i;
  #line 898 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 899 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 902 
  int ret_val = 0;
  #line 905 
  if (eeprom->len == 0U) 
                         #line 906 
                         return -22;
  #line 908 
  eeprom->magic = (unsigned int)((int)hw->vendor_id | ((int)hw->device_id << 16));
  #line 910 
  first_word = (int)(eeprom->offset >> 1);
  #line 911 
  last_word = (int)(((eeprom->offset + eeprom->len) + 4294967295U) >> 1);
  #line 912 
  eeprom_len = (last_word - first_word) + 1;
  #line 914 
  eeprom_buff = (u16 *)kmalloc_array((unsigned long)eeprom_len,2UL,3264U);
  #line 915 
  if (eeprom_buff == (u16 *)0U) 
                                #line 916 
                                return -12;
  #line 918 
  ret_val = (*(hw->eeprom.ops.read_buffer))(hw,(unsigned short)((int)((unsigned short)first_word)),(unsigned short)((int)((unsigned short)eeprom_len)),eeprom_buff);
  #line 922 
  i = (unsigned short)0U;
  #line 922 
  while ((int)i < eeprom_len) {
    #line 923 
    u16 *tmp_2 = eeprom_buff + (unsigned long)i;
    #line 922 
    i = (u16)((int)i + 1);
  }
  #line 925 
  memcpy((void *)bytes,(void *)((u8 *)eeprom_buff + ((unsigned long)eeprom->offset & (unsigned long)1U)),(unsigned long)eeprom->len);
  #line 926 
  kfree((void *)eeprom_buff);
  #line 928 
  return ret_val;
}

#line 931  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_eeprom(struct net_device *netdev, struct ethtool_eeprom *eeprom, u8 *bytes)
{
  #line 936 
  u16 *eeprom_buff;
  #line 937 
  void *ptr;
  #line 938 
  int max_len;
  #line 938 
  int first_word;
  #line 938 
  int last_word;
  #line 939 
  u16 i;
  #line 934 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 935 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 938 
  int ret_val = 0;
  #line 941 
  if (eeprom->len == 0U) 
                         #line 942 
                         return -22;
  #line 944 
  if (eeprom->magic != (unsigned int)((int)hw->vendor_id | ((int)hw->device_id << 16))) 
    #line 945 
    return -22;
  #line 947 
  max_len = (int)hw->eeprom.word_size * 2;
  #line 949 
  first_word = (int)(eeprom->offset >> 1);
  #line 950 
  last_word = (int)(((eeprom->offset + eeprom->len) + 4294967295U) >> 1);
  #line 951 
  eeprom_buff = (u16 *)kmalloc_0((unsigned long)max_len,3264U);
  #line 952 
  if (eeprom_buff == (u16 *)0U) 
                                #line 953 
                                return -12;
  #line 955 
  ptr = (void *)eeprom_buff;
  #line 957 
  if ((eeprom->offset & 1U) != 0U) {
    #line 962 
    ret_val = (*(hw->eeprom.ops.read))(hw,(unsigned short)((int)((unsigned short)first_word)),eeprom_buff);
    #line 963 
    if (ret_val != 0) 
                      #line 964 
                      goto err;
    #line 966 
    ptr ++;
  }
  #line 968 
  if (((eeprom->offset + eeprom->len) & 1U) != 0U) {
    #line 973 
    ret_val = (*(hw->eeprom.ops.read))(hw,(unsigned short)((int)((unsigned short)last_word)),eeprom_buff + (unsigned long)(last_word - first_word));
    #line 975 
    if (ret_val != 0) 
                      #line 976 
                      goto err;
  }
  #line 980 
  i = (unsigned short)0U;
  #line 980 
  while (last_word - first_word >= (int)i) {
    #line 981 
    u16 *tmp_2 = eeprom_buff + (unsigned long)i;
    #line 980 
    i = (u16)((int)i + 1);
  }
  #line 983 
  memcpy(ptr,(void *)bytes,(unsigned long)eeprom->len);
  #line 985 
  i = (unsigned short)0U;
  #line 985 
  while (last_word - first_word >= (int)i) {
    #line 986 
    u16 *tmp_4 = eeprom_buff + (unsigned long)i;
    #line 985 
    i = (u16)((int)i + 1);
  }
  #line 988 
  ret_val = (*(hw->eeprom.ops.write_buffer))(hw,(unsigned short)((int)((unsigned short)first_word)),(unsigned short)((int)((unsigned int)((int)((unsigned short)last_word) - (int)((unsigned short)first_word)) + 1U)),eeprom_buff);
  #line 993 
  if (ret_val == 0) 
                    #line 994 
                    (*(hw->eeprom.ops.update_checksum))(hw);
  #line 996 
  err: 
       #line 996 
  ;
  #line 997 
  kfree((void *)eeprom_buff);
  #line 998 
  return ret_val;
}

#line 1001  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *drvinfo)
{
  #line 1004 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 1006 
  strlcpy((char *)(& drvinfo->driver),(char *)(& ixgbe_driver_name),32UL);
  #line 1007 
  strlcpy((char *)(& drvinfo->version),(char *)(& ixgbe_driver_version),32UL);
  #line 1010 
  strlcpy((char *)(& drvinfo->fw_version),(char *)(& adapter->eeprom_id),32UL);
  #line 1013 
  ;
  #line 1013 
  strlcpy((char *)(& drvinfo->bus_info),pci_name(adapter->pdev),32UL);
  #line 1016 
  drvinfo->n_priv_flags = 2U;
  #line 1017 
  return;
}

#line 1019  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_ringparam(struct net_device *netdev, struct ethtool_ringparam *ring)
{
  #line 1022 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 1023 
  struct ixgbe_ring *tx_ring = adapter->tx_ring[0];
  #line 1024 
  struct ixgbe_ring *rx_ring = adapter->rx_ring[0];
  #line 1026 
  ring->rx_max_pending = 4096U;
  #line 1027 
  ring->tx_max_pending = 4096U;
  #line 1028 
  ring->rx_pending = (unsigned int)rx_ring->count;
  #line 1029 
  ring->tx_pending = (unsigned int)tx_ring->count;
  #line 1030 
  return;
}

#line 1032  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_ringparam(struct net_device *netdev, struct ethtool_ringparam *ring)
{
  #line 1074 
  int tmp_10;
  #line 1043 
  unsigned int tmp_2;
  #line 1047 
  unsigned int __UNIQUE_ID___x450;
  #line 1047 
  unsigned int tmp_6;
  #line 1043 
  unsigned int __UNIQUE_ID___x446;
  #line 1074 
  int __UNIQUE_ID___x452;
  #line 1036 
  struct ixgbe_ring *temp_ring;
  #line 1037 
  int i;
  #line 1037 
  int j;
  #line 1038 
  u32 new_rx_count;
  #line 1038 
  u32 new_tx_count;
  #line 1035 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 1037 
  int err = 0;
  #line 1040 
  if (ring->rx_mini_pending != 0U || ring->rx_jumbo_pending != 0U) 
                                                                   #line 1041 
                                                                   return -22;
  {
    #line 1043 
    unsigned int __UNIQUE_ID___x444;
    #line 1043 
    unsigned int tmp_0;
    {
      #line 1043 
      __UNIQUE_ID___x444 = ring->tx_pending;
      #line 1043 
      unsigned int __UNIQUE_ID___y445 = 64U;
      #line 1043 
      if (__UNIQUE_ID___x444 > __UNIQUE_ID___y445) 
                                                   #line 1043 
                                                   tmp_0 = __UNIQUE_ID___x444; else 
                                                                    #line 1043 
                                                                    tmp_0 = __UNIQUE_ID___y445;
      }
    #line 1043 
    __UNIQUE_ID___x446 = tmp_0;
    #line 1043 
    unsigned int __UNIQUE_ID___y447 = 4096U;
    #line 1043 
    if (__UNIQUE_ID___x446 < __UNIQUE_ID___y447) 
                                                 #line 1043 
                                                 tmp_2 = __UNIQUE_ID___x446; else 
                                                                    #line 1043 
                                                                    tmp_2 = __UNIQUE_ID___y447;
    }
  #line 1043 
  new_tx_count = tmp_2;
  #line 1045 
  new_tx_count = (new_tx_count + 7U) & 4294967288U;
  {
    #line 1047 
    unsigned int __UNIQUE_ID___x448;
    #line 1047 
    unsigned int tmp_4;
    {
      #line 1047 
      __UNIQUE_ID___x448 = ring->rx_pending;
      #line 1047 
      unsigned int __UNIQUE_ID___y449 = 64U;
      #line 1047 
      if (__UNIQUE_ID___x448 > __UNIQUE_ID___y449) 
                                                   #line 1047 
                                                   tmp_4 = __UNIQUE_ID___x448; else 
                                                                    #line 1047 
                                                                    tmp_4 = __UNIQUE_ID___y449;
      }
    #line 1047 
    __UNIQUE_ID___x450 = tmp_4;
    #line 1047 
    unsigned int __UNIQUE_ID___y451 = 4096U;
    #line 1047 
    if (__UNIQUE_ID___x450 < __UNIQUE_ID___y451) 
                                                 #line 1047 
                                                 tmp_6 = __UNIQUE_ID___x450; else 
                                                                    #line 1047 
                                                                    tmp_6 = __UNIQUE_ID___y451;
    }
  #line 1047 
  new_rx_count = tmp_6;
  #line 1049 
  new_rx_count = (new_rx_count + 7U) & 4294967288U;
  #line 1051 
  if (adapter->tx_ring_count == new_tx_count && adapter->rx_ring_count == new_rx_count) 
    #line 1054 
    return 0;
  #line 1057 
  while (1) {
    #line 1057 
    if (! ((int)test_and_set_bit(1L,& adapter->state) != 0)) 
                                                             #line 1057 
                                                             break;
    #line 1058 
    usleep_range(1000UL,2000UL);
  }
  #line 1060 
  if (! netif_running(adapter->netdev)) {
    #line 1061 
    i = 0;
    #line 1061 
    while (adapter->num_tx_queues > i) {
      #line 1062 
      (adapter->tx_ring[i])->count = (unsigned short)new_tx_count;
      #line 1061 
      i ++;
    }
    #line 1063 
    i = 0;
    #line 1063 
    while (adapter->num_xdp_queues > i) {
      #line 1064 
      (adapter->xdp_ring[i])->count = (unsigned short)new_tx_count;
      #line 1063 
      i ++;
    }
    #line 1065 
    i = 0;
    #line 1065 
    while (adapter->num_rx_queues > i) {
      #line 1066 
      (adapter->rx_ring[i])->count = (unsigned short)new_rx_count;
      #line 1065 
      i ++;
    }
    #line 1067 
    adapter->tx_ring_count = new_tx_count;
    #line 1068 
    adapter->xdp_ring_count = new_tx_count;
    #line 1069 
    adapter->rx_ring_count = new_rx_count;
    #line 1070 
    goto clear_reset;
  }
  {
    #line 1074 
    __UNIQUE_ID___x452 = adapter->num_tx_queues + adapter->num_xdp_queues;
    #line 1074 
    int __UNIQUE_ID___y453 = adapter->num_rx_queues;
    #line 1074 
    if (__UNIQUE_ID___x452 > __UNIQUE_ID___y453) 
                                                 #line 1074 
                                                 tmp_10 = __UNIQUE_ID___x452; else 
                                                                    #line 1074 
                                                                    tmp_10 = __UNIQUE_ID___y453;
    }
  #line 1074 
  i = tmp_10;
  #line 1076 
  temp_ring = (struct ixgbe_ring *)cif_vmalloc_0(array_size((unsigned long)i,4096UL));
  #line 1078 
  if (temp_ring == (struct ixgbe_ring *)0) {
    #line 1079 
    err = -12;
    #line 1080 
    goto clear_reset;
  }
  #line 1083 
  ixgbe_down(adapter);
  #line 1091 
  if (adapter->tx_ring_count != new_tx_count) {
    #line 1092 
    i = 0;
    #line 1092 
    while (adapter->num_tx_queues > i) {
      #line 1093 
      memcpy((void *)(temp_ring + (unsigned long)i),(void *)adapter->tx_ring[i],4096UL);
      #line 1096 
      (temp_ring + (unsigned long)i)->count = (unsigned short)new_tx_count;
      #line 1097 
      err = ixgbe_setup_tx_resources(temp_ring + (unsigned long)i);
      #line 1098 
      if (err != 0) {
        #line 1099 
        while (i != 0) {
          #line 1100 
          i --;
          #line 1101 
          ixgbe_free_tx_resources(temp_ring + (unsigned long)i);
        }
        #line 1103 
        goto err_setup;
      }
      #line 1092 
      i ++;
    }
    #line 1107 
    j = 0;
    #line 1107 
    while (adapter->num_xdp_queues > j) {
      #line 1108 
      memcpy((void *)(temp_ring + (unsigned long)i),(void *)adapter->xdp_ring[j],4096UL);
      #line 1111 
      (temp_ring + (unsigned long)i)->count = (unsigned short)new_tx_count;
      #line 1112 
      err = ixgbe_setup_tx_resources(temp_ring + (unsigned long)i);
      #line 1113 
      if (err != 0) {
        #line 1114 
        while (i != 0) {
          #line 1115 
          i --;
          #line 1116 
          ixgbe_free_tx_resources(temp_ring + (unsigned long)i);
        }
        #line 1118 
        goto err_setup;
      }
      #line 1107 
      j ++;
      #line 1107 
      i ++;
    }
    #line 1122 
    i = 0;
    #line 1122 
    while (adapter->num_tx_queues > i) {
      #line 1123 
      ixgbe_free_tx_resources(adapter->tx_ring[i]);
      #line 1125 
      memcpy((void *)adapter->tx_ring[i],(void *)(temp_ring + (unsigned long)i),4096UL);
      #line 1122 
      i ++;
    }
    #line 1128 
    j = 0;
    #line 1128 
    while (adapter->num_xdp_queues > j) {
      #line 1129 
      ixgbe_free_tx_resources(adapter->xdp_ring[j]);
      #line 1131 
      memcpy((void *)adapter->xdp_ring[j],(void *)(temp_ring + (unsigned long)i),4096UL);
      #line 1128 
      j ++;
      #line 1128 
      i ++;
    }
    #line 1135 
    adapter->tx_ring_count = new_tx_count;
  }
  #line 1139 
  if (adapter->rx_ring_count != new_rx_count) {
    #line 1140 
    i = 0;
    #line 1140 
    while (adapter->num_rx_queues > i) {
      #line 1141 
      memcpy((void *)(temp_ring + (unsigned long)i),(void *)adapter->rx_ring[i],4096UL);
      #line 1145 
      memset((void *)(& (temp_ring + (unsigned long)i)->xdp_rxq),0,64UL);
      #line 1148 
      (temp_ring + (unsigned long)i)->count = (unsigned short)new_rx_count;
      #line 1149 
      err = ixgbe_setup_rx_resources(adapter,temp_ring + (unsigned long)i);
      #line 1150 
      if (err != 0) {
        #line 1151 
        while (i != 0) {
          #line 1152 
          i --;
          #line 1153 
          ixgbe_free_rx_resources(temp_ring + (unsigned long)i);
        }
        #line 1155 
        goto err_setup;
      }
      #line 1140 
      i ++;
    }
    #line 1160 
    i = 0;
    #line 1160 
    while (adapter->num_rx_queues > i) {
      #line 1161 
      ixgbe_free_rx_resources(adapter->rx_ring[i]);
      #line 1163 
      memcpy((void *)adapter->rx_ring[i],(void *)(temp_ring + (unsigned long)i),4096UL);
      #line 1160 
      i ++;
    }
    #line 1167 
    adapter->rx_ring_count = new_rx_count;
  }
  #line 1170 
  err_setup: 
             #line 1170 
  ;
  #line 1171 
  ixgbe_up(adapter);
  #line 1172 
  cif_vfree_0((void *)temp_ring);
  #line 1173 
  clear_reset: 
               #line 1173 
  ;
  #line 1174 
  cif_clear_bit_0(1L,& adapter->state);
  #line 1175 
  return err;
}

#line 1178  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_sset_count(struct net_device *netdev, int sset)
{
  #line 1180 
  switch (sset) {
    #line 1181 
    case 0: 
            #line 1181 
    ;
    #line 1182 
    return 5;
    #line 1183 
    case 1: 
            #line 1183 
    ;
    #line 1184 
    return (int)(((unsigned long)(netdev->num_tx_queues * 2U) + 48UL) * (unsigned long)2U);
    #line 1185 
    case 2: 
            #line 1185 
    ;
    #line 1186 
    return 2;
    #line 1187 
    default: 
             #line 1187 
    ;
    #line 1188 
    return -95;
  }
}

#line 1192  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_ethtool_stats(struct net_device *netdev, struct ethtool_stats *stats, u64 *data)
{
  #line 1196 
  struct rtnl_link_stats64 temp;
  #line 1197 
  struct rtnl_link_stats64 *net_stats;
  #line 1198 
  unsigned int start;
  #line 1199 
  struct ixgbe_ring *ring;
  #line 1200 
  int i;
  #line 1200 
  int j;
  #line 1195 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 1201 
  char *p = (char *)0;
  #line 1203 
  ixgbe_update_stats(adapter);
  #line 1204 
  net_stats = dev_get_stats(netdev,& temp);
  #line 1205 
  i = 0;
  #line 1205 
  while ((unsigned int)i <= 63U) {
    #line 1206 
    switch (ixgbe_gstrings_stats[i].type) {
      #line 1207 
      case 0: 
              #line 1207 
      ;
      #line 1208 
      p = (char *)net_stats + (unsigned long)ixgbe_gstrings_stats[i].stat_offset;
      #line 1210 
      break;
      #line 1211 
      case 1: 
              #line 1211 
      ;
      #line 1212 
      p = (char *)adapter + (unsigned long)ixgbe_gstrings_stats[i].stat_offset;
      #line 1214 
      break;
      #line 1215 
      default: 
               #line 1215 
      ;
      #line 1216 
      *(data + (unsigned long)i) = 0ULL;
      #line 1217 
      goto __Cont;
    }
    #line 1220 
    if (ixgbe_gstrings_stats[i].sizeof_stat == 8) 
                                                  #line 1220 
                                                  *(data + (unsigned long)i) = *((u64 *)p); else 
                                                                    #line 1220 
                                                                    *(data + (unsigned long)i) = (unsigned long long)*((u32 *)p);
    #line 1205 
    __Cont: 
            #line 1205 
    i ++;
  }
  #line 1223 
  j = 0;
  #line 1223 
  while (netdev->num_tx_queues > (unsigned int)j) {
    #line 1224 
    ring = adapter->tx_ring[j];
    #line 1225 
    if (ring == (struct ixgbe_ring *)0) {
      #line 1226 
      *(data + (unsigned long)i) = 0ULL;
      #line 1227 
      *(data + ((unsigned long)i + (unsigned long)1U)) = 0ULL;
      #line 1228 
      i += 2;
      #line 1229 
      goto __Cont_0;
    }
    #line 1232 
    while (1) {
      #line 1233 
      start = u64_stats_fetch_begin_irq(& ring->syncp);
      #line 1234 
      *(data + (unsigned long)i) = ring->stats.packets;
      #line 1235 
      *(data + ((unsigned long)i + (unsigned long)1U)) = ring->stats.bytes;
      #line 1236 
      if (! ((int)u64_stats_fetch_retry_irq(& ring->syncp,start) != 0)) 
        #line 1232 
        break;
    }
    #line 1237 
    i += 2;
    #line 1223 
    __Cont_0: 
              #line 1223 
    j ++;
  }
  #line 1239 
  j = 0;
  #line 1239 
  while (netdev->num_tx_queues > (unsigned int)j) {
    #line 1240 
    ring = adapter->rx_ring[j];
    #line 1241 
    if (ring == (struct ixgbe_ring *)0) {
      #line 1242 
      *(data + (unsigned long)i) = 0ULL;
      #line 1243 
      *(data + ((unsigned long)i + (unsigned long)1U)) = 0ULL;
      #line 1244 
      i += 2;
      #line 1245 
      goto __Cont_1;
    }
    #line 1248 
    while (1) {
      #line 1249 
      start = u64_stats_fetch_begin_irq(& ring->syncp);
      #line 1250 
      *(data + (unsigned long)i) = ring->stats.packets;
      #line 1251 
      *(data + ((unsigned long)i + (unsigned long)1U)) = ring->stats.bytes;
      #line 1252 
      if (! ((int)u64_stats_fetch_retry_irq(& ring->syncp,start) != 0)) 
        #line 1248 
        break;
    }
    #line 1253 
    i += 2;
    #line 1239 
    __Cont_1: 
              #line 1239 
    j ++;
  }
  #line 1256 
  j = 0;
  #line 1256 
  while (j <= 7) {
    {
      #line 1257 
      int tmp_3;
      #line 1258 
      int tmp_4;
      #line 1257 
      tmp_3 = i;
      #line 1257 
      i ++;
      #line 1257 
      *(data + (unsigned long)tmp_3) = adapter->stats.pxontxc[j];
      #line 1258 
      tmp_4 = i;
      #line 1258 
      i ++;
      #line 1258 
      *(data + (unsigned long)tmp_4) = adapter->stats.pxofftxc[j];
    }
    #line 1256 
    j ++;
  }
  #line 1260 
  j = 0;
  #line 1260 
  while (j <= 7) {
    {
      #line 1261 
      int tmp_5;
      #line 1262 
      int tmp_6;
      #line 1261 
      tmp_5 = i;
      #line 1261 
      i ++;
      #line 1261 
      *(data + (unsigned long)tmp_5) = adapter->stats.pxonrxc[j];
      #line 1262 
      tmp_6 = i;
      #line 1262 
      i ++;
      #line 1262 
      *(data + (unsigned long)tmp_6) = adapter->stats.pxoffrxc[j];
    }
    #line 1260 
    j ++;
  }
  #line 1264 
  return;
}

#line 1266  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_strings(struct net_device *netdev, u32 stringset, u8 *data)
{
  #line 1270 
  unsigned int i;
  #line 1269 
  char *p = (char *)data;
  #line 1272 
  switch (stringset) {
    #line 1273 
    case (u32)0: 
                 #line 1273 
    ;
    #line 1274 
    i = 0U;
    #line 1274 
    while (i <= 4U) {
      #line 1275 
      memcpy((void *)data,(void *)(& ixgbe_gstrings_test[i]),32UL);
      #line 1276 
      data += 32U;
      #line 1274 
      i ++;
    }
    #line 1278 
    break;
    #line 1279 
    case (u32)1: 
                 #line 1279 
    ;
    #line 1280 
    i = 0U;
    #line 1280 
    while (i <= 63U) {
      #line 1281 
      memcpy((void *)p,(void *)(& ixgbe_gstrings_stats[i].stat_string),32UL);
      #line 1283 
      p += 32U;
      #line 1280 
      i ++;
    }
    #line 1285 
    i = 0U;
    #line 1285 
    while (netdev->num_tx_queues > i) {
      #line 1286 
      sprintf(p,(char *)"tx_queue_%u_packets",i);
      #line 1287 
      p += 32U;
      #line 1288 
      sprintf(p,(char *)"tx_queue_%u_bytes",i);
      #line 1289 
      p += 32U;
      #line 1285 
      i ++;
    }
    #line 1291 
    i = 0U;
    #line 1291 
    while (netdev->num_tx_queues > i) {
      #line 1292 
      sprintf(p,(char *)"rx_queue_%u_packets",i);
      #line 1293 
      p += 32U;
      #line 1294 
      sprintf(p,(char *)"rx_queue_%u_bytes",i);
      #line 1295 
      p += 32U;
      #line 1291 
      i ++;
    }
    #line 1297 
    i = 0U;
    #line 1297 
    while (i <= 7U) {
      #line 1298 
      sprintf(p,(char *)"tx_pb_%u_pxon",i);
      #line 1299 
      p += 32U;
      #line 1300 
      sprintf(p,(char *)"tx_pb_%u_pxoff",i);
      #line 1301 
      p += 32U;
      #line 1297 
      i ++;
    }
    #line 1303 
    i = 0U;
    #line 1303 
    while (i <= 7U) {
      #line 1304 
      sprintf(p,(char *)"rx_pb_%u_pxon",i);
      #line 1305 
      p += 32U;
      #line 1306 
      sprintf(p,(char *)"rx_pb_%u_pxoff",i);
      #line 1307 
      p += 32U;
      #line 1303 
      i ++;
    }
    #line 1310 
    break;
    #line 1311 
    case (u32)2: 
                 #line 1311 
    ;
    #line 1312 
    memcpy((void *)data,(void *)(& ixgbe_priv_flags_strings),64UL);
  }
  #line 1314 
  return;
}

#line 1317  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_link_test(struct ixgbe_adapter *adapter, u64 *data)
{
  #line 1320 
  bool link_up;
  #line 1319 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 1321 
  u32 link_speed = 0U;
  #line 1323 
  if ((int)ixgbe_removed((void *)hw->hw_addr) != 0) {
    #line 1324 
    *data = 1ULL;
    #line 1325 
    return 1;
  }
  #line 1327 
  *data = 0ULL;
  #line 1329 
  (*(hw->mac.ops.check_link))(hw,& link_speed,& link_up,(_Bool)1);
  #line 1330 
  if ((int)link_up != 0) 
                         #line 1331 
                         return (int)*data; else 
                                                 #line 1333 
                                                 *data = 1ULL;
  #line 1334 
  return (int)*data;
}

#line 1364  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static struct ixgbe_reg_test reg_test_82599[20U] = {{.reg = (unsigned short)12832U, .array_len = (unsigned char)1U, .test_type = (unsigned char)1U, .mask = 2148007920U, .write = 2148007920U}, {.reg = (unsigned short)12896U, .array_len = (unsigned char)1U, .test_type = (unsigned char)1U, .mask = 2148007920U, .write = 2148007920U}, {.reg = (unsigned short)12296U, .array_len = (unsigned char)1U, .test_type = (unsigned char)1U, .mask = 4294967295U, .write = 4294967295U}, {.reg = (unsigned short)20616U, .array_len = (unsigned char)1U, .test_type = (unsigned char)1U}, {.reg = (unsigned short)4096U, .array_len = (unsigned char)4U, .test_type = (unsigned char)1U, .mask = 4294967168U, .write = 4294967168U}, {.reg = (unsigned short)4100U, .array_len = (unsigned char)4U, .test_type = (unsigned char)1U, .mask = 4294967295U, .write = 4294967295U}, {.reg = (unsigned short)4104U, .array_len = (unsigned char)4U, .test_type = (unsigned char)1U, .mask = 1048448U, .write = 1048575U}, {.reg = (unsigned short)4136U, .array_len = (unsigned char)4U, .test_type = (unsigned char)3U, .write = 33554432U}, {.reg = (unsigned short)4120U, .array_len = (unsigned char)4U, .test_type = (unsigned char)1U, .mask = 65535U, .write = 65535U}, {.reg = (unsigned short)4136U, .array_len = (unsigned char)4U, .test_type = (unsigned char)3U}, {.reg = (unsigned short)12896U, .array_len = (unsigned char)1U, .test_type = (unsigned char)1U, .mask = 2148007920U, .write = 2148007920U}, {.reg = (unsigned short)12800U, .array_len = (unsigned char)1U, .test_type = (unsigned char)1U, .mask = 4294967295U, .write = 4294967295U}, {.reg = (unsigned short)24576U, .array_len = (unsigned char)4U, .test_type = (unsigned char)1U, .mask = 4294967168U, .write = 4294967295U}, {.reg = (unsigned short)24580U, .array_len = (unsigned char)4U, .test_type = (unsigned char)1U, .mask = 4294967295U, .write = 4294967295U}, {.reg = (unsigned short)24584U, .array_len = (unsigned char)4U, .test_type = (unsigned char)1U, .mask = 1048448U, .write = 1048448U}, {.reg = (unsigned short)12288U, .array_len = (unsigned char)1U, .test_type = (unsigned char)2U, .mask = 1U, .write = 1U}, {.reg = (unsigned short)21504U, .array_len = (unsigned char)16U, .test_type = (unsigned char)5U, .mask = 4294967295U, .write = 4294967295U}, {.reg = (unsigned short)21504U, .array_len = (unsigned char)16U, .test_type = (unsigned char)6U, .mask = 2147614719U, .write = 2148335615U}, {.reg = (unsigned short)20992U, .array_len = (unsigned char)128U, .test_type = (unsigned char)4U, .mask = 4294967295U, .write = 4294967295U}};
#line 1388  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static struct ixgbe_reg_test reg_test_82598[22U] = {{.reg = (unsigned short)12832U, .array_len = (unsigned char)1U, .test_type = (unsigned char)1U, .mask = 2148007920U, .write = 2148007920U}, {.reg = (unsigned short)12896U, .array_len = (unsigned char)1U, .test_type = (unsigned char)1U, .mask = 2148007920U, .write = 2148007920U}, {.reg = (unsigned short)12296U, .array_len = (unsigned char)1U, .test_type = (unsigned char)1U, .mask = 4294967295U, .write = 4294967295U}, {.reg = (unsigned short)20616U, .array_len = (unsigned char)1U, .test_type = (unsigned char)1U}, {.reg = (unsigned short)4096U, .array_len = (unsigned char)4U, .test_type = (unsigned char)1U, .mask = 4294967168U, .write = 4294967295U}, {.reg = (unsigned short)4100U, .array_len = (unsigned char)4U, .test_type = (unsigned char)1U, .mask = 4294967295U, .write = 4294967295U}, {.reg = (unsigned short)4104U, .array_len = (unsigned char)4U, .test_type = (unsigned char)1U, .mask = 1048448U, .write = 1048575U}, {.reg = (unsigned short)4136U, .array_len = (unsigned char)4U, .test_type = (unsigned char)3U, .write = 33554432U}, {.reg = (unsigned short)4120U, .array_len = (unsigned char)4U, .test_type = (unsigned char)1U, .mask = 65535U, .write = 65535U}, {.reg = (unsigned short)4136U, .array_len = (unsigned char)4U, .test_type = (unsigned char)3U}, {.reg = (unsigned short)12896U, .array_len = (unsigned char)1U, .test_type = (unsigned char)1U, .mask = 2148007920U, .write = 2148007920U}, {.reg = (unsigned short)12800U, .array_len = (unsigned char)1U, .test_type = (unsigned char)1U, .mask = 4294967295U, .write = 4294967295U}, {.reg = (unsigned short)51968U, .array_len = (unsigned char)1U, .test_type = (unsigned char)1U, .mask = 255U, .write = 255U}, {.reg = (unsigned short)24576U, .array_len = (unsigned char)4U, .test_type = (unsigned char)1U, .mask = 4294967168U, .write = 4294967295U}, {.reg = (unsigned short)24580U, .array_len = (unsigned char)4U, .test_type = (unsigned char)1U, .mask = 4294967295U, .write = 4294967295U}, {.reg = (unsigned short)24584U, .array_len = (unsigned char)4U, .test_type = (unsigned char)1U, .mask = 1048448U, .write = 1048575U}, {.reg = (unsigned short)12288U, .array_len = (unsigned char)1U, .test_type = (unsigned char)2U, .mask = 3U, .write = 3U}, {.reg = (unsigned short)32256U, .array_len = (unsigned char)1U, .test_type = (unsigned char)2U, .mask = 5U, .write = 5U}, {.reg = (unsigned short)21504U, .array_len = (unsigned char)16U, .test_type = (unsigned char)5U, .mask = 4294967295U, .write = 4294967295U}, {.reg = (unsigned short)21504U, .array_len = (unsigned char)16U, .test_type = (unsigned char)6U, .mask = 2148335615U, .write = 2148335615U}, {.reg = (unsigned short)20992U, .array_len = (unsigned char)128U, .test_type = (unsigned char)4U, .mask = 4294967295U, .write = 4294967295U}};
#line 1415  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static bool reg_pattern_test(struct ixgbe_adapter *adapter, u64 *data, int reg, u32 mask, u32 write)
{
  #line 1418 
  u32 pat;
  #line 1418 
  u32 val;
  #line 1418 
  u32 before;
  #line 1419 
  u32 test_pattern[4U] = {1515870810U, 2779096485U, 0U, 4294967295U};
  #line 1422 
  if ((int)ixgbe_removed((void *)adapter->hw.hw_addr) != 0) {
    #line 1423 
    *data = 1ULL;
    #line 1424 
    return (_Bool)1;
  }
  #line 1426 
  pat = 0U;
  #line 1426 
  while (pat <= 3U) {
    #line 1427 
    before = ixgbe_read_reg(& adapter->hw,(unsigned int)reg);
    #line 1428 
    ixgbe_write_reg_6(& adapter->hw,(unsigned int)reg,test_pattern[pat] & write);
    #line 1429 
    val = ixgbe_read_reg(& adapter->hw,(unsigned int)reg);
    #line 1430 
    if (((test_pattern[pat] & write) & mask) != val) {
      #line 1431 
      if (((int)adapter->msg_enable & 1) != 0) 
                                               #line 1431 
                                               netdev_err(adapter->netdev,(char *)"pattern test reg %04X failed: got 0x%08X expected 0x%08X\n",reg,val,(test_pattern[pat] & write) & mask);
      #line 1433 
      *data = (unsigned long long)reg;
      #line 1434 
      ixgbe_write_reg_6(& adapter->hw,(unsigned int)reg,before);
      #line 1435 
      return (_Bool)1;
    }
    #line 1437 
    ixgbe_write_reg_6(& adapter->hw,(unsigned int)reg,before);
    #line 1426 
    pat ++;
  }
  #line 1439 
  return (_Bool)0;
}

#line 1442  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static bool reg_set_and_check(struct ixgbe_adapter *adapter, u64 *data, int reg, u32 mask, u32 write)
{
  #line 1445 
  u32 val;
  #line 1445 
  u32 before;
  #line 1447 
  if ((int)ixgbe_removed((void *)adapter->hw.hw_addr) != 0) {
    #line 1448 
    *data = 1ULL;
    #line 1449 
    return (_Bool)1;
  }
  #line 1451 
  before = ixgbe_read_reg(& adapter->hw,(unsigned int)reg);
  #line 1452 
  ixgbe_write_reg_6(& adapter->hw,(unsigned int)reg,write & mask);
  #line 1453 
  val = ixgbe_read_reg(& adapter->hw,(unsigned int)reg);
  #line 1454 
  if (((write ^ val) & mask) != 0U) {
    #line 1455 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 1455 
                                             netdev_err(adapter->netdev,(char *)"set/check reg %04X test failed: got 0x%08X expected 0x%08X\n",reg,val & mask,write & mask);
    #line 1457 
    *data = (unsigned long long)reg;
    #line 1458 
    ixgbe_write_reg_6(& adapter->hw,(unsigned int)reg,before);
    #line 1459 
    return (_Bool)1;
  }
  #line 1461 
  ixgbe_write_reg_6(& adapter->hw,(unsigned int)reg,before);
  #line 1462 
  return (_Bool)0;
}

#line 1465  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_reg_test(struct ixgbe_adapter *adapter, u64 *data)
{
  #line 1467 
  struct ixgbe_reg_test *test;
  #line 1468 
  u32 value;
  #line 1468 
  u32 before;
  #line 1468 
  u32 after;
  #line 1469 
  u32 i;
  #line 1469 
  u32 toggle;
  #line 1471 
  if ((int)ixgbe_removed((void *)adapter->hw.hw_addr) != 0) {
    #line 1472 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 1472 
                                             netdev_err(adapter->netdev,(char *)"Adapter removed - register test blocked\n");
    #line 1473 
    *data = 1ULL;
    #line 1474 
    return 1;
  }
  #line 1476 
  switch ((unsigned int)adapter->hw.mac.type) {
    #line 1477 
    case (unsigned int)1: 
                          #line 1477 
    ;
    #line 1478 
    toggle = 2147480575U;
    #line 1479 
    test = (struct ixgbe_reg_test *)(& reg_test_82598);
    #line 1480 
    break;
    #line 1481 
    case (unsigned int)2: 
                          #line 1481 
    ;
    #line 1482 
    case (unsigned int)3: 
                          #line 1482 
    ;
    #line 1483 
    case (unsigned int)4: 
                          #line 1483 
    ;
    #line 1484 
    case (unsigned int)5: 
                          #line 1484 
    ;
    #line 1485 
    case (unsigned int)6: 
                          #line 1485 
    ;
    #line 1486 
    toggle = 2147480335U;
    #line 1487 
    test = (struct ixgbe_reg_test *)(& reg_test_82599);
    #line 1488 
    break;
    #line 1489 
    default: 
             #line 1489 
    ;
    #line 1490 
    *data = 1ULL;
    #line 1491 
    return 1;
  }
  #line 1500 
  before = ixgbe_read_reg(& adapter->hw,8U);
  #line 1501 
  value = ixgbe_read_reg(& adapter->hw,8U) & toggle;
  #line 1502 
  ixgbe_write_reg_6(& adapter->hw,8U,toggle);
  #line 1503 
  after = ixgbe_read_reg(& adapter->hw,8U) & toggle;
  #line 1504 
  if (value != after) {
    #line 1505 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 1505 
                                             netdev_err(adapter->netdev,(char *)"failed STATUS register test got: 0x%08X expected: 0x%08X\n",after,value);
    #line 1507 
    *data = 1ULL;
    #line 1508 
    return 1;
  }
  #line 1511 
  ixgbe_write_reg_6(& adapter->hw,8U,before);
  #line 1517 
  while ((unsigned int)test->reg != 0U) {
    #line 1518 
    i = 0U;
    #line 1518 
    while ((unsigned int)test->array_len > i) {
      {
        #line 1519 
        bool b = (_Bool)0;
        #line 1521 
        switch ((int)test->test_type) {
          #line 1522 
          case 1: 
                  #line 1522 
          ;
          #line 1523 
          b = reg_pattern_test(adapter,data,(int)((unsigned int)test->reg + i * 64U),test->mask,test->write);
          #line 1527 
          break;
          #line 1528 
          case 2: 
                  #line 1528 
          ;
          #line 1529 
          b = reg_set_and_check(adapter,data,(int)((unsigned int)test->reg + i * 64U),test->mask,test->write);
          #line 1533 
          break;
          #line 1534 
          case 3: 
                  #line 1534 
          ;
          #line 1535 
          ixgbe_write_reg_6(& adapter->hw,(unsigned int)test->reg + i * 64U,test->write);
          #line 1538 
          break;
          #line 1539 
          case 4: 
                  #line 1539 
          ;
          #line 1540 
          b = reg_pattern_test(adapter,data,(int)((unsigned int)test->reg + i * 4U),test->mask,test->write);
          #line 1544 
          break;
          #line 1545 
          case 5: 
                  #line 1545 
          ;
          #line 1546 
          b = reg_pattern_test(adapter,data,(int)((unsigned int)test->reg + i * 8U),test->mask,test->write);
          #line 1550 
          break;
          #line 1551 
          case 6: 
                  #line 1551 
          ;
          #line 1552 
          b = reg_pattern_test(adapter,data,(int)(((unsigned int)test->reg + i * 8U) + 4U),test->mask,test->write);
          #line 1556 
          break;
        }
        #line 1558 
        if ((int)b != 0) 
                         #line 1559 
                         return 1;
      }
      #line 1518 
      i ++;
    }
    #line 1561 
    test ++;
  }
  #line 1564 
  *data = 0ULL;
  #line 1565 
  return 0;
}

#line 1568  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_eeprom_test(struct ixgbe_adapter *adapter, u64 *data)
{
  #line 1570 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 1571 
  if ((*(hw->eeprom.ops.validate_checksum))(hw,(u16 *)0U) != 0) 
                                                                #line 1572 
                                                                *data = 1ULL; else 
                                                                    #line 1574 
                                                                    *data = 0ULL;
  #line 1575 
  return (int)*data;
}

#line 1578  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static irqreturn_t ixgbe_test_intr(int irq, void *data)
{
  #line 1580 
  struct net_device *netdev = (struct net_device *)data;
  #line 1581 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 1583 
  adapter->test_icr |= ixgbe_read_reg(& adapter->hw,2048U);
  #line 1585 
  return IRQ_HANDLED;
}

#line 1588  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_intr_test(struct ixgbe_adapter *adapter, u64 *data)
{
  #line 1591 
  u32 mask;
  #line 1590 
  struct net_device *netdev = adapter->netdev;
  #line 1591 
  u32 i = 0U;
  #line 1591 
  u32 shared_int = 1U;
  #line 1592 
  u32 irq = (adapter->pdev)->irq;
  #line 1594 
  *data = 0ULL;
  #line 1597 
  if (adapter->msix_entries != (struct msix_entry *)0) 
                                                       #line 1599 
                                                       return 0;
  else 
    #line 1600 
    if (((unsigned long)adapter->flags & 2UL) != 0UL) {
      #line 1601 
      shared_int = 0U;
      #line 1602 
      if (cif_request_irq_0(irq,& ixgbe_test_intr,0UL,(char *)(& netdev->name),
                        (void *)netdev) != 0) {
        #line 1604 
        *data = 1ULL;
        #line 1605 
        return -1;
      }
    }
    else {
      #line 1607 
      if (cif_request_irq_0(irq,& ixgbe_test_intr,256UL,
                          (char *)(& netdev->name),(void *)netdev) == 0) 
        #line 1609 
        shared_int = 0U;
      else {
        #line 1610 
        if (cif_request_irq_0(irq,& ixgbe_test_intr,128UL,
                          (char *)(& netdev->name),(void *)netdev) != 0) {
          #line 1612 
          *data = 1ULL;
          #line 1613 
          return -1;
        }
      }
    }
  #line 1615 
  if (((int)adapter->msg_enable & 8192) != 0) {
    #line 1615 
    char *tmp_2;
    #line 1615 
    if (shared_int != 0U) 
                          #line 1615 
                          tmp_2 = (char *)"shared"; else 
                                                         #line 1615 
                                                         tmp_2 = (char *)"unshared";
    #line 1615 
    ;
    #line 1615 
    netdev_info(adapter->netdev,(char *)"testing %s interrupt\n",tmp_2);
  }
  #line 1619 
  ixgbe_write_reg_6(& adapter->hw,2184U,4294967295U);
  #line 1620 
  ixgbe_read_reg(& adapter->hw,8U);
  #line 1621 
  usleep_range(10000UL,20000UL);
  #line 1624 
  while (i <= 9U) {
    #line 1626 
    mask = (unsigned int)(1UL << i);
    #line 1628 
    if (shared_int == 0U) {
      #line 1636 
      adapter->test_icr = 0U;
      #line 1637 
      ixgbe_write_reg_6(& adapter->hw,2184U,~ mask & 32767U);
      #line 1639 
      ixgbe_write_reg_6(& adapter->hw,2056U,~ mask & 32767U);
      #line 1641 
      ixgbe_read_reg(& adapter->hw,8U);
      #line 1642 
      usleep_range(10000UL,20000UL);
      #line 1644 
      if ((adapter->test_icr & mask) != 0U) {
        #line 1645 
        *data = 3ULL;
        #line 1646 
        break;
      }
    }
    #line 1656 
    adapter->test_icr = 0U;
    #line 1657 
    ixgbe_write_reg_6(& adapter->hw,2176U,mask);
    #line 1658 
    ixgbe_write_reg_6(& adapter->hw,2056U,mask);
    #line 1659 
    ixgbe_read_reg(& adapter->hw,8U);
    #line 1660 
    usleep_range(10000UL,20000UL);
    #line 1662 
    if ((adapter->test_icr & mask) == 0U) {
      #line 1663 
      *data = 4ULL;
      #line 1664 
      break;
    }
    #line 1667 
    if (shared_int == 0U) {
      #line 1675 
      adapter->test_icr = 0U;
      #line 1676 
      ixgbe_write_reg_6(& adapter->hw,2184U,~ mask & 32767U);
      #line 1678 
      ixgbe_write_reg_6(& adapter->hw,2056U,~ mask & 32767U);
      #line 1680 
      ixgbe_read_reg(& adapter->hw,8U);
      #line 1681 
      usleep_range(10000UL,20000UL);
      #line 1683 
      if (adapter->test_icr != 0U) {
        #line 1684 
        *data = 5ULL;
        #line 1685 
        break;
      }
    }
    #line 1624 
    i ++;
  }
  #line 1691 
  ixgbe_write_reg_6(& adapter->hw,2184U,4294967295U);
  #line 1692 
  ixgbe_read_reg(& adapter->hw,8U);
  #line 1693 
  usleep_range(10000UL,20000UL);
  #line 1696 
  cif_free_irq_0(irq,(void *)netdev);
  #line 1698 
  return (int)*data;
}

#line 1701  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_free_desc_rings(struct ixgbe_adapter *adapter)
{
  #line 1710 
  ixgbe_disable_rx(adapter);
  #line 1713 
  ixgbe_disable_tx(adapter);
  #line 1715 
  ixgbe_reset(adapter);
  #line 1717 
  ixgbe_free_tx_resources(& adapter->test_tx_ring);
  #line 1718 
  ixgbe_free_rx_resources(& adapter->test_rx_ring);
  #line 1719 
  return;
}

#line 1721  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_setup_desc_rings(struct ixgbe_adapter *adapter)
{
  #line 1726 
  u32 rctl;
  #line 1726 
  u32 reg_data;
  #line 1727 
  int ret_val;
  #line 1728 
  int err;
  #line 1723 
  struct ixgbe_ring *tx_ring = & adapter->test_tx_ring;
  #line 1724 
  struct ixgbe_ring *rx_ring = & adapter->test_rx_ring;
  #line 1725 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 1731 
  tx_ring->count = (unsigned short)512U;
  #line 1732 
  tx_ring->queue_index = (unsigned char)0U;
  #line 1733 
  tx_ring->dev = & (adapter->pdev)->dev;
  #line 1734 
  tx_ring->netdev = adapter->netdev;
  #line 1735 
  tx_ring->reg_idx = (adapter->tx_ring[0])->reg_idx;
  #line 1737 
  err = ixgbe_setup_tx_resources(tx_ring);
  #line 1738 
  if (err != 0) 
                #line 1739 
                return 1;
  #line 1741 
  switch ((unsigned int)adapter->hw.mac.type) {
    #line 1742 
    case (unsigned int)2: 
                          #line 1742 
    ;
    #line 1743 
    case (unsigned int)3: 
                          #line 1743 
    ;
    #line 1744 
    case (unsigned int)4: 
                          #line 1744 
    ;
    #line 1745 
    case (unsigned int)5: 
                          #line 1745 
    ;
    #line 1746 
    case (unsigned int)6: 
                          #line 1746 
    ;
    #line 1747 
    reg_data = ixgbe_read_reg(& adapter->hw,19072U);
    #line 1748 
    reg_data |= 1U;
    #line 1749 
    ixgbe_write_reg_6(& adapter->hw,19072U,reg_data);
    #line 1750 
    break;
    #line 1751 
    default: 
             #line 1751 
    ;
    #line 1752 
    break;
  }
  #line 1755 
  ixgbe_configure_tx_ring(adapter,tx_ring);
  #line 1758 
  rx_ring->count = (unsigned short)512U;
  #line 1759 
  rx_ring->queue_index = (unsigned char)0U;
  #line 1760 
  rx_ring->dev = & (adapter->pdev)->dev;
  #line 1761 
  rx_ring->netdev = adapter->netdev;
  #line 1762 
  rx_ring->reg_idx = (adapter->rx_ring[0])->reg_idx;
  #line 1764 
  err = ixgbe_setup_rx_resources(adapter,rx_ring);
  #line 1765 
  if (err != 0) {
    #line 1766 
    ret_val = 4;
    #line 1767 
    goto err_nomem;
  }
  #line 1770 
  (*(hw->mac.ops.disable_rx))(hw);
  #line 1772 
  ixgbe_configure_rx_ring(adapter,rx_ring);
  #line 1774 
  rctl = ixgbe_read_reg(& adapter->hw,12288U);
  #line 1775 
  rctl |= 2U;
  #line 1776 
  ixgbe_write_reg_6(& adapter->hw,12288U,rctl);
  #line 1778 
  (*(hw->mac.ops.enable_rx))(hw);
  #line 1780 
  return 0;
  #line 1782 
  err_nomem: 
             #line 1782 
  ;
  #line 1783 
  ixgbe_free_desc_rings(adapter);
  #line 1784 
  return ret_val;
}

#line 1787  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_setup_loopback_test(struct ixgbe_adapter *adapter)
{
  #line 1790 
  u32 reg_data;
  #line 1789 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 1794 
  reg_data = ixgbe_read_reg(hw,16960U);
  #line 1795 
  reg_data |= 32768U;
  #line 1796 
  ixgbe_write_reg_6(hw,16960U,reg_data);
  #line 1798 
  reg_data = ixgbe_read_reg(hw,20608U);
  #line 1799 
  reg_data |= 1282U;
  #line 1800 
  ixgbe_write_reg_6(hw,20608U,reg_data);
  #line 1803 
  switch ((unsigned int)adapter->hw.mac.type) {
    #line 1804 
    case (unsigned int)3: 
                          #line 1804 
    ;
    #line 1805 
    case (unsigned int)4: 
                          #line 1805 
    ;
    #line 1806 
    case (unsigned int)5: 
                          #line 1806 
    ;
    #line 1807 
    case (unsigned int)6: 
                          #line 1807 
    ;
    #line 1808 
    reg_data = ixgbe_read_reg(hw,17200U);
    #line 1809 
    reg_data |= 1U;
    #line 1810 
    ixgbe_write_reg_6(hw,17200U,reg_data);
    #line 1811 
    break;
    #line 1812 
    default: 
             #line 1812 
    ;
    #line 1813 
    if (hw->mac.orig_autoc != 0U) {
      #line 1814 
      reg_data = hw->mac.orig_autoc | 1U;
      #line 1815 
      ixgbe_write_reg_6(hw,17056U,reg_data);
    }
    else 
         #line 1817 
         return 10;
  }
  #line 1820 
  ixgbe_read_reg(hw,8U);
  #line 1821 
  usleep_range(10000UL,20000UL);
  #line 1824 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) {
    #line 1825 
    u8 atlas;
    #line 1827 
    (*(hw->mac.ops.read_analog_reg8))(hw,36U,& atlas);
    #line 1828 
    atlas = (unsigned char)((unsigned int)atlas | 16U);
    #line 1829 
    (*(hw->mac.ops.write_analog_reg8))(hw,36U,(unsigned char)((int)atlas));
    #line 1831 
    (*(hw->mac.ops.read_analog_reg8))(hw,11U,& atlas);
    #line 1832 
    atlas = (unsigned char)((unsigned int)atlas | 240U);
    #line 1833 
    (*(hw->mac.ops.write_analog_reg8))(hw,11U,(unsigned char)((int)atlas));
    #line 1835 
    (*(hw->mac.ops.read_analog_reg8))(hw,12U,& atlas);
    #line 1836 
    atlas = (unsigned char)((unsigned int)atlas | 240U);
    #line 1837 
    (*(hw->mac.ops.write_analog_reg8))(hw,12U,(unsigned char)((int)atlas));
    #line 1839 
    (*(hw->mac.ops.read_analog_reg8))(hw,13U,& atlas);
    #line 1840 
    atlas = (unsigned char)((unsigned int)atlas | 240U);
    #line 1841 
    (*(hw->mac.ops.write_analog_reg8))(hw,13U,(unsigned char)((int)atlas));
  }
  #line 1844 
  return 0;
}

#line 1847  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_loopback_cleanup(struct ixgbe_adapter *adapter)
{
  #line 1849 
  u32 reg_data;
  #line 1851 
  reg_data = ixgbe_read_reg(& adapter->hw,16960U);
  #line 1852 
  reg_data &= 4294934527U;
  #line 1853 
  ixgbe_write_reg_6(& adapter->hw,16960U,reg_data);
  #line 1854 
  return;
}

#line 1856  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_create_lbtest_frame(struct sk_buff *skb, unsigned int frame_size)
{
  #line 1859 
  memset((void *)skb->data,255,(unsigned long)frame_size);
  #line 1860 
  frame_size >>= 1;
  #line 1861 
  memset((void *)(skb->data + (unsigned long)frame_size),170,(unsigned long)(frame_size / 2U + 4294967295U));
  #line 1862 
  memset((void *)(skb->data + (unsigned long)(frame_size + 10U)),190,1UL);
  #line 1863 
  memset((void *)(skb->data + (unsigned long)(frame_size + 12U)),175,1UL);
  #line 1864 
  return;
}

#line 1866  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static bool ixgbe_check_lbtest_frame(struct ixgbe_rx_buffer *rx_buffer, unsigned int frame_size)
{
  #line 1869 
  unsigned char *data;
  #line 1870 
  bool match = (_Bool)1;
  #line 1872 
  frame_size >>= 1;
  #line 1874 
  data = (unsigned char *)(kmap(rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page) + (unsigned long)rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page_offset);
  #line 1876 
  if (((unsigned int)*(data + 3U) != 255U || (unsigned int)*(data + (unsigned long)(frame_size + 10U)) != 190U) || (unsigned int)*(data + (unsigned long)(frame_size + 12U)) != 175U) 
    #line 1879 
    match = (_Bool)0;
  #line 1881 
  kunmap(rx_buffer->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page);
  #line 1883 
  return match;
}

#line 1886  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static u16 ixgbe_clean_test_rings(struct ixgbe_ring *rx_ring, struct ixgbe_ring *tx_ring, unsigned int size)
{
  #line 1890 
  union ixgbe_adv_rx_desc *rx_desc;
  #line 1891 
  u16 rx_ntc;
  #line 1891 
  u16 tx_ntc;
  #line 1891 
  u16 count = (unsigned short)0U;
  #line 1894 
  rx_ntc = rx_ring->next_to_clean;
  #line 1895 
  tx_ntc = tx_ring->next_to_clean;
  #line 1896 
  rx_desc = (union ixgbe_adv_rx_desc *)rx_ring->desc + (unsigned long)rx_ntc;
  #line 1898 
  while ((int)tx_ring->next_to_use != (int)tx_ntc) {
    #line 1899 
    union ixgbe_adv_tx_desc *tx_desc;
    #line 1900 
    struct ixgbe_tx_buffer *tx_buffer;
    #line 1902 
    tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc + (unsigned long)tx_ntc;
    #line 1905 
    if ((tx_desc->wb.status & 1U) == 0U) 
                                         #line 1906 
                                         return count;
    #line 1909 
    tx_buffer = tx_ring->__anonCompField_ixgbe_ring_221.tx_buffer_info + (unsigned long)tx_ntc;
    #line 1912 
    dev_kfree_skb_any(tx_buffer->__anonCompField_ixgbe_tx_buffer_217.skb);
    #line 1915 
    dma_unmap_single_attrs(tx_ring->dev,tx_buffer->dma,(unsigned long)tx_buffer->len,(enum dma_data_direction)DMA_TO_DEVICE,0UL);
    #line 1919 
    tx_buffer->len = 0U;
    #line 1922 
    tx_ntc = (u16)((int)tx_ntc + 1);
    #line 1923 
    if ((int)tx_ring->count == (int)tx_ntc) 
                                            #line 1924 
                                            tx_ntc = (unsigned short)0U;
  }
  #line 1927 
  while ((unsigned int)rx_desc->wb.upper.length != 0U) {
    #line 1928 
    struct ixgbe_rx_buffer *rx_buffer;
    #line 1931 
    rx_buffer = rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info + (unsigned long)rx_ntc;
    #line 1934 
    ;
    #line 1934 
    ;
    #line 1934 
    dma_sync_single_for_cpu(rx_ring->dev,rx_buffer->dma,(unsigned long)ixgbe_rx_bufsz(rx_ring),(enum dma_data_direction)DMA_FROM_DEVICE);
    #line 1940 
    if ((int)ixgbe_check_lbtest_frame(rx_buffer,size) != 0) 
                                                            #line 1941 
                                                            count = (u16)((int)count + 1); else 
                                                                    #line 1943 
                                                                    break;
    #line 1946 
    ;
    #line 1946 
    ;
    #line 1946 
    dma_sync_single_for_device(rx_ring->dev,rx_buffer->dma,(unsigned long)ixgbe_rx_bufsz(rx_ring),(enum dma_data_direction)DMA_FROM_DEVICE);
    #line 1952 
    rx_ntc = (u16)((int)rx_ntc + 1);
    #line 1953 
    if ((int)rx_ring->count == (int)rx_ntc) 
                                            #line 1954 
                                            rx_ntc = (unsigned short)0U;
    #line 1957 
    rx_desc = (union ixgbe_adv_rx_desc *)rx_ring->desc + (unsigned long)rx_ntc;
  }
  #line 1960 
  netdev_tx_reset_queue_0(txring_txq(tx_ring));
  #line 1963 
  ixgbe_alloc_rx_buffers(rx_ring,(unsigned short)((int)count));
  #line 1964 
  rx_ring->next_to_clean = rx_ntc;
  #line 1965 
  tx_ring->next_to_clean = tx_ntc;
  #line 1967 
  return count;
}

#line 1970  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_run_loopback_test(struct ixgbe_adapter *adapter)
{
  #line 1974 
  int i;
  #line 1974 
  int j;
  #line 1974 
  int lc;
  #line 1974 
  int good_cnt;
  #line 1976 
  netdev_tx_t tx_ret_val;
  #line 1977 
  struct sk_buff *skb;
  #line 1972 
  struct ixgbe_ring *tx_ring = & adapter->test_tx_ring;
  #line 1973 
  struct ixgbe_ring *rx_ring = & adapter->test_rx_ring;
  #line 1974 
  int ret_val = 0;
  #line 1975 
  unsigned int size = 1024U;
  #line 1978 
  u32 flags_orig = adapter->flags;
  #line 1981 
  adapter->flags &= 4294963199U;
  #line 1984 
  skb = alloc_skb(size,3264U);
  #line 1985 
  if (skb == (struct sk_buff *)0) 
                                  #line 1986 
                                  return 11;
  #line 1989 
  ixgbe_create_lbtest_frame(skb,size);
  #line 1990 
  skb_put(skb,size);
  #line 1998 
  if ((int)rx_ring->count <= (int)tx_ring->count) 
                                                  #line 1999 
                                                  lc = (int)((unsigned int)tx_ring->count / 64U) * 2 + 1; else 
                                                                    #line 2001 
                                                                    lc = (int)((unsigned int)rx_ring->count / 64U) * 2 + 1;
  #line 2003 
  j = 0;
  #line 2003 
  while (j <= lc) {
    {
      #line 2005 
      good_cnt = 0;
      #line 2008 
      i = 0;
      #line 2008 
      while (i <= 63) {
        #line 2009 
        skb_get(skb);
        #line 2010 
        tx_ret_val = ixgbe_xmit_frame_ring(skb,adapter,tx_ring);
        #line 2013 
        if (tx_ret_val == (unsigned int)NETDEV_TX_OK) 
                                                      #line 2014 
                                                      good_cnt ++;
        #line 2008 
        i ++;
      }
      #line 2017 
      if (good_cnt != 64) {
        #line 2018 
        ret_val = 12;
        #line 2019 
        break;
      }
      #line 2023 
      msleep(200U);
      #line 2025 
      good_cnt = (int)ixgbe_clean_test_rings(rx_ring,tx_ring,size);
      #line 2026 
      if (good_cnt != 64) {
        #line 2027 
        ret_val = 13;
        #line 2028 
        break;
      }
    }
    #line 2003 
    j ++;
  }
  #line 2033 
  kfree_skb(skb);
  #line 2034 
  adapter->flags = flags_orig;
  #line 2036 
  return ret_val;
}

#line 2039  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_loopback_test(struct ixgbe_adapter *adapter, u64 *data)
{
  #line 2041 
  *data = (unsigned long long)ixgbe_setup_desc_rings(adapter);
  #line 2042 
  if (*data != 0ULL) 
                     #line 2043 
                     goto out;
  #line 2044 
  *data = (unsigned long long)ixgbe_setup_loopback_test(adapter);
  #line 2045 
  if (*data != 0ULL) 
                     #line 2046 
                     goto err_loopback;
  #line 2047 
  *data = (unsigned long long)ixgbe_run_loopback_test(adapter);
  #line 2048 
  ixgbe_loopback_cleanup(adapter);
  #line 2050 
  err_loopback: 
                #line 2050 
  ;
  #line 2051 
  ixgbe_free_desc_rings(adapter);
  #line 2052 
  out: 
       #line 2052 
  ;
  #line 2053 
  return (int)*data;
}

#line 2056  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_diag_test(struct net_device *netdev, struct ethtool_test *eth_test, u64 *data)
{
  #line 2059 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 2060 
  bool if_running = netif_running(netdev);
  #line 2062 
  if ((int)ixgbe_removed((void *)adapter->hw.hw_addr) != 0) {
    #line 2063 
    if (((int)adapter->msg_enable & 8192) != 0) 
                                                #line 2063 
                                                netdev_err(adapter->netdev,(char *)"Adapter removed - test blocked\n");
    #line 2064 
    *data = 1ULL;
    #line 2065 
    *(data + 1U) = 1ULL;
    #line 2066 
    *(data + 2U) = 1ULL;
    #line 2067 
    *(data + 3U) = 1ULL;
    #line 2068 
    *(data + 4U) = 1ULL;
    #line 2069 
    eth_test->flags |= 2U;
    #line 2070 
    return;
  }
  #line 2072 
  cif_set_bit_3(0L,& adapter->state);
  #line 2073 
  if (eth_test->flags == 1U) {
    #line 2074 
    struct ixgbe_hw *hw = & adapter->hw;
    #line 2076 
    if (((unsigned long)adapter->flags & 8388608UL) != 0UL) {
      #line 2077 
      int i;
      #line 2078 
      i = 0;
      #line 2078 
      while (adapter->num_vfs > (unsigned int)i) {
        #line 2079 
        if ((int)(adapter->vfinfo + (unsigned long)i)->clear_to_send != 0) {
          #line 2080 
          netdev_warn(netdev,(char *)"offline diagnostic is not supported when VFs are present\n");
          #line 2081 
          *data = 1ULL;
          #line 2082 
          *(data + 1U) = 1ULL;
          #line 2083 
          *(data + 2U) = 1ULL;
          #line 2084 
          *(data + 3U) = 1ULL;
          #line 2085 
          *(data + 4U) = 1ULL;
          #line 2086 
          eth_test->flags |= 2U;
          #line 2087 
          cif_clear_bit_0(0L,& adapter->state);
          #line 2089 
          goto skip_ol_tests;
        }
        #line 2078 
        i ++;
      }
    }
    #line 2095 
    if (((int)adapter->msg_enable & 8192) != 0) 
                                                #line 2095 
                                                netdev_info(adapter->netdev,(char *)"offline testing starting\n");
    #line 2100 
    if (ixgbe_link_test(adapter,data + 4U) != 0) 
                                                 #line 2101 
                                                 eth_test->flags |= 2U;
    #line 2103 
    if ((int)if_running != 0) 
                              #line 2105 
                              ixgbe_close(netdev); else 
                                                        #line 2107 
                                                        ixgbe_reset(adapter);
    #line 2109 
    if (((int)adapter->msg_enable & 8192) != 0) 
                                                #line 2109 
                                                netdev_info(adapter->netdev,(char *)"register testing starting\n");
    #line 2110 
    if (ixgbe_reg_test(adapter,data) != 0) 
                                           #line 2111 
                                           eth_test->flags |= 2U;
    #line 2113 
    ixgbe_reset(adapter);
    #line 2114 
    if (((int)adapter->msg_enable & 8192) != 0) 
                                                #line 2114 
                                                netdev_info(adapter->netdev,(char *)"eeprom testing starting\n");
    #line 2115 
    if (ixgbe_eeprom_test(adapter,data + 1U) != 0) 
                                                   #line 2116 
                                                   eth_test->flags |= 2U;
    #line 2118 
    ixgbe_reset(adapter);
    #line 2119 
    if (((int)adapter->msg_enable & 8192) != 0) 
                                                #line 2119 
                                                netdev_info(adapter->netdev,(char *)"interrupt testing starting\n");
    #line 2120 
    if (ixgbe_intr_test(adapter,data + 2U) != 0) 
                                                 #line 2121 
                                                 eth_test->flags |= 2U;
    #line 2125 
    if (((unsigned long)adapter->flags & 8404992UL) != 0UL) {
      #line 2127 
      if (((int)adapter->msg_enable & 8192) != 0) 
                                                  #line 2127 
                                                  netdev_info(adapter->netdev,(char *)"Skip MAC loopback diagnostic in VT mode\n");
      #line 2128 
      *(data + 3U) = 0ULL;
      #line 2129 
      goto skip_loopback;
    }
    #line 2132 
    ixgbe_reset(adapter);
    #line 2133 
    if (((int)adapter->msg_enable & 8192) != 0) 
                                                #line 2133 
                                                netdev_info(adapter->netdev,(char *)"loopback testing starting\n");
    #line 2134 
    if (ixgbe_loopback_test(adapter,data + 3U) != 0) 
                                                     #line 2135 
                                                     eth_test->flags |= 2U;
    #line 2137 
    skip_loopback: 
                   #line 2137 
    ;
    #line 2138 
    ixgbe_reset(adapter);
    #line 2141 
    cif_clear_bit_0(0L,& adapter->state);
    #line 2142 
    if ((int)if_running != 0) 
                              #line 2143 
                              ixgbe_open(netdev);
    else 
      #line 2144 
      if (hw->mac.ops.disable_tx_laser != (void (*)(struct ixgbe_hw *))0) 
        #line 2145 
        (*(hw->mac.ops.disable_tx_laser))(hw);
  }
  else {
    #line 2147 
    if (((int)adapter->msg_enable & 8192) != 0) 
                                                #line 2147 
                                                netdev_info(adapter->netdev,(char *)"online testing starting\n");
    #line 2150 
    if (ixgbe_link_test(adapter,data + 4U) != 0) 
                                                 #line 2151 
                                                 eth_test->flags |= 2U;
    #line 2154 
    *data = 0ULL;
    #line 2155 
    *(data + 1U) = 0ULL;
    #line 2156 
    *(data + 2U) = 0ULL;
    #line 2157 
    *(data + 3U) = 0ULL;
    #line 2159 
    cif_clear_bit_0(0L,& adapter->state);
  }
  #line 2162 
  skip_ol_tests: 
                 #line 2162 
  ;
  #line 2163 
  msleep_interruptible(4000U);
  #line 2164 
  return;
}

#line 2166  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_wol_exclusion(struct ixgbe_adapter *adapter, struct ethtool_wolinfo *wol)
{
  #line 2169 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 2170 
  int retval = 0;
  #line 2173 
  if (! ixgbe_wol_supported(adapter,(unsigned short)((int)hw->device_id),
                          (unsigned short)((int)hw->subsystem_device_id))) {
    #line 2175 
    retval = 1;
    #line 2176 
    wol->supported = 0U;
  }
  #line 2179 
  return retval;
}

#line 2182  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)
{
  #line 2185 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 2187 
  wol->supported = 46U;
  #line 2189 
  wol->wolopts = 0U;
  #line 2191 
  if (ixgbe_wol_exclusion(adapter,wol) != 0) 
                                             #line 2193 
                                             return;
  else {
    #line 2192 
    if (! device_can_wakeup(& (adapter->pdev)->dev)) 
                                                     #line 2193 
                                                     return;
  }
  #line 2195 
  if ((adapter->wol & 4U) != 0U) 
                                 #line 2196 
                                 wol->wolopts |= 2U;
  #line 2197 
  if ((adapter->wol & 8U) != 0U) 
                                 #line 2198 
                                 wol->wolopts |= 4U;
  #line 2199 
  if ((adapter->wol & 16U) != 0U) 
                                  #line 2200 
                                  wol->wolopts |= 8U;
  #line 2201 
  if ((adapter->wol & 2U) != 0U) 
                                 #line 2202 
                                 wol->wolopts |= 32U;
  #line 2203 
  return;
}

#line 2205  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)
{
  #line 2207 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 2209 
  if ((wol->wolopts & 209U) != 0U) 
                                   #line 2211 
                                   return -95;
  #line 2213 
  if (ixgbe_wol_exclusion(adapter,wol) != 0) {
    #line 2214 
    int tmp_0;
    #line 2214 
    if (wol->wolopts != 0U) 
                            #line 2214 
                            tmp_0 = -95; else 
                                              #line 2214 
                                              tmp_0 = 0;
    #line 2214 
    return tmp_0;
  }
  #line 2216 
  adapter->wol = 0U;
  #line 2218 
  if ((wol->wolopts & 2U) != 0U) 
                                 #line 2219 
                                 adapter->wol |= 4U;
  #line 2220 
  if ((wol->wolopts & 4U) != 0U) 
                                 #line 2221 
                                 adapter->wol |= 8U;
  #line 2222 
  if ((wol->wolopts & 8U) != 0U) 
                                 #line 2223 
                                 adapter->wol |= 16U;
  #line 2224 
  if ((wol->wolopts & 32U) != 0U) 
                                  #line 2225 
                                  adapter->wol |= 2U;
  #line 2227 
  device_set_wakeup_enable(& (adapter->pdev)->dev,(_Bool)(adapter->wol != 0U));
  #line 2229 
  return 0;
}

#line 2232  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_nway_reset(struct net_device *netdev)
{
  #line 2234 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 2236 
  if ((int)netif_running(netdev) != 0) 
                                       #line 2237 
                                       ixgbe_reinit_locked(adapter);
  #line 2239 
  return 0;
}

#line 2242  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_phys_id(struct net_device *netdev, enum ethtool_phys_id_state state)
{
  #line 2245 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 2246 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 2248 
  if (hw->mac.ops.led_on == (s32 (*)(struct ixgbe_hw *, u32 ))0 || hw->mac.ops.led_off == (s32 (*)(struct ixgbe_hw *, u32 ))0) 
    #line 2249 
    return -95;
  #line 2251 
  switch ((unsigned int)state) {
    #line 2252 
    case (unsigned int)1: 
                          #line 2252 
    ;
    #line 2253 
    adapter->led_reg = ixgbe_read_reg(hw,512U);
    #line 2254 
    return 2;
    #line 2256 
    case (unsigned int)2: 
                          #line 2256 
    ;
    #line 2257 
    (*(hw->mac.ops.led_on))(hw,(unsigned int)hw->mac.led_link_act);
    #line 2258 
    break;
    #line 2260 
    case (unsigned int)3: 
                          #line 2260 
    ;
    #line 2261 
    (*(hw->mac.ops.led_off))(hw,(unsigned int)hw->mac.led_link_act);
    #line 2262 
    break;
    #line 2264 
    case (unsigned int)0: 
                          #line 2264 
    ;
    #line 2266 
    ixgbe_write_reg_6(& adapter->hw,512U,adapter->led_reg);
    #line 2267 
    break;
  }
  #line 2270 
  return 0;
}

#line 2273  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_coalesce(struct net_device *netdev, struct ethtool_coalesce *ec)
{
  #line 2276 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 2279 
  if ((unsigned int)adapter->rx_itr_setting <= 1U) 
                                                   #line 2280 
                                                   ec->rx_coalesce_usecs = (unsigned int)adapter->rx_itr_setting; else 
                                                                    #line 2282 
                                                                    ec->rx_coalesce_usecs = (unsigned int)((int)adapter->rx_itr_setting >> 2);
  #line 2285 
  if ((unsigned int)(adapter->q_vector[0])->tx.count != 0U && (unsigned int)(adapter->q_vector[0])->rx.count != 0U) 
    #line 2286 
    return 0;
  #line 2289 
  if ((unsigned int)adapter->tx_itr_setting <= 1U) 
                                                   #line 2290 
                                                   ec->tx_coalesce_usecs = (unsigned int)adapter->tx_itr_setting; else 
                                                                    #line 2292 
                                                                    ec->tx_coalesce_usecs = (unsigned int)((int)adapter->tx_itr_setting >> 2);
  #line 2294 
  return 0;
}

#line 2301  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static bool ixgbe_update_rsc(struct ixgbe_adapter *adapter)
{
  #line 2303 
  struct net_device *netdev = adapter->netdev;
  #line 2306 
  if (((unsigned long)adapter->flags2 & 1UL) == 0UL || (netdev->features & 32768ULL) == 0ULL) 
    #line 2308 
    return (_Bool)0;
  #line 2311 
  if ((unsigned int)adapter->rx_itr_setting == 1U || (unsigned int)adapter->rx_itr_setting > 24U) {
    #line 2313 
    if (((unsigned long)adapter->flags2 & 2UL) == 0UL) {
      #line 2314 
      adapter->flags2 |= 2U;
      #line 2315 
      if (((int)adapter->msg_enable & 2) != 0) 
                                               #line 2315 
                                               netdev_info(adapter->netdev,(char *)"rx-usecs value high enough to re-enable RSC\n");
      #line 2316 
      return (_Bool)1;
    }
  }
  else 
    #line 2319 
    if (((unsigned long)adapter->flags2 & 2UL) != 0UL) {
      #line 2320 
      adapter->flags2 &= 4294967293U;
      #line 2321 
      if (((int)adapter->msg_enable & 2) != 0) 
                                               #line 2321 
                                               netdev_info(adapter->netdev,(char *)"rx-usecs set too low, disabling RSC\n");
      #line 2322 
      return (_Bool)1;
    }
  #line 2324 
  return (_Bool)0;
}

#line 2327  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_coalesce(struct net_device *netdev, struct ethtool_coalesce *ec)
{
  #line 2331 
  struct ixgbe_q_vector *q_vector;
  #line 2332 
  int i;
  #line 2333 
  u16 tx_itr_param;
  #line 2333 
  u16 rx_itr_param;
  #line 2333 
  u16 tx_itr_prev;
  #line 2330 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 2334 
  bool need_reset = (_Bool)0;
  #line 2336 
  if ((unsigned int)(adapter->q_vector[0])->tx.count != 0U && (unsigned int)(adapter->q_vector[0])->rx.count != 0U) {
    #line 2338 
    if (ec->tx_coalesce_usecs != 0U) 
                                     #line 2339 
                                     return -22;
    #line 2340 
    tx_itr_prev = adapter->rx_itr_setting;
  }
  else 
       #line 2342 
       tx_itr_prev = adapter->tx_itr_setting;
  #line 2345 
  if (ec->rx_coalesce_usecs > 1022U || ec->tx_coalesce_usecs > 1022U) 
    #line 2347 
    return -22;
  #line 2349 
  if (ec->rx_coalesce_usecs > 1U) 
                                  #line 2350 
                                  adapter->rx_itr_setting = (unsigned short)((int)((unsigned short)ec->rx_coalesce_usecs) << 2U); else 
                                                                    #line 2352 
                                                                    adapter->rx_itr_setting = (unsigned short)ec->rx_coalesce_usecs;
  #line 2354 
  if ((unsigned int)adapter->rx_itr_setting == 1U) 
                                                   #line 2355 
                                                   rx_itr_param = (unsigned short)200U; else 
                                                                    #line 2357 
                                                                    rx_itr_param = adapter->rx_itr_setting;
  #line 2359 
  if (ec->tx_coalesce_usecs > 1U) 
                                  #line 2360 
                                  adapter->tx_itr_setting = (unsigned short)((int)((unsigned short)ec->tx_coalesce_usecs) << 2U); else 
                                                                    #line 2362 
                                                                    adapter->tx_itr_setting = (unsigned short)ec->tx_coalesce_usecs;
  #line 2364 
  if ((unsigned int)adapter->tx_itr_setting == 1U) 
                                                   #line 2365 
                                                   tx_itr_param = (unsigned short)336U; else 
                                                                    #line 2367 
                                                                    tx_itr_param = adapter->tx_itr_setting;
  #line 2370 
  if ((unsigned int)(adapter->q_vector[0])->tx.count != 0U && (unsigned int)(adapter->q_vector[0])->rx.count != 0U) 
    #line 2371 
    adapter->tx_itr_setting = adapter->rx_itr_setting;
  #line 2374 
  if ((unsigned int)adapter->tx_itr_setting != 1U && (unsigned int)adapter->tx_itr_setting <= 39U) {
    #line 2376 
    if ((unsigned int)tx_itr_prev == 1U || (unsigned int)tx_itr_prev > 39U) 
      #line 2378 
      need_reset = (_Bool)1;
  }
  else 
    #line 2380 
    if ((unsigned int)tx_itr_prev != 1U && (unsigned int)tx_itr_prev <= 39U) 
      #line 2382 
      need_reset = (_Bool)1;
  #line 2386 
  need_reset = (_Bool)(((int)ixgbe_update_rsc(adapter) | (int)need_reset) != 0);
  #line 2388 
  i = 0;
  #line 2388 
  while (adapter->num_q_vectors > i) {
    #line 2389 
    q_vector = adapter->q_vector[i];
    #line 2390 
    if ((unsigned int)q_vector->tx.count != 0U && (unsigned int)q_vector->rx.count == 0U) 
      #line 2392 
      q_vector->itr = tx_itr_param; else 
                                         #line 2395 
                                         q_vector->itr = rx_itr_param;
    #line 2396 
    ixgbe_write_eitr(q_vector);
    #line 2388 
    i ++;
  }
  #line 2404 
  if ((int)need_reset != 0) 
                            #line 2405 
                            ixgbe_do_reset(netdev);
  #line 2407 
  return 0;
}

#line 2410  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_ethtool_fdir_entry(struct ixgbe_adapter *adapter, struct ethtool_rxnfc *cmd)
{
  #line 2422 
  void *__mptr;
  #line 2422 
  struct ixgbe_fdir_filter *tmp_0;
  #line 2416 
  struct hlist_node *node2;
  #line 2413 
  union ixgbe_atr_input *mask = & adapter->fdir_mask;
  #line 2414 
  struct ethtool_rx_flow_spec *fsp = & cmd->fs;
  #line 2417 
  struct ixgbe_fdir_filter *rule = (struct ixgbe_fdir_filter *)0;
  #line 2420 
  cmd->data = (unsigned long long)((1024 << adapter->fdir_pballoc) + -2);
  {
    #line 2422 
    struct hlist_node *____ptr = adapter->fdir_filter_list.first;
    #line 2422 
    if (____ptr != (struct hlist_node *)0) {
      #line 2422 
      __mptr = (void *)____ptr;
      #line 2422 
      tmp_0 = ((struct ixgbe_fdir_filter *)__mptr);
    }
    else 
         #line 2422 
         tmp_0 = (struct ixgbe_fdir_filter *)0;
    }
  #line 2422 
  rule = tmp_0;
  #line 2422 
  while (1) {
    #line 2422 
    void *__mptr_0;
    #line 2422 
    struct ixgbe_fdir_filter *tmp_3;
    #line 2422 
    if (rule != (struct ixgbe_fdir_filter *)0) {
      #line 2422 
      node2 = rule->fdir_node.next;
      #line 2422 
      if (! (1 != 0)) 
                      #line 2422 
                      break;
    }
    else 
         #line 2422 
         break;
    #line 2424 
    if (fsp->location <= (unsigned int)rule->sw_idx) 
                                                     #line 2425 
                                                     break;
    {
      #line 2422 
      struct hlist_node *____ptr_0 = node2;
      #line 2422 
      if (____ptr_0 != (struct hlist_node *)0) {
        #line 2422 
        __mptr_0 = (void *)____ptr_0;
        #line 2422 
        tmp_3 = ((struct ixgbe_fdir_filter *)__mptr_0);
      }
      else 
           #line 2422 
           tmp_3 = (struct ixgbe_fdir_filter *)0;
      }
    #line 2422 
    rule = tmp_3;
  }
  #line 2428 
  if (rule == (struct ixgbe_fdir_filter *)0 || fsp->location != (unsigned int)rule->sw_idx) 
    #line 2429 
    return -22;
  #line 2434 
  switch ((int)rule->filter.formatted.flow_type) {
    #line 2435 
    case 2: 
            #line 2435 
    ;
    #line 2436 
    fsp->flow_type = 1U;
    #line 2437 
    break;
    #line 2438 
    case 1: 
            #line 2438 
    ;
    #line 2439 
    fsp->flow_type = 2U;
    #line 2440 
    break;
    #line 2441 
    case 3: 
            #line 2441 
    ;
    #line 2442 
    fsp->flow_type = 3U;
    #line 2443 
    break;
    #line 2444 
    case 0: 
            #line 2444 
    ;
    #line 2445 
    fsp->flow_type = 13U;
    #line 2446 
    fsp->h_u.usr_ip4_spec.ip_ver = (unsigned char)1U;
    #line 2447 
    fsp->h_u.usr_ip4_spec.proto = (unsigned char)0U;
    #line 2448 
    fsp->m_u.usr_ip4_spec.proto = (unsigned char)0U;
    #line 2449 
    break;
    #line 2450 
    default: 
             #line 2450 
    ;
    #line 2451 
    return -22;
  }
  #line 2454 
  fsp->h_u.tcp_ip4_spec.psrc = rule->filter.formatted.src_port;
  #line 2455 
  fsp->m_u.tcp_ip4_spec.psrc = mask->formatted.src_port;
  #line 2456 
  fsp->h_u.tcp_ip4_spec.pdst = rule->filter.formatted.dst_port;
  #line 2457 
  fsp->m_u.tcp_ip4_spec.pdst = mask->formatted.dst_port;
  #line 2458 
  fsp->h_u.tcp_ip4_spec.ip4src = rule->filter.formatted.src_ip[0];
  #line 2459 
  fsp->m_u.tcp_ip4_spec.ip4src = mask->formatted.src_ip[0];
  #line 2460 
  fsp->h_u.tcp_ip4_spec.ip4dst = rule->filter.formatted.dst_ip[0];
  #line 2461 
  fsp->m_u.tcp_ip4_spec.ip4dst = mask->formatted.dst_ip[0];
  #line 2462 
  fsp->h_ext.vlan_tci = rule->filter.formatted.vlan_id;
  #line 2463 
  fsp->m_ext.vlan_tci = mask->formatted.vlan_id;
  #line 2464 
  fsp->h_ext.vlan_etype = rule->filter.formatted.flex_bytes;
  #line 2465 
  fsp->m_ext.vlan_etype = mask->formatted.flex_bytes;
  #line 2466 
  fsp->h_ext.data[1] = __builtin_bswap32((unsigned int)rule->filter.formatted.vm_pool);
  #line 2467 
  fsp->m_ext.data[1] = __builtin_bswap32((unsigned int)mask->formatted.vm_pool);
  #line 2468 
  fsp->flow_type |= 2147483648U;
  #line 2471 
  if (rule->action == 127ULL) 
                              #line 2472 
                              fsp->ring_cookie = 18446744073709551615ULL; else 
                                                                    #line 2474 
                                                                    fsp->ring_cookie = rule->action;
  #line 2476 
  return 0;
}

#line 2479  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_ethtool_fdir_all(struct ixgbe_adapter *adapter, struct ethtool_rxnfc *cmd, u32 *rule_locs)
{
  #line 2490 
  void *__mptr;
  #line 2490 
  struct ixgbe_fdir_filter *tmp_0;
  #line 2483 
  struct hlist_node *node2;
  #line 2484 
  struct ixgbe_fdir_filter *rule;
  #line 2485 
  int cnt = 0;
  #line 2488 
  cmd->data = (unsigned long long)((1024 << adapter->fdir_pballoc) + -2);
  {
    #line 2490 
    struct hlist_node *____ptr = adapter->fdir_filter_list.first;
    #line 2490 
    if (____ptr != (struct hlist_node *)0) {
      #line 2490 
      __mptr = (void *)____ptr;
      #line 2490 
      tmp_0 = ((struct ixgbe_fdir_filter *)__mptr);
    }
    else 
         #line 2490 
         tmp_0 = (struct ixgbe_fdir_filter *)0;
    }
  #line 2490 
  rule = tmp_0;
  #line 2490 
  while (1) {
    #line 2490 
    void *__mptr_0;
    #line 2490 
    struct ixgbe_fdir_filter *tmp_3;
    #line 2490 
    if (rule != (struct ixgbe_fdir_filter *)0) {
      #line 2490 
      node2 = rule->fdir_node.next;
      #line 2490 
      if (! (1 != 0)) 
                      #line 2490 
                      break;
    }
    else 
         #line 2490 
         break;
    #line 2492 
    if (cmd->__anonCompField_ethtool_rxnfc_100.rule_cnt == (unsigned int)cnt) 
      #line 2493 
      return -90;
    #line 2494 
    *(rule_locs + (unsigned long)cnt) = (unsigned int)rule->sw_idx;
    #line 2495 
    cnt ++;
    {
      #line 2490 
      struct hlist_node *____ptr_0 = node2;
      #line 2490 
      if (____ptr_0 != (struct hlist_node *)0) {
        #line 2490 
        __mptr_0 = (void *)____ptr_0;
        #line 2490 
        tmp_3 = ((struct ixgbe_fdir_filter *)__mptr_0);
      }
      else 
           #line 2490 
           tmp_3 = (struct ixgbe_fdir_filter *)0;
      }
    #line 2490 
    rule = tmp_3;
  }
  #line 2498 
  cmd->__anonCompField_ethtool_rxnfc_100.rule_cnt = (unsigned int)cnt;
  #line 2500 
  return 0;
}

#line 2503  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_rss_hash_opts(struct ixgbe_adapter *adapter, struct ethtool_rxnfc *cmd)
{
  #line 2506 
  cmd->data = 0ULL;
  #line 2509 
  switch (cmd->flow_type) {
    #line 2510 
    case (__u32)1: 
                   #line 2510 
    ;
    #line 2511 
    cmd->data |= 192ULL;
    #line 2513 
    case (__u32)2: 
                   #line 2513 
    ;
    #line 2514 
    if (((unsigned long)adapter->flags2 & 256UL) != 0UL) 
                                                         #line 2515 
                                                         cmd->data |= 192ULL;
    #line 2517 
    case (__u32)3: 
                   #line 2517 
    ;
    #line 2518 
    case (__u32)4: 
                   #line 2518 
    ;
    #line 2519 
    case (__u32)9: 
                   #line 2519 
    ;
    #line 2520 
    case (__u32)10: 
                    #line 2520 
    ;
    #line 2521 
    case (__u32)16: 
                    #line 2521 
    ;
    #line 2522 
    cmd->data |= 48ULL;
    #line 2523 
    break;
    #line 2524 
    case (__u32)5: 
                   #line 2524 
    ;
    #line 2525 
    cmd->data |= 192ULL;
    #line 2527 
    case (__u32)6: 
                   #line 2527 
    ;
    #line 2528 
    if (((unsigned long)adapter->flags2 & 512UL) != 0UL) 
                                                         #line 2529 
                                                         cmd->data |= 192ULL;
    #line 2531 
    case (__u32)7: 
                   #line 2531 
    ;
    #line 2532 
    case (__u32)8: 
                   #line 2532 
    ;
    #line 2533 
    case (__u32)11: 
                    #line 2533 
    ;
    #line 2534 
    case (__u32)12: 
                    #line 2534 
    ;
    #line 2535 
    case (__u32)17: 
                    #line 2535 
    ;
    #line 2536 
    cmd->data |= 48ULL;
    #line 2537 
    break;
    #line 2538 
    default: 
             #line 2538 
    ;
    #line 2539 
    return -22;
  }
  #line 2542 
  return 0;
}

#line 2545  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd, u32 *rule_locs)
{
  #line 2548 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 2549 
  int ret = -95;
  #line 2551 
  switch (cmd->cmd) {
    #line 2552 
    case (__u32)45: 
                    #line 2552 
    ;
    #line 2553 
    cmd->data = (unsigned long long)adapter->num_rx_queues;
    #line 2554 
    ret = 0;
    #line 2555 
    break;
    #line 2556 
    case (__u32)46: 
                    #line 2556 
    ;
    #line 2557 
    cmd->__anonCompField_ethtool_rxnfc_100.rule_cnt = (unsigned int)adapter->fdir_filter_count;
    #line 2558 
    ret = 0;
    #line 2559 
    break;
    #line 2560 
    case (__u32)47: 
                    #line 2560 
    ;
    #line 2561 
    ret = ixgbe_get_ethtool_fdir_entry(adapter,cmd);
    #line 2562 
    break;
    #line 2563 
    case (__u32)48: 
                    #line 2563 
    ;
    #line 2564 
    ret = ixgbe_get_ethtool_fdir_all(adapter,cmd,rule_locs);
    #line 2565 
    break;
    #line 2566 
    case (__u32)41: 
                    #line 2566 
    ;
    #line 2567 
    ret = ixgbe_get_rss_hash_opts(adapter,cmd);
    #line 2568 
    break;
    #line 2569 
    default: 
             #line 2569 
    ;
    #line 2570 
    break;
  }
  #line 2573 
  return ret;
}

#line 2576  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
int ixgbe_update_ethtool_fdir_entry(struct ixgbe_adapter *adapter, struct ixgbe_fdir_filter *input, u16 sw_idx)
{
  #line 2588 
  struct ixgbe_fdir_filter *tmp_0;
  #line 2588 
  void *__mptr;
  #line 2581 
  struct hlist_node *node2;
  #line 2582 
  struct ixgbe_fdir_filter *rule;
  #line 2582 
  struct ixgbe_fdir_filter *parent;
  #line 2580 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 2583 
  int err = -22;
  #line 2585 
  parent = (struct ixgbe_fdir_filter *)0;
  #line 2586 
  rule = (struct ixgbe_fdir_filter *)0;
  {
    #line 2588 
    struct hlist_node *____ptr = adapter->fdir_filter_list.first;
    #line 2588 
    if (____ptr != (struct hlist_node *)0) {
      #line 2588 
      __mptr = (void *)____ptr;
      #line 2588 
      tmp_0 = ((struct ixgbe_fdir_filter *)__mptr);
    }
    else 
         #line 2588 
         tmp_0 = (struct ixgbe_fdir_filter *)0;
    }
  #line 2588 
  rule = tmp_0;
  #line 2588 
  while (1) {
    #line 2588 
    void *__mptr_0;
    #line 2588 
    struct ixgbe_fdir_filter *tmp_3;
    #line 2588 
    if (rule != (struct ixgbe_fdir_filter *)0) {
      #line 2588 
      node2 = rule->fdir_node.next;
      #line 2588 
      if (! (1 != 0)) 
                      #line 2588 
                      break;
    }
    else 
         #line 2588 
         break;
    #line 2591 
    if ((int)rule->sw_idx >= (int)sw_idx) 
                                          #line 2592 
                                          break;
    #line 2593 
    parent = rule;
    {
      #line 2588 
      struct hlist_node *____ptr_0 = node2;
      #line 2588 
      if (____ptr_0 != (struct hlist_node *)0) {
        #line 2588 
        __mptr_0 = (void *)____ptr_0;
        #line 2588 
        tmp_3 = ((struct ixgbe_fdir_filter *)__mptr_0);
      }
      else 
           #line 2588 
           tmp_3 = (struct ixgbe_fdir_filter *)0;
      }
    #line 2588 
    rule = tmp_3;
  }
  #line 2597 
  if (rule != (struct ixgbe_fdir_filter *)0 && (int)rule->sw_idx == (int)sw_idx) {
    #line 2598 
    if (input == (struct ixgbe_fdir_filter *)0 || (int)rule->filter.formatted.bkt_hash != (int)input->filter.formatted.bkt_hash) 
      #line 2600 
      err = ixgbe_fdir_erase_perfect_filter_82599(hw,& rule->filter,(unsigned short)((int)sw_idx));
    #line 2605 
    hlist_del_0(& rule->fdir_node);
    #line 2606 
    kfree((void *)rule);
    #line 2607 
    (adapter->fdir_filter_count) --;
  }
  #line 2614 
  if (input == (struct ixgbe_fdir_filter *)0) 
                                              #line 2615 
                                              return err;
  #line 2618 
  INIT_HLIST_NODE(& input->fdir_node);
  #line 2621 
  if (parent != (struct ixgbe_fdir_filter *)0) 
                                               #line 2622 
                                               hlist_add_behind(& input->fdir_node,& parent->fdir_node); else 
                                                                    #line 2624 
                                                                    hlist_add_head(& input->fdir_node,& adapter->fdir_filter_list);
  #line 2628 
  (adapter->fdir_filter_count) ++;
  #line 2630 
  return 0;
}

#line 2633  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_flowspec_to_flow_type(struct ethtool_rx_flow_spec *fsp, u8 *flow_type)
{
  #line 2636 
  switch (fsp->flow_type & 2147483647U) {
    #line 2637 
    case (unsigned int)1: 
                          #line 2637 
    ;
    #line 2638 
    *flow_type = (unsigned char)2U;
    #line 2639 
    break;
    #line 2640 
    case (unsigned int)2: 
                          #line 2640 
    ;
    #line 2641 
    *flow_type = (unsigned char)1U;
    #line 2642 
    break;
    #line 2643 
    case (unsigned int)3: 
                          #line 2643 
    ;
    #line 2644 
    *flow_type = (unsigned char)3U;
    #line 2645 
    break;
    #line 2646 
    case (unsigned int)13: 
                           #line 2646 
    ;
    #line 2647 
    switch ((int)fsp->h_u.usr_ip4_spec.proto) {
      #line 2648 
      case 6: 
              #line 2648 
      ;
      #line 2649 
      *flow_type = (unsigned char)2U;
      #line 2650 
      break;
      #line 2651 
      case 17: 
               #line 2651 
      ;
      #line 2652 
      *flow_type = (unsigned char)1U;
      #line 2653 
      break;
      #line 2654 
      case 132: 
                #line 2654 
      ;
      #line 2655 
      *flow_type = (unsigned char)3U;
      #line 2656 
      break;
      #line 2657 
      case 0: 
              #line 2657 
      ;
      #line 2658 
      if ((unsigned int)fsp->m_u.usr_ip4_spec.proto == 0U) {
        #line 2659 
        *flow_type = (unsigned char)0U;
        #line 2660 
        break;
      }
      #line 2663 
      default: 
               #line 2663 
      ;
      #line 2664 
      return 0;
    }
    #line 2666 
    break;
    #line 2667 
    default: 
             #line 2667 
    ;
    #line 2668 
    return 0;
  }
  #line 2671 
  return 1;
}

#line 2674  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_add_ethtool_fdir_entry(struct ixgbe_adapter *adapter, struct ethtool_rxnfc *cmd)
{
  #line 2680 
  struct ixgbe_fdir_filter *input;
  #line 2681 
  union ixgbe_atr_input mask;
  #line 2682 
  u8 queue;
  #line 2683 
  int err;
  #line 2677 
  struct ethtool_rx_flow_spec *fsp = & cmd->fs;
  #line 2679 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 2685 
  if (((unsigned long)adapter->flags & 524288UL) == 0UL) 
                                                         #line 2686 
                                                         return -95;
  #line 2691 
  if (fsp->ring_cookie == 18446744073709551615ULL) 
                                                   #line 2692 
                                                   queue = (unsigned char)127U;
  else {
    #line 2694 
    u32 ring = (unsigned int)ethtool_get_flow_spec_ring(fsp->ring_cookie);
    #line 2695 
    u8 vf = (unsigned char)ethtool_get_flow_spec_ring_vf(fsp->ring_cookie);
    #line 2697 
    if ((unsigned int)vf == 0U && (unsigned int)adapter->num_rx_queues <= ring) 
      #line 2698 
      return -22;
    else 
      #line 2699 
      if ((unsigned int)vf != 0U && ((unsigned int)vf > adapter->num_vfs || (unsigned int)adapter->num_rx_queues_per_pool <= ring)) 
        #line 2702 
        return -22;
    #line 2705 
    if ((unsigned int)vf == 0U) 
                                #line 2706 
                                queue = (adapter->rx_ring[ring])->reg_idx; else 
                                                                    #line 2708 
                                                                    queue = (unsigned char)(((unsigned int)vf + 255U) * (unsigned int)((unsigned char)adapter->num_rx_queues_per_pool) + (unsigned int)((unsigned char)ring));
  }
  #line 2713 
  if (fsp->location >= (unsigned int)((1024 << adapter->fdir_pballoc) + -2)) {
    #line 2714 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 2714 
                                             netdev_err(adapter->netdev,(char *)"Location out of range\n");
    #line 2715 
    return -22;
  }
  #line 2718 
  input = (struct ixgbe_fdir_filter *)kzalloc_1(72UL,2592U);
  #line 2719 
  if (input == (struct ixgbe_fdir_filter *)0) 
                                              #line 2720 
                                              return -12;
  #line 2722 
  memset((void *)(& mask),0,44UL);
  #line 2725 
  input->sw_idx = (unsigned short)fsp->location;
  #line 2728 
  if (ixgbe_flowspec_to_flow_type(fsp,& input->filter.formatted.flow_type) == 0) {
    #line 2730 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 2730 
                                             netdev_err(adapter->netdev,(char *)"Unrecognized flow type\n");
    #line 2731 
    goto err_out;
  }
  #line 2734 
  mask.formatted.flow_type = (unsigned char)7U;
  #line 2737 
  if ((unsigned int)input->filter.formatted.flow_type == 0U) 
                                                             #line 2738 
                                                             mask.formatted.flow_type = (unsigned char)((unsigned int)mask.formatted.flow_type & 4U);
  #line 2741 
  input->filter.formatted.src_ip[0] = fsp->h_u.tcp_ip4_spec.ip4src;
  #line 2742 
  mask.formatted.src_ip[0] = fsp->m_u.tcp_ip4_spec.ip4src;
  #line 2743 
  input->filter.formatted.dst_ip[0] = fsp->h_u.tcp_ip4_spec.ip4dst;
  #line 2744 
  mask.formatted.dst_ip[0] = fsp->m_u.tcp_ip4_spec.ip4dst;
  #line 2745 
  input->filter.formatted.src_port = fsp->h_u.tcp_ip4_spec.psrc;
  #line 2746 
  mask.formatted.src_port = fsp->m_u.tcp_ip4_spec.psrc;
  #line 2747 
  input->filter.formatted.dst_port = fsp->h_u.tcp_ip4_spec.pdst;
  #line 2748 
  mask.formatted.dst_port = fsp->m_u.tcp_ip4_spec.pdst;
  #line 2750 
  if ((fsp->flow_type & 2147483648U) != 0U) {
    #line 2751 
    input->filter.formatted.vm_pool = (unsigned char)__builtin_bswap32(fsp->h_ext.data[1]);
    #line 2753 
    mask.formatted.vm_pool = (unsigned char)__builtin_bswap32(fsp->m_ext.data[1]);
    #line 2755 
    input->filter.formatted.vlan_id = fsp->h_ext.vlan_tci;
    #line 2756 
    mask.formatted.vlan_id = fsp->m_ext.vlan_tci;
    #line 2757 
    input->filter.formatted.flex_bytes = fsp->h_ext.vlan_etype;
    #line 2759 
    mask.formatted.flex_bytes = fsp->m_ext.vlan_etype;
  }
  #line 2763 
  if (fsp->ring_cookie == 18446744073709551615ULL) 
                                                   #line 2764 
                                                   input->action = 127ULL; else 
                                                                    #line 2766 
                                                                    input->action = fsp->ring_cookie;
  #line 2768 
  cif_spin_lock_fdir_perfect_lock_of_ixgbe_adapter_0(& adapter->fdir_perfect_lock);
  #line 2770 
  if (hlist_empty_0(& adapter->fdir_filter_list) != 0) {
    #line 2772 
    memcpy((void *)(& adapter->fdir_mask),(void *)(& mask),44UL);
    #line 2773 
    err = ixgbe_fdir_set_input_mask_82599(hw,& mask);
    #line 2774 
    if (err != 0) {
      #line 2775 
      if (((int)adapter->msg_enable & 1) != 0) 
                                               #line 2775 
                                               netdev_err(adapter->netdev,(char *)"Error writing mask\n");
      #line 2776 
      goto err_out_w_lock;
    }
  }
  else {
    #line 2778 
    if (memcmp((void *)(& adapter->fdir_mask),(void *)(& mask),44UL) != 0) {
      #line 2779 
      if (((int)adapter->msg_enable & 1) != 0) 
                                               #line 2779 
                                               netdev_err(adapter->netdev,(char *)"Only one mask supported per port\n");
      #line 2780 
      goto err_out_w_lock;
    }
  }
  #line 2784 
  ixgbe_atr_compute_perfect_hash_82599(& input->filter,& mask);
  #line 2787 
  err = ixgbe_fdir_write_perfect_filter_82599(hw,& input->filter,(unsigned short)((int)input->sw_idx),(unsigned char)((int)queue));
  #line 2789 
  if (err != 0) 
                #line 2790 
                goto err_out_w_lock;
  #line 2792 
  ixgbe_update_ethtool_fdir_entry(adapter,input,(unsigned short)((int)input->sw_idx));
  #line 2794 
  cif_spin_unlock_fdir_perfect_lock_of_ixgbe_adapter_0(& adapter->fdir_perfect_lock);
  #line 2796 
  return err;
  #line 2797 
  err_out_w_lock: 
                  #line 2797 
  ;
  #line 2798 
  cif_spin_unlock_fdir_perfect_lock_of_ixgbe_adapter_0(& adapter->fdir_perfect_lock);
  #line 2799 
  err_out: 
           #line 2799 
  ;
  #line 2800 
  kfree((void *)input);
  #line 2801 
  return -22;
}

#line 2804  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_del_ethtool_fdir_entry(struct ixgbe_adapter *adapter, struct ethtool_rxnfc *cmd)
{
  #line 2809 
  int err;
  #line 2807 
  struct ethtool_rx_flow_spec *fsp = & cmd->fs;
  #line 2811 
  cif_spin_lock_fdir_perfect_lock_of_ixgbe_adapter_0(& adapter->fdir_perfect_lock);
  #line 2812 
  err = ixgbe_update_ethtool_fdir_entry(adapter,(struct ixgbe_fdir_filter *)0,(unsigned short)((int)((unsigned short)fsp->location)));
  #line 2813 
  cif_spin_unlock_fdir_perfect_lock_of_ixgbe_adapter_0(& adapter->fdir_perfect_lock);
  #line 2815 
  return err;
}

#line 2820  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_rss_hash_opt(struct ixgbe_adapter *adapter, struct ethtool_rxnfc *nfc)
{
  #line 2823 
  u32 flags2 = adapter->flags2;
  #line 2829 
  if ((nfc->data & 18446744073709551375ULL) != 0ULL) 
                                                     #line 2831 
                                                     return -22;
  #line 2833 
  switch (nfc->flow_type) {
    #line 2834 
    case (__u32)1: 
                   #line 2834 
    ;
    #line 2835 
    case (__u32)5: 
                   #line 2835 
    ;
    #line 2836 
    if ((((nfc->data & 16ULL) == 0ULL || (nfc->data & 32ULL) == 0ULL) || (nfc->data & 64ULL) == 0ULL) || (nfc->data & 128ULL) == 0ULL) 
      #line 2840 
      return -22;
    #line 2841 
    break;
    #line 2842 
    case (__u32)2: 
                   #line 2842 
    ;
    #line 2843 
    if ((nfc->data & 16ULL) == 0ULL || (nfc->data & 32ULL) == 0ULL) 
                                                                    #line 2845 
                                                                    return -22;
    #line 2846 
    switch (nfc->data & 192ULL) {
      #line 2847 
      case (unsigned long long)0: 
                                  #line 2847 
      ;
      #line 2848 
      flags2 &= 4294967039U;
      #line 2849 
      break;
      #line 2850 
      case (unsigned long long)192: 
                                    #line 2850 
      ;
      #line 2851 
      flags2 |= 256U;
      #line 2852 
      break;
      #line 2853 
      default: 
               #line 2853 
      ;
      #line 2854 
      return -22;
    }
    #line 2856 
    break;
    #line 2857 
    case (__u32)6: 
                   #line 2857 
    ;
    #line 2858 
    if ((nfc->data & 16ULL) == 0ULL || (nfc->data & 32ULL) == 0ULL) 
                                                                    #line 2860 
                                                                    return -22;
    #line 2861 
    switch (nfc->data & 192ULL) {
      #line 2862 
      case (unsigned long long)0: 
                                  #line 2862 
      ;
      #line 2863 
      flags2 &= 4294966783U;
      #line 2864 
      break;
      #line 2865 
      case (unsigned long long)192: 
                                    #line 2865 
      ;
      #line 2866 
      flags2 |= 512U;
      #line 2867 
      break;
      #line 2868 
      default: 
               #line 2868 
      ;
      #line 2869 
      return -22;
    }
    #line 2871 
    break;
    #line 2872 
    case (__u32)4: 
                   #line 2872 
    ;
    #line 2873 
    case (__u32)9: 
                   #line 2873 
    ;
    #line 2874 
    case (__u32)10: 
                    #line 2874 
    ;
    #line 2875 
    case (__u32)3: 
                   #line 2875 
    ;
    #line 2876 
    case (__u32)8: 
                   #line 2876 
    ;
    #line 2877 
    case (__u32)11: 
                    #line 2877 
    ;
    #line 2878 
    case (__u32)12: 
                    #line 2878 
    ;
    #line 2879 
    case (__u32)7: 
                   #line 2879 
    ;
    #line 2880 
    if ((((nfc->data & 16ULL) == 0ULL || (nfc->data & 32ULL) == 0ULL) || (nfc->data & 64ULL) != 0ULL) || (nfc->data & 128ULL) != 0ULL) 
      #line 2884 
      return -22;
    #line 2885 
    break;
    #line 2886 
    default: 
             #line 2886 
    ;
    #line 2887 
    return -22;
  }
  #line 2891 
  if (adapter->flags2 != flags2) {
    #line 2893 
    u32 mrqc;
    #line 2892 
    struct ixgbe_hw *hw = & adapter->hw;
    #line 2894 
    unsigned int pf_pool = adapter->num_vfs;
    #line 2896 
    if (hw->mac.type > (unsigned int)ixgbe_mac_X540 && ((unsigned long)adapter->flags & 8388608UL) != 0UL) 
      #line 2898 
      mrqc = ixgbe_read_reg(hw,(pf_pool + 3328U) * 4U); else 
                                                             #line 2900 
                                                             mrqc = ixgbe_read_reg(hw,22552U);
    #line 2902 
    if (((unsigned long)flags2 & 768UL) != 0UL && ((unsigned long)adapter->flags2 & 768UL) == 0UL) 
      #line 2904 
      if (((int)adapter->msg_enable & 1) != 0) 
                                               #line 2904 
                                               netdev_warn(adapter->netdev,(char *)"enabling UDP RSS: fragmented packets may arrive out of order to the stack above\n");
    #line 2906 
    adapter->flags2 = flags2;
    #line 2909 
    mrqc |= 3342336U;
    #line 2914 
    mrqc &= 4282384383U;
    #line 2917 
    if (((unsigned long)flags2 & 256UL) != 0UL) 
                                                #line 2918 
                                                mrqc |= 4194304U;
    #line 2920 
    if (((unsigned long)flags2 & 512UL) != 0UL) 
                                                #line 2921 
                                                mrqc |= 8388608U;
    #line 2923 
    if (hw->mac.type > (unsigned int)ixgbe_mac_X540 && ((unsigned long)adapter->flags & 8388608UL) != 0UL) 
      #line 2925 
      ixgbe_write_reg_6(hw,(pf_pool + 3328U) * 4U,mrqc); else 
                                                              #line 2927 
                                                              ixgbe_write_reg_6(hw,22552U,mrqc);
  }
  #line 2930 
  return 0;
}

#line 2933  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)
{
  #line 2935 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 2936 
  int ret = -95;
  #line 2938 
  switch (cmd->cmd) {
    #line 2939 
    case (__u32)50: 
                    #line 2939 
    ;
    #line 2940 
    ret = ixgbe_add_ethtool_fdir_entry(adapter,cmd);
    #line 2941 
    break;
    #line 2942 
    case (__u32)49: 
                    #line 2942 
    ;
    #line 2943 
    ret = ixgbe_del_ethtool_fdir_entry(adapter,cmd);
    #line 2944 
    break;
    #line 2945 
    case (__u32)42: 
                    #line 2945 
    ;
    #line 2946 
    ret = ixgbe_set_rss_hash_opt(adapter,cmd);
    #line 2947 
    break;
    #line 2948 
    default: 
             #line 2948 
    ;
    #line 2949 
    break;
  }
  #line 2952 
  return ret;
}

#line 2955  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_rss_indir_tbl_max(struct ixgbe_adapter *adapter)
{
  #line 2957 
  if (adapter->hw.mac.type <= (unsigned int)ixgbe_mac_X540) 
                                                            #line 2958 
                                                            return 16; else 
                                                                    #line 2960 
                                                                    return 64;
}

#line 2963  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static u32 ixgbe_get_rxfh_key_size(struct net_device *netdev)
{
  #line 2965 
  return 40U;
}

#line 2968  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static u32 ixgbe_rss_indir_size(struct net_device *netdev)
{
  #line 2970 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 2972 
  return ixgbe_rss_indir_tbl_entries(adapter);
}

#line 2975  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_reta(struct ixgbe_adapter *adapter, u32 *indir)
{
  #line 2977 
  int i;
  #line 2977 
  int reta_size = (int)ixgbe_rss_indir_tbl_entries(adapter);
  #line 2978 
  u16 rss_m = adapter->ring_feature[2].mask;
  #line 2980 
  if (((unsigned long)adapter->flags & 8388608UL) != 0UL) 
                                                          #line 2981 
                                                          rss_m = (unsigned short)((unsigned int)adapter->ring_feature[2].indices + 65535U);
  #line 2983 
  i = 0;
  #line 2983 
  while (i < reta_size) {
    #line 2984 
    *(indir + (unsigned long)i) = (unsigned int)((int)adapter->rss_indir_tbl[i] & (int)rss_m);
    #line 2983 
    i ++;
  }
  #line 2985 
  return;
}

#line 2987  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key, u8 *hfunc)
{
  #line 2990 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 2992 
  if (hfunc != (u8 *)0U) 
                         #line 2993 
                         *hfunc = (unsigned char)1U;
  #line 2995 
  if (indir != (u32 *)0U) 
                          #line 2996 
                          ixgbe_get_reta(adapter,indir);
  #line 2998 
  if (key != (u8 *)0U) {
    #line 2999 
    ;
    #line 2999 
    ;
    #line 2999 
    memcpy((void *)key,(void *)adapter->rss_key,(unsigned long)ixgbe_get_rxfh_key_size(netdev));
  }
  #line 3001 
  return 0;
}

#line 3004  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_rxfh(struct net_device *netdev, u32 *indir, u8 *key, u8 hfunc)
{
  #line 3008 
  int i;
  #line 3007 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 3009 
  u32 reta_entries = ixgbe_rss_indir_tbl_entries(adapter);
  #line 3011 
  if ((unsigned int)hfunc != 0U) 
                                 #line 3012 
                                 return -22;
  #line 3015 
  if (indir != (u32 *)0U) {
    #line 3016 
    int tmp_2;
    #line 3016 
    int __UNIQUE_ID___x454;
    {
      #line 3016 
      __UNIQUE_ID___x454 = adapter->num_rx_queues;
      #line 3016 
      int __UNIQUE_ID___y455 = ixgbe_rss_indir_tbl_max(adapter);
      #line 3016 
      if (__UNIQUE_ID___x454 < __UNIQUE_ID___y455) 
                                                   #line 3016 
                                                   tmp_2 = __UNIQUE_ID___x454; else 
                                                                    #line 3016 
                                                                    tmp_2 = __UNIQUE_ID___y455;
      }
    #line 3016 
    int max_queues = tmp_2;
    #line 3020 
    if (((unsigned long)adapter->flags & 8388608UL) != 0UL && max_queues <= 1) 
      #line 3022 
      max_queues = 2;
    #line 3025 
    i = 0;
    #line 3025 
    while ((unsigned int)i < reta_entries) {
      #line 3026 
      if (*(indir + (unsigned long)i) >= (unsigned int)max_queues) 
                                                                   #line 3027 
                                                                   return -22;
      #line 3025 
      i ++;
    }
    #line 3029 
    i = 0;
    #line 3029 
    while ((unsigned int)i < reta_entries) {
      #line 3030 
      adapter->rss_indir_tbl[i] = (unsigned char)*(indir + (unsigned long)i);
      #line 3029 
      i ++;
    }
    #line 3032 
    ixgbe_store_reta(adapter);
  }
  #line 3036 
  if (key != (u8 *)0U) {
    #line 3037 
    ;
    #line 3037 
    ;
    #line 3037 
    memcpy((void *)adapter->rss_key,(void *)key,(unsigned long)ixgbe_get_rxfh_key_size(netdev));
    #line 3038 
    ixgbe_store_key(adapter);
  }
  #line 3041 
  return 0;
}

#line 3044  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_ts_info(struct net_device *dev, struct ethtool_ts_info *info)
{
  #line 3047 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 3050 
  info->rx_filters = 1U;
  #line 3052 
  switch ((unsigned int)adapter->hw.mac.type) {
    #line 3053 
    case (unsigned int)4: 
                          #line 3053 
    ;
    #line 3054 
    case (unsigned int)5: 
                          #line 3054 
    ;
    #line 3055 
    case (unsigned int)6: 
                          #line 3055 
    ;
    #line 3056 
    info->rx_filters |= 2U;
    #line 3057 
    break;
    #line 3058 
    case (unsigned int)3: 
                          #line 3058 
    ;
    #line 3059 
    case (unsigned int)2: 
                          #line 3059 
    ;
    #line 3060 
    info->rx_filters |= 4144U;
    #line 3064 
    break;
    #line 3065 
    default: 
             #line 3065 
    ;
    #line 3066 
    return ethtool_op_get_ts_info(dev,info);
  }
  #line 3069 
  info->so_timestamping = 95U;
  #line 3077 
  if (adapter->ptp_clock != (struct ptp_clock *)0) 
                                                   #line 3078 
                                                   info->phc_index = ptp_clock_index(adapter->ptp_clock); else 
                                                                    #line 3080 
                                                                    info->phc_index = -1;
  #line 3082 
  info->tx_types = 3U;
  #line 3086 
  return 0;
}

#line 3089  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static unsigned int ixgbe_max_channels(struct ixgbe_adapter *adapter)
{
  #line 3091 
  unsigned int max_combined;
  #line 3092 
  u8 tcs = adapter->hw_tcs;
  #line 3094 
  if (((unsigned long)adapter->flags & 8UL) == 0UL) 
                                                    #line 3096 
                                                    max_combined = 1U;
  else 
    #line 3097 
    if (((unsigned long)adapter->flags & 8388608UL) != 0UL) 
                                                            #line 3099 
                                                            max_combined = (unsigned int)((int)adapter->ring_feature[2].mask + 1);
    else 
      #line 3100 
      if ((unsigned int)tcs > 1U) 
        #line 3102 
        if (adapter->hw.mac.type == (unsigned int)ixgbe_mac_82598EB) 
          #line 3104 
          max_combined = 4U;
        else 
          #line 3105 
          if ((unsigned int)tcs > 4U) 
                                      #line 3107 
                                      max_combined = 8U; else 
                                                              #line 3110 
                                                              max_combined = 16U;
      else 
        #line 3112 
        if (adapter->atr_sample_rate != 0U) 
                                            #line 3114 
                                            max_combined = 63U;
        else {
          #line 3117 
          max_combined = (unsigned int)ixgbe_max_rss_indices(adapter);
        }
  #line 3120 
  return max_combined;
}

#line 3123  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_channels(struct net_device *dev, struct ethtool_channels *ch)
{
  #line 3126 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 3129 
  ch->max_combined = ixgbe_max_channels(adapter);
  #line 3132 
  if (((unsigned long)adapter->flags & 8UL) != 0UL) {
    #line 3133 
    ch->max_other = 1U;
    #line 3134 
    ch->other_count = 1U;
  }
  #line 3138 
  ch->combined_count = (unsigned int)adapter->ring_feature[2].indices;
  #line 3141 
  if (ch->combined_count == 1U) 
                                #line 3142 
                                return;
  #line 3145 
  if (((unsigned long)adapter->flags & 8388608UL) != 0UL) 
                                                          #line 3146 
                                                          return;
  #line 3149 
  if ((unsigned int)adapter->hw_tcs > 1U) 
                                          #line 3150 
                                          return;
  #line 3153 
  if (adapter->atr_sample_rate == 0U) 
                                      #line 3154 
                                      return;
  #line 3157 
  ch->combined_count = (unsigned int)adapter->ring_feature[3].indices;
  #line 3158 
  return;
}

#line 3160  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_channels(struct net_device *dev, struct ethtool_channels *ch)
{
  #line 3163 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 3164 
  unsigned int count = ch->combined_count;
  #line 3165 
  u8 max_rss_indices = ixgbe_max_rss_indices(adapter);
  #line 3168 
  if ((count == 0U || ch->rx_count != 0U) || ch->tx_count != 0U) 
                                                                 #line 3169 
                                                                 return -22;
  #line 3172 
  if (ch->other_count != 1U) 
                             #line 3173 
                             return -22;
  #line 3176 
  ;
  #line 3176 
  if (ixgbe_max_channels(adapter) < count) 
                                           #line 3177 
                                           return -22;
  #line 3180 
  adapter->ring_feature[3].limit = (unsigned short)count;
  #line 3183 
  if ((unsigned int)max_rss_indices < count) 
                                             #line 3184 
                                             count = (unsigned int)max_rss_indices;
  #line 3185 
  adapter->ring_feature[2].limit = (unsigned short)count;
  #line 3189 
  if (count > 8U) 
                  #line 3190 
                  count = 8U;
  #line 3191 
  adapter->ring_feature[4].limit = (unsigned short)count;
  #line 3195 
  return ixgbe_setup_tc(dev,(unsigned char)((int)adapter->hw_tcs));
}

#line 3198  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_module_info(struct net_device *dev, struct ethtool_modinfo *modinfo)
{
  #line 3203 
  s32 status;
  #line 3204 
  u8 sff8472_rev;
  #line 3204 
  u8 addr_mode;
  #line 3201 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 3202 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 3205 
  bool page_swap = (_Bool)0;
  #line 3207 
  if (hw->phy.type == (unsigned int)ixgbe_phy_fw) 
                                                  #line 3208 
                                                  return -6;
  #line 3211 
  status = (*(hw->phy.ops.read_i2c_eeprom))(hw,(unsigned char)94,& sff8472_rev);
  #line 3214 
  if (status != 0) 
                   #line 3215 
                   return -5;
  #line 3218 
  status = (*(hw->phy.ops.read_i2c_eeprom))(hw,(unsigned char)92,& addr_mode);
  #line 3221 
  if (status != 0) 
                   #line 3222 
                   return -5;
  #line 3224 
  if (((int)addr_mode & 4) != 0) {
    #line 3225 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 3225 
                                             netdev_err(adapter->netdev,(char *)"Address change required to access page 0xA2, but not supported. Please report the module type to the driver maintainers.\n");
    #line 3226 
    page_swap = (_Bool)1;
  }
  #line 3229 
  if (((unsigned int)sff8472_rev == 0U || (int)page_swap != 0) || ((int)addr_mode & 64) == 0) {
    #line 3232 
    modinfo->type = 1U;
    #line 3233 
    modinfo->eeprom_len = 256U;
  }
  else {
    #line 3236 
    modinfo->type = 2U;
    #line 3237 
    modinfo->eeprom_len = 512U;
  }
  #line 3240 
  return 0;
}

#line 3243  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_module_eeprom(struct net_device *dev, struct ethtool_eeprom *ee, u8 *data)
{
  #line 3247 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 3248 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 3249 
  s32 status = -17;
  #line 3250 
  u8 databyte = (unsigned char)255U;
  #line 3251 
  int i = 0;
  #line 3253 
  if (ee->len == 0U) 
                     #line 3254 
                     return -22;
  #line 3256 
  if (hw->phy.type == (unsigned int)ixgbe_phy_fw) 
                                                  #line 3257 
                                                  return -6;
  #line 3259 
  i = (int)ee->offset;
  #line 3259 
  while (ee->offset + ee->len > (unsigned int)i) {
    {
      #line 3261 
      if ((int)test_bit(7L,& adapter->state) != 0) 
                                                   #line 3262 
                                                   return -16;
      #line 3264 
      if (i <= 255) 
                    #line 3265 
                    status = (*(hw->phy.ops.read_i2c_eeprom))(hw,(unsigned char)((int)((unsigned char)i)),& databyte); else 
                                                                    #line 3267 
                                                                    status = (*(hw->phy.ops.read_i2c_sff8472))(hw,(unsigned char)((int)((unsigned char)i)),& databyte);
      #line 3269 
      if (status != 0) 
                       #line 3270 
                       return -5;
      #line 3272 
      *(data + (unsigned long)((unsigned int)i - ee->offset)) = databyte;
    }
    #line 3259 
    i ++;
  }
  #line 3275 
  return 0;
}

#line 3281  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static struct __anonstruct_ixgbe_ls_map_7804 ixgbe_ls_map[5U] = {{.mac_speed = 2U, .supported = 2U}, {.mac_speed = 8U, .supported = 8U}, {.mac_speed = 32U, .supported = 32U}, {.mac_speed = 1024U, .supported = 32768U}, {.mac_speed = 128U, .supported = 4096U}};
#line 3292  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static struct __anonstruct_ixgbe_lp_map_7805 ixgbe_lp_map[6U] = {{.lp_advertised = 2U, .mac_speed = 8U}, {.lp_advertised = 4U, .mac_speed = 32U}, {.lp_advertised = 8U, .mac_speed = 4096U}, {.lp_advertised = 16U, .mac_speed = 131072U}, {.lp_advertised = 32U, .mac_speed = 262144U}, {.lp_advertised = 64U, .mac_speed = 524288U}};
#line 3302  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_eee_fw(struct ixgbe_adapter *adapter, struct ethtool_eee *edata)
{
  #line 3306 
  s32 rc;
  #line 3307 
  u16 i;
  #line 3304 
  u32 info[4U] = {0U};
  #line 3305 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 3309 
  rc = ixgbe_fw_phy_activity(hw,(unsigned short)4098,& info);
  #line 3310 
  if (rc != 0) 
               #line 3311 
               return rc;
  #line 3313 
  edata->lp_advertised = 0U;
  #line 3314 
  i = (unsigned short)0U;
  #line 3314 
  while ((unsigned int)i <= 5U) {
    #line 3315 
    if ((info[0] & ixgbe_lp_map[(int)i].lp_advertised) != 0U) 
                                                              #line 3316 
                                                              edata->lp_advertised |= ixgbe_lp_map[(int)i].mac_speed;
    #line 3314 
    i = (u16)((int)i + 1);
  }
  #line 3319 
  edata->supported = 0U;
  #line 3320 
  i = (unsigned short)0U;
  #line 3320 
  while ((unsigned int)i <= 4U) {
    #line 3321 
    if ((hw->phy.eee_speeds_supported & ixgbe_ls_map[(int)i].mac_speed) != 0U) 
      #line 3322 
      edata->supported |= ixgbe_ls_map[(int)i].supported;
    #line 3320 
    i = (u16)((int)i + 1);
  }
  #line 3325 
  edata->advertised = 0U;
  #line 3326 
  i = (unsigned short)0U;
  #line 3326 
  while ((unsigned int)i <= 4U) {
    #line 3327 
    if ((hw->phy.eee_speeds_advertised & ixgbe_ls_map[(int)i].mac_speed) != 0U) 
      #line 3328 
      edata->advertised |= ixgbe_ls_map[(int)i].supported;
    #line 3326 
    i = (u16)((int)i + 1);
  }
  #line 3331 
  edata->eee_enabled = (unsigned int)(edata->advertised != 0U);
  #line 3332 
  edata->tx_lpi_enabled = edata->eee_enabled;
  #line 3333 
  if ((edata->advertised & edata->lp_advertised) != 0U) 
                                                        #line 3334 
                                                        edata->eee_active = 1U;
  #line 3336 
  return 0;
}

#line 3339  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_eee(struct net_device *netdev, struct ethtool_eee *edata)
{
  #line 3341 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 3342 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 3344 
  if (((unsigned long)adapter->flags2 & 16384UL) == 0UL) 
                                                         #line 3345 
                                                         return -95;
  #line 3347 
  if (hw->phy.eee_speeds_supported != 0U && hw->phy.type == (unsigned int)ixgbe_phy_fw) {
    #line 3348 
    return ixgbe_get_eee_fw(adapter,edata);
  }
  #line 3350 
  return -95;
}

#line 3353  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_eee(struct net_device *netdev, struct ethtool_eee *edata)
{
  #line 3357 
  struct ethtool_eee eee_data;
  #line 3358 
  s32 ret_val;
  #line 3355 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 3356 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 3360 
  if (((unsigned long)adapter->flags2 & 16384UL) == 0UL) 
                                                         #line 3361 
                                                         return -95;
  #line 3363 
  memset((void *)(& eee_data),0,40UL);
  #line 3365 
  ret_val = ixgbe_get_eee(netdev,& eee_data);
  #line 3366 
  if (ret_val != 0) 
                    #line 3367 
                    return ret_val;
  #line 3369 
  if (eee_data.eee_enabled != 0U && edata->eee_enabled == 0U) {
    #line 3370 
    if (eee_data.tx_lpi_enabled != edata->tx_lpi_enabled) {
      #line 3371 
      if (((int)adapter->msg_enable & 1) != 0) 
                                               #line 3371 
                                               netdev_err(adapter->netdev,(char *)"Setting EEE tx-lpi is not supported\n");
      #line 3372 
      return -22;
    }
    #line 3375 
    if (eee_data.tx_lpi_timer != edata->tx_lpi_timer) {
      #line 3376 
      if (((int)adapter->msg_enable & 1) != 0) 
                                               #line 3376 
                                               netdev_err(adapter->netdev,(char *)"Setting EEE Tx LPI timer is not supported\n");
      #line 3378 
      return -22;
    }
    #line 3381 
    if (eee_data.advertised != edata->advertised) {
      #line 3382 
      if (((int)adapter->msg_enable & 1) != 0) 
                                               #line 3382 
                                               netdev_err(adapter->netdev,(char *)"Setting EEE advertised speeds is not supported\n");
      #line 3384 
      return -22;
    }
  }
  #line 3388 
  if (eee_data.eee_enabled != edata->eee_enabled) {
    #line 3389 
    if (edata->eee_enabled != 0U) {
      #line 3390 
      adapter->flags2 |= 32768U;
      #line 3391 
      hw->phy.eee_speeds_advertised = hw->phy.eee_speeds_supported;
    }
    else {
      #line 3394 
      adapter->flags2 &= 4294934527U;
      #line 3395 
      hw->phy.eee_speeds_advertised = 0U;
    }
    #line 3399 
    if ((int)netif_running(netdev) != 0) 
                                         #line 3400 
                                         ixgbe_reinit_locked(adapter); else 
                                                                    #line 3402 
                                                                    ixgbe_reset(adapter);
  }
  #line 3405 
  return 0;
}

#line 3408  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static u32 ixgbe_get_priv_flags(struct net_device *netdev)
{
  #line 3410 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 3411 
  u32 priv_flags = 0U;
  #line 3413 
  if (((unsigned long)adapter->flags2 & 65536UL) != 0UL) 
                                                         #line 3414 
                                                         priv_flags |= 1U;
  #line 3416 
  if (((unsigned long)adapter->flags2 & 262144UL) != 0UL) 
                                                          #line 3417 
                                                          priv_flags |= 2U;
  #line 3419 
  return priv_flags;
}

#line 3422  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_priv_flags(struct net_device *netdev, u32 priv_flags)
{
  #line 3424 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 3425 
  unsigned int flags2 = adapter->flags2;
  #line 3427 
  flags2 &= 4294901759U;
  #line 3428 
  if (((unsigned long)priv_flags & 1UL) != 0UL) 
                                                #line 3429 
                                                flags2 |= 65536U;
  #line 3431 
  flags2 &= 4294705151U;
  #line 3432 
  if (((unsigned long)priv_flags & 2UL) != 0UL) 
                                                #line 3433 
                                                flags2 |= 262144U;
  #line 3435 
  if (adapter->flags2 != flags2) {
    #line 3436 
    adapter->flags2 = flags2;
    #line 3439 
    if ((int)netif_running(netdev) != 0) 
                                         #line 3440 
                                         ixgbe_reinit_locked(adapter);
  }
  #line 3443 
  return 0;
}

#line 3446  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static struct ethtool_ops ixgbe_ethtool_ops = {.get_drvinfo = & ixgbe_get_drvinfo, .get_regs_len = & ixgbe_get_regs_len, .get_regs = & ixgbe_get_regs, .get_wol = & ixgbe_get_wol, .set_wol = & ixgbe_set_wol, .get_msglevel = & ixgbe_get_msglevel, .set_msglevel = & ixgbe_set_msglevel, .nway_reset = & ixgbe_nway_reset, .get_link = & ethtool_op_get_link, .get_eeprom_len = & ixgbe_get_eeprom_len, .get_eeprom = & ixgbe_get_eeprom, .set_eeprom = & ixgbe_set_eeprom, .get_coalesce = & ixgbe_get_coalesce, .set_coalesce = & ixgbe_set_coalesce, .get_ringparam = & ixgbe_get_ringparam, .set_ringparam = & ixgbe_set_ringparam, .get_pauseparam = & ixgbe_get_pauseparam, .set_pauseparam = & ixgbe_set_pauseparam, .self_test = & ixgbe_diag_test, .get_strings = & ixgbe_get_strings, .set_phys_id = & ixgbe_set_phys_id, .get_ethtool_stats = & ixgbe_get_ethtool_stats, .get_priv_flags = & ixgbe_get_priv_flags, .set_priv_flags = & ixgbe_set_priv_flags, .get_sset_count = & ixgbe_get_sset_count, .get_rxnfc = & ixgbe_get_rxnfc, .set_rxnfc = & ixgbe_set_rxnfc, .get_rxfh_key_size = & ixgbe_get_rxfh_key_size, .get_rxfh_indir_size = & ixgbe_rss_indir_size, .get_rxfh = & ixgbe_get_rxfh, .set_rxfh = & ixgbe_set_rxfh, .get_channels = & ixgbe_get_channels, .set_channels = & ixgbe_set_channels, .get_ts_info = & ixgbe_get_ts_info, .get_module_info = & ixgbe_get_module_info, .get_module_eeprom = & ixgbe_get_module_eeprom, .get_eee = & ixgbe_get_eee, .set_eee = & ixgbe_set_eee, .get_link_ksettings = & ixgbe_get_link_ksettings, .set_link_ksettings = & ixgbe_set_link_ksettings};
#line 3489  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
void ixgbe_set_ethtool_ops(struct net_device *netdev)
{
  #line 3491 
  netdev->ethtool_ops = & ixgbe_ethtool_ops;
  #line 3492 
  return;
}

#line 108  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
void emg_wrapper_ixgbe_diag_test(struct net_device *arg0, struct ethtool_test *arg1, unsigned long long *arg2)
{
  #line 109 
  ixgbe_diag_test(arg0,arg1,arg2);
  #line 110 
  return;
}

#line 113  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
void emg_wrapper_ixgbe_get_channels(struct net_device *arg0, struct ethtool_channels *arg1)
{
  #line 114 
  ixgbe_get_channels(arg0,arg1);
  #line 115 
  return;
}

#line 118  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_get_coalesce(struct net_device *arg0, struct ethtool_coalesce *arg1)
{
  #line 119 
  return ixgbe_get_coalesce(arg0,arg1);
}

#line 123  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
void emg_wrapper_ixgbe_get_drvinfo(struct net_device *arg0, struct ethtool_drvinfo *arg1)
{
  #line 124 
  ixgbe_get_drvinfo(arg0,arg1);
  #line 125 
  return;
}

#line 128  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_get_eee(struct net_device *arg0, struct ethtool_eee *arg1)
{
  #line 129 
  return ixgbe_get_eee(arg0,arg1);
}

#line 133  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_get_eeprom(struct net_device *arg0, struct ethtool_eeprom *arg1, unsigned char *arg2)
{
  #line 134 
  return ixgbe_get_eeprom(arg0,arg1,arg2);
}

#line 138  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_get_eeprom_len(struct net_device *arg0)
{
  #line 139 
  return ixgbe_get_eeprom_len(arg0);
}

#line 143  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
void emg_wrapper_ixgbe_get_ethtool_stats(struct net_device *arg0, struct ethtool_stats *arg1, unsigned long long *arg2)
{
  #line 144 
  ixgbe_get_ethtool_stats(arg0,arg1,arg2);
  #line 145 
  return;
}

#line 148  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_get_link_ksettings(struct net_device *arg0, struct ethtool_link_ksettings *arg1)
{
  #line 149 
  return ixgbe_get_link_ksettings(arg0,arg1);
}

#line 153  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_get_module_eeprom(struct net_device *arg0, struct ethtool_eeprom *arg1, unsigned char *arg2)
{
  #line 154 
  return ixgbe_get_module_eeprom(arg0,arg1,arg2);
}

#line 158  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_get_module_info(struct net_device *arg0, struct ethtool_modinfo *arg1)
{
  #line 159 
  return ixgbe_get_module_info(arg0,arg1);
}

#line 163  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
unsigned int emg_wrapper_ixgbe_get_msglevel(struct net_device *arg0)
{
  #line 164 
  return ixgbe_get_msglevel(arg0);
}

#line 168  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
void emg_wrapper_ixgbe_get_pauseparam(struct net_device *arg0, struct ethtool_pauseparam *arg1)
{
  #line 169 
  ixgbe_get_pauseparam(arg0,arg1);
  #line 170 
  return;
}

#line 173  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
unsigned int emg_wrapper_ixgbe_get_priv_flags(struct net_device *arg0)
{
  #line 174 
  return ixgbe_get_priv_flags(arg0);
}

#line 178  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
void emg_wrapper_ixgbe_get_regs(struct net_device *arg0, struct ethtool_regs *arg1, void *arg2)
{
  #line 179 
  ixgbe_get_regs(arg0,arg1,arg2);
  #line 180 
  return;
}

#line 183  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_get_regs_len(struct net_device *arg0)
{
  #line 184 
  return ixgbe_get_regs_len(arg0);
}

#line 188  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
void emg_wrapper_ixgbe_get_ringparam(struct net_device *arg0, struct ethtool_ringparam *arg1)
{
  #line 189 
  ixgbe_get_ringparam(arg0,arg1);
  #line 190 
  return;
}

#line 193  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_get_rxfh(struct net_device *arg0, unsigned int *arg1, unsigned char *arg2, unsigned char *arg3)
{
  #line 194 
  return ixgbe_get_rxfh(arg0,arg1,arg2,arg3);
}

#line 198  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
unsigned int emg_wrapper_ixgbe_get_rxfh_key_size(struct net_device *arg0)
{
  #line 199 
  return ixgbe_get_rxfh_key_size(arg0);
}

#line 203  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_get_rxnfc(struct net_device *arg0, struct ethtool_rxnfc *arg1, unsigned int *arg2)
{
  #line 204 
  return ixgbe_get_rxnfc(arg0,arg1,arg2);
}

#line 208  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_get_sset_count(struct net_device *arg0, int arg1)
{
  #line 209 
  return ixgbe_get_sset_count(arg0,arg1);
}

#line 213  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
void emg_wrapper_ixgbe_get_strings(struct net_device *arg0, unsigned int arg1, unsigned char *arg2)
{
  #line 214 
  ixgbe_get_strings(arg0,arg1,arg2);
  #line 215 
  return;
}

#line 218  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_get_ts_info(struct net_device *arg0, struct ethtool_ts_info *arg1)
{
  #line 219 
  return ixgbe_get_ts_info(arg0,arg1);
}

#line 223  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
void emg_wrapper_ixgbe_get_wol(struct net_device *arg0, struct ethtool_wolinfo *arg1)
{
  #line 224 
  ixgbe_get_wol(arg0,arg1);
  #line 225 
  return;
}

#line 228  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_nway_reset(struct net_device *arg0)
{
  #line 229 
  return ixgbe_nway_reset(arg0);
}

#line 233  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
unsigned int emg_wrapper_ixgbe_rss_indir_size(struct net_device *arg0)
{
  #line 234 
  return ixgbe_rss_indir_size(arg0);
}

#line 238  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_set_channels(struct net_device *arg0, struct ethtool_channels *arg1)
{
  #line 239 
  return ixgbe_set_channels(arg0,arg1);
}

#line 243  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_set_coalesce(struct net_device *arg0, struct ethtool_coalesce *arg1)
{
  #line 244 
  return ixgbe_set_coalesce(arg0,arg1);
}

#line 248  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_set_eee(struct net_device *arg0, struct ethtool_eee *arg1)
{
  #line 249 
  return ixgbe_set_eee(arg0,arg1);
}

#line 253  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_set_eeprom(struct net_device *arg0, struct ethtool_eeprom *arg1, unsigned char *arg2)
{
  #line 254 
  return ixgbe_set_eeprom(arg0,arg1,arg2);
}

#line 258  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_set_link_ksettings(struct net_device *arg0, struct ethtool_link_ksettings *arg1)
{
  #line 259 
  return ixgbe_set_link_ksettings(arg0,arg1);
}

#line 263  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
void emg_wrapper_ixgbe_set_msglevel(struct net_device *arg0, unsigned int arg1)
{
  #line 264 
  ixgbe_set_msglevel(arg0,arg1);
  #line 265 
  return;
}

#line 268  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_set_pauseparam(struct net_device *arg0, struct ethtool_pauseparam *arg1)
{
  #line 269 
  return ixgbe_set_pauseparam(arg0,arg1);
}

#line 273  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_set_phys_id(struct net_device *arg0, enum ethtool_phys_id_state arg1)
{
  #line 274 
  return ixgbe_set_phys_id(arg0,arg1);
}

#line 278  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_set_priv_flags(struct net_device *arg0, unsigned int arg1)
{
  #line 279 
  return ixgbe_set_priv_flags(arg0,arg1);
}

#line 283  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_set_ringparam(struct net_device *arg0, struct ethtool_ringparam *arg1)
{
  #line 284 
  return ixgbe_set_ringparam(arg0,arg1);
}

#line 288  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_set_rxfh(struct net_device *arg0, unsigned int *arg1, unsigned char *arg2, unsigned char arg3)
{
  #line 289 
  return ixgbe_set_rxfh(arg0,arg1,arg2,(unsigned char)((int)arg3));
}

#line 293  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_set_rxnfc(struct net_device *arg0, struct ethtool_rxnfc *arg1)
{
  #line 294 
  return ixgbe_set_rxnfc(arg0,arg1);
}

#line 298  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
int emg_wrapper_ixgbe_set_wol(struct net_device *arg0, struct ethtool_wolinfo *arg1)
{
  #line 299 
  return ixgbe_set_wol(arg0,arg1);
}

#line 303  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
enum irqreturn emg_wrapper_ixgbe_test_intr(int arg0, void *arg1)
{
  #line 304 
  return ixgbe_test_intr(arg0,arg1);
}

#line 323  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
static void cif_set_bit_3(long nr, unsigned long *addr)
{
  #line 326 
  ldv_set_bit(nr,addr);
  #line 327 
  return;
}

#line 330  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
static void cif_clear_bit_0(long nr, unsigned long *addr)
{
  #line 333 
  ldv_clear_bit(nr,addr);
  #line 334 
  return;
}

#line 587  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
static void *kmalloc_0(size_t size, gfp_t flags)
{
  #line 590 
  return ldv_kmalloc(size,flags);
}

#line 594  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
static void *kmalloc_array(size_t n, size_t size, gfp_t flags)
{
  #line 597 
  return ldv_kmalloc_array(n,size,flags);
}

#line 622  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
static void *kzalloc_1(size_t size, gfp_t flags)
{
  #line 625 
  return ldv_kzalloc(size,flags);
}

#line 889  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
static void *cif_vmalloc_0(unsigned long size)
{
  #line 892 
  return ldv_vmalloc(size);
}

#line 896  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
static void cif_vfree_0(void *addr)
{
  #line 899 
  ldv_vfree(addr);
  #line 900 
  return;
}

#line 903  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
static int cif_request_irq_0(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char *name, void *dev)
{
  #line 907 
  return emg_request_irq(irq,handler,flags,name,dev);
}

#line 911  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
static void *cif_free_irq_0(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  #line 915 
  return emg_free_irq(ldv_func_arg1,ldv_func_arg2);
}

#line 919  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
static void cif_spin_lock_fdir_perfect_lock_of_ixgbe_adapter_0(spinlock_t *lock)
{
  #line 922 
  ldv_spin_model_lock((char *)"fdir_perfect_lock_of_ixgbe_adapter");
  #line 924 
  spin_lock_0(lock);
  #line 925 
  return;
}

#line 928  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ethtool.i.aux"
static void cif_spin_unlock_fdir_perfect_lock_of_ixgbe_adapter_0(spinlock_t *lock)
{
  #line 931 
  ldv_spin_model_unlock((char *)"fdir_perfect_lock_of_ixgbe_adapter");
  #line 933 
  spin_unlock_0(lock);
  #line 934 
  return;
}

#line 97  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/io.h"
__inline static void writeq(u64 val, void *addr)
{
  #line 99 
  ldv_inline_asm();
  #line 100 
  return;
}

#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
#line 14 
s32 ixgbe_start_hw_gen2(struct ixgbe_hw *hw);
#line 41 
#line 41 
s32 ixgbe_read_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw, u16 offset, u16 words, u16 *data);
#line 56 
#line 56 
s32 ixgbe_disable_rx_buff_generic(struct ixgbe_hw *hw);
#line 57 
#line 57 
s32 ixgbe_enable_rx_buff_generic(struct ixgbe_hw *hw);
#line 59 
#line 59 
s32 ixgbe_fc_enable_generic(struct ixgbe_hw *hw);
#line 66 
#line 66 
s32 ixgbe_get_san_mac_addr_generic(struct ixgbe_hw *hw, u8 *san_mac_addr);
#line 67 
#line 67 
s32 ixgbe_set_vmdq_generic(struct ixgbe_hw *hw, u32 rar, u32 vmdq);
#line 68 
#line 68 
s32 ixgbe_set_vmdq_san_mac_generic(struct ixgbe_hw *hw, u32 vmdq);
#line 69 
#line 69 
s32 ixgbe_clear_vmdq_generic(struct ixgbe_hw *hw, u32 rar, u32 vmdq);
#line 70 
#line 70 
s32 ixgbe_init_uta_tables_generic(struct ixgbe_hw *hw);
#line 71 
#line 71 
s32 ixgbe_set_vfta_generic(struct ixgbe_hw *hw, u32 vlan, u32 vind, bool vlan_on, bool vlvf_bypass);
#line 73 
#line 73 
s32 ixgbe_clear_vfta_generic(struct ixgbe_hw *hw);
#line 74 
#line 74 
s32 ixgbe_check_mac_link_generic(struct ixgbe_hw *hw, ixgbe_link_speed *speed, bool *link_up, bool link_up_wait_to_complete);
#line 77 
#line 77 
s32 ixgbe_get_wwn_prefix_generic(struct ixgbe_hw *hw, u16 *wwnn_prefix, u16 *wwpn_prefix);
#line 85 
#line 85 
void ixgbe_set_mac_anti_spoofing(struct ixgbe_hw *hw, bool enable, int vf);
#line 86 
#line 86 
void ixgbe_set_vlan_anti_spoofing(struct ixgbe_hw *hw, bool enable, int vf);
#line 87 
#line 87 
s32 ixgbe_get_device_caps_generic(struct ixgbe_hw *hw, u16 *device_caps);
#line 88 
#line 88 
s32 ixgbe_set_fw_drv_ver_generic(struct ixgbe_hw *hw, u8 maj, u8 min, u8 build, u8 sub, u16 len, char *driver_ver);
#line 96 
#line 96 
void ixgbe_clear_tx_pending(struct ixgbe_hw *hw);
#line 97 
#line 97 
bool ixgbe_mng_present(struct ixgbe_hw *hw);
#line 100 
#line 100 
void ixgbe_set_rxpba_generic(struct ixgbe_hw *hw, int num_pb, u32 headroom, int strategy);
#line 115 
#line 115 
s32 ixgbe_get_thermal_sensor_data_generic(struct ixgbe_hw *hw);
#line 116 
#line 116 
s32 ixgbe_init_thermal_sensor_thresh_generic(struct ixgbe_hw *hw);
#line 125 
#line 125 
s32 ixgbe_setup_mac_link_multispeed_fiber(struct ixgbe_hw *hw, ixgbe_link_speed speed, bool autoneg_wait_to_complete);
#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static void ixgbe_write_reg_7(struct ixgbe_hw *hw, u32 reg, u32 value)
{
  #line 147 
  union __anonunion___u_8528 __u;
  #line 146 
  __read_once_size((void *)(& hw->hw_addr),(void *)(& __u.__c),8);
  #line 146 
  u8 *reg_addr = (__u.__val);
  #line 148 
  if ((int)ixgbe_removed((void *)reg_addr) != 0) 
                                                 #line 149 
                                                 return;
  #line 150 
  writel(value,(void *)(reg_addr + (unsigned long)reg));
  #line 151 
  return;
}

#line 163  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static void ixgbe_write_reg64(struct ixgbe_hw *hw, u32 reg, u64 value)
{
  #line 166 
  union __anonunion___u_8530 __u;
  #line 165 
  __read_once_size((void *)(& hw->hw_addr),(void *)(& __u.__c),8);
  #line 165 
  u8 *reg_addr = (__u.__val);
  #line 167 
  if ((int)ixgbe_removed((void *)reg_addr) != 0) 
                                                 #line 168 
                                                 return;
  #line 169 
  writeq(value,(void *)(reg_addr + (unsigned long)reg));
  #line 170 
  return;
}

#line 143  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h"
#line 143 
bool ixgbe_check_reset_blocked(struct ixgbe_hw *hw);
#line 159 
#line 159 
s32 ixgbe_read_i2c_byte_generic(struct ixgbe_hw *hw, u8 byte_offset, u8 dev_addr, u8 *data);
#line 163 
#line 163 
s32 ixgbe_write_i2c_byte_generic(struct ixgbe_hw *hw, u8 byte_offset, u8 dev_addr, u8 data);
#line 167 
#line 167 
s32 ixgbe_read_i2c_eeprom_generic(struct ixgbe_hw *hw, u8 byte_offset, u8 *eeprom_data);
#line 169 
#line 169 
s32 ixgbe_read_i2c_sff8472_generic(struct ixgbe_hw *hw, u8 byte_offset, u8 *sff8472_data);
#line 171 
#line 171 
s32 ixgbe_write_i2c_eeprom_generic(struct ixgbe_hw *hw, u8 byte_offset, u8 eeprom_data);
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
#line 564 
static void ixgbe_disable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw);
#line 20 
#line 587 
static void ixgbe_enable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw);
#line 21 
#line 610 
static void ixgbe_flap_tx_laser_multispeed_fiber(struct ixgbe_hw *hw);
#line 23 
#line 631 
static void ixgbe_set_hard_rate_select_speed(struct ixgbe_hw *hw, ixgbe_link_speed speed);
#line 24 
#line 660 
static s32 ixgbe_setup_mac_link_smartspeed(struct ixgbe_hw *hw, ixgbe_link_speed speed, bool autoneg_wait_to_complete);
#line 27 
#line 480 
static void ixgbe_stop_mac_link_on_d3_82599(struct ixgbe_hw *hw);
#line 28 
#line 503 
static s32 ixgbe_start_mac_link_82599(struct ixgbe_hw *hw, bool autoneg_wait_to_complete);
#line 30 
#line 770 
static s32 ixgbe_setup_mac_link_82599(struct ixgbe_hw *hw, ixgbe_link_speed speed, bool autoneg_wait_to_complete);
#line 33 
#line 886 
static s32 ixgbe_setup_copper_link_82599(struct ixgbe_hw *hw, ixgbe_link_speed speed, bool autoneg_wait_to_complete);
#line 36 
#line 1868 
static s32 ixgbe_verify_fw_version_82599(struct ixgbe_hw *hw);
#line 37 
#line 2064 
static s32 ixgbe_read_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset, u8 dev_addr, u8 *data);
#line 39 
#line 2118 
static s32 ixgbe_write_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset, u8 dev_addr, u8 data);
#line 41 
#line 2009 
static s32 ixgbe_reset_pipeline_82599(struct ixgbe_hw *hw);
#line 42 
#line 1917 
static bool ixgbe_verify_lesm_fw_enabled_82599(struct ixgbe_hw *hw);
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
bool ixgbe_mng_enabled(struct ixgbe_hw *hw)
{
  #line 46 
  u32 fwsm;
  #line 46 
  u32 manc;
  #line 46 
  u32 factps;
  #line 48 
  fwsm = ixgbe_read_reg(hw,*(hw->mvals + 6U));
  #line 49 
  if ((fwsm & 14U) != 4U) 
                          #line 50 
                          return (_Bool)0;
  #line 52 
  manc = ixgbe_read_reg(hw,22560U);
  #line 53 
  if ((manc & 131072U) == 0U) 
                              #line 54 
                              return (_Bool)0;
  #line 56 
  factps = ixgbe_read_reg(hw,*(hw->mvals + 3U));
  #line 57 
  if ((factps & 536870912U) != 0U) 
                                   #line 58 
                                   return (_Bool)0;
  #line 60 
  return (_Bool)1;
}

#line 63  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static void ixgbe_init_mac_link_ops_82599(struct ixgbe_hw *hw)
{
  #line 65 
  struct ixgbe_mac_info *mac = & hw->mac;
  #line 70 
  if ((*(mac->ops.get_media_type))(hw) == (unsigned int)ixgbe_media_type_fiber) {
    #line 71 
    if (ixgbe_mng_enabled(hw)) 
                               #line 70 
                               goto _LAND;
    else {
      #line 72 
      mac->ops.disable_tx_laser = & ixgbe_disable_tx_laser_multispeed_fiber;
      #line 74 
      mac->ops.enable_tx_laser = & ixgbe_enable_tx_laser_multispeed_fiber;
      #line 76 
      mac->ops.flap_tx_laser = & ixgbe_flap_tx_laser_multispeed_fiber;
    }
  }
  else {
    #line 70 
    _LAND: {
             #line 78 
             mac->ops.disable_tx_laser = (void (*)(struct ixgbe_hw *))0;
             #line 79 
             mac->ops.enable_tx_laser = (void (*)(struct ixgbe_hw *))0;
             #line 80 
             mac->ops.flap_tx_laser = (void (*)(struct ixgbe_hw *))0;
           }
  }
  #line 83 
  if ((int)hw->phy.multispeed_fiber != 0) {
    #line 85 
    mac->ops.setup_link = & ixgbe_setup_mac_link_multispeed_fiber;
    #line 86 
    mac->ops.setup_mac_link = & ixgbe_setup_mac_link_82599;
    #line 87 
    mac->ops.set_rate_select_speed = & ixgbe_set_hard_rate_select_speed;
  }
  else {
    #line 90 
    if ((*(mac->ops.get_media_type))(hw) == (unsigned int)ixgbe_media_type_backplane) 
      #line 91 
      if (hw->phy.smart_speed <= (unsigned int)ixgbe_smart_speed_on) {
        #line 94 
        if (ixgbe_verify_lesm_fw_enabled_82599(hw)) 
                                                    #line 97 
                                                    mac->ops.setup_link = & ixgbe_setup_mac_link_82599; else 
                                                                    #line 95 
                                                                    mac->ops.setup_link = & ixgbe_setup_mac_link_smartspeed;
      }
      else 
           #line 97 
           mac->ops.setup_link = & ixgbe_setup_mac_link_82599;
    else 
         #line 97 
         mac->ops.setup_link = & ixgbe_setup_mac_link_82599;
  }
  #line 98 
  return;
}

#line 101  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_setup_sfp_modules_82599(struct ixgbe_hw *hw)
{
  #line 103 
  s32 ret_val;
  #line 104 
  u16 list_offset;
  #line 104 
  u16 data_offset;
  #line 104 
  u16 data_value;
  #line 106 
  if (hw->phy.sfp_type != (unsigned int)ixgbe_sfp_type_unknown) {
    #line 107 
    ixgbe_init_mac_link_ops_82599(hw);
    #line 109 
    hw->phy.ops.reset = (s32 (*)(struct ixgbe_hw *))0;
    #line 111 
    ret_val = ixgbe_get_sfp_init_sequence_offsets(hw,& list_offset,& data_offset);
    #line 113 
    if (ret_val != 0) 
                      #line 114 
                      return ret_val;
    #line 117 
    ret_val = (*(hw->mac.ops.acquire_swfw_sync))(hw,8U);
    #line 119 
    if (ret_val != 0) 
                      #line 120 
                      return -16;
    #line 122 
    data_offset = (u16)((int)data_offset + 1);
    #line 122 
    ;
    #line 122 
    if ((*(hw->eeprom.ops.read))(hw,(unsigned short)((int)data_offset),
                               & data_value) != 0) 
      #line 123 
      goto setup_sfp_err;
    #line 124 
    while ((unsigned int)data_value != 65535U) {
      #line 125 
      ixgbe_write_reg_7(hw,85760U,(unsigned int)data_value);
      #line 126 
      ixgbe_read_reg(hw,8U);
      #line 127 
      data_offset = (u16)((int)data_offset + 1);
      #line 127 
      ;
      #line 127 
      if ((*(hw->eeprom.ops.read))(hw,(unsigned short)((int)data_offset),
                                 & data_value) != 0) 
        #line 128 
        goto setup_sfp_err;
    }
    #line 132 
    (*(hw->mac.ops.release_swfw_sync))(hw,8U);
    #line 137 
    usleep_range((unsigned long)(hw->eeprom.semaphore_delay * 1000U),(unsigned long)(hw->eeprom.semaphore_delay * 2000U));
    #line 141 
    ret_val = (*(hw->mac.ops.prot_autoc_write))(hw,hw->mac.orig_autoc | 24576U,(_Bool)0);
    #line 145 
    if (ret_val != 0) {
      {
        #line 146 
        bool branch;
        #line 146 
        struct _ddebug __UNIQUE_ID_ddebug443 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_setup_sfp_modules_82599", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c", .format = (char *)" sfp module setup not complete\n", .lineno = (unsigned int)146U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 146 
        branch = arch_static_branch(& __UNIQUE_ID_ddebug443.key.dd_key_false.key,(_Bool)0);
        #line 146 
        if ((long)((long)((int)branch != 0)) != 0L) 
                                                    #line 146 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug443,((struct ixgbe_adapter *)hw->back)->netdev,(char *)" sfp module setup not complete\n");
      }
      #line 147 
      return -30;
    }
  }
  #line 151 
  return 0;
  #line 153 
  setup_sfp_err: 
                 #line 153 
  ;
  #line 155 
  (*(hw->mac.ops.release_swfw_sync))(hw,8U);
  #line 159 
  usleep_range((unsigned long)(hw->eeprom.semaphore_delay * 1000U),(unsigned long)(hw->eeprom.semaphore_delay * 2000U));
  #line 161 
  netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"eeprom read at offset %d failed\n",(int)data_offset);
  #line 162 
  return -30;
}

#line 176  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 prot_autoc_read_82599(struct ixgbe_hw *hw, bool *locked, u32 *reg_val)
{
  #line 179 
  s32 ret_val;
  #line 181 
  *locked = (_Bool)0;
  #line 183 
  if ((int)ixgbe_verify_lesm_fw_enabled_82599(hw) != 0) {
    #line 184 
    ret_val = (*(hw->mac.ops.acquire_swfw_sync))(hw,8U);
    #line 186 
    if (ret_val != 0) 
                      #line 187 
                      return -16;
    #line 189 
    *locked = (_Bool)1;
  }
  #line 192 
  *reg_val = ixgbe_read_reg(hw,17056U);
  #line 193 
  return 0;
}

#line 206  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 prot_autoc_write_82599(struct ixgbe_hw *hw, u32 autoc, bool locked)
{
  #line 208 
  s32 ret_val = 0;
  #line 211 
  if ((int)ixgbe_check_reset_blocked(hw) != 0) 
                                               #line 212 
                                               goto out;
  #line 218 
  if (! locked) {
    #line 218 
    if ((int)ixgbe_verify_lesm_fw_enabled_82599(hw) != 0) {
      #line 219 
      ret_val = (*(hw->mac.ops.acquire_swfw_sync))(hw,8U);
      #line 221 
      if (ret_val != 0) 
                        #line 222 
                        return -16;
      #line 224 
      locked = (_Bool)1;
    }
  }
  #line 227 
  ixgbe_write_reg_7(hw,17056U,autoc);
  #line 228 
  ret_val = ixgbe_reset_pipeline_82599(hw);
  #line 230 
  out: 
       #line 230 
  ;
  #line 234 
  if ((int)locked != 0) 
                        #line 235 
                        (*(hw->mac.ops.release_swfw_sync))(hw,8U);
  #line 237 
  return ret_val;
}

#line 240  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_get_invariants_82599(struct ixgbe_hw *hw)
{
  #line 242 
  struct ixgbe_mac_info *mac = & hw->mac;
  #line 244 
  ixgbe_init_mac_link_ops_82599(hw);
  #line 246 
  mac->mcft_size = 128U;
  #line 247 
  mac->vft_size = 128U;
  #line 248 
  mac->num_rar_entries = 128U;
  #line 249 
  mac->rx_pb_size = 512U;
  #line 250 
  mac->max_rx_queues = 128U;
  #line 251 
  mac->max_tx_queues = 128U;
  #line 252 
  mac->max_msix_vectors = ixgbe_get_pcie_msix_count_generic(hw);
  #line 254 
  return 0;
}

#line 266  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_init_phy_ops_82599(struct ixgbe_hw *hw)
{
  #line 270 
  s32 ret_val;
  #line 271 
  u32 esdp;
  #line 268 
  struct ixgbe_mac_info *mac = & hw->mac;
  #line 269 
  struct ixgbe_phy_info *phy = & hw->phy;
  #line 273 
  if ((unsigned int)hw->device_id == 5464U) {
    #line 275 
    hw->phy.qsfp_shared_i2c_bus = (_Bool)1;
    #line 278 
    esdp = ixgbe_read_reg(hw,32U);
    #line 279 
    esdp |= 256U;
    #line 280 
    esdp &= 4294966783U;
    #line 281 
    esdp &= 4294967294U;
    #line 282 
    esdp &= 4294901759U;
    #line 283 
    esdp &= 4294836223U;
    #line 284 
    ixgbe_write_reg_7(hw,32U,esdp);
    #line 285 
    ixgbe_read_reg(hw,8U);
    #line 287 
    phy->ops.read_i2c_byte = & ixgbe_read_i2c_byte_82599;
    #line 288 
    phy->ops.write_i2c_byte = & ixgbe_write_i2c_byte_82599;
  }
  #line 292 
  ret_val = (*(phy->ops.identify))(hw);
  #line 295 
  ixgbe_init_mac_link_ops_82599(hw);
  #line 298 
  if ((*(mac->ops.get_media_type))(hw) == (unsigned int)ixgbe_media_type_copper) {
    #line 299 
    mac->ops.setup_link = & ixgbe_setup_copper_link_82599;
    #line 300 
    mac->ops.get_link_capabilities = & ixgbe_get_copper_link_capabilities_generic;
  }
  #line 305 
  switch ((unsigned int)hw->phy.type) {
    #line 306 
    case (unsigned int)2: 
                          #line 306 
    ;
    #line 307 
    phy->ops.check_link = & ixgbe_check_phy_link_tnx;
    #line 308 
    phy->ops.setup_link = & ixgbe_setup_phy_link_tnx;
    #line 309 
    break;
    #line 310 
    default: 
             #line 310 
    ;
    #line 311 
    break;
  }
  #line 314 
  return ret_val;
}

#line 325  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_get_link_capabilities_82599(struct ixgbe_hw *hw, ixgbe_link_speed *speed, bool *autoneg)
{
  #line 329 
  u32 autoc = 0U;
  #line 333 
  if (((((unsigned int)hw->phy.sfp_type + 4294967287U <= 1U || hw->phy.sfp_type == (unsigned int)ixgbe_sfp_type_1g_lx_core0) || hw->phy.sfp_type == (unsigned int)ixgbe_sfp_type_1g_lx_core1) || hw->phy.sfp_type == (unsigned int)ixgbe_sfp_type_1g_sx_core0) || hw->phy.sfp_type == (unsigned int)ixgbe_sfp_type_1g_sx_core1) {
    #line 338 
    *speed = 32U;
    #line 339 
    *autoneg = (_Bool)1;
    #line 340 
    return 0;
  }
  #line 348 
  if ((int)hw->mac.orig_link_settings_stored != 0) 
                                                   #line 349 
                                                   autoc = hw->mac.orig_autoc; else 
                                                                    #line 351 
                                                                    autoc = ixgbe_read_reg(hw,17056U);
  #line 353 
  switch (autoc & 57344U) {
    #line 354 
    case (unsigned int)0: 
                          #line 354 
    ;
    #line 355 
    *speed = 32U;
    #line 356 
    *autoneg = (_Bool)0;
    #line 357 
    break;
    #line 359 
    case (unsigned int)8192: 
                             #line 359 
    ;
    #line 360 
    *speed = 128U;
    #line 361 
    *autoneg = (_Bool)0;
    #line 362 
    break;
    #line 364 
    case (unsigned int)16384: 
                              #line 364 
    ;
    #line 365 
    *speed = 32U;
    #line 366 
    *autoneg = (_Bool)1;
    #line 367 
    break;
    #line 369 
    case (unsigned int)24576: 
                              #line 369 
    ;
    #line 370 
    *speed = 128U;
    #line 371 
    *autoneg = (_Bool)0;
    #line 372 
    break;
    #line 374 
    case (unsigned int)32768: 
                              #line 374 
    ;
    #line 375 
    case (unsigned int)49152: 
                              #line 375 
    ;
    #line 376 
    *speed = 0U;
    #line 377 
    if ((autoc & 65536U) != 0U) 
                                #line 378 
                                *speed |= 128U;
    #line 379 
    if ((autoc & 2147483648U) != 0U) 
                                     #line 380 
                                     *speed |= 128U;
    #line 381 
    if ((autoc & 1073741824U) != 0U) 
                                     #line 382 
                                     *speed |= 32U;
    #line 383 
    *autoneg = (_Bool)1;
    #line 384 
    break;
    #line 386 
    case (unsigned int)57344: 
                              #line 386 
    ;
    #line 387 
    *speed = 8U;
    #line 388 
    if ((autoc & 65536U) != 0U) 
                                #line 389 
                                *speed |= 128U;
    #line 390 
    if ((autoc & 2147483648U) != 0U) 
                                     #line 391 
                                     *speed |= 128U;
    #line 392 
    if ((autoc & 1073741824U) != 0U) 
                                     #line 393 
                                     *speed |= 32U;
    #line 394 
    *autoneg = (_Bool)1;
    #line 395 
    break;
    #line 397 
    case (unsigned int)40960: 
                              #line 397 
    ;
    #line 398 
    *speed = 40U;
    #line 399 
    *autoneg = (_Bool)0;
    #line 400 
    break;
    #line 402 
    default: 
             #line 402 
    ;
    #line 403 
    return -8;
  }
  #line 406 
  if ((int)hw->phy.multispeed_fiber != 0) {
    #line 407 
    *speed |= 160U;
    #line 411 
    if (hw->phy.media_type == (unsigned int)ixgbe_media_type_fiber_qsfp) 
      #line 412 
      *autoneg = (_Bool)0; else 
                                #line 414 
                                *autoneg = (_Bool)1;
  }
  #line 417 
  return 0;
}

#line 426  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static enum ixgbe_media_type ixgbe_get_media_type_82599(struct ixgbe_hw *hw)
{
  #line 429 
  switch ((unsigned int)hw->phy.type) {
    #line 430 
    case (unsigned int)9: 
                          #line 430 
    ;
    #line 431 
    case (unsigned int)2: 
                          #line 431 
    ;
    #line 432 
    return ixgbe_media_type_copper;
    #line 434 
    default: 
             #line 434 
    ;
    #line 435 
    break;
  }
  #line 438 
  switch ((int)hw->device_id) {
    #line 439 
    case 4343: 
               #line 439 
    ;
    #line 440 
    case 5396: 
               #line 440 
    ;
    #line 441 
    case 4344: 
               #line 441 
    ;
    #line 442 
    case 5399: 
               #line 442 
    ;
    #line 443 
    case 5418: 
               #line 443 
    ;
    #line 444 
    case 4348: 
               #line 444 
    ;
    #line 446 
    return ixgbe_media_type_backplane;
    #line 448 
    case 4347: 
               #line 448 
    ;
    #line 449 
    case 5417: 
               #line 449 
    ;
    #line 450 
    case 5383: 
               #line 450 
    ;
    #line 451 
    case 5453: 
               #line 451 
    ;
    #line 452 
    case 5450: 
               #line 452 
    ;
    #line 453 
    case 5463: 
               #line 453 
    ;
    #line 454 
    return ixgbe_media_type_fiber;
    #line 456 
    case 4345: 
               #line 456 
    ;
    #line 457 
    return ixgbe_media_type_cx4;
    #line 459 
    case 5404: 
               #line 459 
    ;
    #line 460 
    return ixgbe_media_type_copper;
    #line 462 
    case 5455: 
               #line 462 
    ;
    #line 463 
    return ixgbe_media_type_fiber_lco;
    #line 465 
    case 5464: 
               #line 465 
    ;
    #line 466 
    return ixgbe_media_type_fiber_qsfp;
    #line 468 
    default: 
             #line 468 
    ;
    #line 469 
    return ixgbe_media_type_unknown;
  }
}

#line 480  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static void ixgbe_stop_mac_link_on_d3_82599(struct ixgbe_hw *hw)
{
  #line 482 
  u32 autoc2_reg;
  #line 483 
  u16 ee_ctrl_2 = (unsigned short)0U;
  #line 485 
  (*(hw->eeprom.ops.read))(hw,(unsigned short)1,& ee_ctrl_2);
  #line 487 
  if (! ixgbe_mng_present(hw)) 
    #line 487 
    if (! hw->wol_enabled) 
      #line 487 
      if (((int)ee_ctrl_2 & 2) != 0) {
        #line 489 
        autoc2_reg = ixgbe_read_reg(hw,17064U);
        #line 490 
        autoc2_reg |= 1342177280U;
        #line 491 
        ixgbe_write_reg_7(hw,17064U,autoc2_reg);
      }
  #line 493 
  return;
}

#line 503  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_start_mac_link_82599(struct ixgbe_hw *hw, bool autoneg_wait_to_complete)
{
  #line 506 
  u32 autoc_reg;
  #line 507 
  u32 links_reg;
  #line 508 
  u32 i;
  #line 509 
  s32 status = 0;
  #line 510 
  bool got_lock = (_Bool)0;
  #line 512 
  if ((int)ixgbe_verify_lesm_fw_enabled_82599(hw) != 0) {
    #line 513 
    status = (*(hw->mac.ops.acquire_swfw_sync))(hw,8U);
    #line 515 
    if (status != 0) 
                     #line 516 
                     return status;
    #line 518 
    got_lock = (_Bool)1;
  }
  #line 522 
  ixgbe_reset_pipeline_82599(hw);
  #line 524 
  if ((int)got_lock != 0) 
                          #line 525 
                          (*(hw->mac.ops.release_swfw_sync))(hw,8U);
  #line 528 
  if ((int)autoneg_wait_to_complete != 0) {
    #line 529 
    autoc_reg = ixgbe_read_reg(hw,17056U);
    #line 530 
    if (((autoc_reg & 57344U) == 32768U || (autoc_reg & 57344U) == 49152U) || (autoc_reg & 57344U) == 57344U) {
      #line 536 
      links_reg = 0U;
      #line 537 
      i = 0U;
      #line 537 
      while (i <= 44U) {
        #line 538 
        links_reg = ixgbe_read_reg(hw,17060U);
        #line 539 
        if ((links_reg & 2147483648U) != 0U) 
                                             #line 540 
                                             break;
        #line 541 
        msleep(100U);
        #line 537 
        i ++;
      }
      #line 543 
      if ((links_reg & 2147483648U) == 0U) {
        #line 544 
        status = -14;
        {
          #line 545 
          bool branch;
          #line 545 
          struct _ddebug __UNIQUE_ID_ddebug444 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_start_mac_link_82599", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c", .format = (char *)"Autoneg did not complete.\n", .lineno = (unsigned int)545U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
          #line 545 
          branch = arch_static_branch(& __UNIQUE_ID_ddebug444.key.dd_key_false.key,(_Bool)0);
          #line 545 
          if ((long)((long)((int)branch != 0)) != 0L) 
                                                      #line 545 
                                                      __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug444,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Autoneg did not complete.\n");
        }
      }
    }
  }
  #line 551 
  msleep(50U);
  #line 553 
  return status;
}

#line 564  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static void ixgbe_disable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw)
{
  #line 566 
  u32 esdp_reg = ixgbe_read_reg(hw,32U);
  #line 569 
  if ((int)ixgbe_check_reset_blocked(hw) != 0) 
                                               #line 570 
                                               return;
  #line 573 
  esdp_reg |= 8U;
  #line 574 
  ixgbe_write_reg_7(hw,32U,esdp_reg);
  #line 575 
  ixgbe_read_reg(hw,8U);
  #line 576 
  __const_udelay(429500UL);
  #line 578 
  return;
}

#line 587  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static void ixgbe_enable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw)
{
  #line 589 
  u32 esdp_reg = ixgbe_read_reg(hw,32U);
  #line 592 
  esdp_reg &= 4294967287U;
  #line 593 
  ixgbe_write_reg_7(hw,32U,esdp_reg);
  #line 594 
  ixgbe_read_reg(hw,8U);
  #line 595 
  msleep(100U);
  #line 596 
  return;
}

#line 610  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static void ixgbe_flap_tx_laser_multispeed_fiber(struct ixgbe_hw *hw)
{
  #line 613 
  if ((int)ixgbe_check_reset_blocked(hw) != 0) 
                                               #line 614 
                                               return;
  #line 616 
  if ((int)hw->mac.autotry_restart != 0) {
    #line 617 
    ixgbe_disable_tx_laser_multispeed_fiber(hw);
    #line 618 
    ixgbe_enable_tx_laser_multispeed_fiber(hw);
    #line 619 
    hw->mac.autotry_restart = (_Bool)0;
  }
  #line 621 
  return;
}

#line 631  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static void ixgbe_set_hard_rate_select_speed(struct ixgbe_hw *hw, ixgbe_link_speed speed)
{
  #line 633 
  u32 esdp_reg = ixgbe_read_reg(hw,32U);
  #line 635 
  switch (speed) {
    #line 636 
    case (ixgbe_link_speed)128: 
                                #line 636 
    ;
    #line 637 
    esdp_reg |= 8224U;
    #line 638 
    break;
    #line 639 
    case (ixgbe_link_speed)32: 
                               #line 639 
    ;
    #line 640 
    esdp_reg &= 4294967263U;
    #line 641 
    esdp_reg |= 8192U;
    #line 642 
    break;
    #line 643 
    default: 
             #line 643 
    ;
    {
      #line 644 
      bool branch;
      #line 644 
      struct _ddebug __UNIQUE_ID_ddebug445 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_set_hard_rate_select_speed", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c", .format = (char *)"Invalid fixed module speed\n", .lineno = (unsigned int)644U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 644 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug445.key.dd_key_false.key,(_Bool)0);
      #line 644 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 644 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug445,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Invalid fixed module speed\n");
    }
    #line 645 
    return;
  }
  #line 648 
  ixgbe_write_reg_7(hw,32U,esdp_reg);
  #line 649 
  ixgbe_read_reg(hw,8U);
  #line 650 
  return;
}

#line 660  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_setup_mac_link_smartspeed(struct ixgbe_hw *hw, ixgbe_link_speed speed, bool autoneg_wait_to_complete)
{
  #line 666 
  s32 i;
  #line 666 
  s32 j;
  #line 664 
  s32 status = 0;
  #line 665 
  ixgbe_link_speed link_speed = 0U;
  #line 667 
  bool link_up = (_Bool)0;
  #line 668 
  u32 autoc_reg = ixgbe_read_reg(hw,17056U);
  #line 671 
  hw->phy.autoneg_advertised = 0U;
  #line 673 
  if ((speed & 128U) != 0U) 
                            #line 674 
                            hw->phy.autoneg_advertised |= 128U;
  #line 676 
  if ((speed & 32U) != 0U) 
                           #line 677 
                           hw->phy.autoneg_advertised |= 32U;
  #line 679 
  if ((speed & 8U) != 0U) 
                          #line 680 
                          hw->phy.autoneg_advertised |= 8U;
  #line 690 
  hw->phy.smart_speed_active = (_Bool)0;
  #line 691 
  j = 0;
  #line 691 
  while (j <= 2) {
    #line 692 
    status = ixgbe_setup_mac_link_82599(hw,speed,(_Bool)((bool)((int)autoneg_wait_to_complete) != 0));
    #line 694 
    if (status != 0) 
                     #line 695 
                     goto out;
    #line 703 
    i = 0;
    #line 703 
    while (i <= 4) {
      {
        #line 704 
        unsigned long __ms = 100UL;
        #line 704 
        while (1) {
          #line 704 
          unsigned long tmp_0;
          #line 704 
          tmp_0 = __ms;
          #line 704 
          __ms --;
          #line 704 
          ;
          #line 704 
          if (! (tmp_0 != 0UL)) 
                                #line 704 
                                break;
          #line 704 
          __const_udelay(4295000UL);
        }
      }
      #line 707 
      status = (*(hw->mac.ops.check_link))(hw,& link_speed,& link_up,(_Bool)0);
      #line 709 
      if (status != 0) 
                       #line 710 
                       goto out;
      #line 712 
      if ((int)link_up != 0) 
                             #line 713 
                             goto out;
      #line 703 
      i ++;
    }
    #line 691 
    j ++;
  }
  #line 721 
  if ((autoc_reg & 65536U) == 0U || (autoc_reg & 3221225472U) == 0U) 
    #line 723 
    goto out;
  #line 726 
  hw->phy.smart_speed_active = (_Bool)1;
  #line 727 
  status = ixgbe_setup_mac_link_82599(hw,speed,(_Bool)((bool)((int)autoneg_wait_to_complete) != 0));
  #line 729 
  if (status != 0) 
                   #line 730 
                   goto out;
  #line 738 
  i = 0;
  #line 738 
  while (i <= 5) {
    {
      #line 739 
      unsigned long __ms_0 = 100UL;
      #line 739 
      while (1) {
        #line 739 
        unsigned long tmp_1;
        #line 739 
        tmp_1 = __ms_0;
        #line 739 
        __ms_0 --;
        #line 739 
        ;
        #line 739 
        if (! (tmp_1 != 0UL)) 
                              #line 739 
                              break;
        #line 739 
        __const_udelay(4295000UL);
      }
    }
    #line 742 
    status = (*(hw->mac.ops.check_link))(hw,& link_speed,& link_up,(_Bool)0);
    #line 744 
    if (status != 0) 
                     #line 745 
                     goto out;
    #line 747 
    if ((int)link_up != 0) 
                           #line 748 
                           goto out;
    #line 738 
    i ++;
  }
  #line 752 
  hw->phy.smart_speed_active = (_Bool)0;
  #line 753 
  status = ixgbe_setup_mac_link_82599(hw,speed,(_Bool)((bool)((int)autoneg_wait_to_complete) != 0));
  #line 756 
  out: 
       #line 756 
  ;
  #line 757 
  if ((int)link_up != 0 && link_speed == 32U) {
    #line 758 
    bool branch;
    #line 758 
    struct _ddebug __UNIQUE_ID_ddebug446 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_setup_mac_link_smartspeed", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c", .format = (char *)"Smartspeed has downgraded the link speed from the maximum advertised\n", .lineno = (unsigned int)758U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 758 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug446.key.dd_key_false.key,(_Bool)0);
    #line 758 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 758 
                                                __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug446,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Smartspeed has downgraded the link speed from the maximum advertised\n");
  }
  #line 759 
  return status;
}

#line 770  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_setup_mac_link_82599(struct ixgbe_hw *hw, ixgbe_link_speed speed, bool autoneg_wait_to_complete)
{
  #line 775 
  s32 status;
  #line 776 
  u32 pma_pmd_1g;
  #line 776 
  u32 link_mode;
  #line 776 
  u32 links_reg;
  #line 776 
  u32 i;
  #line 774 
  bool autoneg = (_Bool)0;
  #line 777 
  u32 autoc2 = ixgbe_read_reg(hw,17064U);
  #line 778 
  u32 pma_pmd_10g_serial = autoc2 & 196608U;
  #line 779 
  ixgbe_link_speed link_capabilities = 0U;
  #line 782 
  u32 current_autoc = ixgbe_read_reg(hw,17056U);
  #line 784 
  u32 orig_autoc = 0U;
  #line 786 
  u32 autoc = current_autoc;
  #line 789 
  status = (*(hw->mac.ops.get_link_capabilities))(hw,& link_capabilities,& autoneg);
  #line 791 
  if (status != 0) 
                   #line 792 
                   return status;
  #line 794 
  speed &= link_capabilities;
  #line 796 
  if (speed == 0U) 
                   #line 797 
                   return -8;
  #line 800 
  if ((int)hw->mac.orig_link_settings_stored != 0) 
                                                   #line 801 
                                                   orig_autoc = hw->mac.orig_autoc; else 
                                                                    #line 803 
                                                                    orig_autoc = autoc;
  #line 805 
  link_mode = autoc & 57344U;
  #line 806 
  pma_pmd_1g = autoc & 512U;
  #line 808 
  if ((link_mode == 32768U || link_mode == 49152U) || link_mode == 57344U) {
    #line 812 
    autoc &= 1073676287U;
    #line 813 
    if ((speed & 128U) != 0U) {
      #line 814 
      if ((orig_autoc & 2147483648U) != 0U) 
                                            #line 815 
                                            autoc |= 2147483648U;
      #line 816 
      if ((orig_autoc & 65536U) != 0U && ! hw->phy.smart_speed_active) 
        #line 818 
        autoc |= 65536U;
    }
    #line 820 
    if ((speed & 32U) != 0U) 
                             #line 821 
                             autoc |= 1073741824U;
  }
  else 
    #line 822 
    if (pma_pmd_1g == 0U && (link_mode == 0U || link_mode == 16384U)) {
      #line 826 
      if (speed == 128U && pma_pmd_10g_serial == 131072U) {
        #line 828 
        autoc &= 4294909951U;
        #line 829 
        autoc |= 24576U;
      }
    }
    else 
      #line 831 
      if (pma_pmd_10g_serial == 131072U && link_mode == 24576U) 
        #line 834 
        if (speed == 32U && pma_pmd_1g == 0U) {
          #line 836 
          autoc &= 4294909951U;
          #line 837 
          if ((int)autoneg != 0) 
                                 #line 838 
                                 autoc |= 16384U; else 
                                                       #line 840 
                                                       autoc = autoc;
        }
  #line 844 
  if (autoc != current_autoc) {
    #line 846 
    status = (*(hw->mac.ops.prot_autoc_write))(hw,autoc,(_Bool)0);
    #line 847 
    if (status != 0) 
                     #line 848 
                     return status;
    #line 851 
    if ((int)autoneg_wait_to_complete != 0) 
      #line 852 
      if ((link_mode == 32768U || link_mode == 49152U) || link_mode == 57344U) {
        #line 855 
        links_reg = 0U;
        #line 856 
        i = 0U;
        #line 856 
        while (i <= 44U) {
          #line 857 
          links_reg = ixgbe_read_reg(hw,17060U);
          #line 859 
          if ((links_reg & 2147483648U) != 0U) 
                                               #line 860 
                                               break;
          #line 861 
          msleep(100U);
          #line 856 
          i ++;
        }
        #line 863 
        if ((links_reg & 2147483648U) == 0U) {
          #line 864 
          status = -14;
          {
            #line 866 
            bool branch;
            #line 866 
            struct _ddebug __UNIQUE_ID_ddebug447 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_setup_mac_link_82599", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c", .format = (char *)"Autoneg did not complete.\n", .lineno = (unsigned int)866U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
            #line 866 
            branch = arch_static_branch(& __UNIQUE_ID_ddebug447.key.dd_key_false.key,(_Bool)0);
            #line 866 
            if ((long)((long)((int)branch != 0)) != 0L) 
                                                        #line 866 
                                                        __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug447,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Autoneg did not complete.\n");
          }
        }
      }
    #line 872 
    msleep(50U);
  }
  #line 875 
  return status;
}

#line 886  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_setup_copper_link_82599(struct ixgbe_hw *hw, ixgbe_link_speed speed, bool autoneg_wait_to_complete)
{
  #line 890 
  s32 status;
  #line 893 
  status = (*(hw->phy.ops.setup_link_speed))(hw,speed,(_Bool)((bool)((int)autoneg_wait_to_complete) != 0));
  #line 896 
  ixgbe_start_mac_link_82599(hw,(_Bool)((bool)((int)autoneg_wait_to_complete) != 0));
  #line 898 
  return status;
}

#line 909  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_reset_hw_82599(struct ixgbe_hw *hw)
{
  #line 911 
  ixgbe_link_speed link_speed;
  #line 912 
  s32 status;
  #line 913 
  u32 ctrl;
  #line 913 
  u32 i;
  #line 913 
  u32 autoc;
  #line 913 
  u32 autoc2;
  #line 914 
  u32 curr_lms;
  #line 915 
  bool link_up = (_Bool)0;
  #line 918 
  status = (*(hw->mac.ops.stop_adapter))(hw);
  #line 919 
  if (status != 0) 
                   #line 920 
                   return status;
  #line 923 
  ixgbe_clear_tx_pending(hw);
  #line 928 
  status = (*(hw->phy.ops.init))(hw);
  #line 930 
  if (status == -19) 
                     #line 931 
                     return status;
  #line 934 
  if ((int)hw->phy.sfp_setup_needed != 0) {
    #line 935 
    status = (*(hw->mac.ops.setup_sfp))(hw);
    #line 936 
    hw->phy.sfp_setup_needed = (_Bool)0;
  }
  #line 939 
  if (status == -19) 
                     #line 940 
                     return status;
  #line 943 
  if (! hw->phy.reset_disable && hw->phy.ops.reset != (s32 (*)(struct ixgbe_hw *))0) 
    #line 944 
    (*(hw->phy.ops.reset))(hw);
  #line 947 
  curr_lms = ixgbe_read_reg(hw,17056U) & 57344U;
  #line 949 
  mac_reset_top: 
                 #line 949 
  ;
  #line 956 
  ctrl = 8U;
  #line 957 
  if (! hw->force_full_reset) {
    #line 958 
    (*(hw->mac.ops.check_link))(hw,& link_speed,& link_up,(_Bool)0);
    #line 959 
    if ((int)link_up != 0) 
                           #line 960 
                           ctrl = 67108864U;
  }
  #line 963 
  ctrl = ixgbe_read_reg(hw,0U) | ctrl;
  #line 964 
  ixgbe_write_reg_7(hw,0U,ctrl);
  #line 965 
  ixgbe_read_reg(hw,8U);
  #line 966 
  usleep_range(1000UL,1200UL);
  #line 969 
  i = 0U;
  #line 969 
  while (i <= 9U) {
    #line 970 
    ctrl = ixgbe_read_reg(hw,0U);
    #line 971 
    if ((ctrl & 67108872U) == 0U) 
                                  #line 972 
                                  break;
    #line 973 
    __const_udelay(4295UL);
    #line 969 
    i ++;
  }
  #line 976 
  if ((ctrl & 67108872U) != 0U) {
    #line 977 
    status = -15;
    {
      #line 978 
      bool branch;
      #line 978 
      struct _ddebug __UNIQUE_ID_ddebug448 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_reset_hw_82599", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c", .format = (char *)"Reset polling failed to complete.\n", .lineno = (unsigned int)978U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 978 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug448.key.dd_key_false.key,(_Bool)0);
      #line 978 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 978 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug448,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Reset polling failed to complete.\n");
    }
  }
  #line 981 
  msleep(50U);
  #line 988 
  if (((int)hw->mac.flags & 1) != 0) {
    #line 989 
    hw->mac.flags = (unsigned char)((unsigned int)hw->mac.flags & 254U);
    #line 990 
    goto mac_reset_top;
  }
  #line 998 
  autoc = ixgbe_read_reg(hw,17056U);
  #line 999 
  autoc2 = ixgbe_read_reg(hw,17064U);
  #line 1002 
  if ((autoc2 & 1879048192U) != 0U) {
    #line 1003 
    autoc2 &= 2415919103U;
    #line 1004 
    ixgbe_write_reg_7(hw,17064U,autoc2);
    #line 1005 
    ixgbe_read_reg(hw,8U);
  }
  #line 1008 
  if (! hw->mac.orig_link_settings_stored) {
    #line 1009 
    hw->mac.orig_autoc = autoc;
    #line 1010 
    hw->mac.orig_autoc2 = autoc2;
    #line 1011 
    hw->mac.orig_link_settings_stored = (_Bool)1;
  }
  else {
    #line 1020 
    if ((int)hw->phy.multispeed_fiber != 0) {
      #line 1020 
      if ((int)ixgbe_mng_enabled(hw) != 0) 
                                           #line 1022 
                                           hw->mac.orig_autoc = (hw->mac.orig_autoc & 4294909951U) | curr_lms; else 
                                                                    #line 1020 
                                                                    goto _LAND;
    }
    else {
      #line 1020 
      _LAND: 
             #line 1020 
      ;
      #line 1020 
      if ((int)hw->wol_enabled != 0) 
                                     #line 1022 
                                     hw->mac.orig_autoc = (hw->mac.orig_autoc & 4294909951U) | curr_lms;
    }
    #line 1026 
    if (hw->mac.orig_autoc != autoc) {
      #line 1027 
      status = (*(hw->mac.ops.prot_autoc_write))(hw,hw->mac.orig_autoc,(_Bool)0);
      #line 1030 
      if (status != 0) 
                       #line 1031 
                       return status;
    }
    #line 1034 
    if (((hw->mac.orig_autoc2 ^ autoc2) & 4294901760U) != 0U) {
      #line 1036 
      autoc2 &= 65535U;
      #line 1037 
      autoc2 = (hw->mac.orig_autoc2 & 4294901760U) | autoc2;
      #line 1039 
      ixgbe_write_reg_7(hw,17064U,autoc2);
    }
  }
  #line 1044 
  (*(hw->mac.ops.get_mac_addr))(hw,(u8 *)(& hw->mac.perm_addr));
  #line 1051 
  hw->mac.num_rar_entries = 128U;
  #line 1052 
  (*(hw->mac.ops.init_rx_addrs))(hw);
  #line 1055 
  (*(hw->mac.ops.get_san_mac_addr))(hw,(u8 *)(& hw->mac.san_addr));
  #line 1058 
  if ((int)is_valid_ether_addr((u8 *)(& hw->mac.san_addr)) != 0) {
    #line 1060 
    hw->mac.san_mac_rar_index = (unsigned char)((unsigned int)((unsigned char)hw->mac.num_rar_entries) + 255U);
    #line 1062 
    (*(hw->mac.ops.set_rar))(hw,(unsigned int)hw->mac.san_mac_rar_index,(u8 *)(& hw->mac.san_addr),0U,2147483648U);
    #line 1066 
    (*(hw->mac.ops.clear_vmdq))(hw,(unsigned int)hw->mac.san_mac_rar_index,4294967295U);
    #line 1070 
    (hw->mac.num_rar_entries) --;
  }
  #line 1074 
  (*(hw->mac.ops.get_wwn_prefix))(hw,& hw->mac.wwnn_prefix,& hw->mac.wwpn_prefix);
  #line 1077 
  return status;
}

#line 1085  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_fdir_check_cmd_complete(struct ixgbe_hw *hw, u32 *fdircmd)
{
  #line 1087 
  int i;
  #line 1089 
  i = 0;
  #line 1089 
  while (i <= 9) {
    #line 1090 
    *fdircmd = ixgbe_read_reg(hw,60972U);
    #line 1091 
    if ((*fdircmd & 3U) == 0U) 
                               #line 1092 
                               return 0;
    #line 1093 
    __const_udelay(42950UL);
    #line 1089 
    i ++;
  }
  #line 1096 
  return -38;
}

#line 1103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
s32 ixgbe_reinit_fdir_tables_82599(struct ixgbe_hw *hw)
{
  #line 1105 
  int i;
  #line 1107 
  u32 fdircmd;
  #line 1108 
  s32 err;
  #line 1106 
  u32 fdirctrl = ixgbe_read_reg(hw,60928U);
  #line 1110 
  fdirctrl &= 4294967287U;
  #line 1116 
  err = ixgbe_fdir_check_cmd_complete(hw,& fdircmd);
  #line 1117 
  if (err != 0) {
    {
      #line 1118 
      bool branch;
      #line 1118 
      struct _ddebug __UNIQUE_ID_ddebug449 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_reinit_fdir_tables_82599", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c", .format = (char *)"Flow Director previous command did not complete, aborting table re-initialization.\n", .lineno = (unsigned int)1118U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1118 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug449.key.dd_key_false.key,(_Bool)0);
      #line 1118 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 1118 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug449,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Flow Director previous command did not complete, aborting table re-initialization.\n");
    }
    #line 1119 
    return err;
  }
  #line 1122 
  ixgbe_write_reg_7(hw,60984U,0U);
  #line 1123 
  ixgbe_read_reg(hw,8U);
  #line 1131 
  ;
  #line 1131 
  ixgbe_write_reg_7(hw,60972U,ixgbe_read_reg(hw,60972U) | 256U);
  #line 1134 
  ixgbe_read_reg(hw,8U);
  #line 1135 
  ;
  #line 1135 
  ixgbe_write_reg_7(hw,60972U,ixgbe_read_reg(hw,60972U) & 4294967039U);
  #line 1138 
  ixgbe_read_reg(hw,8U);
  #line 1143 
  ixgbe_write_reg_7(hw,60968U,0U);
  #line 1144 
  ixgbe_read_reg(hw,8U);
  #line 1146 
  ixgbe_write_reg_7(hw,60928U,fdirctrl);
  #line 1147 
  ixgbe_read_reg(hw,8U);
  #line 1150 
  i = 0;
  #line 1150 
  while (i <= 9) {
    {
      #line 1151 
      if ((ixgbe_read_reg(hw,60928U) & 8U) != 0U) 
                                                  #line 1153 
                                                  break;
      #line 1154 
      usleep_range(1000UL,2000UL);
    }
    #line 1150 
    i ++;
  }
  #line 1156 
  if (i > 9) {
    {
      #line 1157 
      bool branch_0;
      #line 1157 
      struct _ddebug __UNIQUE_ID_ddebug450 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_reinit_fdir_tables_82599", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c", .format = (char *)"Flow Director Signature poll time exceeded!\n", .lineno = (unsigned int)1157U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1157 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug450.key.dd_key_false.key,(_Bool)0);
      #line 1157 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 1157 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug450,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Flow Director Signature poll time exceeded!\n");
    }
    #line 1158 
    return -23;
  }
  #line 1162 
  ixgbe_read_reg(hw,61008U);
  #line 1163 
  ixgbe_read_reg(hw,61012U);
  #line 1164 
  ixgbe_read_reg(hw,61016U);
  #line 1165 
  ixgbe_read_reg(hw,61020U);
  #line 1166 
  ixgbe_read_reg(hw,61004U);
  #line 1168 
  return 0;
}

#line 1176  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static void ixgbe_fdir_enable_82599(struct ixgbe_hw *hw, u32 fdirctrl)
{
  #line 1178 
  int i;
  #line 1181 
  ixgbe_write_reg_7(hw,61032U,1034753250U);
  #line 1182 
  ixgbe_write_reg_7(hw,61036U,390936084U);
  #line 1197 
  ixgbe_write_reg_7(hw,60928U,fdirctrl);
  #line 1198 
  ixgbe_read_reg(hw,8U);
  #line 1199 
  i = 0;
  #line 1199 
  while (i <= 9) {
    {
      #line 1200 
      if ((ixgbe_read_reg(hw,60928U) & 8U) != 0U) 
                                                  #line 1202 
                                                  break;
      #line 1203 
      usleep_range(1000UL,2000UL);
    }
    #line 1199 
    i ++;
  }
  #line 1206 
  if (i > 9) {
    #line 1207 
    bool branch;
    #line 1207 
    struct _ddebug __UNIQUE_ID_ddebug451 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_fdir_enable_82599", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c", .format = (char *)"Flow Director poll time exceeded!\n", .lineno = (unsigned int)1207U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 1207 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug451.key.dd_key_false.key,(_Bool)0);
    #line 1207 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 1207 
                                                __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug451,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Flow Director poll time exceeded!\n");
  }
  #line 1209 
  return;
}

#line 1216  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
s32 ixgbe_init_fdir_signature_82599(struct ixgbe_hw *hw, u32 fdirctrl)
{
  #line 1224 
  fdirctrl |= 1241907200U;
  #line 1229 
  ixgbe_fdir_enable_82599(hw,fdirctrl);
  #line 1231 
  return 0;
}

#line 1240  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
s32 ixgbe_init_fdir_perfect_82599(struct ixgbe_hw *hw, u32 fdirctrl)
{
  #line 1250 
  fdirctrl |= 1241939728U;
  #line 1257 
  ixgbe_fdir_enable_82599(hw,fdirctrl);
  #line 1259 
  return 0;
}

#line 1297  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static u32 ixgbe_atr_compute_sig_hash_82599(union ixgbe_atr_hash_dword input, union ixgbe_atr_hash_dword common)
{
  #line 1300 
  u32 hi_hash_dword;
  #line 1300 
  u32 lo_hash_dword;
  #line 1300 
  u32 flow_vm_vlan;
  #line 1301 
  u32 sig_hash = 0U;
  #line 1301 
  u32 bucket_hash = 0U;
  #line 1301 
  u32 common_hash = 0U;
  #line 1304 
  flow_vm_vlan = __builtin_bswap32(input.dword);
  #line 1307 
  hi_hash_dword = __builtin_bswap32(common.dword);
  #line 1310 
  lo_hash_dword = (hi_hash_dword << 16) | (hi_hash_dword << ((unsigned long)8 * sizeof(hi_hash_dword) - (unsigned long)16));
  #line 1313 
  hi_hash_dword = ((flow_vm_vlan >> 16) ^ flow_vm_vlan) ^ hi_hash_dword;
  {
    #line 1316 
    u32 n = 0U;
    #line 1316 
    if (((353178624UL >> n) & 1UL) != 0UL) 
                                           #line 1316 
                                           common_hash = (lo_hash_dword >> n) ^ common_hash;
    else 
      #line 1316 
      if (((1034753250UL >> n) & 1UL) != 0UL) 
                                              #line 1316 
                                              bucket_hash = (lo_hash_dword >> n) ^ bucket_hash;
      else 
        #line 1316 
        if (((390936084UL >> n) & 1UL) != 0UL) 
                                               #line 1316 
                                               sig_hash = (lo_hash_dword << (16U - n)) ^ sig_hash;
    #line 1316 
    if (((353178624UL >> (n + 16U)) & 1UL) != 0UL) 
                                                   #line 1316 
                                                   common_hash = (hi_hash_dword >> n) ^ common_hash;
    else 
      #line 1316 
      if (((1034753250UL >> (n + 16U)) & 1UL) != 0UL) 
                                                      #line 1316 
                                                      bucket_hash = (hi_hash_dword >> n) ^ bucket_hash;
      else 
        #line 1316 
        if (((390936084UL >> (n + 16U)) & 1UL) != 0UL) 
                                                       #line 1316 
                                                       sig_hash = (hi_hash_dword << (16U - n)) ^ sig_hash;
  }
  #line 1323 
  lo_hash_dword = ((flow_vm_vlan << 16) ^ flow_vm_vlan) ^ lo_hash_dword;
  {
    #line 1326 
    u32 n_0 = 1U;
    #line 1326 
    if (((353178624UL >> n_0) & 1UL) != 0UL) 
                                             #line 1326 
                                             common_hash = (lo_hash_dword >> n_0) ^ common_hash;
    else 
      #line 1326 
      if (((1034753250UL >> n_0) & 1UL) != 0UL) 
                                                #line 1326 
                                                bucket_hash = (lo_hash_dword >> n_0) ^ bucket_hash;
      else 
        #line 1326 
        if (((390936084UL >> n_0) & 1UL) != 0UL) 
                                                 #line 1326 
                                                 sig_hash = (lo_hash_dword << (16U - n_0)) ^ sig_hash;
    #line 1326 
    if (((353178624UL >> (n_0 + 16U)) & 1UL) != 0UL) 
                                                     #line 1326 
                                                     common_hash = (hi_hash_dword >> n_0) ^ common_hash;
    else 
      #line 1326 
      if (((1034753250UL >> (n_0 + 16U)) & 1UL) != 0UL) 
                                                        #line 1326 
                                                        bucket_hash = (hi_hash_dword >> n_0) ^ bucket_hash;
      else 
        #line 1326 
        if (((390936084UL >> (n_0 + 16U)) & 1UL) != 0UL) 
                                                         #line 1326 
                                                         sig_hash = (hi_hash_dword << (16U - n_0)) ^ sig_hash;
  }
  {
    #line 1327 
    u32 n_1 = 2U;
    #line 1327 
    if (((353178624UL >> n_1) & 1UL) != 0UL) 
                                             #line 1327 
                                             common_hash = (lo_hash_dword >> n_1) ^ common_hash;
    else 
      #line 1327 
      if (((1034753250UL >> n_1) & 1UL) != 0UL) 
                                                #line 1327 
                                                bucket_hash = (lo_hash_dword >> n_1) ^ bucket_hash;
      else 
        #line 1327 
        if (((390936084UL >> n_1) & 1UL) != 0UL) 
                                                 #line 1327 
                                                 sig_hash = (lo_hash_dword << (16U - n_1)) ^ sig_hash;
    #line 1327 
    if (((353178624UL >> (n_1 + 16U)) & 1UL) != 0UL) 
                                                     #line 1327 
                                                     common_hash = (hi_hash_dword >> n_1) ^ common_hash;
    else 
      #line 1327 
      if (((1034753250UL >> (n_1 + 16U)) & 1UL) != 0UL) 
                                                        #line 1327 
                                                        bucket_hash = (hi_hash_dword >> n_1) ^ bucket_hash;
      else 
        #line 1327 
        if (((390936084UL >> (n_1 + 16U)) & 1UL) != 0UL) 
                                                         #line 1327 
                                                         sig_hash = (hi_hash_dword << (16U - n_1)) ^ sig_hash;
  }
  {
    #line 1328 
    u32 n_2 = 3U;
    #line 1328 
    if (((353178624UL >> n_2) & 1UL) != 0UL) 
                                             #line 1328 
                                             common_hash = (lo_hash_dword >> n_2) ^ common_hash;
    else 
      #line 1328 
      if (((1034753250UL >> n_2) & 1UL) != 0UL) 
                                                #line 1328 
                                                bucket_hash = (lo_hash_dword >> n_2) ^ bucket_hash;
      else 
        #line 1328 
        if (((390936084UL >> n_2) & 1UL) != 0UL) 
                                                 #line 1328 
                                                 sig_hash = (lo_hash_dword << (16U - n_2)) ^ sig_hash;
    #line 1328 
    if (((353178624UL >> (n_2 + 16U)) & 1UL) != 0UL) 
                                                     #line 1328 
                                                     common_hash = (hi_hash_dword >> n_2) ^ common_hash;
    else 
      #line 1328 
      if (((1034753250UL >> (n_2 + 16U)) & 1UL) != 0UL) 
                                                        #line 1328 
                                                        bucket_hash = (hi_hash_dword >> n_2) ^ bucket_hash;
      else 
        #line 1328 
        if (((390936084UL >> (n_2 + 16U)) & 1UL) != 0UL) 
                                                         #line 1328 
                                                         sig_hash = (hi_hash_dword << (16U - n_2)) ^ sig_hash;
  }
  {
    #line 1329 
    u32 n_3 = 4U;
    #line 1329 
    if (((353178624UL >> n_3) & 1UL) != 0UL) 
                                             #line 1329 
                                             common_hash = (lo_hash_dword >> n_3) ^ common_hash;
    else 
      #line 1329 
      if (((1034753250UL >> n_3) & 1UL) != 0UL) 
                                                #line 1329 
                                                bucket_hash = (lo_hash_dword >> n_3) ^ bucket_hash;
      else 
        #line 1329 
        if (((390936084UL >> n_3) & 1UL) != 0UL) 
                                                 #line 1329 
                                                 sig_hash = (lo_hash_dword << (16U - n_3)) ^ sig_hash;
    #line 1329 
    if (((353178624UL >> (n_3 + 16U)) & 1UL) != 0UL) 
                                                     #line 1329 
                                                     common_hash = (hi_hash_dword >> n_3) ^ common_hash;
    else 
      #line 1329 
      if (((1034753250UL >> (n_3 + 16U)) & 1UL) != 0UL) 
                                                        #line 1329 
                                                        bucket_hash = (hi_hash_dword >> n_3) ^ bucket_hash;
      else 
        #line 1329 
        if (((390936084UL >> (n_3 + 16U)) & 1UL) != 0UL) 
                                                         #line 1329 
                                                         sig_hash = (hi_hash_dword << (16U - n_3)) ^ sig_hash;
  }
  {
    #line 1330 
    u32 n_4 = 5U;
    #line 1330 
    if (((353178624UL >> n_4) & 1UL) != 0UL) 
                                             #line 1330 
                                             common_hash = (lo_hash_dword >> n_4) ^ common_hash;
    else 
      #line 1330 
      if (((1034753250UL >> n_4) & 1UL) != 0UL) 
                                                #line 1330 
                                                bucket_hash = (lo_hash_dword >> n_4) ^ bucket_hash;
      else 
        #line 1330 
        if (((390936084UL >> n_4) & 1UL) != 0UL) 
                                                 #line 1330 
                                                 sig_hash = (lo_hash_dword << (16U - n_4)) ^ sig_hash;
    #line 1330 
    if (((353178624UL >> (n_4 + 16U)) & 1UL) != 0UL) 
                                                     #line 1330 
                                                     common_hash = (hi_hash_dword >> n_4) ^ common_hash;
    else 
      #line 1330 
      if (((1034753250UL >> (n_4 + 16U)) & 1UL) != 0UL) 
                                                        #line 1330 
                                                        bucket_hash = (hi_hash_dword >> n_4) ^ bucket_hash;
      else 
        #line 1330 
        if (((390936084UL >> (n_4 + 16U)) & 1UL) != 0UL) 
                                                         #line 1330 
                                                         sig_hash = (hi_hash_dword << (16U - n_4)) ^ sig_hash;
  }
  {
    #line 1331 
    u32 n_5 = 6U;
    #line 1331 
    if (((353178624UL >> n_5) & 1UL) != 0UL) 
                                             #line 1331 
                                             common_hash = (lo_hash_dword >> n_5) ^ common_hash;
    else 
      #line 1331 
      if (((1034753250UL >> n_5) & 1UL) != 0UL) 
                                                #line 1331 
                                                bucket_hash = (lo_hash_dword >> n_5) ^ bucket_hash;
      else 
        #line 1331 
        if (((390936084UL >> n_5) & 1UL) != 0UL) 
                                                 #line 1331 
                                                 sig_hash = (lo_hash_dword << (16U - n_5)) ^ sig_hash;
    #line 1331 
    if (((353178624UL >> (n_5 + 16U)) & 1UL) != 0UL) 
                                                     #line 1331 
                                                     common_hash = (hi_hash_dword >> n_5) ^ common_hash;
    else 
      #line 1331 
      if (((1034753250UL >> (n_5 + 16U)) & 1UL) != 0UL) 
                                                        #line 1331 
                                                        bucket_hash = (hi_hash_dword >> n_5) ^ bucket_hash;
      else 
        #line 1331 
        if (((390936084UL >> (n_5 + 16U)) & 1UL) != 0UL) 
                                                         #line 1331 
                                                         sig_hash = (hi_hash_dword << (16U - n_5)) ^ sig_hash;
  }
  {
    #line 1332 
    u32 n_6 = 7U;
    #line 1332 
    if (((353178624UL >> n_6) & 1UL) != 0UL) 
                                             #line 1332 
                                             common_hash = (lo_hash_dword >> n_6) ^ common_hash;
    else 
      #line 1332 
      if (((1034753250UL >> n_6) & 1UL) != 0UL) 
                                                #line 1332 
                                                bucket_hash = (lo_hash_dword >> n_6) ^ bucket_hash;
      else 
        #line 1332 
        if (((390936084UL >> n_6) & 1UL) != 0UL) 
                                                 #line 1332 
                                                 sig_hash = (lo_hash_dword << (16U - n_6)) ^ sig_hash;
    #line 1332 
    if (((353178624UL >> (n_6 + 16U)) & 1UL) != 0UL) 
                                                     #line 1332 
                                                     common_hash = (hi_hash_dword >> n_6) ^ common_hash;
    else 
      #line 1332 
      if (((1034753250UL >> (n_6 + 16U)) & 1UL) != 0UL) 
                                                        #line 1332 
                                                        bucket_hash = (hi_hash_dword >> n_6) ^ bucket_hash;
      else 
        #line 1332 
        if (((390936084UL >> (n_6 + 16U)) & 1UL) != 0UL) 
                                                         #line 1332 
                                                         sig_hash = (hi_hash_dword << (16U - n_6)) ^ sig_hash;
  }
  {
    #line 1333 
    u32 n_7 = 8U;
    #line 1333 
    if (((353178624UL >> n_7) & 1UL) != 0UL) 
                                             #line 1333 
                                             common_hash = (lo_hash_dword >> n_7) ^ common_hash;
    else 
      #line 1333 
      if (((1034753250UL >> n_7) & 1UL) != 0UL) 
                                                #line 1333 
                                                bucket_hash = (lo_hash_dword >> n_7) ^ bucket_hash;
      else 
        #line 1333 
        if (((390936084UL >> n_7) & 1UL) != 0UL) 
                                                 #line 1333 
                                                 sig_hash = (lo_hash_dword << (16U - n_7)) ^ sig_hash;
    #line 1333 
    if (((353178624UL >> (n_7 + 16U)) & 1UL) != 0UL) 
                                                     #line 1333 
                                                     common_hash = (hi_hash_dword >> n_7) ^ common_hash;
    else 
      #line 1333 
      if (((1034753250UL >> (n_7 + 16U)) & 1UL) != 0UL) 
                                                        #line 1333 
                                                        bucket_hash = (hi_hash_dword >> n_7) ^ bucket_hash;
      else 
        #line 1333 
        if (((390936084UL >> (n_7 + 16U)) & 1UL) != 0UL) 
                                                         #line 1333 
                                                         sig_hash = (hi_hash_dword << (16U - n_7)) ^ sig_hash;
  }
  {
    #line 1334 
    u32 n_8 = 9U;
    #line 1334 
    if (((353178624UL >> n_8) & 1UL) != 0UL) 
                                             #line 1334 
                                             common_hash = (lo_hash_dword >> n_8) ^ common_hash;
    else 
      #line 1334 
      if (((1034753250UL >> n_8) & 1UL) != 0UL) 
                                                #line 1334 
                                                bucket_hash = (lo_hash_dword >> n_8) ^ bucket_hash;
      else 
        #line 1334 
        if (((390936084UL >> n_8) & 1UL) != 0UL) 
                                                 #line 1334 
                                                 sig_hash = (lo_hash_dword << (16U - n_8)) ^ sig_hash;
    #line 1334 
    if (((353178624UL >> (n_8 + 16U)) & 1UL) != 0UL) 
                                                     #line 1334 
                                                     common_hash = (hi_hash_dword >> n_8) ^ common_hash;
    else 
      #line 1334 
      if (((1034753250UL >> (n_8 + 16U)) & 1UL) != 0UL) 
                                                        #line 1334 
                                                        bucket_hash = (hi_hash_dword >> n_8) ^ bucket_hash;
      else 
        #line 1334 
        if (((390936084UL >> (n_8 + 16U)) & 1UL) != 0UL) 
                                                         #line 1334 
                                                         sig_hash = (hi_hash_dword << (16U - n_8)) ^ sig_hash;
  }
  {
    #line 1335 
    u32 n_9 = 10U;
    #line 1335 
    if (((353178624UL >> n_9) & 1UL) != 0UL) 
                                             #line 1335 
                                             common_hash = (lo_hash_dword >> n_9) ^ common_hash;
    else 
      #line 1335 
      if (((1034753250UL >> n_9) & 1UL) != 0UL) 
                                                #line 1335 
                                                bucket_hash = (lo_hash_dword >> n_9) ^ bucket_hash;
      else 
        #line 1335 
        if (((390936084UL >> n_9) & 1UL) != 0UL) 
                                                 #line 1335 
                                                 sig_hash = (lo_hash_dword << (16U - n_9)) ^ sig_hash;
    #line 1335 
    if (((353178624UL >> (n_9 + 16U)) & 1UL) != 0UL) 
                                                     #line 1335 
                                                     common_hash = (hi_hash_dword >> n_9) ^ common_hash;
    else 
      #line 1335 
      if (((1034753250UL >> (n_9 + 16U)) & 1UL) != 0UL) 
                                                        #line 1335 
                                                        bucket_hash = (hi_hash_dword >> n_9) ^ bucket_hash;
      else 
        #line 1335 
        if (((390936084UL >> (n_9 + 16U)) & 1UL) != 0UL) 
                                                         #line 1335 
                                                         sig_hash = (hi_hash_dword << (16U - n_9)) ^ sig_hash;
  }
  {
    #line 1336 
    u32 n_10 = 11U;
    #line 1336 
    if (((353178624UL >> n_10) & 1UL) != 0UL) 
                                              #line 1336 
                                              common_hash = (lo_hash_dword >> n_10) ^ common_hash;
    else 
      #line 1336 
      if (((1034753250UL >> n_10) & 1UL) != 0UL) 
                                                 #line 1336 
                                                 bucket_hash = (lo_hash_dword >> n_10) ^ bucket_hash;
      else 
        #line 1336 
        if (((390936084UL >> n_10) & 1UL) != 0UL) 
                                                  #line 1336 
                                                  sig_hash = (lo_hash_dword << (16U - n_10)) ^ sig_hash;
    #line 1336 
    if (((353178624UL >> (n_10 + 16U)) & 1UL) != 0UL) 
                                                      #line 1336 
                                                      common_hash = (hi_hash_dword >> n_10) ^ common_hash;
    else 
      #line 1336 
      if (((1034753250UL >> (n_10 + 16U)) & 1UL) != 0UL) 
                                                         #line 1336 
                                                         bucket_hash = (hi_hash_dword >> n_10) ^ bucket_hash;
      else 
        #line 1336 
        if (((390936084UL >> (n_10 + 16U)) & 1UL) != 0UL) 
                                                          #line 1336 
                                                          sig_hash = (hi_hash_dword << (16U - n_10)) ^ sig_hash;
  }
  {
    #line 1337 
    u32 n_11 = 12U;
    #line 1337 
    if (((353178624UL >> n_11) & 1UL) != 0UL) 
                                              #line 1337 
                                              common_hash = (lo_hash_dword >> n_11) ^ common_hash;
    else 
      #line 1337 
      if (((1034753250UL >> n_11) & 1UL) != 0UL) 
                                                 #line 1337 
                                                 bucket_hash = (lo_hash_dword >> n_11) ^ bucket_hash;
      else 
        #line 1337 
        if (((390936084UL >> n_11) & 1UL) != 0UL) 
                                                  #line 1337 
                                                  sig_hash = (lo_hash_dword << (16U - n_11)) ^ sig_hash;
    #line 1337 
    if (((353178624UL >> (n_11 + 16U)) & 1UL) != 0UL) 
                                                      #line 1337 
                                                      common_hash = (hi_hash_dword >> n_11) ^ common_hash;
    else 
      #line 1337 
      if (((1034753250UL >> (n_11 + 16U)) & 1UL) != 0UL) 
                                                         #line 1337 
                                                         bucket_hash = (hi_hash_dword >> n_11) ^ bucket_hash;
      else 
        #line 1337 
        if (((390936084UL >> (n_11 + 16U)) & 1UL) != 0UL) 
                                                          #line 1337 
                                                          sig_hash = (hi_hash_dword << (16U - n_11)) ^ sig_hash;
  }
  {
    #line 1338 
    u32 n_12 = 13U;
    #line 1338 
    if (((353178624UL >> n_12) & 1UL) != 0UL) 
                                              #line 1338 
                                              common_hash = (lo_hash_dword >> n_12) ^ common_hash;
    else 
      #line 1338 
      if (((1034753250UL >> n_12) & 1UL) != 0UL) 
                                                 #line 1338 
                                                 bucket_hash = (lo_hash_dword >> n_12) ^ bucket_hash;
      else 
        #line 1338 
        if (((390936084UL >> n_12) & 1UL) != 0UL) 
                                                  #line 1338 
                                                  sig_hash = (lo_hash_dword << (16U - n_12)) ^ sig_hash;
    #line 1338 
    if (((353178624UL >> (n_12 + 16U)) & 1UL) != 0UL) 
                                                      #line 1338 
                                                      common_hash = (hi_hash_dword >> n_12) ^ common_hash;
    else 
      #line 1338 
      if (((1034753250UL >> (n_12 + 16U)) & 1UL) != 0UL) 
                                                         #line 1338 
                                                         bucket_hash = (hi_hash_dword >> n_12) ^ bucket_hash;
      else 
        #line 1338 
        if (((390936084UL >> (n_12 + 16U)) & 1UL) != 0UL) 
                                                          #line 1338 
                                                          sig_hash = (hi_hash_dword << (16U - n_12)) ^ sig_hash;
  }
  {
    #line 1339 
    u32 n_13 = 14U;
    #line 1339 
    if (((353178624UL >> n_13) & 1UL) != 0UL) 
                                              #line 1339 
                                              common_hash = (lo_hash_dword >> n_13) ^ common_hash;
    else 
      #line 1339 
      if (((1034753250UL >> n_13) & 1UL) != 0UL) 
                                                 #line 1339 
                                                 bucket_hash = (lo_hash_dword >> n_13) ^ bucket_hash;
      else 
        #line 1339 
        if (((390936084UL >> n_13) & 1UL) != 0UL) 
                                                  #line 1339 
                                                  sig_hash = (lo_hash_dword << (16U - n_13)) ^ sig_hash;
    #line 1339 
    if (((353178624UL >> (n_13 + 16U)) & 1UL) != 0UL) 
                                                      #line 1339 
                                                      common_hash = (hi_hash_dword >> n_13) ^ common_hash;
    else 
      #line 1339 
      if (((1034753250UL >> (n_13 + 16U)) & 1UL) != 0UL) 
                                                         #line 1339 
                                                         bucket_hash = (hi_hash_dword >> n_13) ^ bucket_hash;
      else 
        #line 1339 
        if (((390936084UL >> (n_13 + 16U)) & 1UL) != 0UL) 
                                                          #line 1339 
                                                          sig_hash = (hi_hash_dword << (16U - n_13)) ^ sig_hash;
  }
  {
    #line 1340 
    u32 n_14 = 15U;
    #line 1340 
    if (((353178624UL >> n_14) & 1UL) != 0UL) 
                                              #line 1340 
                                              common_hash = (lo_hash_dword >> n_14) ^ common_hash;
    else 
      #line 1340 
      if (((1034753250UL >> n_14) & 1UL) != 0UL) 
                                                 #line 1340 
                                                 bucket_hash = (lo_hash_dword >> n_14) ^ bucket_hash;
      else 
        #line 1340 
        if (((390936084UL >> n_14) & 1UL) != 0UL) 
                                                  #line 1340 
                                                  sig_hash = (lo_hash_dword << (16U - n_14)) ^ sig_hash;
    #line 1340 
    if (((353178624UL >> (n_14 + 16U)) & 1UL) != 0UL) 
                                                      #line 1340 
                                                      common_hash = (hi_hash_dword >> n_14) ^ common_hash;
    else 
      #line 1340 
      if (((1034753250UL >> (n_14 + 16U)) & 1UL) != 0UL) 
                                                         #line 1340 
                                                         bucket_hash = (hi_hash_dword >> n_14) ^ bucket_hash;
      else 
        #line 1340 
        if (((390936084UL >> (n_14 + 16U)) & 1UL) != 0UL) 
                                                          #line 1340 
                                                          sig_hash = (hi_hash_dword << (16U - n_14)) ^ sig_hash;
  }
  #line 1343 
  bucket_hash ^= common_hash;
  #line 1344 
  bucket_hash &= 32767U;
  #line 1346 
  sig_hash = (common_hash << 16) ^ sig_hash;
  #line 1347 
  sig_hash &= 2147418112U;
  #line 1350 
  return sig_hash ^ bucket_hash;
}

#line 1363  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
s32 ixgbe_fdir_add_signature_filter_82599(struct ixgbe_hw *hw, union ixgbe_atr_hash_dword input, union ixgbe_atr_hash_dword common, u8 queue)
{
  #line 1368 
  u64 fdirhashcmd;
  #line 1369 
  u8 flow_type;
  #line 1370 
  bool tunnel;
  #line 1371 
  u32 fdircmd;
  #line 1377 
  tunnel = (_Bool)(((int)input.formatted.flow_type & 16) != 0);
  #line 1378 
  flow_type = (unsigned char)((unsigned int)input.formatted.flow_type & 15U);
  #line 1380 
  switch ((int)flow_type) {
    #line 1381 
    case 2: 
            #line 1381 
    ;
    #line 1382 
    case 1: 
            #line 1382 
    ;
    #line 1383 
    case 3: 
            #line 1383 
    ;
    #line 1384 
    case 6: 
            #line 1384 
    ;
    #line 1385 
    case 5: 
            #line 1385 
    ;
    #line 1386 
    case 7: 
            #line 1386 
    ;
    #line 1387 
    break;
    #line 1388 
    default: 
             #line 1388 
    ;
    {
      #line 1389 
      bool branch;
      #line 1389 
      struct _ddebug __UNIQUE_ID_ddebug452 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_fdir_add_signature_filter_82599", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c", .format = (char *)" Error on flow type input\n", .lineno = (unsigned int)1389U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1389 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug452.key.dd_key_false.key,(_Bool)0);
      #line 1389 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 1389 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug452,((struct ixgbe_adapter *)hw->back)->netdev,(char *)" Error on flow type input\n");
    }
    #line 1390 
    return -4;
  }
  #line 1394 
  fdircmd = 34825U;
  #line 1396 
  fdircmd = ((unsigned int)flow_type << 5) | fdircmd;
  #line 1397 
  fdircmd = ((unsigned int)queue << 16) | fdircmd;
  #line 1398 
  if ((int)tunnel != 0) 
                        #line 1399 
                        fdircmd |= 8388608U;
  #line 1405 
  fdirhashcmd = (unsigned long long)fdircmd << 32;
  #line 1406 
  fdirhashcmd = (unsigned long long)ixgbe_atr_compute_sig_hash_82599(input,common) | fdirhashcmd;
  #line 1407 
  ixgbe_write_reg64(hw,60968U,fdirhashcmd);
  {
    #line 1409 
    bool branch_0;
    #line 1409 
    struct _ddebug __UNIQUE_ID_ddebug453 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_fdir_add_signature_filter_82599", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c", .format = (char *)"Tx Queue=%x hash=%x\n", .lineno = (unsigned int)1409U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 1409 
    branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug453.key.dd_key_false.key,(_Bool)0);
    #line 1409 
    if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                  #line 1409 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug453,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Tx Queue=%x hash=%x\n",(int)queue,(unsigned int)fdirhashcmd);
  }
  #line 1411 
  return 0;
}

#line 1434  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
void ixgbe_atr_compute_perfect_hash_82599(union ixgbe_atr_input *input, union ixgbe_atr_input *input_mask)
{
  #line 1438 
  u32 hi_hash_dword;
  #line 1438 
  u32 lo_hash_dword;
  #line 1438 
  u32 flow_vm_vlan;
  #line 1441 
  int i;
  #line 1439 
  u32 bucket_hash = 0U;
  #line 1440 
  __be32 hi_dword = 0U;
  #line 1444 
  i = 0;
  #line 1444 
  while (i <= 10) {
    #line 1445 
    input->dword_stream[i] &= input_mask->dword_stream[i];
    #line 1444 
    i ++;
  }
  #line 1448 
  flow_vm_vlan = __builtin_bswap32(input->dword_stream[0]);
  #line 1451 
  i = 1;
  #line 1451 
  while (i <= 10) {
    #line 1452 
    hi_dword = input->dword_stream[i] ^ hi_dword;
    #line 1451 
    i ++;
  }
  #line 1453 
  hi_hash_dword = __builtin_bswap32(hi_dword);
  #line 1456 
  lo_hash_dword = (hi_hash_dword << 16) | (hi_hash_dword << ((unsigned long)8 * sizeof(hi_hash_dword) - (unsigned long)16));
  #line 1459 
  hi_hash_dword = ((flow_vm_vlan >> 16) ^ flow_vm_vlan) ^ hi_hash_dword;
  {
    #line 1462 
    u32 n = 0U;
    #line 1462 
    if (((1034753250UL >> n) & 1UL) != 0UL) 
                                            #line 1462 
                                            bucket_hash = (lo_hash_dword >> n) ^ bucket_hash;
    #line 1462 
    if (((1034753250UL >> (n + 16U)) & 1UL) != 0UL) 
                                                    #line 1462 
                                                    bucket_hash = (hi_hash_dword >> n) ^ bucket_hash;
  }
  #line 1469 
  lo_hash_dword = ((flow_vm_vlan << 16) ^ flow_vm_vlan) ^ lo_hash_dword;
  #line 1472 
  i = 1;
  #line 1472 
  while (i <= 15) {
    {
      #line 1473 
      u32 n_0 = (unsigned int)i;
      #line 1473 
      if (((1034753250UL >> n_0) & 1UL) != 0UL) 
                                                #line 1473 
                                                bucket_hash = (lo_hash_dword >> n_0) ^ bucket_hash;
      #line 1473 
      if (((1034753250UL >> (n_0 + 16U)) & 1UL) != 0UL) 
                                                        #line 1473 
                                                        bucket_hash = (hi_hash_dword >> n_0) ^ bucket_hash;
    }
    #line 1472 
    i ++;
  }
  #line 1479 
  input->formatted.bkt_hash = (unsigned short)((unsigned int)((unsigned short)bucket_hash) & 8191U);
  #line 1480 
  return;
}

#line 1491  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static u32 ixgbe_get_fdirtcpm_82599(union ixgbe_atr_input *input_mask)
{
  #line 1493 
  u32 mask = (unsigned int)__builtin_bswap16((unsigned short)((int)input_mask->formatted.dst_port));
  #line 1495 
  mask <<= 16;
  #line 1496 
  mask = (unsigned int)__builtin_bswap16((unsigned short)((int)input_mask->formatted.src_port)) | mask;
  #line 1497 
  mask = ((mask << 1) & 2863311530U) | ((mask >> 1) & 1431655765U);
  #line 1498 
  mask = ((mask << 2) & 3435973836U) | ((mask >> 2) & 858993459U);
  #line 1499 
  mask = ((mask << 4) & 4042322160U) | ((mask >> 4) & 252645135U);
  #line 1500 
  return ((mask << 8) & 4278255360U) | ((mask >> 8) & 16711935U);
}

#line 1520  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
s32 ixgbe_fdir_set_input_mask_82599(struct ixgbe_hw *hw, union ixgbe_atr_input *input_mask)
{
  #line 1525 
  u32 fdirtcpm;
  #line 1524 
  u32 fdirm = 32U;
  #line 1538 
  if ((unsigned int)input_mask->formatted.bkt_hash != 0U) {
    #line 1539 
    bool branch;
    #line 1539 
    struct _ddebug __UNIQUE_ID_ddebug454 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_fdir_set_input_mask_82599", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c", .format = (char *)" bucket hash should always be 0 in mask\n", .lineno = (unsigned int)1539U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 1539 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug454.key.dd_key_false.key,(_Bool)0);
    #line 1539 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 1539 
                                                __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug454,((struct ixgbe_adapter *)hw->back)->netdev,(char *)" bucket hash should always be 0 in mask\n");
  }
  #line 1542 
  switch ((int)input_mask->formatted.vm_pool & 127) {
    #line 1543 
    case 0: 
            #line 1543 
    ;
    #line 1544 
    fdirm |= 4U;
    #line 1545 
    case 127: 
              #line 1545 
    ;
    #line 1546 
    break;
    #line 1547 
    default: 
             #line 1547 
    ;
    {
      #line 1548 
      bool branch_0;
      #line 1548 
      struct _ddebug __UNIQUE_ID_ddebug455 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_fdir_set_input_mask_82599", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c", .format = (char *)" Error on vm pool mask\n", .lineno = (unsigned int)1548U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1548 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug455.key.dd_key_false.key,(_Bool)0);
      #line 1548 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 1548 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug455,((struct ixgbe_adapter *)hw->back)->netdev,(char *)" Error on vm pool mask\n");
    }
    #line 1549 
    return -4;
  }
  #line 1552 
  switch ((int)input_mask->formatted.flow_type & 3) {
    #line 1553 
    case 0: 
            #line 1553 
    ;
    #line 1554 
    fdirm |= 8U;
    #line 1555 
    if ((unsigned int)input_mask->formatted.dst_port != 0U || (unsigned int)input_mask->formatted.src_port != 0U) {
      {
        #line 1557 
        bool branch_1;
        #line 1557 
        struct _ddebug __UNIQUE_ID_ddebug456 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_fdir_set_input_mask_82599", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c", .format = (char *)" Error on src/dst port mask\n", .lineno = (unsigned int)1557U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 1557 
        branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug456.key.dd_key_false.key,(_Bool)0);
        #line 1557 
        if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                      #line 1557 
                                                      __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug456,((struct ixgbe_adapter *)hw->back)->netdev,(char *)" Error on src/dst port mask\n");
      }
      #line 1558 
      return -4;
    }
    #line 1560 
    case 3: 
            #line 1560 
    ;
    #line 1561 
    break;
    #line 1562 
    default: 
             #line 1562 
    ;
    {
      #line 1563 
      bool branch_2;
      #line 1563 
      struct _ddebug __UNIQUE_ID_ddebug457 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_fdir_set_input_mask_82599", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c", .format = (char *)" Error on flow type mask\n", .lineno = (unsigned int)1563U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1563 
      branch_2 = arch_static_branch(& __UNIQUE_ID_ddebug457.key.dd_key_false.key,(_Bool)0);
      #line 1563 
      if ((long)((long)((int)branch_2 != 0)) != 0L) 
                                                    #line 1563 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug457,((struct ixgbe_adapter *)hw->back)->netdev,(char *)" Error on flow type mask\n");
    }
    #line 1564 
    return -4;
  }
  #line 1567 
  switch ((int)__builtin_bswap16((unsigned short)((int)input_mask->formatted.vlan_id)) & 61439) {
    #line 1568 
    case 0: 
            #line 1568 
    ;
    #line 1570 
    fdirm |= 1U;
    #line 1572 
    case 4095: 
               #line 1572 
    ;
    #line 1574 
    fdirm |= 2U;
    #line 1575 
    break;
    #line 1576 
    case 57344: 
                #line 1576 
    ;
    #line 1578 
    fdirm |= 1U;
    #line 1580 
    case 61439: 
                #line 1580 
    ;
    #line 1582 
    break;
    #line 1583 
    default: 
             #line 1583 
    ;
    {
      #line 1584 
      bool branch_3;
      #line 1584 
      struct _ddebug __UNIQUE_ID_ddebug458 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_fdir_set_input_mask_82599", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c", .format = (char *)" Error on VLAN mask\n", .lineno = (unsigned int)1584U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1584 
      branch_3 = arch_static_branch(& __UNIQUE_ID_ddebug458.key.dd_key_false.key,(_Bool)0);
      #line 1584 
      if ((long)((long)((int)branch_3 != 0)) != 0L) 
                                                    #line 1584 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug458,((struct ixgbe_adapter *)hw->back)->netdev,(char *)" Error on VLAN mask\n");
    }
    #line 1585 
    return -4;
  }
  #line 1588 
  switch ((int)input_mask->formatted.flex_bytes) {
    #line 1589 
    case 0: 
            #line 1589 
    ;
    #line 1591 
    fdirm |= 16U;
    #line 1593 
    case 65535: 
                #line 1593 
    ;
    #line 1594 
    break;
    #line 1595 
    default: 
             #line 1595 
    ;
    {
      #line 1596 
      bool branch_4;
      #line 1596 
      struct _ddebug __UNIQUE_ID_ddebug459 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_fdir_set_input_mask_82599", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c", .format = (char *)" Error on flexible byte mask\n", .lineno = (unsigned int)1596U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1596 
      branch_4 = arch_static_branch(& __UNIQUE_ID_ddebug459.key.dd_key_false.key,(_Bool)0);
      #line 1596 
      if ((long)((long)((int)branch_4 != 0)) != 0L) 
                                                    #line 1596 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug459,((struct ixgbe_adapter *)hw->back)->netdev,(char *)" Error on flexible byte mask\n");
    }
    #line 1597 
    return -4;
  }
  #line 1601 
  ixgbe_write_reg_7(hw,61040U,fdirm);
  #line 1604 
  fdirtcpm = ixgbe_get_fdirtcpm_82599(input_mask);
  #line 1607 
  ixgbe_write_reg_7(hw,60996U,~ fdirtcpm);
  #line 1608 
  ixgbe_write_reg_7(hw,61000U,~ fdirtcpm);
  #line 1611 
  switch ((unsigned int)hw->mac.type) {
    #line 1612 
    case (unsigned int)4: 
                          #line 1612 
    ;
    #line 1613 
    case (unsigned int)5: 
                          #line 1613 
    ;
    #line 1614 
    case (unsigned int)6: 
                          #line 1614 
    ;
    #line 1615 
    ixgbe_write_reg_7(hw,61048U,~ fdirtcpm);
    #line 1616 
    break;
    #line 1617 
    default: 
             #line 1617 
    ;
    #line 1618 
    break;
  }
  #line 1622 
  ;
  #line 1622 
  ixgbe_write_reg_7(hw,60992U,(((__builtin_bswap32(~ input_mask->formatted.src_ip[0]) >> 24) | ((__builtin_bswap32(~ input_mask->formatted.src_ip[0]) >> 8) & 65280U)) | ((__builtin_bswap32(~ input_mask->formatted.src_ip[0]) << 8) & 16711680U)) | (__builtin_bswap32(~ input_mask->formatted.src_ip[0]) << 24));
  #line 1624 
  ;
  #line 1624 
  ixgbe_write_reg_7(hw,60988U,(((__builtin_bswap32(~ input_mask->formatted.dst_ip[0]) >> 24) | ((__builtin_bswap32(~ input_mask->formatted.dst_ip[0]) >> 8) & 65280U)) | ((__builtin_bswap32(~ input_mask->formatted.dst_ip[0]) << 8) & 16711680U)) | (__builtin_bswap32(~ input_mask->formatted.dst_ip[0]) << 24));
  #line 1627 
  return 0;
}

#line 1630  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
s32 ixgbe_fdir_write_perfect_filter_82599(struct ixgbe_hw *hw, union ixgbe_atr_input *input, u16 soft_id, u8 queue)
{
  #line 1634 
  u32 fdirport;
  #line 1634 
  u32 fdirvlan;
  #line 1634 
  u32 fdirhash;
  #line 1634 
  u32 fdircmd;
  #line 1635 
  s32 err;
  #line 1638 
  ;
  #line 1638 
  ixgbe_write_reg_7(hw,60940U,(((__builtin_bswap32(input->formatted.src_ip[0]) >> 24) | ((__builtin_bswap32(input->formatted.src_ip[0]) >> 8) & 65280U)) | ((__builtin_bswap32(input->formatted.src_ip[0]) << 8) & 16711680U)) | (__builtin_bswap32(input->formatted.src_ip[0]) << 24));
  #line 1640 
  ;
  #line 1640 
  ixgbe_write_reg_7(hw,60944U,(((__builtin_bswap32(input->formatted.src_ip[1]) >> 24) | ((__builtin_bswap32(input->formatted.src_ip[1]) >> 8) & 65280U)) | ((__builtin_bswap32(input->formatted.src_ip[1]) << 8) & 16711680U)) | (__builtin_bswap32(input->formatted.src_ip[1]) << 24));
  #line 1642 
  ;
  #line 1642 
  ixgbe_write_reg_7(hw,60948U,(((__builtin_bswap32(input->formatted.src_ip[2]) >> 24) | ((__builtin_bswap32(input->formatted.src_ip[2]) >> 8) & 65280U)) | ((__builtin_bswap32(input->formatted.src_ip[2]) << 8) & 16711680U)) | (__builtin_bswap32(input->formatted.src_ip[2]) << 24));
  #line 1646 
  ;
  #line 1646 
  ixgbe_write_reg_7(hw,60952U,(((__builtin_bswap32(input->formatted.src_ip[0]) >> 24) | ((__builtin_bswap32(input->formatted.src_ip[0]) >> 8) & 65280U)) | ((__builtin_bswap32(input->formatted.src_ip[0]) << 8) & 16711680U)) | (__builtin_bswap32(input->formatted.src_ip[0]) << 24));
  #line 1649 
  ;
  #line 1649 
  ixgbe_write_reg_7(hw,60956U,(((__builtin_bswap32(input->formatted.dst_ip[0]) >> 24) | ((__builtin_bswap32(input->formatted.dst_ip[0]) >> 8) & 65280U)) | ((__builtin_bswap32(input->formatted.dst_ip[0]) << 8) & 16711680U)) | (__builtin_bswap32(input->formatted.dst_ip[0]) << 24));
  #line 1652 
  fdirport = (unsigned int)__builtin_bswap16((unsigned short)((int)input->formatted.dst_port));
  #line 1653 
  fdirport <<= 16;
  #line 1654 
  fdirport = (unsigned int)__builtin_bswap16((unsigned short)((int)input->formatted.src_port)) | fdirport;
  #line 1655 
  ixgbe_write_reg_7(hw,60960U,fdirport);
  #line 1658 
  fdirvlan = (unsigned int)__builtin_bswap16((unsigned short)((int)((unsigned short)(((int)input->formatted.flex_bytes >> 8) | (
                                                                   (int)input->formatted.flex_bytes << 8)))));
  #line 1659 
  fdirvlan <<= 16;
  #line 1660 
  fdirvlan = (unsigned int)__builtin_bswap16((unsigned short)((int)input->formatted.vlan_id)) | fdirvlan;
  #line 1661 
  ixgbe_write_reg_7(hw,60964U,fdirvlan);
  #line 1664 
  fdirhash = (unsigned int)input->formatted.bkt_hash;
  #line 1665 
  fdirhash = (unsigned int)((int)soft_id << 16) | fdirhash;
  #line 1666 
  ixgbe_write_reg_7(hw,60968U,fdirhash);
  #line 1672 
  ixgbe_read_reg(hw,8U);
  #line 1675 
  fdircmd = 34825U;
  #line 1677 
  if ((unsigned int)queue == 127U) 
                                   #line 1678 
                                   fdircmd |= 512U;
  #line 1679 
  fdircmd = (unsigned int)((int)input->formatted.flow_type << 5) | fdircmd;
  #line 1680 
  fdircmd = ((unsigned int)queue << 16) | fdircmd;
  #line 1681 
  fdircmd = ((unsigned int)input->formatted.vm_pool << 24) | fdircmd;
  #line 1683 
  ixgbe_write_reg_7(hw,60972U,fdircmd);
  #line 1684 
  err = ixgbe_fdir_check_cmd_complete(hw,& fdircmd);
  #line 1685 
  if (err != 0) {
    {
      #line 1686 
      bool branch;
      #line 1686 
      struct _ddebug __UNIQUE_ID_ddebug460 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_fdir_write_perfect_filter_82599", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c", .format = (char *)"Flow Director command did not complete!\n", .lineno = (unsigned int)1686U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1686 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug460.key.dd_key_false.key,(_Bool)0);
      #line 1686 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 1686 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug460,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Flow Director command did not complete!\n");
    }
    #line 1687 
    return err;
  }
  #line 1690 
  return 0;
}

#line 1693  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
s32 ixgbe_fdir_erase_perfect_filter_82599(struct ixgbe_hw *hw, union ixgbe_atr_input *input, u16 soft_id)
{
  #line 1697 
  u32 fdirhash;
  #line 1698 
  u32 fdircmd;
  #line 1699 
  s32 err;
  #line 1702 
  fdirhash = (unsigned int)input->formatted.bkt_hash;
  #line 1703 
  fdirhash = (unsigned int)((int)soft_id << 16) | fdirhash;
  #line 1704 
  ixgbe_write_reg_7(hw,60968U,fdirhash);
  #line 1707 
  ixgbe_read_reg(hw,8U);
  #line 1710 
  ixgbe_write_reg_7(hw,60972U,3U);
  #line 1712 
  err = ixgbe_fdir_check_cmd_complete(hw,& fdircmd);
  #line 1713 
  if (err != 0) {
    {
      #line 1714 
      bool branch;
      #line 1714 
      struct _ddebug __UNIQUE_ID_ddebug461 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_fdir_erase_perfect_filter_82599", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c", .format = (char *)"Flow Director command did not complete!\n", .lineno = (unsigned int)1714U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1714 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug461.key.dd_key_false.key,(_Bool)0);
      #line 1714 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 1714 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug461,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Flow Director command did not complete!\n");
    }
    #line 1715 
    return err;
  }
  #line 1719 
  if ((fdircmd & 4U) != 0U) {
    #line 1720 
    ixgbe_write_reg_7(hw,60968U,fdirhash);
    #line 1721 
    ixgbe_read_reg(hw,8U);
    #line 1722 
    ixgbe_write_reg_7(hw,60972U,2U);
  }
  #line 1726 
  return 0;
}

#line 1737  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_read_analog_reg8_82599(struct ixgbe_hw *hw, u32 reg, u8 *val)
{
  #line 1739 
  u32 core_ctl;
  #line 1741 
  ixgbe_write_reg_7(hw,85760U,(reg << 8) | 65536U);
  #line 1743 
  ixgbe_read_reg(hw,8U);
  #line 1744 
  __const_udelay(42950UL);
  #line 1745 
  core_ctl = ixgbe_read_reg(hw,85760U);
  #line 1746 
  *val = (unsigned char)core_ctl;
  #line 1748 
  return 0;
}

#line 1759  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_write_analog_reg8_82599(struct ixgbe_hw *hw, u32 reg, u8 val)
{
  #line 1761 
  u32 core_ctl;
  #line 1763 
  core_ctl = (reg << 8) | (unsigned int)val;
  #line 1764 
  ixgbe_write_reg_7(hw,85760U,core_ctl);
  #line 1765 
  ixgbe_read_reg(hw,8U);
  #line 1766 
  __const_udelay(42950UL);
  #line 1768 
  return 0;
}

#line 1779  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_start_hw_82599(struct ixgbe_hw *hw)
{
  #line 1781 
  s32 ret_val = 0;
  #line 1783 
  ret_val = ixgbe_start_hw_generic(hw);
  #line 1784 
  if (ret_val != 0) 
                    #line 1785 
                    return ret_val;
  #line 1787 
  ret_val = ixgbe_start_hw_gen2(hw);
  #line 1788 
  if (ret_val != 0) 
                    #line 1789 
                    return ret_val;
  #line 1792 
  hw->mac.autotry_restart = (_Bool)1;
  #line 1794 
  return ixgbe_verify_fw_version_82599(hw);
}

#line 1805  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_identify_phy_82599(struct ixgbe_hw *hw)
{
  #line 1807 
  s32 status;
  #line 1810 
  status = ixgbe_identify_phy_generic(hw);
  #line 1811 
  if (status != 0) {
    #line 1813 
    if ((*(hw->mac.ops.get_media_type))(hw) == (unsigned int)ixgbe_media_type_copper) 
      #line 1814 
      return status;
    #line 1815 
    status = ixgbe_identify_module_generic(hw);
  }
  #line 1819 
  if (hw->phy.type == (unsigned int)ixgbe_phy_unknown) {
    #line 1820 
    hw->phy.type = ixgbe_phy_none;
    #line 1821 
    status = 0;
  }
  #line 1825 
  if (hw->phy.type == (unsigned int)ixgbe_phy_sfp_unsupported) 
                                                               #line 1826 
                                                               return -19;
  #line 1828 
  return status;
}

#line 1838  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_enable_rx_dma_82599(struct ixgbe_hw *hw, u32 regval)
{
  #line 1846 
  (*(hw->mac.ops.disable_rx_buff))(hw);
  #line 1848 
  if ((regval & 1U) != 0U) 
                           #line 1849 
                           (*(hw->mac.ops.enable_rx))(hw); else 
                                                                #line 1851 
                                                                (*(hw->mac.ops.disable_rx))(hw);
  #line 1853 
  (*(hw->mac.ops.enable_rx_buff))(hw);
  #line 1855 
  return 0;
}

#line 1868  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_verify_fw_version_82599(struct ixgbe_hw *hw)
{
  #line 1871 
  u16 fw_offset;
  #line 1871 
  u16 fw_ptp_cfg_offset;
  #line 1872 
  u16 offset;
  #line 1870 
  s32 status = -24;
  #line 1873 
  u16 fw_version = (unsigned short)0U;
  #line 1876 
  if (hw->phy.media_type != (unsigned int)ixgbe_media_type_fiber) 
                                                                  #line 1877 
                                                                  return 0;
  #line 1880 
  offset = (unsigned short)15U;
  #line 1881 
  if ((*(hw->eeprom.ops.read))(hw,(unsigned short)((int)offset),& fw_offset) != 0) 
    #line 1882 
    goto fw_version_err;
  #line 1884 
  if ((unsigned int)fw_offset + 65535U > 65533U) 
                                                 #line 1885 
                                                 return -24;
  #line 1888 
  offset = (unsigned short)((unsigned int)fw_offset + 4U);
  #line 1889 
  if ((*(hw->eeprom.ops.read))(hw,(unsigned short)((int)offset),
                                 & fw_ptp_cfg_offset) != 0) 
    #line 1890 
    goto fw_version_err;
  #line 1892 
  if ((unsigned int)fw_ptp_cfg_offset + 65535U > 65533U) 
                                                         #line 1893 
                                                         return -24;
  #line 1896 
  offset = (unsigned short)((unsigned int)fw_ptp_cfg_offset + 7U);
  #line 1897 
  if ((*(hw->eeprom.ops.read))(hw,(unsigned short)((int)offset),
                                 & fw_version) != 0) 
    #line 1898 
    goto fw_version_err;
  #line 1900 
  if ((unsigned int)fw_version > 5U) 
                                     #line 1901 
                                     status = 0;
  #line 1903 
  return status;
  #line 1905 
  fw_version_err: 
                  #line 1905 
  ;
  #line 1906 
  netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"eeprom read at offset %d failed\n",(int)offset);
  #line 1907 
  return -24;
}

#line 1917  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static bool ixgbe_verify_lesm_fw_enabled_82599(struct ixgbe_hw *hw)
{
  #line 1919 
  u16 fw_offset;
  #line 1919 
  u16 fw_lesm_param_offset;
  #line 1919 
  u16 fw_lesm_state;
  #line 1920 
  s32 status;
  #line 1923 
  status = (*(hw->eeprom.ops.read))(hw,(unsigned short)15,& fw_offset);
  #line 1925 
  if ((status != 0 || (unsigned int)fw_offset == 0U) || (unsigned int)fw_offset == 65535U) 
    #line 1926 
    return (_Bool)0;
  #line 1929 
  status = (*(hw->eeprom.ops.read))(hw,(unsigned short)((int)((unsigned int)fw_offset + 2U)),& fw_lesm_param_offset);
  #line 1933 
  if ((status != 0 || (unsigned int)fw_lesm_param_offset == 0U) || (unsigned int)fw_lesm_param_offset == 65535U) 
    #line 1935 
    return (_Bool)0;
  #line 1938 
  status = (*(hw->eeprom.ops.read))(hw,(unsigned short)((int)((unsigned int)fw_lesm_param_offset + 1U)),& fw_lesm_state);
  #line 1942 
  if (status == 0 && ((int)fw_lesm_state & 32768) != 0) 
                                                        #line 1943 
                                                        return (_Bool)1;
  #line 1945 
  return (_Bool)0;
}

#line 1959  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_read_eeprom_buffer_82599(struct ixgbe_hw *hw, u16 offset, u16 words, u16 *data)
{
  #line 1962 
  struct ixgbe_eeprom_info *eeprom = & hw->eeprom;
  #line 1967 
  if (eeprom->type == (unsigned int)ixgbe_eeprom_spi && (int)offset + ((int)words + -1) <= 16383) {
    #line 1969 
    return ixgbe_read_eerd_buffer_generic(hw,(unsigned short)((int)offset),
                                     (unsigned short)((int)words),data);
  }
  #line 1971 
  return ixgbe_read_eeprom_buffer_bit_bang_generic(hw,
                                                  (unsigned short)((int)offset),
                                                  (unsigned short)((int)words),
                                                  data);
}

#line 1985  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_read_eeprom_82599(struct ixgbe_hw *hw, u16 offset, u16 *data)
{
  #line 1988 
  struct ixgbe_eeprom_info *eeprom = & hw->eeprom;
  #line 1994 
  if (eeprom->type == (unsigned int)ixgbe_eeprom_spi && (unsigned int)offset <= 16383U) {
    #line 1995 
    return ixgbe_read_eerd_generic(hw,(unsigned short)((int)offset),data);
  }
  #line 1997 
  return ixgbe_read_eeprom_bit_bang_generic(hw,(unsigned short)((int)offset),
                                           data);
}

#line 2009  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_reset_pipeline_82599(struct ixgbe_hw *hw)
{
  #line 2011 
  s32 ret_val;
  #line 2013 
  u32 i;
  #line 2013 
  u32 autoc_reg;
  #line 2013 
  u32 autoc2_reg;
  #line 2012 
  u32 anlp1_reg = 0U;
  #line 2016 
  autoc2_reg = ixgbe_read_reg(hw,17064U);
  #line 2017 
  if ((autoc2_reg & 1879048192U) != 0U) {
    #line 2018 
    autoc2_reg &= 2415919103U;
    #line 2019 
    ixgbe_write_reg_7(hw,17064U,autoc2_reg);
    #line 2020 
    ixgbe_read_reg(hw,8U);
  }
  #line 2023 
  autoc_reg = ixgbe_read_reg(hw,17056U);
  #line 2024 
  autoc_reg |= 4096U;
  #line 2027 
  ixgbe_write_reg_7(hw,17056U,autoc_reg ^ 32768U);
  #line 2031 
  i = 0U;
  #line 2031 
  while (i <= 9U) {
    #line 2032 
    usleep_range(4000UL,8000UL);
    #line 2033 
    anlp1_reg = ixgbe_read_reg(hw,17072U);
    #line 2034 
    if ((anlp1_reg & 983040U) != 0U) 
                                     #line 2035 
                                     break;
    #line 2031 
    i ++;
  }
  #line 2038 
  if ((anlp1_reg & 983040U) == 0U) {
    {
      #line 2039 
      bool branch;
      #line 2039 
      struct _ddebug __UNIQUE_ID_ddebug462 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_reset_pipeline_82599", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c", .format = (char *)"auto negotiation not completed\n", .lineno = (unsigned int)2039U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 2039 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug462.key.dd_key_false.key,(_Bool)0);
      #line 2039 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 2039 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug462,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"auto negotiation not completed\n");
    }
    #line 2040 
    ret_val = -15;
    #line 2041 
    goto reset_pipeline_out;
  }
  #line 2044 
  ret_val = 0;
  #line 2046 
  reset_pipeline_out: 
                      #line 2046 
  ;
  #line 2048 
  ixgbe_write_reg_7(hw,17056U,autoc_reg);
  #line 2049 
  ixgbe_read_reg(hw,8U);
  #line 2051 
  return ret_val;
}

#line 2064  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_read_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset, u8 dev_addr, u8 *data)
{
  #line 2067 
  u32 esdp;
  #line 2068 
  s32 status;
  #line 2069 
  s32 timeout = 200;
  #line 2071 
  if ((int)hw->phy.qsfp_shared_i2c_bus == 1) {
    #line 2073 
    esdp = ixgbe_read_reg(hw,32U);
    #line 2074 
    esdp |= 1U;
    #line 2075 
    ixgbe_write_reg_7(hw,32U,esdp);
    #line 2076 
    ixgbe_read_reg(hw,8U);
    #line 2078 
    while (timeout != 0) {
      #line 2079 
      esdp = ixgbe_read_reg(hw,32U);
      #line 2080 
      if ((esdp & 2U) != 0U) 
                             #line 2081 
                             break;
      #line 2083 
      usleep_range(5000UL,10000UL);
      #line 2084 
      timeout --;
    }
    #line 2087 
    if (timeout == 0) {
      {
        #line 2088 
        bool branch;
        #line 2088 
        struct _ddebug __UNIQUE_ID_ddebug463 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_read_i2c_byte_82599", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c", .format = (char *)"Driver can\'t access resource, acquiring I2C bus timeout.\n", .lineno = (unsigned int)2088U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 2088 
        branch = arch_static_branch(& __UNIQUE_ID_ddebug463.key.dd_key_false.key,(_Bool)0);
        #line 2088 
        if ((long)((long)((int)branch != 0)) != 0L) 
                                                    #line 2088 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug463,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Driver can\'t access resource, acquiring I2C bus timeout.\n");
      }
      #line 2089 
      status = -18;
      #line 2090 
      goto release_i2c_access;
    }
  }
  #line 2094 
  status = ixgbe_read_i2c_byte_generic(hw,(unsigned char)((int)byte_offset),(unsigned char)((int)dev_addr),data);
  #line 2096 
  release_i2c_access: 
                      #line 2096 
  ;
  #line 2097 
  if ((int)hw->phy.qsfp_shared_i2c_bus == 1) {
    #line 2099 
    esdp = ixgbe_read_reg(hw,32U);
    #line 2100 
    esdp &= 4294967294U;
    #line 2101 
    ixgbe_write_reg_7(hw,32U,esdp);
    #line 2102 
    ixgbe_read_reg(hw,8U);
  }
  #line 2105 
  return status;
}

#line 2118  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_write_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset, u8 dev_addr, u8 data)
{
  #line 2121 
  u32 esdp;
  #line 2122 
  s32 status;
  #line 2123 
  s32 timeout = 200;
  #line 2125 
  if ((int)hw->phy.qsfp_shared_i2c_bus == 1) {
    #line 2127 
    esdp = ixgbe_read_reg(hw,32U);
    #line 2128 
    esdp |= 1U;
    #line 2129 
    ixgbe_write_reg_7(hw,32U,esdp);
    #line 2130 
    ixgbe_read_reg(hw,8U);
    #line 2132 
    while (timeout != 0) {
      #line 2133 
      esdp = ixgbe_read_reg(hw,32U);
      #line 2134 
      if ((esdp & 2U) != 0U) 
                             #line 2135 
                             break;
      #line 2137 
      usleep_range(5000UL,10000UL);
      #line 2138 
      timeout --;
    }
    #line 2141 
    if (timeout == 0) {
      {
        #line 2142 
        bool branch;
        #line 2142 
        struct _ddebug __UNIQUE_ID_ddebug464 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_write_i2c_byte_82599", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c", .format = (char *)"Driver can\'t access resource, acquiring I2C bus timeout.\n", .lineno = (unsigned int)2142U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 2142 
        branch = arch_static_branch(& __UNIQUE_ID_ddebug464.key.dd_key_false.key,(_Bool)0);
        #line 2142 
        if ((long)((long)((int)branch != 0)) != 0L) 
                                                    #line 2142 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug464,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Driver can\'t access resource, acquiring I2C bus timeout.\n");
      }
      #line 2143 
      status = -18;
      #line 2144 
      goto release_i2c_access;
    }
  }
  #line 2148 
  status = ixgbe_write_i2c_byte_generic(hw,(unsigned char)((int)byte_offset),(unsigned char)((int)dev_addr),(unsigned char)((int)data));
  #line 2150 
  release_i2c_access: 
                      #line 2150 
  ;
  #line 2151 
  if ((int)hw->phy.qsfp_shared_i2c_bus == 1) {
    #line 2153 
    esdp = ixgbe_read_reg(hw,32U);
    #line 2154 
    esdp &= 4294967294U;
    #line 2155 
    ixgbe_write_reg_7(hw,32U,esdp);
    #line 2156 
    ixgbe_read_reg(hw,8U);
  }
  #line 2159 
  return status;
}

#line 2162  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static struct ixgbe_mac_operations mac_ops_82599 = {.init_hw = & ixgbe_init_hw_generic, .reset_hw = & ixgbe_reset_hw_82599, .start_hw = & ixgbe_start_hw_82599, .clear_hw_cntrs = & ixgbe_clear_hw_cntrs_generic, .get_media_type = & ixgbe_get_media_type_82599, .get_mac_addr = & ixgbe_get_mac_addr_generic, .get_san_mac_addr = & ixgbe_get_san_mac_addr_generic, .get_device_caps = & ixgbe_get_device_caps_generic, .get_wwn_prefix = & ixgbe_get_wwn_prefix_generic, .stop_adapter = & ixgbe_stop_adapter_generic, .get_bus_info = & ixgbe_get_bus_info_generic, .set_lan_id = & ixgbe_set_lan_id_multi_port_pcie, .read_analog_reg8 = & ixgbe_read_analog_reg8_82599, .write_analog_reg8 = & ixgbe_write_analog_reg8_82599, .setup_sfp = & ixgbe_setup_sfp_modules_82599, .disable_rx_buff = & ixgbe_disable_rx_buff_generic, .enable_rx_buff = & ixgbe_enable_rx_buff_generic, .enable_rx_dma = & ixgbe_enable_rx_dma_82599, .acquire_swfw_sync = & ixgbe_acquire_swfw_sync, .release_swfw_sync = & ixgbe_release_swfw_sync, .prot_autoc_read = & prot_autoc_read_82599, .prot_autoc_write = & prot_autoc_write_82599, .stop_link_on_d3 = & ixgbe_stop_mac_link_on_d3_82599, .setup_link = & ixgbe_setup_mac_link_82599, .check_link = & ixgbe_check_mac_link_generic, .get_link_capabilities = & ixgbe_get_link_capabilities_82599, .set_rxpba = & ixgbe_set_rxpba_generic, .led_on = & ixgbe_led_on_generic, .led_off = & ixgbe_led_off_generic, .blink_led_start = & ixgbe_blink_led_start_generic, .blink_led_stop = & ixgbe_blink_led_stop_generic, .init_led_link_act = & ixgbe_init_led_link_act_generic, .set_rar = & ixgbe_set_rar_generic, .clear_rar = & ixgbe_clear_rar_generic, .set_vmdq = & ixgbe_set_vmdq_generic, .set_vmdq_san_mac = & ixgbe_set_vmdq_san_mac_generic, .clear_vmdq = & ixgbe_clear_vmdq_generic, .init_rx_addrs = & ixgbe_init_rx_addrs_generic, .update_mc_addr_list = & ixgbe_update_mc_addr_list_generic, .enable_mc = & ixgbe_enable_mc_generic, .disable_mc = & ixgbe_disable_mc_generic, .clear_vfta = & ixgbe_clear_vfta_generic, .set_vfta = & ixgbe_set_vfta_generic, .init_uta_tables = & ixgbe_init_uta_tables_generic, .set_mac_anti_spoofing = & ixgbe_set_mac_anti_spoofing, .set_vlan_anti_spoofing = & ixgbe_set_vlan_anti_spoofing, .fc_enable = & ixgbe_fc_enable_generic, .setup_fc = & ixgbe_setup_fc_generic, .fc_autoneg = & ixgbe_fc_autoneg, .set_fw_drv_ver = & ixgbe_set_fw_drv_ver_generic, .get_thermal_sensor_data = & ixgbe_get_thermal_sensor_data_generic, .init_thermal_sensor_thresh = & ixgbe_init_thermal_sensor_thresh_generic, .disable_rx = & ixgbe_disable_rx_generic, .enable_rx = & ixgbe_enable_rx_generic};
#line 2220  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static struct ixgbe_eeprom_operations eeprom_ops_82599 = {.init_params = & ixgbe_init_eeprom_params_generic, .read = & ixgbe_read_eeprom_82599, .read_buffer = & ixgbe_read_eeprom_buffer_82599, .write = & ixgbe_write_eeprom_generic, .write_buffer = & ixgbe_write_eeprom_buffer_bit_bang_generic, .validate_checksum = & ixgbe_validate_eeprom_checksum_generic, .update_checksum = & ixgbe_update_eeprom_checksum_generic, .calc_checksum = & ixgbe_calc_eeprom_checksum_generic};
#line 2231  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static struct ixgbe_phy_operations phy_ops_82599 = {.identify = & ixgbe_identify_phy_82599, .identify_sfp = & ixgbe_identify_module_generic, .init = & ixgbe_init_phy_ops_82599, .reset = & ixgbe_reset_phy_generic, .read_reg = & ixgbe_read_phy_reg_generic, .write_reg = & ixgbe_write_phy_reg_generic, .setup_link = & ixgbe_setup_phy_link_generic, .setup_link_speed = & ixgbe_setup_phy_link_speed_generic, .read_i2c_byte = & ixgbe_read_i2c_byte_generic, .write_i2c_byte = & ixgbe_write_i2c_byte_generic, .read_i2c_sff8472 = & ixgbe_read_i2c_sff8472_generic, .read_i2c_eeprom = & ixgbe_read_i2c_eeprom_generic, .write_i2c_eeprom = & ixgbe_write_i2c_eeprom_generic, .check_overtemp = & ixgbe_tn_check_overtemp};
#line 2248  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
struct ixgbe_info ixgbe_82599_info = {.mac = ixgbe_mac_82599EB, .get_invariants = & ixgbe_get_invariants_82599, .mac_ops = & mac_ops_82599, .eeprom_ops = & eeprom_ops_82599, .phy_ops = & phy_ops_82599, .mbx_ops = & mbx_ops_generic, .mvals = (u32 *)(& ixgbe_mvals_8259X)};
#line 6  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.h"
#line 6 
s32 ixgbe_get_invariants_X540(struct ixgbe_hw *hw);
#line 7 
#line 7 
s32 ixgbe_setup_mac_link_X540(struct ixgbe_hw *hw, ixgbe_link_speed speed, bool autoneg_wait_to_complete);
#line 9 
#line 9 
s32 ixgbe_reset_hw_X540(struct ixgbe_hw *hw);
#line 10 
#line 10 
s32 ixgbe_start_hw_X540(struct ixgbe_hw *hw);
#line 11 
#line 11 
enum ixgbe_media_type ixgbe_get_media_type_X540(struct ixgbe_hw *hw);
#line 14 
#line 14 
s32 ixgbe_blink_led_start_X540(struct ixgbe_hw *hw, u32 index);
#line 15 
#line 15 
s32 ixgbe_blink_led_stop_X540(struct ixgbe_hw *hw, u32 index);
#line 16 
#line 16 
s32 ixgbe_acquire_swfw_sync_X540(struct ixgbe_hw *hw, u32 mask);
#line 17 
#line 17 
void ixgbe_release_swfw_sync_X540(struct ixgbe_hw *hw, u32 mask);
#line 18 
#line 18 
void ixgbe_init_swfw_sync_X540(struct ixgbe_hw *hw);
#line 19 
#line 19 
s32 ixgbe_init_eeprom_params_X540(struct ixgbe_hw *hw);
#line 1005  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 1005 
s32 ixgbe_negotiate_fc(struct ixgbe_hw *hw, u32 adv_reg, u32 lp_reg, u32 adv_sym, u32 adv_asm, u32 lp_sym, u32 lp_asm);
#line 90  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
#line 90 
u8 ixgbe_calculate_checksum(u8 *buffer, u32 length);
#line 91 
#line 91 
s32 ixgbe_host_interface_command(struct ixgbe_hw *hw, void *buffer, u32 length, u32 timeout, bool return_data);
#line 93 
#line 93 
s32 ixgbe_hic_unlocked(struct ixgbe_hw *hw, u32 *buffer, u32 length, u32 timeout);
#line 128 
#line 128 
void ixgbe_set_soft_rate_select_speed(struct ixgbe_hw *hw, ixgbe_link_speed speed);
#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static void ixgbe_write_reg_8(struct ixgbe_hw *hw, u32 reg, u32 value)
{
  #line 147 
  union __anonunion___u_9268 __u;
  #line 146 
  __read_once_size((void *)(& hw->hw_addr),(void *)(& __u.__c),8);
  #line 146 
  u8 *reg_addr = (__u.__val);
  #line 148 
  if ((int)ixgbe_removed((void *)reg_addr) != 0) 
                                                 #line 149 
                                                 return;
  #line 150 
  writel(value,(void *)(reg_addr + (unsigned long)reg));
  #line 151 
  return;
}

#line 152  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h"
#line 152 
s32 ixgbe_set_copper_phy_power(struct ixgbe_hw *hw, bool on);
#line 161 
#line 161 
s32 ixgbe_read_i2c_byte_generic_unlocked(struct ixgbe_hw *hw, u8 byte_offset, u8 dev_addr, u8 *data);
#line 165 
#line 165 
s32 ixgbe_write_i2c_byte_generic_unlocked(struct ixgbe_hw *hw, u8 byte_offset, u8 dev_addr, u8 data);
#line 173 
#line 173 
s32 ixgbe_read_i2c_combined_generic_int(struct ixgbe_hw *hw, u8 addr, u16 reg, u16 *val, bool lock);
#line 175 
#line 175 
s32 ixgbe_write_i2c_combined_generic_int(struct ixgbe_hw *hw, u8 addr, u16 reg, u16 val, bool lock);
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
#line 2530 
static s32 ixgbe_setup_kr_speed_x550em(struct ixgbe_hw *hw, ixgbe_link_speed speed);
#line 10 
#line 2851 
static s32 ixgbe_setup_fc_x550em(struct ixgbe_hw *hw);
#line 11 
#line 3010 
static void ixgbe_fc_autoneg_fiber_x550em_a(struct ixgbe_hw *hw);
#line 12 
#line 2936 
static void ixgbe_fc_autoneg_backplane_x550em_a(struct ixgbe_hw *hw);
#line 13 
#line 3557 
static s32 ixgbe_setup_fc_backplane_x550em_a(struct ixgbe_hw *hw);
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_get_invariants_X550_x(struct ixgbe_hw *hw)
{
  #line 17 
  struct ixgbe_mac_info *mac = & hw->mac;
  #line 18 
  struct ixgbe_phy_info *phy = & hw->phy;
  #line 19 
  struct ixgbe_link_info *link = & hw->link;
  #line 22 
  ixgbe_get_invariants_X540(hw);
  #line 24 
  if ((*(mac->ops.get_media_type))(hw) != (unsigned int)ixgbe_media_type_copper) 
    #line 25 
    phy->ops.set_phy_power = (s32 (*)(struct ixgbe_hw *, bool ))0;
  #line 27 
  link->addr = (unsigned char)190U;
  #line 29 
  return 0;
}

#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_get_invariants_X550_x_fw(struct ixgbe_hw *hw)
{
  #line 34 
  struct ixgbe_phy_info *phy = & hw->phy;
  #line 37 
  ixgbe_get_invariants_X540(hw);
  #line 39 
  phy->ops.set_phy_power = (s32 (*)(struct ixgbe_hw *, bool ))0;
  #line 41 
  return 0;
}

#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_get_invariants_X550_a(struct ixgbe_hw *hw)
{
  #line 46 
  struct ixgbe_mac_info *mac = & hw->mac;
  #line 47 
  struct ixgbe_phy_info *phy = & hw->phy;
  #line 50 
  ixgbe_get_invariants_X540(hw);
  #line 52 
  if ((*(mac->ops.get_media_type))(hw) != (unsigned int)ixgbe_media_type_copper) 
    #line 53 
    phy->ops.set_phy_power = (s32 (*)(struct ixgbe_hw *, bool ))0;
  #line 55 
  return 0;
}

#line 58  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_get_invariants_X550_a_fw(struct ixgbe_hw *hw)
{
  #line 60 
  struct ixgbe_phy_info *phy = & hw->phy;
  #line 63 
  ixgbe_get_invariants_X540(hw);
  #line 65 
  phy->ops.set_phy_power = (s32 (*)(struct ixgbe_hw *, bool ))0;
  #line 67 
  return 0;
}

#line 73  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static void ixgbe_setup_mux_ctl(struct ixgbe_hw *hw)
{
  #line 75 
  u32 esdp = ixgbe_read_reg(hw,32U);
  #line 77 
  if ((unsigned int)hw->bus.lan_id != 0U) {
    #line 78 
    esdp &= 4294836221U;
    #line 79 
    esdp |= 512U;
  }
  #line 81 
  esdp &= 4294901503U;
  #line 82 
  ixgbe_write_reg_8(hw,32U,esdp);
  #line 83 
  ixgbe_read_reg(hw,8U);
  #line 84 
  return;
}

#line 94  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_read_cs4227(struct ixgbe_hw *hw, u16 reg, u16 *value)
{
  #line 96 
  return (*(hw->link.ops.read_link_unlocked))(hw,
                                           (unsigned char)((int)hw->link.addr),
                                           (unsigned short)((int)reg),value);
}

#line 107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_write_cs4227(struct ixgbe_hw *hw, u16 reg, u16 value)
{
  #line 109 
  return (*(hw->link.ops.write_link_unlocked))(hw,
                                            (unsigned char)((int)hw->link.addr),
                                            (unsigned short)((int)reg),
                                            (unsigned short)((int)value));
}

#line 120  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_read_pe(struct ixgbe_hw *hw, u8 reg, u8 *value)
{
  #line 122 
  s32 status;
  #line 124 
  status = ixgbe_read_i2c_byte_generic_unlocked(hw,(unsigned char)((int)reg),(unsigned char)224,value);
  #line 125 
  if (status != 0) 
                   #line 126 
                   netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"port expander access failed with %d\n",status);
  #line 127 
  return status;
}

#line 138  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_write_pe(struct ixgbe_hw *hw, u8 reg, u8 value)
{
  #line 140 
  s32 status;
  #line 142 
  status = ixgbe_write_i2c_byte_generic_unlocked(hw,(unsigned char)((int)reg),(unsigned char)224,(unsigned char)((int)value));
  #line 144 
  if (status != 0) 
                   #line 145 
                   netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"port expander access failed with %d\n",status);
  #line 146 
  return status;
}

#line 156  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_reset_cs4227(struct ixgbe_hw *hw)
{
  #line 158 
  s32 status;
  #line 159 
  u32 retry;
  #line 160 
  u16 value;
  #line 161 
  u8 reg;
  #line 164 
  status = ixgbe_read_pe(hw,(unsigned char)1,& reg);
  #line 165 
  if (status != 0) 
                   #line 166 
                   return status;
  #line 167 
  reg = (unsigned char)((unsigned int)reg | 2U);
  #line 168 
  status = ixgbe_write_pe(hw,(unsigned char)1,(unsigned char)((int)reg));
  #line 169 
  if (status != 0) 
                   #line 170 
                   return status;
  #line 172 
  status = ixgbe_read_pe(hw,(unsigned char)3,& reg);
  #line 173 
  if (status != 0) 
                   #line 174 
                   return status;
  #line 175 
  reg = (unsigned char)((unsigned int)reg & 253U);
  #line 176 
  status = ixgbe_write_pe(hw,(unsigned char)3,(unsigned char)((int)reg));
  #line 177 
  if (status != 0) 
                   #line 178 
                   return status;
  #line 180 
  status = ixgbe_read_pe(hw,(unsigned char)1,& reg);
  #line 181 
  if (status != 0) 
                   #line 182 
                   return status;
  #line 183 
  reg = (unsigned char)((unsigned int)reg & 253U);
  #line 184 
  status = ixgbe_write_pe(hw,(unsigned char)1,(unsigned char)((int)reg));
  #line 185 
  if (status != 0) 
                   #line 186 
                   return status;
  #line 188 
  usleep_range(500UL,600UL);
  #line 190 
  status = ixgbe_read_pe(hw,(unsigned char)1,& reg);
  #line 191 
  if (status != 0) 
                   #line 192 
                   return status;
  #line 193 
  reg = (unsigned char)((unsigned int)reg | 2U);
  #line 194 
  status = ixgbe_write_pe(hw,(unsigned char)1,(unsigned char)((int)reg));
  #line 195 
  if (status != 0) 
                   #line 196 
                   return status;
  #line 199 
  msleep(500U);
  #line 200 
  retry = 0U;
  #line 200 
  while (retry <= 14U) {
    #line 201 
    status = ixgbe_read_cs4227(hw,(unsigned short)385,& value);
    #line 203 
    if (status == 0 && (unsigned int)value == 1U) 
                                                  #line 204 
                                                  break;
    #line 205 
    msleep(30U);
    #line 200 
    retry ++;
  }
  #line 207 
  if (retry == 15U) {
    #line 208 
    netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"CS4227 reset did not complete\n");
    #line 209 
    return -3;
  }
  #line 212 
  status = ixgbe_read_cs4227(hw,(unsigned short)20481,& value);
  #line 213 
  if (status != 0 || ((int)value & 1) == 0) {
    #line 214 
    netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"CS4227 EEPROM did not load successfully\n");
    #line 215 
    return -3;
  }
  #line 218 
  return 0;
}

#line 225  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static void ixgbe_check_cs4227(struct ixgbe_hw *hw)
{
  #line 228 
  s32 status;
  #line 229 
  u16 value;
  #line 230 
  u8 retry;
  #line 227 
  u32 swfw_mask = hw->phy.phy_semaphore_mask;
  #line 232 
  retry = (unsigned char)0U;
  #line 232 
  while ((unsigned int)retry <= 14U) {
    #line 233 
    status = (*(hw->mac.ops.acquire_swfw_sync))(hw,swfw_mask);
    #line 234 
    if (status != 0) {
      #line 235 
      netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"semaphore failed with %d\n",status);
      #line 236 
      msleep(30U);
      #line 237 
      goto __Cont;
    }
    #line 241 
    status = ixgbe_read_cs4227(hw,(unsigned short)2,& value);
    #line 242 
    if (status == 0 && (unsigned int)value == 23205U) 
                                                      #line 243 
                                                      goto out;
    #line 245 
    if (status != 0 || (unsigned int)value != 4951U) 
                                                     #line 246 
                                                     break;
    #line 249 
    (*(hw->mac.ops.release_swfw_sync))(hw,swfw_mask);
    #line 250 
    msleep(30U);
    #line 232 
    __Cont: 
            #line 232 
    retry = (u8)((int)retry + 1);
  }
  #line 253 
  if ((unsigned int)retry == 15U) {
    #line 254 
    status = (*(hw->mac.ops.acquire_swfw_sync))(hw,swfw_mask);
    #line 255 
    if (status != 0) {
      #line 256 
      netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"semaphore failed with %d\n",status);
      #line 257 
      return;
    }
  }
  #line 262 
  status = ixgbe_reset_cs4227(hw);
  #line 263 
  if (status != 0) {
    #line 264 
    netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"CS4227 reset failed: %d",status);
    #line 265 
    goto out;
  }
  #line 271 
  ixgbe_write_cs4227(hw,(unsigned short)2,(unsigned short)4951);
  #line 273 
  (*(hw->mac.ops.release_swfw_sync))(hw,swfw_mask);
  #line 274 
  usleep_range(10000UL,12000UL);
  #line 275 
  status = (*(hw->mac.ops.acquire_swfw_sync))(hw,swfw_mask);
  #line 276 
  if (status != 0) {
    #line 277 
    netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"semaphore failed with %d",status);
    #line 278 
    return;
  }
  #line 282 
  status = ixgbe_write_cs4227(hw,(unsigned short)2,(unsigned short)23205);
  #line 285 
  out: 
       #line 285 
  ;
  #line 286 
  (*(hw->mac.ops.release_swfw_sync))(hw,swfw_mask);
  #line 287 
  msleep(hw->eeprom.semaphore_delay);
  #line 288 
  return;
}

#line 295  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_identify_phy_x550em(struct ixgbe_hw *hw)
{
  #line 297 
  switch ((int)hw->device_id) {
    #line 298 
    case 5582: 
               #line 298 
    ;
    #line 299 
    if ((unsigned int)hw->bus.lan_id != 0U) 
                                            #line 300 
                                            hw->phy.phy_semaphore_mask = 4U; else 
                                                                    #line 302 
                                                                    hw->phy.phy_semaphore_mask = 2U;
    #line 303 
    return ixgbe_identify_module_generic(hw);
    #line 304 
    case 5548: 
               #line 304 
    ;
    #line 306 
    hw->phy.phy_semaphore_mask = 6150U;
    #line 307 
    ixgbe_setup_mux_ctl(hw);
    #line 308 
    ixgbe_check_cs4227(hw);
    #line 310 
    case 5572: 
               #line 310 
    ;
    #line 311 
    return ixgbe_identify_module_generic(hw);
    #line 312 
    case 5546: 
               #line 312 
    ;
    #line 313 
    hw->phy.type = ixgbe_phy_x550em_kx4;
    #line 314 
    break;
    #line 315 
    case 5552: 
               #line 315 
    ;
    #line 316 
    hw->phy.type = ixgbe_phy_x550em_xfi;
    #line 317 
    break;
    #line 318 
    case 5547: 
               #line 318 
    ;
    #line 319 
    case 5570: 
               #line 319 
    ;
    #line 320 
    case 5571: 
               #line 320 
    ;
    #line 321 
    hw->phy.type = ixgbe_phy_x550em_kr;
    #line 322 
    break;
    #line 323 
    case 5576: 
               #line 323 
    ;
    #line 324 
    if ((unsigned int)hw->bus.lan_id != 0U) 
                                            #line 325 
                                            hw->phy.phy_semaphore_mask = 4U; else 
                                                                    #line 327 
                                                                    hw->phy.phy_semaphore_mask = 2U;
    #line 329 
    case 5549: 
               #line 329 
    ;
    #line 330 
    return ixgbe_identify_phy_generic(hw);
    #line 331 
    case 5550: 
               #line 331 
    ;
    #line 332 
    hw->phy.type = ixgbe_phy_ext_1g_t;
    #line 333 
    break;
    #line 334 
    case 5604: 
               #line 334 
    ;
    #line 335 
    case 5605: 
               #line 335 
    ;
    #line 336 
    hw->phy.type = ixgbe_phy_fw;
    #line 337 
    hw->phy.ops.read_reg = (s32 (*)(struct ixgbe_hw *, u32 , u32 , u16 *))0;
    #line 338 
    hw->phy.ops.write_reg = (s32 (*)(struct ixgbe_hw *, u32 , u32 , u16 ))0;
    #line 339 
    if ((unsigned int)hw->bus.lan_id != 0U) 
                                            #line 340 
                                            hw->phy.phy_semaphore_mask |= 4U; else 
                                                                    #line 342 
                                                                    hw->phy.phy_semaphore_mask |= 2U;
    #line 343 
    break;
    #line 344 
    default: 
             #line 344 
    ;
    #line 345 
    break;
  }
  #line 347 
  return 0;
}

#line 350  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_read_phy_reg_x550em(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type, u16 *phy_data)
{
  #line 353 
  return 2147483647;
}

#line 356  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_write_phy_reg_x550em(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type, u16 phy_data)
{
  #line 359 
  return 2147483647;
}

#line 371  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_read_i2c_combined_generic(struct ixgbe_hw *hw, u8 addr, u16 reg, u16 *val)
{
  #line 374 
  return ixgbe_read_i2c_combined_generic_int(hw,(unsigned char)((int)addr),
                                          (unsigned short)((int)reg),val,
                                          (_Bool)1);
}

#line 387  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_read_i2c_combined_generic_unlocked(struct ixgbe_hw *hw, u8 addr, u16 reg, u16 *val)
{
  #line 390 
  return ixgbe_read_i2c_combined_generic_int(hw,(unsigned char)((int)addr),
                                          (unsigned short)((int)reg),val,
                                          (_Bool)0);
}

#line 402  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_write_i2c_combined_generic(struct ixgbe_hw *hw, u8 addr, u16 reg, u16 val)
{
  #line 405 
  return ixgbe_write_i2c_combined_generic_int(hw,(unsigned char)((int)addr),
                                           (unsigned short)((int)reg),
                                           (unsigned short)((int)val),
                                           (_Bool)1);
}

#line 418  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_write_i2c_combined_generic_unlocked(struct ixgbe_hw *hw, u8 addr, u16 reg, u16 val)
{
  #line 421 
  return ixgbe_write_i2c_combined_generic_int(hw,(unsigned char)((int)addr),
                                           (unsigned short)((int)reg),
                                           (unsigned short)((int)val),
                                           (_Bool)0);
}

#line 430  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
s32 ixgbe_fw_phy_activity(struct ixgbe_hw *hw, u16 activity, u32 (*data)[4U])
{
  #line 436 
  union __anonunion_hic_9272 hic;
  #line 438 
  s32 rc;
  #line 439 
  u32 i;
  #line 437 
  u16 retries = (unsigned short)50U;
  #line 441 
  while (1) {
    #line 442 
    memset((void *)(& hic),0,24UL);
    #line 443 
    hic.cmd.hdr.cmd = (unsigned char)5U;
    #line 444 
    hic.cmd.hdr.buf_len = (unsigned char)20U;
    #line 445 
    hic.cmd.hdr.checksum = (unsigned char)255U;
    #line 446 
    hic.cmd.port_number = hw->bus.lan_id;
    #line 447 
    hic.cmd.activity_id = activity;
    #line 448 
    i = 0U;
    #line 448 
    while (i <= 3U) {
      #line 449 
      hic.cmd.data[i] = __builtin_bswap32((*data)[i]);
      #line 448 
      i ++;
    }
    #line 451 
    rc = ixgbe_host_interface_command(hw,(void *)(& hic.cmd),24U,500U,(_Bool)1);
    #line 454 
    if (rc != 0) 
                 #line 455 
                 return rc;
    #line 456 
    if ((unsigned int)hic.rsp.hdr.cmd_or_resp.ret_status == 1U) {
      #line 458 
      i = 0U;
      #line 458 
      while (i <= 3U) {
        #line 459 
        (*data)[i] = __builtin_bswap32(hic.rsp.data[i]);
        #line 458 
        i ++;
      }
      #line 460 
      return 0;
    }
    #line 462 
    usleep_range(20UL,30UL);
    #line 463 
    retries = (u16)((int)retries - 1);
    #line 464 
    if (! ((unsigned int)retries != 0U)) 
                                         #line 441 
                                         break;
  }
  #line 466 
  return -33;
}

#line 472  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static struct __anonstruct_ixgbe_fw_map_9274 ixgbe_fw_map[6U] = {{.fw_speed = (unsigned short)1U, .phy_speed = 2U}, {.fw_speed = (unsigned short)2U, .phy_speed = 8U}, {.fw_speed = (unsigned short)4U, .phy_speed = 32U}, {.fw_speed = (unsigned short)8U, .phy_speed = 1024U}, {.fw_speed = (unsigned short)16U, .phy_speed = 2048U}, {.fw_speed = (unsigned short)32U, .phy_speed = 128U}};
#line 487  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_get_phy_id_fw(struct ixgbe_hw *hw)
{
  #line 490 
  u16 phy_speeds;
  #line 491 
  u16 phy_id_lo;
  #line 492 
  s32 rc;
  #line 493 
  u16 i;
  #line 489 
  u32 info[4U] = {0U};
  #line 495 
  if (hw->phy.id != 0U) 
                        #line 496 
                        return 0;
  #line 498 
  rc = ixgbe_fw_phy_activity(hw,(unsigned short)7,& info);
  #line 499 
  if (rc != 0) 
               #line 500 
               return rc;
  #line 502 
  hw->phy.speeds_supported = 0U;
  #line 503 
  phy_speeds = (unsigned short)((unsigned int)((unsigned short)info[0]) & 4095U);
  #line 504 
  i = (unsigned short)0U;
  #line 504 
  while ((unsigned int)i <= 5U) {
    #line 505 
    if ((unsigned int)((int)ixgbe_fw_map[(int)i].fw_speed & (int)phy_speeds) != 0U) 
      #line 506 
      hw->phy.speeds_supported |= ixgbe_fw_map[(int)i].phy_speed;
    #line 504 
    i = (u16)((int)i + 1);
  }
  #line 509 
  hw->phy.id = info[0] & 4294901760U;
  #line 510 
  phy_id_lo = (unsigned short)info[1];
  #line 511 
  hw->phy.id |= (unsigned int)phy_id_lo & 4294967280U;
  #line 512 
  hw->phy.revision = (unsigned int)phy_id_lo & 15U;
  #line 513 
  if (hw->phy.id == 0U || hw->phy.id == 4294967280U) 
                                                     #line 514 
                                                     return -17;
  #line 516 
  hw->phy.autoneg_advertised = hw->phy.speeds_supported;
  #line 517 
  hw->phy.eee_speeds_supported = 40U;
  #line 519 
  hw->phy.eee_speeds_advertised = hw->phy.eee_speeds_supported;
  #line 520 
  return 0;
}

#line 529  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_identify_phy_fw(struct ixgbe_hw *hw)
{
  #line 531 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 532 
                                          hw->phy.phy_semaphore_mask = 4U; else 
                                                                    #line 534 
                                                                    hw->phy.phy_semaphore_mask = 2U;
  #line 536 
  hw->phy.type = ixgbe_phy_fw;
  #line 537 
  hw->phy.ops.read_reg = (s32 (*)(struct ixgbe_hw *, u32 , u32 , u16 *))0;
  #line 538 
  hw->phy.ops.write_reg = (s32 (*)(struct ixgbe_hw *, u32 , u32 , u16 ))0;
  #line 539 
  return ixgbe_get_phy_id_fw(hw);
}

#line 548  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_shutdown_fw_phy(struct ixgbe_hw *hw)
{
  #line 550 
  u32 setup[4U] = {0U};
  #line 552 
  setup[0] = 1U;
  #line 553 
  return ixgbe_fw_phy_activity(hw,(unsigned short)4,& setup);
}

#line 560  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_setup_fw_link(struct ixgbe_hw *hw)
{
  #line 563 
  s32 rc;
  #line 564 
  u16 i;
  #line 562 
  u32 setup[4U] = {0U};
  #line 566 
  if ((int)hw->phy.reset_disable != 0) 
                                       #line 567 
                                       return 0;
  else {
    #line 566 
    if ((int)ixgbe_check_reset_blocked(hw) != 0) 
                                                 #line 567 
                                                 return 0;
  }
  #line 569 
  if ((int)hw->fc.strict_ieee != 0 && hw->fc.requested_mode == (unsigned int)ixgbe_fc_rx_pause) {
    #line 570 
    netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"rx_pause not valid in strict IEEE mode\n");
    #line 571 
    return -13;
  }
  #line 574 
  switch ((unsigned int)hw->fc.requested_mode) {
    #line 575 
    case (unsigned int)3: 
                          #line 575 
    ;
    #line 576 
    setup[0] |= 196608U;
    #line 578 
    break;
    #line 579 
    case (unsigned int)1: 
                          #line 579 
    ;
    #line 580 
    setup[0] |= 131072U;
    #line 582 
    break;
    #line 583 
    case (unsigned int)2: 
                          #line 583 
    ;
    #line 584 
    setup[0] |= 65536U;
    #line 586 
    break;
    #line 587 
    default: 
             #line 587 
    ;
    #line 588 
    break;
  }
  #line 591 
  i = (unsigned short)0U;
  #line 591 
  while ((unsigned int)i <= 5U) {
    #line 592 
    if ((hw->phy.autoneg_advertised & ixgbe_fw_map[(int)i].phy_speed) != 0U) 
      #line 593 
      setup[0] |= (unsigned int)ixgbe_fw_map[(int)i].fw_speed;
    #line 591 
    i = (u16)((int)i + 1);
  }
  #line 595 
  setup[0] |= 4718592U;
  #line 597 
  if (hw->phy.eee_speeds_advertised != 0U) 
                                           #line 598 
                                           setup[0] |= 1048576U;
  #line 600 
  rc = ixgbe_fw_phy_activity(hw,(unsigned short)2,& setup);
  #line 601 
  if (rc != 0) 
               #line 602 
               return rc;
  #line 603 
  if (setup[0] == 1U) 
                      #line 604 
                      return -26;
  #line 605 
  return 0;
}

#line 614  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_fc_autoneg_fw(struct ixgbe_hw *hw)
{
  #line 616 
  if (hw->fc.requested_mode == (unsigned int)ixgbe_fc_default) 
                                                               #line 617 
                                                               hw->fc.requested_mode = ixgbe_fc_full;
  #line 619 
  return ixgbe_setup_fw_link(hw);
}

#line 628  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_init_eeprom_params_X550(struct ixgbe_hw *hw)
{
  #line 631 
  u32 eec;
  #line 632 
  u16 eeprom_size;
  #line 630 
  struct ixgbe_eeprom_info *eeprom = & hw->eeprom;
  #line 634 
  if (eeprom->type == (unsigned int)ixgbe_eeprom_uninitialized) {
    #line 635 
    eeprom->semaphore_delay = 10U;
    #line 636 
    eeprom->type = ixgbe_flash;
    #line 638 
    eec = ixgbe_read_reg(hw,*(hw->mvals));
    #line 639 
    eeprom_size = (unsigned short)((unsigned int)((unsigned short)(eec >> 11)) & 15U);
    #line 641 
    eeprom->word_size = (unsigned short)(1UL << ((int)eeprom_size + 6));
    {
      #line 644 
      bool branch;
      #line 644 
      struct _ddebug __UNIQUE_ID_ddebug443 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_init_eeprom_params_X550", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c", .format = (char *)"Eeprom params: type = %d, size = %d\n", .lineno = (unsigned int)644U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 644 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug443.key.dd_key_false.key,(_Bool)0);
      #line 644 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 644 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug443,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Eeprom params: type = %d, size = %d\n",(unsigned int)eeprom->type,(int)eeprom->word_size);
    }
  }
  #line 648 
  return 0;
}

#line 660  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_iosf_wait(struct ixgbe_hw *hw, u32 *ctrl)
{
  #line 662 
  u32 i;
  #line 662 
  u32 command;
  #line 668 
  i = 0U;
  #line 668 
  while (i <= 99U) {
    #line 669 
    command = ixgbe_read_reg(hw,69956U);
    #line 670 
    if (((unsigned long)command & 2147483648UL) == 0UL) 
                                                        #line 671 
                                                        break;
    #line 672 
    __const_udelay(42950UL);
    #line 668 
    i ++;
  }
  #line 674 
  if (ctrl != (u32 *)0U) 
                         #line 675 
                         *ctrl = command;
  #line 676 
  if (i == 100U) {
    {
      #line 677 
      bool branch;
      #line 677 
      struct _ddebug __UNIQUE_ID_ddebug444 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_iosf_wait", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c", .format = (char *)"IOSF wait timed out\n", .lineno = (unsigned int)677U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 677 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug444.key.dd_key_false.key,(_Bool)0);
      #line 677 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 677 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug444,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"IOSF wait timed out\n");
    }
    #line 678 
    return -3;
  }
  #line 681 
  return 0;
}

#line 691  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_read_iosf_sb_reg_x550(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type, u32 *data)
{
  #line 695 
  u32 command;
  #line 695 
  u32 error;
  #line 696 
  s32 ret;
  #line 694 
  u32 gssr = 6U;
  #line 698 
  ret = (*(hw->mac.ops.acquire_swfw_sync))(hw,gssr);
  #line 699 
  if (ret != 0) 
                #line 700 
                return ret;
  #line 702 
  ret = ixgbe_iosf_wait(hw,(u32 *)0U);
  #line 703 
  if (ret != 0) 
                #line 704 
                goto out;
  #line 706 
  command = (device_type << 28) | reg_addr;
  #line 710 
  ixgbe_write_reg_8(hw,69956U,command);
  #line 712 
  ret = ixgbe_iosf_wait(hw,& command);
  #line 714 
  if ((command & 786432U) != 0U) {
    #line 715 
    error = (command >> 20) & 255U;
    {
      #line 717 
      bool branch;
      #line 717 
      struct _ddebug __UNIQUE_ID_ddebug445 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_read_iosf_sb_reg_x550", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c", .format = (char *)"Failed to read, error %x\n", .lineno = (unsigned int)717U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 717 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug445.key.dd_key_false.key,(_Bool)0);
      #line 717 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 717 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug445,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Failed to read, error %x\n",error);
    }
    #line 718 
    return -3;
  }
  #line 721 
  if (ret == 0) 
                #line 722 
                *data = ixgbe_read_reg(hw,69960U);
  #line 724 
  out: 
       #line 724 
  ;
  #line 725 
  (*(hw->mac.ops.release_swfw_sync))(hw,gssr);
  #line 726 
  return ret;
}

#line 733  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_get_phy_token(struct ixgbe_hw *hw)
{
  #line 735 
  struct ixgbe_hic_phy_token_req token_cmd;
  #line 736 
  s32 status;
  #line 738 
  token_cmd.hdr.cmd = (unsigned char)10U;
  #line 739 
  token_cmd.hdr.buf_len = (unsigned char)2U;
  #line 740 
  token_cmd.hdr.cmd_or_resp.cmd_resv = (unsigned char)0U;
  #line 741 
  token_cmd.hdr.checksum = (unsigned char)255U;
  #line 742 
  token_cmd.port_number = hw->bus.lan_id;
  #line 743 
  token_cmd.command_type = (unsigned char)0U;
  #line 744 
  token_cmd.pad = (unsigned short)0U;
  #line 745 
  status = ixgbe_host_interface_command(hw,(void *)(& token_cmd),8U,500U,(_Bool)1);
  #line 748 
  if (status != 0) 
                   #line 749 
                   return status;
  #line 750 
  if ((unsigned int)token_cmd.hdr.cmd_or_resp.ret_status == 1U) 
                                                                #line 751 
                                                                return 0;
  #line 752 
  if ((unsigned int)token_cmd.hdr.cmd_or_resp.ret_status != 128U) 
                                                                  #line 753 
                                                                  return -39;
  #line 755 
  return -40;
}

#line 762  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_put_phy_token(struct ixgbe_hw *hw)
{
  #line 764 
  struct ixgbe_hic_phy_token_req token_cmd;
  #line 765 
  s32 status;
  #line 767 
  token_cmd.hdr.cmd = (unsigned char)10U;
  #line 768 
  token_cmd.hdr.buf_len = (unsigned char)2U;
  #line 769 
  token_cmd.hdr.cmd_or_resp.cmd_resv = (unsigned char)0U;
  #line 770 
  token_cmd.hdr.checksum = (unsigned char)255U;
  #line 771 
  token_cmd.port_number = hw->bus.lan_id;
  #line 772 
  token_cmd.command_type = (unsigned char)1U;
  #line 773 
  token_cmd.pad = (unsigned short)0U;
  #line 774 
  status = ixgbe_host_interface_command(hw,(void *)(& token_cmd),8U,500U,(_Bool)1);
  #line 777 
  if (status != 0) 
                   #line 778 
                   return status;
  #line 779 
  if ((unsigned int)token_cmd.hdr.cmd_or_resp.ret_status == 1U) 
                                                                #line 780 
                                                                return 0;
  #line 781 
  return -39;
}

#line 791  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_write_iosf_sb_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type, u32 data)
{
  #line 795 
  struct ixgbe_hic_internal_phy_req write_cmd;
  #line 797 
  memset((void *)(& write_cmd),0,16UL);
  #line 798 
  write_cmd.hdr.cmd = (unsigned char)11U;
  #line 799 
  write_cmd.hdr.buf_len = (unsigned char)10U;
  #line 800 
  write_cmd.hdr.checksum = (unsigned char)255U;
  #line 801 
  write_cmd.port_number = hw->bus.lan_id;
  #line 802 
  write_cmd.command_type = (unsigned char)1U;
  #line 803 
  write_cmd.address = __builtin_bswap16((unsigned short)((int)((unsigned short)reg_addr)));
  #line 804 
  write_cmd.write_data = __builtin_bswap32(data);
  #line 806 
  return ixgbe_host_interface_command(hw,(void *)(& write_cmd),16U,500U,
                                   (_Bool)0);
}

#line 817  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_read_iosf_sb_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type, u32 *data)
{
  #line 824 
  union __anonunion_hic_9278 hic;
  #line 825 
  s32 status;
  #line 827 
  memset((void *)(& hic),0,16UL);
  #line 828 
  hic.cmd.hdr.cmd = (unsigned char)11U;
  #line 829 
  hic.cmd.hdr.buf_len = (unsigned char)10U;
  #line 830 
  hic.cmd.hdr.checksum = (unsigned char)255U;
  #line 831 
  hic.cmd.port_number = hw->bus.lan_id;
  #line 832 
  hic.cmd.command_type = (unsigned char)0U;
  #line 833 
  hic.cmd.address = __builtin_bswap16((unsigned short)((int)((unsigned short)reg_addr)));
  #line 835 
  status = ixgbe_host_interface_command(hw,(void *)(& hic.cmd),16U,500U,(_Bool)1);
  #line 839 
  *data = __builtin_bswap32(hic.rsp.read_data);
  #line 841 
  return status;
}

#line 852  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_read_ee_hostif_buffer_X550(struct ixgbe_hw *hw, u16 offset, u16 words, u16 *data)
{
  #line 856 
  struct ixgbe_hic_read_shadow_ram buffer;
  #line 858 
  u16 words_to_read;
  #line 859 
  s32 status;
  #line 860 
  u32 i;
  #line 855 
  u32 mask = 1025U;
  #line 857 
  u32 current_word = 0U;
  #line 863 
  status = (*(hw->mac.ops.acquire_swfw_sync))(hw,1025U);
  #line 864 
  if (status != 0) {
    {
      #line 865 
      bool branch;
      #line 865 
      struct _ddebug __UNIQUE_ID_ddebug446 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_read_ee_hostif_buffer_X550", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c", .format = (char *)"EEPROM read buffer - semaphore failed\n", .lineno = (unsigned int)865U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 865 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug446.key.dd_key_false.key,(_Bool)0);
      #line 865 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 865 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug446,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"EEPROM read buffer - semaphore failed\n");
    }
    #line 866 
    return status;
  }
  #line 869 
  while ((unsigned int)words != 0U) {
    #line 870 
    if ((unsigned int)words > 512U) 
                                    #line 871 
                                    words_to_read = (unsigned short)512U; else 
                                                                    #line 873 
                                                                    words_to_read = words;
    #line 875 
    buffer.hdr.req.cmd = (unsigned char)49U;
    #line 876 
    buffer.hdr.req.buf_lenh = (unsigned char)0U;
    #line 877 
    buffer.hdr.req.buf_lenl = (unsigned char)6U;
    #line 878 
    buffer.hdr.req.checksum = (unsigned char)255U;
    #line 881 
    buffer.address = __builtin_bswap32(((unsigned int)offset + current_word) * 2U);
    #line 883 
    buffer.length = __builtin_bswap16((unsigned short)((int)((unsigned int)words_to_read * 2U)));
    #line 884 
    buffer.pad2 = (unsigned short)0U;
    #line 885 
    buffer.pad3 = (unsigned short)0U;
    #line 887 
    status = ixgbe_hic_unlocked(hw,(u32 *)(& buffer),16U,500U);
    #line 889 
    if (status != 0) {
      {
        #line 890 
        bool branch_0;
        #line 890 
        struct _ddebug __UNIQUE_ID_ddebug447 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_read_ee_hostif_buffer_X550", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c", .format = (char *)"Host interface command failed\n", .lineno = (unsigned int)890U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 890 
        branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug447.key.dd_key_false.key,(_Bool)0);
        #line 890 
        if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                      #line 890 
                                                      __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug447,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Host interface command failed\n");
      }
      #line 891 
      goto out;
    }
    #line 894 
    i = 0U;
    #line 894 
    while ((unsigned int)words_to_read > i) {
      {
        #line 895 
        u32 reg = (i + 44038U) * 2U;
        #line 897 
        u32 value = ixgbe_read_reg(hw,reg);
        #line 899 
        *(data + (unsigned long)current_word) = (unsigned short)value;
        #line 900 
        current_word ++;
        #line 901 
        i ++;
        #line 902 
        if ((unsigned int)words_to_read > i) {
          #line 903 
          value >>= 16;
          #line 904 
          *(data + (unsigned long)current_word) = (unsigned short)value;
          #line 905 
          current_word ++;
        }
      }
      #line 894 
      i ++;
    }
    #line 908 
    words = (unsigned short)((int)words - (int)words_to_read);
  }
  #line 911 
  out: 
       #line 911 
  ;
  #line 912 
  (*(hw->mac.ops.release_swfw_sync))(hw,1025U);
  #line 913 
  return status;
}

#line 924  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_checksum_ptr_x550(struct ixgbe_hw *hw, u16 ptr, u16 size, u16 *csum, u16 *buffer, u32 buffer_size)
{
  #line 928 
  u16 buf[256U];
  #line 929 
  s32 status;
  #line 930 
  u16 length;
  #line 930 
  u16 bufsz;
  #line 930 
  u16 i;
  #line 930 
  u16 start;
  #line 931 
  u16 *local_buffer;
  #line 933 
  bufsz = (unsigned short)256U;
  #line 936 
  if (buffer == (u16 *)0U) {
    #line 937 
    status = ixgbe_read_ee_hostif_buffer_X550(hw,(unsigned short)((int)ptr),(unsigned short)((int)bufsz),(u16 *)(& buf));
    #line 938 
    if (status != 0) {
      {
        #line 939 
        bool branch;
        #line 939 
        struct _ddebug __UNIQUE_ID_ddebug448 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_checksum_ptr_x550", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c", .format = (char *)"Failed to read EEPROM image\n", .lineno = (unsigned int)939U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 939 
        branch = arch_static_branch(& __UNIQUE_ID_ddebug448.key.dd_key_false.key,(_Bool)0);
        #line 939 
        if ((long)((long)((int)branch != 0)) != 0L) 
                                                    #line 939 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug448,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Failed to read EEPROM image\n");
      }
      #line 940 
      return status;
    }
    #line 942 
    local_buffer = (u16 *)(& buf);
  }
  else {
    #line 944 
    if ((unsigned int)ptr > buffer_size) 
                                         #line 945 
                                         return -5;
    #line 946 
    local_buffer = buffer + (unsigned long)ptr;
  }
  #line 949 
  if ((unsigned int)size != 0U) {
    #line 950 
    start = (unsigned short)0U;
    #line 951 
    length = size;
  }
  else {
    #line 953 
    start = (unsigned short)1U;
    #line 954 
    length = *local_buffer;
    #line 957 
    if ((unsigned int)length + 65535U > 65533U || (int)ptr + (int)length >= (int)hw->eeprom.word_size) 
      #line 959 
      return 0;
  }
  #line 962 
  if (buffer != (u16 *)0U && (unsigned int)start + (unsigned int)length > buffer_size) 
    #line 963 
    return -5;
  #line 965 
  i = start;
  #line 965 
  while ((unsigned int)length != 0U) {
    #line 966 
    if ((int)i == (int)bufsz && buffer == (u16 *)0U) {
      #line 967 
      ptr = (unsigned short)((int)ptr + (int)bufsz);
      #line 968 
      i = (unsigned short)0U;
      #line 969 
      if ((int)length < (int)bufsz) 
                                    #line 970 
                                    bufsz = length;
      #line 973 
      status = ixgbe_read_ee_hostif_buffer_X550(hw,(unsigned short)((int)ptr),(unsigned short)((int)bufsz),(u16 *)(& buf));
      #line 975 
      if (status != 0) {
        {
          #line 976 
          bool branch_0;
          #line 976 
          struct _ddebug __UNIQUE_ID_ddebug449 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_checksum_ptr_x550", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c", .format = (char *)"Failed to read EEPROM image\n", .lineno = (unsigned int)976U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
          #line 976 
          branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug449.key.dd_key_false.key,(_Bool)0);
          #line 976 
          if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                        #line 976 
                                                        __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug449,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Failed to read EEPROM image\n");
        }
        #line 977 
        return status;
      }
    }
    #line 980 
    *csum = (unsigned short)((int)*csum + (int)*(local_buffer + (unsigned long)i));
    #line 965 
    i = (u16)((int)i + 1);
    #line 965 
    length = (u16)((int)length - 1);
  }
  #line 982 
  return 0;
}

#line 992  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_calc_checksum_X550(struct ixgbe_hw *hw, u16 *buffer, u32 buffer_size)
{
  #line 995 
  u16 eeprom_ptrs[66U];
  #line 996 
  u16 *local_buffer;
  #line 997 
  s32 status;
  #line 999 
  u16 pointer;
  #line 999 
  u16 i;
  #line 999 
  u16 size;
  #line 998 
  u16 checksum = (unsigned short)0U;
  #line 1001 
  (*(hw->eeprom.ops.init_params))(hw);
  #line 1003 
  if (buffer == (u16 *)0U) {
    #line 1005 
    status = ixgbe_read_ee_hostif_buffer_X550(hw,(unsigned short)0,(unsigned short)66,(u16 *)(& eeprom_ptrs));
    #line 1008 
    if (status != 0) {
      {
        #line 1009 
        bool branch;
        #line 1009 
        struct _ddebug __UNIQUE_ID_ddebug450 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_calc_checksum_X550", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c", .format = (char *)"Failed to read EEPROM image\n", .lineno = (unsigned int)1009U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 1009 
        branch = arch_static_branch(& __UNIQUE_ID_ddebug450.key.dd_key_false.key,(_Bool)0);
        #line 1009 
        if ((long)((long)((int)branch != 0)) != 0L) 
                                                    #line 1009 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug450,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Failed to read EEPROM image\n");
      }
      #line 1010 
      return status;
    }
    #line 1012 
    local_buffer = (u16 *)(& eeprom_ptrs);
  }
  else {
    #line 1014 
    if (buffer_size <= 64U) 
                            #line 1015 
                            return -5;
    #line 1016 
    local_buffer = buffer;
  }
  #line 1022 
  i = (unsigned short)0U;
  #line 1022 
  while ((unsigned int)i <= 65U) {
    #line 1023 
    if ((unsigned int)i != 63U) 
                                #line 1024 
                                checksum = (unsigned short)((int)*(local_buffer + (unsigned long)i) + (int)checksum);
    #line 1022 
    i = (u16)((int)i + 1);
  }
  #line 1029 
  i = (unsigned short)2U;
  #line 1029 
  while ((unsigned int)i <= 14U) {
    #line 1030 
    if ((unsigned int)i + 65532U <= 1U) 
                                        #line 1031 
                                        goto __Cont;
    #line 1033 
    pointer = *(local_buffer + (unsigned long)i);
    #line 1036 
    if ((unsigned int)pointer + 65535U > 65533U || (int)hw->eeprom.word_size <= (int)pointer) 
      #line 1038 
      goto __Cont;
    #line 1040 
    switch ((int)i) {
      #line 1041 
      case 6: 
              #line 1041 
      ;
      #line 1042 
      size = (unsigned short)36U;
      #line 1043 
      break;
      #line 1044 
      case 7: 
              #line 1044 
      ;
      #line 1045 
      case 8: 
              #line 1045 
      ;
      #line 1046 
      size = (unsigned short)8U;
      #line 1047 
      break;
      #line 1048 
      default: 
               #line 1048 
      ;
      #line 1049 
      size = (unsigned short)0U;
      #line 1050 
      break;
    }
    #line 1053 
    status = ixgbe_checksum_ptr_x550(hw,(unsigned short)((int)pointer),(unsigned short)((int)size),& checksum,buffer,buffer_size);
    #line 1055 
    if (status != 0) 
                     #line 1056 
                     return status;
    #line 1029 
    __Cont: 
            #line 1029 
    i = (u16)((int)i + 1);
  }
  #line 1059 
  checksum = (unsigned short)(47802U - (unsigned int)checksum);
  #line 1061 
  return (int)checksum;
}

#line 1069  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_calc_eeprom_checksum_X550(struct ixgbe_hw *hw)
{
  #line 1071 
  return ixgbe_calc_checksum_X550(hw,(u16 *)0U,0U);
}

#line 1081  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_read_ee_hostif_X550(struct ixgbe_hw *hw, u16 offset, u16 *data)
{
  #line 1084 
  struct ixgbe_hic_read_shadow_ram buffer;
  #line 1085 
  s32 status;
  #line 1083 
  u32 mask = 1025U;
  #line 1087 
  buffer.hdr.req.cmd = (unsigned char)49U;
  #line 1088 
  buffer.hdr.req.buf_lenh = (unsigned char)0U;
  #line 1089 
  buffer.hdr.req.buf_lenl = (unsigned char)6U;
  #line 1090 
  buffer.hdr.req.checksum = (unsigned char)255U;
  #line 1093 
  buffer.address = __builtin_bswap32((unsigned int)((int)offset * 2));
  #line 1095 
  buffer.length = (unsigned short)512U;
  #line 1097 
  status = (*(hw->mac.ops.acquire_swfw_sync))(hw,1025U);
  #line 1098 
  if (status != 0) 
                   #line 1099 
                   return status;
  #line 1101 
  status = ixgbe_hic_unlocked(hw,(u32 *)(& buffer),16U,500U);
  #line 1103 
  if (status == 0) {
    #line 1104 
    *data = (unsigned short)ixgbe_read_reg(hw,88076U);
  }
  #line 1108 
  (*(hw->mac.ops.release_swfw_sync))(hw,1025U);
  #line 1109 
  return status;
}

#line 1119  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_validate_eeprom_checksum_X550(struct ixgbe_hw *hw, u16 *checksum_val)
{
  #line 1122 
  s32 status;
  #line 1123 
  u16 checksum;
  #line 1124 
  u16 read_checksum = (unsigned short)0U;
  #line 1130 
  status = (*(hw->eeprom.ops.read))(hw,(unsigned short)0,& checksum);
  #line 1131 
  if (status != 0) {
    {
      #line 1132 
      bool branch;
      #line 1132 
      struct _ddebug __UNIQUE_ID_ddebug451 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_validate_eeprom_checksum_X550", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c", .format = (char *)"EEPROM read failed\n", .lineno = (unsigned int)1132U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1132 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug451.key.dd_key_false.key,(_Bool)0);
      #line 1132 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 1132 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug451,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"EEPROM read failed\n");
    }
    #line 1133 
    return status;
  }
  #line 1136 
  status = (*(hw->eeprom.ops.calc_checksum))(hw);
  #line 1137 
  if (status < 0) 
                  #line 1138 
                  return status;
  #line 1140 
  checksum = (unsigned short)status;
  #line 1142 
  status = ixgbe_read_ee_hostif_X550(hw,(unsigned short)63,& read_checksum);
  #line 1144 
  if (status != 0) 
                   #line 1145 
                   return status;
  #line 1150 
  if ((int)read_checksum != (int)checksum) {
    #line 1151 
    status = -2;
    {
      #line 1152 
      bool branch_0;
      #line 1152 
      struct _ddebug __UNIQUE_ID_ddebug452 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_validate_eeprom_checksum_X550", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c", .format = (char *)"Invalid EEPROM checksum", .lineno = (unsigned int)1152U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1152 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug452.key.dd_key_false.key,(_Bool)0);
      #line 1152 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 1152 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug452,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Invalid EEPROM checksum");
    }
  }
  #line 1156 
  if (checksum_val != (u16 *)0U) 
                                 #line 1157 
                                 *checksum_val = checksum;
  #line 1159 
  return status;
}

#line 1169  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_write_ee_hostif_data_X550(struct ixgbe_hw *hw, u16 offset, u16 data)
{
  #line 1172 
  s32 status;
  #line 1173 
  struct ixgbe_hic_write_shadow_ram buffer;
  #line 1175 
  buffer.hdr.req.cmd = (unsigned char)51U;
  #line 1176 
  buffer.hdr.req.buf_lenh = (unsigned char)0U;
  #line 1177 
  buffer.hdr.req.buf_lenl = (unsigned char)10U;
  #line 1178 
  buffer.hdr.req.checksum = (unsigned char)255U;
  #line 1181 
  buffer.length = (unsigned short)512U;
  #line 1182 
  buffer.data = data;
  #line 1183 
  buffer.address = __builtin_bswap32((unsigned int)((int)offset * 2));
  #line 1185 
  status = ixgbe_host_interface_command(hw,(void *)(& buffer),16U,500U,(_Bool)0);
  #line 1187 
  return status;
}

#line 1197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_write_ee_hostif_X550(struct ixgbe_hw *hw, u16 offset, u16 data)
{
  #line 1199 
  s32 status = 0;
  #line 1201 
  if ((*(hw->mac.ops.acquire_swfw_sync))(hw,1U) == 0) {
    #line 1202 
    status = ixgbe_write_ee_hostif_data_X550(hw,(unsigned short)((int)offset),(unsigned short)((int)data));
    #line 1203 
    (*(hw->mac.ops.release_swfw_sync))(hw,1U);
  }
  else {
    {
      #line 1205 
      bool branch;
      #line 1205 
      struct _ddebug __UNIQUE_ID_ddebug453 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_write_ee_hostif_X550", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c", .format = (char *)"write ee hostif failed to get semaphore", .lineno = (unsigned int)1205U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1205 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug453.key.dd_key_false.key,(_Bool)0);
      #line 1205 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 1205 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug453,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"write ee hostif failed to get semaphore");
    }
    #line 1206 
    status = -16;
  }
  #line 1209 
  return status;
}

#line 1217  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_update_flash_X550(struct ixgbe_hw *hw)
{
  #line 1220 
  union ixgbe_hic_hdr2 buffer;
  #line 1219 
  s32 status = 0;
  #line 1222 
  buffer.req.cmd = (unsigned char)54U;
  #line 1223 
  buffer.req.buf_lenh = (unsigned char)0U;
  #line 1224 
  buffer.req.buf_lenl = (unsigned char)0U;
  #line 1225 
  buffer.req.checksum = (unsigned char)255U;
  #line 1227 
  status = ixgbe_host_interface_command(hw,(void *)(& buffer),4U,500U,(_Bool)0);
  #line 1229 
  return status;
}

#line 1239  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_get_bus_info_X550em(struct ixgbe_hw *hw)
{
  #line 1241 
  hw->bus.type = ixgbe_bus_type_internal;
  #line 1242 
  hw->bus.width = ixgbe_bus_width_unknown;
  #line 1243 
  hw->bus.speed = ixgbe_bus_speed_unknown;
  #line 1245 
  (*(hw->mac.ops.set_lan_id))(hw);
  #line 1247 
  return 0;
}

#line 1256  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static bool ixgbe_fw_recovery_mode_X550(struct ixgbe_hw *hw)
{
  #line 1258 
  u32 fwsm;
  #line 1260 
  fwsm = ixgbe_read_reg(hw,*(hw->mvals + 6U));
  #line 1261 
  return (_Bool)(((unsigned long)fwsm & 32UL) != 0UL);
}

#line 1268  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static void ixgbe_disable_rx_x550(struct ixgbe_hw *hw)
{
  #line 1270 
  u32 rxctrl;
  #line 1270 
  u32 pfdtxgswc;
  #line 1271 
  s32 status;
  #line 1272 
  struct ixgbe_hic_disable_rxen fw_cmd;
  #line 1274 
  rxctrl = ixgbe_read_reg(hw,12288U);
  #line 1275 
  if ((rxctrl & 1U) != 0U) {
    #line 1276 
    pfdtxgswc = ixgbe_read_reg(hw,33312U);
    #line 1277 
    if ((pfdtxgswc & 1U) != 0U) {
      #line 1278 
      pfdtxgswc &= 4294967294U;
      #line 1279 
      ixgbe_write_reg_8(hw,33312U,pfdtxgswc);
      #line 1280 
      hw->mac.set_lben = (_Bool)1;
    }
    else 
         #line 1282 
         hw->mac.set_lben = (_Bool)0;
    #line 1285 
    fw_cmd.hdr.cmd = (unsigned char)222U;
    #line 1286 
    fw_cmd.hdr.buf_len = (unsigned char)1U;
    #line 1287 
    fw_cmd.hdr.checksum = (unsigned char)255U;
    #line 1288 
    fw_cmd.port_number = hw->bus.lan_id;
    #line 1290 
    status = ixgbe_host_interface_command(hw,(void *)(& fw_cmd),8U,500U,(_Bool)1);
    #line 1295 
    if (status != 0) {
      #line 1296 
      rxctrl = ixgbe_read_reg(hw,12288U);
      #line 1297 
      if ((rxctrl & 1U) != 0U) {
        #line 1298 
        rxctrl &= 4294967294U;
        #line 1299 
        ixgbe_write_reg_8(hw,12288U,rxctrl);
      }
    }
  }
  #line 1303 
  return;
}

#line 1312  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_update_eeprom_checksum_X550(struct ixgbe_hw *hw)
{
  #line 1314 
  s32 status;
  #line 1315 
  u16 checksum = (unsigned short)0U;
  #line 1321 
  status = ixgbe_read_ee_hostif_X550(hw,(unsigned short)0,& checksum);
  #line 1322 
  if (status != 0) {
    {
      #line 1323 
      bool branch;
      #line 1323 
      struct _ddebug __UNIQUE_ID_ddebug454 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_update_eeprom_checksum_X550", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c", .format = (char *)"EEPROM read failed\n", .lineno = (unsigned int)1323U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1323 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug454.key.dd_key_false.key,(_Bool)0);
      #line 1323 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 1323 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug454,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"EEPROM read failed\n");
    }
    #line 1324 
    return status;
  }
  #line 1327 
  status = ixgbe_calc_eeprom_checksum_X550(hw);
  #line 1328 
  if (status < 0) 
                  #line 1329 
                  return status;
  #line 1331 
  checksum = (unsigned short)status;
  #line 1333 
  status = ixgbe_write_ee_hostif_X550(hw,(unsigned short)63,(unsigned short)((int)checksum));
  #line 1335 
  if (status != 0) 
                   #line 1336 
                   return status;
  #line 1338 
  status = ixgbe_update_flash_X550(hw);
  #line 1340 
  return status;
}

#line 1352  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_write_ee_hostif_buffer_X550(struct ixgbe_hw *hw, u16 offset, u16 words, u16 *data)
{
  #line 1356 
  s32 status = 0;
  #line 1357 
  u32 i = 0U;
  #line 1360 
  status = (*(hw->mac.ops.acquire_swfw_sync))(hw,1U);
  #line 1361 
  if (status != 0) {
    {
      #line 1362 
      bool branch;
      #line 1362 
      struct _ddebug __UNIQUE_ID_ddebug455 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_write_ee_hostif_buffer_X550", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c", .format = (char *)"EEPROM write buffer - semaphore failed\n", .lineno = (unsigned int)1362U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1362 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug455.key.dd_key_false.key,(_Bool)0);
      #line 1362 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 1362 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug455,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"EEPROM write buffer - semaphore failed\n");
    }
    #line 1363 
    return status;
  }
  #line 1366 
  i = 0U;
  #line 1366 
  while ((unsigned int)words > i) {
    #line 1367 
    status = ixgbe_write_ee_hostif_data_X550(hw,(unsigned short)((int)((unsigned short)i) + (int)offset),(unsigned short)((int)*(data + (unsigned long)i)));
    #line 1369 
    if (status != 0) {
      {
        #line 1370 
        bool branch_0;
        #line 1370 
        struct _ddebug __UNIQUE_ID_ddebug456 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_write_ee_hostif_buffer_X550", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c", .format = (char *)"Eeprom buffered write failed\n", .lineno = (unsigned int)1370U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 1370 
        branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug456.key.dd_key_false.key,(_Bool)0);
        #line 1370 
        if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                      #line 1370 
                                                      __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug456,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Eeprom buffered write failed\n");
      }
      #line 1371 
      break;
    }
    #line 1366 
    i ++;
  }
  #line 1375 
  (*(hw->mac.ops.release_swfw_sync))(hw,1U);
  #line 1377 
  return status;
}

#line 1388  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_write_iosf_sb_reg_x550(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type, u32 data)
{
  #line 1392 
  u32 command;
  #line 1392 
  u32 error;
  #line 1393 
  s32 ret;
  #line 1391 
  u32 gssr = 6U;
  #line 1395 
  ret = (*(hw->mac.ops.acquire_swfw_sync))(hw,gssr);
  #line 1396 
  if (ret != 0) 
                #line 1397 
                return ret;
  #line 1399 
  ret = ixgbe_iosf_wait(hw,(u32 *)0U);
  #line 1400 
  if (ret != 0) 
                #line 1401 
                goto out;
  #line 1403 
  command = (device_type << 28) | reg_addr;
  #line 1407 
  ixgbe_write_reg_8(hw,69956U,command);
  #line 1410 
  ixgbe_write_reg_8(hw,69960U,data);
  #line 1412 
  ret = ixgbe_iosf_wait(hw,& command);
  #line 1414 
  if ((command & 786432U) != 0U) {
    #line 1415 
    error = (command >> 20) & 255U;
    {
      #line 1417 
      bool branch;
      #line 1417 
      struct _ddebug __UNIQUE_ID_ddebug457 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_write_iosf_sb_reg_x550", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c", .format = (char *)"Failed to write, error %x\n", .lineno = (unsigned int)1417U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1417 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug457.key.dd_key_false.key,(_Bool)0);
      #line 1417 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 1417 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug457,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Failed to write, error %x\n",error);
    }
    #line 1418 
    return -3;
  }
  #line 1421 
  out: 
       #line 1421 
  ;
  #line 1422 
  (*(hw->mac.ops.release_swfw_sync))(hw,gssr);
  #line 1423 
  return ret;
}

#line 1432  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_setup_ixfi_x550em_x(struct ixgbe_hw *hw)
{
  #line 1434 
  s32 status;
  #line 1435 
  u32 reg_val;
  #line 1438 
  unsigned int tmp;
  #line 1445 
  unsigned int tmp_0;
  #line 1452 
  unsigned int tmp_1;
  #line 1461 
  unsigned int tmp_2;
  #line 1467 
  unsigned int tmp_3;
  #line 1476 
  unsigned int tmp_4;
  #line 1483 
  unsigned int tmp_5;
  #line 1493 
  unsigned int tmp_6;
  #line 1438 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 1438 
                                          tmp = 35584U; else 
                                                             #line 1438 
                                                             tmp = 19200U;
  #line 1438 
  ;
  #line 1438 
  status = ixgbe_read_iosf_sb_reg_x550(hw,tmp,0U,& reg_val);
  #line 1441 
  if (status != 0) 
                   #line 1442 
                   return status;
  #line 1444 
  reg_val |= 16U;
  #line 1445 
  ;
  #line 1445 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 1445 
                                          tmp_0 = 35584U; else 
                                                               #line 1445 
                                                               tmp_0 = 19200U;
  #line 1445 
  ;
  #line 1445 
  status = ixgbe_write_iosf_sb_reg_x550(hw,tmp_0,0U,reg_val);
  #line 1448 
  if (status != 0) 
                   #line 1449 
                   return status;
  #line 1452 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 1452 
                                          tmp_1 = 34356U; else 
                                                               #line 1452 
                                                               tmp_1 = 17972U;
  #line 1452 
  ;
  #line 1452 
  status = ixgbe_read_iosf_sb_reg_x550(hw,tmp_1,0U,& reg_val);
  #line 1455 
  if (status != 0) 
                   #line 1456 
                   return status;
  #line 1458 
  reg_val &= 4294967231U;
  #line 1459 
  reg_val &= 4294934527U;
  #line 1460 
  reg_val &= 4294901759U;
  #line 1461 
  ;
  #line 1461 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 1461 
                                          tmp_2 = 34356U; else 
                                                               #line 1461 
                                                               tmp_2 = 17972U;
  #line 1461 
  ;
  #line 1461 
  status = ixgbe_write_iosf_sb_reg_x550(hw,tmp_2,0U,reg_val);
  #line 1464 
  if (status != 0) 
                   #line 1465 
                   return status;
  #line 1467 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 1467 
                                          tmp_3 = 34360U; else 
                                                               #line 1467 
                                                               tmp_3 = 17976U;
  #line 1467 
  ;
  #line 1467 
  status = ixgbe_read_iosf_sb_reg_x550(hw,tmp_3,0U,& reg_val);
  #line 1470 
  if (status != 0) 
                   #line 1471 
                   return status;
  #line 1473 
  reg_val &= 4294967231U;
  #line 1474 
  reg_val &= 4294934527U;
  #line 1475 
  reg_val &= 4294901759U;
  #line 1476 
  ;
  #line 1476 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 1476 
                                          tmp_4 = 34360U; else 
                                                               #line 1476 
                                                               tmp_4 = 17976U;
  #line 1476 
  ;
  #line 1476 
  status = ixgbe_write_iosf_sb_reg_x550(hw,tmp_4,0U,reg_val);
  #line 1479 
  if (status != 0) 
                   #line 1480 
                   return status;
  #line 1483 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 1483 
                                          tmp_5 = 38176U; else 
                                                               #line 1483 
                                                               tmp_5 = 21792U;
  #line 1483 
  ;
  #line 1483 
  status = ixgbe_read_iosf_sb_reg_x550(hw,tmp_5,0U,& reg_val);
  #line 1486 
  if (status != 0) 
                   #line 1487 
                   return status;
  #line 1489 
  reg_val |= 2147483648U;
  #line 1490 
  reg_val |= 8U;
  #line 1491 
  reg_val |= 4U;
  #line 1492 
  reg_val |= 2U;
  #line 1493 
  ;
  #line 1493 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 1493 
                                          tmp_6 = 38176U; else 
                                                               #line 1493 
                                                               tmp_6 = 21792U;
  #line 1493 
  ;
  #line 1493 
  status = ixgbe_write_iosf_sb_reg_x550(hw,tmp_6,0U,reg_val);
  #line 1496 
  return status;
}

#line 1504  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_restart_an_internal_phy_x550em(struct ixgbe_hw *hw)
{
  #line 1506 
  s32 status;
  #line 1507 
  u32 link_ctrl;
  #line 1510 
  unsigned int tmp;
  #line 1520 
  unsigned int tmp_1;
  #line 1510 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 1510 
                                          tmp = 33292U; else 
                                                             #line 1510 
                                                             tmp = 16908U;
  #line 1510 
  ;
  #line 1510 
  status = (*(hw->mac.ops.read_iosf_sb_reg))(hw,tmp,0U,& link_ctrl);
  #line 1514 
  if (status != 0) {
    {
      #line 1515 
      bool branch;
      #line 1515 
      struct _ddebug __UNIQUE_ID_ddebug458 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_restart_an_internal_phy_x550em", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c", .format = (char *)"Auto-negotiation did not complete\n", .lineno = (unsigned int)1515U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1515 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug458.key.dd_key_false.key,(_Bool)0);
      #line 1515 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 1515 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug458,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Auto-negotiation did not complete\n");
    }
    #line 1516 
    return status;
  }
  #line 1519 
  link_ctrl |= 2147483648U;
  #line 1520 
  ;
  #line 1520 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 1520 
                                          tmp_1 = 33292U; else 
                                                               #line 1520 
                                                               tmp_1 = 16908U;
  #line 1520 
  ;
  #line 1520 
  status = (*(hw->mac.ops.write_iosf_sb_reg))(hw,tmp_1,0U,link_ctrl);
  #line 1524 
  if (hw->mac.type == (unsigned int)ixgbe_mac_x550em_a) {
    #line 1525 
    u32 flx_mask_st20;
    #line 1528 
    unsigned int tmp_2;
    #line 1538 
    unsigned int tmp_4;
    #line 1528 
    if ((unsigned int)hw->bus.lan_id != 0U) 
                                            #line 1528 
                                            tmp_2 = 36948U; else 
                                                                 #line 1528 
                                                                 tmp_2 = 20564U;
    #line 1528 
    ;
    #line 1528 
    status = (*(hw->mac.ops.read_iosf_sb_reg))(hw,tmp_2,0U,& flx_mask_st20);
    #line 1532 
    if (status != 0) {
      {
        #line 1533 
        bool branch_0;
        #line 1533 
        struct _ddebug __UNIQUE_ID_ddebug459 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_restart_an_internal_phy_x550em", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c", .format = (char *)"Auto-negotiation did not complete\n", .lineno = (unsigned int)1533U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 1533 
        branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug459.key.dd_key_false.key,(_Bool)0);
        #line 1533 
        if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                      #line 1533 
                                                      __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug459,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Auto-negotiation did not complete\n");
      }
      #line 1534 
      return status;
    }
    #line 1537 
    flx_mask_st20 |= 2147483648U;
    #line 1538 
    ;
    #line 1538 
    if ((unsigned int)hw->bus.lan_id != 0U) 
                                            #line 1538 
                                            tmp_4 = 36948U; else 
                                                                 #line 1538 
                                                                 tmp_4 = 20564U;
    #line 1538 
    ;
    #line 1538 
    status = (*(hw->mac.ops.write_iosf_sb_reg))(hw,tmp_4,0U,flx_mask_st20);
  }
  #line 1543 
  return status;
}

#line 1553  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_setup_ixfi_x550em(struct ixgbe_hw *hw, ixgbe_link_speed *speed)
{
  #line 1556 
  s32 status;
  #line 1557 
  u32 reg_val;
  #line 1564 
  unsigned int tmp;
  #line 1586 
  unsigned int tmp_0;
  #line 1555 
  struct ixgbe_mac_info *mac = & hw->mac;
  #line 1560 
  if (mac->type != (unsigned int)ixgbe_mac_X550EM_x) 
                                                     #line 1561 
                                                     return -8;
  #line 1564 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 1564 
                                          tmp = 33292U; else 
                                                             #line 1564 
                                                             tmp = 16908U;
  #line 1564 
  ;
  #line 1564 
  status = ixgbe_read_iosf_sb_reg_x550(hw,tmp,0U,& reg_val);
  #line 1567 
  if (status != 0) 
                   #line 1568 
                   return status;
  #line 1570 
  reg_val &= 3758096383U;
  #line 1571 
  reg_val &= 4294965503U;
  #line 1574 
  switch (*speed) {
    #line 1575 
    case (ixgbe_link_speed)128: 
                                #line 1575 
    ;
    #line 1576 
    reg_val |= 1024U;
    #line 1577 
    break;
    #line 1578 
    case (ixgbe_link_speed)32: 
                               #line 1578 
    ;
    #line 1579 
    reg_val |= 512U;
    #line 1580 
    break;
    #line 1581 
    default: 
             #line 1581 
    ;
    #line 1583 
    return -8;
  }
  #line 1586 
  ;
  #line 1586 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 1586 
                                          tmp_0 = 33292U; else 
                                                               #line 1586 
                                                               tmp_0 = 16908U;
  #line 1586 
  ;
  #line 1586 
  status = ixgbe_write_iosf_sb_reg_x550(hw,tmp_0,0U,reg_val);
  #line 1589 
  if (status != 0) 
                   #line 1590 
                   return status;
  #line 1593 
  if (hw->mac.type == (unsigned int)ixgbe_mac_X550EM_x) {
    #line 1594 
    status = ixgbe_setup_ixfi_x550em_x(hw);
    #line 1595 
    if (status != 0) 
                     #line 1596 
                     return status;
  }
  #line 1600 
  status = ixgbe_restart_an_internal_phy_x550em(hw);
  #line 1602 
  return status;
}

#line 1610  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_supported_sfp_modules_X550em(struct ixgbe_hw *hw, bool *linear)
{
  #line 1612 
  switch ((unsigned int)hw->phy.sfp_type) {
    #line 1613 
    case (unsigned int)65534: 
                              #line 1613 
    ;
    #line 1614 
    return -20;
    #line 1615 
    case (unsigned int)3: 
                          #line 1615 
    ;
    #line 1616 
    case (unsigned int)4: 
                          #line 1616 
    ;
    #line 1617 
    *linear = (_Bool)1;
    #line 1618 
    break;
    #line 1619 
    case (unsigned int)5: 
                          #line 1619 
    ;
    #line 1620 
    case (unsigned int)6: 
                          #line 1620 
    ;
    #line 1621 
    case (unsigned int)7: 
                          #line 1621 
    ;
    #line 1622 
    case (unsigned int)8: 
                          #line 1622 
    ;
    #line 1623 
    case (unsigned int)11: 
                           #line 1623 
    ;
    #line 1624 
    case (unsigned int)12: 
                           #line 1624 
    ;
    #line 1625 
    case (unsigned int)13: 
                           #line 1625 
    ;
    #line 1626 
    case (unsigned int)14: 
                           #line 1626 
    ;
    #line 1627 
    *linear = (_Bool)0;
    #line 1628 
    break;
    #line 1629 
    case (unsigned int)65535: 
                              #line 1629 
    ;
    #line 1630 
    case (unsigned int)9: 
                          #line 1630 
    ;
    #line 1631 
    case (unsigned int)10: 
                           #line 1631 
    ;
    #line 1632 
    default: 
             #line 1632 
    ;
    #line 1633 
    return -19;
  }
  #line 1636 
  return 0;
}

#line 1648  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_setup_mac_link_sfp_x550em(struct ixgbe_hw *hw, ixgbe_link_speed speed, bool autoneg_wait_to_complete)
{
  #line 1652 
  s32 status;
  #line 1653 
  u16 reg_slice;
  #line 1653 
  u16 reg_val;
  #line 1654 
  bool setup_linear = (_Bool)0;
  #line 1657 
  status = ixgbe_supported_sfp_modules_X550em(hw,& setup_linear);
  #line 1663 
  if (status == -20) 
                     #line 1664 
                     return 0;
  #line 1666 
  if (status != 0) 
                   #line 1667 
                   return status;
  #line 1670 
  ixgbe_setup_kr_speed_x550em(hw,speed);
  #line 1673 
  reg_slice = (unsigned short)((unsigned int)((int)((unsigned short)hw->bus.lan_id) << 12U) + 4784U);
  #line 1674 
  if ((int)setup_linear != 0) 
                              #line 1675 
                              reg_val = (unsigned short)5U; else 
                                                                 #line 1677 
                                                                 reg_val = (unsigned short)9U;
  #line 1679 
  status = (*(hw->link.ops.write_link))(hw,(unsigned char)((int)hw->link.addr),(unsigned short)((int)reg_slice),(unsigned short)((int)reg_val));
  #line 1682 
  return status;
}

#line 1693  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_setup_sfi_x550a(struct ixgbe_hw *hw, ixgbe_link_speed *speed)
{
  #line 1696 
  s32 status;
  #line 1697 
  u32 reg_val;
  #line 1700 
  unsigned int tmp;
  #line 1724 
  unsigned int tmp_0;
  #line 1695 
  struct ixgbe_mac_info *mac = & hw->mac;
  #line 1700 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 1700 
                                          tmp = 36948U; else 
                                                             #line 1700 
                                                             tmp = 20564U;
  #line 1700 
  ;
  #line 1700 
  status = (*(mac->ops.read_iosf_sb_reg))(hw,tmp,0U,& reg_val);
  #line 1703 
  if (status != 0) 
                   #line 1704 
                   return status;
  #line 1706 
  reg_val &= 4160749567U;
  #line 1707 
  reg_val &= 4227858431U;
  #line 1708 
  reg_val &= 4261412863U;
  #line 1709 
  reg_val &= 2415919103U;
  #line 1712 
  switch (*speed) {
    #line 1713 
    case (ixgbe_link_speed)128: 
                                #line 1713 
    ;
    #line 1714 
    reg_val |= 805306368U;
    #line 1715 
    break;
    #line 1716 
    case (ixgbe_link_speed)32: 
                               #line 1716 
    ;
    #line 1717 
    reg_val |= 536870912U;
    #line 1718 
    break;
    #line 1719 
    default: 
             #line 1719 
    ;
    #line 1721 
    return -8;
  }
  #line 1724 
  ;
  #line 1724 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 1724 
                                          tmp_0 = 36948U; else 
                                                               #line 1724 
                                                               tmp_0 = 20564U;
  #line 1724 
  ;
  #line 1724 
  status = (*(mac->ops.write_iosf_sb_reg))(hw,tmp_0,0U,reg_val);
  #line 1729 
  status = ixgbe_restart_an_internal_phy_x550em(hw);
  #line 1731 
  return status;
}

#line 1743  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_setup_mac_link_sfp_n(struct ixgbe_hw *hw, ixgbe_link_speed speed, bool autoneg_wait_to_complete)
{
  #line 1747 
  u32 reg_phy_int;
  #line 1748 
  s32 ret_val;
  #line 1763 
  unsigned int tmp;
  #line 1773 
  unsigned int tmp_0;
  #line 1746 
  bool setup_linear = (_Bool)0;
  #line 1751 
  ret_val = ixgbe_supported_sfp_modules_X550em(hw,& setup_linear);
  #line 1756 
  if (ret_val == -20) 
                      #line 1757 
                      return 0;
  #line 1759 
  if (ret_val != 0) 
                    #line 1760 
                    return ret_val;
  #line 1763 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 1763 
                                          tmp = 36948U; else 
                                                             #line 1763 
                                                             tmp = 20564U;
  #line 1763 
  ;
  #line 1763 
  ret_val = (*(hw->mac.ops.read_iosf_sb_reg))(hw,tmp,0U,& reg_phy_int);
  #line 1766 
  if (ret_val != 0) 
                    #line 1767 
                    return ret_val;
  #line 1769 
  reg_phy_int &= 4291821567U;
  #line 1770 
  if (! setup_linear) 
                      #line 1771 
                      reg_phy_int |= 1048576U;
  #line 1773 
  ;
  #line 1773 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 1773 
                                          tmp_0 = 36948U; else 
                                                               #line 1773 
                                                               tmp_0 = 20564U;
  #line 1773 
  ;
  #line 1773 
  ret_val = (*(hw->mac.ops.write_iosf_sb_reg))(hw,tmp_0,0U,reg_phy_int);
  #line 1776 
  if (ret_val != 0) 
                    #line 1777 
                    return ret_val;
  #line 1780 
  return ixgbe_setup_sfi_x550a(hw,& speed);
}

#line 1792  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_setup_mac_link_sfp_x550a(struct ixgbe_hw *hw, ixgbe_link_speed speed, bool autoneg_wait_to_complete)
{
  #line 1795 
  u32 reg_slice;
  #line 1795 
  u32 slice_offset;
  #line 1797 
  u16 reg_phy_ext;
  #line 1798 
  s32 ret_val;
  #line 1796 
  bool setup_linear = (_Bool)0;
  #line 1801 
  ret_val = ixgbe_supported_sfp_modules_X550em(hw,& setup_linear);
  #line 1806 
  if (ret_val == -20) 
                      #line 1807 
                      return 0;
  #line 1809 
  if (ret_val != 0) 
                    #line 1810 
                    return ret_val;
  #line 1813 
  ixgbe_setup_kr_speed_x550em(hw,speed);
  #line 1815 
  if (hw->phy.mdio.prtad == -1) 
                                #line 1816 
                                return -17;
  #line 1819 
  ret_val = (*(hw->phy.ops.read_reg))(hw,415U,0U,& reg_phy_ext);
  #line 1821 
  if (ret_val != 0) 
                    #line 1822 
                    return ret_val;
  #line 1827 
  if ((unsigned int)reg_phy_ext == 16U) 
                                        #line 1828 
                                        slice_offset = (unsigned int)(((int)hw->bus.lan_id + ((int)hw->bus.instance_id << 1)) << 12); else 
                                                                    #line 1831 
                                                                    slice_offset = (unsigned int)((int)hw->bus.lan_id << 12);
  #line 1834 
  reg_slice = slice_offset + 4784U;
  #line 1836 
  ret_val = (*(hw->phy.ops.read_reg))(hw,reg_slice,0U,& reg_phy_ext);
  #line 1838 
  if (ret_val != 0) 
                    #line 1839 
                    return ret_val;
  #line 1841 
  reg_phy_ext = (unsigned short)((unsigned int)reg_phy_ext & 65523U);
  #line 1844 
  if ((int)setup_linear != 0) 
                              #line 1845 
                              reg_phy_ext = (unsigned short)((unsigned int)reg_phy_ext | 5U); else 
                                                                    #line 1847 
                                                                    reg_phy_ext = (unsigned short)((unsigned int)reg_phy_ext | 9U);
  #line 1849 
  ret_val = (*(hw->phy.ops.write_reg))(hw,reg_slice,0U,(unsigned short)((int)reg_phy_ext));
  #line 1851 
  if (ret_val != 0) 
                    #line 1852 
                    return ret_val;
  #line 1855 
  return (*(hw->phy.ops.read_reg))(hw,reg_slice,0U,& reg_phy_ext);
}

#line 1870  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_setup_mac_link_t_X550em(struct ixgbe_hw *hw, ixgbe_link_speed speed, bool autoneg_wait)
{
  #line 1874 
  s32 status;
  #line 1875 
  ixgbe_link_speed force_speed;
  #line 1880 
  if ((speed & 128U) != 0U) 
                            #line 1881 
                            force_speed = 128U; else 
                                                     #line 1883 
                                                     force_speed = 32U;
  #line 1887 
  if (hw->mac.type == (unsigned int)ixgbe_mac_X550EM_x && ((unsigned long)hw->phy.nw_mng_if_sel & 16777216UL) == 0UL) {
    #line 1889 
    status = ixgbe_setup_ixfi_x550em(hw,& force_speed);
    #line 1891 
    if (status != 0) 
                     #line 1892 
                     return status;
  }
  #line 1895 
  return (*(hw->phy.ops.setup_link_speed))(hw,speed,
                                        (_Bool)((bool)((int)autoneg_wait) != 0));
}

#line 1906  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_check_link_t_X550em(struct ixgbe_hw *hw, ixgbe_link_speed *speed, bool *link_up, bool link_up_wait_to_complete)
{
  #line 1911 
  u32 status;
  #line 1912 
  u16 i;
  #line 1912 
  u16 autoneg_status;
  #line 1914 
  if ((*(hw->mac.ops.get_media_type))(hw) != (unsigned int)ixgbe_media_type_copper) 
    #line 1915 
    return -4;
  #line 1917 
  status = (unsigned int)ixgbe_check_mac_link_generic(hw,speed,link_up,
                                     (_Bool)((bool)((int)link_up_wait_to_complete) != 0));
  #line 1921 
  if (status != 0U || ! *link_up) 
                                  #line 1922 
                                  return (int)status;
  #line 1929 
  i = (unsigned short)0U;
  #line 1929 
  while ((unsigned int)i <= 1U) {
    {
      #line 1930 
      status = (unsigned int)(*(hw->phy.ops.read_reg))(hw,1U,7U,& autoneg_status);
      #line 1933 
      if (status != 0U) 
                        #line 1934 
                        return (int)status;
    }
    #line 1929 
    i = (u16)((int)i + 1);
  }
  #line 1938 
  if (((int)autoneg_status & 4) == 0) 
                                      #line 1939 
                                      *link_up = (_Bool)0;
  #line 1941 
  return 0;
}

#line 1951  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_setup_sgmii(struct ixgbe_hw *hw, ixgbe_link_speed speed, bool autoneg_wait_to_complete)
{
  #line 1955 
  u32 lval;
  #line 1955 
  u32 sval;
  #line 1955 
  u32 flx_val;
  #line 1956 
  s32 rc;
  #line 1958 
  unsigned int tmp;
  #line 1969 
  unsigned int tmp_0;
  #line 1975 
  unsigned int tmp_1;
  #line 1983 
  unsigned int tmp_2;
  #line 1989 
  unsigned int tmp_3;
  #line 1995 
  unsigned int tmp_4;
  #line 2007 
  unsigned int tmp_5;
  #line 1954 
  struct ixgbe_mac_info *mac = & hw->mac;
  #line 1958 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 1958 
                                          tmp = 33292U; else 
                                                             #line 1958 
                                                             tmp = 16908U;
  #line 1958 
  ;
  #line 1958 
  rc = (*(mac->ops.read_iosf_sb_reg))(hw,tmp,0U,& lval);
  #line 1961 
  if (rc != 0) 
               #line 1962 
               return rc;
  #line 1964 
  lval &= 3758096383U;
  #line 1965 
  lval &= 4294965503U;
  #line 1966 
  lval |= 4096U;
  #line 1967 
  lval |= 8192U;
  #line 1968 
  lval |= 512U;
  #line 1969 
  ;
  #line 1969 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 1969 
                                          tmp_0 = 33292U; else 
                                                               #line 1969 
                                                               tmp_0 = 16908U;
  #line 1969 
  ;
  #line 1969 
  rc = (*(mac->ops.write_iosf_sb_reg))(hw,tmp_0,0U,lval);
  #line 1972 
  if (rc != 0) 
               #line 1973 
               return rc;
  #line 1975 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 1975 
                                          tmp_1 = 33440U; else 
                                                               #line 1975 
                                                               tmp_1 = 17056U;
  #line 1975 
  ;
  #line 1975 
  rc = (*(mac->ops.read_iosf_sb_reg))(hw,tmp_1,0U,& sval);
  #line 1978 
  if (rc != 0) 
               #line 1979 
               return rc;
  #line 1981 
  sval |= 524288U;
  #line 1982 
  sval |= 4096U;
  #line 1983 
  ;
  #line 1983 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 1983 
                                          tmp_2 = 33440U; else 
                                                               #line 1983 
                                                               tmp_2 = 17056U;
  #line 1983 
  ;
  #line 1983 
  rc = (*(mac->ops.write_iosf_sb_reg))(hw,tmp_2,0U,sval);
  #line 1986 
  if (rc != 0) 
               #line 1987 
               return rc;
  #line 1989 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 1989 
                                          tmp_3 = 36948U; else 
                                                               #line 1989 
                                                               tmp_3 = 20564U;
  #line 1989 
  ;
  #line 1989 
  rc = (*(mac->ops.read_iosf_sb_reg))(hw,tmp_3,0U,& flx_val);
  #line 1992 
  if (rc != 0) 
               #line 1993 
               return rc;
  #line 1995 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 1995 
                                          tmp_4 = 36948U; else 
                                                               #line 1995 
                                                               tmp_4 = 20564U;
  #line 1995 
  ;
  #line 1995 
  rc = (*(mac->ops.read_iosf_sb_reg))(hw,tmp_4,0U,& flx_val);
  #line 1998 
  if (rc != 0) 
               #line 1999 
               return rc;
  #line 2001 
  flx_val &= 2415919103U;
  #line 2002 
  flx_val |= 536870912U;
  #line 2003 
  flx_val &= 4160749567U;
  #line 2004 
  flx_val |= 33554432U;
  #line 2005 
  flx_val |= 67108864U;
  #line 2007 
  ;
  #line 2007 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 2007 
                                          tmp_5 = 36948U; else 
                                                               #line 2007 
                                                               tmp_5 = 20564U;
  #line 2007 
  ;
  #line 2007 
  rc = (*(mac->ops.write_iosf_sb_reg))(hw,tmp_5,0U,flx_val);
  #line 2010 
  if (rc != 0) 
               #line 2011 
               return rc;
  #line 2013 
  rc = ixgbe_restart_an_internal_phy_x550em(hw);
  #line 2014 
  return rc;
}

#line 2023  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_setup_sgmii_fw(struct ixgbe_hw *hw, ixgbe_link_speed speed, bool autoneg_wait)
{
  #line 2027 
  u32 lval;
  #line 2027 
  u32 sval;
  #line 2027 
  u32 flx_val;
  #line 2028 
  s32 rc;
  #line 2030 
  unsigned int tmp;
  #line 2041 
  unsigned int tmp_0;
  #line 2047 
  unsigned int tmp_1;
  #line 2055 
  unsigned int tmp_2;
  #line 2061 
  unsigned int tmp_3;
  #line 2067 
  unsigned int tmp_4;
  #line 2079 
  unsigned int tmp_5;
  #line 2026 
  struct ixgbe_mac_info *mac = & hw->mac;
  #line 2030 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 2030 
                                          tmp = 33292U; else 
                                                             #line 2030 
                                                             tmp = 16908U;
  #line 2030 
  ;
  #line 2030 
  rc = (*(mac->ops.read_iosf_sb_reg))(hw,tmp,0U,& lval);
  #line 2033 
  if (rc != 0) 
               #line 2034 
               return rc;
  #line 2036 
  lval &= 3758096383U;
  #line 2037 
  lval &= 4294965503U;
  #line 2038 
  lval |= 4096U;
  #line 2039 
  lval |= 8192U;
  #line 2040 
  lval &= 4294966783U;
  #line 2041 
  ;
  #line 2041 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 2041 
                                          tmp_0 = 33292U; else 
                                                               #line 2041 
                                                               tmp_0 = 16908U;
  #line 2041 
  ;
  #line 2041 
  rc = (*(mac->ops.write_iosf_sb_reg))(hw,tmp_0,0U,lval);
  #line 2044 
  if (rc != 0) 
               #line 2045 
               return rc;
  #line 2047 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 2047 
                                          tmp_1 = 33440U; else 
                                                               #line 2047 
                                                               tmp_1 = 17056U;
  #line 2047 
  ;
  #line 2047 
  rc = (*(mac->ops.read_iosf_sb_reg))(hw,tmp_1,0U,& sval);
  #line 2050 
  if (rc != 0) 
               #line 2051 
               return rc;
  #line 2053 
  sval &= 4294443007U;
  #line 2054 
  sval &= 4294963199U;
  #line 2055 
  ;
  #line 2055 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 2055 
                                          tmp_2 = 33440U; else 
                                                               #line 2055 
                                                               tmp_2 = 17056U;
  #line 2055 
  ;
  #line 2055 
  rc = (*(mac->ops.write_iosf_sb_reg))(hw,tmp_2,0U,sval);
  #line 2058 
  if (rc != 0) 
               #line 2059 
               return rc;
  #line 2061 
  ;
  #line 2061 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 2061 
                                          tmp_3 = 33292U; else 
                                                               #line 2061 
                                                               tmp_3 = 16908U;
  #line 2061 
  ;
  #line 2061 
  rc = (*(mac->ops.write_iosf_sb_reg))(hw,tmp_3,0U,lval);
  #line 2064 
  if (rc != 0) 
               #line 2065 
               return rc;
  #line 2067 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 2067 
                                          tmp_4 = 36948U; else 
                                                               #line 2067 
                                                               tmp_4 = 20564U;
  #line 2067 
  ;
  #line 2067 
  rc = (*(mac->ops.read_iosf_sb_reg))(hw,tmp_4,0U,& flx_val);
  #line 2070 
  if (rc != 0) 
               #line 2071 
               return rc;
  #line 2073 
  flx_val &= 2415919103U;
  #line 2074 
  flx_val |= 1073741824U;
  #line 2075 
  flx_val &= 4160749567U;
  #line 2076 
  flx_val |= 33554432U;
  #line 2077 
  flx_val |= 67108864U;
  #line 2079 
  ;
  #line 2079 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 2079 
                                          tmp_5 = 36948U; else 
                                                               #line 2079 
                                                               tmp_5 = 20564U;
  #line 2079 
  ;
  #line 2079 
  rc = (*(mac->ops.write_iosf_sb_reg))(hw,tmp_5,0U,flx_val);
  #line 2082 
  if (rc != 0) 
               #line 2083 
               return rc;
  #line 2085 
  ixgbe_restart_an_internal_phy_x550em(hw);
  #line 2087 
  return (*(hw->phy.ops.setup_link_speed))(hw,speed,
                                          (_Bool)((bool)((int)autoneg_wait) != 0));
}

#line 2096  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static void ixgbe_fc_autoneg_sgmii_x550em_a(struct ixgbe_hw *hw)
{
  #line 2100 
  ixgbe_link_speed speed;
  #line 2101 
  bool link_up;
  #line 2098 
  s32 status = -27;
  #line 2099 
  u32 info[4U] = {0U};
  #line 2108 
  if ((int)hw->fc.disable_fc_autoneg != 0) 
                                           #line 2109 
                                           goto out;
  #line 2111 
  (*(hw->mac.ops.check_link))(hw,& speed,& link_up,(_Bool)0);
  #line 2112 
  if (! link_up) 
                 #line 2113 
                 goto out;
  #line 2116 
  status = ixgbe_fw_phy_activity(hw,(unsigned short)3,& info);
  #line 2117 
  if (status != 0 || ((unsigned long)info[0] & 16777216UL) == 0UL) {
    #line 2118 
    status = -27;
    #line 2119 
    goto out;
  }
  #line 2123 
  status = ixgbe_negotiate_fc(hw,info[0],info[0],2097152U,1048576U,536870912U,268435456U);
  #line 2129 
  out: 
       #line 2129 
  ;
  #line 2130 
  if (status == 0) 
                   #line 2131 
                   hw->fc.fc_was_autonegged = (_Bool)1;
  else {
    #line 2133 
    hw->fc.fc_was_autonegged = (_Bool)0;
    #line 2134 
    hw->fc.current_mode = hw->fc.requested_mode;
  }
  #line 2136 
  return;
}

#line 2141  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static void ixgbe_init_mac_link_ops_X550em_a(struct ixgbe_hw *hw)
{
  #line 2143 
  struct ixgbe_mac_info *mac = & hw->mac;
  #line 2145 
  switch ((unsigned int)(*(mac->ops.get_media_type))(hw)) {
    #line 2146 
    case (unsigned int)1: 
                          #line 2146 
    ;
    #line 2147 
    mac->ops.setup_fc = (s32 (*)(struct ixgbe_hw *))0;
    #line 2148 
    mac->ops.fc_autoneg = & ixgbe_fc_autoneg_fiber_x550em_a;
    #line 2149 
    break;
    #line 2150 
    case (unsigned int)4: 
                          #line 2150 
    ;
    #line 2151 
    if ((unsigned int)hw->device_id + 59932U > 1U) {
      #line 2153 
      mac->ops.setup_link = & ixgbe_setup_mac_link_t_X550em;
      #line 2154 
      break;
    }
    #line 2156 
    mac->ops.fc_autoneg = & ixgbe_fc_autoneg_sgmii_x550em_a;
    #line 2157 
    mac->ops.setup_fc = & ixgbe_fc_autoneg_fw;
    #line 2158 
    mac->ops.setup_link = & ixgbe_setup_sgmii_fw;
    #line 2159 
    mac->ops.check_link = & ixgbe_check_mac_link_generic;
    #line 2160 
    break;
    #line 2161 
    case (unsigned int)5: 
                          #line 2161 
    ;
    #line 2162 
    mac->ops.fc_autoneg = & ixgbe_fc_autoneg_backplane_x550em_a;
    #line 2163 
    mac->ops.setup_fc = & ixgbe_setup_fc_backplane_x550em_a;
    #line 2164 
    break;
    #line 2165 
    default: 
             #line 2165 
    ;
    #line 2166 
    break;
  }
  #line 2168 
  return;
}

#line 2173  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static void ixgbe_init_mac_link_ops_X550em(struct ixgbe_hw *hw)
{
  #line 2175 
  struct ixgbe_mac_info *mac = & hw->mac;
  #line 2177 
  mac->ops.setup_fc = & ixgbe_setup_fc_x550em;
  #line 2179 
  switch ((unsigned int)(*(mac->ops.get_media_type))(hw)) {
    #line 2180 
    case (unsigned int)1: 
                          #line 2180 
    ;
    #line 2184 
    mac->ops.disable_tx_laser = (void (*)(struct ixgbe_hw *))0;
    #line 2185 
    mac->ops.enable_tx_laser = (void (*)(struct ixgbe_hw *))0;
    #line 2186 
    mac->ops.flap_tx_laser = (void (*)(struct ixgbe_hw *))0;
    #line 2187 
    mac->ops.setup_link = & ixgbe_setup_mac_link_multispeed_fiber;
    #line 2188 
    switch ((int)hw->device_id) {
      #line 2189 
      case 5572: 
                 #line 2189 
      ;
      #line 2190 
      mac->ops.setup_mac_link = & ixgbe_setup_mac_link_sfp_n;
      #line 2191 
      break;
      #line 2192 
      case 5582: 
                 #line 2192 
      ;
      #line 2193 
      mac->ops.setup_mac_link = & ixgbe_setup_mac_link_sfp_x550a;
      #line 2195 
      break;
      #line 2196 
      default: 
               #line 2196 
      ;
      #line 2197 
      mac->ops.setup_mac_link = & ixgbe_setup_mac_link_sfp_x550em;
      #line 2199 
      break;
    }
    #line 2201 
    mac->ops.set_rate_select_speed = & ixgbe_set_soft_rate_select_speed;
    #line 2203 
    break;
    #line 2204 
    case (unsigned int)4: 
                          #line 2204 
    ;
    #line 2205 
    if ((unsigned int)hw->device_id == 5550U) 
                                              #line 2206 
                                              break;
    #line 2207 
    mac->ops.setup_link = & ixgbe_setup_mac_link_t_X550em;
    #line 2208 
    mac->ops.setup_fc = & ixgbe_setup_fc_generic;
    #line 2209 
    mac->ops.check_link = & ixgbe_check_link_t_X550em;
    #line 2210 
    break;
    #line 2211 
    case (unsigned int)5: 
                          #line 2211 
    ;
    #line 2212 
    if ((unsigned int)hw->device_id + 59962U <= 1U) 
                                                    #line 2214 
                                                    mac->ops.setup_link = & ixgbe_setup_sgmii;
    #line 2215 
    break;
    #line 2216 
    default: 
             #line 2216 
    ;
    #line 2217 
    break;
  }
  #line 2221 
  if (hw->mac.type == (unsigned int)ixgbe_mac_x550em_a) 
                                                        #line 2222 
                                                        ixgbe_init_mac_link_ops_X550em_a(hw);
  #line 2223 
  return;
}

#line 2228  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_setup_sfp_modules_X550em(struct ixgbe_hw *hw)
{
  #line 2230 
  s32 status;
  #line 2231 
  bool linear;
  #line 2234 
  status = ixgbe_supported_sfp_modules_X550em(hw,& linear);
  #line 2235 
  if (status != 0) 
                   #line 2236 
                   return status;
  #line 2238 
  ixgbe_init_mac_link_ops_X550em(hw);
  #line 2239 
  hw->phy.ops.reset = (s32 (*)(struct ixgbe_hw *))0;
  #line 2241 
  return 0;
}

#line 2249  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_get_link_capabilities_X550em(struct ixgbe_hw *hw, ixgbe_link_speed *speed, bool *autoneg)
{
  #line 2253 
  if (hw->phy.type == (unsigned int)ixgbe_phy_fw) {
    #line 2254 
    *autoneg = (_Bool)1;
    #line 2255 
    *speed = hw->phy.speeds_supported;
    #line 2256 
    return 0;
  }
  #line 2260 
  if (hw->phy.media_type == (unsigned int)ixgbe_media_type_fiber) {
    #line 2262 
    *autoneg = (_Bool)0;
    #line 2266 
    if ((unsigned int)hw->phy.sfp_type + 4294967285U <= 3U) {
      #line 2268 
      *speed = 32U;
      #line 2269 
      return 0;
    }
    #line 2273 
    if ((int)hw->phy.multispeed_fiber != 0) 
                                            #line 2274 
                                            *speed = 160U; else 
                                                                #line 2277 
                                                                *speed = 128U;
  }
  else {
    #line 2279 
    switch ((unsigned int)hw->phy.type) {
      #line 2280 
      case (unsigned int)5: 
                            #line 2280 
      ;
      #line 2281 
      *speed = 1184U;
      #line 2284 
      break;
      #line 2285 
      case (unsigned int)6: 
                            #line 2285 
      ;
      #line 2286 
      *speed = 160U;
      #line 2288 
      break;
      #line 2289 
      case (unsigned int)8: 
                            #line 2289 
      ;
      #line 2290 
      case (unsigned int)26: 
                             #line 2290 
      ;
      #line 2291 
      *speed = 32U;
      #line 2292 
      break;
      #line 2293 
      case (unsigned int)4: 
                            #line 2293 
      ;
      #line 2294 
      if (hw->mac.type == (unsigned int)ixgbe_mac_x550em_a) 
        #line 2296 
        if (((unsigned long)hw->phy.nw_mng_if_sel & 1048576UL) != 0UL) {
          #line 2298 
          *speed = 1024U;
          #line 2299 
          break;
        }
        else 
          #line 2300 
          if ((unsigned int)hw->device_id == 5571U) {
            #line 2302 
            *speed = 32U;
            #line 2303 
            break;
          }
      #line 2307 
      default: 
               #line 2307 
      ;
      #line 2308 
      *speed = 160U;
      #line 2310 
      break;
    }
    #line 2312 
    *autoneg = (_Bool)1;
  }
  #line 2314 
  return 0;
}

#line 2329  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_get_lasi_ext_t_x550em(struct ixgbe_hw *hw, bool *lsc)
{
  #line 2331 
  u32 status;
  #line 2332 
  u16 reg;
  #line 2334 
  *lsc = (_Bool)0;
  #line 2337 
  status = (unsigned int)(*(hw->phy.ops.read_reg))(hw,64512U,30U,& reg);
  #line 2341 
  if (status != 0U || ((int)reg & 1) == 0) 
                                           #line 2342 
                                           return (int)status;
  #line 2345 
  status = (unsigned int)(*(hw->phy.ops.read_reg))(hw,64513U,30U,& reg);
  #line 2349 
  if (status != 0U || ((int)reg & 4100) == 0) 
                                              #line 2351 
                                              return (int)status;
  #line 2354 
  status = (unsigned int)(*(hw->phy.ops.read_reg))(hw,52224U,30U,& reg);
  #line 2358 
  if (status != 0U) 
                    #line 2359 
                    return (int)status;
  #line 2362 
  if (((int)reg & 16384) != 0) {
    #line 2364 
    ixgbe_set_copper_phy_power(hw,(_Bool)0);
    #line 2365 
    return -26;
  }
  #line 2367 
  if (((int)reg & 16) != 0) {
    #line 2369 
    status = (unsigned int)(*(hw->phy.ops.read_reg))(hw,51280U,30U,& reg);
    #line 2372 
    if (status != 0U) 
                      #line 2373 
                      return (int)status;
    #line 2376 
    if ((unsigned int)reg == 32775U) {
      #line 2378 
      ixgbe_set_copper_phy_power(hw,(_Bool)0);
      #line 2379 
      return -26;
    }
  }
  #line 2384 
  status = (unsigned int)(*(hw->phy.ops.read_reg))(hw,64512U,7U,& reg);
  #line 2387 
  if (status != 0U || ((int)reg & 512) == 0) 
                                             #line 2388 
                                             return (int)status;
  #line 2391 
  status = (unsigned int)(*(hw->phy.ops.read_reg))(hw,52225U,7U,& reg);
  #line 2394 
  if (status != 0U) 
                    #line 2395 
                    return (int)status;
  #line 2398 
  if (((int)reg & 1) != 0) 
                           #line 2399 
                           *lsc = (_Bool)1;
  #line 2401 
  return 0;
}

#line 2413  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_enable_lasi_ext_t_x550em(struct ixgbe_hw *hw)
{
  #line 2415 
  u32 status;
  #line 2416 
  u16 reg;
  #line 2417 
  bool lsc;
  #line 2420 
  status = (unsigned int)ixgbe_get_lasi_ext_t_x550em(hw,& lsc);
  #line 2432 
  if (hw->mac.type != (unsigned int)ixgbe_mac_x550em_a) {
    #line 2433 
    status = (unsigned int)(*(hw->phy.ops.read_reg))(hw,54273U,7U,& reg);
    #line 2436 
    if (status != 0U) 
                      #line 2437 
                      return (int)status;
    #line 2439 
    reg = (unsigned short)((unsigned int)reg | 1U);
    #line 2441 
    status = (unsigned int)(*(hw->phy.ops.write_reg))(hw,54273U,7U,(unsigned short)((int)reg));
    #line 2444 
    if (status != 0U) 
                      #line 2445 
                      return (int)status;
  }
  #line 2449 
  status = (unsigned int)(*(hw->phy.ops.read_reg))(hw,54272U,30U,& reg);
  #line 2452 
  if (status != 0U) 
                    #line 2453 
                    return (int)status;
  #line 2455 
  reg = (unsigned short)((unsigned int)reg | 16400U);
  #line 2458 
  status = (unsigned int)(*(hw->phy.ops.write_reg))(hw,54272U,30U,(unsigned short)((int)reg));
  #line 2461 
  if (status != 0U) 
                    #line 2462 
                    return (int)status;
  #line 2465 
  status = (unsigned int)(*(hw->phy.ops.read_reg))(hw,65281U,30U,& reg);
  #line 2468 
  if (status != 0U) 
                    #line 2469 
                    return (int)status;
  #line 2471 
  reg = (unsigned short)((unsigned int)reg | 4100U);
  #line 2474 
  status = (unsigned int)(*(hw->phy.ops.write_reg))(hw,65281U,30U,(unsigned short)((int)reg));
  #line 2477 
  if (status != 0U) 
                    #line 2478 
                    return (int)status;
  #line 2481 
  status = (unsigned int)(*(hw->phy.ops.read_reg))(hw,65280U,30U,& reg);
  #line 2484 
  if (status != 0U) 
                    #line 2485 
                    return (int)status;
  #line 2487 
  reg = (unsigned short)((unsigned int)reg | 1U);
  #line 2489 
  status = (unsigned int)(*(hw->phy.ops.write_reg))(hw,65280U,30U,(unsigned short)((int)reg));
  #line 2493 
  return (int)status;
}

#line 2507  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_handle_lasi_ext_t_x550em(struct ixgbe_hw *hw)
{
  #line 2510 
  bool lsc;
  #line 2511 
  u32 status;
  #line 2509 
  struct ixgbe_phy_info *phy = & hw->phy;
  #line 2513 
  status = (unsigned int)ixgbe_get_lasi_ext_t_x550em(hw,& lsc);
  #line 2514 
  if (status != 0U) 
                    #line 2515 
                    return (int)status;
  #line 2517 
  if ((int)lsc != 0 && phy->ops.setup_internal_link != (s32 (*)(struct ixgbe_hw *))0) {
    #line 2518 
    return (*(phy->ops.setup_internal_link))(hw);
  }
  #line 2520 
  return 0;
}

#line 2530  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_setup_kr_speed_x550em(struct ixgbe_hw *hw, ixgbe_link_speed speed)
{
  #line 2533 
  s32 status;
  #line 2534 
  u32 reg_val;
  #line 2536 
  unsigned int tmp;
  #line 2554 
  unsigned int tmp_0;
  #line 2536 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 2536 
                                          tmp = 33292U; else 
                                                             #line 2536 
                                                             tmp = 16908U;
  #line 2536 
  ;
  #line 2536 
  status = (*(hw->mac.ops.read_iosf_sb_reg))(hw,tmp,0U,& reg_val);
  #line 2539 
  if (status != 0) 
                   #line 2540 
                   return status;
  #line 2542 
  reg_val |= 536870912U;
  #line 2543 
  reg_val &= 4294639615U;
  #line 2547 
  if ((speed & 128U) != 0U) 
                            #line 2548 
                            reg_val |= 262144U;
  #line 2551 
  if ((speed & 32U) != 0U) 
                           #line 2552 
                           reg_val |= 65536U;
  #line 2554 
  ;
  #line 2554 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 2554 
                                          tmp_0 = 33292U; else 
                                                               #line 2554 
                                                               tmp_0 = 16908U;
  #line 2554 
  ;
  #line 2554 
  status = (*(hw->mac.ops.write_iosf_sb_reg))(hw,tmp_0,0U,reg_val);
  #line 2558 
  if (hw->mac.type == (unsigned int)ixgbe_mac_x550em_a) {
    #line 2560 
    unsigned int tmp_1;
    #line 2573 
    unsigned int tmp_2;
    #line 2560 
    if ((unsigned int)hw->bus.lan_id != 0U) 
                                            #line 2560 
                                            tmp_1 = 36948U; else 
                                                                 #line 2560 
                                                                 tmp_1 = 20564U;
    #line 2560 
    ;
    #line 2560 
    status = (*(hw->mac.ops.read_iosf_sb_reg))(hw,tmp_1,0U,& reg_val);
    #line 2564 
    if (status != 0) 
                     #line 2565 
                     return status;
    #line 2567 
    reg_val &= 2415919103U;
    #line 2568 
    reg_val |= 1073741824U;
    #line 2569 
    reg_val |= 134217728U;
    #line 2570 
    reg_val &= 4227858431U;
    #line 2571 
    reg_val &= 4261412863U;
    #line 2573 
    ;
    #line 2573 
    if ((unsigned int)hw->bus.lan_id != 0U) 
                                            #line 2573 
                                            tmp_2 = 36948U; else 
                                                                 #line 2573 
                                                                 tmp_2 = 20564U;
    #line 2573 
    ;
    #line 2573 
    status = (*(hw->mac.ops.write_iosf_sb_reg))(hw,tmp_2,0U,reg_val);
  }
  #line 2578 
  return ixgbe_restart_an_internal_phy_x550em(hw);
}

#line 2585  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_setup_kr_x550em(struct ixgbe_hw *hw)
{
  #line 2588 
  if ((hw->phy.autoneg_advertised & 1024U) != 0U) 
                                                  #line 2589 
                                                  return 0;
  #line 2591 
  if ((int)ixgbe_check_reset_blocked(hw) != 0) 
                                               #line 2592 
                                               return 0;
  #line 2594 
  return ixgbe_setup_kr_speed_x550em(hw,hw->phy.autoneg_advertised);
}

#line 2603  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_ext_phy_t_x550em_get_link(struct ixgbe_hw *hw, bool *link_up)
{
  #line 2605 
  u32 ret;
  #line 2606 
  u16 autoneg_status;
  #line 2608 
  *link_up = (_Bool)0;
  #line 2611 
  ret = (unsigned int)(*(hw->phy.ops.read_reg))(hw,1U,7U,& autoneg_status);
  #line 2613 
  if (ret != 0U) 
                 #line 2614 
                 return (int)ret;
  #line 2616 
  ret = (unsigned int)(*(hw->phy.ops.read_reg))(hw,1U,7U,& autoneg_status);
  #line 2618 
  if (ret != 0U) 
                 #line 2619 
                 return (int)ret;
  #line 2621 
  *link_up = (_Bool)(((int)autoneg_status & 4) != 0);
  #line 2623 
  return 0;
}

#line 2637  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_setup_internal_phy_t_x550em(struct ixgbe_hw *hw)
{
  #line 2639 
  ixgbe_link_speed force_speed;
  #line 2640 
  bool link_up;
  #line 2641 
  u32 status;
  #line 2642 
  u16 speed;
  #line 2644 
  if ((*(hw->mac.ops.get_media_type))(hw) != (unsigned int)ixgbe_media_type_copper) 
    #line 2645 
    return -4;
  #line 2647 
  if (hw->mac.type != (unsigned int)ixgbe_mac_X550EM_x || ((unsigned long)hw->phy.nw_mng_if_sel & 16777216UL) != 0UL) {
    #line 2649 
    speed = (unsigned short)160U;
    #line 2651 
    return ixgbe_setup_kr_speed_x550em(hw,(unsigned int)speed);
  }
  #line 2655 
  status = (unsigned int)ixgbe_ext_phy_t_x550em_get_link(hw,& link_up);
  #line 2656 
  if (status != 0U) 
                    #line 2657 
                    return (int)status;
  #line 2659 
  if (! link_up) 
                 #line 2660 
                 return 0;
  #line 2662 
  status = (unsigned int)(*(hw->phy.ops.read_reg))(hw,51200U,7U,& speed);
  #line 2665 
  if (status != 0U) 
                    #line 2666 
                    return (int)status;
  #line 2669 
  status = (unsigned int)ixgbe_ext_phy_t_x550em_get_link(hw,& link_up);
  #line 2670 
  if (status != 0U) 
                    #line 2671 
                    return (int)status;
  #line 2673 
  if (! link_up) 
                 #line 2674 
                 return 0;
  #line 2677 
  speed = (unsigned short)((unsigned int)speed & 7U);
  #line 2679 
  switch ((int)speed) {
    #line 2680 
    case 7: 
            #line 2680 
    ;
    #line 2681 
    force_speed = 128U;
    #line 2682 
    break;
    #line 2683 
    case 5: 
            #line 2683 
    ;
    #line 2684 
    force_speed = 32U;
    #line 2685 
    break;
    #line 2686 
    default: 
             #line 2686 
    ;
    #line 2688 
    return -13;
  }
  #line 2691 
  return ixgbe_setup_ixfi_x550em(hw,& force_speed);
}

#line 2697  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_reset_phy_t_X550em(struct ixgbe_hw *hw)
{
  #line 2699 
  s32 status;
  #line 2701 
  status = ixgbe_reset_phy_generic(hw);
  #line 2703 
  if (status != 0) 
                   #line 2704 
                   return status;
  #line 2707 
  return ixgbe_enable_lasi_ext_t_x550em(hw);
}

#line 2715  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_led_on_t_x550em(struct ixgbe_hw *hw, u32 led_idx)
{
  #line 2717 
  u16 phy_data;
  #line 2719 
  if (led_idx > 2U) 
                    #line 2720 
                    return -5;
  #line 2723 
  (*(hw->phy.ops.read_reg))(hw,led_idx + 50224U,30U,& phy_data);
  #line 2725 
  phy_data = (unsigned short)((unsigned int)phy_data | 256U);
  #line 2726 
  (*(hw->phy.ops.write_reg))(hw,led_idx + 50224U,30U,(unsigned short)((int)phy_data));
  #line 2729 
  return 0;
}

#line 2737  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_led_off_t_x550em(struct ixgbe_hw *hw, u32 led_idx)
{
  #line 2739 
  u16 phy_data;
  #line 2741 
  if (led_idx > 2U) 
                    #line 2742 
                    return -5;
  #line 2745 
  (*(hw->phy.ops.read_reg))(hw,led_idx + 50224U,30U,& phy_data);
  #line 2747 
  phy_data = (unsigned short)((unsigned int)phy_data & 65279U);
  #line 2748 
  (*(hw->phy.ops.write_reg))(hw,led_idx + 50224U,30U,(unsigned short)((int)phy_data));
  #line 2751 
  return 0;
}

#line 2769  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_set_fw_drv_ver_x550(struct ixgbe_hw *hw, u8 maj, u8 min, u8 build, u8 sub, u16 len, char *driver_ver)
{
  #line 2773 
  struct ixgbe_hic_drv_info2 fw_cmd;
  #line 2774 
  s32 ret_val;
  #line 2775 
  int i;
  #line 2777 
  if (((unsigned int)len == 0U || driver_ver == (char *)0) || (unsigned int)len > 39U) 
    #line 2778 
    return -32;
  #line 2780 
  fw_cmd.hdr.cmd = (unsigned char)221U;
  #line 2781 
  fw_cmd.hdr.buf_len = (unsigned char)((unsigned int)((unsigned char)len) + 5U);
  #line 2782 
  fw_cmd.hdr.cmd_or_resp.cmd_resv = (unsigned char)0U;
  #line 2783 
  fw_cmd.port_num = hw->bus.func;
  #line 2784 
  fw_cmd.ver_maj = maj;
  #line 2785 
  fw_cmd.ver_min = min;
  #line 2786 
  fw_cmd.ver_build = build;
  #line 2787 
  fw_cmd.ver_sub = sub;
  #line 2788 
  fw_cmd.hdr.checksum = (unsigned char)0U;
  #line 2789 
  memcpy((void *)(& fw_cmd.driver_string),(void *)driver_ver,(unsigned long)len);
  #line 2790 
  fw_cmd.hdr.checksum = ixgbe_calculate_checksum((u8 *)(& fw_cmd),(unsigned int)((int)fw_cmd.hdr.buf_len + 4));
  #line 2793 
  i = 0;
  #line 2793 
  while (i <= 3) {
    #line 2794 
    ret_val = ixgbe_host_interface_command(hw,(void *)(& fw_cmd),48U,500U,(_Bool)1);
    #line 2798 
    if (ret_val != 0) 
                      #line 2799 
                      goto __Cont;
    #line 2801 
    if ((unsigned int)fw_cmd.hdr.cmd_or_resp.ret_status != 1U) 
                                                               #line 2803 
                                                               return -33;
    #line 2804 
    return 0;
    #line 2793 
    __Cont: 
            #line 2793 
    i ++;
  }
  #line 2807 
  return ret_val;
}

#line 2816  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_get_lcd_t_x550em(struct ixgbe_hw *hw, ixgbe_link_speed *lcd_speed)
{
  #line 2819 
  u16 an_lp_status;
  #line 2820 
  s32 status;
  #line 2821 
  u16 word = hw->eeprom.ctrl_word_3;
  #line 2823 
  *lcd_speed = 0U;
  #line 2825 
  status = (*(hw->phy.ops.read_reg))(hw,59424U,7U,& an_lp_status);
  #line 2828 
  if (status != 0) 
                   #line 2829 
                   return status;
  #line 2832 
  if (((int)an_lp_status & 32768) != 0) {
    #line 2833 
    *lcd_speed = 32U;
    #line 2834 
    return status;
  }
  #line 2838 
  if ((unsigned int)hw->bus.lan_id != 0U && ((int)word & 256) != 0 || ((int)word & 64) != 0) 
    #line 2840 
    return status;
  #line 2843 
  *lcd_speed = 128U;
  #line 2844 
  return status;
}

#line 2851  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_setup_fc_x550em(struct ixgbe_hw *hw)
{
  #line 2853 
  bool pause;
  #line 2853 
  bool asm_dir;
  #line 2854 
  u32 reg_val;
  #line 2855 
  s32 rc = 0;
  #line 2858 
  if ((int)hw->fc.strict_ieee != 0 && hw->fc.requested_mode == (unsigned int)ixgbe_fc_rx_pause) {
    #line 2859 
    netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"ixgbe_fc_rx_pause not valid in strict IEEE mode\n");
    #line 2860 
    return -13;
  }
  #line 2866 
  if (hw->fc.requested_mode == (unsigned int)ixgbe_fc_default) 
                                                               #line 2867 
                                                               hw->fc.requested_mode = ixgbe_fc_full;
  #line 2870 
  switch ((unsigned int)hw->fc.requested_mode) {
    #line 2871 
    case (unsigned int)0: 
                          #line 2871 
    ;
    #line 2872 
    pause = (_Bool)0;
    #line 2873 
    asm_dir = (_Bool)0;
    #line 2874 
    break;
    #line 2875 
    case (unsigned int)2: 
                          #line 2875 
    ;
    #line 2876 
    pause = (_Bool)0;
    #line 2877 
    asm_dir = (_Bool)1;
    #line 2878 
    break;
    #line 2879 
    case (unsigned int)1: 
                          #line 2879 
    ;
    #line 2889 
    case (unsigned int)3: 
                          #line 2889 
    ;
    #line 2890 
    pause = (_Bool)1;
    #line 2891 
    asm_dir = (_Bool)1;
    #line 2892 
    break;
    #line 2893 
    default: 
             #line 2893 
    ;
    #line 2894 
    netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Flow control param set incorrectly\n");
    #line 2895 
    return -4;
  }
  #line 2898 
  switch ((int)hw->device_id) {
    #line 2902 
    unsigned int tmp;
    #line 2915 
    unsigned int tmp_0;
    #line 2899 
    case 5547: 
               #line 2899 
    ;
    #line 2900 
    case 5570: 
               #line 2900 
    ;
    #line 2901 
    case 5571: 
               #line 2901 
    ;
    #line 2902 
    if ((unsigned int)hw->bus.lan_id != 0U) 
                                            #line 2902 
                                            tmp = 33324U; else 
                                                               #line 2902 
                                                               tmp = 16940U;
    #line 2902 
    ;
    #line 2902 
    rc = (*(hw->mac.ops.read_iosf_sb_reg))(hw,tmp,0U,& reg_val);
    #line 2906 
    if (rc != 0) 
                 #line 2907 
                 return rc;
    #line 2909 
    reg_val &= 3489660927U;
    #line 2911 
    if ((int)pause != 0) 
                         #line 2912 
                         reg_val |= 268435456U;
    #line 2913 
    if ((int)asm_dir != 0) 
                           #line 2914 
                           reg_val |= 536870912U;
    #line 2915 
    ;
    #line 2915 
    if ((unsigned int)hw->bus.lan_id != 0U) 
                                            #line 2915 
                                            tmp_0 = 33324U; else 
                                                                 #line 2915 
                                                                 tmp_0 = 16940U;
    #line 2915 
    ;
    #line 2915 
    rc = (*(hw->mac.ops.write_iosf_sb_reg))(hw,tmp_0,0U,reg_val);
    #line 2921 
    hw->fc.disable_fc_autoneg = (_Bool)1;
    #line 2922 
    break;
    #line 2923 
    case 5552: 
               #line 2923 
    ;
    #line 2924 
    hw->fc.disable_fc_autoneg = (_Bool)1;
    #line 2925 
    break;
    #line 2926 
    default: 
             #line 2926 
    ;
    #line 2927 
    break;
  }
  #line 2929 
  return rc;
}

#line 2936  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static void ixgbe_fc_autoneg_backplane_x550em_a(struct ixgbe_hw *hw)
{
  #line 2938 
  u32 link_s1;
  #line 2938 
  u32 lp_an_page_low;
  #line 2938 
  u32 an_cntl_1;
  #line 2940 
  ixgbe_link_speed speed;
  #line 2941 
  bool link_up;
  #line 2960 
  unsigned int tmp;
  #line 2973 
  unsigned int tmp_1;
  #line 2982 
  unsigned int tmp_3;
  #line 2939 
  s32 status = -27;
  #line 2948 
  if ((int)hw->fc.disable_fc_autoneg != 0) {
    #line 2949 
    netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Flow control autoneg is disabled");
    #line 2950 
    goto out;
  }
  #line 2953 
  (*(hw->mac.ops.check_link))(hw,& speed,& link_up,(_Bool)0);
  #line 2954 
  if (! link_up) {
    #line 2955 
    netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"The link is down");
    #line 2956 
    goto out;
  }
  #line 2960 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 2960 
                                          tmp = 33280U; else 
                                                             #line 2960 
                                                             tmp = 16896U;
  #line 2960 
  ;
  #line 2960 
  status = (*(hw->mac.ops.read_iosf_sb_reg))(hw,tmp,0U,& link_s1);
  #line 2964 
  if (status != 0 || ((unsigned long)link_s1 & 268435456UL) == 0UL) {
    {
      #line 2965 
      bool branch;
      #line 2965 
      struct _ddebug __UNIQUE_ID_ddebug460 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_fc_autoneg_backplane_x550em_a", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c", .format = (char *)"Auto-Negotiation did not complete\n", .lineno = (unsigned int)2965U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 2965 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug460.key.dd_key_false.key,(_Bool)0);
      #line 2965 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 2965 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug460,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Auto-Negotiation did not complete\n");
    }
    #line 2966 
    status = -27;
    #line 2967 
    goto out;
  }
  #line 2973 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 2973 
                                          tmp_1 = 33324U; else 
                                                               #line 2973 
                                                               tmp_1 = 16940U;
  #line 2973 
  ;
  #line 2973 
  status = (*(hw->mac.ops.read_iosf_sb_reg))(hw,tmp_1,0U,& an_cntl_1);
  #line 2977 
  if (status != 0) {
    {
      #line 2978 
      bool branch_0;
      #line 2978 
      struct _ddebug __UNIQUE_ID_ddebug461 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_fc_autoneg_backplane_x550em_a", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c", .format = (char *)"Auto-Negotiation did not complete\n", .lineno = (unsigned int)2978U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 2978 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug461.key.dd_key_false.key,(_Bool)0);
      #line 2978 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 2978 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug461,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Auto-Negotiation did not complete\n");
    }
    #line 2979 
    goto out;
  }
  #line 2982 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 2982 
                                          tmp_3 = 33644U; else 
                                                               #line 2982 
                                                               tmp_3 = 17260U;
  #line 2982 
  ;
  #line 2982 
  status = (*(hw->mac.ops.read_iosf_sb_reg))(hw,tmp_3,0U,& lp_an_page_low);
  #line 2986 
  if (status != 0) {
    {
      #line 2987 
      bool branch_1;
      #line 2987 
      struct _ddebug __UNIQUE_ID_ddebug462 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_fc_autoneg_backplane_x550em_a", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c", .format = (char *)"Auto-Negotiation did not complete\n", .lineno = (unsigned int)2987U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 2987 
      branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug462.key.dd_key_false.key,(_Bool)0);
      #line 2987 
      if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                    #line 2987 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug462,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Auto-Negotiation did not complete\n");
    }
    #line 2988 
    goto out;
  }
  #line 2991 
  status = ixgbe_negotiate_fc(hw,an_cntl_1,lp_an_page_low,268435456U,536870912U,1024U,2048U);
  #line 2997 
  out: 
       #line 2997 
  ;
  #line 2998 
  if (status == 0) 
                   #line 2999 
                   hw->fc.fc_was_autonegged = (_Bool)1;
  else {
    #line 3001 
    hw->fc.fc_was_autonegged = (_Bool)0;
    #line 3002 
    hw->fc.current_mode = hw->fc.requested_mode;
  }
  #line 3004 
  return;
}

#line 3010  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static void ixgbe_fc_autoneg_fiber_x550em_a(struct ixgbe_hw *hw)
{
  #line 3012 
  hw->fc.fc_was_autonegged = (_Bool)0;
  #line 3013 
  hw->fc.current_mode = hw->fc.requested_mode;
  #line 3014 
  return;
}

#line 3023  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_enter_lplu_t_x550em(struct ixgbe_hw *hw)
{
  #line 3025 
  u16 an_10g_cntl_reg;
  #line 3025 
  u16 autoneg_reg;
  #line 3025 
  u16 speed;
  #line 3026 
  s32 status;
  #line 3027 
  ixgbe_link_speed lcd_speed;
  #line 3028 
  u32 save_autoneg;
  #line 3029 
  bool link_up;
  #line 3032 
  if ((int)ixgbe_check_reset_blocked(hw) != 0) 
                                               #line 3033 
                                               return 0;
  #line 3035 
  status = ixgbe_ext_phy_t_x550em_get_link(hw,& link_up);
  #line 3036 
  if (status != 0) 
                   #line 3037 
                   return status;
  #line 3039 
  status = (*(hw->eeprom.ops.read))(hw,(unsigned short)56,& hw->eeprom.ctrl_word_3);
  #line 3041 
  if (status != 0) 
                   #line 3042 
                   return status;
  #line 3048 
  if (! link_up || ((int)hw->eeprom.ctrl_word_3 & 8) == 0) 
                                                           #line 3048 
                                                           goto _LOR;
  else 
    #line 3049 
    if (! hw->wol_enabled) {
      #line 3049 
      if (! ixgbe_mng_present(hw)) {
        #line 3048 
        _LOR: 
        #line 3050 
        return ixgbe_set_copper_phy_power(hw,(_Bool)0);
      }
    }
  #line 3053 
  status = ixgbe_get_lcd_t_x550em(hw,& lcd_speed);
  #line 3054 
  if (status != 0) 
                   #line 3055 
                   return status;
  #line 3058 
  if (lcd_speed == 0U) {
    #line 3059 
    return ixgbe_set_copper_phy_power(hw,(_Bool)0);
  }
  #line 3061 
  status = (*(hw->phy.ops.read_reg))(hw,51200U,7U,& speed);
  #line 3064 
  if (status != 0) 
                   #line 3065 
                   return status;
  #line 3068 
  status = ixgbe_ext_phy_t_x550em_get_link(hw,& link_up);
  #line 3069 
  if (status != 0) {
    #line 3070 
    return ixgbe_set_copper_phy_power(hw,(_Bool)0);
  }
  #line 3073 
  speed = (unsigned short)((unsigned int)speed & 6U);
  #line 3076 
  if ((unsigned int)speed == 4U && lcd_speed == 32U || (unsigned int)speed == 6U && lcd_speed == 128U) 
    #line 3080 
    return status;
  #line 3083 
  status = (*(hw->phy.ops.read_reg))(hw,52224U,7U,& autoneg_reg);
  #line 3086 
  if (status != 0) 
                   #line 3087 
                   return status;
  #line 3089 
  status = (*(hw->phy.ops.read_reg))(hw,32U,7U,& an_10g_cntl_reg);
  #line 3092 
  if (status != 0) 
                   #line 3093 
                   return status;
  #line 3095 
  status = (*(hw->phy.ops.read_reg))(hw,50176U,7U,& autoneg_reg);
  #line 3099 
  if (status != 0) 
                   #line 3100 
                   return status;
  #line 3102 
  save_autoneg = hw->phy.autoneg_advertised;
  #line 3105 
  status = (*(hw->mac.ops.setup_link))(hw,lcd_speed,(_Bool)0);
  #line 3108 
  hw->phy.autoneg_advertised = save_autoneg;
  #line 3110 
  return status;
}

#line 3117  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_reset_phy_fw(struct ixgbe_hw *hw)
{
  #line 3120 
  s32 rc;
  #line 3119 
  u32 store[4U] = {0U};
  #line 3122 
  if ((int)hw->phy.reset_disable != 0) 
                                       #line 3123 
                                       return 0;
  else {
    #line 3122 
    if ((int)ixgbe_check_reset_blocked(hw) != 0) 
                                                 #line 3123 
                                                 return 0;
  }
  #line 3125 
  rc = ixgbe_fw_phy_activity(hw,(unsigned short)5,& store);
  #line 3126 
  if (rc != 0) 
               #line 3127 
               return rc;
  #line 3128 
  memset((void *)(& store),0,16UL);
  #line 3130 
  rc = ixgbe_fw_phy_activity(hw,(unsigned short)1,& store);
  #line 3131 
  if (rc != 0) 
               #line 3132 
               return rc;
  #line 3134 
  return ixgbe_setup_fw_link(hw);
}

#line 3141  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_check_overtemp_fw(struct ixgbe_hw *hw)
{
  #line 3144 
  s32 rc;
  #line 3143 
  u32 store[4U] = {0U};
  #line 3146 
  rc = ixgbe_fw_phy_activity(hw,(unsigned short)3,& store);
  #line 3147 
  if (rc != 0) 
               #line 3148 
               return rc;
  #line 3150 
  if (((unsigned long)store[0] & 33554432UL) != 0UL) {
    #line 3151 
    ixgbe_shutdown_fw_phy(hw);
    #line 3152 
    return -26;
  }
  #line 3154 
  return 0;
}

#line 3163  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static void ixgbe_read_mng_if_sel_x550em(struct ixgbe_hw *hw)
{
  #line 3168 
  hw->phy.nw_mng_if_sel = ixgbe_read_reg(hw,70008U);
  #line 3173 
  if (hw->mac.type == (unsigned int)ixgbe_mac_x550em_a && ((unsigned long)hw->phy.nw_mng_if_sel & 2UL) != 0UL) 
    #line 3175 
    hw->phy.mdio.prtad = (int)(hw->phy.nw_mng_if_sel >> 3) & 31;
  #line 3177 
  return;
}

#line 3188  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_init_phy_ops_X550em(struct ixgbe_hw *hw)
{
  #line 3191 
  s32 ret_val;
  #line 3190 
  struct ixgbe_phy_info *phy = & hw->phy;
  #line 3193 
  (*(hw->mac.ops.set_lan_id))(hw);
  #line 3195 
  ixgbe_read_mng_if_sel_x550em(hw);
  #line 3197 
  if ((*(hw->mac.ops.get_media_type))(hw) == (unsigned int)ixgbe_media_type_fiber) {
    #line 3198 
    phy->phy_semaphore_mask = 6150U;
    #line 3199 
    ixgbe_setup_mux_ctl(hw);
  }
  #line 3203 
  ret_val = (*(phy->ops.identify))(hw);
  #line 3204 
  if (ret_val == -19 || ret_val == -17) 
                                        #line 3206 
                                        return ret_val;
  #line 3209 
  ixgbe_init_mac_link_ops_X550em(hw);
  #line 3210 
  if (phy->sfp_type != (unsigned int)ixgbe_sfp_type_unknown) 
                                                             #line 3211 
                                                             phy->ops.reset = (s32 (*)(struct ixgbe_hw *))0;
  #line 3214 
  switch ((unsigned int)hw->phy.type) {
    #line 3215 
    case (unsigned int)5: 
                          #line 3215 
    ;
    #line 3216 
    phy->ops.setup_link = (s32 (*)(struct ixgbe_hw *))0;
    #line 3217 
    phy->ops.read_reg = & ixgbe_read_phy_reg_x550em;
    #line 3218 
    phy->ops.write_reg = & ixgbe_write_phy_reg_x550em;
    #line 3219 
    break;
    #line 3220 
    case (unsigned int)4: 
                          #line 3220 
    ;
    #line 3221 
    phy->ops.setup_link = & ixgbe_setup_kr_x550em;
    #line 3222 
    phy->ops.read_reg = & ixgbe_read_phy_reg_x550em;
    #line 3223 
    phy->ops.write_reg = & ixgbe_write_phy_reg_x550em;
    #line 3224 
    break;
    #line 3225 
    case (unsigned int)6: 
                          #line 3225 
    ;
    #line 3227 
    phy->ops.setup_link = (s32 (*)(struct ixgbe_hw *))0;
    #line 3228 
    phy->ops.read_reg = & ixgbe_read_phy_reg_x550em;
    #line 3229 
    phy->ops.write_reg = & ixgbe_write_phy_reg_x550em;
    #line 3230 
    break;
    #line 3231 
    case (unsigned int)7: 
                          #line 3231 
    ;
    #line 3235 
    phy->nw_mng_if_sel = ixgbe_read_reg(hw,70008U);
    #line 3240 
    phy->ops.setup_internal_link = & ixgbe_setup_internal_phy_t_x550em;
    #line 3244 
    if (hw->mac.type == (unsigned int)ixgbe_mac_X550EM_x) {
      #line 3244 
      if ((ixgbe_read_reg(hw,69976U) & 192U) == 0U) 
                                                    #line 3247 
                                                    phy->ops.enter_lplu = & ixgbe_enter_lplu_t_x550em;
    }
    #line 3249 
    phy->ops.handle_lasi = & ixgbe_handle_lasi_ext_t_x550em;
    #line 3250 
    phy->ops.reset = & ixgbe_reset_phy_t_X550em;
    #line 3251 
    break;
    #line 3252 
    case (unsigned int)26: 
                           #line 3252 
    ;
    #line 3253 
    phy->ops.setup_link = (s32 (*)(struct ixgbe_hw *))0;
    #line 3254 
    break;
    #line 3255 
    case (unsigned int)27: 
                           #line 3255 
    ;
    #line 3256 
    phy->ops.setup_link = & ixgbe_setup_fw_link;
    #line 3257 
    phy->ops.reset = & ixgbe_reset_phy_fw;
    #line 3258 
    break;
    #line 3259 
    case (unsigned int)8: 
                          #line 3259 
    ;
    #line 3260 
    phy->ops.setup_link = (s32 (*)(struct ixgbe_hw *))0;
    #line 3261 
    phy->ops.read_reg = (s32 (*)(struct ixgbe_hw *, u32 , u32 , u16 *))0;
    #line 3262 
    phy->ops.write_reg = (s32 (*)(struct ixgbe_hw *, u32 , u32 , u16 ))0;
    #line 3263 
    phy->ops.reset = (s32 (*)(struct ixgbe_hw *))0;
    #line 3264 
    break;
    #line 3265 
    default: 
             #line 3265 
    ;
    #line 3266 
    break;
  }
  #line 3269 
  return ret_val;
}

#line 3278  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static enum ixgbe_media_type ixgbe_get_media_type_X550em(struct ixgbe_hw *hw)
{
  #line 3280 
  enum ixgbe_media_type media_type;
  #line 3283 
  switch ((int)hw->device_id) {
    #line 3284 
    case 5574: 
               #line 3284 
    ;
    #line 3285 
    case 5575: 
               #line 3285 
    ;
    #line 3286 
    hw->phy.type = ixgbe_phy_sgmii;
    #line 3288 
    case 5547: 
               #line 3288 
    ;
    #line 3289 
    case 5546: 
               #line 3289 
    ;
    #line 3290 
    case 5552: 
               #line 3290 
    ;
    #line 3291 
    case 5570: 
               #line 3291 
    ;
    #line 3292 
    case 5571: 
               #line 3292 
    ;
    #line 3293 
    media_type = ixgbe_media_type_backplane;
    #line 3294 
    break;
    #line 3295 
    case 5548: 
               #line 3295 
    ;
    #line 3296 
    case 5582: 
               #line 3296 
    ;
    #line 3297 
    case 5572: 
               #line 3297 
    ;
    #line 3298 
    media_type = ixgbe_media_type_fiber;
    #line 3299 
    break;
    #line 3300 
    case 5550: 
               #line 3300 
    ;
    #line 3301 
    case 5549: 
               #line 3301 
    ;
    #line 3302 
    case 5576: 
               #line 3302 
    ;
    #line 3303 
    case 5604: 
               #line 3303 
    ;
    #line 3304 
    case 5605: 
               #line 3304 
    ;
    #line 3305 
    media_type = ixgbe_media_type_copper;
    #line 3306 
    break;
    #line 3307 
    default: 
             #line 3307 
    ;
    #line 3308 
    media_type = ixgbe_media_type_unknown;
    #line 3309 
    break;
  }
  #line 3311 
  return media_type;
}

#line 3317  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_init_ext_t_x550em(struct ixgbe_hw *hw)
{
  #line 3319 
  s32 status;
  #line 3320 
  u16 reg;
  #line 3322 
  status = (*(hw->phy.ops.read_reg))(hw,52226U,1U,& reg);
  #line 3326 
  if (status != 0) 
                   #line 3327 
                   return status;
  #line 3332 
  if (((int)reg & 3) != 0) {
    #line 3333 
    status = (*(hw->phy.ops.read_reg))(hw,50297U,30U,& reg);
    #line 3337 
    if (status != 0) 
                     #line 3338 
                     return status;
    #line 3340 
    reg = (unsigned short)((unsigned int)reg & 32767U);
    #line 3342 
    status = (*(hw->phy.ops.write_reg))(hw,50297U,30U,(unsigned short)((int)reg));
    #line 3346 
    if (status != 0) 
                     #line 3347 
                     return status;
  }
  #line 3350 
  return status;
}

#line 3357  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static void ixgbe_set_mdio_speed(struct ixgbe_hw *hw)
{
  #line 3359 
  u32 hlreg0;
  #line 3361 
  switch ((int)hw->device_id) {
    #line 3362 
    case 5549: 
               #line 3362 
    ;
    #line 3363 
    case 5574: 
               #line 3363 
    ;
    #line 3364 
    case 5575: 
               #line 3364 
    ;
    #line 3365 
    case 5576: 
               #line 3365 
    ;
    #line 3366 
    case 5582: 
               #line 3366 
    ;
    #line 3368 
    hlreg0 = ixgbe_read_reg(hw,16960U);
    #line 3369 
    hlreg0 &= 4294901759U;
    #line 3370 
    ixgbe_write_reg_8(hw,16960U,hlreg0);
    #line 3371 
    break;
    #line 3372 
    case 5604: 
               #line 3372 
    ;
    #line 3373 
    case 5605: 
               #line 3373 
    ;
    #line 3375 
    hlreg0 = ixgbe_read_reg(hw,16960U);
    #line 3376 
    hlreg0 |= 65536U;
    #line 3377 
    ixgbe_write_reg_8(hw,16960U,hlreg0);
    #line 3378 
    break;
    #line 3379 
    default: 
             #line 3379 
    ;
    #line 3380 
    break;
  }
  #line 3382 
  return;
}

#line 3391  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_reset_hw_X550em(struct ixgbe_hw *hw)
{
  #line 3393 
  ixgbe_link_speed link_speed;
  #line 3394 
  s32 status;
  #line 3396 
  u32 i;
  #line 3395 
  u32 ctrl = 0U;
  #line 3397 
  bool link_up = (_Bool)0;
  #line 3398 
  u32 swfw_mask = hw->phy.phy_semaphore_mask;
  #line 3401 
  status = (*(hw->mac.ops.stop_adapter))(hw);
  #line 3402 
  if (status != 0) 
                   #line 3403 
                   return status;
  #line 3406 
  ixgbe_clear_tx_pending(hw);
  #line 3409 
  status = (*(hw->phy.ops.init))(hw);
  #line 3410 
  if (status == -19 || status == -17) 
                                      #line 3412 
                                      return status;
  #line 3415 
  if (hw->phy.type == (unsigned int)ixgbe_phy_x550em_ext_t) {
    #line 3416 
    status = ixgbe_init_ext_t_x550em(hw);
    #line 3417 
    if (status != 0) 
                     #line 3418 
                     return status;
  }
  #line 3422 
  if ((int)hw->phy.sfp_setup_needed != 0) {
    #line 3423 
    status = (*(hw->mac.ops.setup_sfp))(hw);
    #line 3424 
    hw->phy.sfp_setup_needed = (_Bool)0;
  }
  #line 3427 
  if (status == -19) 
                     #line 3428 
                     return status;
  #line 3431 
  if (! hw->phy.reset_disable && hw->phy.ops.reset != (s32 (*)(struct ixgbe_hw *))0) 
    #line 3432 
    (*(hw->phy.ops.reset))(hw);
  #line 3434 
  mac_reset_top: 
                 #line 3434 
  ;
  #line 3440 
  ctrl = 8U;
  #line 3442 
  if (! hw->force_full_reset) {
    #line 3443 
    (*(hw->mac.ops.check_link))(hw,& link_speed,& link_up,(_Bool)0);
    #line 3444 
    if ((int)link_up != 0) 
                           #line 3445 
                           ctrl = 67108864U;
  }
  #line 3448 
  status = (*(hw->mac.ops.acquire_swfw_sync))(hw,swfw_mask);
  #line 3449 
  if (status != 0) {
    {
      #line 3450 
      bool branch;
      #line 3450 
      struct _ddebug __UNIQUE_ID_ddebug463 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_reset_hw_X550em", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c", .format = (char *)"semaphore failed with %d", .lineno = (unsigned int)3450U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 3450 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug463.key.dd_key_false.key,(_Bool)0);
      #line 3450 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 3450 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug463,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"semaphore failed with %d",status);
    }
    #line 3451 
    return -16;
  }
  #line 3454 
  ctrl = ixgbe_read_reg(hw,0U) | ctrl;
  #line 3455 
  ixgbe_write_reg_8(hw,0U,ctrl);
  #line 3456 
  ixgbe_read_reg(hw,8U);
  #line 3457 
  (*(hw->mac.ops.release_swfw_sync))(hw,swfw_mask);
  #line 3458 
  usleep_range(1000UL,1200UL);
  #line 3461 
  i = 0U;
  #line 3461 
  while (i <= 9U) {
    #line 3462 
    ctrl = ixgbe_read_reg(hw,0U);
    #line 3463 
    if ((ctrl & 67108872U) == 0U) 
                                  #line 3464 
                                  break;
    #line 3465 
    __const_udelay(4295UL);
    #line 3461 
    i ++;
  }
  #line 3468 
  if ((ctrl & 67108872U) != 0U) {
    #line 3469 
    status = -15;
    {
      #line 3470 
      bool branch_0;
      #line 3470 
      struct _ddebug __UNIQUE_ID_ddebug464 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_reset_hw_X550em", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c", .format = (char *)"Reset polling failed to complete.\n", .lineno = (unsigned int)3470U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 3470 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug464.key.dd_key_false.key,(_Bool)0);
      #line 3470 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 3470 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug464,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Reset polling failed to complete.\n");
    }
  }
  #line 3473 
  msleep(50U);
  #line 3479 
  if (((int)hw->mac.flags & 1) != 0) {
    #line 3480 
    hw->mac.flags = (unsigned char)((unsigned int)hw->mac.flags & 254U);
    #line 3481 
    goto mac_reset_top;
  }
  #line 3485 
  (*(hw->mac.ops.get_mac_addr))(hw,(u8 *)(& hw->mac.perm_addr));
  #line 3491 
  hw->mac.num_rar_entries = 128U;
  #line 3492 
  (*(hw->mac.ops.init_rx_addrs))(hw);
  #line 3494 
  ixgbe_set_mdio_speed(hw);
  #line 3496 
  if ((unsigned int)hw->device_id == 5548U) 
                                            #line 3497 
                                            ixgbe_setup_mux_ctl(hw);
  #line 3499 
  return status;
}

#line 3508  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static void ixgbe_set_ethertype_anti_spoofing_X550(struct ixgbe_hw *hw, bool enable, int vf)
{
  #line 3513 
  u32 pfvfspoof;
  #line 3511 
  int vf_target_reg = vf >> 3;
  #line 3512 
  int vf_target_shift = vf % 8 + 16;
  #line 3515 
  pfvfspoof = ixgbe_read_reg(hw,(unsigned int)((vf_target_reg + 8320) * 4));
  #line 3516 
  if ((int)enable != 0) 
                        #line 3517 
                        pfvfspoof = (unsigned int)(1UL << vf_target_shift) | pfvfspoof; else 
                                                                    #line 3519 
                                                                    pfvfspoof = ~ ((unsigned int)(1UL << vf_target_shift)) & pfvfspoof;
  #line 3521 
  ixgbe_write_reg_8(hw,(unsigned int)((vf_target_reg + 8320) * 4),pfvfspoof);
  #line 3522 
  return;
}

#line 3529  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static void ixgbe_set_source_address_pruning_X550(struct ixgbe_hw *hw, bool enable, unsigned int pool)
{
  #line 3533 
  u64 pfflp;
  #line 3536 
  if (pool > 63U) 
                  #line 3537 
                  return;
  #line 3539 
  pfflp = (unsigned long long)ixgbe_read_reg(hw,20656U);
  #line 3540 
  pfflp = ((unsigned long long)ixgbe_read_reg(hw,20660U) << 32) | pfflp;
  #line 3542 
  if ((int)enable != 0) 
                        #line 3543 
                        pfflp = (1ULL << pool) | pfflp; else 
                                                             #line 3545 
                                                             pfflp = ~ (1ULL << pool) & pfflp;
  #line 3547 
  ixgbe_write_reg_8(hw,20656U,(unsigned int)pfflp);
  #line 3548 
  ixgbe_write_reg_8(hw,20660U,(unsigned int)(pfflp >> 32));
  #line 3549 
  return;
}

#line 3557  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_setup_fc_backplane_x550em_a(struct ixgbe_hw *hw)
{
  #line 3575 
  unsigned int tmp;
  #line 3625 
  unsigned int tmp_1;
  #line 3559 
  s32 status = 0;
  #line 3560 
  u32 an_cntl = 0U;
  #line 3563 
  if ((int)hw->fc.strict_ieee != 0 && hw->fc.requested_mode == (unsigned int)ixgbe_fc_rx_pause) {
    #line 3564 
    netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"ixgbe_fc_rx_pause not valid in strict IEEE mode\n");
    #line 3565 
    return -13;
  }
  #line 3568 
  if (hw->fc.requested_mode == (unsigned int)ixgbe_fc_default) 
                                                               #line 3569 
                                                               hw->fc.requested_mode = ixgbe_fc_full;
  #line 3575 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 3575 
                                          tmp = 33324U; else 
                                                             #line 3575 
                                                             tmp = 16940U;
  #line 3575 
  ;
  #line 3575 
  status = (*(hw->mac.ops.read_iosf_sb_reg))(hw,tmp,0U,& an_cntl);
  #line 3579 
  if (status != 0) {
    {
      #line 3580 
      bool branch;
      #line 3580 
      struct _ddebug __UNIQUE_ID_ddebug465 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_setup_fc_backplane_x550em_a", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c", .format = (char *)"Auto-Negotiation did not complete\n", .lineno = (unsigned int)3580U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 3580 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug465.key.dd_key_false.key,(_Bool)0);
      #line 3580 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 3580 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug465,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Auto-Negotiation did not complete\n");
    }
    #line 3581 
    return status;
  }
  #line 3593 
  switch ((unsigned int)hw->fc.requested_mode) {
    #line 3594 
    case (unsigned int)0: 
                          #line 3594 
    ;
    #line 3596 
    an_cntl &= 3489660927U;
    #line 3598 
    break;
    #line 3599 
    case (unsigned int)2: 
                          #line 3599 
    ;
    #line 3603 
    an_cntl |= 536870912U;
    #line 3604 
    an_cntl &= 4026531839U;
    #line 3605 
    break;
    #line 3606 
    case (unsigned int)1: 
                          #line 3606 
    ;
    #line 3615 
    case (unsigned int)3: 
                          #line 3615 
    ;
    #line 3617 
    an_cntl |= 805306368U;
    #line 3619 
    break;
    #line 3620 
    default: 
             #line 3620 
    ;
    #line 3621 
    netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Flow control param set incorrectly\n");
    #line 3622 
    return -4;
  }
  #line 3625 
  ;
  #line 3625 
  if ((unsigned int)hw->bus.lan_id != 0U) 
                                          #line 3625 
                                          tmp_1 = 33324U; else 
                                                               #line 3625 
                                                               tmp_1 = 16940U;
  #line 3625 
  ;
  #line 3625 
  status = (*(hw->mac.ops.write_iosf_sb_reg))(hw,tmp_1,0U,an_cntl);
  #line 3630 
  status = ixgbe_restart_an_internal_phy_x550em(hw);
  #line 3632 
  return status;
}

#line 3640  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static void ixgbe_set_mux(struct ixgbe_hw *hw, u8 state)
{
  #line 3642 
  u32 esdp;
  #line 3644 
  if ((unsigned int)hw->bus.lan_id == 0U) 
                                          #line 3645 
                                          return;
  #line 3646 
  esdp = ixgbe_read_reg(hw,32U);
  #line 3647 
  if ((unsigned int)state != 0U) 
                                 #line 3648 
                                 esdp |= 2U; else 
                                                  #line 3650 
                                                  esdp &= 4294967293U;
  #line 3651 
  ixgbe_write_reg_8(hw,32U,esdp);
  #line 3652 
  ixgbe_read_reg(hw,8U);
  #line 3653 
  return;
}

#line 3662  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_acquire_swfw_sync_X550em(struct ixgbe_hw *hw, u32 mask)
{
  #line 3664 
  s32 status;
  #line 3666 
  status = ixgbe_acquire_swfw_sync_X540(hw,mask);
  #line 3667 
  if (status != 0) 
                   #line 3668 
                   return status;
  #line 3670 
  if ((mask & 6144U) != 0U) 
                            #line 3671 
                            ixgbe_set_mux(hw,(unsigned char)1);
  #line 3673 
  return 0;
}

#line 3683  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static void ixgbe_release_swfw_sync_X550em(struct ixgbe_hw *hw, u32 mask)
{
  #line 3685 
  if ((mask & 6144U) != 0U) 
                            #line 3686 
                            ixgbe_set_mux(hw,(unsigned char)0);
  #line 3688 
  ixgbe_release_swfw_sync_X540(hw,mask);
  #line 3689 
  return;
}

#line 3698  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_acquire_swfw_sync_x550em_a(struct ixgbe_hw *hw, u32 mask)
{
  #line 3702 
  s32 status;
  #line 3700 
  u32 hmask = mask & 3221225471U;
  #line 3701 
  int retries = 1000;
  #line 3704 
  while (1) {
    #line 3704 
    retries --;
    #line 3704 
    if (! (retries != 0)) 
                          #line 3704 
                          break;
    #line 3705 
    status = 0;
    #line 3706 
    if (hmask != 0U) 
                     #line 3707 
                     status = ixgbe_acquire_swfw_sync_X540(hw,hmask);
    #line 3708 
    if (status != 0) 
                     #line 3709 
                     return status;
    #line 3710 
    if ((mask & 1073741824U) == 0U) 
                                    #line 3711 
                                    return 0;
    #line 3713 
    status = ixgbe_get_phy_token(hw);
    #line 3714 
    if (status == 0) 
                     #line 3715 
                     return 0;
    #line 3716 
    if (hmask != 0U) 
                     #line 3717 
                     ixgbe_release_swfw_sync_X540(hw,hmask);
    #line 3718 
    if (status != -40) 
                       #line 3719 
                       return status;
    #line 3720 
    msleep(5U);
  }
  #line 3723 
  return status;
}

#line 3733  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static void ixgbe_release_swfw_sync_x550em_a(struct ixgbe_hw *hw, u32 mask)
{
  #line 3735 
  u32 hmask = mask & 3221225471U;
  #line 3737 
  if ((mask & 1073741824U) != 0U) 
                                  #line 3738 
                                  ixgbe_put_phy_token(hw);
  #line 3740 
  if (hmask != 0U) 
                   #line 3741 
                   ixgbe_release_swfw_sync_X540(hw,hmask);
  #line 3742 
  return;
}

#line 3755  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_read_phy_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type, u16 *phy_data)
{
  #line 3759 
  s32 status;
  #line 3758 
  u32 mask = hw->phy.phy_semaphore_mask | 1073741824U;
  #line 3761 
  if ((*(hw->mac.ops.acquire_swfw_sync))(hw,mask) != 0) 
                                                        #line 3762 
                                                        return -16;
  #line 3764 
  status = (*(hw->phy.ops.read_reg_mdi))(hw,reg_addr,device_type,phy_data);
  #line 3766 
  (*(hw->mac.ops.release_swfw_sync))(hw,mask);
  #line 3768 
  return status;
}

#line 3781  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static s32 ixgbe_write_phy_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type, u16 phy_data)
{
  #line 3785 
  s32 status;
  #line 3784 
  u32 mask = hw->phy.phy_semaphore_mask | 1073741824U;
  #line 3787 
  if ((*(hw->mac.ops.acquire_swfw_sync))(hw,mask) != 0) 
                                                        #line 3788 
                                                        return -16;
  #line 3790 
  status = ixgbe_write_phy_reg_mdi(hw,reg_addr,device_type,(unsigned short)((int)phy_data));
  #line 3791 
  (*(hw->mac.ops.release_swfw_sync))(hw,mask);
  #line 3793 
  return status;
}

#line 3839  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static struct ixgbe_mac_operations mac_ops_X550 = {.init_hw = & ixgbe_init_hw_generic, .reset_hw = & ixgbe_reset_hw_X540, .start_hw = & ixgbe_start_hw_X540, .clear_hw_cntrs = & ixgbe_clear_hw_cntrs_generic, .get_media_type = & ixgbe_get_media_type_X540, .get_mac_addr = & ixgbe_get_mac_addr_generic, .get_san_mac_addr = & ixgbe_get_san_mac_addr_generic, .get_device_caps = & ixgbe_get_device_caps_generic, .get_wwn_prefix = & ixgbe_get_wwn_prefix_generic, .stop_adapter = & ixgbe_stop_adapter_generic, .get_bus_info = & ixgbe_get_bus_info_generic, .set_lan_id = & ixgbe_set_lan_id_multi_port_pcie, .disable_rx_buff = & ixgbe_disable_rx_buff_generic, .enable_rx_buff = & ixgbe_enable_rx_buff_generic, .enable_rx_dma = & ixgbe_enable_rx_dma_generic, .acquire_swfw_sync = & ixgbe_acquire_swfw_sync_X540, .release_swfw_sync = & ixgbe_release_swfw_sync_X540, .init_swfw_sync = & ixgbe_init_swfw_sync_X540, .prot_autoc_read = & prot_autoc_read_generic, .prot_autoc_write = & prot_autoc_write_generic, .setup_link = & ixgbe_setup_mac_link_X540, .check_link = & ixgbe_check_mac_link_generic, .get_link_capabilities = & ixgbe_get_copper_link_capabilities_generic, .set_rxpba = & ixgbe_set_rxpba_generic, .led_on = & ixgbe_led_on_generic, .led_off = & ixgbe_led_off_generic, .blink_led_start = & ixgbe_blink_led_start_X540, .blink_led_stop = & ixgbe_blink_led_stop_X540, .init_led_link_act = & ixgbe_init_led_link_act_generic, .set_rar = & ixgbe_set_rar_generic, .clear_rar = & ixgbe_clear_rar_generic, .set_vmdq = & ixgbe_set_vmdq_generic, .set_vmdq_san_mac = & ixgbe_set_vmdq_san_mac_generic, .clear_vmdq = & ixgbe_clear_vmdq_generic, .init_rx_addrs = & ixgbe_init_rx_addrs_generic, .update_mc_addr_list = & ixgbe_update_mc_addr_list_generic, .enable_mc = & ixgbe_enable_mc_generic, .disable_mc = & ixgbe_disable_mc_generic, .clear_vfta = & ixgbe_clear_vfta_generic, .set_vfta = & ixgbe_set_vfta_generic, .init_uta_tables = & ixgbe_init_uta_tables_generic, .set_mac_anti_spoofing = & ixgbe_set_mac_anti_spoofing, .set_vlan_anti_spoofing = & ixgbe_set_vlan_anti_spoofing, .fc_enable = & ixgbe_fc_enable_generic, .setup_fc = & ixgbe_setup_fc_generic, .fc_autoneg = & ixgbe_fc_autoneg, .set_fw_drv_ver = & ixgbe_set_fw_drv_ver_x550, .fw_recovery_mode = & ixgbe_fw_recovery_mode_X550, .disable_rx = & ixgbe_disable_rx_x550, .enable_rx = & ixgbe_enable_rx_generic, .set_source_address_pruning = & ixgbe_set_source_address_pruning_X550, .set_ethertype_anti_spoofing = & ixgbe_set_ethertype_anti_spoofing_X550};
#line 3861  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static struct ixgbe_mac_operations mac_ops_X550EM_x = {.init_hw = & ixgbe_init_hw_generic, .reset_hw = & ixgbe_reset_hw_X550em, .start_hw = & ixgbe_start_hw_X540, .clear_hw_cntrs = & ixgbe_clear_hw_cntrs_generic, .get_media_type = & ixgbe_get_media_type_X550em, .get_mac_addr = & ixgbe_get_mac_addr_generic, .get_device_caps = & ixgbe_get_device_caps_generic, .stop_adapter = & ixgbe_stop_adapter_generic, .get_bus_info = & ixgbe_get_bus_info_X550em, .set_lan_id = & ixgbe_set_lan_id_multi_port_pcie, .setup_sfp = & ixgbe_setup_sfp_modules_X550em, .disable_rx_buff = & ixgbe_disable_rx_buff_generic, .enable_rx_buff = & ixgbe_enable_rx_buff_generic, .enable_rx_dma = & ixgbe_enable_rx_dma_generic, .acquire_swfw_sync = & ixgbe_acquire_swfw_sync_X550em, .release_swfw_sync = & ixgbe_release_swfw_sync_X550em, .init_swfw_sync = & ixgbe_init_swfw_sync_X540, .setup_link = & ixgbe_setup_mac_link_X540, .check_link = & ixgbe_check_mac_link_generic, .get_link_capabilities = & ixgbe_get_link_capabilities_X550em, .set_rxpba = & ixgbe_set_rxpba_generic, .led_on = & ixgbe_led_on_t_x550em, .led_off = & ixgbe_led_off_t_x550em, .blink_led_start = & ixgbe_blink_led_start_X540, .blink_led_stop = & ixgbe_blink_led_stop_X540, .init_led_link_act = & ixgbe_init_led_link_act_generic, .set_rar = & ixgbe_set_rar_generic, .clear_rar = & ixgbe_clear_rar_generic, .set_vmdq = & ixgbe_set_vmdq_generic, .set_vmdq_san_mac = & ixgbe_set_vmdq_san_mac_generic, .clear_vmdq = & ixgbe_clear_vmdq_generic, .init_rx_addrs = & ixgbe_init_rx_addrs_generic, .update_mc_addr_list = & ixgbe_update_mc_addr_list_generic, .enable_mc = & ixgbe_enable_mc_generic, .disable_mc = & ixgbe_disable_mc_generic, .clear_vfta = & ixgbe_clear_vfta_generic, .set_vfta = & ixgbe_set_vfta_generic, .init_uta_tables = & ixgbe_init_uta_tables_generic, .set_mac_anti_spoofing = & ixgbe_set_mac_anti_spoofing, .set_vlan_anti_spoofing = & ixgbe_set_vlan_anti_spoofing, .fc_enable = & ixgbe_fc_enable_generic, .fc_autoneg = & ixgbe_fc_autoneg, .set_fw_drv_ver = & ixgbe_set_fw_drv_ver_x550, .fw_recovery_mode = & ixgbe_fw_recovery_mode_X550, .disable_rx = & ixgbe_disable_rx_x550, .enable_rx = & ixgbe_enable_rx_generic, .set_source_address_pruning = & ixgbe_set_source_address_pruning_X550, .set_ethertype_anti_spoofing = & ixgbe_set_ethertype_anti_spoofing_X550, .read_iosf_sb_reg = & ixgbe_read_iosf_sb_reg_x550, .write_iosf_sb_reg = & ixgbe_write_iosf_sb_reg_x550};
#line 3883  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static struct ixgbe_mac_operations mac_ops_X550EM_x_fw = {.init_hw = & ixgbe_init_hw_generic, .reset_hw = & ixgbe_reset_hw_X550em, .start_hw = & ixgbe_start_hw_X540, .clear_hw_cntrs = & ixgbe_clear_hw_cntrs_generic, .get_media_type = & ixgbe_get_media_type_X550em, .get_mac_addr = & ixgbe_get_mac_addr_generic, .get_device_caps = & ixgbe_get_device_caps_generic, .stop_adapter = & ixgbe_stop_adapter_generic, .get_bus_info = & ixgbe_get_bus_info_X550em, .set_lan_id = & ixgbe_set_lan_id_multi_port_pcie, .setup_sfp = & ixgbe_setup_sfp_modules_X550em, .disable_rx_buff = & ixgbe_disable_rx_buff_generic, .enable_rx_buff = & ixgbe_enable_rx_buff_generic, .enable_rx_dma = & ixgbe_enable_rx_dma_generic, .acquire_swfw_sync = & ixgbe_acquire_swfw_sync_X550em, .release_swfw_sync = & ixgbe_release_swfw_sync_X550em, .init_swfw_sync = & ixgbe_init_swfw_sync_X540, .setup_link = & ixgbe_setup_mac_link_X540, .check_link = & ixgbe_check_mac_link_generic, .get_link_capabilities = & ixgbe_get_link_capabilities_X550em, .set_rxpba = & ixgbe_set_rxpba_generic, .blink_led_start = & ixgbe_blink_led_start_X540, .blink_led_stop = & ixgbe_blink_led_stop_X540, .set_rar = & ixgbe_set_rar_generic, .clear_rar = & ixgbe_clear_rar_generic, .set_vmdq = & ixgbe_set_vmdq_generic, .set_vmdq_san_mac = & ixgbe_set_vmdq_san_mac_generic, .clear_vmdq = & ixgbe_clear_vmdq_generic, .init_rx_addrs = & ixgbe_init_rx_addrs_generic, .update_mc_addr_list = & ixgbe_update_mc_addr_list_generic, .enable_mc = & ixgbe_enable_mc_generic, .disable_mc = & ixgbe_disable_mc_generic, .clear_vfta = & ixgbe_clear_vfta_generic, .set_vfta = & ixgbe_set_vfta_generic, .init_uta_tables = & ixgbe_init_uta_tables_generic, .set_mac_anti_spoofing = & ixgbe_set_mac_anti_spoofing, .set_vlan_anti_spoofing = & ixgbe_set_vlan_anti_spoofing, .fc_enable = & ixgbe_fc_enable_generic, .fc_autoneg = & ixgbe_fc_autoneg, .set_fw_drv_ver = & ixgbe_set_fw_drv_ver_x550, .fw_recovery_mode = & ixgbe_fw_recovery_mode_X550, .disable_rx = & ixgbe_disable_rx_x550, .enable_rx = & ixgbe_enable_rx_generic, .set_source_address_pruning = & ixgbe_set_source_address_pruning_X550, .set_ethertype_anti_spoofing = & ixgbe_set_ethertype_anti_spoofing_X550, .read_iosf_sb_reg = & ixgbe_read_iosf_sb_reg_x550, .write_iosf_sb_reg = & ixgbe_write_iosf_sb_reg_x550};
#line 3905  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static struct ixgbe_mac_operations mac_ops_x550em_a = {.init_hw = & ixgbe_init_hw_generic, .reset_hw = & ixgbe_reset_hw_X550em, .start_hw = & ixgbe_start_hw_X540, .clear_hw_cntrs = & ixgbe_clear_hw_cntrs_generic, .get_media_type = & ixgbe_get_media_type_X550em, .get_mac_addr = & ixgbe_get_mac_addr_generic, .get_device_caps = & ixgbe_get_device_caps_generic, .stop_adapter = & ixgbe_stop_adapter_generic, .get_bus_info = & ixgbe_get_bus_info_X550em, .set_lan_id = & ixgbe_set_lan_id_multi_port_pcie, .setup_sfp = & ixgbe_setup_sfp_modules_X550em, .disable_rx_buff = & ixgbe_disable_rx_buff_generic, .enable_rx_buff = & ixgbe_enable_rx_buff_generic, .enable_rx_dma = & ixgbe_enable_rx_dma_generic, .acquire_swfw_sync = & ixgbe_acquire_swfw_sync_x550em_a, .release_swfw_sync = & ixgbe_release_swfw_sync_x550em_a, .setup_link = & ixgbe_setup_mac_link_X540, .check_link = & ixgbe_check_mac_link_generic, .get_link_capabilities = & ixgbe_get_link_capabilities_X550em, .set_rxpba = & ixgbe_set_rxpba_generic, .led_on = & ixgbe_led_on_t_x550em, .led_off = & ixgbe_led_off_t_x550em, .blink_led_start = & ixgbe_blink_led_start_X540, .blink_led_stop = & ixgbe_blink_led_stop_X540, .init_led_link_act = & ixgbe_init_led_link_act_generic, .set_rar = & ixgbe_set_rar_generic, .clear_rar = & ixgbe_clear_rar_generic, .set_vmdq = & ixgbe_set_vmdq_generic, .set_vmdq_san_mac = & ixgbe_set_vmdq_san_mac_generic, .clear_vmdq = & ixgbe_clear_vmdq_generic, .init_rx_addrs = & ixgbe_init_rx_addrs_generic, .update_mc_addr_list = & ixgbe_update_mc_addr_list_generic, .enable_mc = & ixgbe_enable_mc_generic, .disable_mc = & ixgbe_disable_mc_generic, .clear_vfta = & ixgbe_clear_vfta_generic, .set_vfta = & ixgbe_set_vfta_generic, .init_uta_tables = & ixgbe_init_uta_tables_generic, .set_mac_anti_spoofing = & ixgbe_set_mac_anti_spoofing, .set_vlan_anti_spoofing = & ixgbe_set_vlan_anti_spoofing, .fc_enable = & ixgbe_fc_enable_generic, .setup_fc = & ixgbe_setup_fc_x550em, .fc_autoneg = & ixgbe_fc_autoneg, .set_fw_drv_ver = & ixgbe_set_fw_drv_ver_x550, .fw_recovery_mode = & ixgbe_fw_recovery_mode_X550, .disable_rx = & ixgbe_disable_rx_x550, .enable_rx = & ixgbe_enable_rx_generic, .set_source_address_pruning = & ixgbe_set_source_address_pruning_X550, .set_ethertype_anti_spoofing = & ixgbe_set_ethertype_anti_spoofing_X550, .read_iosf_sb_reg = & ixgbe_read_iosf_sb_reg_x550a, .write_iosf_sb_reg = & ixgbe_write_iosf_sb_reg_x550a};
#line 3926  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static struct ixgbe_mac_operations mac_ops_x550em_a_fw = {.init_hw = & ixgbe_init_hw_generic, .reset_hw = & ixgbe_reset_hw_X550em, .start_hw = & ixgbe_start_hw_X540, .clear_hw_cntrs = & ixgbe_clear_hw_cntrs_generic, .get_media_type = & ixgbe_get_media_type_X550em, .get_mac_addr = & ixgbe_get_mac_addr_generic, .get_device_caps = & ixgbe_get_device_caps_generic, .stop_adapter = & ixgbe_stop_adapter_generic, .get_bus_info = & ixgbe_get_bus_info_X550em, .set_lan_id = & ixgbe_set_lan_id_multi_port_pcie, .setup_sfp = & ixgbe_setup_sfp_modules_X550em, .disable_rx_buff = & ixgbe_disable_rx_buff_generic, .enable_rx_buff = & ixgbe_enable_rx_buff_generic, .enable_rx_dma = & ixgbe_enable_rx_dma_generic, .acquire_swfw_sync = & ixgbe_acquire_swfw_sync_x550em_a, .release_swfw_sync = & ixgbe_release_swfw_sync_x550em_a, .check_link = & ixgbe_check_mac_link_generic, .get_link_capabilities = & ixgbe_get_link_capabilities_X550em, .set_rxpba = & ixgbe_set_rxpba_generic, .led_on = & ixgbe_led_on_generic, .led_off = & ixgbe_led_off_generic, .blink_led_start = & ixgbe_blink_led_start_X540, .blink_led_stop = & ixgbe_blink_led_stop_X540, .init_led_link_act = & ixgbe_init_led_link_act_generic, .set_rar = & ixgbe_set_rar_generic, .clear_rar = & ixgbe_clear_rar_generic, .set_vmdq = & ixgbe_set_vmdq_generic, .set_vmdq_san_mac = & ixgbe_set_vmdq_san_mac_generic, .clear_vmdq = & ixgbe_clear_vmdq_generic, .init_rx_addrs = & ixgbe_init_rx_addrs_generic, .update_mc_addr_list = & ixgbe_update_mc_addr_list_generic, .enable_mc = & ixgbe_enable_mc_generic, .disable_mc = & ixgbe_disable_mc_generic, .clear_vfta = & ixgbe_clear_vfta_generic, .set_vfta = & ixgbe_set_vfta_generic, .init_uta_tables = & ixgbe_init_uta_tables_generic, .set_mac_anti_spoofing = & ixgbe_set_mac_anti_spoofing, .set_vlan_anti_spoofing = & ixgbe_set_vlan_anti_spoofing, .fc_enable = & ixgbe_fc_enable_generic, .setup_fc = & ixgbe_setup_fc_x550em, .fc_autoneg = & ixgbe_fc_autoneg, .set_fw_drv_ver = & ixgbe_set_fw_drv_ver_x550, .fw_recovery_mode = & ixgbe_fw_recovery_mode_X550, .disable_rx = & ixgbe_disable_rx_x550, .enable_rx = & ixgbe_enable_rx_generic, .set_source_address_pruning = & ixgbe_set_source_address_pruning_X550, .set_ethertype_anti_spoofing = & ixgbe_set_ethertype_anti_spoofing_X550, .read_iosf_sb_reg = & ixgbe_read_iosf_sb_reg_x550a, .write_iosf_sb_reg = & ixgbe_write_iosf_sb_reg_x550a};
#line 3956  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static struct ixgbe_eeprom_operations eeprom_ops_X550 = {.init_params = & ixgbe_init_eeprom_params_X550, .read = & ixgbe_read_ee_hostif_X550, .read_buffer = & ixgbe_read_ee_hostif_buffer_X550, .write = & ixgbe_write_ee_hostif_X550, .write_buffer = & ixgbe_write_ee_hostif_buffer_X550, .validate_checksum = & ixgbe_validate_eeprom_checksum_X550, .update_checksum = & ixgbe_update_eeprom_checksum_X550, .calc_checksum = & ixgbe_calc_eeprom_checksum_X550};
#line 3961  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static struct ixgbe_eeprom_operations eeprom_ops_X550EM_x = {.init_params = & ixgbe_init_eeprom_params_X540, .read = & ixgbe_read_ee_hostif_X550, .read_buffer = & ixgbe_read_ee_hostif_buffer_X550, .write = & ixgbe_write_ee_hostif_X550, .write_buffer = & ixgbe_write_ee_hostif_buffer_X550, .validate_checksum = & ixgbe_validate_eeprom_checksum_X550, .update_checksum = & ixgbe_update_eeprom_checksum_X550, .calc_checksum = & ixgbe_calc_eeprom_checksum_X550};
#line 3978  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static struct ixgbe_phy_operations phy_ops_X550 = {.identify = & ixgbe_identify_phy_generic, .identify_sfp = & ixgbe_identify_module_generic, .read_reg = & ixgbe_read_phy_reg_generic, .write_reg = & ixgbe_write_phy_reg_generic, .setup_link = & ixgbe_setup_phy_link_generic, .setup_link_speed = & ixgbe_setup_phy_link_speed_generic, .read_i2c_byte = & ixgbe_read_i2c_byte_generic, .write_i2c_byte = & ixgbe_write_i2c_byte_generic, .read_i2c_sff8472 = & ixgbe_read_i2c_sff8472_generic, .read_i2c_eeprom = & ixgbe_read_i2c_eeprom_generic, .write_i2c_eeprom = & ixgbe_write_i2c_eeprom_generic, .check_overtemp = & ixgbe_tn_check_overtemp};
#line 3987  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static struct ixgbe_phy_operations phy_ops_X550EM_x = {.identify = & ixgbe_identify_phy_x550em, .identify_sfp = & ixgbe_identify_module_generic, .init = & ixgbe_init_phy_ops_X550em, .read_reg = & ixgbe_read_phy_reg_generic, .write_reg = & ixgbe_write_phy_reg_generic, .setup_link = & ixgbe_setup_phy_link_generic, .setup_link_speed = & ixgbe_setup_phy_link_speed_generic, .read_i2c_byte = & ixgbe_read_i2c_byte_generic, .write_i2c_byte = & ixgbe_write_i2c_byte_generic, .read_i2c_sff8472 = & ixgbe_read_i2c_sff8472_generic, .read_i2c_eeprom = & ixgbe_read_i2c_eeprom_generic, .write_i2c_eeprom = & ixgbe_write_i2c_eeprom_generic, .check_overtemp = & ixgbe_tn_check_overtemp};
#line 3996  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static struct ixgbe_phy_operations phy_ops_x550em_x_fw = {.identify = & ixgbe_identify_phy_x550em, .identify_sfp = & ixgbe_identify_module_generic, .init = & ixgbe_init_phy_ops_X550em, .setup_link = & ixgbe_setup_phy_link_generic, .setup_link_speed = & ixgbe_setup_phy_link_speed_generic, .read_i2c_byte = & ixgbe_read_i2c_byte_generic, .write_i2c_byte = & ixgbe_write_i2c_byte_generic, .read_i2c_sff8472 = & ixgbe_read_i2c_sff8472_generic, .read_i2c_eeprom = & ixgbe_read_i2c_eeprom_generic, .write_i2c_eeprom = & ixgbe_write_i2c_eeprom_generic};
#line 4007  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static struct ixgbe_phy_operations phy_ops_x550em_a = {.identify = & ixgbe_identify_phy_x550em, .identify_sfp = & ixgbe_identify_module_generic, .init = & ixgbe_init_phy_ops_X550em, .read_reg = & ixgbe_read_phy_reg_x550a, .write_reg = & ixgbe_write_phy_reg_x550a, .read_reg_mdi = & ixgbe_read_phy_reg_mdi, .write_reg_mdi = & ixgbe_write_phy_reg_mdi, .setup_link = & ixgbe_setup_phy_link_generic, .setup_link_speed = & ixgbe_setup_phy_link_speed_generic, .read_i2c_byte = & ixgbe_read_i2c_byte_generic, .write_i2c_byte = & ixgbe_write_i2c_byte_generic, .read_i2c_sff8472 = & ixgbe_read_i2c_sff8472_generic, .read_i2c_eeprom = & ixgbe_read_i2c_eeprom_generic, .write_i2c_eeprom = & ixgbe_write_i2c_eeprom_generic, .check_overtemp = & ixgbe_tn_check_overtemp};
#line 4018  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static struct ixgbe_phy_operations phy_ops_x550em_a_fw = {.identify = & ixgbe_identify_phy_fw, .identify_sfp = & ixgbe_identify_module_generic, .init = & ixgbe_init_phy_ops_X550em, .setup_link = & ixgbe_setup_phy_link_generic, .setup_link_speed = & ixgbe_setup_phy_link_speed_generic, .read_i2c_byte = & ixgbe_read_i2c_byte_generic, .write_i2c_byte = & ixgbe_write_i2c_byte_generic, .read_i2c_sff8472 = & ixgbe_read_i2c_sff8472_generic, .read_i2c_eeprom = & ixgbe_read_i2c_eeprom_generic, .write_i2c_eeprom = & ixgbe_write_i2c_eeprom_generic, .check_overtemp = & ixgbe_check_overtemp_fw};
#line 4029  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static struct ixgbe_link_operations link_ops_x550em_x = {.read_link = & ixgbe_read_i2c_combined_generic, .read_link_unlocked = & ixgbe_read_i2c_combined_generic_unlocked, .write_link = & ixgbe_write_i2c_combined_generic, .write_link_unlocked = & ixgbe_write_i2c_combined_generic_unlocked};
#line 4036  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static u32 ixgbe_mvals_X550[23U] = {65552U, 65564U, 66048U, 65872U, 65856U, 65888U, 65864U, 2U, 4U, 8U, 33554432U, 67108864U, 134217728U, 70920U, 70928U, 16384U, 512U, 4096U, 1024U, 2048U, 256U, 8192U, 89948U};
#line 4040  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static u32 ixgbe_mvals_X550EM_x[23U] = {65552U, 65564U, 66048U, 65872U, 65856U, 65888U, 65864U, 2U, 4U, 8U, 33554432U, 67108864U, 134217728U, 70920U, 70928U, 16384U, 512U, 4096U, 1024U, 2048U, 256U, 8192U, 89948U};
#line 4044  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
static u32 ixgbe_mvals_x550em_a[23U] = {90104U, 89960U, 89956U, 90092U, 89968U, 89976U, 89972U, 2U, 4U, 8U, 33554432U, 67108864U, 134217728U, 70920U, 70928U, 16384U, 512U, 4096U, 1024U, 2048U, 256U, 8192U, 89948U};
#line 4048  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
struct ixgbe_info ixgbe_X550_info = {.mac = ixgbe_mac_X550, .get_invariants = & ixgbe_get_invariants_X540, .mac_ops = & mac_ops_X550, .eeprom_ops = & eeprom_ops_X550, .phy_ops = & phy_ops_X550, .mbx_ops = & mbx_ops_generic, .mvals = (u32 *)(& ixgbe_mvals_X550)};
#line 4058  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
struct ixgbe_info ixgbe_X550EM_x_info = {.mac = ixgbe_mac_X550EM_x, .get_invariants = & ixgbe_get_invariants_X550_x, .mac_ops = & mac_ops_X550EM_x, .eeprom_ops = & eeprom_ops_X550EM_x, .phy_ops = & phy_ops_X550EM_x, .mbx_ops = & mbx_ops_generic, .link_ops = & link_ops_x550em_x, .mvals = (u32 *)(& ixgbe_mvals_X550EM_x)};
#line 4069  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
struct ixgbe_info ixgbe_x550em_x_fw_info = {.mac = ixgbe_mac_X550EM_x, .get_invariants = & ixgbe_get_invariants_X550_x_fw, .mac_ops = & mac_ops_X550EM_x_fw, .eeprom_ops = & eeprom_ops_X550EM_x, .phy_ops = & phy_ops_x550em_x_fw, .mbx_ops = & mbx_ops_generic, .mvals = (u32 *)(& ixgbe_mvals_X550EM_x)};
#line 4079  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
struct ixgbe_info ixgbe_x550em_a_info = {.mac = ixgbe_mac_x550em_a, .get_invariants = & ixgbe_get_invariants_X550_a, .mac_ops = & mac_ops_x550em_a, .eeprom_ops = & eeprom_ops_X550EM_x, .phy_ops = & phy_ops_x550em_a, .mbx_ops = & mbx_ops_generic, .mvals = (u32 *)(& ixgbe_mvals_x550em_a)};
#line 4089  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c"
struct ixgbe_info ixgbe_x550em_a_fw_info = {.mac = ixgbe_mac_x550em_a, .get_invariants = & ixgbe_get_invariants_X550_a_fw, .mac_ops = & mac_ops_x550em_a_fw, .eeprom_ops = & eeprom_ops_X550EM_x, .phy_ops = & phy_ops_x550em_a_fw, .mbx_ops = & mbx_ops_generic, .mvals = (u32 *)(& ixgbe_mvals_x550em_a)};
#line 112  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ktime.h"
__inline static int ktime_compare(ktime_t cmp1, ktime_t cmp2)
{
  #line 114 
  if (cmp1 < cmp2) 
                   #line 115 
                   return -1;
  #line 116 
  if (cmp1 > cmp2) 
                   #line 117 
                   return 1;
  #line 118 
  return 0;
}

#line 196  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ktime.h"
__inline static ktime_t ktime_add_us(ktime_t kt, u64 usec)
{
  #line 198 
  return (long long)(usec * 1000ULL + (unsigned long long)kt);
}

#line 67  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timekeeping.h"
#line 67 
ktime_t ktime_get(void);
#line 1054  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
#line 1054 
struct pci_dev *pci_get_domain_bus_and_slot(int, unsigned int, unsigned int);
#line 140  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mdio.h"
#line 140 
int mdio45_probe(struct mdio_if_info *, int);
#line 266  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/phy.h"
#line 266 
int __mdiobus_register(struct mii_bus *, struct module *);
#line 270 
#line 270 
struct mii_bus *devm_mdiobus_alloc_size(struct device *, int);
#line 271  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/phy.h"
__inline static struct mii_bus *devm_mdiobus_alloc(struct device *dev)
{
  #line 273 
  return devm_mdiobus_alloc_size(dev,0);
}

#line 276 
#line 276 
void devm_mdiobus_free(struct device *, struct mii_bus *);
#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static void ixgbe_write_reg_9(struct ixgbe_hw *hw, u32 reg, u32 value)
{
  #line 147 
  union __anonunion___u_9999 __u;
  #line 146 
  __read_once_size((void *)(& hw->hw_addr),(void *)(& __u.__c),8);
  #line 146 
  u8 *reg_addr = (__u.__val);
  #line 148 
  if ((int)ixgbe_removed((void *)reg_addr) != 0) 
                                                 #line 149 
                                                 return;
  #line 150 
  writel(value,(void *)(reg_addr + (unsigned long)reg));
  #line 151 
  return;
}

#line 154  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h"
#line 1401  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_identify_sfp_module_generic(struct ixgbe_hw *hw);
#line 12 
#line 2229 
static void ixgbe_i2c_start(struct ixgbe_hw *hw);
#line 13 
#line 2262 
static void ixgbe_i2c_stop(struct ixgbe_hw *hw);
#line 14 
#line 2296 
static s32 ixgbe_clock_in_i2c_byte(struct ixgbe_hw *hw, u8 *data);
#line 15 
#line 2317 
static s32 ixgbe_clock_out_i2c_byte(struct ixgbe_hw *hw, u8 data);
#line 16 
#line 2348 
static s32 ixgbe_get_i2c_ack(struct ixgbe_hw *hw);
#line 17 
#line 2399 
static s32 ixgbe_clock_in_i2c_bit(struct ixgbe_hw *hw, bool *data);
#line 18 
#line 2433 
static s32 ixgbe_clock_out_i2c_bit(struct ixgbe_hw *hw, bool data);
#line 19 
#line 2466 
static void ixgbe_raise_i2c_clk(struct ixgbe_hw *hw, u32 *i2cctl);
#line 20 
#line 2499 
static void ixgbe_lower_i2c_clk(struct ixgbe_hw *hw, u32 *i2cctl);
#line 21 
#line 2521 
static s32 ixgbe_set_i2c_data(struct ixgbe_hw *hw, u32 *i2cctl, bool data);
#line 22 
#line 2563 
static bool ixgbe_get_i2c_data(struct ixgbe_hw *hw, u32 *i2cctl);
#line 23 
#line 2586 
static void ixgbe_i2c_bus_clear(struct ixgbe_hw *hw);
#line 24 
#line 360 
static enum ixgbe_phy_type ixgbe_get_phy_type_from_id(u32 phy_id);
#line 25 
#line 336 
static s32 ixgbe_get_phy_id(struct ixgbe_hw *hw);
#line 26 
#line 1666 
static s32 ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw);
#line 35  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_out_i2c_byte_ack(struct ixgbe_hw *hw, u8 byte)
{
  #line 37 
  s32 status;
  #line 39 
  status = ixgbe_clock_out_i2c_byte(hw,(unsigned char)((int)byte));
  #line 40 
  if (status != 0) 
                   #line 41 
                   return status;
  #line 42 
  return ixgbe_get_i2c_ack(hw);
}

#line 52  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_in_i2c_byte_ack(struct ixgbe_hw *hw, u8 *byte)
{
  #line 54 
  s32 status;
  #line 56 
  status = ixgbe_clock_in_i2c_byte(hw,byte);
  #line 57 
  if (status != 0) 
                   #line 58 
                   return status;
  #line 60 
  return ixgbe_clock_out_i2c_bit(hw,(_Bool)0);
}

#line 70  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static u8 ixgbe_ones_comp_byte_add(u8 add1, u8 add2)
{
  #line 72 
  u16 sum = (unsigned short)((int)((unsigned short)add1) + (int)((unsigned short)add2));
  #line 74 
  sum = (unsigned short)(((unsigned int)sum & 255U) + (unsigned int)((unsigned short)((int)sum >> 8)));
  #line 75 
  return (unsigned char)sum;
}

#line 88  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_read_i2c_combined_generic_int(struct ixgbe_hw *hw, u8 addr, u16 reg, u16 *val, bool lock)
{
  #line 94 
  u8 csum_byte;
  #line 95 
  u8 high_bits;
  #line 96 
  u8 low_bits;
  #line 97 
  u8 reg_high;
  #line 98 
  u8 csum;
  #line 91 
  u32 swfw_mask = hw->phy.phy_semaphore_mask;
  #line 92 
  int max_retry = 3;
  #line 93 
  int retry = 0;
  #line 100 
  reg_high = (unsigned char)(((int)reg >> 7) | 1);
  #line 101 
  csum = ixgbe_ones_comp_byte_add((unsigned char)((int)reg_high),(unsigned char)((int)((unsigned char)reg)));
  #line 102 
  csum = (unsigned char)(~ ((int)csum));
  #line 103 
  while (1) {
    {
      #line 104 
      if ((int)lock != 0) {
        #line 104 
        if ((*(hw->mac.ops.acquire_swfw_sync))(hw,swfw_mask) != 0) 
                                                                   #line 105 
                                                                   return -16;
      }
      #line 106 
      ixgbe_i2c_start(hw);
      #line 108 
      if (ixgbe_out_i2c_byte_ack(hw,(unsigned char)((int)addr)) != 0) 
        #line 109 
        goto fail;
      #line 111 
      if (ixgbe_out_i2c_byte_ack(hw,(unsigned char)((int)reg_high)) != 0) 
        #line 112 
        goto fail;
      #line 114 
      if (ixgbe_out_i2c_byte_ack(hw,(unsigned char)((int)((unsigned char)reg))) != 0) 
        #line 115 
        goto fail;
      #line 117 
      if (ixgbe_out_i2c_byte_ack(hw,(unsigned char)((int)csum)) != 0) 
        #line 118 
        goto fail;
      #line 120 
      ixgbe_i2c_start(hw);
      #line 122 
      if (ixgbe_out_i2c_byte_ack(hw,
                               (unsigned char)((int)((unsigned int)addr | 1U))) != 0) 
        #line 123 
        goto fail;
      #line 125 
      if (ixgbe_in_i2c_byte_ack(hw,& high_bits) != 0) 
                                                      #line 126 
                                                      goto fail;
      #line 128 
      if (ixgbe_in_i2c_byte_ack(hw,& low_bits) != 0) 
                                                     #line 129 
                                                     goto fail;
      #line 131 
      if (ixgbe_clock_in_i2c_byte(hw,& csum_byte) != 0) 
                                                        #line 132 
                                                        goto fail;
      #line 134 
      if (ixgbe_clock_out_i2c_bit(hw,(_Bool)0) != 0) 
                                                     #line 135 
                                                     goto fail;
      #line 136 
      ixgbe_i2c_stop(hw);
      #line 137 
      if ((int)lock != 0) 
                          #line 138 
                          (*(hw->mac.ops.release_swfw_sync))(hw,swfw_mask);
      #line 139 
      *val = (unsigned short)(((int)high_bits << 8) | (int)low_bits);
      #line 140 
      return 0;
      #line 142 
      fail: 
            #line 142 
      ;
      #line 143 
      ixgbe_i2c_bus_clear(hw);
      #line 144 
      if ((int)lock != 0) 
                          #line 145 
                          (*(hw->mac.ops.release_swfw_sync))(hw,swfw_mask);
      #line 146 
      retry ++;
      #line 147 
      if (retry < max_retry) {
        #line 148 
        bool branch;
        #line 148 
        struct _ddebug __UNIQUE_ID_ddebug443 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_read_i2c_combined_generic_int", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"I2C byte read combined error - Retry.\n", .lineno = (unsigned int)148U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 148 
        branch = arch_static_branch(& __UNIQUE_ID_ddebug443.key.dd_key_false.key,(_Bool)0);
        #line 148 
        if ((long)((long)((int)branch != 0)) != 0L) 
                                                    #line 148 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug443,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"I2C byte read combined error - Retry.\n");
      }
      else {
        #line 150 
        bool branch_0;
        #line 150 
        struct _ddebug __UNIQUE_ID_ddebug444 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_read_i2c_combined_generic_int", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"I2C byte read combined error.\n", .lineno = (unsigned int)150U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 150 
        branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug444.key.dd_key_false.key,(_Bool)0);
        #line 150 
        if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                      #line 150 
                                                      __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug444,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"I2C byte read combined error.\n");
      }
    }
    #line 152 
    if (! (retry < max_retry)) 
                               #line 103 
                               break;
  }
  #line 153 
  return -18;
}

#line 166  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_write_i2c_combined_generic_int(struct ixgbe_hw *hw, u8 addr, u16 reg, u16 val, bool lock)
{
  #line 172 
  u8 reg_high;
  #line 173 
  u8 csum;
  #line 169 
  u32 swfw_mask = hw->phy.phy_semaphore_mask;
  #line 170 
  int max_retry = 1;
  #line 171 
  int retry = 0;
  #line 175 
  reg_high = (unsigned char)((unsigned int)((unsigned char)((int)reg >> 7)) & 254U);
  #line 176 
  csum = ixgbe_ones_comp_byte_add((unsigned char)((int)reg_high),(unsigned char)((int)((unsigned char)reg)));
  #line 177 
  csum = ixgbe_ones_comp_byte_add((unsigned char)((int)csum),(unsigned char)((int)((unsigned char)((int)val >> 8))));
  #line 178 
  csum = ixgbe_ones_comp_byte_add((unsigned char)((int)csum),(unsigned char)((int)((unsigned char)val)));
  #line 179 
  csum = (unsigned char)(~ ((int)csum));
  #line 180 
  while (1) {
    {
      #line 181 
      if ((int)lock != 0) {
        #line 181 
        if ((*(hw->mac.ops.acquire_swfw_sync))(hw,swfw_mask) != 0) 
                                                                   #line 182 
                                                                   return -16;
      }
      #line 183 
      ixgbe_i2c_start(hw);
      #line 185 
      if (ixgbe_out_i2c_byte_ack(hw,(unsigned char)((int)addr)) != 0) 
        #line 186 
        goto fail;
      #line 188 
      if (ixgbe_out_i2c_byte_ack(hw,(unsigned char)((int)reg_high)) != 0) 
        #line 189 
        goto fail;
      #line 191 
      if (ixgbe_out_i2c_byte_ack(hw,(unsigned char)((int)((unsigned char)reg))) != 0) 
        #line 192 
        goto fail;
      #line 194 
      if (ixgbe_out_i2c_byte_ack(hw,
                               (unsigned char)((int)((unsigned char)(
                               (int)val >> 8)))) != 0) 
        #line 195 
        goto fail;
      #line 197 
      if (ixgbe_out_i2c_byte_ack(hw,(unsigned char)((int)((unsigned char)val))) != 0) 
        #line 198 
        goto fail;
      #line 200 
      if (ixgbe_out_i2c_byte_ack(hw,(unsigned char)((int)csum)) != 0) 
        #line 201 
        goto fail;
      #line 202 
      ixgbe_i2c_stop(hw);
      #line 203 
      if ((int)lock != 0) 
                          #line 204 
                          (*(hw->mac.ops.release_swfw_sync))(hw,swfw_mask);
      #line 205 
      return 0;
      #line 207 
      fail: 
            #line 207 
      ;
      #line 208 
      ixgbe_i2c_bus_clear(hw);
      #line 209 
      if ((int)lock != 0) 
                          #line 210 
                          (*(hw->mac.ops.release_swfw_sync))(hw,swfw_mask);
      #line 211 
      retry ++;
      #line 212 
      if (retry < max_retry) {
        #line 213 
        bool branch;
        #line 213 
        struct _ddebug __UNIQUE_ID_ddebug445 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_write_i2c_combined_generic_int", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"I2C byte write combined error - Retry.\n", .lineno = (unsigned int)213U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 213 
        branch = arch_static_branch(& __UNIQUE_ID_ddebug445.key.dd_key_false.key,(_Bool)0);
        #line 213 
        if ((long)((long)((int)branch != 0)) != 0L) 
                                                    #line 213 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug445,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"I2C byte write combined error - Retry.\n");
      }
      else {
        #line 215 
        bool branch_0;
        #line 215 
        struct _ddebug __UNIQUE_ID_ddebug446 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_write_i2c_combined_generic_int", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"I2C byte write combined error.\n", .lineno = (unsigned int)215U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 215 
        branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug446.key.dd_key_false.key,(_Bool)0);
        #line 215 
        if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                      #line 215 
                                                      __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug446,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"I2C byte write combined error.\n");
      }
    }
    #line 217 
    if (! (retry < max_retry)) 
                               #line 180 
                               break;
  }
  #line 218 
  return -18;
}

#line 228  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static bool ixgbe_probe_phy(struct ixgbe_hw *hw, u16 phy_addr)
{
  #line 230 
  u16 ext_ability = (unsigned short)0U;
  #line 232 
  hw->phy.mdio.prtad = (int)phy_addr;
  #line 233 
  if (mdio45_probe(& hw->phy.mdio,(int)phy_addr) != 0) 
                                                       #line 234 
                                                       return (_Bool)0;
  #line 236 
  if (ixgbe_get_phy_id(hw) != 0) 
                                 #line 237 
                                 return (_Bool)0;
  #line 239 
  hw->phy.type = ixgbe_get_phy_type_from_id(hw->phy.id);
  #line 241 
  if (hw->phy.type == (unsigned int)ixgbe_phy_unknown) {
    #line 242 
    (*(hw->phy.ops.read_reg))(hw,11U,1U,& ext_ability);
    #line 246 
    if (((int)ext_ability & 36) != 0) 
                                      #line 249 
                                      hw->phy.type = ixgbe_phy_cu_unknown; else 
                                                                    #line 251 
                                                                    hw->phy.type = ixgbe_phy_generic;
  }
  #line 254 
  return (_Bool)1;
}

#line 263  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_identify_phy_generic(struct ixgbe_hw *hw)
{
  #line 265 
  u32 phy_addr;
  #line 266 
  u32 status = 4294967279U;
  #line 268 
  if (hw->phy.phy_semaphore_mask == 0U) 
    #line 269 
    if ((unsigned int)hw->bus.lan_id != 0U) 
                                            #line 270 
                                            hw->phy.phy_semaphore_mask = 4U; else 
                                                                    #line 272 
                                                                    hw->phy.phy_semaphore_mask = 2U;
  #line 275 
  if (hw->phy.type != (unsigned int)ixgbe_phy_unknown) 
                                                       #line 276 
                                                       return 0;
  #line 278 
  if (hw->phy.nw_mng_if_sel != 0U) {
    #line 279 
    phy_addr = (hw->phy.nw_mng_if_sel >> 3) & 31U;
    #line 282 
    if ((int)ixgbe_probe_phy(hw,(unsigned short)((int)((unsigned short)phy_addr))) != 0) 
      #line 283 
      return 0; else 
                     #line 285 
                     return -17;
  }
  #line 288 
  phy_addr = 0U;
  #line 288 
  while (phy_addr <= 31U) {
    #line 289 
    if ((int)ixgbe_probe_phy(hw,(unsigned short)((int)((unsigned short)phy_addr))) != 0) {
      #line 290 
      status = 0U;
      #line 291 
      break;
    }
    #line 288 
    phy_addr ++;
  }
  #line 299 
  if (status != 0U) 
                    #line 300 
                    hw->phy.mdio.prtad = -1;
  #line 302 
  return (int)status;
}

#line 314  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
bool ixgbe_check_reset_blocked(struct ixgbe_hw *hw)
{
  #line 316 
  u32 mmngc;
  #line 319 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) 
                                                       #line 320 
                                                       return (_Bool)0;
  #line 322 
  mmngc = ixgbe_read_reg(hw,17104U);
  #line 323 
  if ((mmngc & 1U) != 0U) {
    {
      #line 324 
      bool branch;
      #line 324 
      struct _ddebug __UNIQUE_ID_ddebug447 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_check_reset_blocked", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"MNG_VETO bit detected.\n", .lineno = (unsigned int)324U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 324 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug447.key.dd_key_false.key,(_Bool)0);
      #line 324 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 324 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug447,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"MNG_VETO bit detected.\n");
    }
    #line 325 
    return (_Bool)1;
  }
  #line 328 
  return (_Bool)0;
}

#line 336  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_get_phy_id(struct ixgbe_hw *hw)
{
  #line 338 
  s32 status;
  #line 339 
  u16 phy_id_high = (unsigned short)0U;
  #line 340 
  u16 phy_id_low = (unsigned short)0U;
  #line 342 
  status = (*(hw->phy.ops.read_reg))(hw,2U,1U,& phy_id_high);
  #line 345 
  if (status == 0) {
    #line 346 
    hw->phy.id = (unsigned int)((int)phy_id_high << 16);
    #line 347 
    status = (*(hw->phy.ops.read_reg))(hw,3U,1U,& phy_id_low);
    #line 349 
    hw->phy.id |= (unsigned int)phy_id_low & 4294967280U;
    #line 350 
    hw->phy.revision = (unsigned int)phy_id_low & 15U;
  }
  #line 352 
  return status;
}

#line 360  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static enum ixgbe_phy_type ixgbe_get_phy_type_from_id(u32 phy_id)
{
  #line 362 
  enum ixgbe_phy_type phy_type;
  #line 364 
  switch (phy_id) {
    #line 365 
    case (u32)10589200: 
                        #line 365 
    ;
    #line 366 
    phy_type = ixgbe_phy_tn;
    #line 367 
    break;
    #line 368 
    case (u32)22282787: 
                        #line 368 
    ;
    #line 369 
    case (u32)22282785: 
                        #line 369 
    ;
    #line 370 
    case (u32)22282752: 
                        #line 370 
    ;
    #line 371 
    phy_type = ixgbe_phy_aq;
    #line 372 
    break;
    #line 373 
    case (u32)4432896: 
                       #line 373 
    ;
    #line 374 
    phy_type = ixgbe_phy_qt;
    #line 375 
    break;
    #line 376 
    case (u32)54693968: 
                        #line 376 
    ;
    #line 377 
    phy_type = ixgbe_phy_nl;
    #line 378 
    break;
    #line 379 
    case (u32)22282816: 
                        #line 379 
    ;
    #line 380 
    case (u32)22282832: 
                        #line 380 
    ;
    #line 381 
    phy_type = ixgbe_phy_x550em_ext_t;
    #line 382 
    break;
    #line 383 
    default: 
             #line 383 
    ;
    #line 384 
    phy_type = ixgbe_phy_unknown;
    #line 385 
    break;
  }
  #line 388 
  return phy_type;
}

#line 395  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_reset_phy_generic(struct ixgbe_hw *hw)
{
  #line 397 
  u32 i;
  #line 398 
  u16 ctrl = (unsigned short)0U;
  #line 399 
  s32 status = 0;
  #line 401 
  if (hw->phy.type == (unsigned int)ixgbe_phy_unknown) 
                                                       #line 402 
                                                       status = ixgbe_identify_phy_generic(hw);
  #line 404 
  if (status != 0 || hw->phy.type == (unsigned int)ixgbe_phy_none) 
                                                                   #line 405 
                                                                   return status;
  #line 408 
  if (! hw->phy.reset_if_overtemp) {
    #line 408 
    if ((*(hw->phy.ops.check_overtemp))(hw) == -26) 
                                                    #line 410 
                                                    return 0;
  }
  #line 413 
  if ((int)ixgbe_check_reset_blocked(hw) != 0) 
                                               #line 414 
                                               return 0;
  #line 420 
  (*(hw->phy.ops.write_reg))(hw,0U,4U,(unsigned short)32768);
  #line 429 
  i = 0U;
  #line 429 
  while (i <= 29U) {
    #line 430 
    msleep(100U);
    #line 431 
    if (hw->phy.type == (unsigned int)ixgbe_phy_x550em_ext_t) {
      #line 432 
      status = (*(hw->phy.ops.read_reg))(hw,52226U,1U,& ctrl);
      #line 435 
      if (status != 0) 
                       #line 436 
                       return status;
      #line 438 
      if (((int)ctrl & 3) != 0) {
        #line 439 
        __const_udelay(8590UL);
        #line 440 
        break;
      }
    }
    else {
      #line 443 
      status = (*(hw->phy.ops.read_reg))(hw,0U,4U,& ctrl);
      #line 445 
      if (status != 0) 
                       #line 446 
                       return status;
      #line 448 
      if (((int)ctrl & 32768) == 0) {
        #line 449 
        __const_udelay(8590UL);
        #line 450 
        break;
      }
    }
    #line 429 
    i ++;
  }
  #line 455 
  if (((int)ctrl & 32768) != 0) {
    {
      #line 456 
      bool branch;
      #line 456 
      struct _ddebug __UNIQUE_ID_ddebug448 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_reset_phy_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"PHY reset polling failed to complete.\n", .lineno = (unsigned int)456U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 456 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug448.key.dd_key_false.key,(_Bool)0);
      #line 456 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 456 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug448,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"PHY reset polling failed to complete.\n");
    }
    #line 457 
    return -15;
  }
  #line 460 
  return 0;
}

#line 471  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_read_phy_reg_mdi(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type, u16 *phy_data)
{
  #line 474 
  u32 i;
  #line 474 
  u32 data;
  #line 474 
  u32 command;
  #line 477 
  command = (((device_type << 16) | reg_addr) | (unsigned int)(hw->phy.mdio.prtad << 21)) | 1073741824U;
  #line 482 
  ixgbe_write_reg_9(hw,16988U,command);
  #line 488 
  i = 0U;
  #line 488 
  while (i <= 99U) {
    #line 489 
    __const_udelay(42950UL);
    #line 491 
    command = ixgbe_read_reg(hw,16988U);
    #line 492 
    if ((command & 1073741824U) == 0U) 
                                       #line 493 
                                       break;
    #line 488 
    i ++;
  }
  #line 497 
  if ((command & 1073741824U) != 0U) {
    {
      #line 498 
      bool branch;
      #line 498 
      struct _ddebug __UNIQUE_ID_ddebug449 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_read_phy_reg_mdi", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"PHY address command did not complete.\n", .lineno = (unsigned int)498U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 498 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug449.key.dd_key_false.key,(_Bool)0);
      #line 498 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 498 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug449,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"PHY address command did not complete.\n");
    }
    #line 499 
    return -3;
  }
  #line 505 
  command = (((device_type << 16) | reg_addr) | (unsigned int)(hw->phy.mdio.prtad << 21)) | 1275068416U;
  #line 510 
  ixgbe_write_reg_9(hw,16988U,command);
  #line 516 
  i = 0U;
  #line 516 
  while (i <= 99U) {
    #line 517 
    __const_udelay(42950UL);
    #line 519 
    command = ixgbe_read_reg(hw,16988U);
    #line 520 
    if ((command & 1073741824U) == 0U) 
                                       #line 521 
                                       break;
    #line 516 
    i ++;
  }
  #line 524 
  if ((command & 1073741824U) != 0U) {
    {
      #line 525 
      bool branch_0;
      #line 525 
      struct _ddebug __UNIQUE_ID_ddebug450 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_read_phy_reg_mdi", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"PHY read command didn\'t complete\n", .lineno = (unsigned int)525U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 525 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug450.key.dd_key_false.key,(_Bool)0);
      #line 525 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 525 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug450,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"PHY read command didn\'t complete\n");
    }
    #line 526 
    return -3;
  }
  #line 532 
  data = ixgbe_read_reg(hw,16992U);
  #line 533 
  data >>= 16;
  #line 534 
  *phy_data = (unsigned short)data;
  #line 536 
  return 0;
}

#line 547  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_read_phy_reg_generic(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type, u16 *phy_data)
{
  #line 550 
  s32 status;
  #line 551 
  u32 gssr = hw->phy.phy_semaphore_mask;
  #line 553 
  if ((*(hw->mac.ops.acquire_swfw_sync))(hw,gssr) == 0) {
    #line 554 
    status = ixgbe_read_phy_reg_mdi(hw,reg_addr,device_type,phy_data);
    #line 556 
    (*(hw->mac.ops.release_swfw_sync))(hw,gssr);
  }
  else 
       #line 558 
       return -16;
  #line 561 
  return status;
}

#line 572  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_write_phy_reg_mdi(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type, u16 phy_data)
{
  #line 575 
  u32 i;
  #line 575 
  u32 command;
  #line 578 
  ixgbe_write_reg_9(hw,16992U,(unsigned int)phy_data);
  #line 581 
  command = (((device_type << 16) | reg_addr) | (unsigned int)(hw->phy.mdio.prtad << 21)) | 1073741824U;
  #line 586 
  ixgbe_write_reg_9(hw,16988U,command);
  #line 593 
  i = 0U;
  #line 593 
  while (i <= 99U) {
    #line 594 
    __const_udelay(42950UL);
    #line 596 
    command = ixgbe_read_reg(hw,16988U);
    #line 597 
    if ((command & 1073741824U) == 0U) 
                                       #line 598 
                                       break;
    #line 593 
    i ++;
  }
  #line 601 
  if ((command & 1073741824U) != 0U) {
    {
      #line 602 
      bool branch;
      #line 602 
      struct _ddebug __UNIQUE_ID_ddebug451 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_write_phy_reg_mdi", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"PHY address cmd didn\'t complete\n", .lineno = (unsigned int)602U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 602 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug451.key.dd_key_false.key,(_Bool)0);
      #line 602 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 602 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug451,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"PHY address cmd didn\'t complete\n");
    }
    #line 603 
    return -3;
  }
  #line 610 
  command = (((device_type << 16) | reg_addr) | (unsigned int)(hw->phy.mdio.prtad << 21)) | 1140850688U;
  #line 615 
  ixgbe_write_reg_9(hw,16988U,command);
  #line 621 
  i = 0U;
  #line 621 
  while (i <= 99U) {
    #line 622 
    __const_udelay(42950UL);
    #line 624 
    command = ixgbe_read_reg(hw,16988U);
    #line 625 
    if ((command & 1073741824U) == 0U) 
                                       #line 626 
                                       break;
    #line 621 
    i ++;
  }
  #line 629 
  if ((command & 1073741824U) != 0U) {
    {
      #line 630 
      bool branch_0;
      #line 630 
      struct _ddebug __UNIQUE_ID_ddebug452 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_write_phy_reg_mdi", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"PHY write cmd didn\'t complete\n", .lineno = (unsigned int)630U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 630 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug452.key.dd_key_false.key,(_Bool)0);
      #line 630 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 630 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug452,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"PHY write cmd didn\'t complete\n");
    }
    #line 631 
    return -3;
  }
  #line 634 
  return 0;
}

#line 645  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_write_phy_reg_generic(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type, u16 phy_data)
{
  #line 648 
  s32 status;
  #line 649 
  u32 gssr = hw->phy.phy_semaphore_mask;
  #line 651 
  if ((*(hw->mac.ops.acquire_swfw_sync))(hw,gssr) == 0) {
    #line 652 
    status = ixgbe_write_phy_reg_mdi(hw,reg_addr,device_type,(unsigned short)((int)phy_data));
    #line 654 
    (*(hw->mac.ops.release_swfw_sync))(hw,gssr);
  }
  else 
       #line 656 
       return -16;
  #line 659 
  return status;
}

#line 669  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_msca_cmd(struct ixgbe_hw *hw, u32 cmd)
{
  #line 673 
  int tmp_3;
  #line 671 
  ixgbe_write_reg_9(hw,16988U,cmd);
  {
    #line 673 
    u64 __timeout_us = 1000ULL;
    #line 673 
    unsigned long __sleep_us = 10UL;
    #line 673 
    ;
    #line 673 
    ktime_t __timeout = ktime_add_us(ktime_get(),__timeout_us);
    #line 673 
    if (__sleep_us != 0UL) 
                           #line 673 
                           __might_sleep((char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c",673,0);
    #line 673 
    while (1) {
      #line 673 
      cmd = ixgbe_read_reg(hw,16988U);
      #line 673 
      if ((cmd & 1073741824U) == 0U) 
                                     #line 673 
                                     break;
      #line 673 
      if (__timeout_us != 0ULL) {
        #line 673 
        ;
        #line 673 
        if (ktime_compare(ktime_get(),__timeout) > 0) {
          #line 673 
          cmd = ixgbe_read_reg(hw,16988U);
          #line 673 
          break;
        }
      }
      #line 673 
      if (__sleep_us != 0UL) 
                             #line 673 
                             usleep_range((__sleep_us >> 2) + 1UL,__sleep_us);
    }
    #line 673 
    if ((cmd & 1073741824U) == 0U) 
                                   #line 673 
                                   tmp_3 = 0; else 
                                                   #line 673 
                                                   tmp_3 = -110;
    }
  #line 673 
  return tmp_3;
}

#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_mii_bus_read_generic(struct ixgbe_hw *hw, int addr, int regnum, u32 gssr)
{
  #line 688 
  u32 hwaddr;
  #line 688 
  u32 cmd;
  #line 689 
  s32 data;
  #line 691 
  if ((*(hw->mac.ops.acquire_swfw_sync))(hw,gssr) != 0) 
                                                        #line 692 
                                                        return -16;
  #line 694 
  hwaddr = (unsigned int)(addr << 21);
  #line 695 
  if ((regnum & 1073741824) != 0) {
    #line 696 
    hwaddr = ((unsigned int)regnum & 4194303U) | hwaddr;
    #line 697 
    cmd = hwaddr | 1073741824U;
  }
  else {
    #line 699 
    hwaddr = (((unsigned int)regnum << 16U) & 4128768U) | hwaddr;
    #line 700 
    cmd = hwaddr | 1476395008U;
  }
  #line 704 
  data = ixgbe_msca_cmd(hw,cmd);
  #line 705 
  if (data < 0) 
                #line 706 
                goto mii_bus_read_done;
  #line 711 
  if ((regnum & 1073741824) == 0) 
                                  #line 712 
                                  goto do_mii_bus_read;
  #line 714 
  cmd = hwaddr | 1275068416U;
  #line 715 
  data = ixgbe_msca_cmd(hw,cmd);
  #line 716 
  if (data < 0) 
                #line 717 
                goto mii_bus_read_done;
  #line 719 
  do_mii_bus_read: 
                   #line 719 
  ;
  #line 720 
  data = (int)ixgbe_read_reg(hw,16992U);
  #line 721 
  data = (data >> 16) & 131071;
  #line 723 
  mii_bus_read_done: 
                     #line 723 
  ;
  #line 724 
  (*(hw->mac.ops.release_swfw_sync))(hw,gssr);
  #line 725 
  return data;
}

#line 736  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_mii_bus_write_generic(struct ixgbe_hw *hw, int addr, int regnum, u16 val, u32 gssr)
{
  #line 739 
  u32 hwaddr;
  #line 739 
  u32 cmd;
  #line 740 
  s32 err;
  #line 742 
  if ((*(hw->mac.ops.acquire_swfw_sync))(hw,gssr) != 0) 
                                                        #line 743 
                                                        return -16;
  #line 745 
  ixgbe_write_reg_9(hw,16992U,(unsigned int)val);
  #line 747 
  hwaddr = (unsigned int)(addr << 21);
  #line 748 
  if ((regnum & 1073741824) != 0) {
    #line 749 
    hwaddr = ((unsigned int)regnum & 4194303U) | hwaddr;
    #line 750 
    cmd = hwaddr | 1073741824U;
  }
  else {
    #line 752 
    hwaddr = (((unsigned int)regnum << 16U) & 4128768U) | hwaddr;
    #line 753 
    cmd = hwaddr | 1409286144U;
  }
  #line 760 
  err = ixgbe_msca_cmd(hw,cmd);
  #line 761 
  if (err < 0 || (regnum & 1073741824) == 0) 
                                             #line 762 
                                             goto mii_bus_write_done;
  #line 764 
  cmd = hwaddr | 1140850688U;
  #line 765 
  err = ixgbe_msca_cmd(hw,cmd);
  #line 767 
  mii_bus_write_done: 
                      #line 767 
  ;
  #line 768 
  (*(hw->mac.ops.release_swfw_sync))(hw,gssr);
  #line 769 
  return err;
}

#line 778  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_mii_bus_read(struct mii_bus *bus, int addr, int regnum)
{
  #line 780 
  struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)bus->priv;
  #line 781 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 782 
  u32 gssr = hw->phy.phy_semaphore_mask;
  #line 784 
  return ixgbe_mii_bus_read_generic(hw,addr,regnum,gssr);
}

#line 794  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_mii_bus_write(struct mii_bus *bus, int addr, int regnum, u16 val)
{
  #line 797 
  struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)bus->priv;
  #line 798 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 799 
  u32 gssr = hw->phy.phy_semaphore_mask;
  #line 801 
  return ixgbe_mii_bus_write_generic(hw,addr,regnum,(unsigned short)((int)val),
                                  gssr);
}

#line 810  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_x550em_a_mii_bus_read(struct mii_bus *bus, int addr, int regnum)
{
  #line 813 
  struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)bus->priv;
  #line 814 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 815 
  u32 gssr = hw->phy.phy_semaphore_mask;
  #line 817 
  gssr |= 1073741826U;
  #line 818 
  return ixgbe_mii_bus_read_generic(hw,addr,regnum,gssr);
}

#line 828  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_x550em_a_mii_bus_write(struct mii_bus *bus, int addr, int regnum, u16 val)
{
  #line 831 
  struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)bus->priv;
  #line 832 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 833 
  u32 gssr = hw->phy.phy_semaphore_mask;
  #line 835 
  gssr |= 1073741826U;
  #line 836 
  return ixgbe_mii_bus_write_generic(hw,addr,regnum,(unsigned short)((int)val),
                                  gssr);
}

#line 846  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static struct pci_dev *ixgbe_get_first_secondary_devfn(unsigned int devfn)
{
  #line 848 
  struct pci_dev *rp_pdev;
  #line 849 
  int bus;
  #line 851 
  rp_pdev = pci_get_domain_bus_and_slot(0,0U,devfn);
  #line 852 
  if (rp_pdev != (struct pci_dev *)0 && rp_pdev->subordinate != (struct pci_bus *)0) {
    #line 853 
    bus = (int)(rp_pdev->subordinate)->number;
    #line 854 
    return pci_get_domain_bus_and_slot(0,(unsigned int)bus,0U);
  }
  #line 857 
  return (struct pci_dev *)0;
}

#line 868  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static bool ixgbe_x550em_a_has_mii(struct ixgbe_hw *hw)
{
  #line 872 
  struct pci_dev *func0_pdev;
  #line 870 
  struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)hw->back;
  #line 871 
  struct pci_dev *pdev = adapter->pdev;
  #line 880 
  func0_pdev = ixgbe_get_first_secondary_devfn(176U);
  #line 881 
  if (func0_pdev != (struct pci_dev *)0) 
    #line 882 
    if (func0_pdev == pdev) 
                            #line 883 
                            return (_Bool)1; else 
                                                  #line 885 
                                                  return (_Bool)0;
  #line 887 
  func0_pdev = ixgbe_get_first_secondary_devfn(184U);
  #line 888 
  if (func0_pdev == pdev) 
                          #line 889 
                          return (_Bool)1;
  #line 891 
  return (_Bool)0;
}

#line 902  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_mii_bus_init(struct ixgbe_hw *hw)
{
  #line 907 
  struct mii_bus *bus;
  #line 904 
  struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)hw->back;
  #line 905 
  struct pci_dev *pdev = adapter->pdev;
  #line 906 
  struct device *dev = & (adapter->netdev)->dev;
  #line 908 
  int err = -19;
  #line 910 
  bus = devm_mdiobus_alloc(dev);
  #line 911 
  if (bus == (struct mii_bus *)0) 
                                  #line 912 
                                  return -12;
  #line 914 
  switch ((int)hw->device_id) {
    #line 916 
    case 5570: 
               #line 916 
    ;
    #line 917 
    case 5571: 
               #line 917 
    ;
    #line 918 
    case 5572: 
               #line 918 
    ;
    #line 919 
    case 5574: 
               #line 919 
    ;
    #line 920 
    case 5575: 
               #line 920 
    ;
    #line 921 
    case 5576: 
               #line 921 
    ;
    #line 922 
    case 5582: 
               #line 922 
    ;
    #line 923 
    case 5604: 
               #line 923 
    ;
    #line 924 
    case 5605: 
               #line 924 
    ;
    #line 925 
    if (! ixgbe_x550em_a_has_mii(hw)) 
                                      #line 926 
                                      goto ixgbe_no_mii_bus;
    #line 927 
    bus->read = & ixgbe_x550em_a_mii_bus_read;
    #line 928 
    bus->write = & ixgbe_x550em_a_mii_bus_write;
    #line 929 
    break;
    #line 930 
    default: 
             #line 930 
    ;
    #line 931 
    bus->read = & ixgbe_mii_bus_read;
    #line 932 
    bus->write = & ixgbe_mii_bus_write;
    #line 933 
    break;
  }
  #line 937 
  ;
  #line 937 
  snprintf((char *)(& bus->id),61UL,(char *)"%s-mdio-%s",(char *)(& ixgbe_driver_name),pci_name(pdev));
  #line 940 
  bus->name = (char *)"ixgbe-mdio";
  #line 941 
  bus->priv = (void *)adapter;
  #line 942 
  bus->parent = dev;
  #line 943 
  bus->phy_mask = 4294967295U;
  #line 949 
  hw->phy.mdio.mode_support = 3U;
  #line 951 
  err = __mdiobus_register(bus,& __this_module);
  #line 952 
  if (err == 0) {
    #line 953 
    adapter->mii_bus = bus;
    #line 954 
    return 0;
  }
  #line 957 
  ixgbe_no_mii_bus: 
                    #line 957 
  ;
  #line 958 
  devm_mdiobus_free(dev,bus);
  #line 959 
  return err;
}

#line 968  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_setup_phy_link_generic(struct ixgbe_hw *hw)
{
  #line 973 
  ixgbe_link_speed speed;
  #line 970 
  s32 status = 0;
  #line 971 
  u16 autoneg_reg = (unsigned short)0U;
  #line 972 
  bool autoneg = (_Bool)0;
  #line 975 
  ixgbe_get_copper_link_capabilities_generic(hw,& speed,& autoneg);
  #line 978 
  (*(hw->phy.ops.read_reg))(hw,32U,7U,& autoneg_reg);
  #line 980 
  autoneg_reg = (unsigned short)((unsigned int)autoneg_reg & 61439U);
  #line 981 
  if ((hw->phy.autoneg_advertised & 128U) != 0U && (speed & 128U) != 0U) 
    #line 983 
    autoneg_reg = (unsigned short)((unsigned int)autoneg_reg | 4096U);
  #line 985 
  (*(hw->phy.ops.write_reg))(hw,32U,7U,(unsigned short)((int)autoneg_reg));
  #line 987 
  (*(hw->phy.ops.read_reg))(hw,50176U,7U,& autoneg_reg);
  #line 990 
  if (hw->mac.type == (unsigned int)ixgbe_mac_X550) {
    #line 992 
    autoneg_reg = (unsigned short)((unsigned int)autoneg_reg & 63487U);
    #line 993 
    if ((hw->phy.autoneg_advertised & 2048U) != 0U && (speed & 2048U) != 0U) 
      #line 995 
      autoneg_reg = (unsigned short)((unsigned int)autoneg_reg | 2048U);
    #line 998 
    autoneg_reg = (unsigned short)((unsigned int)autoneg_reg & 64511U);
    #line 999 
    if ((hw->phy.autoneg_advertised & 1024U) != 0U && (speed & 1024U) != 0U) 
      #line 1002 
      autoneg_reg = (unsigned short)((unsigned int)autoneg_reg | 1024U);
  }
  #line 1006 
  autoneg_reg = (unsigned short)((unsigned int)autoneg_reg & 32767U);
  #line 1007 
  if ((hw->phy.autoneg_advertised & 32U) != 0U && (speed & 32U) != 0U) 
    #line 1009 
    autoneg_reg = (unsigned short)((unsigned int)autoneg_reg | 32768U);
  #line 1011 
  (*(hw->phy.ops.write_reg))(hw,50176U,7U,(unsigned short)((int)autoneg_reg));
  #line 1015 
  (*(hw->phy.ops.read_reg))(hw,16U,7U,& autoneg_reg);
  #line 1017 
  autoneg_reg = (unsigned short)((unsigned int)autoneg_reg & 65151U);
  #line 1018 
  if ((hw->phy.autoneg_advertised & 8U) != 0U && (speed & 8U) != 0U) 
    #line 1020 
    autoneg_reg = (unsigned short)((unsigned int)autoneg_reg | 256U);
  #line 1022 
  (*(hw->phy.ops.write_reg))(hw,16U,7U,(unsigned short)((int)autoneg_reg));
  #line 1025 
  if ((int)ixgbe_check_reset_blocked(hw) != 0) 
                                               #line 1026 
                                               return 0;
  #line 1029 
  (*(hw->phy.ops.read_reg))(hw,0U,7U,& autoneg_reg);
  #line 1032 
  autoneg_reg = (unsigned short)((unsigned int)autoneg_reg | 512U);
  #line 1034 
  (*(hw->phy.ops.write_reg))(hw,0U,7U,(unsigned short)((int)autoneg_reg));
  #line 1037 
  return status;
}

#line 1046  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_setup_phy_link_speed_generic(struct ixgbe_hw *hw, ixgbe_link_speed speed, bool autoneg_wait_to_complete)
{
  #line 1053 
  hw->phy.autoneg_advertised = 0U;
  #line 1055 
  if ((speed & 128U) != 0U) 
                            #line 1056 
                            hw->phy.autoneg_advertised |= 128U;
  #line 1058 
  if ((speed & 2048U) != 0U) 
                             #line 1059 
                             hw->phy.autoneg_advertised |= 2048U;
  #line 1061 
  if ((speed & 1024U) != 0U) 
                             #line 1062 
                             hw->phy.autoneg_advertised |= 1024U;
  #line 1064 
  if ((speed & 32U) != 0U) 
                           #line 1065 
                           hw->phy.autoneg_advertised |= 32U;
  #line 1067 
  if ((speed & 8U) != 0U) 
                          #line 1068 
                          hw->phy.autoneg_advertised |= 8U;
  #line 1070 
  if ((speed & 2U) != 0U) 
                          #line 1071 
                          hw->phy.autoneg_advertised |= 2U;
  #line 1074 
  if (hw->phy.ops.setup_link != (s32 (*)(struct ixgbe_hw *))0) 
                                                               #line 1075 
                                                               (*(hw->phy.ops.setup_link))(hw);
  #line 1077 
  return 0;
}

#line 1087  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_get_copper_speeds_supported(struct ixgbe_hw *hw)
{
  #line 1089 
  u16 speed_ability;
  #line 1090 
  s32 status;
  #line 1092 
  status = (*(hw->phy.ops.read_reg))(hw,4U,1U,& speed_ability);
  #line 1094 
  if (status != 0) 
                   #line 1095 
                   return status;
  #line 1097 
  if (((int)speed_ability & 1) != 0) 
                                     #line 1098 
                                     hw->phy.speeds_supported |= 128U;
  #line 1099 
  if (((int)speed_ability & 16) != 0) 
                                      #line 1100 
                                      hw->phy.speeds_supported |= 32U;
  #line 1101 
  if (((int)speed_ability & 32) != 0) 
                                      #line 1102 
                                      hw->phy.speeds_supported |= 8U;
  #line 1104 
  switch ((unsigned int)hw->mac.type) {
    #line 1105 
    case (unsigned int)4: 
                          #line 1105 
    ;
    #line 1106 
    hw->phy.speeds_supported |= 1024U;
    #line 1107 
    hw->phy.speeds_supported |= 2048U;
    #line 1108 
    break;
    #line 1109 
    case (unsigned int)5: 
                          #line 1109 
    ;
    #line 1110 
    case (unsigned int)6: 
                          #line 1110 
    ;
    #line 1111 
    hw->phy.speeds_supported &= 4294967287U;
    #line 1112 
    break;
    #line 1113 
    default: 
             #line 1113 
    ;
    #line 1114 
    break;
  }
  #line 1117 
  return 0;
}

#line 1126  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_get_copper_link_capabilities_generic(struct ixgbe_hw *hw, ixgbe_link_speed *speed, bool *autoneg)
{
  #line 1130 
  s32 status = 0;
  #line 1132 
  *autoneg = (_Bool)1;
  #line 1133 
  if (hw->phy.speeds_supported == 0U) 
                                      #line 1134 
                                      status = ixgbe_get_copper_speeds_supported(hw);
  #line 1136 
  *speed = hw->phy.speeds_supported;
  #line 1137 
  return status;
}

#line 1149  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_check_phy_link_tnx(struct ixgbe_hw *hw, ixgbe_link_speed *speed, bool *link_up)
{
  #line 1152 
  s32 status;
  #line 1153 
  u32 time_out;
  #line 1154 
  u32 max_time_out = 10U;
  #line 1155 
  u16 phy_link = (unsigned short)0U;
  #line 1156 
  u16 phy_speed = (unsigned short)0U;
  #line 1157 
  u16 phy_data = (unsigned short)0U;
  #line 1160 
  *link_up = (_Bool)0;
  #line 1161 
  *speed = 128U;
  #line 1168 
  time_out = 0U;
  #line 1168 
  while (time_out < max_time_out) {
    #line 1169 
    __const_udelay(42950UL);
    #line 1170 
    status = (*(hw->phy.ops.read_reg))(hw,1U,30U,& phy_data);
    #line 1174 
    phy_link = (unsigned short)((unsigned int)phy_data & 8U);
    #line 1176 
    phy_speed = (unsigned short)((unsigned int)phy_data & 16U);
    #line 1178 
    if ((unsigned int)phy_link == 8U) {
      #line 1179 
      *link_up = (_Bool)1;
      #line 1180 
      if ((unsigned int)phy_speed == 16U) 
                                          #line 1182 
                                          *speed = 32U;
      #line 1183 
      break;
    }
    #line 1168 
    time_out ++;
  }
  #line 1187 
  return status;
}

#line 1199  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_setup_phy_link_tnx(struct ixgbe_hw *hw)
{
  #line 1203 
  ixgbe_link_speed speed;
  #line 1201 
  u16 autoneg_reg = (unsigned short)0U;
  #line 1202 
  bool autoneg = (_Bool)0;
  #line 1205 
  ixgbe_get_copper_link_capabilities_generic(hw,& speed,& autoneg);
  #line 1207 
  if ((speed & 128U) != 0U) {
    #line 1209 
    (*(hw->phy.ops.read_reg))(hw,32U,7U,& autoneg_reg);
    #line 1213 
    autoneg_reg = (unsigned short)((unsigned int)autoneg_reg & 61439U);
    #line 1214 
    if ((hw->phy.autoneg_advertised & 128U) != 0U) 
                                                   #line 1215 
                                                   autoneg_reg = (unsigned short)((unsigned int)autoneg_reg | 4096U);
    #line 1217 
    (*(hw->phy.ops.write_reg))(hw,32U,7U,(unsigned short)((int)autoneg_reg));
  }
  #line 1222 
  if ((speed & 32U) != 0U) {
    #line 1224 
    (*(hw->phy.ops.read_reg))(hw,23U,7U,& autoneg_reg);
    #line 1228 
    autoneg_reg = (unsigned short)((unsigned int)autoneg_reg & 49151U);
    #line 1229 
    if ((hw->phy.autoneg_advertised & 32U) != 0U) 
                                                  #line 1230 
                                                  autoneg_reg = (unsigned short)((unsigned int)autoneg_reg | 16384U);
    #line 1232 
    (*(hw->phy.ops.write_reg))(hw,23U,7U,(unsigned short)((int)autoneg_reg));
  }
  #line 1237 
  if ((speed & 8U) != 0U) {
    #line 1239 
    (*(hw->phy.ops.read_reg))(hw,16U,7U,& autoneg_reg);
    #line 1243 
    autoneg_reg = (unsigned short)((unsigned int)autoneg_reg & 65151U);
    #line 1245 
    if ((hw->phy.autoneg_advertised & 8U) != 0U) 
                                                 #line 1246 
                                                 autoneg_reg = (unsigned short)((unsigned int)autoneg_reg | 256U);
    #line 1248 
    (*(hw->phy.ops.write_reg))(hw,16U,7U,(unsigned short)((int)autoneg_reg));
  }
  #line 1254 
  if ((int)ixgbe_check_reset_blocked(hw) != 0) 
                                               #line 1255 
                                               return 0;
  #line 1258 
  (*(hw->phy.ops.read_reg))(hw,0U,7U,& autoneg_reg);
  #line 1261 
  autoneg_reg = (unsigned short)((unsigned int)autoneg_reg | 512U);
  #line 1263 
  (*(hw->phy.ops.write_reg))(hw,0U,7U,(unsigned short)((int)autoneg_reg));
  #line 1265 
  return 0;
}

#line 1272  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_reset_phy_nl(struct ixgbe_hw *hw)
{
  #line 1274 
  u16 phy_offset;
  #line 1274 
  u16 control;
  #line 1274 
  u16 eword;
  #line 1274 
  u16 edata;
  #line 1274 
  u16 block_crc;
  #line 1276 
  u16 list_offset;
  #line 1276 
  u16 data_offset;
  #line 1278 
  s32 ret_val;
  #line 1279 
  u32 i;
  #line 1275 
  bool end_data = (_Bool)0;
  #line 1277 
  u16 phy_data = (unsigned short)0U;
  #line 1282 
  if ((int)ixgbe_check_reset_blocked(hw) != 0) 
                                               #line 1283 
                                               return 0;
  #line 1285 
  (*(hw->phy.ops.read_reg))(hw,0U,4U,& phy_data);
  #line 1288 
  (*(hw->phy.ops.write_reg))(hw,0U,4U,(unsigned short)((int)((unsigned int)phy_data | 32768U)));
  #line 1291 
  i = 0U;
  #line 1291 
  while (i <= 99U) {
    #line 1292 
    (*(hw->phy.ops.read_reg))(hw,0U,4U,& phy_data);
    #line 1294 
    if (((int)phy_data & 32768) == 0) 
                                      #line 1295 
                                      break;
    #line 1296 
    usleep_range(10000UL,20000UL);
    #line 1291 
    i ++;
  }
  #line 1299 
  if (((int)phy_data & 32768) != 0) {
    {
      #line 1300 
      bool branch;
      #line 1300 
      struct _ddebug __UNIQUE_ID_ddebug453 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_reset_phy_nl", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"PHY reset did not complete.\n", .lineno = (unsigned int)1300U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1300 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug453.key.dd_key_false.key,(_Bool)0);
      #line 1300 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 1300 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug453,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"PHY reset did not complete.\n");
    }
    #line 1301 
    return -3;
  }
  #line 1305 
  ret_val = ixgbe_get_sfp_init_sequence_offsets(hw,& list_offset,& data_offset);
  #line 1307 
  if (ret_val != 0) 
                    #line 1308 
                    return ret_val;
  #line 1310 
  ret_val = (*(hw->eeprom.ops.read))(hw,(unsigned short)((int)data_offset),& block_crc);
  #line 1311 
  data_offset = (u16)((int)data_offset + 1);
  #line 1312 
  while (! end_data) {
    #line 1316 
    ret_val = (*(hw->eeprom.ops.read))(hw,(unsigned short)((int)data_offset),& eword);
    #line 1317 
    if (ret_val != 0) 
                      #line 1318 
                      goto err_eeprom;
    #line 1319 
    control = (unsigned short)((int)eword >> 12);
    #line 1321 
    edata = (unsigned short)((unsigned int)eword & 4095U);
    #line 1322 
    switch ((int)control) {
      #line 1331 
      u16 tmp_3;
      #line 1323 
      case 0: 
              #line 1323 
      ;
      #line 1324 
      data_offset = (u16)((int)data_offset + 1);
      {
        #line 1325 
        bool branch_0;
        #line 1325 
        struct _ddebug __UNIQUE_ID_ddebug454 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_reset_phy_nl", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"DELAY: %d MS\n", .lineno = (unsigned int)1325U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 1325 
        branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug454.key.dd_key_false.key,(_Bool)0);
        #line 1325 
        if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                      #line 1325 
                                                      __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug454,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"DELAY: %d MS\n",(int)edata);
      }
      #line 1326 
      usleep_range((unsigned long)((int)edata * 1000),(unsigned long)((int)edata * 2000));
      #line 1327 
      break;
      #line 1328 
      case 1: 
              #line 1328 
      ;
      {
        #line 1329 
        bool branch_1;
        #line 1329 
        struct _ddebug __UNIQUE_ID_ddebug455 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_reset_phy_nl", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"DATA:\n", .lineno = (unsigned int)1329U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 1329 
        branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug455.key.dd_key_false.key,(_Bool)0);
        #line 1329 
        if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                      #line 1329 
                                                      __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug455,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"DATA:\n");
      }
      #line 1330 
      data_offset = (u16)((int)data_offset + 1);
      #line 1331 
      tmp_3 = data_offset;
      #line 1331 
      data_offset = (u16)((int)data_offset + 1);
      #line 1331 
      ;
      #line 1331 
      ;
      #line 1331 
      ret_val = (*(hw->eeprom.ops.read))(hw,(unsigned short)((int)tmp_3),& phy_offset);
      #line 1333 
      if (ret_val != 0) 
                        #line 1334 
                        goto err_eeprom;
      #line 1335 
      i = 0U;
      #line 1335 
      while ((unsigned int)edata > i) {
        #line 1336 
        ret_val = (*(hw->eeprom.ops.read))(hw,(unsigned short)((int)data_offset),& eword);
        #line 1338 
        if (ret_val != 0) 
                          #line 1339 
                          goto err_eeprom;
        #line 1340 
        (*(hw->phy.ops.write_reg))(hw,(unsigned int)phy_offset,1U,(unsigned short)((int)eword));
        {
          #line 1342 
          bool branch_2;
          #line 1342 
          struct _ddebug __UNIQUE_ID_ddebug456 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_reset_phy_nl", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"Wrote %4.4x to %4.4x\n", .lineno = (unsigned int)1342U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
          #line 1342 
          branch_2 = arch_static_branch(& __UNIQUE_ID_ddebug456.key.dd_key_false.key,(_Bool)0);
          #line 1342 
          if ((long)((long)((int)branch_2 != 0)) != 0L) 
                                                        #line 1342 
                                                        __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug456,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Wrote %4.4x to %4.4x\n",(int)eword,(int)phy_offset);
        }
        #line 1344 
        data_offset = (u16)((int)data_offset + 1);
        #line 1345 
        phy_offset = (u16)((int)phy_offset + 1);
        #line 1335 
        i ++;
      }
      #line 1347 
      break;
      #line 1348 
      case 15: 
               #line 1348 
      ;
      #line 1349 
      data_offset = (u16)((int)data_offset + 1);
      {
        #line 1350 
        bool branch_3;
        #line 1350 
        struct _ddebug __UNIQUE_ID_ddebug457 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_reset_phy_nl", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"CONTROL:\n", .lineno = (unsigned int)1350U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 1350 
        branch_3 = arch_static_branch(& __UNIQUE_ID_ddebug457.key.dd_key_false.key,(_Bool)0);
        #line 1350 
        if ((long)((long)((int)branch_3 != 0)) != 0L) 
                                                      #line 1350 
                                                      __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug457,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"CONTROL:\n");
      }
      #line 1351 
      if ((unsigned int)edata == 4095U) {
        {
          #line 1352 
          bool branch_4;
          #line 1352 
          struct _ddebug __UNIQUE_ID_ddebug458 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_reset_phy_nl", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"EOL\n", .lineno = (unsigned int)1352U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
          #line 1352 
          branch_4 = arch_static_branch(& __UNIQUE_ID_ddebug458.key.dd_key_false.key,(_Bool)0);
          #line 1352 
          if ((long)((long)((int)branch_4 != 0)) != 0L) 
                                                        #line 1352 
                                                        __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug458,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"EOL\n");
        }
        #line 1353 
        end_data = (_Bool)1;
      }
      else 
        #line 1354 
        if ((unsigned int)edata == 0U) {
          #line 1355 
          bool branch_5;
          #line 1355 
          struct _ddebug __UNIQUE_ID_ddebug459 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_reset_phy_nl", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"SOL\n", .lineno = (unsigned int)1355U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
          #line 1355 
          branch_5 = arch_static_branch(& __UNIQUE_ID_ddebug459.key.dd_key_false.key,(_Bool)0);
          #line 1355 
          if ((long)((long)((int)branch_5 != 0)) != 0L) 
                                                        #line 1355 
                                                        __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug459,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"SOL\n");
        }
        else {
          {
            #line 1357 
            bool branch_6;
            #line 1357 
            struct _ddebug __UNIQUE_ID_ddebug460 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_reset_phy_nl", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"Bad control value\n", .lineno = (unsigned int)1357U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
            #line 1357 
            branch_6 = arch_static_branch(& __UNIQUE_ID_ddebug460.key.dd_key_false.key,(_Bool)0);
            #line 1357 
            if ((long)((long)((int)branch_6 != 0)) != 0L) 
                                                          #line 1357 
                                                          __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug460,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Bad control value\n");
          }
          #line 1358 
          return -3;
        }
      #line 1360 
      break;
      #line 1361 
      default: 
               #line 1361 
      ;
      {
        #line 1362 
        bool branch_7;
        #line 1362 
        struct _ddebug __UNIQUE_ID_ddebug461 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_reset_phy_nl", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"Bad control type\n", .lineno = (unsigned int)1362U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 1362 
        branch_7 = arch_static_branch(& __UNIQUE_ID_ddebug461.key.dd_key_false.key,(_Bool)0);
        #line 1362 
        if ((long)((long)((int)branch_7 != 0)) != 0L) 
                                                      #line 1362 
                                                      __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug461,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Bad control type\n");
      }
      #line 1363 
      return -3;
    }
  }
  #line 1367 
  return ret_val;
  #line 1369 
  err_eeprom: 
              #line 1369 
  ;
  #line 1370 
  netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"eeprom read at offset %d failed\n",(int)data_offset);
  #line 1371 
  return -3;
}

#line 1380  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_identify_module_generic(struct ixgbe_hw *hw)
{
  #line 1382 
  switch ((unsigned int)(*(hw->mac.ops.get_media_type))(hw)) {
    #line 1383 
    case (unsigned int)1: 
                          #line 1383 
    ;
    #line 1384 
    return ixgbe_identify_sfp_module_generic(hw);
    #line 1385 
    case (unsigned int)2: 
                          #line 1385 
    ;
    #line 1386 
    return ixgbe_identify_qsfp_module_generic(hw);
    #line 1387 
    default: 
             #line 1387 
    ;
    #line 1388 
    hw->phy.sfp_type = ixgbe_sfp_type_not_present;
    #line 1389 
    return -20;
  }
  #line 1392 
  return -20;
}

#line 1401  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_identify_sfp_module_generic(struct ixgbe_hw *hw)
{
  #line 1404 
  s32 status;
  #line 1403 
  struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)hw->back;
  #line 1405 
  u32 vendor_oui = 0U;
  #line 1406 
  enum ixgbe_sfp_type stored_sfp_type = hw->phy.sfp_type;
  #line 1407 
  u8 identifier = (unsigned char)0U;
  #line 1408 
  u8 comp_codes_1g = (unsigned char)0U;
  #line 1409 
  u8 comp_codes_10g = (unsigned char)0U;
  #line 1410 
  u8 oui_bytes[3U] = {(unsigned char)0U, (unsigned char)0U, (unsigned char)0U};
  #line 1411 
  u8 cable_tech = (unsigned char)0U;
  #line 1412 
  u8 cable_spec = (unsigned char)0U;
  #line 1413 
  u16 enforce_sfp = (unsigned short)0U;
  #line 1415 
  if ((*(hw->mac.ops.get_media_type))(hw) != (unsigned int)ixgbe_media_type_fiber) {
    #line 1416 
    hw->phy.sfp_type = ixgbe_sfp_type_not_present;
    #line 1417 
    return -20;
  }
  #line 1421 
  (*(hw->mac.ops.set_lan_id))(hw);
  #line 1423 
  status = (*(hw->phy.ops.read_i2c_eeprom))(hw,(unsigned char)0,& identifier);
  #line 1427 
  if (status != 0) 
                   #line 1428 
                   goto err_read_i2c_eeprom;
  #line 1430 
  if ((unsigned int)identifier != 3U) {
    #line 1431 
    hw->phy.type = ixgbe_phy_sfp_unsupported;
    #line 1432 
    return -19;
  }
  #line 1434 
  status = (*(hw->phy.ops.read_i2c_eeprom))(hw,(unsigned char)6,& comp_codes_1g);
  #line 1438 
  if (status != 0) 
                   #line 1439 
                   goto err_read_i2c_eeprom;
  #line 1441 
  status = (*(hw->phy.ops.read_i2c_eeprom))(hw,(unsigned char)3,& comp_codes_10g);
  #line 1445 
  if (status != 0) 
                   #line 1446 
                   goto err_read_i2c_eeprom;
  #line 1447 
  status = (*(hw->phy.ops.read_i2c_eeprom))(hw,(unsigned char)8,& cable_tech);
  #line 1451 
  if (status != 0) 
                   #line 1452 
                   goto err_read_i2c_eeprom;
  #line 1470 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) 
    #line 1471 
    if (((int)cable_tech & 4) != 0) 
                                    #line 1472 
                                    hw->phy.sfp_type = ixgbe_sfp_type_da_cu;
    else 
      #line 1473 
      if (((int)comp_codes_10g & 16) != 0) 
                                           #line 1474 
                                           hw->phy.sfp_type = ixgbe_sfp_type_sr;
      else 
        #line 1475 
        if (((int)comp_codes_10g & 32) != 0) 
                                             #line 1476 
                                             hw->phy.sfp_type = ixgbe_sfp_type_lr; else 
                                                                    #line 1478 
                                                                    hw->phy.sfp_type = ixgbe_sfp_type_unknown;
  else 
    #line 1480 
    if (((int)cable_tech & 4) != 0) 
      #line 1481 
      if ((unsigned int)hw->bus.lan_id == 0U) 
                                              #line 1482 
                                              hw->phy.sfp_type = ixgbe_sfp_type_da_cu_core0; else 
                                                                    #line 1485 
                                                                    hw->phy.sfp_type = ixgbe_sfp_type_da_cu_core1;
    else 
      #line 1487 
      if (((int)cable_tech & 8) != 0) {
        #line 1488 
        (*(hw->phy.ops.read_i2c_eeprom))(hw,(unsigned char)60,& cable_spec);
        #line 1491 
        if (((int)cable_spec & 4) != 0) 
          #line 1493 
          if ((unsigned int)hw->bus.lan_id == 0U) 
                                                  #line 1494 
                                                  hw->phy.sfp_type = ixgbe_sfp_type_da_act_lmt_core0; else 
                                                                    #line 1497 
                                                                    hw->phy.sfp_type = ixgbe_sfp_type_da_act_lmt_core1;
        else 
             #line 1500 
             hw->phy.sfp_type = ixgbe_sfp_type_unknown;
      }
      else 
        #line 1503 
        if (((int)comp_codes_10g & 48) != 0) 
          #line 1506 
          if ((unsigned int)hw->bus.lan_id == 0U) 
                                                  #line 1507 
                                                  hw->phy.sfp_type = ixgbe_sfp_type_srlr_core0; else 
                                                                    #line 1510 
                                                                    hw->phy.sfp_type = ixgbe_sfp_type_srlr_core1;
        else 
          #line 1512 
          if (((int)comp_codes_1g & 8) != 0) 
            #line 1513 
            if ((unsigned int)hw->bus.lan_id == 0U) 
                                                    #line 1514 
                                                    hw->phy.sfp_type = ixgbe_sfp_type_1g_cu_core0; else 
                                                                    #line 1517 
                                                                    hw->phy.sfp_type = ixgbe_sfp_type_1g_cu_core1;
          else 
            #line 1519 
            if (((int)comp_codes_1g & 1) != 0) 
              #line 1520 
              if ((unsigned int)hw->bus.lan_id == 0U) 
                                                      #line 1521 
                                                      hw->phy.sfp_type = ixgbe_sfp_type_1g_sx_core0; else 
                                                                    #line 1524 
                                                                    hw->phy.sfp_type = ixgbe_sfp_type_1g_sx_core1;
            else 
              #line 1526 
              if (((int)comp_codes_1g & 2) != 0) 
                #line 1527 
                if ((unsigned int)hw->bus.lan_id == 0U) 
                                                        #line 1528 
                                                        hw->phy.sfp_type = ixgbe_sfp_type_1g_lx_core0; else 
                                                                    #line 1531 
                                                                    hw->phy.sfp_type = ixgbe_sfp_type_1g_lx_core1;
              else 
                   #line 1534 
                   hw->phy.sfp_type = ixgbe_sfp_type_unknown;
  #line 1538 
  if (hw->phy.sfp_type != stored_sfp_type) 
                                           #line 1539 
                                           hw->phy.sfp_setup_needed = (_Bool)1;
  #line 1542 
  hw->phy.multispeed_fiber = (_Bool)0;
  #line 1543 
  if (((int)comp_codes_1g & 1) != 0 && ((int)comp_codes_10g & 16) != 0 || ((int)comp_codes_1g & 2) != 0 && ((int)comp_codes_10g & 32) != 0) 
    #line 1547 
    hw->phy.multispeed_fiber = (_Bool)1;
  #line 1550 
  if (hw->phy.type != (unsigned int)ixgbe_phy_nl) {
    #line 1551 
    hw->phy.id = (unsigned int)identifier;
    #line 1552 
    status = (*(hw->phy.ops.read_i2c_eeprom))(hw,(unsigned char)37,oui_bytes);
    #line 1556 
    if (status != 0) 
                     #line 1557 
                     goto err_read_i2c_eeprom;
    #line 1559 
    status = (*(hw->phy.ops.read_i2c_eeprom))(hw,(unsigned char)38,& oui_bytes[1]);
    #line 1563 
    if (status != 0) 
                     #line 1564 
                     goto err_read_i2c_eeprom;
    #line 1566 
    status = (*(hw->phy.ops.read_i2c_eeprom))(hw,(unsigned char)39,& oui_bytes[2]);
    #line 1570 
    if (status != 0) 
                     #line 1571 
                     goto err_read_i2c_eeprom;
    #line 1573 
    vendor_oui = (unsigned int)((((int)oui_bytes[0] << 24) | ((int)oui_bytes[1] << 16)) | ((int)oui_bytes[2] << 8));
    #line 1578 
    switch (vendor_oui) {
      #line 1579 
      case (u32)4224512: 
                         #line 1579 
      ;
      #line 1580 
      if (((int)cable_tech & 4) != 0) 
                                      #line 1581 
                                      hw->phy.type = ixgbe_phy_sfp_passive_tyco;
      #line 1583 
      break;
      #line 1584 
      case (u32)9463040: 
                         #line 1584 
      ;
      #line 1585 
      if (((int)cable_tech & 8) != 0) 
                                      #line 1586 
                                      hw->phy.type = ixgbe_phy_sfp_ftl_active; else 
                                                                    #line 1588 
                                                                    hw->phy.type = ixgbe_phy_sfp_ftl;
      #line 1589 
      break;
      #line 1590 
      case (u32)1534464: 
                         #line 1590 
      ;
      #line 1591 
      hw->phy.type = ixgbe_phy_sfp_avago;
      #line 1592 
      break;
      #line 1593 
      case (u32)1777920: 
                         #line 1593 
      ;
      #line 1594 
      hw->phy.type = ixgbe_phy_sfp_intel;
      #line 1595 
      break;
      #line 1596 
      default: 
               #line 1596 
      ;
      #line 1597 
      if (((int)cable_tech & 4) != 0) 
                                      #line 1598 
                                      hw->phy.type = ixgbe_phy_sfp_passive_unknown;
      else 
        #line 1600 
        if (((int)cable_tech & 8) != 0) 
                                        #line 1601 
                                        hw->phy.type = ixgbe_phy_sfp_active_unknown; else 
                                                                    #line 1604 
                                                                    hw->phy.type = ixgbe_phy_sfp_unknown;
      #line 1605 
      break;
    }
  }
  #line 1610 
  if (((int)cable_tech & 12) != 0) 
                                   #line 1612 
                                   return 0;
  #line 1617 
  if ((((((unsigned int)hw->phy.sfp_type + 4294967287U > 1U && hw->phy.sfp_type != (unsigned int)ixgbe_sfp_type_1g_lx_core0) && hw->phy.sfp_type != (unsigned int)ixgbe_sfp_type_1g_lx_core1) && hw->phy.sfp_type != (unsigned int)ixgbe_sfp_type_1g_sx_core0) && hw->phy.sfp_type != (unsigned int)ixgbe_sfp_type_1g_sx_core1) && (unsigned int)comp_codes_10g == 0U) {
    #line 1622 
    hw->phy.type = ixgbe_phy_sfp_unsupported;
    #line 1623 
    return -19;
  }
  #line 1627 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) 
                                                       #line 1628 
                                                       return 0;
  #line 1630 
  (*(hw->mac.ops.get_device_caps))(hw,& enforce_sfp);
  #line 1633 
  if ((((((unsigned int)hw->phy.sfp_type + 4294967287U > 1U && hw->phy.sfp_type != (unsigned int)ixgbe_sfp_type_1g_lx_core0) && hw->phy.sfp_type != (unsigned int)ixgbe_sfp_type_1g_lx_core1) && hw->phy.sfp_type != (unsigned int)ixgbe_sfp_type_1g_sx_core0) && hw->phy.sfp_type != (unsigned int)ixgbe_sfp_type_1g_sx_core1) && ((int)enforce_sfp & 1) == 0) {
    #line 1639 
    if (hw->phy.type == (unsigned int)ixgbe_phy_sfp_intel) 
                                                           #line 1640 
                                                           return 0;
    #line 1641 
    if ((int)hw->allow_unsupported_sfp != 0) {
      #line 1642 
      if (((int)adapter->msg_enable & 1) != 0) 
                                               #line 1642 
                                               netdev_warn(adapter->netdev,(char *)"WARNING: Intel (R) Network Connections are quality tested using Intel (R) Ethernet Optics.  Using untested modules is not supported and may cause unstable operation or damage to the module or the adapter.  Intel Corporation is not responsible for any harm caused by using untested modules.\n");
      #line 1643 
      return 0;
    }
    {
      #line 1645 
      bool branch;
      #line 1645 
      struct _ddebug __UNIQUE_ID_ddebug462 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_identify_sfp_module_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"SFP+ module not supported\n", .lineno = (unsigned int)1645U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1645 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug462.key.dd_key_false.key,(_Bool)0);
      #line 1645 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 1645 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug462,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"SFP+ module not supported\n");
    }
    #line 1646 
    hw->phy.type = ixgbe_phy_sfp_unsupported;
    #line 1647 
    return -19;
  }
  #line 1649 
  return 0;
  #line 1651 
  err_read_i2c_eeprom: 
                       #line 1651 
  ;
  #line 1652 
  hw->phy.sfp_type = ixgbe_sfp_type_not_present;
  #line 1653 
  if (hw->phy.type != (unsigned int)ixgbe_phy_nl) {
    #line 1654 
    hw->phy.id = 0U;
    #line 1655 
    hw->phy.type = ixgbe_phy_unknown;
  }
  #line 1657 
  return -20;
}

#line 1666  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw)
{
  #line 1669 
  s32 status;
  #line 1668 
  struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)hw->back;
  #line 1670 
  u32 vendor_oui = 0U;
  #line 1671 
  enum ixgbe_sfp_type stored_sfp_type = hw->phy.sfp_type;
  #line 1672 
  u8 identifier = (unsigned char)0U;
  #line 1673 
  u8 comp_codes_1g = (unsigned char)0U;
  #line 1674 
  u8 comp_codes_10g = (unsigned char)0U;
  #line 1675 
  u8 oui_bytes[3U] = {(unsigned char)0U, (unsigned char)0U, (unsigned char)0U};
  #line 1676 
  u16 enforce_sfp = (unsigned short)0U;
  #line 1677 
  u8 connector = (unsigned char)0U;
  #line 1678 
  u8 cable_length = (unsigned char)0U;
  #line 1679 
  u8 device_tech = (unsigned char)0U;
  #line 1680 
  bool active_cable = (_Bool)0;
  #line 1682 
  if ((*(hw->mac.ops.get_media_type))(hw) != (unsigned int)ixgbe_media_type_fiber_qsfp) {
    #line 1683 
    hw->phy.sfp_type = ixgbe_sfp_type_not_present;
    #line 1684 
    return -20;
  }
  #line 1688 
  (*(hw->mac.ops.set_lan_id))(hw);
  #line 1690 
  status = (*(hw->phy.ops.read_i2c_eeprom))(hw,(unsigned char)0,& identifier);
  #line 1693 
  if (status != 0) 
                   #line 1694 
                   goto err_read_i2c_eeprom;
  #line 1696 
  if ((unsigned int)identifier != 13U) {
    #line 1697 
    hw->phy.type = ixgbe_phy_sfp_unsupported;
    #line 1698 
    return -19;
  }
  #line 1701 
  hw->phy.id = (unsigned int)identifier;
  #line 1703 
  status = (*(hw->phy.ops.read_i2c_eeprom))(hw,(unsigned char)131,& comp_codes_10g);
  #line 1706 
  if (status != 0) 
                   #line 1707 
                   goto err_read_i2c_eeprom;
  #line 1709 
  status = (*(hw->phy.ops.read_i2c_eeprom))(hw,(unsigned char)134,& comp_codes_1g);
  #line 1712 
  if (status != 0) 
                   #line 1713 
                   goto err_read_i2c_eeprom;
  #line 1715 
  if (((int)comp_codes_10g & 8) != 0) {
    #line 1716 
    hw->phy.type = ixgbe_phy_qsfp_passive_unknown;
    #line 1717 
    if ((unsigned int)hw->bus.lan_id == 0U) 
                                            #line 1718 
                                            hw->phy.sfp_type = ixgbe_sfp_type_da_cu_core0; else 
                                                                    #line 1720 
                                                                    hw->phy.sfp_type = ixgbe_sfp_type_da_cu_core1;
  }
  else 
    #line 1721 
    if (((int)comp_codes_10g & 48) != 0) 
      #line 1723 
      if ((unsigned int)hw->bus.lan_id == 0U) 
                                              #line 1724 
                                              hw->phy.sfp_type = ixgbe_sfp_type_srlr_core0; else 
                                                                    #line 1726 
                                                                    hw->phy.sfp_type = ixgbe_sfp_type_srlr_core1;
    else {
      #line 1728 
      if (((int)comp_codes_10g & 1) != 0) 
                                          #line 1729 
                                          active_cable = (_Bool)1;
      #line 1731 
      if (! active_cable) {
        #line 1735 
        (*(hw->phy.ops.read_i2c_eeprom))(hw,(unsigned char)130,& connector);
        #line 1739 
        (*(hw->phy.ops.read_i2c_eeprom))(hw,(unsigned char)146,& cable_length);
        #line 1743 
        (*(hw->phy.ops.read_i2c_eeprom))(hw,(unsigned char)147,& device_tech);
        #line 1747 
        if (((unsigned int)connector == 35U && (unsigned int)cable_length != 0U) && (unsigned int)((int)device_tech >> 4) == 0U) 
          #line 1752 
          active_cable = (_Bool)1;
      }
      #line 1755 
      if ((int)active_cable != 0) {
        #line 1756 
        hw->phy.type = ixgbe_phy_qsfp_active_unknown;
        #line 1757 
        if ((unsigned int)hw->bus.lan_id == 0U) 
                                                #line 1758 
                                                hw->phy.sfp_type = ixgbe_sfp_type_da_act_lmt_core0; else 
                                                                    #line 1761 
                                                                    hw->phy.sfp_type = ixgbe_sfp_type_da_act_lmt_core1;
      }
      else {
        #line 1765 
        hw->phy.type = ixgbe_phy_sfp_unsupported;
        #line 1766 
        return -19;
      }
    }
  #line 1770 
  if (hw->phy.sfp_type != stored_sfp_type) 
                                           #line 1771 
                                           hw->phy.sfp_setup_needed = (_Bool)1;
  #line 1774 
  hw->phy.multispeed_fiber = (_Bool)0;
  #line 1775 
  if (((int)comp_codes_1g & 1) != 0 && ((int)comp_codes_10g & 16) != 0 || ((int)comp_codes_1g & 2) != 0 && ((int)comp_codes_10g & 32) != 0) 
    #line 1779 
    hw->phy.multispeed_fiber = (_Bool)1;
  #line 1782 
  if (((int)comp_codes_10g & 48) != 0) {
    #line 1784 
    status = (*(hw->phy.ops.read_i2c_eeprom))(hw,(unsigned char)165,oui_bytes);
    #line 1788 
    if (status != 0) 
                     #line 1789 
                     goto err_read_i2c_eeprom;
    #line 1791 
    status = (*(hw->phy.ops.read_i2c_eeprom))(hw,(unsigned char)166,& oui_bytes[1]);
    #line 1795 
    if (status != 0) 
                     #line 1796 
                     goto err_read_i2c_eeprom;
    #line 1798 
    status = (*(hw->phy.ops.read_i2c_eeprom))(hw,(unsigned char)167,& oui_bytes[2]);
    #line 1802 
    if (status != 0) 
                     #line 1803 
                     goto err_read_i2c_eeprom;
    #line 1805 
    vendor_oui = (unsigned int)((((int)oui_bytes[0] << 24) | ((int)oui_bytes[1] << 16)) | ((int)oui_bytes[2] << 8));
    #line 1810 
    if (vendor_oui == 1777920U) 
                                #line 1811 
                                hw->phy.type = ixgbe_phy_qsfp_intel; else 
                                                                    #line 1813 
                                                                    hw->phy.type = ixgbe_phy_qsfp_unknown;
    #line 1815 
    (*(hw->mac.ops.get_device_caps))(hw,& enforce_sfp);
    #line 1816 
    if (((int)enforce_sfp & 1) == 0) {
      #line 1818 
      if (hw->phy.type == (unsigned int)ixgbe_phy_qsfp_intel) 
                                                              #line 1819 
                                                              return 0;
      #line 1820 
      if ((int)hw->allow_unsupported_sfp != 0) {
        #line 1821 
        if (((int)adapter->msg_enable & 1) != 0) 
                                                 #line 1821 
                                                 netdev_warn(adapter->netdev,(char *)"WARNING: Intel (R) Network Connections are quality tested using Intel (R) Ethernet Optics. Using untested modules is not supported and may cause unstable operation or damage to the module or the adapter. Intel Corporation is not responsible for any harm caused by using untested modules.\n");
        #line 1822 
        return 0;
      }
      {
        #line 1824 
        bool branch;
        #line 1824 
        struct _ddebug __UNIQUE_ID_ddebug463 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_identify_qsfp_module_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"QSFP module not supported\n", .lineno = (unsigned int)1824U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 1824 
        branch = arch_static_branch(& __UNIQUE_ID_ddebug463.key.dd_key_false.key,(_Bool)0);
        #line 1824 
        if ((long)((long)((int)branch != 0)) != 0L) 
                                                    #line 1824 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug463,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"QSFP module not supported\n");
      }
      #line 1825 
      hw->phy.type = ixgbe_phy_sfp_unsupported;
      #line 1826 
      return -19;
    }
    #line 1828 
    return 0;
  }
  #line 1830 
  return 0;
  #line 1832 
  err_read_i2c_eeprom: 
                       #line 1832 
  ;
  #line 1833 
  hw->phy.sfp_type = ixgbe_sfp_type_not_present;
  #line 1834 
  hw->phy.id = 0U;
  #line 1835 
  hw->phy.type = ixgbe_phy_unknown;
  #line 1837 
  return -20;
}

#line 1849  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_get_sfp_init_sequence_offsets(struct ixgbe_hw *hw, u16 *list_offset, u16 *data_offset)
{
  #line 1853 
  u16 sfp_id;
  #line 1854 
  u16 sfp_type = (unsigned short)hw->phy.sfp_type;
  #line 1856 
  if (hw->phy.sfp_type == (unsigned int)ixgbe_sfp_type_unknown) 
                                                                #line 1857 
                                                                return -19;
  #line 1859 
  if (hw->phy.sfp_type == (unsigned int)ixgbe_sfp_type_not_present) 
                                                                    #line 1860 
                                                                    return -20;
  #line 1862 
  if ((unsigned int)hw->device_id == 4321U && hw->phy.sfp_type == (unsigned int)ixgbe_sfp_type_da_cu) 
    #line 1864 
    return -19;
  #line 1870 
  if (((unsigned int)sfp_type == 7U || (unsigned int)sfp_type == 13U) || ((unsigned int)sfp_type == 9U || (unsigned int)sfp_type == 11U)) 
    #line 1874 
    sfp_type = (unsigned short)5U;
  else 
    #line 1875 
    if (((unsigned int)sfp_type == 8U || (unsigned int)sfp_type == 14U) || ((unsigned int)sfp_type == 10U || (unsigned int)sfp_type == 12U)) 
      #line 1879 
      sfp_type = (unsigned short)6U;
  #line 1882 
  if ((*(hw->eeprom.ops.read))(hw,(unsigned short)43,list_offset) != 0) {
    #line 1883 
    netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"eeprom read at %d failed\n",43);
    #line 1885 
    return -21;
  }
  #line 1888 
  if ((unsigned int)*list_offset + 65535U > 65533U) 
                                                    #line 1889 
                                                    return -21;
  #line 1892 
  *list_offset = (u16)((int)*list_offset + 1);
  #line 1898 
  if ((*(hw->eeprom.ops.read))(hw,(unsigned short)((int)*list_offset),
                                 & sfp_id) != 0) 
    #line 1899 
    goto err_phy;
  #line 1901 
  while ((unsigned int)sfp_id != 65535U) 
    #line 1902 
    if ((int)sfp_id == (int)sfp_type) {
      #line 1903 
      *list_offset = (u16)((int)*list_offset + 1);
      #line 1904 
      if ((*(hw->eeprom.ops.read))(hw,(unsigned short)((int)*list_offset),
                                 data_offset) != 0) 
        #line 1905 
        goto err_phy;
      #line 1906 
      if ((unsigned int)*data_offset + 65535U > 65533U) {
        {
          #line 1907 
          bool branch;
          #line 1907 
          struct _ddebug __UNIQUE_ID_ddebug464 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_get_sfp_init_sequence_offsets", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"SFP+ module not supported\n", .lineno = (unsigned int)1907U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
          #line 1907 
          branch = arch_static_branch(& __UNIQUE_ID_ddebug464.key.dd_key_false.key,(_Bool)0);
          #line 1907 
          if ((long)((long)((int)branch != 0)) != 0L) 
                                                      #line 1907 
                                                      __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug464,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"SFP+ module not supported\n");
        }
        #line 1908 
        return -19;
      }
      else 
           #line 1910 
           break;
    }
    else {
      #line 1913 
      *list_offset = (unsigned short)((unsigned int)*list_offset + 2U);
      #line 1914 
      if ((*(hw->eeprom.ops.read))(hw,(unsigned short)((int)*list_offset),
                                 & sfp_id) != 0) 
        #line 1915 
        goto err_phy;
    }
  #line 1919 
  if ((unsigned int)sfp_id == 65535U) {
    {
      #line 1920 
      bool branch_0;
      #line 1920 
      struct _ddebug __UNIQUE_ID_ddebug465 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_get_sfp_init_sequence_offsets", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"No matching SFP+ module found\n", .lineno = (unsigned int)1920U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1920 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug465.key.dd_key_false.key,(_Bool)0);
      #line 1920 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 1920 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug465,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"No matching SFP+ module found\n");
    }
    #line 1921 
    return -19;
  }
  #line 1924 
  return 0;
  #line 1926 
  err_phy: 
           #line 1926 
  ;
  #line 1927 
  netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"eeprom read at offset %d failed\n",(int)*list_offset);
  #line 1928 
  return -3;
}

#line 1939  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_read_i2c_eeprom_generic(struct ixgbe_hw *hw, u8 byte_offset, u8 *eeprom_data)
{
  #line 1942 
  return (*(hw->phy.ops.read_i2c_byte))(hw,(unsigned char)((int)byte_offset),
                                     (unsigned char)160,eeprom_data);
}

#line 1955  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_read_i2c_sff8472_generic(struct ixgbe_hw *hw, u8 byte_offset, u8 *sff8472_data)
{
  #line 1958 
  return (*(hw->phy.ops.read_i2c_byte))(hw,(unsigned char)((int)byte_offset),
                                     (unsigned char)162,sff8472_data);
}

#line 1971  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_write_i2c_eeprom_generic(struct ixgbe_hw *hw, u8 byte_offset, u8 eeprom_data)
{
  #line 1974 
  return (*(hw->phy.ops.write_i2c_byte))(hw,(unsigned char)((int)byte_offset),
                                      (unsigned char)160,
                                      (unsigned char)((int)eeprom_data));
}

#line 1985  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static bool ixgbe_is_sfp_probe(struct ixgbe_hw *hw, u8 offset, u8 addr)
{
  #line 1987 
  if (((unsigned int)addr == 160U && (unsigned int)offset == 0U) && hw->phy.sfp_type == (unsigned int)ixgbe_sfp_type_not_present) 
    #line 1990 
    return (_Bool)1;
  #line 1991 
  return (_Bool)0;
}

#line 2005  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_read_i2c_byte_generic_int(struct ixgbe_hw *hw, u8 byte_offset, u8 dev_addr, u8 *data, bool lock)
{
  #line 2008 
  s32 status;
  #line 2009 
  u32 max_retry = 10U;
  #line 2010 
  u32 retry = 0U;
  #line 2011 
  u32 swfw_mask = hw->phy.phy_semaphore_mask;
  #line 2012 
  bool nack = (_Bool)1;
  #line 2014 
  if (hw->mac.type > (unsigned int)ixgbe_mac_X540) 
                                                   #line 2015 
                                                   max_retry = 3U;
  #line 2016 
  if ((int)ixgbe_is_sfp_probe(hw,(unsigned char)((int)byte_offset),
                         (unsigned char)((int)dev_addr)) != 0) 
    #line 2017 
    max_retry = 2U;
  #line 2019 
  *data = (unsigned char)0U;
  #line 2021 
  while (1) {
    #line 2022 
    if ((int)lock != 0) {
      #line 2022 
      if ((*(hw->mac.ops.acquire_swfw_sync))(hw,swfw_mask) != 0) 
                                                                 #line 2023 
                                                                 return -16;
    }
    #line 2025 
    ixgbe_i2c_start(hw);
    #line 2028 
    status = ixgbe_clock_out_i2c_byte(hw,(unsigned char)((int)dev_addr));
    #line 2029 
    if (status != 0) 
                     #line 2030 
                     goto fail;
    #line 2032 
    status = ixgbe_get_i2c_ack(hw);
    #line 2033 
    if (status != 0) 
                     #line 2034 
                     goto fail;
    #line 2036 
    status = ixgbe_clock_out_i2c_byte(hw,(unsigned char)((int)byte_offset));
    #line 2037 
    if (status != 0) 
                     #line 2038 
                     goto fail;
    #line 2040 
    status = ixgbe_get_i2c_ack(hw);
    #line 2041 
    if (status != 0) 
                     #line 2042 
                     goto fail;
    #line 2044 
    ixgbe_i2c_start(hw);
    #line 2047 
    status = ixgbe_clock_out_i2c_byte(hw,(unsigned char)((int)((unsigned int)dev_addr | 1U)));
    #line 2048 
    if (status != 0) 
                     #line 2049 
                     goto fail;
    #line 2051 
    status = ixgbe_get_i2c_ack(hw);
    #line 2052 
    if (status != 0) 
                     #line 2053 
                     goto fail;
    #line 2055 
    status = ixgbe_clock_in_i2c_byte(hw,data);
    #line 2056 
    if (status != 0) 
                     #line 2057 
                     goto fail;
    #line 2059 
    status = ixgbe_clock_out_i2c_bit(hw,(_Bool)((bool)((int)nack) != 0));
    #line 2060 
    if (status != 0) 
                     #line 2061 
                     goto fail;
    #line 2063 
    ixgbe_i2c_stop(hw);
    #line 2064 
    if ((int)lock != 0) 
                        #line 2065 
                        (*(hw->mac.ops.release_swfw_sync))(hw,swfw_mask);
    #line 2066 
    return 0;
    #line 2068 
    fail: 
          #line 2068 
    ;
    #line 2069 
    ixgbe_i2c_bus_clear(hw);
    #line 2070 
    if ((int)lock != 0) {
      #line 2071 
      (*(hw->mac.ops.release_swfw_sync))(hw,swfw_mask);
      #line 2072 
      msleep(100U);
    }
    #line 2074 
    retry ++;
    #line 2075 
    if (retry < max_retry) {
      #line 2076 
      bool branch;
      #line 2076 
      struct _ddebug __UNIQUE_ID_ddebug466 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_read_i2c_byte_generic_int", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"I2C byte read error - Retrying.\n", .lineno = (unsigned int)2076U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 2076 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug466.key.dd_key_false.key,(_Bool)0);
      #line 2076 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 2076 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug466,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"I2C byte read error - Retrying.\n");
    }
    else {
      #line 2078 
      bool branch_0;
      #line 2078 
      struct _ddebug __UNIQUE_ID_ddebug467 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_read_i2c_byte_generic_int", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"I2C byte read error.\n", .lineno = (unsigned int)2078U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 2078 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug467.key.dd_key_false.key,(_Bool)0);
      #line 2078 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 2078 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug467,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"I2C byte read error.\n");
    }
    #line 2080 
    if (! (retry < max_retry)) 
                               #line 2021 
                               break;
  }
  #line 2082 
  return status;
}

#line 2095  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_read_i2c_byte_generic(struct ixgbe_hw *hw, u8 byte_offset, u8 dev_addr, u8 *data)
{
  #line 2098 
  return ixgbe_read_i2c_byte_generic_int(hw,(unsigned char)((int)byte_offset),
                                      (unsigned char)((int)dev_addr),data,
                                      (_Bool)1);
}

#line 2112  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_read_i2c_byte_generic_unlocked(struct ixgbe_hw *hw, u8 byte_offset, u8 dev_addr, u8 *data)
{
  #line 2115 
  return ixgbe_read_i2c_byte_generic_int(hw,(unsigned char)((int)byte_offset),
                                      (unsigned char)((int)dev_addr),data,
                                      (_Bool)0);
}

#line 2130  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_write_i2c_byte_generic_int(struct ixgbe_hw *hw, u8 byte_offset, u8 dev_addr, u8 data, bool lock)
{
  #line 2133 
  s32 status;
  #line 2134 
  u32 max_retry = 1U;
  #line 2135 
  u32 retry = 0U;
  #line 2136 
  u32 swfw_mask = hw->phy.phy_semaphore_mask;
  #line 2138 
  if ((int)lock != 0) {
    #line 2138 
    if ((*(hw->mac.ops.acquire_swfw_sync))(hw,swfw_mask) != 0) 
                                                               #line 2139 
                                                               return -16;
  }
  #line 2141 
  while (1) {
    #line 2142 
    ixgbe_i2c_start(hw);
    #line 2144 
    status = ixgbe_clock_out_i2c_byte(hw,(unsigned char)((int)dev_addr));
    #line 2145 
    if (status != 0) 
                     #line 2146 
                     goto fail;
    #line 2148 
    status = ixgbe_get_i2c_ack(hw);
    #line 2149 
    if (status != 0) 
                     #line 2150 
                     goto fail;
    #line 2152 
    status = ixgbe_clock_out_i2c_byte(hw,(unsigned char)((int)byte_offset));
    #line 2153 
    if (status != 0) 
                     #line 2154 
                     goto fail;
    #line 2156 
    status = ixgbe_get_i2c_ack(hw);
    #line 2157 
    if (status != 0) 
                     #line 2158 
                     goto fail;
    #line 2160 
    status = ixgbe_clock_out_i2c_byte(hw,(unsigned char)((int)data));
    #line 2161 
    if (status != 0) 
                     #line 2162 
                     goto fail;
    #line 2164 
    status = ixgbe_get_i2c_ack(hw);
    #line 2165 
    if (status != 0) 
                     #line 2166 
                     goto fail;
    #line 2168 
    ixgbe_i2c_stop(hw);
    #line 2169 
    if ((int)lock != 0) 
                        #line 2170 
                        (*(hw->mac.ops.release_swfw_sync))(hw,swfw_mask);
    #line 2171 
    return 0;
    #line 2173 
    fail: 
          #line 2173 
    ;
    #line 2174 
    ixgbe_i2c_bus_clear(hw);
    #line 2175 
    retry ++;
    #line 2176 
    if (retry < max_retry) {
      #line 2177 
      bool branch;
      #line 2177 
      struct _ddebug __UNIQUE_ID_ddebug468 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_write_i2c_byte_generic_int", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"I2C byte write error - Retrying.\n", .lineno = (unsigned int)2177U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 2177 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug468.key.dd_key_false.key,(_Bool)0);
      #line 2177 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 2177 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug468,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"I2C byte write error - Retrying.\n");
    }
    else {
      #line 2179 
      bool branch_0;
      #line 2179 
      struct _ddebug __UNIQUE_ID_ddebug469 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_write_i2c_byte_generic_int", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"I2C byte write error.\n", .lineno = (unsigned int)2179U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 2179 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug469.key.dd_key_false.key,(_Bool)0);
      #line 2179 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 2179 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug469,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"I2C byte write error.\n");
    }
    #line 2181 
    if (! (retry < max_retry)) 
                               #line 2141 
                               break;
  }
  #line 2182 
  if ((int)lock != 0) 
                      #line 2183 
                      (*(hw->mac.ops.release_swfw_sync))(hw,swfw_mask);
  #line 2185 
  return status;
}

#line 2198  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_write_i2c_byte_generic(struct ixgbe_hw *hw, u8 byte_offset, u8 dev_addr, u8 data)
{
  #line 2201 
  return ixgbe_write_i2c_byte_generic_int(hw,(unsigned char)((int)byte_offset),
                                       (unsigned char)((int)dev_addr),
                                       (unsigned char)((int)data),(_Bool)1);
}

#line 2215  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_write_i2c_byte_generic_unlocked(struct ixgbe_hw *hw, u8 byte_offset, u8 dev_addr, u8 data)
{
  #line 2218 
  return ixgbe_write_i2c_byte_generic_int(hw,(unsigned char)((int)byte_offset),
                                       (unsigned char)((int)dev_addr),
                                       (unsigned char)((int)data),(_Bool)0);
}

#line 2229  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static void ixgbe_i2c_start(struct ixgbe_hw *hw)
{
  #line 2231 
  u32 i2cctl = ixgbe_read_reg(hw,*(hw->mvals + 22U));
  #line 2233 
  i2cctl = *(hw->mvals + 20U) | i2cctl;
  #line 2236 
  ixgbe_set_i2c_data(hw,& i2cctl,(_Bool)1);
  #line 2237 
  ixgbe_raise_i2c_clk(hw,& i2cctl);
  #line 2240 
  __const_udelay(21475UL);
  #line 2242 
  ixgbe_set_i2c_data(hw,& i2cctl,(_Bool)0);
  #line 2245 
  __const_udelay(17180UL);
  #line 2247 
  ixgbe_lower_i2c_clk(hw,& i2cctl);
  #line 2250 
  __const_udelay(21475UL);
  #line 2252 
  return;
}

#line 2262  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static void ixgbe_i2c_stop(struct ixgbe_hw *hw)
{
  #line 2264 
  u32 i2cctl = ixgbe_read_reg(hw,*(hw->mvals + 22U));
  #line 2265 
  u32 data_oe_bit = *(hw->mvals + 19U);
  #line 2266 
  u32 clk_oe_bit = *(hw->mvals + 21U);
  #line 2267 
  u32 bb_en_bit = *(hw->mvals + 20U);
  #line 2270 
  ixgbe_set_i2c_data(hw,& i2cctl,(_Bool)0);
  #line 2271 
  ixgbe_raise_i2c_clk(hw,& i2cctl);
  #line 2274 
  __const_udelay(17180UL);
  #line 2276 
  ixgbe_set_i2c_data(hw,& i2cctl,(_Bool)1);
  #line 2279 
  __const_udelay(21475UL);
  #line 2281 
  if ((bb_en_bit != 0U || data_oe_bit != 0U) || clk_oe_bit != 0U) {
    #line 2282 
    i2cctl = ~ bb_en_bit & i2cctl;
    #line 2283 
    i2cctl = (data_oe_bit | clk_oe_bit) | i2cctl;
    #line 2284 
    ixgbe_write_reg_9(hw,*(hw->mvals + 22U),i2cctl);
    #line 2285 
    ixgbe_read_reg(hw,8U);
  }
  #line 2287 
  return;
}

#line 2296  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_clock_in_i2c_byte(struct ixgbe_hw *hw, u8 *data)
{
  #line 2298 
  s32 i;
  #line 2299 
  bool bit = (_Bool)0;
  #line 2301 
  *data = (unsigned char)0U;
  #line 2302 
  i = 7;
  #line 2302 
  while (i >= 0) {
    #line 2303 
    ixgbe_clock_in_i2c_bit(hw,& bit);
    #line 2304 
    *data = (unsigned char)((int)*data | ((int)bit << i));
    #line 2302 
    i --;
  }
  #line 2307 
  return 0;
}

#line 2317  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_clock_out_i2c_byte(struct ixgbe_hw *hw, u8 data)
{
  #line 2319 
  s32 status;
  #line 2320 
  s32 i;
  #line 2321 
  u32 i2cctl;
  #line 2322 
  bool bit = (_Bool)0;
  #line 2324 
  i = 7;
  #line 2324 
  while (i >= 0) {
    #line 2325 
    bit = (_Bool)((((int)data >> i) & 1) != 0);
    #line 2326 
    status = ixgbe_clock_out_i2c_bit(hw,(_Bool)((bool)((int)bit) != 0));
    #line 2328 
    if (status != 0) 
                     #line 2329 
                     break;
    #line 2324 
    i --;
  }
  #line 2333 
  i2cctl = ixgbe_read_reg(hw,*(hw->mvals + 22U));
  #line 2334 
  i2cctl = *(hw->mvals + 18U) | i2cctl;
  #line 2335 
  i2cctl = *(hw->mvals + 19U) | i2cctl;
  #line 2336 
  ixgbe_write_reg_9(hw,*(hw->mvals + 22U),i2cctl);
  #line 2337 
  ixgbe_read_reg(hw,8U);
  #line 2339 
  return status;
}

#line 2348  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_get_i2c_ack(struct ixgbe_hw *hw)
{
  #line 2350 
  u32 data_oe_bit = *(hw->mvals + 19U);
  #line 2351 
  s32 status = 0;
  #line 2352 
  u32 i = 0U;
  #line 2353 
  u32 i2cctl = ixgbe_read_reg(hw,*(hw->mvals + 22U));
  #line 2354 
  u32 timeout = 10U;
  #line 2355 
  bool ack = (_Bool)1;
  #line 2357 
  if (data_oe_bit != 0U) {
    #line 2358 
    i2cctl = *(hw->mvals + 18U) | i2cctl;
    #line 2359 
    i2cctl |= data_oe_bit;
    #line 2360 
    ixgbe_write_reg_9(hw,*(hw->mvals + 22U),i2cctl);
    #line 2361 
    ixgbe_read_reg(hw,8U);
  }
  #line 2363 
  ixgbe_raise_i2c_clk(hw,& i2cctl);
  #line 2366 
  __const_udelay(17180UL);
  #line 2370 
  i = 0U;
  #line 2370 
  while (i < timeout) {
    #line 2371 
    i2cctl = ixgbe_read_reg(hw,*(hw->mvals + 22U));
    #line 2372 
    ack = ixgbe_get_i2c_data(hw,& i2cctl);
    #line 2374 
    __const_udelay(4295UL);
    #line 2375 
    if (! ack) 
               #line 2376 
               break;
    #line 2370 
    i ++;
  }
  #line 2379 
  if ((int)ack == 1) {
    {
      #line 2380 
      bool branch;
      #line 2380 
      struct _ddebug __UNIQUE_ID_ddebug470 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_get_i2c_ack", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"I2C ack was not received.\n", .lineno = (unsigned int)2380U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 2380 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug470.key.dd_key_false.key,(_Bool)0);
      #line 2380 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 2380 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug470,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"I2C ack was not received.\n");
    }
    #line 2381 
    status = -18;
  }
  #line 2384 
  ixgbe_lower_i2c_clk(hw,& i2cctl);
  #line 2387 
  __const_udelay(21475UL);
  #line 2389 
  return status;
}

#line 2399  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_clock_in_i2c_bit(struct ixgbe_hw *hw, bool *data)
{
  #line 2401 
  u32 i2cctl = ixgbe_read_reg(hw,*(hw->mvals + 22U));
  #line 2402 
  u32 data_oe_bit = *(hw->mvals + 19U);
  #line 2404 
  if (data_oe_bit != 0U) {
    #line 2405 
    i2cctl = *(hw->mvals + 18U) | i2cctl;
    #line 2406 
    i2cctl |= data_oe_bit;
    #line 2407 
    ixgbe_write_reg_9(hw,*(hw->mvals + 22U),i2cctl);
    #line 2408 
    ixgbe_read_reg(hw,8U);
  }
  #line 2410 
  ixgbe_raise_i2c_clk(hw,& i2cctl);
  #line 2413 
  __const_udelay(17180UL);
  #line 2415 
  i2cctl = ixgbe_read_reg(hw,*(hw->mvals + 22U));
  #line 2416 
  *data = ixgbe_get_i2c_data(hw,& i2cctl);
  #line 2418 
  ixgbe_lower_i2c_clk(hw,& i2cctl);
  #line 2421 
  __const_udelay(21475UL);
  #line 2423 
  return 0;
}

#line 2433  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_clock_out_i2c_bit(struct ixgbe_hw *hw, bool data)
{
  #line 2435 
  s32 status;
  #line 2436 
  u32 i2cctl = ixgbe_read_reg(hw,*(hw->mvals + 22U));
  #line 2438 
  status = ixgbe_set_i2c_data(hw,& i2cctl,(_Bool)((bool)((int)data) != 0));
  #line 2439 
  if (status == 0) {
    #line 2440 
    ixgbe_raise_i2c_clk(hw,& i2cctl);
    #line 2443 
    __const_udelay(17180UL);
    #line 2445 
    ixgbe_lower_i2c_clk(hw,& i2cctl);
    #line 2450 
    __const_udelay(21475UL);
  }
  else {
    {
      #line 2452 
      bool branch;
      #line 2452 
      struct _ddebug __UNIQUE_ID_ddebug471 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_clock_out_i2c_bit", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"I2C data was not set to %X\n", .lineno = (unsigned int)2452U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 2452 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug471.key.dd_key_false.key,(_Bool)0);
      #line 2452 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 2452 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug471,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"I2C data was not set to %X\n",(int)data);
    }
    #line 2453 
    return -18;
  }
  #line 2456 
  return 0;
}

#line 2466  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static void ixgbe_raise_i2c_clk(struct ixgbe_hw *hw, u32 *i2cctl)
{
  #line 2468 
  u32 clk_oe_bit = *(hw->mvals + 21U);
  #line 2469 
  u32 i = 0U;
  #line 2470 
  u32 timeout = 500U;
  #line 2471 
  u32 i2cctl_r = 0U;
  #line 2473 
  if (clk_oe_bit != 0U) {
    #line 2474 
    *i2cctl |= clk_oe_bit;
    #line 2475 
    ixgbe_write_reg_9(hw,*(hw->mvals + 22U),*i2cctl);
  }
  #line 2478 
  i = 0U;
  #line 2478 
  while (i < timeout) {
    #line 2479 
    *i2cctl |= *(hw->mvals + 16U);
    #line 2480 
    ixgbe_write_reg_9(hw,*(hw->mvals + 22U),*i2cctl);
    #line 2481 
    ixgbe_read_reg(hw,8U);
    #line 2483 
    __const_udelay(4295UL);
    #line 2485 
    i2cctl_r = ixgbe_read_reg(hw,*(hw->mvals + 22U));
    #line 2486 
    if ((*(hw->mvals + 15U) & i2cctl_r) != 0U) 
                                               #line 2487 
                                               break;
    #line 2478 
    i ++;
  }
  #line 2489 
  return;
}

#line 2499  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static void ixgbe_lower_i2c_clk(struct ixgbe_hw *hw, u32 *i2cctl)
{
  #line 2502 
  *i2cctl &= ~ *(hw->mvals + 16U);
  #line 2503 
  *i2cctl &= ~ *(hw->mvals + 21U);
  #line 2505 
  ixgbe_write_reg_9(hw,*(hw->mvals + 22U),*i2cctl);
  #line 2506 
  ixgbe_read_reg(hw,8U);
  #line 2509 
  __const_udelay(4295UL);
  #line 2511 
  return;
}

#line 2521  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_set_i2c_data(struct ixgbe_hw *hw, u32 *i2cctl, bool data)
{
  #line 2523 
  u32 data_oe_bit = *(hw->mvals + 19U);
  #line 2525 
  if ((int)data != 0) 
                      #line 2526 
                      *i2cctl |= *(hw->mvals + 18U); else 
                                                          #line 2528 
                                                          *i2cctl &= ~ *(hw->mvals + 18U);
  #line 2529 
  *i2cctl &= ~ data_oe_bit;
  #line 2531 
  ixgbe_write_reg_9(hw,*(hw->mvals + 22U),*i2cctl);
  #line 2532 
  ixgbe_read_reg(hw,8U);
  #line 2535 
  __const_udelay(12885UL);
  #line 2537 
  if (! data) 
              #line 2538 
              return 0;
  #line 2539 
  if (data_oe_bit != 0U) {
    #line 2540 
    *i2cctl |= data_oe_bit;
    #line 2541 
    ixgbe_write_reg_9(hw,*(hw->mvals + 22U),*i2cctl);
    #line 2542 
    ixgbe_read_reg(hw,8U);
  }
  #line 2546 
  *i2cctl = ixgbe_read_reg(hw,*(hw->mvals + 22U));
  #line 2547 
  ;
  #line 2547 
  if ((int)ixgbe_get_i2c_data(hw,i2cctl) != (int)data) {
    {
      #line 2548 
      bool branch;
      #line 2548 
      struct _ddebug __UNIQUE_ID_ddebug472 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_set_i2c_data", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c", .format = (char *)"Error - I2C data was not set to %X.\n", .lineno = (unsigned int)2548U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 2548 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug472.key.dd_key_false.key,(_Bool)0);
      #line 2548 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 2548 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug472,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Error - I2C data was not set to %X.\n",(int)data);
    }
    #line 2549 
    return -18;
  }
  #line 2552 
  return 0;
}

#line 2563  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static bool ixgbe_get_i2c_data(struct ixgbe_hw *hw, u32 *i2cctl)
{
  #line 2565 
  u32 data_oe_bit = *(hw->mvals + 19U);
  #line 2567 
  if (data_oe_bit != 0U) {
    #line 2568 
    *i2cctl |= data_oe_bit;
    #line 2569 
    ixgbe_write_reg_9(hw,*(hw->mvals + 22U),*i2cctl);
    #line 2570 
    ixgbe_read_reg(hw,8U);
    #line 2571 
    __const_udelay(4295UL);
  }
  #line 2574 
  if ((*i2cctl & *(hw->mvals + 17U)) != 0U) 
                                            #line 2575 
                                            return (_Bool)1;
  #line 2576 
  return (_Bool)0;
}

#line 2586  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static void ixgbe_i2c_bus_clear(struct ixgbe_hw *hw)
{
  #line 2588 
  u32 i2cctl;
  #line 2589 
  u32 i;
  #line 2591 
  ixgbe_i2c_start(hw);
  #line 2592 
  i2cctl = ixgbe_read_reg(hw,*(hw->mvals + 22U));
  #line 2594 
  ixgbe_set_i2c_data(hw,& i2cctl,(_Bool)1);
  #line 2596 
  i = 0U;
  #line 2596 
  while (i <= 8U) {
    #line 2597 
    ixgbe_raise_i2c_clk(hw,& i2cctl);
    #line 2600 
    __const_udelay(17180UL);
    #line 2602 
    ixgbe_lower_i2c_clk(hw,& i2cctl);
    #line 2605 
    __const_udelay(21475UL);
    #line 2596 
    i ++;
  }
  #line 2608 
  ixgbe_i2c_start(hw);
  #line 2611 
  ixgbe_i2c_stop(hw);
  #line 2612 
  return;
}

#line 2620  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_tn_check_overtemp(struct ixgbe_hw *hw)
{
  #line 2622 
  u16 phy_data = (unsigned short)0U;
  #line 2624 
  if ((unsigned int)hw->device_id != 5404U) 
                                            #line 2625 
                                            return 0;
  #line 2628 
  (*(hw->phy.ops.read_reg))(hw,36869U,1U,& phy_data);
  #line 2631 
  if (((int)phy_data & 8) == 0) 
                                #line 2632 
                                return 0;
  #line 2634 
  return -26;
}

#line 2641  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_set_copper_phy_power(struct ixgbe_hw *hw, bool on)
{
  #line 2643 
  u32 status;
  #line 2644 
  u16 reg;
  #line 2647 
  if ((*(hw->mac.ops.get_media_type))(hw) != (unsigned int)ixgbe_media_type_copper) 
    #line 2648 
    return 0;
  #line 2650 
  if (! on) {
    #line 2650 
    if ((int)ixgbe_mng_present(hw) != 0) 
                                         #line 2651 
                                         return 0;
  }
  #line 2653 
  status = (unsigned int)(*(hw->phy.ops.read_reg))(hw,0U,30U,& reg);
  #line 2654 
  if (status != 0U) 
                    #line 2655 
                    return (int)status;
  #line 2657 
  if ((int)on != 0) 
                    #line 2658 
                    reg = (unsigned short)((unsigned int)reg & 63487U);
  else {
    #line 2660 
    if ((int)ixgbe_check_reset_blocked(hw) != 0) 
                                                 #line 2661 
                                                 return 0;
    #line 2662 
    reg = (unsigned short)((unsigned int)reg | 2048U);
  }
  #line 2665 
  status = (unsigned int)(*(hw->phy.ops.write_reg))(hw,0U,30U,(unsigned short)((int)reg));
  #line 2666 
  return (int)status;
}

#line 118  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
#line 162  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_unpack_pfc(struct ixgbe_dcb_config *cfg, u8 *pfc_en);
#line 119  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
#line 173  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_unpack_refill(struct ixgbe_dcb_config *cfg, int direction, u16 *refill);
#line 120  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
#line 183  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_unpack_max(struct ixgbe_dcb_config *cfg, u16 *max);
#line 121  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
#line 192  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_unpack_bwgid(struct ixgbe_dcb_config *cfg, int direction, u8 *bwgid);
#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
#line 202  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_unpack_prio(struct ixgbe_dcb_config *cfg, int direction, u8 *ptype);
#line 123  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
#line 235  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_unpack_map(struct ixgbe_dcb_config *cfg, int direction, u8 *map);
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
#line 336  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
s32 ixgbe_dcb_hw_ets_config(struct ixgbe_hw *hw, u16 *refill, u16 *max, u8 *bwg_id, u8 *prio_type, u8 *prio_tc);
#line 137  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
#line 377  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_read_rtrup2tc(struct ixgbe_hw *hw, u8 *map);
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
static s32 ixgbe_ieee_credits(__u8 *bw, __u16 *refill, __u16 *max, int max_frame)
{
  #line 25 
  int min_credit;
  #line 25 
  int multiplier;
  #line 26 
  int i;
  #line 24 
  int min_percent = 100;
  #line 28 
  min_credit = (max_frame / 2 + 63) / 64;
  #line 31 
  i = 0;
  #line 31 
  while (i <= 7) {
    #line 32 
    if ((int)*(bw + (unsigned long)i) < min_percent && (unsigned int)*(bw + (unsigned long)i) != 0U) 
      #line 33 
      min_percent = (int)*(bw + (unsigned long)i);
    #line 31 
    i ++;
  }
  #line 36 
  multiplier = min_credit / min_percent + 1;
  #line 39 
  i = 0;
  #line 39 
  while (i <= 7) {
    {
      #line 40 
      int __UNIQUE_ID___x443;
      #line 40 
      int tmp;
      {
        #line 40 
        __UNIQUE_ID___x443 = (int)*(bw + (unsigned long)i) * multiplier;
        #line 40 
        int __UNIQUE_ID___y444 = 511;
        #line 40 
        if (__UNIQUE_ID___x443 < __UNIQUE_ID___y444) 
                                                     #line 40 
                                                     tmp = __UNIQUE_ID___x443; else 
                                                                    #line 40 
                                                                    tmp = __UNIQUE_ID___y444;
        }
      #line 40 
      int val = tmp;
      #line 42 
      if (val < min_credit) 
                            #line 43 
                            val = min_credit;
      #line 44 
      *(refill + (unsigned long)i) = (unsigned short)val;
      #line 46 
      if ((unsigned int)*(bw + (unsigned long)i) != 0U) 
                                                        #line 46 
                                                        *(max + (unsigned long)i) = (unsigned short)(((int)*(bw + (unsigned long)i) * 4095) / 100); else 
                                                                    #line 46 
                                                                    *(max + (unsigned long)i) = (unsigned short)min_credit;
    }
    #line 39 
    i ++;
  }
  #line 48 
  return 0;
}

#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
s32 ixgbe_dcb_calculate_tc_credits(struct ixgbe_hw *hw, struct ixgbe_dcb_config *dcb_config, int max_frame, u8 direction)
{
  #line 66 
  struct tc_bw_alloc *p;
  #line 67 
  int min_credit;
  #line 68 
  int min_multiplier;
  #line 75 
  u8 i;
  #line 69 
  int min_percent = 100;
  #line 71 
  u32 credit_refill = 0U;
  #line 72 
  u32 credit_max = 0U;
  #line 73 
  u16 link_percentage = (unsigned short)0U;
  #line 74 
  u8 bw_percent = (unsigned char)0U;
  #line 77 
  if (dcb_config == (struct ixgbe_dcb_config *)0) 
                                                  #line 78 
                                                  return -1;
  #line 80 
  min_credit = (max_frame / 2 + 63) / 64;
  #line 84 
  i = (unsigned char)0U;
  #line 84 
  while ((unsigned int)i <= 7U) {
    #line 85 
    p = & dcb_config->tc_config[(int)i].path[(int)direction];
    #line 86 
    bw_percent = dcb_config->bw_percentage[(int)direction][(int)p->bwg_id];
    #line 87 
    link_percentage = (unsigned short)p->bwg_percent;
    #line 89 
    link_percentage = (unsigned short)(((int)link_percentage * (int)bw_percent) / 100);
    #line 91 
    if ((unsigned int)link_percentage != 0U && (int)link_percentage < min_percent) 
      #line 92 
      min_percent = (int)link_percentage;
    #line 84 
    i = (u8)((int)i + 1);
  }
  #line 103 
  min_multiplier = min_credit / min_percent + 1;
  #line 106 
  i = (unsigned char)0U;
  #line 106 
  while ((unsigned int)i <= 7U) {
    {
      #line 120 
      int __UNIQUE_ID___x445;
      #line 120 
      int tmp;
      #line 107 
      p = & dcb_config->tc_config[(int)i].path[(int)direction];
      #line 108 
      bw_percent = dcb_config->bw_percentage[(int)direction][(int)p->bwg_id];
      #line 110 
      link_percentage = (unsigned short)p->bwg_percent;
      #line 112 
      link_percentage = (unsigned short)(((int)link_percentage * (int)bw_percent) / 100);
      #line 113 
      if ((unsigned int)p->bwg_percent != 0U && (unsigned int)link_percentage == 0U) 
        #line 114 
        link_percentage = (unsigned short)1U;
      #line 117 
      p->link_percent = (unsigned char)link_percentage;
      {
        #line 120 
        __UNIQUE_ID___x445 = (int)link_percentage * min_multiplier;
        #line 120 
        int __UNIQUE_ID___y446 = 511;
        #line 120 
        if (__UNIQUE_ID___x445 < __UNIQUE_ID___y446) 
                                                     #line 120 
                                                     tmp = __UNIQUE_ID___x445; else 
                                                                    #line 120 
                                                                    tmp = __UNIQUE_ID___y446;
        }
      #line 120 
      credit_refill = (unsigned int)tmp;
      #line 124 
      if (credit_refill < (unsigned int)min_credit) 
                                                    #line 125 
                                                    credit_refill = (unsigned int)min_credit;
      #line 127 
      p->data_credits_refill = (unsigned short)credit_refill;
      #line 130 
      credit_max = (unsigned int)(((int)link_percentage * 4095) / 100);
      #line 137 
      if (credit_max < (unsigned int)min_credit) 
                                                 #line 138 
                                                 credit_max = (unsigned int)min_credit;
      #line 140 
      if ((unsigned int)direction == 0U) {
        #line 147 
        if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB && credit_max + 4294967295U <= 511U) 
          #line 150 
          credit_max = 513U;
        #line 152 
        dcb_config->tc_config[(int)i].desc_credits_max = (unsigned short)credit_max;
      }
      #line 156 
      p->data_credits_max = (unsigned short)credit_max;
    }
    #line 106 
    i = (u8)((int)i + 1);
  }
  #line 159 
  return 0;
}

#line 162  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_unpack_pfc(struct ixgbe_dcb_config *cfg, u8 *pfc_en)
{
  #line 165 
  int tc;
  #line 164 
  struct tc_configuration *tc_config = & cfg->tc_config[0];
  #line 167 
  *pfc_en = (unsigned char)0U;
  #line 167 
  tc = 0;
  #line 167 
  while (tc <= 7) {
    #line 168 
    if ((tc_config + (unsigned long)tc)->dcb_pfc != (unsigned int)pfc_disabled) 
      #line 169 
      *pfc_en = (unsigned char)((int)*pfc_en | (int)((unsigned char)(1UL << tc)));
    #line 167 
    tc ++;
  }
  #line 170 
  return;
}

#line 173  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_unpack_refill(struct ixgbe_dcb_config *cfg, int direction, u16 *refill)
{
  #line 177 
  int tc;
  #line 176 
  struct tc_configuration *tc_config = & cfg->tc_config[0];
  #line 179 
  tc = 0;
  #line 179 
  while (tc <= 7) {
    #line 180 
    *(refill + (unsigned long)tc) = (tc_config + (unsigned long)tc)->path[direction].data_credits_refill;
    #line 179 
    tc ++;
  }
  #line 181 
  return;
}

#line 183  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_unpack_max(struct ixgbe_dcb_config *cfg, u16 *max)
{
  #line 186 
  int tc;
  #line 185 
  struct tc_configuration *tc_config = & cfg->tc_config[0];
  #line 188 
  tc = 0;
  #line 188 
  while (tc <= 7) {
    #line 189 
    *(max + (unsigned long)tc) = (tc_config + (unsigned long)tc)->desc_credits_max;
    #line 188 
    tc ++;
  }
  #line 190 
  return;
}

#line 192  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_unpack_bwgid(struct ixgbe_dcb_config *cfg, int direction, u8 *bwgid)
{
  #line 196 
  int tc;
  #line 195 
  struct tc_configuration *tc_config = & cfg->tc_config[0];
  #line 198 
  tc = 0;
  #line 198 
  while (tc <= 7) {
    #line 199 
    *(bwgid + (unsigned long)tc) = (tc_config + (unsigned long)tc)->path[direction].bwg_id;
    #line 198 
    tc ++;
  }
  #line 200 
  return;
}

#line 202  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_unpack_prio(struct ixgbe_dcb_config *cfg, int direction, u8 *ptype)
{
  #line 206 
  int tc;
  #line 205 
  struct tc_configuration *tc_config = & cfg->tc_config[0];
  #line 208 
  tc = 0;
  #line 208 
  while (tc <= 7) {
    #line 209 
    *(ptype + (unsigned long)tc) = (unsigned char)(tc_config + (unsigned long)tc)->path[direction].prio_type;
    #line 208 
    tc ++;
  }
  #line 210 
  return;
}

#line 212  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
u8 ixgbe_dcb_get_tc_from_up(struct ixgbe_dcb_config *cfg, int direction, u8 up)
{
  #line 214 
  struct tc_configuration *tc_config = & cfg->tc_config[0];
  #line 215 
  u8 prio_mask = (unsigned char)(1UL << (int)up);
  #line 216 
  u8 tc = cfg->num_tcs.pg_tcs;
  #line 219 
  if ((unsigned int)tc == 0U) 
                              #line 220 
                              return (unsigned char)0U;
  #line 227 
  tc = (u8)((int)tc - 1);
  #line 227 
  while ((unsigned int)tc != 0U) {
    #line 228 
    if ((unsigned int)((int)(tc_config + (unsigned long)tc)->path[direction].up_to_tc_bitmap & (int)prio_mask) != 0U) 
      #line 229 
      break;
    #line 227 
    tc = (u8)((int)tc - 1);
  }
  #line 232 
  return tc;
}

#line 235  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_unpack_map(struct ixgbe_dcb_config *cfg, int direction, u8 *map)
{
  #line 237 
  u8 up;
  #line 239 
  up = (unsigned char)0U;
  #line 239 
  while ((unsigned int)up <= 7U) {
    #line 240 
    *(map + (unsigned long)up) = ixgbe_dcb_get_tc_from_up(cfg,direction,(unsigned char)((int)up));
    #line 239 
    up = (u8)((int)up + 1);
  }
  #line 241 
  return;
}

#line 250  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
s32 ixgbe_dcb_hw_config(struct ixgbe_hw *hw, struct ixgbe_dcb_config *dcb_config)
{
  #line 253 
  u8 pfc_en;
  #line 254 
  u8 ptype[8U];
  #line 255 
  u8 bwgid[8U];
  #line 256 
  u8 prio_tc[8U];
  #line 257 
  u16 refill[8U];
  #line 258 
  u16 max[8U];
  #line 261 
  ixgbe_dcb_unpack_pfc(dcb_config,& pfc_en);
  #line 262 
  ixgbe_dcb_unpack_refill(dcb_config,0,(u16 *)(& refill));
  #line 263 
  ixgbe_dcb_unpack_max(dcb_config,(u16 *)(& max));
  #line 264 
  ixgbe_dcb_unpack_bwgid(dcb_config,0,(u8 *)(& bwgid));
  #line 265 
  ixgbe_dcb_unpack_prio(dcb_config,0,(u8 *)(& ptype));
  #line 266 
  ixgbe_dcb_unpack_map(dcb_config,0,(u8 *)(& prio_tc));
  #line 268 
  switch ((unsigned int)hw->mac.type) {
    #line 269 
    case (unsigned int)1: 
                          #line 269 
    ;
    #line 270 
    return ixgbe_dcb_hw_config_82598(hw,(unsigned char)((int)pfc_en),
                                (u16 *)(& refill),(u16 *)(& max),
                                (u8 *)(& bwgid),(u8 *)(& ptype));
    #line 272 
    case (unsigned int)2: 
                          #line 272 
    ;
    #line 273 
    case (unsigned int)3: 
                          #line 273 
    ;
    #line 274 
    case (unsigned int)4: 
                          #line 274 
    ;
    #line 275 
    case (unsigned int)5: 
                          #line 275 
    ;
    #line 276 
    case (unsigned int)6: 
                          #line 276 
    ;
    #line 277 
    return ixgbe_dcb_hw_config_82599(hw,(unsigned char)((int)pfc_en),
                                  (u16 *)(& refill),(u16 *)(& max),
                                  (u8 *)(& bwgid),(u8 *)(& ptype),
                                  (u8 *)(& prio_tc));
    #line 279 
    default: 
             #line 279 
    ;
    #line 280 
    break;
  }
  #line 282 
  return 0;
}

#line 286  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
s32 ixgbe_dcb_hw_pfc_config(struct ixgbe_hw *hw, u8 pfc_en, u8 *prio_tc)
{
  #line 288 
  switch ((unsigned int)hw->mac.type) {
    #line 289 
    case (unsigned int)1: 
                          #line 289 
    ;
    #line 290 
    return ixgbe_dcb_config_pfc_82598(hw,(unsigned char)((int)pfc_en));
    #line 291 
    case (unsigned int)2: 
                          #line 291 
    ;
    #line 292 
    case (unsigned int)3: 
                          #line 292 
    ;
    #line 293 
    case (unsigned int)4: 
                          #line 293 
    ;
    #line 294 
    case (unsigned int)5: 
                          #line 294 
    ;
    #line 295 
    case (unsigned int)6: 
                          #line 295 
    ;
    #line 296 
    return ixgbe_dcb_config_pfc_82599(hw,(unsigned char)((int)pfc_en),prio_tc);
    #line 297 
    default: 
             #line 297 
    ;
    #line 298 
    break;
  }
  #line 300 
  return -22;
}

#line 303  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
s32 ixgbe_dcb_hw_ets(struct ixgbe_hw *hw, struct ieee_ets *ets, int max_frame)
{
  #line 305 
  __u16 refill[8U];
  #line 305 
  __u16 max[8U];
  #line 306 
  __u8 prio_type[8U];
  #line 307 
  int i;
  #line 310 
  __u8 bwg_id[8U] = {(unsigned char)0U, (unsigned char)1U, (unsigned char)2U, (unsigned char)3U, (unsigned char)4U, (unsigned char)5U, (unsigned char)6U, (unsigned char)7U};
  #line 313 
  i = 0;
  #line 313 
  while (i <= 7) {
    #line 314 
    switch ((int)ets->tc_tsa[i]) {
      #line 315 
      case 0: 
              #line 315 
      ;
      #line 316 
      prio_type[i] = (unsigned char)2U;
      #line 317 
      break;
      #line 318 
      case 2: 
              #line 318 
      ;
      #line 319 
      prio_type[i] = (unsigned char)0U;
      #line 320 
      break;
      #line 321 
      default: 
               #line 321 
      ;
      #line 327 
      return -22;
    }
    #line 313 
    i ++;
  }
  #line 331 
  ixgbe_ieee_credits((__u8 *)(& ets->tc_tx_bw),(__u16 *)(& refill),(__u16 *)(& max),max_frame);
  #line 332 
  return ixgbe_dcb_hw_ets_config(hw,(u16 *)(& refill),(u16 *)(& max),
                              (u8 *)(& bwg_id),(u8 *)(& prio_type),
                              (u8 *)(& ets->prio_tc));
}

#line 336  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
s32 ixgbe_dcb_hw_ets_config(struct ixgbe_hw *hw, u16 *refill, u16 *max, u8 *bwg_id, u8 *prio_type, u8 *prio_tc)
{
  #line 340 
  switch ((unsigned int)hw->mac.type) {
    #line 341 
    case (unsigned int)1: 
                          #line 341 
    ;
    #line 342 
    ixgbe_dcb_config_rx_arbiter_82598(hw,refill,max,prio_type);
    #line 344 
    ixgbe_dcb_config_tx_desc_arbiter_82598(hw,refill,max,bwg_id,prio_type);
    #line 346 
    ixgbe_dcb_config_tx_data_arbiter_82598(hw,refill,max,bwg_id,prio_type);
    #line 348 
    break;
    #line 349 
    case (unsigned int)2: 
                          #line 349 
    ;
    #line 350 
    case (unsigned int)3: 
                          #line 350 
    ;
    #line 351 
    case (unsigned int)4: 
                          #line 351 
    ;
    #line 352 
    case (unsigned int)5: 
                          #line 352 
    ;
    #line 353 
    case (unsigned int)6: 
                          #line 353 
    ;
    #line 354 
    ixgbe_dcb_config_rx_arbiter_82599(hw,refill,max,bwg_id,prio_type,prio_tc);
    #line 356 
    ixgbe_dcb_config_tx_desc_arbiter_82599(hw,refill,max,bwg_id,prio_type);
    #line 358 
    ixgbe_dcb_config_tx_data_arbiter_82599(hw,refill,max,bwg_id,prio_type,prio_tc);
    #line 360 
    break;
    #line 361 
    default: 
             #line 361 
    ;
    #line 362 
    break;
  }
  #line 364 
  return 0;
}

#line 367  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
static void ixgbe_dcb_read_rtrup2tc_82599(struct ixgbe_hw *hw, u8 *map)
{
  #line 369 
  u32 reg;
  #line 369 
  u32 i;
  #line 371 
  reg = ixgbe_read_reg(hw,12320U);
  #line 372 
  i = 0U;
  #line 372 
  while (i <= 7U) {
    #line 373 
    *(map + (unsigned long)i) = (unsigned char)((unsigned int)((unsigned char)(reg >> i * 3U)) & 7U);
    #line 372 
    i ++;
  }
  #line 374 
  return;
}

#line 377  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_read_rtrup2tc(struct ixgbe_hw *hw, u8 *map)
{
  #line 379 
  switch ((unsigned int)hw->mac.type) {
    #line 380 
    case (unsigned int)2: 
                          #line 380 
    ;
    #line 381 
    case (unsigned int)3: 
                          #line 381 
    ;
    #line 382 
    case (unsigned int)4: 
                          #line 382 
    ;
    #line 383 
    case (unsigned int)5: 
                          #line 383 
    ;
    #line 384 
    case (unsigned int)6: 
                          #line 384 
    ;
    #line 385 
    ixgbe_dcb_read_rtrup2tc_82599(hw,map);
    #line 386 
    break;
    #line 387 
    default: 
             #line 387 
    ;
    #line 388 
    break;
  }
  #line 390 
  return;
}

#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
#line 1302  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_write_eewr_generic(struct ixgbe_hw *hw, u16 offset, u16 data);
#line 37  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
#line 1256  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_write_eewr_buffer_generic(struct ixgbe_hw *hw, u16 offset, u16 words, u16 *data);
#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static void ixgbe_write_reg_10(struct ixgbe_hw *hw, u32 reg, u32 value)
{
  #line 147 
  union __anonunion___u_11461 __u;
  #line 146 
  __read_once_size((void *)(& hw->hw_addr),(void *)(& __u.__c),8);
  #line 146 
  u8 *reg_addr = (__u.__val);
  #line 148 
  if ((int)ixgbe_removed((void *)reg_addr) != 0) 
                                                 #line 149 
                                                 return;
  #line 150 
  writel(value,(void *)(reg_addr + (unsigned long)reg));
  #line 151 
  return;
}

#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
#line 1341 
static s32 ixgbe_acquire_eeprom(struct ixgbe_hw *hw);
#line 14 
#line 1387 
static s32 ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw);
#line 15 
#line 1462 
static void ixgbe_release_eeprom_semaphore(struct ixgbe_hw *hw);
#line 16 
#line 1478 
static s32 ixgbe_ready_eeprom(struct ixgbe_hw *hw);
#line 17 
#line 1516 
static void ixgbe_standby_eeprom(struct ixgbe_hw *hw);
#line 18 
#line 1539 
static void ixgbe_shift_out_eeprom_bits(struct ixgbe_hw *hw, u16 data, u16 count);
#line 20 
#line 1593 
static u16 ixgbe_shift_in_eeprom_bits(struct ixgbe_hw *hw, u16 count);
#line 21 
#line 1631 
static void ixgbe_raise_eeprom_clk(struct ixgbe_hw *hw, u32 *eec);
#line 22 
#line 1648 
static void ixgbe_lower_eeprom_clk(struct ixgbe_hw *hw, u32 *eec);
#line 23 
#line 1664 
static void ixgbe_release_eeprom(struct ixgbe_hw *hw);
#line 25 
#line 1996 
static s32 ixgbe_mta_vector(struct ixgbe_hw *hw, u8 *mc_addr);
#line 26 
#line 1315 
static s32 ixgbe_poll_eerd_eewr_done(struct ixgbe_hw *hw, u32 ee_reg);
#line 27 
#line 1087 
static s32 ixgbe_read_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, u16 offset, u16 words, u16 *data);
#line 29 
#line 949 
static s32 ixgbe_write_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, u16 offset, u16 words, u16 *data);
#line 31 
#line 1202 
static s32 ixgbe_detect_eeprom_page_size_generic(struct ixgbe_hw *hw, u16 offset);
#line 33 
#line 2517 
static s32 ixgbe_disable_pcie_master(struct ixgbe_hw *hw);
#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
u32 ixgbe_mvals_8259X[23U] = {65552U, 65564U, 66048U, 65872U, 65856U, 65888U, 65864U, 1U, 2U, 4U, 16777216U, 33554432U, 67108864U, 69768U, 69772U, 1U, 2U, 4U, 8U, [22] = 40U};
#line 49  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
bool ixgbe_device_supports_autoneg_fc(struct ixgbe_hw *hw)
{
  #line 52 
  ixgbe_link_speed speed;
  #line 53 
  bool link_up;
  #line 51 
  bool supported = (_Bool)0;
  #line 55 
  switch ((unsigned int)hw->phy.media_type) {
    #line 56 
    case (unsigned int)1: 
                          #line 56 
    ;
    #line 58 
    switch ((int)hw->device_id) {
      #line 59 
      case 5582: 
                 #line 59 
      ;
      #line 60 
      case 5572: 
                 #line 60 
      ;
      #line 61 
      supported = (_Bool)0;
      #line 62 
      break;
      #line 63 
      default: 
               #line 63 
      ;
      #line 64 
      (*(hw->mac.ops.check_link))(hw,& speed,& link_up,(_Bool)0);
      #line 66 
      if ((int)link_up != 0) 
                             #line 67 
                             supported = (_Bool)(speed == 32U); else 
                                                                  #line 70 
                                                                  supported = (_Bool)1;
    }
    #line 73 
    break;
    #line 74 
    case (unsigned int)5: 
                          #line 74 
    ;
    #line 75 
    if ((unsigned int)hw->device_id == 5552U) 
                                              #line 76 
                                              supported = (_Bool)0; else 
                                                                    #line 78 
                                                                    supported = (_Bool)1;
    #line 79 
    break;
    #line 80 
    case (unsigned int)4: 
                          #line 80 
    ;
    #line 82 
    switch ((int)hw->device_id) {
      #line 83 
      case 5404: 
                 #line 83 
      ;
      #line 84 
      case 5416: 
                 #line 84 
      ;
      #line 85 
      case 5472: 
                 #line 85 
      ;
      #line 86 
      case 5475: 
                 #line 86 
      ;
      #line 87 
      case 5585: 
                 #line 87 
      ;
      #line 88 
      case 5549: 
                 #line 88 
      ;
      #line 89 
      case 5576: 
                 #line 89 
      ;
      #line 90 
      case 5604: 
                 #line 90 
      ;
      #line 91 
      case 5605: 
                 #line 91 
      ;
      #line 92 
      supported = (_Bool)1;
      #line 93 
      break;
      #line 94 
      default: 
               #line 94 
      ;
      #line 95 
      break;
    }
    #line 97 
    default: 
             #line 97 
    ;
    #line 98 
    break;
  }
  #line 101 
  if (! supported) {
    #line 102 
    bool branch;
    #line 102 
    struct _ddebug __UNIQUE_ID_ddebug443 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_device_supports_autoneg_fc", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Device %x does not support flow control autoneg\n", .lineno = (unsigned int)102U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 102 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug443.key.dd_key_false.key,(_Bool)0);
    #line 102 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 102 
                                                __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug443,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Device %x does not support flow control autoneg\n",(int)hw->device_id);
  }
  #line 105 
  return supported;
}

#line 114  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_setup_fc_generic(struct ixgbe_hw *hw)
{
  #line 116 
  s32 ret_val = 0;
  #line 117 
  u32 reg = 0U;
  #line 117 
  u32 reg_bp = 0U;
  #line 118 
  u16 reg_cu = (unsigned short)0U;
  #line 119 
  bool locked = (_Bool)0;
  #line 125 
  if ((int)hw->fc.strict_ieee != 0 && hw->fc.requested_mode == (unsigned int)ixgbe_fc_rx_pause) {
    {
      #line 126 
      bool branch;
      #line 126 
      struct _ddebug __UNIQUE_ID_ddebug444 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_setup_fc_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"ixgbe_fc_rx_pause not valid in strict IEEE mode\n", .lineno = (unsigned int)126U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 126 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug444.key.dd_key_false.key,(_Bool)0);
      #line 126 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 126 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug444,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"ixgbe_fc_rx_pause not valid in strict IEEE mode\n");
    }
    #line 127 
    return -13;
  }
  #line 134 
  if (hw->fc.requested_mode == (unsigned int)ixgbe_fc_default) 
                                                               #line 135 
                                                               hw->fc.requested_mode = ixgbe_fc_full;
  #line 142 
  switch ((unsigned int)hw->phy.media_type) {
    #line 143 
    case (unsigned int)5: 
                          #line 143 
    ;
    #line 145 
    ret_val = (*(hw->mac.ops.prot_autoc_read))(hw,& locked,& reg_bp);
    #line 146 
    if (ret_val != 0) 
                      #line 147 
                      return ret_val;
    #line 150 
    case (unsigned int)1: 
                          #line 150 
    ;
    #line 151 
    reg = ixgbe_read_reg(hw,16920U);
    #line 153 
    break;
    #line 154 
    case (unsigned int)4: 
                          #line 154 
    ;
    #line 155 
    (*(hw->phy.ops.read_reg))(hw,16U,7U,& reg_cu);
    #line 157 
    break;
    #line 158 
    default: 
             #line 158 
    ;
    #line 159 
    break;
  }
  #line 172 
  switch ((unsigned int)hw->fc.requested_mode) {
    #line 173 
    case (unsigned int)0: 
                          #line 173 
    ;
    #line 175 
    reg &= 4294966911U;
    #line 176 
    if (hw->phy.media_type == (unsigned int)ixgbe_media_type_backplane) 
      #line 177 
      reg_bp &= 3489660927U;
    else 
      #line 179 
      if (hw->phy.media_type == (unsigned int)ixgbe_media_type_copper) 
        #line 180 
        reg_cu = (unsigned short)((unsigned int)reg_cu & 62463U);
    #line 181 
    break;
    #line 182 
    case (unsigned int)2: 
                          #line 182 
    ;
    #line 187 
    reg |= 256U;
    #line 188 
    reg &= 4294967167U;
    #line 189 
    if (hw->phy.media_type == (unsigned int)ixgbe_media_type_backplane) {
      #line 190 
      reg_bp |= 536870912U;
      #line 191 
      reg_bp &= 4026531839U;
    }
    else 
      #line 192 
      if (hw->phy.media_type == (unsigned int)ixgbe_media_type_copper) {
        #line 193 
        reg_cu = (unsigned short)((unsigned int)reg_cu | 2048U);
        #line 194 
        reg_cu = (unsigned short)((unsigned int)reg_cu & 64511U);
      }
    #line 196 
    break;
    #line 197 
    case (unsigned int)1: 
                          #line 197 
    ;
    #line 207 
    case (unsigned int)3: 
                          #line 207 
    ;
    #line 209 
    reg |= 384U;
    #line 210 
    if (hw->phy.media_type == (unsigned int)ixgbe_media_type_backplane) 
      #line 211 
      reg_bp |= 805306368U;
    else 
      #line 213 
      if (hw->phy.media_type == (unsigned int)ixgbe_media_type_copper) 
        #line 214 
        reg_cu = (unsigned short)((unsigned int)reg_cu | 3072U);
    #line 215 
    break;
    #line 216 
    default: 
             #line 216 
    ;
    {
      #line 217 
      bool branch_0;
      #line 217 
      struct _ddebug __UNIQUE_ID_ddebug445 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_setup_fc_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Flow control param set incorrectly\n", .lineno = (unsigned int)217U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 217 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug445.key.dd_key_false.key,(_Bool)0);
      #line 217 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 217 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug445,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Flow control param set incorrectly\n");
    }
    #line 218 
    return -4;
  }
  #line 221 
  if (hw->mac.type != (unsigned int)ixgbe_mac_X540) {
    #line 226 
    ixgbe_write_reg_10(hw,16920U,reg);
    #line 227 
    reg = ixgbe_read_reg(hw,16904U);
    #line 230 
    if ((int)hw->fc.strict_ieee != 0) 
                                      #line 231 
                                      reg &= 4294705151U;
    #line 233 
    ixgbe_write_reg_10(hw,16904U,reg);
    {
      #line 234 
      bool branch_1;
      #line 234 
      struct _ddebug __UNIQUE_ID_ddebug446 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_setup_fc_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Set up FC; PCS1GLCTL = 0x%08X\n", .lineno = (unsigned int)234U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 234 
      branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug446.key.dd_key_false.key,(_Bool)0);
      #line 234 
      if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                    #line 234 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug446,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Set up FC; PCS1GLCTL = 0x%08X\n",reg);
    }
  }
  #line 242 
  if (hw->phy.media_type == (unsigned int)ixgbe_media_type_backplane) {
    #line 247 
    ret_val = (*(hw->mac.ops.prot_autoc_write))(hw,reg_bp,(_Bool)((bool)((int)locked) != 0));
    #line 248 
    if (ret_val != 0) 
                      #line 249 
                      return ret_val;
  }
  else 
    #line 251 
    if (hw->phy.media_type == (unsigned int)ixgbe_media_type_copper) {
      #line 251 
      if ((int)ixgbe_device_supports_autoneg_fc(hw) != 0) 
                                                          #line 253 
                                                          (*(hw->phy.ops.write_reg))(hw,16U,7U,(unsigned short)((int)reg_cu));
    }
  {
    #line 257 
    bool branch_2;
    #line 257 
    struct _ddebug __UNIQUE_ID_ddebug447 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_setup_fc_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Set up FC; IXGBE_AUTOC = 0x%08X\n", .lineno = (unsigned int)257U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 257 
    branch_2 = arch_static_branch(& __UNIQUE_ID_ddebug447.key.dd_key_false.key,(_Bool)0);
    #line 257 
    if ((long)((long)((int)branch_2 != 0)) != 0L) 
                                                  #line 257 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug447,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Set up FC; IXGBE_AUTOC = 0x%08X\n",reg);
  }
  #line 258 
  return ret_val;
}

#line 270  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_start_hw_generic(struct ixgbe_hw *hw)
{
  #line 272 
  s32 ret_val;
  #line 273 
  u32 ctrl_ext;
  #line 274 
  u16 device_caps;
  #line 277 
  hw->phy.media_type = (*(hw->mac.ops.get_media_type))(hw);
  #line 280 
  (*(hw->phy.ops.identify))(hw);
  #line 283 
  (*(hw->mac.ops.clear_vfta))(hw);
  #line 286 
  (*(hw->mac.ops.clear_hw_cntrs))(hw);
  #line 289 
  ctrl_ext = ixgbe_read_reg(hw,24U);
  #line 290 
  ctrl_ext |= 65536U;
  #line 291 
  ixgbe_write_reg_10(hw,24U,ctrl_ext);
  #line 292 
  ixgbe_read_reg(hw,8U);
  #line 295 
  if (hw->mac.ops.setup_fc != (s32 (*)(struct ixgbe_hw *))0) {
    #line 296 
    ret_val = (*(hw->mac.ops.setup_fc))(hw);
    #line 297 
    if (ret_val != 0) 
                      #line 298 
                      return ret_val;
  }
  #line 302 
  switch ((unsigned int)hw->mac.type) {
    #line 303 
    case (unsigned int)2: 
                          #line 303 
    ;
    #line 304 
    case (unsigned int)5: 
                          #line 304 
    ;
    #line 305 
    case (unsigned int)6: 
                          #line 305 
    ;
    #line 306 
    (*(hw->mac.ops.get_device_caps))(hw,& device_caps);
    #line 307 
    if (((unsigned long)device_caps & 128UL) != 0UL) 
                                                     #line 308 
                                                     hw->need_crosstalk_fix = (_Bool)0; else 
                                                                    #line 310 
                                                                    hw->need_crosstalk_fix = (_Bool)1;
    #line 311 
    break;
    #line 312 
    default: 
             #line 312 
    ;
    #line 313 
    hw->need_crosstalk_fix = (_Bool)0;
    #line 314 
    break;
  }
  #line 318 
  hw->adapter_stopped = (_Bool)0;
  #line 320 
  return 0;
}

#line 333  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_start_hw_gen2(struct ixgbe_hw *hw)
{
  #line 335 
  u32 i;
  #line 338 
  i = 0U;
  #line 338 
  while (hw->mac.max_tx_queues > i) {
    #line 339 
    ixgbe_write_reg_10(hw,18692U,i);
    #line 340 
    ixgbe_write_reg_10(hw,18820U,0U);
    #line 338 
    i ++;
  }
  #line 342 
  ixgbe_read_reg(hw,8U);
  #line 344 
  return 0;
}

#line 357  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_init_hw_generic(struct ixgbe_hw *hw)
{
  #line 359 
  s32 status;
  #line 362 
  status = (*(hw->mac.ops.reset_hw))(hw);
  #line 364 
  if (status == 0) 
                   #line 366 
                   status = (*(hw->mac.ops.start_hw))(hw);
  #line 370 
  if (hw->mac.ops.init_led_link_act != (s32 (*)(struct ixgbe_hw *))0) 
    #line 371 
    (*(hw->mac.ops.init_led_link_act))(hw);
  #line 373 
  return status;
}

#line 383  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_clear_hw_cntrs_generic(struct ixgbe_hw *hw)
{
  #line 385 
  u16 i = (unsigned short)0U;
  #line 387 
  ixgbe_read_reg(hw,16384U);
  #line 388 
  ixgbe_read_reg(hw,16388U);
  #line 389 
  ixgbe_read_reg(hw,16392U);
  #line 390 
  ixgbe_read_reg(hw,16400U);
  #line 391 
  i = (unsigned short)0U;
  #line 391 
  while ((unsigned int)i <= 7U) {
    #line 392 
    ixgbe_read_reg(hw,(unsigned int)(((int)i + 4072) * 4));
    #line 391 
    i = (u16)((int)i + 1);
  }
  #line 394 
  ixgbe_read_reg(hw,16436U);
  #line 395 
  ixgbe_read_reg(hw,16440U);
  #line 396 
  ixgbe_read_reg(hw,16448U);
  #line 397 
  ixgbe_read_reg(hw,16224U);
  #line 398 
  ixgbe_read_reg(hw,16232U);
  #line 399 
  if (hw->mac.type > (unsigned int)ixgbe_mac_82598EB) {
    #line 400 
    ixgbe_read_reg(hw,16804U);
    #line 401 
    ixgbe_read_reg(hw,16808U);
  }
  else {
    #line 403 
    ixgbe_read_reg(hw,53088U);
    #line 404 
    ixgbe_read_reg(hw,53096U);
  }
  #line 407 
  i = (unsigned short)0U;
  #line 407 
  while ((unsigned int)i <= 7U) {
    #line 408 
    ixgbe_read_reg(hw,(unsigned int)(((int)i + 4032) * 4));
    #line 409 
    ixgbe_read_reg(hw,(unsigned int)(((int)i + 4040) * 4));
    #line 410 
    if (hw->mac.type > (unsigned int)ixgbe_mac_82598EB) {
      #line 411 
      ixgbe_read_reg(hw,(unsigned int)(((int)i + 4176) * 4));
      #line 412 
      ixgbe_read_reg(hw,(unsigned int)(((int)i + 4184) * 4));
    }
    else {
      #line 414 
      ixgbe_read_reg(hw,(unsigned int)(((int)i + 13248) * 4));
      #line 415 
      ixgbe_read_reg(hw,(unsigned int)(((int)i + 13256) * 4));
    }
    #line 407 
    i = (u16)((int)i + 1);
  }
  #line 418 
  if (hw->mac.type > (unsigned int)ixgbe_mac_82598EB) {
    #line 419 
    i = (unsigned short)0U;
    #line 419 
    while ((unsigned int)i <= 7U) {
      #line 420 
      ixgbe_read_reg(hw,(unsigned int)(((int)i + 3216) * 4));
      #line 419 
      i = (u16)((int)i + 1);
    }
  }
  #line 421 
  ixgbe_read_reg(hw,16476U);
  #line 422 
  ixgbe_read_reg(hw,16480U);
  #line 423 
  ixgbe_read_reg(hw,16484U);
  #line 424 
  ixgbe_read_reg(hw,16488U);
  #line 425 
  ixgbe_read_reg(hw,16492U);
  #line 426 
  ixgbe_read_reg(hw,16496U);
  #line 427 
  ixgbe_read_reg(hw,16500U);
  #line 428 
  ixgbe_read_reg(hw,16504U);
  #line 429 
  ixgbe_read_reg(hw,16508U);
  #line 430 
  ixgbe_read_reg(hw,16512U);
  #line 431 
  ixgbe_read_reg(hw,16520U);
  #line 432 
  ixgbe_read_reg(hw,16524U);
  #line 433 
  ixgbe_read_reg(hw,16528U);
  #line 434 
  ixgbe_read_reg(hw,16532U);
  #line 435 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) {
    #line 436 
    i = (unsigned short)0U;
    #line 436 
    while ((unsigned int)i <= 7U) {
      #line 437 
      ixgbe_read_reg(hw,(unsigned int)(((int)i + 4080) * 4));
      #line 436 
      i = (u16)((int)i + 1);
    }
  }
  #line 438 
  ixgbe_read_reg(hw,16548U);
  #line 439 
  ixgbe_read_reg(hw,16552U);
  #line 440 
  ixgbe_read_reg(hw,16556U);
  #line 441 
  ixgbe_read_reg(hw,16560U);
  #line 442 
  ixgbe_read_reg(hw,16564U);
  #line 443 
  ixgbe_read_reg(hw,16568U);
  #line 444 
  ixgbe_read_reg(hw,53136U);
  #line 445 
  ixgbe_read_reg(hw,16576U);
  #line 446 
  ixgbe_read_reg(hw,16580U);
  #line 447 
  ixgbe_read_reg(hw,16592U);
  #line 448 
  ixgbe_read_reg(hw,16596U);
  #line 449 
  ixgbe_read_reg(hw,16600U);
  #line 450 
  ixgbe_read_reg(hw,16604U);
  #line 451 
  ixgbe_read_reg(hw,16608U);
  #line 452 
  ixgbe_read_reg(hw,16612U);
  #line 453 
  ixgbe_read_reg(hw,16616U);
  #line 454 
  ixgbe_read_reg(hw,16620U);
  #line 455 
  ixgbe_read_reg(hw,16624U);
  #line 456 
  ixgbe_read_reg(hw,16628U);
  #line 457 
  i = (unsigned short)0U;
  #line 457 
  while ((unsigned int)i <= 15U) {
    #line 458 
    ixgbe_read_reg(hw,(unsigned int)((int)i * 64 + 4144));
    #line 459 
    ixgbe_read_reg(hw,(unsigned int)((int)i * 64 + 24624));
    #line 460 
    if (hw->mac.type > (unsigned int)ixgbe_mac_82598EB) {
      #line 461 
      ixgbe_read_reg(hw,(unsigned int)((int)i * 64 + 4148));
      #line 462 
      ixgbe_read_reg(hw,(unsigned int)((int)i * 64 + 4152));
      #line 463 
      ixgbe_read_reg(hw,(unsigned int)(((int)i + 4320) * 8));
      #line 464 
      ixgbe_read_reg(hw,(unsigned int)((int)i * 8 + 34564));
      #line 465 
      ixgbe_read_reg(hw,(unsigned int)((int)i * 64 + 5168));
    }
    else {
      #line 467 
      ixgbe_read_reg(hw,(unsigned int)((int)i * 64 + 4148));
      #line 468 
      ixgbe_read_reg(hw,(unsigned int)((int)i * 64 + 24628));
    }
    #line 457 
    i = (u16)((int)i + 1);
  }
  #line 472 
  if ((unsigned int)hw->mac.type + 4294967293U <= 1U) {
    #line 473 
    if (hw->phy.id == 0U) 
                          #line 474 
                          (*(hw->phy.ops.identify))(hw);
    #line 475 
    (*(hw->phy.ops.read_reg))(hw,59408U,3U,& i);
    #line 476 
    (*(hw->phy.ops.read_reg))(hw,59409U,3U,& i);
    #line 477 
    (*(hw->phy.ops.read_reg))(hw,59424U,3U,& i);
    #line 478 
    (*(hw->phy.ops.read_reg))(hw,59425U,3U,& i);
  }
  #line 481 
  return 0;
}

#line 492  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_read_pba_string_generic(struct ixgbe_hw *hw, u8 *pba_num, u32 pba_num_size)
{
  #line 495 
  s32 ret_val;
  #line 496 
  u16 data;
  #line 497 
  u16 pba_ptr;
  #line 498 
  u16 offset;
  #line 499 
  u16 length;
  #line 501 
  if (pba_num == (u8 *)0U) {
    {
      #line 502 
      bool branch;
      #line 502 
      struct _ddebug __UNIQUE_ID_ddebug448 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_read_pba_string_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"PBA string buffer was null\n", .lineno = (unsigned int)502U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 502 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug448.key.dd_key_false.key,(_Bool)0);
      #line 502 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 502 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug448,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"PBA string buffer was null\n");
    }
    #line 503 
    return -32;
  }
  #line 506 
  ret_val = (*(hw->eeprom.ops.read))(hw,(unsigned short)21,& data);
  #line 507 
  if (ret_val != 0) {
    {
      #line 508 
      bool branch_0;
      #line 508 
      struct _ddebug __UNIQUE_ID_ddebug449 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_read_pba_string_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"NVM Read Error\n", .lineno = (unsigned int)508U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 508 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug449.key.dd_key_false.key,(_Bool)0);
      #line 508 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 508 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug449,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"NVM Read Error\n");
    }
    #line 509 
    return ret_val;
  }
  #line 512 
  ret_val = (*(hw->eeprom.ops.read))(hw,(unsigned short)22,& pba_ptr);
  #line 513 
  if (ret_val != 0) {
    {
      #line 514 
      bool branch_1;
      #line 514 
      struct _ddebug __UNIQUE_ID_ddebug450 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_read_pba_string_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"NVM Read Error\n", .lineno = (unsigned int)514U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 514 
      branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug450.key.dd_key_false.key,(_Bool)0);
      #line 514 
      if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                    #line 514 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug450,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"NVM Read Error\n");
    }
    #line 515 
    return ret_val;
  }
  #line 523 
  if ((unsigned int)data != 64250U) {
    {
      #line 524 
      bool branch_2;
      #line 524 
      struct _ddebug __UNIQUE_ID_ddebug451 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_read_pba_string_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"NVM PBA number is not stored as string\n", .lineno = (unsigned int)524U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 524 
      branch_2 = arch_static_branch(& __UNIQUE_ID_ddebug451.key.dd_key_false.key,(_Bool)0);
      #line 524 
      if ((long)((long)((int)branch_2 != 0)) != 0L) 
                                                    #line 524 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug451,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"NVM PBA number is not stored as string\n");
    }
    #line 527 
    if (pba_num_size <= 10U) {
      {
        #line 528 
        bool branch_3;
        #line 528 
        struct _ddebug __UNIQUE_ID_ddebug452 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_read_pba_string_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"PBA string buffer too small\n", .lineno = (unsigned int)528U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 528 
        branch_3 = arch_static_branch(& __UNIQUE_ID_ddebug452.key.dd_key_false.key,(_Bool)0);
        #line 528 
        if ((long)((long)((int)branch_3 != 0)) != 0L) 
                                                      #line 528 
                                                      __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug452,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"PBA string buffer too small\n");
      }
      #line 529 
      return -25;
    }
    #line 533 
    *pba_num = (unsigned char)((unsigned int)((unsigned char)((int)data >> 12)) & 15U);
    #line 534 
    *(pba_num + 1U) = (unsigned char)((unsigned int)((unsigned char)((int)data >> 8)) & 15U);
    #line 535 
    *(pba_num + 2U) = (unsigned char)((unsigned int)((unsigned char)((int)data >> 4)) & 15U);
    #line 536 
    *(pba_num + 3U) = (unsigned char)((unsigned int)((unsigned char)data) & 15U);
    #line 537 
    *(pba_num + 4U) = (unsigned char)((unsigned int)((unsigned char)((int)pba_ptr >> 12)) & 15U);
    #line 538 
    *(pba_num + 5U) = (unsigned char)((unsigned int)((unsigned char)((int)pba_ptr >> 8)) & 15U);
    #line 539 
    *(pba_num + 6U) = (unsigned char)45U;
    #line 540 
    *(pba_num + 7U) = (unsigned char)0U;
    #line 541 
    *(pba_num + 8U) = (unsigned char)((unsigned int)((unsigned char)((int)pba_ptr >> 4)) & 15U);
    #line 542 
    *(pba_num + 9U) = (unsigned char)((unsigned int)((unsigned char)pba_ptr) & 15U);
    #line 545 
    *(pba_num + 10U) = (unsigned char)0U;
    #line 548 
    offset = (unsigned short)0U;
    #line 548 
    while ((unsigned int)offset <= 9U) {
      #line 549 
      if ((unsigned int)*(pba_num + (unsigned long)offset) <= 9U) 
                                                                  #line 550 
                                                                  *(pba_num + (unsigned long)offset) = (unsigned char)((unsigned int)*(pba_num + (unsigned long)offset) + 48U);
      else 
        #line 551 
        if ((unsigned int)*(pba_num + (unsigned long)offset) <= 15U) 
          #line 552 
          *(pba_num + (unsigned long)offset) = (unsigned char)((unsigned int)*(pba_num + (unsigned long)offset) + 55U);
      #line 548 
      offset = (u16)((int)offset + 1);
    }
    #line 555 
    return 0;
  }
  #line 558 
  ret_val = (*(hw->eeprom.ops.read))(hw,(unsigned short)((int)pba_ptr),& length);
  #line 559 
  if (ret_val != 0) {
    {
      #line 560 
      bool branch_4;
      #line 560 
      struct _ddebug __UNIQUE_ID_ddebug453 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_read_pba_string_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"NVM Read Error\n", .lineno = (unsigned int)560U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 560 
      branch_4 = arch_static_branch(& __UNIQUE_ID_ddebug453.key.dd_key_false.key,(_Bool)0);
      #line 560 
      if ((long)((long)((int)branch_4 != 0)) != 0L) 
                                                    #line 560 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug453,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"NVM Read Error\n");
    }
    #line 561 
    return ret_val;
  }
  #line 564 
  if ((unsigned int)length + 65535U > 65533U) {
    {
      #line 565 
      bool branch_5;
      #line 565 
      struct _ddebug __UNIQUE_ID_ddebug454 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_read_pba_string_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"NVM PBA number section invalid length\n", .lineno = (unsigned int)565U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 565 
      branch_5 = arch_static_branch(& __UNIQUE_ID_ddebug454.key.dd_key_false.key,(_Bool)0);
      #line 565 
      if ((long)((long)((int)branch_5 != 0)) != 0L) 
                                                    #line 565 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug454,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"NVM PBA number section invalid length\n");
    }
    #line 566 
    return -31;
  }
  #line 570 
  if ((unsigned int)length * 2U + 4294967295U > pba_num_size) {
    {
      #line 571 
      bool branch_6;
      #line 571 
      struct _ddebug __UNIQUE_ID_ddebug455 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_read_pba_string_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"PBA string buffer too small\n", .lineno = (unsigned int)571U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 571 
      branch_6 = arch_static_branch(& __UNIQUE_ID_ddebug455.key.dd_key_false.key,(_Bool)0);
      #line 571 
      if ((long)((long)((int)branch_6 != 0)) != 0L) 
                                                    #line 571 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug455,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"PBA string buffer too small\n");
    }
    #line 572 
    return -25;
  }
  #line 576 
  pba_ptr = (u16)((int)pba_ptr + 1);
  #line 577 
  length = (u16)((int)length - 1);
  #line 579 
  offset = (unsigned short)0U;
  #line 579 
  while ((int)offset < (int)length) {
    #line 580 
    ret_val = (*(hw->eeprom.ops.read))(hw,(unsigned short)((int)pba_ptr + (int)offset),& data);
    #line 581 
    if (ret_val != 0) {
      {
        #line 582 
        bool branch_7;
        #line 582 
        struct _ddebug __UNIQUE_ID_ddebug456 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_read_pba_string_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"NVM Read Error\n", .lineno = (unsigned int)582U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 582 
        branch_7 = arch_static_branch(& __UNIQUE_ID_ddebug456.key.dd_key_false.key,(_Bool)0);
        #line 582 
        if ((long)((long)((int)branch_7 != 0)) != 0L) 
                                                      #line 582 
                                                      __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug456,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"NVM Read Error\n");
      }
      #line 583 
      return ret_val;
    }
    #line 585 
    *(pba_num + (unsigned long)((int)offset * 2)) = (unsigned char)((int)data >> 8);
    #line 586 
    *(pba_num + ((unsigned long)((int)offset * 2) + (unsigned long)1U)) = (unsigned char)data;
    #line 579 
    offset = (u16)((int)offset + 1);
  }
  #line 588 
  *(pba_num + (unsigned long)((int)offset * 2)) = (unsigned char)0U;
  #line 590 
  return 0;
}

#line 602  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_get_mac_addr_generic(struct ixgbe_hw *hw, u8 *mac_addr)
{
  #line 604 
  u32 rar_high;
  #line 605 
  u32 rar_low;
  #line 606 
  u16 i;
  #line 608 
  rar_high = ixgbe_read_reg(hw,21508U);
  #line 609 
  rar_low = ixgbe_read_reg(hw,21504U);
  #line 611 
  i = (unsigned short)0U;
  #line 611 
  while ((unsigned int)i <= 3U) {
    #line 612 
    *(mac_addr + (unsigned long)i) = (unsigned char)(rar_low >> (int)i * 8);
    #line 611 
    i = (u16)((int)i + 1);
  }
  #line 614 
  i = (unsigned short)0U;
  #line 614 
  while ((unsigned int)i <= 1U) {
    #line 615 
    *(mac_addr + ((unsigned long)i + (unsigned long)4U)) = (unsigned char)(rar_high >> (int)i * 8);
    #line 614 
    i = (u16)((int)i + 1);
  }
  #line 617 
  return 0;
}

#line 620  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
enum ixgbe_bus_width ixgbe_convert_bus_width(u16 link_status)
{
  #line 622 
  switch ((int)link_status & 1008) {
    #line 623 
    case 16: 
             #line 623 
    ;
    #line 624 
    return ixgbe_bus_width_pcie_x1;
    #line 625 
    case 32: 
             #line 625 
    ;
    #line 626 
    return ixgbe_bus_width_pcie_x2;
    #line 627 
    case 64: 
             #line 627 
    ;
    #line 628 
    return ixgbe_bus_width_pcie_x4;
    #line 629 
    case 128: 
              #line 629 
    ;
    #line 630 
    return ixgbe_bus_width_pcie_x8;
    #line 631 
    default: 
             #line 631 
    ;
    #line 632 
    return ixgbe_bus_width_unknown;
  }
}

#line 636  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
enum ixgbe_bus_speed ixgbe_convert_bus_speed(u16 link_status)
{
  #line 638 
  switch ((int)link_status & 15) {
    #line 639 
    case 1: 
            #line 639 
    ;
    #line 640 
    return ixgbe_bus_speed_2500;
    #line 641 
    case 2: 
            #line 641 
    ;
    #line 642 
    return ixgbe_bus_speed_5000;
    #line 643 
    case 3: 
            #line 643 
    ;
    #line 644 
    return ixgbe_bus_speed_8000;
    #line 645 
    default: 
             #line 645 
    ;
    #line 646 
    return ixgbe_bus_speed_unknown;
  }
}

#line 656  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_get_bus_info_generic(struct ixgbe_hw *hw)
{
  #line 658 
  u16 link_status;
  #line 660 
  hw->bus.type = ixgbe_bus_type_pci_express;
  #line 663 
  link_status = ixgbe_read_pci_cfg_word(hw,178U);
  #line 665 
  hw->bus.width = ixgbe_convert_bus_width((unsigned short)((int)link_status));
  #line 666 
  hw->bus.speed = ixgbe_convert_bus_speed((unsigned short)((int)link_status));
  #line 668 
  (*(hw->mac.ops.set_lan_id))(hw);
  #line 670 
  return 0;
}

#line 680  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_set_lan_id_multi_port_pcie(struct ixgbe_hw *hw)
{
  #line 683 
  u16 ee_ctrl_4;
  #line 684 
  u32 reg;
  #line 682 
  struct ixgbe_bus_info *bus = & hw->bus;
  #line 686 
  reg = ixgbe_read_reg(hw,8U);
  #line 687 
  bus->func = (unsigned char)((unsigned int)((unsigned char)(reg >> 2)) & 3U);
  #line 688 
  bus->lan_id = bus->func;
  #line 691 
  reg = ixgbe_read_reg(hw,*(hw->mvals + 3U));
  #line 692 
  if ((reg & 1073741824U) != 0U) 
                                 #line 693 
                                 bus->func = (unsigned char)((unsigned int)bus->func ^ 1U);
  #line 696 
  if ((unsigned int)hw->device_id == 5582U) {
    #line 697 
    (*(hw->eeprom.ops.read))(hw,(unsigned short)69,& ee_ctrl_4);
    #line 698 
    bus->instance_id = (unsigned char)((unsigned int)((unsigned char)((int)ee_ctrl_4 >> 4)) & 1U);
  }
  #line 700 
  return;
}

#line 712  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_stop_adapter_generic(struct ixgbe_hw *hw)
{
  #line 714 
  u32 reg_val;
  #line 715 
  u16 i;
  #line 721 
  hw->adapter_stopped = (_Bool)1;
  #line 724 
  (*(hw->mac.ops.disable_rx))(hw);
  #line 727 
  ixgbe_write_reg_10(hw,2184U,4294967295U);
  #line 730 
  ixgbe_read_reg(hw,2048U);
  #line 733 
  i = (unsigned short)0U;
  #line 733 
  while ((unsigned int)i < hw->mac.max_tx_queues) {
    #line 734 
    ixgbe_write_reg_10(hw,(unsigned int)((int)i * 64 + 24616),67108864U);
    #line 733 
    i = (u16)((int)i + 1);
  }
  #line 737 
  i = (unsigned short)0U;
  #line 737 
  while ((unsigned int)i < hw->mac.max_rx_queues) {
    {
      #line 738 
      int tmp;
      #line 741 
      int tmp_0;
      #line 738 
      if ((unsigned int)i <= 63U) 
                                  #line 738 
                                  tmp = (int)i * 64 + 4136; else 
                                                                 #line 738 
                                                                 tmp = ((int)i + -64) * 64 + 53288;
      #line 738 
      ;
      #line 738 
      reg_val = ixgbe_read_reg(hw,(unsigned int)tmp);
      #line 739 
      reg_val &= 4261412863U;
      #line 740 
      reg_val |= 67108864U;
      #line 741 
      ;
      #line 741 
      if ((unsigned int)i <= 63U) 
                                  #line 741 
                                  tmp_0 = (int)i * 64 + 4136; else 
                                                                   #line 741 
                                                                   tmp_0 = ((int)i + -64) * 64 + 53288;
      #line 741 
      ;
      #line 741 
      ixgbe_write_reg_10(hw,(unsigned int)tmp_0,reg_val);
    }
    #line 737 
    i = (u16)((int)i + 1);
  }
  #line 745 
  ixgbe_read_reg(hw,8U);
  #line 746 
  usleep_range(1000UL,2000UL);
  #line 752 
  return ixgbe_disable_pcie_master(hw);
}

#line 762  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_init_led_link_act_generic(struct ixgbe_hw *hw)
{
  #line 765 
  u32 led_reg;
  #line 765 
  u32 led_mode;
  #line 766 
  u16 i;
  #line 764 
  struct ixgbe_mac_info *mac = & hw->mac;
  #line 768 
  led_reg = ixgbe_read_reg(hw,512U);
  #line 771 
  i = (unsigned short)0U;
  #line 771 
  while ((unsigned int)i <= 3U) {
    #line 772 
    led_mode = led_reg >> (int)i * 8;
    #line 774 
    if ((led_mode & 15U) == 4U) {
      #line 776 
      mac->led_link_act = (unsigned char)i;
      #line 777 
      return 0;
    }
    #line 771 
    i = (u16)((int)i + 1);
  }
  #line 784 
  switch ((unsigned int)hw->mac.type) {
    #line 785 
    case (unsigned int)6: 
                          #line 785 
    ;
    #line 786 
    mac->led_link_act = (unsigned char)0U;
    #line 787 
    break;
    #line 788 
    case (unsigned int)5: 
                          #line 788 
    ;
    #line 789 
    mac->led_link_act = (unsigned char)1U;
    #line 790 
    break;
    #line 791 
    default: 
             #line 791 
    ;
    #line 792 
    mac->led_link_act = (unsigned char)2U;
  }
  #line 795 
  return 0;
}

#line 803  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_led_on_generic(struct ixgbe_hw *hw, u32 index)
{
  #line 805 
  u32 led_reg = ixgbe_read_reg(hw,512U);
  #line 807 
  if (index > 3U) 
                  #line 808 
                  return -5;
  #line 811 
  led_reg = (unsigned int)(~ (15 << index * 8U)) & led_reg;
  #line 812 
  led_reg = (unsigned int)(14 << index * 8U) | led_reg;
  #line 813 
  ixgbe_write_reg_10(hw,512U,led_reg);
  #line 814 
  ixgbe_read_reg(hw,8U);
  #line 816 
  return 0;
}

#line 824  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_led_off_generic(struct ixgbe_hw *hw, u32 index)
{
  #line 826 
  u32 led_reg = ixgbe_read_reg(hw,512U);
  #line 828 
  if (index > 3U) 
                  #line 829 
                  return -5;
  #line 832 
  led_reg = (unsigned int)(~ (15 << index * 8U)) & led_reg;
  #line 833 
  led_reg = (unsigned int)(15 << index * 8U) | led_reg;
  #line 834 
  ixgbe_write_reg_10(hw,512U,led_reg);
  #line 835 
  ixgbe_read_reg(hw,8U);
  #line 837 
  return 0;
}

#line 847  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_init_eeprom_params_generic(struct ixgbe_hw *hw)
{
  #line 850 
  u32 eec;
  #line 851 
  u16 eeprom_size;
  #line 849 
  struct ixgbe_eeprom_info *eeprom = & hw->eeprom;
  #line 853 
  if (eeprom->type == (unsigned int)ixgbe_eeprom_uninitialized) {
    #line 854 
    eeprom->type = ixgbe_eeprom_none;
    #line 857 
    eeprom->semaphore_delay = 10U;
    #line 859 
    eeprom->word_page_size = (unsigned short)0U;
    #line 865 
    eec = ixgbe_read_reg(hw,*(hw->mvals));
    #line 866 
    if ((eec & 256U) != 0U) {
      #line 867 
      eeprom->type = ixgbe_eeprom_spi;
      #line 873 
      eeprom_size = (unsigned short)((unsigned int)((unsigned short)(eec >> 11)) & 15U);
      #line 875 
      eeprom->word_size = (unsigned short)(1UL << ((int)eeprom_size + 6));
    }
    #line 879 
    if ((eec & 1024U) != 0U) 
                             #line 880 
                             eeprom->address_bits = (unsigned short)16U; else 
                                                                    #line 882 
                                                                    eeprom->address_bits = (unsigned short)8U;
    {
      #line 883 
      bool branch;
      #line 883 
      struct _ddebug __UNIQUE_ID_ddebug457 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_init_eeprom_params_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Eeprom params: type = %d, size = %d, address bits: %d\n", .lineno = (unsigned int)883U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 883 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug457.key.dd_key_false.key,(_Bool)0);
      #line 883 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 883 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug457,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Eeprom params: type = %d, size = %d, address bits: %d\n",(unsigned int)eeprom->type,(int)eeprom->word_size,(int)eeprom->address_bits);
    }
  }
  #line 887 
  return 0;
}

#line 899  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_write_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw, u16 offset, u16 words, u16 *data)
{
  #line 902 
  s32 status;
  #line 903 
  u16 i;
  #line 903 
  u16 count;
  #line 905 
  (*(hw->eeprom.ops.init_params))(hw);
  #line 907 
  if ((unsigned int)words == 0U) 
                                 #line 908 
                                 return -32;
  #line 910 
  if ((int)offset + (int)words > (int)hw->eeprom.word_size) 
                                                            #line 911 
                                                            return -1;
  #line 917 
  if ((unsigned int)hw->eeprom.word_page_size == 0U && (unsigned int)words > 128U) 
    #line 919 
    ixgbe_detect_eeprom_page_size_generic(hw,(unsigned short)((int)offset));
  #line 926 
  i = (unsigned short)0U;
  #line 926 
  while ((int)i < (int)words) {
    {
      #line 927 
      int tmp;
      #line 927 
      if (512 < (int)words - (int)i) 
                                     #line 927 
                                     tmp = 512; else 
                                                     #line 927 
                                                     tmp = (int)words - (int)i;
      #line 927 
      count = (unsigned short)tmp;
      #line 929 
      status = ixgbe_write_eeprom_buffer_bit_bang(hw,(unsigned short)((int)offset + (int)i),(unsigned short)((int)count),data + (unsigned long)i);
      #line 932 
      if (status != 0) 
                       #line 933 
                       break;
    }
    #line 926 
    i = (unsigned short)((unsigned int)i + 512U);
  }
  #line 936 
  return status;
}

#line 949  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_write_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, u16 offset, u16 words, u16 *data)
{
  #line 952 
  s32 status;
  #line 953 
  u16 word;
  #line 954 
  u16 page_size;
  #line 955 
  u16 i;
  #line 956 
  u8 write_opcode = (unsigned char)2U;
  #line 959 
  status = ixgbe_acquire_eeprom(hw);
  #line 960 
  if (status != 0) 
                   #line 961 
                   return status;
  #line 963 
  if (ixgbe_ready_eeprom(hw) != 0) {
    #line 964 
    ixgbe_release_eeprom(hw);
    #line 965 
    return -1;
  }
  #line 968 
  i = (unsigned short)0U;
  #line 968 
  while ((int)i < (int)words) {
    #line 969 
    ixgbe_standby_eeprom(hw);
    #line 972 
    ixgbe_shift_out_eeprom_bits(hw,(unsigned short)6,(unsigned short)8);
    #line 976 
    ixgbe_standby_eeprom(hw);
    #line 981 
    if ((unsigned int)hw->eeprom.address_bits == 8U && (int)offset + (int)i > 127) 
      #line 983 
      write_opcode = (unsigned char)((unsigned int)write_opcode | 8U);
    #line 986 
    ixgbe_shift_out_eeprom_bits(hw,(unsigned short)((int)write_opcode),(unsigned short)8);
    #line 988 
    ixgbe_shift_out_eeprom_bits(hw,(unsigned short)((int)((unsigned int)((int)offset + (int)i) * 2U)),(unsigned short)((int)hw->eeprom.address_bits));
    #line 991 
    page_size = hw->eeprom.word_page_size;
    #line 994 
    while (1) {
      #line 995 
      word = *(data + (unsigned long)i);
      #line 996 
      word = (unsigned short)(((int)word >> 8) | ((int)word << 8));
      #line 997 
      ixgbe_shift_out_eeprom_bits(hw,(unsigned short)((int)word),(unsigned short)16);
      #line 999 
      if ((unsigned int)page_size == 0U) 
                                         #line 1000 
                                         break;
      #line 1003 
      if ((((int)offset + (int)i) & ((int)page_size + -1)) == (int)page_size + -1) 
        #line 1005 
        break;
      #line 1006 
      i = (u16)((int)i + 1);
      #line 1006 
      ;
      #line 1006 
      if (! ((int)i < (int)words)) 
                                   #line 994 
                                   break;
    }
    #line 1008 
    ixgbe_standby_eeprom(hw);
    #line 1009 
    usleep_range(10000UL,20000UL);
    #line 968 
    i = (u16)((int)i + 1);
  }
  #line 1012 
  ixgbe_release_eeprom(hw);
  #line 1014 
  return 0;
}

#line 1026  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_write_eeprom_generic(struct ixgbe_hw *hw, u16 offset, u16 data)
{
  #line 1028 
  (*(hw->eeprom.ops.init_params))(hw);
  #line 1030 
  if ((int)hw->eeprom.word_size <= (int)offset) 
                                                #line 1031 
                                                return -1;
  #line 1033 
  return ixgbe_write_eeprom_buffer_bit_bang(hw,(unsigned short)((int)offset),
                                         (unsigned short)1,& data);
}

#line 1045  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_read_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw, u16 offset, u16 words, u16 *data)
{
  #line 1048 
  s32 status;
  #line 1049 
  u16 i;
  #line 1049 
  u16 count;
  #line 1051 
  (*(hw->eeprom.ops.init_params))(hw);
  #line 1053 
  if ((unsigned int)words == 0U) 
                                 #line 1054 
                                 return -32;
  #line 1056 
  if ((int)offset + (int)words > (int)hw->eeprom.word_size) 
                                                            #line 1057 
                                                            return -1;
  #line 1064 
  i = (unsigned short)0U;
  #line 1064 
  while ((int)i < (int)words) {
    {
      #line 1065 
      int tmp;
      #line 1065 
      if (512 < (int)words - (int)i) 
                                     #line 1065 
                                     tmp = 512; else 
                                                     #line 1065 
                                                     tmp = (int)words - (int)i;
      #line 1065 
      count = (unsigned short)tmp;
      #line 1068 
      status = ixgbe_read_eeprom_buffer_bit_bang(hw,(unsigned short)((int)offset + (int)i),(unsigned short)((int)count),data + (unsigned long)i);
      #line 1071 
      if (status != 0) 
                       #line 1072 
                       return status;
    }
    #line 1064 
    i = (unsigned short)((unsigned int)i + 512U);
  }
  #line 1075 
  return 0;
}

#line 1087  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_read_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, u16 offset, u16 words, u16 *data)
{
  #line 1090 
  s32 status;
  #line 1091 
  u16 word_in;
  #line 1093 
  u16 i;
  #line 1092 
  u8 read_opcode = (unsigned char)3U;
  #line 1096 
  status = ixgbe_acquire_eeprom(hw);
  #line 1097 
  if (status != 0) 
                   #line 1098 
                   return status;
  #line 1100 
  if (ixgbe_ready_eeprom(hw) != 0) {
    #line 1101 
    ixgbe_release_eeprom(hw);
    #line 1102 
    return -1;
  }
  #line 1105 
  i = (unsigned short)0U;
  #line 1105 
  while ((int)i < (int)words) {
    #line 1106 
    ixgbe_standby_eeprom(hw);
    #line 1110 
    if ((unsigned int)hw->eeprom.address_bits == 8U && (int)offset + (int)i > 127) 
      #line 1112 
      read_opcode = (unsigned char)((unsigned int)read_opcode | 8U);
    #line 1115 
    ixgbe_shift_out_eeprom_bits(hw,(unsigned short)((int)read_opcode),(unsigned short)8);
    #line 1117 
    ixgbe_shift_out_eeprom_bits(hw,(unsigned short)((int)((unsigned int)((int)offset + (int)i) * 2U)),(unsigned short)((int)hw->eeprom.address_bits));
    #line 1121 
    word_in = ixgbe_shift_in_eeprom_bits(hw,(unsigned short)16);
    #line 1122 
    *(data + (unsigned long)i) = (unsigned short)(((int)word_in >> 8) | ((int)word_in << 8));
    #line 1105 
    i = (u16)((int)i + 1);
  }
  #line 1126 
  ixgbe_release_eeprom(hw);
  #line 1128 
  return 0;
}

#line 1139  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_read_eeprom_bit_bang_generic(struct ixgbe_hw *hw, u16 offset, u16 *data)
{
  #line 1142 
  (*(hw->eeprom.ops.init_params))(hw);
  #line 1144 
  if ((int)hw->eeprom.word_size <= (int)offset) 
                                                #line 1145 
                                                return -1;
  #line 1147 
  return ixgbe_read_eeprom_buffer_bit_bang(hw,(unsigned short)((int)offset),
                                        (unsigned short)1,data);
}

#line 1159  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_read_eerd_buffer_generic(struct ixgbe_hw *hw, u16 offset, u16 words, u16 *data)
{
  #line 1162 
  u32 eerd;
  #line 1163 
  s32 status;
  #line 1164 
  u32 i;
  #line 1166 
  (*(hw->eeprom.ops.init_params))(hw);
  #line 1168 
  if ((unsigned int)words == 0U) 
                                 #line 1169 
                                 return -32;
  #line 1171 
  if ((int)hw->eeprom.word_size <= (int)offset) 
                                                #line 1172 
                                                return -1;
  #line 1174 
  i = 0U;
  #line 1174 
  while ((unsigned int)words > i) {
    #line 1175 
    eerd = (((unsigned int)offset + i) << 2) | 1U;
    #line 1178 
    ixgbe_write_reg_10(hw,65556U,eerd);
    #line 1179 
    status = ixgbe_poll_eerd_eewr_done(hw,0U);
    #line 1181 
    if (status == 0) {
      #line 1182 
      *(data + (unsigned long)i) = (unsigned short)(ixgbe_read_reg(hw,65556U) >> 16);
    }
    else {
      {
        #line 1185 
        bool branch;
        #line 1185 
        struct _ddebug __UNIQUE_ID_ddebug458 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_read_eerd_buffer_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Eeprom read timed out\n", .lineno = (unsigned int)1185U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 1185 
        branch = arch_static_branch(& __UNIQUE_ID_ddebug458.key.dd_key_false.key,(_Bool)0);
        #line 1185 
        if ((long)((long)((int)branch != 0)) != 0L) 
                                                    #line 1185 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug458,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Eeprom read timed out\n");
      }
      #line 1186 
      return status;
    }
    #line 1174 
    i ++;
  }
  #line 1190 
  return 0;
}

#line 1202  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_detect_eeprom_page_size_generic(struct ixgbe_hw *hw, u16 offset)
{
  #line 1205 
  u16 data[128U];
  #line 1206 
  s32 status;
  #line 1207 
  u16 i;
  #line 1209 
  i = (unsigned short)0U;
  #line 1209 
  while ((unsigned int)i <= 127U) {
    #line 1210 
    data[(int)i] = i;
    #line 1209 
    i = (u16)((int)i + 1);
  }
  #line 1212 
  hw->eeprom.word_page_size = (unsigned short)128U;
  #line 1213 
  status = ixgbe_write_eeprom_buffer_bit_bang(hw,(unsigned short)((int)offset),(unsigned short)128,(u16 *)(& data));
  #line 1215 
  hw->eeprom.word_page_size = (unsigned short)0U;
  #line 1216 
  if (status != 0) 
                   #line 1217 
                   return status;
  #line 1219 
  status = ixgbe_read_eeprom_buffer_bit_bang(hw,(unsigned short)((int)offset),(unsigned short)1,(u16 *)(& data));
  #line 1220 
  if (status != 0) 
                   #line 1221 
                   return status;
  #line 1227 
  hw->eeprom.word_page_size = (unsigned short)(128U - (unsigned int)data[0]);
  {
    #line 1229 
    bool branch;
    #line 1229 
    struct _ddebug __UNIQUE_ID_ddebug459 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_detect_eeprom_page_size_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Detected EEPROM page size = %d words.\n", .lineno = (unsigned int)1229U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 1229 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug459.key.dd_key_false.key,(_Bool)0);
    #line 1229 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 1229 
                                                __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug459,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Detected EEPROM page size = %d words.\n",(int)hw->eeprom.word_page_size);
  }
  #line 1231 
  return 0;
}

#line 1242  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_read_eerd_generic(struct ixgbe_hw *hw, u16 offset, u16 *data)
{
  #line 1244 
  return ixgbe_read_eerd_buffer_generic(hw,(unsigned short)((int)offset),
                                     (unsigned short)1,data);
}

#line 1256  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_write_eewr_buffer_generic(struct ixgbe_hw *hw, u16 offset, u16 words, u16 *data)
{
  #line 1259 
  u32 eewr;
  #line 1260 
  s32 status;
  #line 1261 
  u16 i;
  #line 1263 
  (*(hw->eeprom.ops.init_params))(hw);
  #line 1265 
  if ((unsigned int)words == 0U) 
                                 #line 1266 
                                 return -32;
  #line 1268 
  if ((int)hw->eeprom.word_size <= (int)offset) 
                                                #line 1269 
                                                return -1;
  #line 1271 
  i = (unsigned short)0U;
  #line 1271 
  while ((int)i < (int)words) {
    #line 1272 
    eewr = (unsigned int)(((((int)offset + (int)i) << 2) | ((int)*(data + (unsigned long)i) << 16)) | 1);
    #line 1276 
    status = ixgbe_poll_eerd_eewr_done(hw,1U);
    #line 1277 
    if (status != 0) {
      {
        #line 1278 
        bool branch;
        #line 1278 
        struct _ddebug __UNIQUE_ID_ddebug460 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_write_eewr_buffer_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Eeprom write EEWR timed out\n", .lineno = (unsigned int)1278U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 1278 
        branch = arch_static_branch(& __UNIQUE_ID_ddebug460.key.dd_key_false.key,(_Bool)0);
        #line 1278 
        if ((long)((long)((int)branch != 0)) != 0L) 
                                                    #line 1278 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug460,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Eeprom write EEWR timed out\n");
      }
      #line 1279 
      return status;
    }
    #line 1282 
    ixgbe_write_reg_10(hw,65560U,eewr);
    #line 1284 
    status = ixgbe_poll_eerd_eewr_done(hw,1U);
    #line 1285 
    if (status != 0) {
      {
        #line 1286 
        bool branch_0;
        #line 1286 
        struct _ddebug __UNIQUE_ID_ddebug461 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_write_eewr_buffer_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Eeprom write EEWR timed out\n", .lineno = (unsigned int)1286U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 1286 
        branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug461.key.dd_key_false.key,(_Bool)0);
        #line 1286 
        if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                      #line 1286 
                                                      __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug461,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Eeprom write EEWR timed out\n");
      }
      #line 1287 
      return status;
    }
    #line 1271 
    i = (u16)((int)i + 1);
  }
  #line 1291 
  return 0;
}

#line 1302  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_write_eewr_generic(struct ixgbe_hw *hw, u16 offset, u16 data)
{
  #line 1304 
  return ixgbe_write_eewr_buffer_generic(hw,(unsigned short)((int)offset),
                                      (unsigned short)1,& data);
}

#line 1315  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_poll_eerd_eewr_done(struct ixgbe_hw *hw, u32 ee_reg)
{
  #line 1317 
  u32 i;
  #line 1318 
  u32 reg;
  #line 1320 
  i = 0U;
  #line 1320 
  while (i <= 99999U) {
    #line 1321 
    if (ee_reg == 0U) 
                      #line 1322 
                      reg = ixgbe_read_reg(hw,65556U); else 
                                                            #line 1324 
                                                            reg = ixgbe_read_reg(hw,65560U);
    #line 1326 
    if ((reg & 2U) != 0U) 
                          #line 1327 
                          return 0;
    #line 1329 
    __const_udelay(21475UL);
    #line 1320 
    i ++;
  }
  #line 1331 
  return -1;
}

#line 1341  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_acquire_eeprom(struct ixgbe_hw *hw)
{
  #line 1343 
  u32 eec;
  #line 1344 
  u32 i;
  #line 1346 
  if ((*(hw->mac.ops.acquire_swfw_sync))(hw,1U) != 0) 
                                                      #line 1347 
                                                      return -16;
  #line 1349 
  eec = ixgbe_read_reg(hw,*(hw->mvals));
  #line 1352 
  eec |= 64U;
  #line 1353 
  ixgbe_write_reg_10(hw,*(hw->mvals),eec);
  #line 1355 
  i = 0U;
  #line 1355 
  while (i <= 999U) {
    #line 1356 
    eec = ixgbe_read_reg(hw,*(hw->mvals));
    #line 1357 
    if ((eec & 128U) != 0U) 
                            #line 1358 
                            break;
    #line 1359 
    __const_udelay(21475UL);
    #line 1355 
    i ++;
  }
  #line 1363 
  if ((eec & 128U) == 0U) {
    #line 1364 
    eec &= 4294967231U;
    #line 1365 
    ixgbe_write_reg_10(hw,*(hw->mvals),eec);
    {
      #line 1366 
      bool branch;
      #line 1366 
      struct _ddebug __UNIQUE_ID_ddebug462 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_acquire_eeprom", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Could not acquire EEPROM grant\n", .lineno = (unsigned int)1366U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1366 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug462.key.dd_key_false.key,(_Bool)0);
      #line 1366 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 1366 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug462,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Could not acquire EEPROM grant\n");
    }
    #line 1368 
    (*(hw->mac.ops.release_swfw_sync))(hw,1U);
    #line 1369 
    return -1;
  }
  #line 1374 
  eec &= 4294967292U;
  #line 1375 
  ixgbe_write_reg_10(hw,*(hw->mvals),eec);
  #line 1376 
  ixgbe_read_reg(hw,8U);
  #line 1377 
  __const_udelay(4295UL);
  #line 1378 
  return 0;
}

#line 1387  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw)
{
  #line 1390 
  u32 i;
  #line 1391 
  u32 swsm;
  #line 1389 
  u32 timeout = 2000U;
  #line 1394 
  i = 0U;
  #line 1394 
  while (i < timeout) {
    #line 1399 
    swsm = ixgbe_read_reg(hw,*(hw->mvals + 4U));
    #line 1400 
    if ((swsm & 1U) == 0U) 
                           #line 1401 
                           break;
    #line 1402 
    usleep_range(50UL,100UL);
    #line 1394 
    i ++;
  }
  #line 1405 
  if (i == timeout) {
    {
      #line 1406 
      bool branch;
      #line 1406 
      struct _ddebug __UNIQUE_ID_ddebug463 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_get_eeprom_semaphore", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Driver can\'t access the Eeprom - SMBI Semaphore not granted.\n", .lineno = (unsigned int)1406U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1406 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug463.key.dd_key_false.key,(_Bool)0);
      #line 1406 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 1406 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug463,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Driver can\'t access the Eeprom - SMBI Semaphore not granted.\n");
    }
    #line 1412 
    ixgbe_release_eeprom_semaphore(hw);
    #line 1414 
    usleep_range(50UL,100UL);
    #line 1419 
    swsm = ixgbe_read_reg(hw,*(hw->mvals + 4U));
    #line 1420 
    if ((swsm & 1U) != 0U) {
      {
        #line 1421 
        bool branch_0;
        #line 1421 
        struct _ddebug __UNIQUE_ID_ddebug464 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_get_eeprom_semaphore", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Software semaphore SMBI between device drivers not granted.\n", .lineno = (unsigned int)1421U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 1421 
        branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug464.key.dd_key_false.key,(_Bool)0);
        #line 1421 
        if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                      #line 1421 
                                                      __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug464,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Software semaphore SMBI between device drivers not granted.\n");
      }
      #line 1422 
      return -1;
    }
  }
  #line 1427 
  i = 0U;
  #line 1427 
  while (i < timeout) {
    #line 1428 
    swsm = ixgbe_read_reg(hw,*(hw->mvals + 4U));
    #line 1431 
    swsm |= 2U;
    #line 1432 
    ixgbe_write_reg_10(hw,*(hw->mvals + 4U),swsm);
    #line 1437 
    swsm = ixgbe_read_reg(hw,*(hw->mvals + 4U));
    #line 1438 
    if ((swsm & 2U) != 0U) 
                           #line 1439 
                           break;
    #line 1441 
    usleep_range(50UL,100UL);
    #line 1427 
    i ++;
  }
  #line 1447 
  if (i >= timeout) {
    {
      #line 1448 
      bool branch_1;
      #line 1448 
      struct _ddebug __UNIQUE_ID_ddebug465 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_get_eeprom_semaphore", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"SWESMBI Software EEPROM semaphore not granted.\n", .lineno = (unsigned int)1448U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1448 
      branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug465.key.dd_key_false.key,(_Bool)0);
      #line 1448 
      if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                    #line 1448 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug465,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"SWESMBI Software EEPROM semaphore not granted.\n");
    }
    #line 1449 
    ixgbe_release_eeprom_semaphore(hw);
    #line 1450 
    return -1;
  }
  #line 1453 
  return 0;
}

#line 1462  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static void ixgbe_release_eeprom_semaphore(struct ixgbe_hw *hw)
{
  #line 1464 
  u32 swsm;
  #line 1466 
  swsm = ixgbe_read_reg(hw,*(hw->mvals + 4U));
  #line 1469 
  swsm &= 4294967292U;
  #line 1470 
  ixgbe_write_reg_10(hw,*(hw->mvals + 4U),swsm);
  #line 1471 
  ixgbe_read_reg(hw,8U);
  #line 1472 
  return;
}

#line 1478  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_ready_eeprom(struct ixgbe_hw *hw)
{
  #line 1480 
  u16 i;
  #line 1481 
  u8 spi_stat_reg;
  #line 1489 
  i = (unsigned short)0U;
  #line 1489 
  while ((unsigned int)i <= 4999U) {
    {
      #line 1490 
      ixgbe_shift_out_eeprom_bits(hw,(unsigned short)5,(unsigned short)8);
      #line 1492 
      spi_stat_reg = (unsigned char)ixgbe_shift_in_eeprom_bits(hw,(unsigned short)8);
      #line 1493 
      if (((int)spi_stat_reg & 1) == 0) 
                                        #line 1494 
                                        break;
      #line 1496 
      __const_udelay(21475UL);
      #line 1497 
      ixgbe_standby_eeprom(hw);
    }
    #line 1489 
    i = (unsigned short)((unsigned int)i + 5U);
  }
  #line 1504 
  if ((unsigned int)i > 4999U) {
    {
      #line 1505 
      bool branch;
      #line 1505 
      struct _ddebug __UNIQUE_ID_ddebug466 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_ready_eeprom", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"SPI EEPROM Status error\n", .lineno = (unsigned int)1505U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1505 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug466.key.dd_key_false.key,(_Bool)0);
      #line 1505 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 1505 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug466,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"SPI EEPROM Status error\n");
    }
    #line 1506 
    return -1;
  }
  #line 1509 
  return 0;
}

#line 1516  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static void ixgbe_standby_eeprom(struct ixgbe_hw *hw)
{
  #line 1518 
  u32 eec;
  #line 1520 
  eec = ixgbe_read_reg(hw,*(hw->mvals));
  #line 1523 
  eec |= 2U;
  #line 1524 
  ixgbe_write_reg_10(hw,*(hw->mvals),eec);
  #line 1525 
  ixgbe_read_reg(hw,8U);
  #line 1526 
  __const_udelay(4295UL);
  #line 1527 
  eec &= 4294967293U;
  #line 1528 
  ixgbe_write_reg_10(hw,*(hw->mvals),eec);
  #line 1529 
  ixgbe_read_reg(hw,8U);
  #line 1530 
  __const_udelay(4295UL);
  #line 1532 
  return;
}

#line 1539  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static void ixgbe_shift_out_eeprom_bits(struct ixgbe_hw *hw, u16 data, u16 count)
{
  #line 1542 
  u32 eec;
  #line 1543 
  u32 mask;
  #line 1544 
  u32 i;
  #line 1546 
  eec = ixgbe_read_reg(hw,*(hw->mvals));
  #line 1552 
  mask = (unsigned int)(1UL << ((int)count + -1));
  #line 1554 
  i = 0U;
  #line 1554 
  while ((unsigned int)count > i) {
    #line 1562 
    if (((unsigned int)data & mask) != 0U) 
                                           #line 1563 
                                           eec |= 4U; else 
                                                           #line 1565 
                                                           eec &= 4294967291U;
    #line 1567 
    ixgbe_write_reg_10(hw,*(hw->mvals),eec);
    #line 1568 
    ixgbe_read_reg(hw,8U);
    #line 1570 
    __const_udelay(4295UL);
    #line 1572 
    ixgbe_raise_eeprom_clk(hw,& eec);
    #line 1573 
    ixgbe_lower_eeprom_clk(hw,& eec);
    #line 1579 
    mask >>= 1;
    #line 1554 
    i ++;
  }
  #line 1583 
  eec &= 4294967291U;
  #line 1584 
  ixgbe_write_reg_10(hw,*(hw->mvals),eec);
  #line 1585 
  ixgbe_read_reg(hw,8U);
  #line 1586 
  return;
}

#line 1593  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static u16 ixgbe_shift_in_eeprom_bits(struct ixgbe_hw *hw, u16 count)
{
  #line 1595 
  u32 eec;
  #line 1596 
  u32 i;
  #line 1597 
  u16 data = (unsigned short)0U;
  #line 1606 
  eec = ixgbe_read_reg(hw,*(hw->mvals));
  #line 1608 
  eec &= 4294967283U;
  #line 1610 
  i = 0U;
  #line 1610 
  while ((unsigned int)count > i) {
    #line 1611 
    data = (unsigned short)((int)data << 1U);
    #line 1612 
    ixgbe_raise_eeprom_clk(hw,& eec);
    #line 1614 
    eec = ixgbe_read_reg(hw,*(hw->mvals));
    #line 1616 
    eec &= 4294967291U;
    #line 1617 
    if ((eec & 8U) != 0U) 
                          #line 1618 
                          data = (unsigned short)((unsigned int)data | 1U);
    #line 1620 
    ixgbe_lower_eeprom_clk(hw,& eec);
    #line 1610 
    i ++;
  }
  #line 1623 
  return data;
}

#line 1631  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static void ixgbe_raise_eeprom_clk(struct ixgbe_hw *hw, u32 *eec)
{
  #line 1637 
  *eec |= 1U;
  #line 1638 
  ixgbe_write_reg_10(hw,*(hw->mvals),*eec);
  #line 1639 
  ixgbe_read_reg(hw,8U);
  #line 1640 
  __const_udelay(4295UL);
  #line 1642 
  return;
}

#line 1648  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static void ixgbe_lower_eeprom_clk(struct ixgbe_hw *hw, u32 *eec)
{
  #line 1654 
  *eec &= 4294967294U;
  #line 1655 
  ixgbe_write_reg_10(hw,*(hw->mvals),*eec);
  #line 1656 
  ixgbe_read_reg(hw,8U);
  #line 1657 
  __const_udelay(4295UL);
  #line 1659 
  return;
}

#line 1664  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static void ixgbe_release_eeprom(struct ixgbe_hw *hw)
{
  #line 1666 
  u32 eec;
  #line 1668 
  eec = ixgbe_read_reg(hw,*(hw->mvals));
  #line 1670 
  eec |= 2U;
  #line 1671 
  eec &= 4294967294U;
  #line 1673 
  ixgbe_write_reg_10(hw,*(hw->mvals),eec);
  #line 1674 
  ixgbe_read_reg(hw,8U);
  #line 1676 
  __const_udelay(4295UL);
  #line 1679 
  eec &= 4294967231U;
  #line 1680 
  ixgbe_write_reg_10(hw,*(hw->mvals),eec);
  #line 1682 
  (*(hw->mac.ops.release_swfw_sync))(hw,1U);
  #line 1688 
  usleep_range((unsigned long)(hw->eeprom.semaphore_delay * 1000U),(unsigned long)(hw->eeprom.semaphore_delay * 2000U));
  #line 1690 
  return;
}

#line 1696  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_calc_eeprom_checksum_generic(struct ixgbe_hw *hw)
{
  #line 1698 
  u16 i;
  #line 1699 
  u16 j;
  #line 1700 
  u16 checksum = (unsigned short)0U;
  #line 1701 
  u16 length = (unsigned short)0U;
  #line 1702 
  u16 pointer = (unsigned short)0U;
  #line 1703 
  u16 word = (unsigned short)0U;
  #line 1706 
  i = (unsigned short)0U;
  #line 1706 
  while ((unsigned int)i <= 62U) {
    {
      #line 1707 
      if ((*(hw->eeprom.ops.read))(hw,(unsigned short)((int)i),& word) != 0) {
        {
          #line 1708 
          bool branch;
          #line 1708 
          struct _ddebug __UNIQUE_ID_ddebug467 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_calc_eeprom_checksum_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"EEPROM read failed\n", .lineno = (unsigned int)1708U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
          #line 1708 
          branch = arch_static_branch(& __UNIQUE_ID_ddebug467.key.dd_key_false.key,(_Bool)0);
          #line 1708 
          if ((long)((long)((int)branch != 0)) != 0L) 
                                                      #line 1708 
                                                      __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug467,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"EEPROM read failed\n");
        }
        #line 1709 
        break;
      }
      #line 1711 
      checksum = (unsigned short)((int)checksum + (int)word);
    }
    #line 1706 
    i = (u16)((int)i + 1);
  }
  #line 1715 
  i = (unsigned short)3U;
  #line 1715 
  while ((unsigned int)i <= 14U) {
    {
      #line 1716 
      if ((*(hw->eeprom.ops.read))(hw,(unsigned short)((int)i),& pointer) != 0) {
        {
          #line 1717 
          bool branch_0;
          #line 1717 
          struct _ddebug __UNIQUE_ID_ddebug468 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_calc_eeprom_checksum_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"EEPROM read failed\n", .lineno = (unsigned int)1717U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
          #line 1717 
          branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug468.key.dd_key_false.key,(_Bool)0);
          #line 1717 
          if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                        #line 1717 
                                                        __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug468,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"EEPROM read failed\n");
        }
        #line 1718 
        return -1;
      }
      #line 1722 
      if ((unsigned int)pointer + 65535U > 65533U) 
                                                   #line 1723 
                                                   goto __Cont;
      #line 1725 
      if ((*(hw->eeprom.ops.read))(hw,(unsigned short)((int)pointer),& length) != 0) {
        {
          #line 1726 
          bool branch_1;
          #line 1726 
          struct _ddebug __UNIQUE_ID_ddebug469 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_calc_eeprom_checksum_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"EEPROM read failed\n", .lineno = (unsigned int)1726U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
          #line 1726 
          branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug469.key.dd_key_false.key,(_Bool)0);
          #line 1726 
          if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                        #line 1726 
                                                        __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug469,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"EEPROM read failed\n");
        }
        #line 1727 
        return -1;
      }
      #line 1730 
      if ((unsigned int)length + 65535U > 65533U) 
                                                  #line 1731 
                                                  goto __Cont;
      #line 1733 
      j = (unsigned short)((unsigned int)pointer + 1U);
      #line 1733 
      while ((int)j <= (int)pointer + (int)length) {
        {
          #line 1734 
          if ((*(hw->eeprom.ops.read))(hw,(unsigned short)((int)j),& word) != 0) {
            {
              #line 1735 
              bool branch_2;
              #line 1735 
              struct _ddebug __UNIQUE_ID_ddebug470 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_calc_eeprom_checksum_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"EEPROM read failed\n", .lineno = (unsigned int)1735U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
              #line 1735 
              branch_2 = arch_static_branch(& __UNIQUE_ID_ddebug470.key.dd_key_false.key,(_Bool)0);
              #line 1735 
              if ((long)((long)((int)branch_2 != 0)) != 0L) 
                                                            #line 1735 
                                                            __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug470,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"EEPROM read failed\n");
            }
            #line 1736 
            return -1;
          }
          #line 1738 
          checksum = (unsigned short)((int)checksum + (int)word);
        }
        #line 1733 
        j = (u16)((int)j + 1);
      }
    }
    #line 1715 
    __Cont: 
            #line 1715 
    i = (u16)((int)i + 1);
  }
  #line 1742 
  checksum = (unsigned short)(47802U - (unsigned int)checksum);
  #line 1744 
  return (int)checksum;
}

#line 1755  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_validate_eeprom_checksum_generic(struct ixgbe_hw *hw, u16 *checksum_val)
{
  #line 1758 
  s32 status;
  #line 1759 
  u16 checksum;
  #line 1760 
  u16 read_checksum = (unsigned short)0U;
  #line 1767 
  status = (*(hw->eeprom.ops.read))(hw,(unsigned short)0,& checksum);
  #line 1768 
  if (status != 0) {
    {
      #line 1769 
      bool branch;
      #line 1769 
      struct _ddebug __UNIQUE_ID_ddebug471 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_validate_eeprom_checksum_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"EEPROM read failed\n", .lineno = (unsigned int)1769U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1769 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug471.key.dd_key_false.key,(_Bool)0);
      #line 1769 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 1769 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug471,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"EEPROM read failed\n");
    }
    #line 1770 
    return status;
  }
  #line 1773 
  status = (*(hw->eeprom.ops.calc_checksum))(hw);
  #line 1774 
  if (status < 0) 
                  #line 1775 
                  return status;
  #line 1777 
  checksum = (unsigned short)status;
  #line 1779 
  status = (*(hw->eeprom.ops.read))(hw,(unsigned short)63,& read_checksum);
  #line 1780 
  if (status != 0) {
    {
      #line 1781 
      bool branch_0;
      #line 1781 
      struct _ddebug __UNIQUE_ID_ddebug472 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_validate_eeprom_checksum_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"EEPROM read failed\n", .lineno = (unsigned int)1781U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1781 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug472.key.dd_key_false.key,(_Bool)0);
      #line 1781 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 1781 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug472,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"EEPROM read failed\n");
    }
    #line 1782 
    return status;
  }
  #line 1788 
  if ((int)read_checksum != (int)checksum) 
                                           #line 1789 
                                           status = -2;
  #line 1792 
  if (checksum_val != (u16 *)0U) 
                                 #line 1793 
                                 *checksum_val = checksum;
  #line 1795 
  return status;
}

#line 1802  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_update_eeprom_checksum_generic(struct ixgbe_hw *hw)
{
  #line 1804 
  s32 status;
  #line 1805 
  u16 checksum;
  #line 1812 
  status = (*(hw->eeprom.ops.read))(hw,(unsigned short)0,& checksum);
  #line 1813 
  if (status != 0) {
    {
      #line 1814 
      bool branch;
      #line 1814 
      struct _ddebug __UNIQUE_ID_ddebug473 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_update_eeprom_checksum_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"EEPROM read failed\n", .lineno = (unsigned int)1814U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1814 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug473.key.dd_key_false.key,(_Bool)0);
      #line 1814 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 1814 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug473,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"EEPROM read failed\n");
    }
    #line 1815 
    return status;
  }
  #line 1818 
  status = (*(hw->eeprom.ops.calc_checksum))(hw);
  #line 1819 
  if (status < 0) 
                  #line 1820 
                  return status;
  #line 1822 
  checksum = (unsigned short)status;
  #line 1824 
  status = (*(hw->eeprom.ops.write))(hw,(unsigned short)63,(unsigned short)((int)checksum));
  #line 1826 
  return status;
}

#line 1839  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_set_rar_generic(struct ixgbe_hw *hw, u32 index, u8 *addr, u32 vmdq, u32 enable_addr)
{
  #line 1842 
  u32 rar_low;
  #line 1842 
  u32 rar_high;
  #line 1867 
  u32 tmp_0;
  #line 1878 
  u32 tmp_1;
  #line 1880 
  u32 tmp_2;
  #line 1843 
  u32 rar_entries = hw->mac.num_rar_entries;
  #line 1846 
  if (index >= rar_entries) {
    {
      #line 1847 
      bool branch;
      #line 1847 
      struct _ddebug __UNIQUE_ID_ddebug474 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_set_rar_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"RAR index %d is out of range.\n", .lineno = (unsigned int)1847U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1847 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug474.key.dd_key_false.key,(_Bool)0);
      #line 1847 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 1847 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug474,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"RAR index %d is out of range.\n",index);
    }
    #line 1848 
    return -32;
  }
  #line 1852 
  (*(hw->mac.ops.set_vmdq))(hw,index,vmdq);
  #line 1858 
  rar_low = (((unsigned int)*addr | ((unsigned int)*(addr + 1U) << 8)) | ((unsigned int)*(addr + 2U) << 16)) | ((unsigned int)*(addr + 3U) << 24);
  #line 1867 
  if (index <= 15U) 
                    #line 1867 
                    tmp_0 = index * 8U + 21508U; else 
                                                      #line 1867 
                                                      tmp_0 = index * 8U + 41476U;
  #line 1867 
  ;
  #line 1867 
  rar_high = ixgbe_read_reg(hw,tmp_0);
  #line 1868 
  rar_high &= 2147418112U;
  #line 1869 
  rar_high = ((unsigned int)*(addr + 4U) | ((unsigned int)*(addr + 5U) << 8)) | rar_high;
  #line 1871 
  if (enable_addr != 0U) 
                         #line 1872 
                         rar_high |= 2147483648U;
  #line 1878 
  ;
  #line 1878 
  if (index <= 15U) 
                    #line 1878 
                    tmp_1 = (index + 2688U) * 8U; else 
                                                       #line 1878 
                                                       tmp_1 = (index + 5184U) * 8U;
  #line 1878 
  ;
  #line 1878 
  ixgbe_write_reg_10(hw,tmp_1,rar_low);
  #line 1879 
  ixgbe_read_reg(hw,8U);
  #line 1880 
  ;
  #line 1880 
  if (index <= 15U) 
                    #line 1880 
                    tmp_2 = index * 8U + 21508U; else 
                                                      #line 1880 
                                                      tmp_2 = index * 8U + 41476U;
  #line 1880 
  ;
  #line 1880 
  ixgbe_write_reg_10(hw,tmp_2,rar_high);
  #line 1882 
  return 0;
}

#line 1892  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_clear_rar_generic(struct ixgbe_hw *hw, u32 index)
{
  #line 1894 
  u32 rar_high;
  #line 1908 
  u32 tmp_0;
  #line 1915 
  u32 tmp_1;
  #line 1917 
  u32 tmp_2;
  #line 1895 
  u32 rar_entries = hw->mac.num_rar_entries;
  #line 1898 
  if (index >= rar_entries) {
    {
      #line 1899 
      bool branch;
      #line 1899 
      struct _ddebug __UNIQUE_ID_ddebug475 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_clear_rar_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"RAR index %d is out of range.\n", .lineno = (unsigned int)1899U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1899 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug475.key.dd_key_false.key,(_Bool)0);
      #line 1899 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 1899 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug475,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"RAR index %d is out of range.\n",index);
    }
    #line 1900 
    return -32;
  }
  #line 1908 
  if (index <= 15U) 
                    #line 1908 
                    tmp_0 = index * 8U + 21508U; else 
                                                      #line 1908 
                                                      tmp_0 = index * 8U + 41476U;
  #line 1908 
  ;
  #line 1908 
  rar_high = ixgbe_read_reg(hw,tmp_0);
  #line 1909 
  rar_high &= 2147418112U;
  #line 1915 
  ;
  #line 1915 
  if (index <= 15U) 
                    #line 1915 
                    tmp_1 = index * 8U + 21508U; else 
                                                      #line 1915 
                                                      tmp_1 = index * 8U + 41476U;
  #line 1915 
  ;
  #line 1915 
  ixgbe_write_reg_10(hw,tmp_1,rar_high);
  #line 1916 
  ixgbe_read_reg(hw,8U);
  #line 1917 
  if (index <= 15U) 
                    #line 1917 
                    tmp_2 = (index + 2688U) * 8U; else 
                                                       #line 1917 
                                                       tmp_2 = (index + 5184U) * 8U;
  #line 1917 
  ;
  #line 1917 
  ixgbe_write_reg_10(hw,tmp_2,0U);
  #line 1920 
  (*(hw->mac.ops.clear_vmdq))(hw,index,4294967295U);
  #line 1922 
  return 0;
}

#line 1933  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_init_rx_addrs_generic(struct ixgbe_hw *hw)
{
  #line 1935 
  u32 i;
  #line 1936 
  u32 rar_entries = hw->mac.num_rar_entries;
  #line 1943 
  if (is_valid_ether_addr((u8 *)(& hw->mac.addr))) {
    {
      #line 1950 
      bool branch_0;
      #line 1950 
      struct _ddebug __UNIQUE_ID_ddebug477 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_init_rx_addrs_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Overriding MAC Address in RAR[0]\n", .lineno = (unsigned int)1950U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1950 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug477.key.dd_key_false.key,(_Bool)0);
      #line 1950 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 1950 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug477,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Overriding MAC Address in RAR[0]\n");
    }
    {
      #line 1951 
      bool branch_1;
      #line 1951 
      struct _ddebug __UNIQUE_ID_ddebug478 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_init_rx_addrs_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)" New MAC Addr =%pM\n", .lineno = (unsigned int)1951U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1951 
      branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug478.key.dd_key_false.key,(_Bool)0);
      #line 1951 
      if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                    #line 1951 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug478,((struct ixgbe_adapter *)hw->back)->netdev,(char *)" New MAC Addr =%pM\n",(u8 *)(& hw->mac.addr));
    }
    #line 1953 
    (*(hw->mac.ops.set_rar))(hw,0U,(u8 *)(& hw->mac.addr),0U,2147483648U);
  }
  else {
    #line 1945 
    (*(hw->mac.ops.get_mac_addr))(hw,(u8 *)(& hw->mac.addr));
    {
      #line 1947 
      bool branch;
      #line 1947 
      struct _ddebug __UNIQUE_ID_ddebug476 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_init_rx_addrs_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)" Keeping Current RAR0 Addr =%pM\n", .lineno = (unsigned int)1947U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1947 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug476.key.dd_key_false.key,(_Bool)0);
      #line 1947 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 1947 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug476,((struct ixgbe_adapter *)hw->back)->netdev,(char *)" Keeping Current RAR0 Addr =%pM\n",(u8 *)(& hw->mac.addr));
    }
  }
  #line 1957 
  (*(hw->mac.ops.clear_vmdq))(hw,0U,4294967295U);
  #line 1959 
  hw->addr_ctrl.overflow_promisc = 0U;
  #line 1961 
  hw->addr_ctrl.rar_used_count = 1U;
  {
    #line 1964 
    bool branch_2;
    #line 1964 
    struct _ddebug __UNIQUE_ID_ddebug479 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_init_rx_addrs_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Clearing RAR[1-%d]\n", .lineno = (unsigned int)1964U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 1964 
    branch_2 = arch_static_branch(& __UNIQUE_ID_ddebug479.key.dd_key_false.key,(_Bool)0);
    #line 1964 
    if ((long)((long)((int)branch_2 != 0)) != 0L) 
                                                  #line 1964 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug479,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Clearing RAR[1-%d]\n",rar_entries + 4294967295U);
  }
  #line 1965 
  i = 1U;
  #line 1965 
  while (i < rar_entries) {
    {
      #line 1966 
      u32 tmp_4;
      #line 1967 
      u32 tmp_5;
      #line 1966 
      if (i <= 15U) 
                    #line 1966 
                    tmp_4 = (i + 2688U) * 8U; else 
                                                   #line 1966 
                                                   tmp_4 = (i + 5184U) * 8U;
      #line 1966 
      ;
      #line 1966 
      ixgbe_write_reg_10(hw,tmp_4,0U);
      #line 1967 
      if (i <= 15U) 
                    #line 1967 
                    tmp_5 = i * 8U + 21508U; else 
                                                  #line 1967 
                                                  tmp_5 = i * 8U + 41476U;
      #line 1967 
      ;
      #line 1967 
      ixgbe_write_reg_10(hw,tmp_5,0U);
    }
    #line 1965 
    i ++;
  }
  #line 1971 
  hw->addr_ctrl.mta_in_use = 0U;
  #line 1972 
  ixgbe_write_reg_10(hw,20624U,(unsigned int)hw->mac.mc_filter_type);
  {
    #line 1974 
    bool branch_3;
    #line 1974 
    struct _ddebug __UNIQUE_ID_ddebug480 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_init_rx_addrs_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)" Clearing MTA\n", .lineno = (unsigned int)1974U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 1974 
    branch_3 = arch_static_branch(& __UNIQUE_ID_ddebug480.key.dd_key_false.key,(_Bool)0);
    #line 1974 
    if ((long)((long)((int)branch_3 != 0)) != 0L) 
                                                  #line 1974 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug480,((struct ixgbe_adapter *)hw->back)->netdev,(char *)" Clearing MTA\n");
  }
  #line 1975 
  i = 0U;
  #line 1975 
  while (hw->mac.mcft_size > i) {
    #line 1976 
    ixgbe_write_reg_10(hw,(i + 5248U) * 4U,0U);
    #line 1975 
    i ++;
  }
  #line 1978 
  if (hw->mac.ops.init_uta_tables != (s32 (*)(struct ixgbe_hw *))0) 
                                                                    #line 1979 
                                                                    (*(hw->mac.ops.init_uta_tables))(hw);
  #line 1981 
  return 0;
}

#line 1996  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_mta_vector(struct ixgbe_hw *hw, u8 *mc_addr)
{
  #line 1998 
  u32 vector = 0U;
  #line 2000 
  switch (hw->mac.mc_filter_type) {
    #line 2001 
    case 0: 
            #line 2001 
    ;
    #line 2002 
    vector = (unsigned int)(((int)*(mc_addr + 4U) >> 4) | ((int)*(mc_addr + 5U) << 4));
    #line 2003 
    break;
    #line 2004 
    case 1: 
            #line 2004 
    ;
    #line 2005 
    vector = (unsigned int)(((int)*(mc_addr + 4U) >> 3) | ((int)*(mc_addr + 5U) << 5));
    #line 2006 
    break;
    #line 2007 
    case 2: 
            #line 2007 
    ;
    #line 2008 
    vector = (unsigned int)(((int)*(mc_addr + 4U) >> 2) | ((int)*(mc_addr + 5U) << 6));
    #line 2009 
    break;
    #line 2010 
    case 3: 
            #line 2010 
    ;
    #line 2011 
    vector = (unsigned int)((int)*(mc_addr + 4U) | ((int)*(mc_addr + 5U) << 8));
    #line 2012 
    break;
    #line 2013 
    default: 
             #line 2013 
    ;
    {
      #line 2014 
      bool branch;
      #line 2014 
      struct _ddebug __UNIQUE_ID_ddebug481 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_mta_vector", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"MC filter type param set incorrectly\n", .lineno = (unsigned int)2014U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 2014 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug481.key.dd_key_false.key,(_Bool)0);
      #line 2014 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 2014 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug481,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"MC filter type param set incorrectly\n");
    }
    #line 2015 
    break;
  }
  #line 2019 
  vector &= 4095U;
  #line 2020 
  return (int)vector;
}

#line 2030  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static void ixgbe_set_mta(struct ixgbe_hw *hw, u8 *mc_addr)
{
  #line 2032 
  u32 vector;
  #line 2033 
  u32 vector_bit;
  #line 2034 
  u32 vector_reg;
  #line 2036 
  (hw->addr_ctrl.mta_in_use) ++;
  #line 2038 
  vector = (unsigned int)ixgbe_mta_vector(hw,mc_addr);
  {
    #line 2039 
    bool branch;
    #line 2039 
    struct _ddebug __UNIQUE_ID_ddebug482 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_set_mta", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)" bit-vector = 0x%03X\n", .lineno = (unsigned int)2039U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 2039 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug482.key.dd_key_false.key,(_Bool)0);
    #line 2039 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 2039 
                                                __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug482,((struct ixgbe_adapter *)hw->back)->netdev,(char *)" bit-vector = 0x%03X\n",vector);
  }
  #line 2050 
  vector_reg = (vector >> 5) & 127U;
  #line 2051 
  vector_bit = vector & 31U;
  #line 2052 
  hw->mac.mta_shadow[vector_reg] |= (unsigned int)(1UL << vector_bit);
  #line 2053 
  return;
}

#line 2065  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_update_mc_addr_list_generic(struct ixgbe_hw *hw, struct net_device *netdev)
{
  #line 2083 
  void *__mptr;
  #line 2068 
  struct netdev_hw_addr *ha;
  #line 2069 
  u32 i;
  #line 2075 
  hw->addr_ctrl.num_mc_addrs = (unsigned int)netdev->mc.count;
  #line 2076 
  hw->addr_ctrl.mta_in_use = 0U;
  {
    #line 2079 
    bool branch;
    #line 2079 
    struct _ddebug __UNIQUE_ID_ddebug483 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_update_mc_addr_list_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)" Clearing MTA\n", .lineno = (unsigned int)2079U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 2079 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug483.key.dd_key_false.key,(_Bool)0);
    #line 2079 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 2079 
                                                __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug483,((struct ixgbe_adapter *)hw->back)->netdev,(char *)" Clearing MTA\n");
  }
  #line 2080 
  memset((void *)(& hw->mac.mta_shadow),0,512UL);
  #line 2083 
  __mptr = (void *)netdev->mc.list.next;
  #line 2083 
  ha = ((struct netdev_hw_addr *)__mptr);
  #line 2083 
  while (& ha->list != & netdev->mc.list) {
    #line 2083 
    void *__mptr_0;
    {
      #line 2084 
      bool branch_0;
      #line 2084 
      struct _ddebug __UNIQUE_ID_ddebug484 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_update_mc_addr_list_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)" Adding the multicast addresses:\n", .lineno = (unsigned int)2084U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 2084 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug484.key.dd_key_false.key,(_Bool)0);
      #line 2084 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 2084 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug484,((struct ixgbe_adapter *)hw->back)->netdev,(char *)" Adding the multicast addresses:\n");
    }
    #line 2085 
    ixgbe_set_mta(hw,(u8 *)(& ha->addr));
    #line 2083 
    __mptr_0 = (void *)ha->list.next;
    #line 2083 
    ha = ((struct netdev_hw_addr *)__mptr_0);
  }
  #line 2089 
  i = 0U;
  #line 2089 
  while (hw->mac.mcft_size > i) {
    #line 2090 
    ixgbe_write_reg_10(hw,(i << 2) + 20992U,hw->mac.mta_shadow[i]);
    #line 2089 
    i ++;
  }
  #line 2093 
  if (hw->addr_ctrl.mta_in_use != 0U) 
                                      #line 2094 
                                      ixgbe_write_reg_10(hw,20624U,(unsigned int)(hw->mac.mc_filter_type | 4));
  {
    #line 2097 
    bool branch_1;
    #line 2097 
    struct _ddebug __UNIQUE_ID_ddebug485 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_update_mc_addr_list_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"ixgbe_update_mc_addr_list_generic Complete\n", .lineno = (unsigned int)2097U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 2097 
    branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug485.key.dd_key_false.key,(_Bool)0);
    #line 2097 
    if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                  #line 2097 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug485,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"ixgbe_update_mc_addr_list_generic Complete\n");
  }
  #line 2098 
  return 0;
}

#line 2107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_enable_mc_generic(struct ixgbe_hw *hw)
{
  #line 2109 
  struct ixgbe_addr_filter_info *a = & hw->addr_ctrl;
  #line 2111 
  if (a->mta_in_use != 0U) 
                           #line 2112 
                           ixgbe_write_reg_10(hw,20624U,(unsigned int)(hw->mac.mc_filter_type | 4));
  #line 2115 
  return 0;
}

#line 2124  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_disable_mc_generic(struct ixgbe_hw *hw)
{
  #line 2126 
  struct ixgbe_addr_filter_info *a = & hw->addr_ctrl;
  #line 2128 
  if (a->mta_in_use != 0U) 
                           #line 2129 
                           ixgbe_write_reg_10(hw,20624U,(unsigned int)hw->mac.mc_filter_type);
  #line 2131 
  return 0;
}

#line 2140  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_fc_enable_generic(struct ixgbe_hw *hw)
{
  #line 2142 
  u32 mflcn_reg;
  #line 2142 
  u32 fccfg_reg;
  #line 2143 
  u32 reg;
  #line 2144 
  u32 fcrtl;
  #line 2144 
  u32 fcrth;
  #line 2145 
  int i;
  #line 2148 
  if ((unsigned int)hw->fc.pause_time == 0U) 
                                             #line 2149 
                                             return -13;
  #line 2152 
  i = 0;
  #line 2152 
  while (i <= 7) {
    #line 2153 
    if (((unsigned int)hw->fc.current_mode & 2U) != 0U && hw->fc.high_water[i] != 0U) 
      #line 2155 
      if (hw->fc.low_water[i] == 0U || hw->fc.low_water[i] >= hw->fc.high_water[i]) {
        {
          #line 2157 
          bool branch;
          #line 2157 
          struct _ddebug __UNIQUE_ID_ddebug486 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_fc_enable_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Invalid water mark configuration\n", .lineno = (unsigned int)2157U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
          #line 2157 
          branch = arch_static_branch(& __UNIQUE_ID_ddebug486.key.dd_key_false.key,(_Bool)0);
          #line 2157 
          if ((long)((long)((int)branch != 0)) != 0L) 
                                                      #line 2157 
                                                      __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug486,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Invalid water mark configuration\n");
        }
        #line 2158 
        return -13;
      }
    #line 2152 
    i ++;
  }
  #line 2164 
  (*(hw->mac.ops.fc_autoneg))(hw);
  #line 2167 
  mflcn_reg = ixgbe_read_reg(hw,17044U);
  #line 2168 
  mflcn_reg &= 4294963203U;
  #line 2170 
  fccfg_reg = ixgbe_read_reg(hw,15616U);
  #line 2171 
  fccfg_reg &= 4294967271U;
  #line 2183 
  switch ((unsigned int)hw->fc.current_mode) {
    #line 2184 
    case (unsigned int)0: 
                          #line 2184 
    ;
    #line 2189 
    break;
    #line 2190 
    case (unsigned int)1: 
                          #line 2190 
    ;
    #line 2199 
    mflcn_reg |= 8U;
    #line 2200 
    break;
    #line 2201 
    case (unsigned int)2: 
                          #line 2201 
    ;
    #line 2206 
    fccfg_reg |= 8U;
    #line 2207 
    break;
    #line 2208 
    case (unsigned int)3: 
                          #line 2208 
    ;
    #line 2210 
    mflcn_reg |= 8U;
    #line 2211 
    fccfg_reg |= 8U;
    #line 2212 
    break;
    #line 2213 
    default: 
             #line 2213 
    ;
    {
      #line 2214 
      bool branch_0;
      #line 2214 
      struct _ddebug __UNIQUE_ID_ddebug487 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_fc_enable_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Flow control param set incorrectly\n", .lineno = (unsigned int)2214U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 2214 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug487.key.dd_key_false.key,(_Bool)0);
      #line 2214 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 2214 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug487,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Flow control param set incorrectly\n");
    }
    #line 2215 
    return -4;
  }
  #line 2219 
  mflcn_reg |= 2U;
  #line 2220 
  ixgbe_write_reg_10(hw,17044U,mflcn_reg);
  #line 2221 
  ixgbe_write_reg_10(hw,15616U,fccfg_reg);
  #line 2224 
  i = 0;
  #line 2224 
  while (i <= 7) {
    #line 2225 
    if (((unsigned int)hw->fc.current_mode & 2U) != 0U && hw->fc.high_water[i] != 0U) {
      #line 2227 
      fcrtl = (hw->fc.low_water[i] << 10) | 2147483648U;
      #line 2228 
      ixgbe_write_reg_10(hw,(unsigned int)((i + 3208) * 4),fcrtl);
      #line 2229 
      fcrth = (hw->fc.high_water[i] << 10) | 2147483648U;
    }
    else {
      #line 2231 
      ixgbe_write_reg_10(hw,(unsigned int)((i + 3208) * 4),0U);
      #line 2239 
      fcrth = ixgbe_read_reg(hw,(unsigned int)((i + 3840) * 4)) + 4294942720U;
    }
    #line 2242 
    ixgbe_write_reg_10(hw,(unsigned int)((i + 3224) * 4),fcrth);
    #line 2224 
    i ++;
  }
  #line 2246 
  reg = (unsigned int)((int)hw->fc.pause_time * 65537);
  #line 2247 
  i = 0;
  #line 2247 
  while (i <= 3) {
    #line 2248 
    ixgbe_write_reg_10(hw,(unsigned int)((i + 3200) * 4),reg);
    #line 2247 
    i ++;
  }
  #line 2250 
  ixgbe_write_reg_10(hw,12960U,(unsigned int)hw->fc.pause_time / 2U);
  #line 2252 
  return 0;
}

#line 2268  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_negotiate_fc(struct ixgbe_hw *hw, u32 adv_reg, u32 lp_reg, u32 adv_sym, u32 adv_asm, u32 lp_sym, u32 lp_asm)
{
  #line 2271 
  if (adv_reg == 0U || lp_reg == 0U) 
                                     #line 2272 
                                     return -27;
  #line 2274 
  if ((adv_reg & adv_sym) != 0U && (lp_reg & lp_sym) != 0U) 
    #line 2282 
    if (hw->fc.requested_mode == (unsigned int)ixgbe_fc_full) {
      #line 2283 
      hw->fc.current_mode = ixgbe_fc_full;
      {
        #line 2284 
        bool branch;
        #line 2284 
        struct _ddebug __UNIQUE_ID_ddebug488 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_negotiate_fc", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Flow Control = FULL.\n", .lineno = (unsigned int)2284U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 2284 
        branch = arch_static_branch(& __UNIQUE_ID_ddebug488.key.dd_key_false.key,(_Bool)0);
        #line 2284 
        if ((long)((long)((int)branch != 0)) != 0L) 
                                                    #line 2284 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug488,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Flow Control = FULL.\n");
      }
    }
    else {
      #line 2286 
      hw->fc.current_mode = ixgbe_fc_rx_pause;
      {
        #line 2287 
        bool branch_0;
        #line 2287 
        struct _ddebug __UNIQUE_ID_ddebug489 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_negotiate_fc", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Flow Control=RX PAUSE frames only\n", .lineno = (unsigned int)2287U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 2287 
        branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug489.key.dd_key_false.key,(_Bool)0);
        #line 2287 
        if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                      #line 2287 
                                                      __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug489,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Flow Control=RX PAUSE frames only\n");
      }
    }
  else 
    #line 2289 
    if ((((adv_reg & adv_sym) == 0U && (adv_reg & adv_asm) != 0U) && (lp_reg & lp_sym) != 0U) && (lp_reg & lp_asm) != 0U) {
      #line 2291 
      hw->fc.current_mode = ixgbe_fc_tx_pause;
      {
        #line 2292 
        bool branch_1;
        #line 2292 
        struct _ddebug __UNIQUE_ID_ddebug490 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_negotiate_fc", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Flow Control = TX PAUSE frames only.\n", .lineno = (unsigned int)2292U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 2292 
        branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug490.key.dd_key_false.key,(_Bool)0);
        #line 2292 
        if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                      #line 2292 
                                                      __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug490,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Flow Control = TX PAUSE frames only.\n");
      }
    }
    else 
      #line 2293 
      if ((((adv_reg & adv_sym) != 0U && (adv_reg & adv_asm) != 0U) && (lp_reg & lp_sym) == 0U) && (lp_reg & lp_asm) != 0U) {
        #line 2295 
        hw->fc.current_mode = ixgbe_fc_rx_pause;
        {
          #line 2296 
          bool branch_2;
          #line 2296 
          struct _ddebug __UNIQUE_ID_ddebug491 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_negotiate_fc", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Flow Control = RX PAUSE frames only.\n", .lineno = (unsigned int)2296U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
          #line 2296 
          branch_2 = arch_static_branch(& __UNIQUE_ID_ddebug491.key.dd_key_false.key,(_Bool)0);
          #line 2296 
          if ((long)((long)((int)branch_2 != 0)) != 0L) 
                                                        #line 2296 
                                                        __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug491,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Flow Control = RX PAUSE frames only.\n");
        }
      }
      else {
        #line 2298 
        hw->fc.current_mode = ixgbe_fc_none;
        {
          #line 2299 
          bool branch_3;
          #line 2299 
          struct _ddebug __UNIQUE_ID_ddebug492 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_negotiate_fc", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Flow Control = NONE.\n", .lineno = (unsigned int)2299U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
          #line 2299 
          branch_3 = arch_static_branch(& __UNIQUE_ID_ddebug492.key.dd_key_false.key,(_Bool)0);
          #line 2299 
          if ((long)((long)((int)branch_3 != 0)) != 0L) 
                                                        #line 2299 
                                                        __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug492,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Flow Control = NONE.\n");
        }
      }
  #line 2301 
  return 0;
}

#line 2310  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_fc_autoneg_fiber(struct ixgbe_hw *hw)
{
  #line 2312 
  u32 pcs_anadv_reg;
  #line 2312 
  u32 pcs_lpab_reg;
  #line 2312 
  u32 linkstat;
  #line 2313 
  s32 ret_val;
  #line 2321 
  linkstat = ixgbe_read_reg(hw,16908U);
  #line 2322 
  if ((linkstat & 65536U) == 0U || (int)(linkstat >> 18) & 1) 
                                                              #line 2324 
                                                              return -27;
  #line 2326 
  pcs_anadv_reg = ixgbe_read_reg(hw,16920U);
  #line 2327 
  pcs_lpab_reg = ixgbe_read_reg(hw,16924U);
  #line 2329 
  ret_val = ixgbe_negotiate_fc(hw,pcs_anadv_reg,pcs_lpab_reg,128U,256U,128U,256U);
  #line 2335 
  return ret_val;
}

#line 2344  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_fc_autoneg_backplane(struct ixgbe_hw *hw)
{
  #line 2346 
  u32 links2;
  #line 2346 
  u32 anlp1_reg;
  #line 2346 
  u32 autoc_reg;
  #line 2346 
  u32 links;
  #line 2347 
  s32 ret_val;
  #line 2354 
  links = ixgbe_read_reg(hw,17060U);
  #line 2355 
  if ((links & 2147483648U) == 0U) 
                                   #line 2356 
                                   return -27;
  #line 2358 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82599EB) {
    #line 2359 
    links2 = ixgbe_read_reg(hw,17188U);
    #line 2360 
    if ((links2 & 64U) == 0U) 
                              #line 2361 
                              return -27;
  }
  #line 2367 
  autoc_reg = ixgbe_read_reg(hw,17056U);
  #line 2368 
  anlp1_reg = ixgbe_read_reg(hw,17072U);
  #line 2370 
  ret_val = ixgbe_negotiate_fc(hw,autoc_reg,anlp1_reg,268435456U,536870912U,1024U,2048U);
  #line 2374 
  return ret_val;
}

#line 2383  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_fc_autoneg_copper(struct ixgbe_hw *hw)
{
  #line 2385 
  u16 technology_ability_reg = (unsigned short)0U;
  #line 2386 
  u16 lp_technology_ability_reg = (unsigned short)0U;
  #line 2388 
  (*(hw->phy.ops.read_reg))(hw,16U,7U,& technology_ability_reg);
  #line 2391 
  (*(hw->phy.ops.read_reg))(hw,19U,7U,& lp_technology_ability_reg);
  #line 2395 
  return ixgbe_negotiate_fc(hw,(unsigned int)technology_ability_reg,
                         (unsigned int)lp_technology_ability_reg,1024U,2048U,
                         1024U,2048U);
}

#line 2408  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_fc_autoneg(struct ixgbe_hw *hw)
{
  #line 2411 
  ixgbe_link_speed speed;
  #line 2412 
  bool link_up;
  #line 2410 
  s32 ret_val = -27;
  #line 2423 
  if ((int)hw->fc.disable_fc_autoneg != 0) 
                                           #line 2424 
                                           goto out;
  #line 2426 
  (*(hw->mac.ops.check_link))(hw,& speed,& link_up,(_Bool)0);
  #line 2427 
  if (! link_up) 
                 #line 2428 
                 goto out;
  #line 2430 
  switch ((unsigned int)hw->phy.media_type) {
    #line 2432 
    case (unsigned int)1: 
                          #line 2432 
    ;
    #line 2433 
    if (speed == 32U) 
                      #line 2434 
                      ret_val = ixgbe_fc_autoneg_fiber(hw);
    #line 2435 
    break;
    #line 2438 
    case (unsigned int)5: 
                          #line 2438 
    ;
    #line 2439 
    ret_val = ixgbe_fc_autoneg_backplane(hw);
    #line 2440 
    break;
    #line 2443 
    case (unsigned int)4: 
                          #line 2443 
    ;
    #line 2444 
    if ((int)ixgbe_device_supports_autoneg_fc(hw) != 0) 
                                                        #line 2445 
                                                        ret_val = ixgbe_fc_autoneg_copper(hw);
    #line 2446 
    break;
    #line 2448 
    default: 
             #line 2448 
    ;
    #line 2449 
    break;
  }
  #line 2452 
  out: 
       #line 2452 
  ;
  #line 2453 
  if (ret_val == 0) 
                    #line 2454 
                    hw->fc.fc_was_autonegged = (_Bool)1;
  else {
    #line 2456 
    hw->fc.fc_was_autonegged = (_Bool)0;
    #line 2457 
    hw->fc.current_mode = hw->fc.requested_mode;
  }
  #line 2459 
  return;
}

#line 2471  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static u32 ixgbe_pcie_timeout_poll(struct ixgbe_hw *hw)
{
  #line 2473 
  s16 devctl2;
  #line 2474 
  u32 pollcnt;
  #line 2476 
  devctl2 = (short)ixgbe_read_pci_cfg_word(hw,200U);
  #line 2477 
  devctl2 = (short)((int)devctl2 & 15);
  #line 2479 
  switch ((int)devctl2) {
    #line 2480 
    case 6: 
            #line 2480 
    ;
    #line 2481 
    pollcnt = 1300U;
    #line 2482 
    break;
    #line 2483 
    case 9: 
            #line 2483 
    ;
    #line 2484 
    pollcnt = 5200U;
    #line 2485 
    break;
    #line 2486 
    case 10: 
             #line 2486 
    ;
    #line 2487 
    pollcnt = 20000U;
    #line 2488 
    break;
    #line 2489 
    case 13: 
             #line 2489 
    ;
    #line 2490 
    pollcnt = 80000U;
    #line 2491 
    break;
    #line 2492 
    case 14: 
             #line 2492 
    ;
    #line 2493 
    pollcnt = 34000U;
    #line 2494 
    break;
    #line 2495 
    case 1: 
            #line 2495 
    ;
    #line 2496 
    case 2: 
            #line 2496 
    ;
    #line 2497 
    case 5: 
            #line 2497 
    ;
    #line 2498 
    case 0: 
            #line 2498 
    ;
    #line 2499 
    default: 
             #line 2499 
    ;
    #line 2500 
    pollcnt = 800U;
    #line 2501 
    break;
  }
  #line 2505 
  return (pollcnt * 11U) / 10U;
}

#line 2517  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_disable_pcie_master(struct ixgbe_hw *hw)
{
  #line 2519 
  u32 i;
  #line 2519 
  u32 poll;
  #line 2520 
  u16 value;
  #line 2523 
  ixgbe_write_reg_10(hw,0U,4U);
  #line 2526 
  i = 0U;
  #line 2526 
  while (i <= 799U) {
    {
      #line 2527 
      if ((ixgbe_read_reg(hw,0U) & 4U) != 0U) 
                                              #line 2528 
                                              break;
      #line 2529 
      usleep_range(100UL,120UL);
    }
    #line 2526 
    i ++;
  }
  #line 2531 
  if (i > 799U) {
    {
      #line 2532 
      bool branch;
      #line 2532 
      struct _ddebug __UNIQUE_ID_ddebug493 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_disable_pcie_master", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"GIO disable did not set - requesting resets\n", .lineno = (unsigned int)2532U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 2532 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug493.key.dd_key_false.key,(_Bool)0);
      #line 2532 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 2532 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug493,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"GIO disable did not set - requesting resets\n");
    }
    #line 2533 
    goto gio_disable_fail;
  }
  #line 2537 
  if ((ixgbe_read_reg(hw,8U) & 524288U) == 0U) 
                                               #line 2539 
                                               return 0;
  else {
    #line 2537 
    if ((int)ixgbe_removed((void *)hw->hw_addr) != 0) 
                                                      #line 2539 
                                                      return 0;
  }
  #line 2542 
  i = 0U;
  #line 2542 
  while (i <= 799U) {
    {
      #line 2543 
      __const_udelay(429500UL);
      #line 2544 
      if ((ixgbe_read_reg(hw,8U) & 524288U) == 0U) 
                                                   #line 2545 
                                                   return 0;
    }
    #line 2542 
    i ++;
  }
  {
    #line 2556 
    bool branch_0;
    #line 2556 
    struct _ddebug __UNIQUE_ID_ddebug494 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_disable_pcie_master", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"GIO Master Disable bit didn\'t clear - requesting resets\n", .lineno = (unsigned int)2556U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 2556 
    branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug494.key.dd_key_false.key,(_Bool)0);
    #line 2556 
    if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                  #line 2556 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug494,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"GIO Master Disable bit didn\'t clear - requesting resets\n");
  }
  #line 2557 
  gio_disable_fail: 
                    #line 2557 
  ;
  #line 2558 
  hw->mac.flags = (unsigned char)((unsigned int)hw->mac.flags | 1U);
  #line 2560 
  if (hw->mac.type > (unsigned int)ixgbe_mac_X540) 
                                                   #line 2561 
                                                   return 0;
  #line 2567 
  poll = ixgbe_pcie_timeout_poll(hw);
  #line 2568 
  i = 0U;
  #line 2568 
  while (i < poll) {
    {
      #line 2569 
      __const_udelay(429500UL);
      #line 2570 
      value = ixgbe_read_pci_cfg_word(hw,170U);
      #line 2571 
      if ((int)ixgbe_removed((void *)hw->hw_addr) != 0) 
                                                        #line 2572 
                                                        return 0;
      #line 2573 
      if (((int)value & 32) == 0) 
                                  #line 2574 
                                  return 0;
    }
    #line 2568 
    i ++;
  }
  {
    #line 2577 
    bool branch_1;
    #line 2577 
    struct _ddebug __UNIQUE_ID_ddebug495 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_disable_pcie_master", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"PCIe transaction pending bit also did not clear.\n", .lineno = (unsigned int)2577U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 2577 
    branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug495.key.dd_key_false.key,(_Bool)0);
    #line 2577 
    if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                  #line 2577 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug495,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"PCIe transaction pending bit also did not clear.\n");
  }
  #line 2578 
  return -12;
}

#line 2589  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_acquire_swfw_sync(struct ixgbe_hw *hw, u32 mask)
{
  #line 2595 
  u32 i;
  #line 2591 
  u32 gssr = 0U;
  #line 2592 
  u32 swmask = mask;
  #line 2593 
  u32 fwmask = mask << 5;
  #line 2594 
  u32 timeout = 200U;
  #line 2597 
  i = 0U;
  #line 2597 
  while (i < timeout) {
    {
      #line 2602 
      if (ixgbe_get_eeprom_semaphore(hw) != 0) 
                                               #line 2603 
                                               return -16;
      #line 2605 
      gssr = ixgbe_read_reg(hw,65888U);
      #line 2606 
      if (((fwmask | swmask) & gssr) == 0U) {
        #line 2607 
        gssr |= swmask;
        #line 2608 
        ixgbe_write_reg_10(hw,65888U,gssr);
        #line 2609 
        ixgbe_release_eeprom_semaphore(hw);
        #line 2610 
        return 0;
      }
      else {
        #line 2613 
        ixgbe_release_eeprom_semaphore(hw);
        #line 2614 
        usleep_range(5000UL,10000UL);
      }
    }
    #line 2597 
    i ++;
  }
  #line 2619 
  if (((fwmask | swmask) & gssr) != 0U) 
                                        #line 2620 
                                        ixgbe_release_swfw_sync(hw,(fwmask | swmask) & gssr);
  #line 2622 
  usleep_range(5000UL,10000UL);
  #line 2623 
  return -16;
}

#line 2634  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_release_swfw_sync(struct ixgbe_hw *hw, u32 mask)
{
  #line 2636 
  u32 gssr;
  #line 2637 
  u32 swmask = mask;
  #line 2639 
  ixgbe_get_eeprom_semaphore(hw);
  #line 2641 
  gssr = ixgbe_read_reg(hw,65888U);
  #line 2642 
  gssr = ~ swmask & gssr;
  #line 2643 
  ixgbe_write_reg_10(hw,65888U,gssr);
  #line 2645 
  ixgbe_release_eeprom_semaphore(hw);
  #line 2646 
  return;
}

#line 2657  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 prot_autoc_read_generic(struct ixgbe_hw *hw, bool *locked, u32 *reg_val)
{
  #line 2659 
  *locked = (_Bool)0;
  #line 2660 
  *reg_val = ixgbe_read_reg(hw,17056U);
  #line 2661 
  return 0;
}

#line 2671  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 prot_autoc_write_generic(struct ixgbe_hw *hw, u32 reg_val, bool locked)
{
  #line 2673 
  ixgbe_write_reg_10(hw,17056U,reg_val);
  #line 2674 
  return 0;
}

#line 2684  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_disable_rx_buff_generic(struct ixgbe_hw *hw)
{
  #line 2687 
  int i;
  #line 2688 
  int secrxreg;
  #line 2690 
  secrxreg = (int)ixgbe_read_reg(hw,36096U);
  #line 2691 
  secrxreg |= 2;
  #line 2692 
  ixgbe_write_reg_10(hw,36096U,(unsigned int)secrxreg);
  #line 2693 
  i = 0;
  #line 2693 
  while (i <= 39) {
    {
      #line 2694 
      secrxreg = (int)ixgbe_read_reg(hw,36100U);
      #line 2695 
      if ((secrxreg & 1) != 0) 
                               #line 2696 
                               break; else 
                                           #line 2699 
                                           __const_udelay(4295000UL);
    }
    #line 2693 
    i ++;
  }
  #line 2703 
  if (i > 39) {
    #line 2704 
    bool branch;
    #line 2704 
    struct _ddebug __UNIQUE_ID_ddebug496 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_disable_rx_buff_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Rx unit being enabled before security path fully disabled. Continuing with init.\n", .lineno = (unsigned int)2704U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 2704 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug496.key.dd_key_false.key,(_Bool)0);
    #line 2704 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 2704 
                                                __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug496,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Rx unit being enabled before security path fully disabled. Continuing with init.\n");
  }
  #line 2706 
  return 0;
}

#line 2716  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_enable_rx_buff_generic(struct ixgbe_hw *hw)
{
  #line 2718 
  u32 secrxreg;
  #line 2720 
  secrxreg = ixgbe_read_reg(hw,36096U);
  #line 2721 
  secrxreg &= 4294967293U;
  #line 2722 
  ixgbe_write_reg_10(hw,36096U,secrxreg);
  #line 2723 
  ixgbe_read_reg(hw,8U);
  #line 2725 
  return 0;
}

#line 2735  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_enable_rx_dma_generic(struct ixgbe_hw *hw, u32 regval)
{
  #line 2737 
  if ((regval & 1U) != 0U) 
                           #line 2738 
                           (*(hw->mac.ops.enable_rx))(hw); else 
                                                                #line 2740 
                                                                (*(hw->mac.ops.disable_rx))(hw);
  #line 2742 
  return 0;
}

#line 2750  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_blink_led_start_generic(struct ixgbe_hw *hw, u32 index)
{
  #line 2757 
  s32 ret_val;
  #line 2752 
  ixgbe_link_speed speed = 0U;
  #line 2753 
  bool link_up = (_Bool)0;
  #line 2754 
  u32 autoc_reg = ixgbe_read_reg(hw,17056U);
  #line 2755 
  u32 led_reg = ixgbe_read_reg(hw,512U);
  #line 2756 
  bool locked = (_Bool)0;
  #line 2759 
  if (index > 3U) 
                  #line 2760 
                  return -5;
  #line 2766 
  (*(hw->mac.ops.check_link))(hw,& speed,& link_up,(_Bool)0);
  #line 2768 
  if (! link_up) {
    #line 2769 
    ret_val = (*(hw->mac.ops.prot_autoc_read))(hw,& locked,& autoc_reg);
    #line 2770 
    if (ret_val != 0) 
                      #line 2771 
                      return ret_val;
    #line 2773 
    autoc_reg |= 4096U;
    #line 2774 
    autoc_reg |= 1U;
    #line 2776 
    ret_val = (*(hw->mac.ops.prot_autoc_write))(hw,autoc_reg,(_Bool)((bool)((int)locked) != 0));
    #line 2777 
    if (ret_val != 0) 
                      #line 2778 
                      return ret_val;
    #line 2780 
    ixgbe_read_reg(hw,8U);
    #line 2782 
    usleep_range(10000UL,20000UL);
  }
  #line 2785 
  led_reg = (unsigned int)(~ (15 << index * 8U)) & led_reg;
  #line 2786 
  led_reg = (unsigned int)(128 << index * 8U) | led_reg;
  #line 2787 
  ixgbe_write_reg_10(hw,512U,led_reg);
  #line 2788 
  ixgbe_read_reg(hw,8U);
  #line 2790 
  return 0;
}

#line 2798  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_blink_led_stop_generic(struct ixgbe_hw *hw, u32 index)
{
  #line 2803 
  s32 ret_val;
  #line 2800 
  u32 autoc_reg = 0U;
  #line 2801 
  u32 led_reg = ixgbe_read_reg(hw,512U);
  #line 2802 
  bool locked = (_Bool)0;
  #line 2805 
  if (index > 3U) 
                  #line 2806 
                  return -5;
  #line 2808 
  ret_val = (*(hw->mac.ops.prot_autoc_read))(hw,& locked,& autoc_reg);
  #line 2809 
  if (ret_val != 0) 
                    #line 2810 
                    return ret_val;
  #line 2812 
  autoc_reg &= 4294967294U;
  #line 2813 
  autoc_reg |= 4096U;
  #line 2815 
  ret_val = (*(hw->mac.ops.prot_autoc_write))(hw,autoc_reg,(_Bool)((bool)((int)locked) != 0));
  #line 2816 
  if (ret_val != 0) 
                    #line 2817 
                    return ret_val;
  #line 2819 
  led_reg = (unsigned int)(~ (15 << index * 8U)) & led_reg;
  #line 2820 
  led_reg = (unsigned int)(~ (128 << index * 8U)) & led_reg;
  #line 2821 
  led_reg = (unsigned int)(4 << index * 8U) | led_reg;
  #line 2822 
  ixgbe_write_reg_10(hw,512U,led_reg);
  #line 2823 
  ixgbe_read_reg(hw,8U);
  #line 2825 
  return 0;
}

#line 2837  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_get_san_mac_addr_offset(struct ixgbe_hw *hw, u16 *san_mac_offset)
{
  #line 2840 
  s32 ret_val;
  #line 2846 
  ret_val = (*(hw->eeprom.ops.read))(hw,(unsigned short)40,san_mac_offset);
  #line 2848 
  if (ret_val != 0) 
                    #line 2849 
                    netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"eeprom read at offset %d failed\n",40);
  #line 2852 
  return ret_val;
}

#line 2865  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_get_san_mac_addr_generic(struct ixgbe_hw *hw, u8 *san_mac_addr)
{
  #line 2867 
  u16 san_mac_data;
  #line 2867 
  u16 san_mac_offset;
  #line 2868 
  u8 i;
  #line 2869 
  s32 ret_val;
  #line 2875 
  ret_val = ixgbe_get_san_mac_addr_offset(hw,& san_mac_offset);
  #line 2876 
  if ((ret_val != 0 || (unsigned int)san_mac_offset == 0U) || (unsigned int)san_mac_offset == 65535U) 
    #line 2878 
    goto san_mac_addr_clr;
  #line 2881 
  (*(hw->mac.ops.set_lan_id))(hw);
  #line 2883 
  if ((unsigned int)hw->bus.func != 0U) {
    #line 2883 
    san_mac_offset = (unsigned short)((unsigned int)san_mac_offset + 3U);
    #line 2883 
    int tmp = (int)san_mac_offset;
  }
  else {
    #line 2884 
    san_mac_offset = san_mac_offset;
    #line 2883 
    int tmp_3 = (int)san_mac_offset;
  }
  #line 2885 
  i = (unsigned char)0U;
  #line 2885 
  while ((unsigned int)i <= 2U) {
    #line 2886 
    ret_val = (*(hw->eeprom.ops.read))(hw,(unsigned short)((int)san_mac_offset),& san_mac_data);
    #line 2888 
    if (ret_val != 0) {
      #line 2889 
      netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"eeprom read at offset %d failed\n",(int)san_mac_offset);
      #line 2891 
      goto san_mac_addr_clr;
    }
    #line 2893 
    *(san_mac_addr + (unsigned long)((int)i * 2)) = (unsigned char)san_mac_data;
    #line 2894 
    *(san_mac_addr + ((unsigned long)((int)i * 2) + (unsigned long)1U)) = (unsigned char)((int)san_mac_data >> 8);
    #line 2895 
    san_mac_offset = (u16)((int)san_mac_offset + 1);
    #line 2885 
    i = (u8)((int)i + 1);
  }
  #line 2897 
  return 0;
  #line 2899 
  san_mac_addr_clr: 
                    #line 2899 
  ;
  #line 2903 
  i = (unsigned char)0U;
  #line 2903 
  while ((unsigned int)i <= 5U) {
    #line 2904 
    *(san_mac_addr + (unsigned long)i) = (unsigned char)255U;
    #line 2903 
    i = (u8)((int)i + 1);
  }
  #line 2905 
  return ret_val;
}

#line 2915  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
u16 ixgbe_get_pcie_msix_count_generic(struct ixgbe_hw *hw)
{
  #line 2917 
  u16 msix_count;
  #line 2918 
  u16 max_msix_count;
  #line 2919 
  u16 pcie_offset;
  #line 2921 
  switch ((unsigned int)hw->mac.type) {
    #line 2922 
    case (unsigned int)1: 
                          #line 2922 
    ;
    #line 2923 
    pcie_offset = (unsigned short)98U;
    #line 2924 
    max_msix_count = (unsigned short)19U;
    #line 2925 
    break;
    #line 2926 
    case (unsigned int)2: 
                          #line 2926 
    ;
    #line 2927 
    case (unsigned int)3: 
                          #line 2927 
    ;
    #line 2928 
    case (unsigned int)4: 
                          #line 2928 
    ;
    #line 2929 
    case (unsigned int)5: 
                          #line 2929 
    ;
    #line 2930 
    case (unsigned int)6: 
                          #line 2930 
    ;
    #line 2931 
    pcie_offset = (unsigned short)114U;
    #line 2932 
    max_msix_count = (unsigned short)64U;
    #line 2933 
    break;
    #line 2934 
    default: 
             #line 2934 
    ;
    #line 2935 
    return (unsigned short)1U;
  }
  #line 2938 
  msix_count = ixgbe_read_pci_cfg_word(hw,(unsigned int)pcie_offset);
  #line 2939 
  if ((int)ixgbe_removed((void *)hw->hw_addr) != 0) 
                                                    #line 2940 
                                                    msix_count = (unsigned short)0U;
  #line 2941 
  msix_count = (unsigned short)((unsigned int)msix_count & 2047U);
  #line 2944 
  msix_count = (u16)((int)msix_count + 1);
  #line 2946 
  if ((int)msix_count > (int)max_msix_count) 
                                             #line 2947 
                                             msix_count = max_msix_count;
  #line 2949 
  return msix_count;
}

#line 2958  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_clear_vmdq_generic(struct ixgbe_hw *hw, u32 rar, u32 vmdq)
{
  #line 2960 
  u32 mpsar_lo;
  #line 2960 
  u32 mpsar_hi;
  #line 2961 
  u32 rar_entries = hw->mac.num_rar_entries;
  #line 2964 
  if (rar >= rar_entries) {
    {
      #line 2965 
      bool branch;
      #line 2965 
      struct _ddebug __UNIQUE_ID_ddebug497 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_clear_vmdq_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"RAR index %d is out of range.\n", .lineno = (unsigned int)2965U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 2965 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug497.key.dd_key_false.key,(_Bool)0);
      #line 2965 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 2965 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug497,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"RAR index %d is out of range.\n",rar);
    }
    #line 2966 
    return -32;
  }
  #line 2969 
  mpsar_lo = ixgbe_read_reg(hw,(rar + 5312U) * 8U);
  #line 2970 
  mpsar_hi = ixgbe_read_reg(hw,rar * 8U + 42500U);
  #line 2972 
  if ((int)ixgbe_removed((void *)hw->hw_addr) != 0) 
                                                    #line 2973 
                                                    return 0;
  #line 2975 
  if (mpsar_lo == 0U && mpsar_hi == 0U) 
                                        #line 2976 
                                        return 0;
  #line 2978 
  if (vmdq == 4294967295U) {
    #line 2979 
    if (mpsar_lo != 0U) {
      #line 2980 
      ixgbe_write_reg_10(hw,(rar + 5312U) * 8U,0U);
      #line 2981 
      mpsar_lo = 0U;
    }
    #line 2983 
    if (mpsar_hi != 0U) {
      #line 2984 
      ixgbe_write_reg_10(hw,rar * 8U + 42500U,0U);
      #line 2985 
      mpsar_hi = 0U;
    }
  }
  else 
    #line 2987 
    if (vmdq <= 31U) {
      #line 2988 
      mpsar_lo = ~ ((unsigned int)(1UL << vmdq)) & mpsar_lo;
      #line 2989 
      ixgbe_write_reg_10(hw,(rar + 5312U) * 8U,mpsar_lo);
    }
    else {
      #line 2991 
      mpsar_hi = ~ ((unsigned int)(1UL << (vmdq + 4294967264U))) & mpsar_hi;
      #line 2992 
      ixgbe_write_reg_10(hw,rar * 8U + 42500U,mpsar_hi);
    }
  #line 2996 
  if (((mpsar_lo == 0U && mpsar_hi == 0U) && rar != 0U) && (unsigned int)hw->mac.san_mac_rar_index != rar) 
    #line 2998 
    (*(hw->mac.ops.clear_rar))(hw,rar);
  #line 3000 
  return 0;
}

#line 3009  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_set_vmdq_generic(struct ixgbe_hw *hw, u32 rar, u32 vmdq)
{
  #line 3011 
  u32 mpsar;
  #line 3012 
  u32 rar_entries = hw->mac.num_rar_entries;
  #line 3015 
  if (rar >= rar_entries) {
    {
      #line 3016 
      bool branch;
      #line 3016 
      struct _ddebug __UNIQUE_ID_ddebug498 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_set_vmdq_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"RAR index %d is out of range.\n", .lineno = (unsigned int)3016U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 3016 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug498.key.dd_key_false.key,(_Bool)0);
      #line 3016 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 3016 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug498,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"RAR index %d is out of range.\n",rar);
    }
    #line 3017 
    return -32;
  }
  #line 3020 
  if (vmdq <= 31U) {
    #line 3021 
    mpsar = ixgbe_read_reg(hw,(rar + 5312U) * 8U);
    #line 3022 
    mpsar = (unsigned int)(1UL << vmdq) | mpsar;
    #line 3023 
    ixgbe_write_reg_10(hw,(rar + 5312U) * 8U,mpsar);
  }
  else {
    #line 3025 
    mpsar = ixgbe_read_reg(hw,rar * 8U + 42500U);
    #line 3026 
    mpsar = (unsigned int)(1UL << (vmdq + 4294967264U)) | mpsar;
    #line 3027 
    ixgbe_write_reg_10(hw,rar * 8U + 42500U,mpsar);
  }
  #line 3029 
  return 0;
}

#line 3042  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_set_vmdq_san_mac_generic(struct ixgbe_hw *hw, u32 vmdq)
{
  #line 3044 
  u32 rar = (unsigned int)hw->mac.san_mac_rar_index;
  #line 3046 
  if (vmdq <= 31U) {
    #line 3047 
    ixgbe_write_reg_10(hw,(rar + 5312U) * 8U,(unsigned int)(1UL << vmdq));
    #line 3048 
    ixgbe_write_reg_10(hw,rar * 8U + 42500U,0U);
  }
  else {
    #line 3050 
    ixgbe_write_reg_10(hw,(rar + 5312U) * 8U,0U);
    #line 3051 
    ixgbe_write_reg_10(hw,rar * 8U + 42500U,(unsigned int)(1UL << (vmdq + 4294967264U)));
  }
  #line 3054 
  return 0;
}

#line 3061  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_init_uta_tables_generic(struct ixgbe_hw *hw)
{
  #line 3063 
  int i;
  #line 3065 
  i = 0;
  #line 3065 
  while (i <= 127) {
    #line 3066 
    ixgbe_write_reg_10(hw,(unsigned int)((i + 15616) * 4),0U);
    #line 3065 
    i ++;
  }
  #line 3068 
  return 0;
}

#line 3081  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_find_vlvf_slot(struct ixgbe_hw *hw, u32 vlan, bool vlvf_bypass)
{
  #line 3083 
  s32 regindex;
  #line 3083 
  s32 first_empty_slot;
  #line 3084 
  u32 bits;
  #line 3118 
  int tmp_0;
  #line 3087 
  if (vlan == 0U) 
                  #line 3088 
                  return 0;
  #line 3094 
  if ((int)vlvf_bypass != 0) 
                             #line 3094 
                             first_empty_slot = -25; else 
                                                          #line 3094 
                                                          first_empty_slot = 0;
  #line 3097 
  vlan |= 2147483648U;
  #line 3104 
  regindex = 64;
  #line 3104 
  while (1) {
    #line 3104 
    regindex --;
    #line 3104 
    if (! (regindex != 0)) 
                           #line 3104 
                           break;
    #line 3105 
    bits = ixgbe_read_reg(hw,(unsigned int)((regindex + 15424) * 4));
    #line 3106 
    if (bits == vlan) 
                      #line 3107 
                      return regindex;
    #line 3108 
    if (first_empty_slot == 0 && bits == 0U) 
                                             #line 3109 
                                             first_empty_slot = regindex;
  }
  #line 3115 
  if (first_empty_slot == 0) {
    #line 3116 
    bool branch;
    #line 3116 
    struct _ddebug __UNIQUE_ID_ddebug499 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_find_vlvf_slot", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"No space in VLVF.\n", .lineno = (unsigned int)3116U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 3116 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug499.key.dd_key_false.key,(_Bool)0);
    #line 3116 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 3116 
                                                __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug499,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"No space in VLVF.\n");
  }
  #line 3118 
  tmp_0 = first_empty_slot != 0;
  #line 3118 
  if (! tmp_0) 
               #line 3118 
               tmp_0 = -25;
  #line 3118 
  return tmp_0;
}

#line 3131  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_set_vfta_generic(struct ixgbe_hw *hw, u32 vlan, u32 vind, bool vlan_on, bool vlvf_bypass)
{
  #line 3134 
  u32 regidx;
  #line 3134 
  u32 vfta_delta;
  #line 3134 
  u32 vfta;
  #line 3134 
  u32 bits;
  #line 3135 
  s32 vlvf_index;
  #line 3160 
  u32 tmp;
  #line 3137 
  if (vlan > 4095U || vind > 63U) 
                                  #line 3138 
                                  return -5;
  #line 3152 
  regidx = vlan / 32U;
  #line 3153 
  vfta_delta = (unsigned int)(1UL << (vlan & 31U));
  #line 3154 
  vfta = ixgbe_read_reg(hw,(regidx + 10240U) * 4U);
  #line 3160 
  if ((int)vlan_on != 0) 
                         #line 3160 
                         tmp = ~ vfta; else 
                                            #line 3160 
                                            tmp = vfta;
  #line 3160 
  vfta_delta = tmp & vfta_delta;
  #line 3161 
  vfta ^= vfta_delta;
  #line 3171 
  if ((ixgbe_read_reg(hw,20912U) & 1U) == 0U) 
                                              #line 3172 
                                              goto vfta_update;
  #line 3174 
  vlvf_index = ixgbe_find_vlvf_slot(hw,vlan,(_Bool)((bool)((int)vlvf_bypass) != 0));
  #line 3175 
  if (vlvf_index < 0) {
    #line 3176 
    if ((int)vlvf_bypass != 0) 
                               #line 3177 
                               goto vfta_update;
    #line 3178 
    return vlvf_index;
  }
  #line 3181 
  bits = ixgbe_read_reg(hw,(((unsigned int)(vlvf_index * 2) + vind / 32U) + 15488U) * 4U);
  #line 3184 
  bits = (unsigned int)(1UL << (vind & 31U)) | bits;
  #line 3185 
  if ((int)vlan_on != 0) 
                         #line 3186 
                         goto vlvf_update;
  #line 3189 
  bits = (unsigned int)(1UL << (vind & 31U)) ^ bits;
  #line 3191 
  if (bits == 0U) {
    #line 3191 
    if (ixgbe_read_reg(hw,
                       (((unsigned int)(vlvf_index * 2) - vind / 32U) + 15489U) * 4U) == 0U) {
      #line 3197 
      if (vfta_delta != 0U) 
                            #line 3198 
                            ixgbe_write_reg_10(hw,(regidx + 10240U) * 4U,vfta);
      #line 3201 
      ixgbe_write_reg_10(hw,(unsigned int)((vlvf_index + 15424) * 4),0U);
      #line 3202 
      ixgbe_write_reg_10(hw,(((unsigned int)(vlvf_index * 2) + vind / 32U) + 15488U) * 4U,0U);
      #line 3204 
      return 0;
    }
  }
  #line 3221 
  vfta_delta = 0U;
  #line 3223 
  vlvf_update: 
               #line 3223 
  ;
  #line 3225 
  ixgbe_write_reg_10(hw,(((unsigned int)(vlvf_index * 2) + vind / 32U) + 15488U) * 4U,bits);
  #line 3226 
  ixgbe_write_reg_10(hw,(unsigned int)((vlvf_index + 15424) * 4),vlan | 2147483648U);
  #line 3228 
  vfta_update: 
               #line 3228 
  ;
  #line 3230 
  if (vfta_delta != 0U) 
                        #line 3231 
                        ixgbe_write_reg_10(hw,(regidx + 10240U) * 4U,vfta);
  #line 3233 
  return 0;
}

#line 3242  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_clear_vfta_generic(struct ixgbe_hw *hw)
{
  #line 3244 
  u32 offset;
  #line 3246 
  offset = 0U;
  #line 3246 
  while (hw->mac.vft_size > offset) {
    #line 3247 
    ixgbe_write_reg_10(hw,(offset + 10240U) * 4U,0U);
    #line 3246 
    offset ++;
  }
  #line 3249 
  offset = 0U;
  #line 3249 
  while (offset <= 63U) {
    #line 3250 
    ixgbe_write_reg_10(hw,(offset + 15424U) * 4U,0U);
    #line 3251 
    ixgbe_write_reg_10(hw,(offset + 7744U) * 8U,0U);
    #line 3252 
    ixgbe_write_reg_10(hw,offset * 8U + 61956U,0U);
    #line 3249 
    offset ++;
  }
  #line 3255 
  return 0;
}

#line 3265  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static bool ixgbe_need_crosstalk_fix(struct ixgbe_hw *hw)
{
  #line 3268 
  if (! hw->need_crosstalk_fix) 
                                #line 3269 
                                return (_Bool)0;
  #line 3272 
  switch ((unsigned int)(*(hw->mac.ops.get_media_type))(hw)) {
    #line 3273 
    case (unsigned int)1: 
                          #line 3273 
    ;
    #line 3274 
    case (unsigned int)2: 
                          #line 3274 
    ;
    #line 3275 
    break;
    #line 3276 
    default: 
             #line 3276 
    ;
    #line 3277 
    return (_Bool)0;
  }
  #line 3280 
  return (_Bool)1;
}

#line 3292  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_check_mac_link_generic(struct ixgbe_hw *hw, ixgbe_link_speed *speed, bool *link_up, bool link_up_wait_to_complete)
{
  #line 3295 
  u32 links_reg;
  #line 3295 
  u32 links_orig;
  #line 3296 
  u32 i;
  #line 3301 
  if ((int)ixgbe_need_crosstalk_fix(hw) != 0) {
    #line 3302 
    u32 sfp_cage_full;
    #line 3304 
    switch ((unsigned int)hw->mac.type) {
      #line 3305 
      case (unsigned int)2: 
                            #line 3305 
      ;
      #line 3306 
      sfp_cage_full = ixgbe_read_reg(hw,32U) & 4U;
      #line 3308 
      break;
      #line 3309 
      case (unsigned int)5: 
                            #line 3309 
      ;
      #line 3310 
      case (unsigned int)6: 
                            #line 3310 
      ;
      #line 3311 
      sfp_cage_full = ixgbe_read_reg(hw,32U) & 1U;
      #line 3313 
      break;
      #line 3314 
      default: 
               #line 3314 
      ;
      #line 3316 
      sfp_cage_full = 0U;
      #line 3317 
      break;
    }
    #line 3320 
    if (sfp_cage_full == 0U) {
      #line 3321 
      *link_up = (_Bool)0;
      #line 3322 
      *speed = 0U;
      #line 3323 
      return 0;
    }
  }
  #line 3328 
  links_orig = ixgbe_read_reg(hw,17060U);
  #line 3330 
  links_reg = ixgbe_read_reg(hw,17060U);
  #line 3332 
  if (links_orig != links_reg) {
    #line 3333 
    bool branch;
    #line 3333 
    struct _ddebug __UNIQUE_ID_ddebug500 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_check_mac_link_generic", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"LINKS changed from %08X to %08X\n", .lineno = (unsigned int)3333U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 3333 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug500.key.dd_key_false.key,(_Bool)0);
    #line 3333 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 3333 
                                                __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug500,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"LINKS changed from %08X to %08X\n",links_orig,links_reg);
  }
  #line 3337 
  if ((int)link_up_wait_to_complete != 0) {
    #line 3338 
    i = 0U;
    #line 3338 
    while (i <= 89U) {
      #line 3339 
      if ((links_reg & 1073741824U) != 0U) {
        #line 3340 
        *link_up = (_Bool)1;
        #line 3341 
        break;
      }
      else 
           #line 3343 
           *link_up = (_Bool)0;
      #line 3345 
      msleep(100U);
      #line 3346 
      links_reg = ixgbe_read_reg(hw,17060U);
      #line 3338 
      i ++;
    }
  }
  else 
    #line 3349 
    if ((links_reg & 1073741824U) != 0U) 
                                         #line 3350 
                                         *link_up = (_Bool)1; else 
                                                                   #line 3352 
                                                                   *link_up = (_Bool)0;
  #line 3355 
  switch (links_reg & 805306368U) {
    #line 3356 
    case (unsigned int)805306368: 
                                  #line 3356 
    ;
    #line 3357 
    if (hw->mac.type > (unsigned int)ixgbe_mac_X540 && (links_reg & 134217728U) != 0U) 
      #line 3359 
      *speed = 1024U; else 
                           #line 3361 
                           *speed = 128U;
    #line 3362 
    break;
    #line 3363 
    case (unsigned int)536870912: 
                                  #line 3363 
    ;
    #line 3364 
    *speed = 32U;
    #line 3365 
    break;
    #line 3366 
    case (unsigned int)268435456: 
                                  #line 3366 
    ;
    #line 3367 
    if (hw->mac.type > (unsigned int)ixgbe_mac_X540 && (links_reg & 134217728U) != 0U) 
      #line 3369 
      *speed = 2048U; else 
                           #line 3371 
                           *speed = 8U;
    #line 3372 
    break;
    #line 3373 
    case (unsigned int)0: 
                          #line 3373 
    ;
    #line 3374 
    *speed = 0U;
    #line 3375 
    if ((unsigned int)hw->device_id + 59932U <= 1U) 
                                                    #line 3377 
                                                    *speed = 2U;
    #line 3379 
    break;
    #line 3380 
    default: 
             #line 3380 
    ;
    #line 3381 
    *speed = 0U;
  }
  #line 3384 
  return 0;
}

#line 3397  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_get_wwn_prefix_generic(struct ixgbe_hw *hw, u16 *wwnn_prefix, u16 *wwpn_prefix)
{
  #line 3400 
  u16 offset;
  #line 3400 
  u16 caps;
  #line 3401 
  u16 alt_san_mac_blk_offset;
  #line 3404 
  *wwnn_prefix = (unsigned short)65535U;
  #line 3405 
  *wwpn_prefix = (unsigned short)65535U;
  #line 3408 
  offset = (unsigned short)39U;
  #line 3409 
  if ((*(hw->eeprom.ops.read))(hw,(unsigned short)((int)offset),
                               & alt_san_mac_blk_offset) != 0) 
    #line 3410 
    goto wwn_prefix_err;
  #line 3412 
  if ((unsigned int)alt_san_mac_blk_offset + 65535U > 65533U) 
                                                              #line 3414 
                                                              return 0;
  #line 3417 
  offset = alt_san_mac_blk_offset;
  #line 3418 
  if ((*(hw->eeprom.ops.read))(hw,(unsigned short)((int)offset),& caps) != 0) 
    #line 3419 
    goto wwn_prefix_err;
  #line 3420 
  if (((int)caps & 1) == 0) 
                            #line 3421 
                            return 0;
  #line 3424 
  offset = (unsigned short)((unsigned int)alt_san_mac_blk_offset + 7U);
  #line 3425 
  if ((*(hw->eeprom.ops.read))(hw,(unsigned short)((int)offset),
                                 wwnn_prefix) != 0) 
    #line 3426 
    netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"eeprom read at offset %d failed\n",(int)offset);
  #line 3428 
  offset = (unsigned short)((unsigned int)alt_san_mac_blk_offset + 8U);
  #line 3429 
  if ((*(hw->eeprom.ops.read))(hw,(unsigned short)((int)offset),
                                 wwpn_prefix) != 0) 
    #line 3430 
    goto wwn_prefix_err;
  #line 3432 
  return 0;
  #line 3434 
  wwn_prefix_err: 
                  #line 3434 
  ;
  #line 3435 
  netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"eeprom read at offset %d failed\n",(int)offset);
  #line 3436 
  return 0;
}

#line 3446  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_set_mac_anti_spoofing(struct ixgbe_hw *hw, bool enable, int vf)
{
  #line 3450 
  u32 pfvfspoof;
  #line 3448 
  int vf_target_reg = vf >> 3;
  #line 3449 
  int vf_target_shift = vf % 8;
  #line 3452 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) 
                                                       #line 3453 
                                                       return;
  #line 3455 
  pfvfspoof = ixgbe_read_reg(hw,(unsigned int)((vf_target_reg + 8320) * 4));
  #line 3456 
  if ((int)enable != 0) 
                        #line 3457 
                        pfvfspoof = (unsigned int)(1UL << vf_target_shift) | pfvfspoof; else 
                                                                    #line 3459 
                                                                    pfvfspoof = ~ ((unsigned int)(1UL << vf_target_shift)) & pfvfspoof;
  #line 3460 
  ixgbe_write_reg_10(hw,(unsigned int)((vf_target_reg + 8320) * 4),pfvfspoof);
  #line 3461 
  return;
}

#line 3470  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_set_vlan_anti_spoofing(struct ixgbe_hw *hw, bool enable, int vf)
{
  #line 3474 
  u32 pfvfspoof;
  #line 3472 
  int vf_target_reg = vf >> 3;
  #line 3473 
  int vf_target_shift = vf % 8 + 8;
  #line 3476 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) 
                                                       #line 3477 
                                                       return;
  #line 3479 
  pfvfspoof = ixgbe_read_reg(hw,(unsigned int)((vf_target_reg + 8320) * 4));
  #line 3480 
  if ((int)enable != 0) 
                        #line 3481 
                        pfvfspoof = (unsigned int)(1UL << vf_target_shift) | pfvfspoof; else 
                                                                    #line 3483 
                                                                    pfvfspoof = ~ ((unsigned int)(1UL << vf_target_shift)) & pfvfspoof;
  #line 3484 
  ixgbe_write_reg_10(hw,(unsigned int)((vf_target_reg + 8320) * 4),pfvfspoof);
  #line 3485 
  return;
}

#line 3495  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_get_device_caps_generic(struct ixgbe_hw *hw, u16 *device_caps)
{
  #line 3497 
  (*(hw->eeprom.ops.read))(hw,(unsigned short)44,device_caps);
  #line 3499 
  return 0;
}

#line 3509  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_set_rxpba_generic(struct ixgbe_hw *hw, int num_pb, u32 headroom, int strategy)
{
  #line 3516 
  u32 rxpktsize;
  #line 3516 
  u32 txpktsize;
  #line 3516 
  u32 txpbthresh;
  #line 3514 
  u32 pbsize = hw->mac.rx_pb_size;
  #line 3515 
  int i = 0;
  #line 3519 
  pbsize -= headroom;
  #line 3521 
  if (num_pb == 0) 
                   #line 3522 
                   num_pb = 1;
  #line 3527 
  switch (strategy) {
    #line 3528 
    case 1: 
            #line 3528 
    ;
    #line 3532 
    rxpktsize = (pbsize * 10U) / (unsigned int)(num_pb * 8);
    #line 3533 
    pbsize -= (unsigned int)(num_pb / 2) * rxpktsize;
    #line 3534 
    rxpktsize <<= 10;
    #line 3535 
    while (num_pb / 2 > i) {
      #line 3536 
      ixgbe_write_reg_10(hw,(unsigned int)((i + 3840) * 4),rxpktsize);
      #line 3535 
      i ++;
    }
    #line 3538 
    case 0: 
            #line 3538 
    ;
    #line 3540 
    rxpktsize = pbsize / (unsigned int)(num_pb - i) << 10;
    #line 3541 
    while (i < num_pb) {
      #line 3542 
      ixgbe_write_reg_10(hw,(unsigned int)((i + 3840) * 4),rxpktsize);
      #line 3541 
      i ++;
    }
    #line 3543 
    break;
    #line 3544 
    default: 
             #line 3544 
    ;
    #line 3545 
    break;
  }
  #line 3553 
  txpktsize = (unsigned int)(163840 / num_pb);
  #line 3554 
  txpbthresh = txpktsize / 1024U + 4294967286U;
  #line 3555 
  i = 0;
  #line 3555 
  while (i < num_pb) {
    #line 3556 
    ixgbe_write_reg_10(hw,(unsigned int)((i + 13056) * 4),txpktsize);
    #line 3557 
    ixgbe_write_reg_10(hw,(unsigned int)((i + 4692) * 4),txpbthresh);
    #line 3555 
    i ++;
  }
  #line 3561 
  while (i <= 7) {
    #line 3562 
    ixgbe_write_reg_10(hw,(unsigned int)((i + 3840) * 4),0U);
    #line 3563 
    ixgbe_write_reg_10(hw,(unsigned int)((i + 13056) * 4),0U);
    #line 3564 
    ixgbe_write_reg_10(hw,(unsigned int)((i + 4692) * 4),0U);
    #line 3561 
    i ++;
  }
  #line 3566 
  return;
}

#line 3576  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
u8 ixgbe_calculate_checksum(u8 *buffer, u32 length)
{
  #line 3578 
  u32 i;
  #line 3579 
  u8 sum = (unsigned char)0U;
  #line 3581 
  if (buffer == (u8 *)0U) 
                          #line 3582 
                          return (unsigned char)0U;
  #line 3584 
  i = 0U;
  #line 3584 
  while (i < length) {
    #line 3585 
    sum = (unsigned char)((int)*(buffer + (unsigned long)i) + (int)sum);
    #line 3584 
    i ++;
  }
  #line 3587 
  return (unsigned char)(- ((int)sum));
}

#line 3604  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_hic_unlocked(struct ixgbe_hw *hw, u32 *buffer, u32 length, u32 timeout)
{
  #line 3607 
  u32 hicr;
  #line 3607 
  u32 i;
  #line 3607 
  u32 fwsts;
  #line 3608 
  u16 dword_len;
  #line 3610 
  if (length + 4294967295U > 1791U) {
    {
      #line 3611 
      bool branch;
      #line 3611 
      struct _ddebug __UNIQUE_ID_ddebug501 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_hic_unlocked", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Buffer length failure buffersize-%d.\n", .lineno = (unsigned int)3611U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 3611 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug501.key.dd_key_false.key,(_Bool)0);
      #line 3611 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 3611 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug501,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Buffer length failure buffersize-%d.\n",length);
    }
    #line 3612 
    return -33;
  }
  #line 3616 
  fwsts = ixgbe_read_reg(hw,89868U);
  #line 3617 
  ixgbe_write_reg_10(hw,89868U,fwsts | 512U);
  #line 3620 
  hicr = ixgbe_read_reg(hw,89856U);
  #line 3621 
  if ((hicr & 1U) == 0U) {
    {
      #line 3622 
      bool branch_0;
      #line 3622 
      struct _ddebug __UNIQUE_ID_ddebug502 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_hic_unlocked", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"IXGBE_HOST_EN bit disabled.\n", .lineno = (unsigned int)3622U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 3622 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug502.key.dd_key_false.key,(_Bool)0);
      #line 3622 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 3622 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug502,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"IXGBE_HOST_EN bit disabled.\n");
    }
    #line 3623 
    return -33;
  }
  #line 3627 
  if ((length & 3U) != 0U) {
    {
      #line 3628 
      bool branch_1;
      #line 3628 
      struct _ddebug __UNIQUE_ID_ddebug503 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_hic_unlocked", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Buffer length failure, not aligned to dword", .lineno = (unsigned int)3628U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 3628 
      branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug503.key.dd_key_false.key,(_Bool)0);
      #line 3628 
      if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                    #line 3628 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug503,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Buffer length failure, not aligned to dword");
    }
    #line 3629 
    return -32;
  }
  #line 3632 
  dword_len = (unsigned short)(length >> 2);
  #line 3637 
  i = 0U;
  #line 3637 
  while ((unsigned int)dword_len > i) {
    #line 3638 
    ixgbe_write_reg_10(hw,(i << 2) + 88064U,*(buffer + (unsigned long)i));
    #line 3637 
    i ++;
  }
  #line 3642 
  ixgbe_write_reg_10(hw,89856U,hicr | 2U);
  #line 3644 
  i = 0U;
  #line 3644 
  while (i < timeout) {
    #line 3645 
    hicr = ixgbe_read_reg(hw,89856U);
    #line 3646 
    if ((hicr & 2U) == 0U) 
                           #line 3647 
                           break;
    #line 3648 
    usleep_range(1000UL,2000UL);
    #line 3644 
    i ++;
  }
  #line 3652 
  if (timeout != 0U && i == timeout) 
                                     #line 3654 
                                     return -33;
  else {
    #line 3652 
    if ((ixgbe_read_reg(hw,89856U) & 4U) == 0U) 
                                                #line 3654 
                                                return -33;
  }
  #line 3656 
  return 0;
}

#line 3676  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_host_interface_command(struct ixgbe_hw *hw, void *buffer, u32 length, u32 timeout, bool return_data)
{
  #line 3685 
  u16 buf_len;
  #line 3685 
  u16 dword_len;
  #line 3686 
  s32 status;
  #line 3687 
  u32 bi;
  #line 3680 
  u32 hdr_size = 4U;
  #line 3684 
  union __anonunion_bp_11474 *bp = (union __anonunion_bp_11474 *)buffer;
  #line 3689 
  if (length + 4294967295U > 1791U) {
    {
      #line 3690 
      bool branch;
      #line 3690 
      struct _ddebug __UNIQUE_ID_ddebug504 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_host_interface_command", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Buffer length failure buffersize-%d.\n", .lineno = (unsigned int)3690U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 3690 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug504.key.dd_key_false.key,(_Bool)0);
      #line 3690 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 3690 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug504,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Buffer length failure buffersize-%d.\n",length);
    }
    #line 3691 
    return -33;
  }
  #line 3694 
  status = (*(hw->mac.ops.acquire_swfw_sync))(hw,1024U);
  #line 3695 
  if (status != 0) 
                   #line 3696 
                   return status;
  #line 3698 
  status = ixgbe_hic_unlocked(hw,(u32 *)buffer,length,timeout);
  #line 3699 
  if (status != 0) 
                   #line 3700 
                   goto rel_out;
  #line 3702 
  if (! return_data) 
                     #line 3703 
                     goto rel_out;
  #line 3706 
  dword_len = (unsigned short)(hdr_size >> 2);
  #line 3709 
  bi = 0U;
  #line 3709 
  while ((unsigned int)dword_len > bi) {
    {
      #line 3710 
      bp->u32arr[bi] = ixgbe_read_reg(hw,(bi << 2) + 88064U);
      #line 3711 
      u32 *tmp_2 = & bp->u32arr[bi];
    }
    #line 3709 
    bi ++;
  }
  #line 3715 
  buf_len = (unsigned short)bp->hdr.buf_len;
  #line 3716 
  if ((unsigned int)buf_len == 0U) 
                                   #line 3717 
                                   goto rel_out;
  #line 3719 
  if (((unsigned int)(((int)buf_len + -1) | 3) + hdr_size) + 1U > length) {
    {
      #line 3720 
      bool branch_0;
      #line 3720 
      struct _ddebug __UNIQUE_ID_ddebug505 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_host_interface_command", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Buffer not large enough for reply message.\n", .lineno = (unsigned int)3720U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 3720 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug505.key.dd_key_false.key,(_Bool)0);
      #line 3720 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 3720 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug505,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Buffer not large enough for reply message.\n");
    }
    #line 3721 
    status = -33;
    #line 3722 
    goto rel_out;
  }
  #line 3726 
  dword_len = (unsigned short)(((int)buf_len + 3) >> 2);
  #line 3729 
  while ((unsigned int)dword_len >= bi) {
    {
      #line 3730 
      bp->u32arr[bi] = ixgbe_read_reg(hw,(bi << 2) + 88064U);
      #line 3731 
      u32 *tmp_4 = & bp->u32arr[bi];
    }
    #line 3729 
    bi ++;
  }
  #line 3734 
  rel_out: 
           #line 3734 
  ;
  #line 3735 
  (*(hw->mac.ops.release_swfw_sync))(hw,1024U);
  #line 3737 
  return status;
}

#line 3755  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_set_fw_drv_ver_generic(struct ixgbe_hw *hw, u8 maj, u8 min, u8 build, u8 sub, u16 len, char *driver_ver)
{
  #line 3759 
  struct ixgbe_hic_drv_info fw_cmd;
  #line 3760 
  int i;
  #line 3761 
  s32 ret_val;
  #line 3763 
  fw_cmd.hdr.cmd = (unsigned char)221U;
  #line 3764 
  fw_cmd.hdr.buf_len = (unsigned char)5U;
  #line 3765 
  fw_cmd.hdr.cmd_or_resp.cmd_resv = (unsigned char)0U;
  #line 3766 
  fw_cmd.port_num = hw->bus.func;
  #line 3767 
  fw_cmd.ver_maj = maj;
  #line 3768 
  fw_cmd.ver_min = min;
  #line 3769 
  fw_cmd.ver_build = build;
  #line 3770 
  fw_cmd.ver_sub = sub;
  #line 3771 
  fw_cmd.hdr.checksum = (unsigned char)0U;
  #line 3772 
  fw_cmd.pad = (unsigned char)0U;
  #line 3773 
  fw_cmd.pad2 = (unsigned short)0U;
  #line 3774 
  fw_cmd.hdr.checksum = ixgbe_calculate_checksum((u8 *)(& fw_cmd),(unsigned int)((int)fw_cmd.hdr.buf_len + 4));
  #line 3777 
  i = 0;
  #line 3777 
  while (i <= 3) {
    #line 3778 
    ret_val = ixgbe_host_interface_command(hw,(void *)(& fw_cmd),12U,500U,(_Bool)1);
    #line 3782 
    if (ret_val != 0) 
                      #line 3783 
                      goto __Cont;
    #line 3785 
    if ((unsigned int)fw_cmd.hdr.cmd_or_resp.ret_status == 1U) 
                                                               #line 3787 
                                                               ret_val = 0; else 
                                                                    #line 3789 
                                                                    ret_val = -33;
    #line 3791 
    break;
    #line 3777 
    __Cont: 
            #line 3777 
    i ++;
  }
  #line 3794 
  return ret_val;
}

#line 3805  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_clear_tx_pending(struct ixgbe_hw *hw)
{
  #line 3807 
  u32 gcr_ext;
  #line 3807 
  u32 hlreg0;
  #line 3807 
  u32 i;
  #line 3807 
  u32 poll;
  #line 3808 
  u16 value;
  #line 3814 
  if (((int)hw->mac.flags & 1) == 0) 
                                     #line 3815 
                                     return;
  #line 3822 
  hlreg0 = ixgbe_read_reg(hw,16960U);
  #line 3823 
  ixgbe_write_reg_10(hw,16960U,hlreg0 | 32768U);
  #line 3826 
  ixgbe_read_reg(hw,8U);
  #line 3827 
  usleep_range(3000UL,6000UL);
  #line 3832 
  poll = ixgbe_pcie_timeout_poll(hw);
  #line 3833 
  i = 0U;
  #line 3833 
  while (i < poll) {
    {
      #line 3834 
      usleep_range(100UL,200UL);
      #line 3835 
      value = ixgbe_read_pci_cfg_word(hw,170U);
      #line 3836 
      if ((int)ixgbe_removed((void *)hw->hw_addr) != 0) 
                                                        #line 3837 
                                                        break;
      #line 3838 
      if (((int)value & 32) == 0) 
                                  #line 3839 
                                  break;
    }
    #line 3833 
    i ++;
  }
  #line 3843 
  gcr_ext = ixgbe_read_reg(hw,69712U);
  #line 3844 
  ixgbe_write_reg_10(hw,69712U,gcr_ext | 1073741824U);
  #line 3848 
  ixgbe_read_reg(hw,8U);
  #line 3849 
  __const_udelay(85900UL);
  #line 3852 
  ixgbe_write_reg_10(hw,69712U,gcr_ext);
  #line 3853 
  ixgbe_write_reg_10(hw,16960U,hlreg0);
  #line 3854 
  return;
}

#line 3856  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static u8 ixgbe_emc_temp_data[4U] = {[1] = (unsigned char)1U, (unsigned char)35U, (unsigned char)42U};
#line 3862  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static u8 ixgbe_emc_therm_limit[4U] = {(unsigned char)32U, (unsigned char)25U, (unsigned char)26U, (unsigned char)48U};
#line 3877  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_get_ets_data(struct ixgbe_hw *hw, u16 *ets_cfg, u16 *ets_offset)
{
  #line 3880 
  s32 status;
  #line 3882 
  status = (*(hw->eeprom.ops.read))(hw,(unsigned short)38,ets_offset);
  #line 3883 
  if (status != 0) 
                   #line 3884 
                   return status;
  #line 3886 
  if ((unsigned int)*ets_offset + 65535U > 65533U) 
                                                   #line 3887 
                                                   return 2147483647;
  #line 3889 
  status = (*(hw->eeprom.ops.read))(hw,(unsigned short)((int)*ets_offset),ets_cfg);
  #line 3890 
  if (status != 0) 
                   #line 3891 
                   return status;
  #line 3893 
  if (((int)*ets_cfg & 56) != 0) 
                                 #line 3894 
                                 return 2147483647;
  #line 3896 
  return 0;
}

#line 3905  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_get_thermal_sensor_data_generic(struct ixgbe_hw *hw)
{
  #line 3907 
  s32 status;
  #line 3908 
  u16 ets_offset;
  #line 3909 
  u16 ets_cfg;
  #line 3910 
  u16 ets_sensor;
  #line 3911 
  u8 num_sensors;
  #line 3912 
  u8 i;
  #line 3913 
  struct ixgbe_thermal_sensor_data *data = & hw->mac.thermal_sensor_data;
  #line 3916 
  if ((ixgbe_read_reg(hw,8U) & 4U) != 0U) 
                                          #line 3917 
                                          return 2147483647;
  #line 3919 
  status = ixgbe_get_ets_data(hw,& ets_cfg,& ets_offset);
  #line 3920 
  if (status != 0) 
                   #line 3921 
                   return status;
  #line 3923 
  num_sensors = (unsigned char)((unsigned int)((unsigned char)ets_cfg) & 7U);
  #line 3924 
  if ((unsigned int)num_sensors > 3U) 
                                      #line 3925 
                                      num_sensors = (unsigned char)3U;
  #line 3927 
  i = (unsigned char)0U;
  #line 3927 
  while ((int)i < (int)num_sensors) {
    {
      #line 3928 
      u8 sensor_index;
      #line 3929 
      u8 sensor_location;
      #line 3931 
      status = (*(hw->eeprom.ops.read))(hw,(unsigned short)((int)((unsigned int)((int)((unsigned short)i) + (int)ets_offset) + 1U)),& ets_sensor);
      #line 3933 
      if (status != 0) 
                       #line 3934 
                       return status;
      #line 3936 
      sensor_index = (unsigned char)((unsigned int)((unsigned char)((int)ets_sensor >> 8)) & 3U);
      #line 3938 
      sensor_location = (unsigned char)((unsigned int)((unsigned char)((int)ets_sensor >> 10)) & 15U);
      #line 3941 
      if ((unsigned int)sensor_location != 0U) {
        #line 3942 
        status = (*(hw->phy.ops.read_i2c_byte))(hw,(unsigned char)((int)ixgbe_emc_temp_data[(int)sensor_index]),(unsigned char)248,& data->sensor[(int)i].temp);
        #line 3946 
        if (status != 0) 
                         #line 3947 
                         return status;
      }
    }
    #line 3927 
    i = (u8)((int)i + 1);
  }
  #line 3951 
  return 0;
}

#line 3961  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_init_thermal_sensor_thresh_generic(struct ixgbe_hw *hw)
{
  #line 3963 
  s32 status;
  #line 3964 
  u16 ets_offset;
  #line 3965 
  u16 ets_cfg;
  #line 3966 
  u16 ets_sensor;
  #line 3967 
  u8 low_thresh_delta;
  #line 3968 
  u8 num_sensors;
  #line 3969 
  u8 therm_limit;
  #line 3970 
  u8 i;
  #line 3971 
  struct ixgbe_thermal_sensor_data *data = & hw->mac.thermal_sensor_data;
  #line 3973 
  memset((void *)data,0,12UL);
  #line 3976 
  if ((ixgbe_read_reg(hw,8U) & 4U) != 0U) 
                                          #line 3977 
                                          return 2147483647;
  #line 3979 
  status = ixgbe_get_ets_data(hw,& ets_cfg,& ets_offset);
  #line 3980 
  if (status != 0) 
                   #line 3981 
                   return status;
  #line 3983 
  low_thresh_delta = (unsigned char)((unsigned int)((unsigned char)((int)ets_cfg >> 6)) & 31U);
  #line 3985 
  num_sensors = (unsigned char)((unsigned int)((unsigned char)ets_cfg) & 7U);
  #line 3986 
  if ((unsigned int)num_sensors > 3U) 
                                      #line 3987 
                                      num_sensors = (unsigned char)3U;
  #line 3989 
  i = (unsigned char)0U;
  #line 3989 
  while ((int)i < (int)num_sensors) {
    {
      #line 3990 
      u8 sensor_index;
      #line 3991 
      u8 sensor_location;
      #line 3993 
      if ((*(hw->eeprom.ops.read))(hw,
                                 (unsigned short)((int)((unsigned int)(
                                                        (int)((unsigned short)i) + (int)ets_offset) + 1U)),
                                 & ets_sensor) != 0) {
        #line 3994 
        netdev_err(((struct ixgbe_adapter *)hw->back)->netdev,(char *)"eeprom read at offset %d failed\n",((int)ets_offset + 1) + (int)i);
        #line 3996 
        goto __Cont;
      }
      #line 3998 
      sensor_index = (unsigned char)((unsigned int)((unsigned char)((int)ets_sensor >> 8)) & 3U);
      #line 4000 
      sensor_location = (unsigned char)((unsigned int)((unsigned char)((int)ets_sensor >> 10)) & 15U);
      #line 4002 
      therm_limit = (unsigned char)ets_sensor;
      #line 4004 
      (*(hw->phy.ops.write_i2c_byte))(hw,(unsigned char)((int)ixgbe_emc_therm_limit[(int)sensor_index]),(unsigned char)248,(unsigned char)((int)therm_limit));
      #line 4008 
      if ((unsigned int)sensor_location == 0U) 
                                               #line 4009 
                                               goto __Cont;
      #line 4011 
      data->sensor[(int)i].location = sensor_location;
      #line 4012 
      data->sensor[(int)i].caution_thresh = therm_limit;
      #line 4013 
      data->sensor[(int)i].max_op_thresh = (unsigned char)((int)therm_limit - (int)low_thresh_delta);
    }
    #line 3989 
    __Cont: 
            #line 3989 
    i = (u8)((int)i + 1);
  }
  #line 4016 
  return 0;
}

#line 4028  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_get_orom_version(struct ixgbe_hw *hw, struct ixgbe_nvm_version *nvm_ver)
{
  #line 4031 
  u16 offset;
  #line 4031 
  u16 eeprom_cfg_blkh;
  #line 4031 
  u16 eeprom_cfg_blkl;
  #line 4033 
  nvm_ver->or_valid = (_Bool)0;
  #line 4035 
  (*(hw->eeprom.ops.read))(hw,(unsigned short)23,& offset);
  #line 4038 
  if ((unsigned int)offset + 65535U > 65533U) 
                                              #line 4039 
                                              return;
  #line 4041 
  (*(hw->eeprom.ops.read))(hw,(unsigned short)((int)((unsigned int)offset + 132U)),& eeprom_cfg_blkh);
  #line 4042 
  (*(hw->eeprom.ops.read))(hw,(unsigned short)((int)((unsigned int)offset + 131U)),& eeprom_cfg_blkl);
  #line 4045 
  if (((unsigned int)((int)eeprom_cfg_blkl | (int)eeprom_cfg_blkh) == 0U || (unsigned int)eeprom_cfg_blkl == 65535U) || (unsigned int)eeprom_cfg_blkh == 65535U) 
    #line 4048 
    return;
  #line 4050 
  nvm_ver->or_valid = (_Bool)1;
  #line 4051 
  nvm_ver->or_major = (unsigned char)((int)eeprom_cfg_blkl >> 8);
  #line 4052 
  nvm_ver->or_build = (unsigned short)(((int)eeprom_cfg_blkl << 8) | ((int)eeprom_cfg_blkh >> 8));
  #line 4054 
  nvm_ver->or_patch = (unsigned char)eeprom_cfg_blkh;
  #line 4055 
  return;
}

#line 4066  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_get_oem_prod_version(struct ixgbe_hw *hw, struct ixgbe_nvm_version *nvm_ver)
{
  #line 4069 
  u16 rel_num;
  #line 4069 
  u16 prod_ver;
  #line 4069 
  u16 mod_len;
  #line 4069 
  u16 cap;
  #line 4069 
  u16 offset;
  #line 4071 
  nvm_ver->oem_valid = (_Bool)0;
  #line 4072 
  (*(hw->eeprom.ops.read))(hw,(unsigned short)27,& offset);
  #line 4075 
  if ((unsigned int)offset + 65535U > 65533U) 
                                              #line 4076 
                                              return;
  #line 4079 
  (*(hw->eeprom.ops.read))(hw,(unsigned short)((int)offset),& mod_len);
  #line 4080 
  (*(hw->eeprom.ops.read))(hw,(unsigned short)((int)((unsigned int)offset + 1U)),& cap);
  #line 4083 
  if ((unsigned int)mod_len != 3U || ((int)cap & 15) != 0) 
                                                           #line 4085 
                                                           return;
  #line 4087 
  (*(hw->eeprom.ops.read))(hw,(unsigned short)((int)((unsigned int)offset + 2U)),& prod_ver);
  #line 4088 
  (*(hw->eeprom.ops.read))(hw,(unsigned short)((int)((unsigned int)offset + 3U)),& rel_num);
  #line 4091 
  if (((unsigned int)((int)rel_num | (int)prod_ver) == 0U || (unsigned int)rel_num == 65535U) || (unsigned int)prod_ver == 65535U) 
    #line 4093 
    return;
  #line 4095 
  nvm_ver->oem_major = (unsigned char)((int)prod_ver >> 8);
  #line 4096 
  nvm_ver->oem_minor = (unsigned char)prod_ver;
  #line 4097 
  nvm_ver->oem_release = rel_num;
  #line 4098 
  nvm_ver->oem_valid = (_Bool)1;
  #line 4099 
  return;
}

#line 4109  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_get_etk_id(struct ixgbe_hw *hw, struct ixgbe_nvm_version *nvm_ver)
{
  #line 4112 
  u16 etk_id_l;
  #line 4112 
  u16 etk_id_h;
  #line 4114 
  if ((*(hw->eeprom.ops.read))(hw,(unsigned short)45,& etk_id_l) != 0) 
    #line 4115 
    etk_id_l = (unsigned short)65535U;
  #line 4116 
  if ((*(hw->eeprom.ops.read))(hw,(unsigned short)46,& etk_id_h) != 0) 
    #line 4117 
    etk_id_h = (unsigned short)65535U;
  #line 4122 
  if (((int)etk_id_h & 32768) == 0) {
    #line 4123 
    nvm_ver->etk_id = (unsigned int)etk_id_h;
    #line 4124 
    nvm_ver->etk_id |= (unsigned int)((int)etk_id_l << 16);
  }
  else {
    #line 4126 
    nvm_ver->etk_id = (unsigned int)etk_id_l;
    #line 4127 
    nvm_ver->etk_id |= (unsigned int)((int)etk_id_h << 16);
  }
  #line 4129 
  return;
}

#line 4131  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_disable_rx_generic(struct ixgbe_hw *hw)
{
  #line 4133 
  u32 rxctrl;
  #line 4135 
  rxctrl = ixgbe_read_reg(hw,12288U);
  #line 4136 
  if ((rxctrl & 1U) != 0U) {
    #line 4137 
    if (hw->mac.type != (unsigned int)ixgbe_mac_82598EB) {
      #line 4138 
      u32 pfdtxgswc;
      #line 4140 
      pfdtxgswc = ixgbe_read_reg(hw,33312U);
      #line 4141 
      if ((pfdtxgswc & 1U) != 0U) {
        #line 4142 
        pfdtxgswc &= 4294967294U;
        #line 4143 
        ixgbe_write_reg_10(hw,33312U,pfdtxgswc);
        #line 4144 
        hw->mac.set_lben = (_Bool)1;
      }
      else 
           #line 4146 
           hw->mac.set_lben = (_Bool)0;
    }
    #line 4149 
    rxctrl &= 4294967294U;
    #line 4150 
    ixgbe_write_reg_10(hw,12288U,rxctrl);
  }
  #line 4152 
  return;
}

#line 4154  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_enable_rx_generic(struct ixgbe_hw *hw)
{
  #line 4156 
  u32 rxctrl;
  #line 4158 
  rxctrl = ixgbe_read_reg(hw,12288U);
  #line 4159 
  ixgbe_write_reg_10(hw,12288U,rxctrl | 1U);
  #line 4161 
  if (hw->mac.type != (unsigned int)ixgbe_mac_82598EB) 
    #line 4162 
    if ((int)hw->mac.set_lben != 0) {
      #line 4163 
      u32 pfdtxgswc;
      #line 4165 
      pfdtxgswc = ixgbe_read_reg(hw,33312U);
      #line 4166 
      pfdtxgswc |= 1U;
      #line 4167 
      ixgbe_write_reg_10(hw,33312U,pfdtxgswc);
      #line 4168 
      hw->mac.set_lben = (_Bool)0;
    }
  #line 4170 
  return;
}

#line 4176  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
bool ixgbe_mng_present(struct ixgbe_hw *hw)
{
  #line 4178 
  u32 fwsm;
  #line 4180 
  if (hw->mac.type <= (unsigned int)ixgbe_mac_82598EB) 
                                                       #line 4181 
                                                       return (_Bool)0;
  #line 4183 
  fwsm = ixgbe_read_reg(hw,*(hw->mvals + 6U));
  #line 4185 
  return (_Bool)((fwsm & 4U) != 0U);
}

#line 4196  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_setup_mac_link_multispeed_fiber(struct ixgbe_hw *hw, ixgbe_link_speed speed, bool autoneg_wait_to_complete)
{
  #line 4205 
  bool autoneg;
  #line 4200 
  ixgbe_link_speed link_speed = 0U;
  #line 4201 
  ixgbe_link_speed highest_link_speed = 0U;
  #line 4202 
  s32 status = 0;
  #line 4203 
  u32 speedcnt = 0U;
  #line 4204 
  u32 i = 0U;
  #line 4205 
  bool link_up = (_Bool)0;
  #line 4208 
  status = (*(hw->mac.ops.get_link_capabilities))(hw,& link_speed,& autoneg);
  #line 4209 
  if (status != 0) 
                   #line 4210 
                   return status;
  #line 4212 
  speed &= link_speed;
  #line 4217 
  if ((speed & 128U) != 0U) {
    #line 4218 
    speedcnt ++;
    #line 4219 
    highest_link_speed = 128U;
    #line 4222 
    switch ((unsigned int)hw->phy.media_type) {
      #line 4223 
      case (unsigned int)1: 
                            #line 4223 
      ;
      #line 4224 
      (*(hw->mac.ops.set_rate_select_speed))(hw,128U);
      #line 4226 
      break;
      #line 4227 
      case (unsigned int)2: 
                            #line 4227 
      ;
      #line 4229 
      break;
      #line 4230 
      default: 
               #line 4230 
      ;
      {
        #line 4231 
        bool branch;
        #line 4231 
        struct _ddebug __UNIQUE_ID_ddebug506 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_setup_mac_link_multispeed_fiber", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Unexpected media type\n", .lineno = (unsigned int)4231U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 4231 
        branch = arch_static_branch(& __UNIQUE_ID_ddebug506.key.dd_key_false.key,(_Bool)0);
        #line 4231 
        if ((long)((long)((int)branch != 0)) != 0L) 
                                                    #line 4231 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug506,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Unexpected media type\n");
      }
      #line 4232 
      break;
    }
    #line 4236 
    msleep(40U);
    #line 4238 
    status = (*(hw->mac.ops.setup_mac_link))(hw,128U,(_Bool)((bool)((int)autoneg_wait_to_complete) != 0));
    #line 4241 
    if (status != 0) 
                     #line 4242 
                     return status;
    #line 4245 
    if (hw->mac.ops.flap_tx_laser != (void (*)(struct ixgbe_hw *))0) 
      #line 4246 
      (*(hw->mac.ops.flap_tx_laser))(hw);
    #line 4252 
    i = 0U;
    #line 4252 
    while (i <= 4U) {
      #line 4254 
      msleep(100U);
      #line 4257 
      status = (*(hw->mac.ops.check_link))(hw,& link_speed,& link_up,(_Bool)0);
      #line 4259 
      if (status != 0) 
                       #line 4260 
                       return status;
      #line 4262 
      if ((int)link_up != 0) 
                             #line 4263 
                             goto out;
      #line 4252 
      i ++;
    }
  }
  #line 4267 
  if ((speed & 32U) != 0U) {
    #line 4268 
    speedcnt ++;
    #line 4269 
    if (highest_link_speed == 0U) 
                                  #line 4270 
                                  highest_link_speed = 32U;
    #line 4273 
    switch ((unsigned int)hw->phy.media_type) {
      #line 4274 
      case (unsigned int)1: 
                            #line 4274 
      ;
      #line 4275 
      (*(hw->mac.ops.set_rate_select_speed))(hw,32U);
      #line 4277 
      break;
      #line 4278 
      case (unsigned int)2: 
                            #line 4278 
      ;
      #line 4280 
      break;
      #line 4281 
      default: 
               #line 4281 
      ;
      {
        #line 4282 
        bool branch_0;
        #line 4282 
        struct _ddebug __UNIQUE_ID_ddebug507 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_setup_mac_link_multispeed_fiber", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Unexpected media type\n", .lineno = (unsigned int)4282U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 4282 
        branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug507.key.dd_key_false.key,(_Bool)0);
        #line 4282 
        if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                      #line 4282 
                                                      __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug507,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Unexpected media type\n");
      }
      #line 4283 
      break;
    }
    #line 4287 
    msleep(40U);
    #line 4289 
    status = (*(hw->mac.ops.setup_mac_link))(hw,32U,(_Bool)((bool)((int)autoneg_wait_to_complete) != 0));
    #line 4292 
    if (status != 0) 
                     #line 4293 
                     return status;
    #line 4296 
    if (hw->mac.ops.flap_tx_laser != (void (*)(struct ixgbe_hw *))0) 
      #line 4297 
      (*(hw->mac.ops.flap_tx_laser))(hw);
    #line 4300 
    msleep(100U);
    #line 4303 
    status = (*(hw->mac.ops.check_link))(hw,& link_speed,& link_up,(_Bool)0);
    #line 4305 
    if (status != 0) 
                     #line 4306 
                     return status;
    #line 4308 
    if ((int)link_up != 0) 
                           #line 4309 
                           goto out;
  }
  #line 4316 
  if (speedcnt > 1U) 
                     #line 4317 
                     status = ixgbe_setup_mac_link_multispeed_fiber(hw,highest_link_speed,(_Bool)((bool)((int)autoneg_wait_to_complete) != 0));
  #line 4321 
  out: 
       #line 4321 
  ;
  #line 4323 
  hw->phy.autoneg_advertised = 0U;
  #line 4325 
  if ((speed & 128U) != 0U) 
                            #line 4326 
                            hw->phy.autoneg_advertised |= 128U;
  #line 4328 
  if ((speed & 32U) != 0U) 
                           #line 4329 
                           hw->phy.autoneg_advertised |= 32U;
  #line 4331 
  return status;
}

#line 4341  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_set_soft_rate_select_speed(struct ixgbe_hw *hw, ixgbe_link_speed speed)
{
  #line 4344 
  s32 status;
  #line 4345 
  u8 rs;
  #line 4345 
  u8 eeprom_data;
  #line 4347 
  switch (speed) {
    #line 4348 
    case (ixgbe_link_speed)128: 
                                #line 4348 
    ;
    #line 4350 
    rs = (unsigned char)8U;
    #line 4351 
    break;
    #line 4352 
    case (ixgbe_link_speed)32: 
                               #line 4352 
    ;
    #line 4353 
    rs = (unsigned char)0U;
    #line 4354 
    break;
    #line 4355 
    default: 
             #line 4355 
    ;
    {
      #line 4356 
      bool branch;
      #line 4356 
      struct _ddebug __UNIQUE_ID_ddebug508 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_set_soft_rate_select_speed", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Invalid fixed module speed\n", .lineno = (unsigned int)4356U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 4356 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug508.key.dd_key_false.key,(_Bool)0);
      #line 4356 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 4356 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug508,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Invalid fixed module speed\n");
    }
    #line 4357 
    return;
  }
  #line 4361 
  status = (*(hw->phy.ops.read_i2c_byte))(hw,(unsigned char)110,(unsigned char)162,& eeprom_data);
  #line 4364 
  if (status != 0) {
    {
      #line 4365 
      bool branch_0;
      #line 4365 
      struct _ddebug __UNIQUE_ID_ddebug509 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_set_soft_rate_select_speed", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Failed to read Rx Rate Select RS0\n", .lineno = (unsigned int)4365U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 4365 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug509.key.dd_key_false.key,(_Bool)0);
      #line 4365 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 4365 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug509,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Failed to read Rx Rate Select RS0\n");
    }
    #line 4366 
    return;
  }
  #line 4369 
  eeprom_data = (unsigned char)(((int)eeprom_data & -9) | (int)rs);
  #line 4371 
  status = (*(hw->phy.ops.write_i2c_byte))(hw,(unsigned char)110,(unsigned char)162,(unsigned char)((int)eeprom_data));
  #line 4374 
  if (status != 0) {
    {
      #line 4375 
      bool branch_1;
      #line 4375 
      struct _ddebug __UNIQUE_ID_ddebug510 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_set_soft_rate_select_speed", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Failed to write Rx Rate Select RS0\n", .lineno = (unsigned int)4375U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 4375 
      branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug510.key.dd_key_false.key,(_Bool)0);
      #line 4375 
      if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                    #line 4375 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug510,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Failed to write Rx Rate Select RS0\n");
    }
    #line 4376 
    return;
  }
  #line 4380 
  status = (*(hw->phy.ops.read_i2c_byte))(hw,(unsigned char)118,(unsigned char)162,& eeprom_data);
  #line 4383 
  if (status != 0) {
    {
      #line 4384 
      bool branch_2;
      #line 4384 
      struct _ddebug __UNIQUE_ID_ddebug511 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_set_soft_rate_select_speed", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Failed to read Rx Rate Select RS1\n", .lineno = (unsigned int)4384U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 4384 
      branch_2 = arch_static_branch(& __UNIQUE_ID_ddebug511.key.dd_key_false.key,(_Bool)0);
      #line 4384 
      if ((long)((long)((int)branch_2 != 0)) != 0L) 
                                                    #line 4384 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug511,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Failed to read Rx Rate Select RS1\n");
    }
    #line 4385 
    return;
  }
  #line 4388 
  eeprom_data = (unsigned char)(((int)eeprom_data & -9) | (int)rs);
  #line 4390 
  status = (*(hw->phy.ops.write_i2c_byte))(hw,(unsigned char)118,(unsigned char)162,(unsigned char)((int)eeprom_data));
  #line 4393 
  if (status != 0) {
    {
      #line 4394 
      bool branch_3;
      #line 4394 
      struct _ddebug __UNIQUE_ID_ddebug512 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_set_soft_rate_select_speed", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c", .format = (char *)"Failed to write Rx Rate Select RS1\n", .lineno = (unsigned int)4394U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 4394 
      branch_3 = arch_static_branch(& __UNIQUE_ID_ddebug512.key.dd_key_false.key,(_Bool)0);
      #line 4394 
      if ((long)((long)((int)branch_3 != 0)) != 0L) 
                                                    #line 4394 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug512,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Failed to write Rx Rate Select RS1\n");
    }
    #line 4395 
    return;
  }
  #line 4397 
  return;
}

#line 747  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static int hlist_unhashed(struct hlist_node *h)
{
  #line 749 
  return h->pprev == (struct hlist_node **)0;
}

#line 757  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void __hlist_del_1(struct hlist_node *n)
{
  #line 759 
  struct hlist_node *next = n->next;
  #line 760 
  struct hlist_node **pprev = n->pprev;
  {
    #line 763 
    union __anonunion___u_11498 __u = {.__val = next};
    #line 762 
    __write_once_size((void *)pprev,(void *)(& __u.__c),8);
    #line 762 
    struct hlist_node *tmp = __u.__val;
  }
  #line 763 
  if (next != (struct hlist_node *)0) 
                                      #line 764 
                                      next->pprev = pprev;
  #line 765 
  return;
}

#line 49  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/string.h"
#line 836  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ipsec.i.aux"
static int cif_strcmp(char *cs, char *ct);
#line 26  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/string.h"
#line 26 
int ldv_strcmp(char *cs, char *ct);
#line 224  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcupdate.h"
#line 224 
int rcu_read_lock_any_held(void);
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rculist.h"
__inline static void hlist_del_init_rcu(struct hlist_node *n)
{
  #line 174 
  if (hlist_unhashed(n) == 0) {
    #line 175 
    __hlist_del_1(n);
    #line 176 
    n->pprev = (struct hlist_node **)0;
  }
  #line 178 
  return;
}

#line 525  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rculist.h"
__inline static void hlist_add_head_rcu(struct hlist_node *n, struct hlist_head *h)
{
  #line 528 
  struct hlist_node *first = h->first;
  #line 530 
  n->next = first;
  #line 531 
  n->pprev = & h->first;
  {
    #line 532 
    uintptr_t _r_a_p__v = (unsigned long)n;
    #line 534 
    ldv_inline_asm();
    {
      #line 533 
      union __anonunion___u_11758 __u = {.__val = (struct hlist_node *)_r_a_p__v};
      #line 532 
      __write_once_size((void *)(& h->first),(void *)(& __u.__c),8);
      #line 532 
      struct hlist_node *tmp_3 = __u.__val;
    }
  }
  #line 533 
  if (first != (struct hlist_node *)0) 
                                       #line 534 
                                       first->pprev = & n->next;
  #line 535 
  return;
}

#line 190  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 190 
void kzfree(void *);
#line 668 
#line 486  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ipsec.i.aux"
static void *kzalloc_2(size_t size, gfp_t flags);
#line 60  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/hash.h"
__inline static u32 __hash_32_generic(u32 val)
{
  #line 62 
  return val * 1640531527U;
}

#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/hash.h"
__inline static u32 hash_32_generic(u32 val, unsigned int bits)
{
  #line 71 
  ;
  #line 71 
  return __hash_32_generic(val) >> (32U - bits);
}

#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/hashtable.h"
__inline static void __hash_init(struct hlist_head *ht, unsigned int sz)
{
  #line 36 
  unsigned int i;
  #line 38 
  i = 0U;
  #line 38 
  while (i < sz) {
    #line 39 
    (ht + (unsigned long)i)->first = (struct hlist_node *)0;
    #line 38 
    i ++;
  }
  #line 40 
  return;
}

#line 114  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/hashtable.h"
__inline static void hash_del_rcu(struct hlist_node *node)
{
  #line 116 
  hlist_del_init_rcu(node);
  #line 117 
  return;
}

#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static void ixgbe_write_reg_11(struct ixgbe_hw *hw, u32 reg, u32 value)
{
  #line 147 
  union __anonunion___u_12197 __u;
  #line 146 
  __read_once_size((void *)(& hw->hw_addr),(void *)(& __u.__c),8);
  #line 146 
  u8 *reg_addr = (__u.__val);
  #line 148 
  if ((int)ixgbe_removed((void *)reg_addr) != 0) 
                                                 #line 149 
                                                 return;
  #line 150 
  writel(value,(void *)(reg_addr + (unsigned long)reg));
  #line 151 
  return;
}

#line 1016  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 840  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
void ixgbe_ipsec_vf_clear(struct ixgbe_adapter *adapter, u32 vf);
#line 1017  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 879  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
int ixgbe_ipsec_vf_add_sa(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf);
#line 1018  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
#line 989  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
int ixgbe_ipsec_vf_del_sa(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf);
#line 92  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ipv6.h"
__inline static struct ipv6hdr *ipv6_hdr(struct sk_buff *skb)
{
  #line 94 
  return (struct ipv6hdr *)skb_network_header(skb);
}

#line 1060  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ipv6.h"
#line 1060 
bool ipv6_ext_hdr(u8);
#line 802  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
__inline static void xfrm_state_hold(struct xfrm_state *x)
{
  #line 804 
  refcount_inc(& x->refcnt);
  #line 805 
  return;
}

#line 1037 
#line 1037 
struct sec_path *secpath_set(struct sk_buff *);
#line 1684 
#line 1684 
struct xfrm_algo_desc *xfrm_aead_get_byname(char *, int, int);
#line 1816  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xfrm.h"
__inline static struct xfrm_state *xfrm_input_state(struct sk_buff *skb)
{
  #line 1818 
  struct sec_path *sp = skb_sec_path(skb);
  #line 1820 
  return sp->xvec[sp->len + -1];
}

#line 10  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
static char aes_gcm_name[18U] = {(char)'r', (char)'f', (char)'c', (char)'4', (char)'1', (char)'0', (char)'6', (char)'(', (char)'g', (char)'c', (char)'m', (char)'(', (char)'a', (char)'e', (char)'s', (char)')', (char)')'};
#line 12 
#line 746 
static void ixgbe_ipsec_del_sa(struct xfrm_state *xs);
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
static void ixgbe_ipsec_set_tx_sa(struct ixgbe_hw *hw, u16 idx, u32 *key, u32 salt)
{
  #line 24 
  u32 reg;
  #line 25 
  int i;
  #line 27 
  i = 0;
  #line 27 
  while (i <= 3) {
    #line 28 
    ;
    #line 28 
    ;
    #line 28 
    ixgbe_write_reg_11(hw,(unsigned int)((i + 8770) * 4),__builtin_bswap32(*(key + (unsigned long)(3 - i))));
    #line 27 
    i ++;
  }
  #line 30 
  ;
  #line 30 
  ixgbe_write_reg_11(hw,35076U,__builtin_bswap32(salt));
  #line 31 
  ixgbe_read_reg(hw,8U);
  #line 33 
  reg = ixgbe_read_reg(hw,35072U);
  #line 34 
  reg &= 1U;
  #line 35 
  reg = ((unsigned int)((int)idx << 3) | reg) | 2147483648U;
  #line 36 
  ixgbe_write_reg_11(hw,35072U,reg);
  #line 37 
  ixgbe_read_reg(hw,8U);
  #line 38 
  return;
}

#line 49  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
static void ixgbe_ipsec_set_rx_item(struct ixgbe_hw *hw, u16 idx, enum ixgbe_ipsec_tbl_sel tbl)
{
  #line 52 
  u32 reg;
  #line 54 
  reg = ixgbe_read_reg(hw,36352U);
  #line 55 
  reg &= 1U;
  #line 56 
  reg = ((((unsigned int)tbl << 1) | (unsigned int)((int)idx << 3)) | reg) | 2147483648U;
  #line 59 
  ixgbe_write_reg_11(hw,36352U,reg);
  #line 60 
  ixgbe_read_reg(hw,8U);
  #line 61 
  return;
}

#line 73  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
static void ixgbe_ipsec_set_rx_sa(struct ixgbe_hw *hw, u16 idx, __be32 spi, u32 *key, u32 salt, u32 mode, u32 ip_idx)
{
  #line 76 
  int i;
  #line 79 
  ixgbe_write_reg_11(hw,36372U,spi);
  #line 81 
  ixgbe_write_reg_11(hw,36376U,ip_idx);
  #line 82 
  ixgbe_read_reg(hw,8U);
  #line 84 
  ixgbe_ipsec_set_rx_item(hw,(unsigned short)((int)idx),(enum ixgbe_ipsec_tbl_sel)ips_rx_spi_tbl);
  #line 87 
  i = 0;
  #line 87 
  while (i <= 3) {
    #line 88 
    ;
    #line 88 
    ;
    #line 88 
    ixgbe_write_reg_11(hw,(unsigned int)((i + 9095) * 4),__builtin_bswap32(*(key + (unsigned long)(3 - i))));
    #line 87 
    i ++;
  }
  #line 90 
  ;
  #line 90 
  ixgbe_write_reg_11(hw,36396U,__builtin_bswap32(salt));
  #line 91 
  ixgbe_write_reg_11(hw,36400U,mode);
  #line 92 
  ixgbe_read_reg(hw,8U);
  #line 94 
  ixgbe_ipsec_set_rx_item(hw,(unsigned short)((int)idx),(enum ixgbe_ipsec_tbl_sel)ips_rx_key_tbl);
  #line 95 
  return;
}

#line 103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
static void ixgbe_ipsec_set_rx_ip(struct ixgbe_hw *hw, u16 idx, __be32 *addr)
{
  #line 105 
  int i;
  #line 108 
  i = 0;
  #line 108 
  while (i <= 3) {
    #line 109 
    ixgbe_write_reg_11(hw,(unsigned int)((i + 9089) * 4),*(addr + (unsigned long)i));
    #line 108 
    i ++;
  }
  #line 111 
  ixgbe_read_reg(hw,8U);
  #line 113 
  ixgbe_ipsec_set_rx_item(hw,(unsigned short)((int)idx),(enum ixgbe_ipsec_tbl_sel)ips_rx_ip_tbl);
  #line 114 
  return;
}

#line 120  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
static void ixgbe_ipsec_clear_hw_tables(struct ixgbe_adapter *adapter)
{
  #line 124 
  u16 idx;
  #line 122 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 123 
  u32 buf[4U] = {0U, 0U, 0U, 0U};
  #line 127 
  ixgbe_write_reg_11(hw,36352U,0U);
  #line 128 
  ixgbe_write_reg_11(hw,35072U,0U);
  #line 131 
  idx = (unsigned short)0U;
  #line 131 
  while ((unsigned int)idx <= 127U) {
    #line 132 
    ixgbe_ipsec_set_tx_sa(hw,(unsigned short)((int)idx),(u32 *)(& buf),0U);
    #line 133 
    ixgbe_ipsec_set_rx_sa(hw,(unsigned short)((int)idx),0U,(u32 *)(& buf),0U,0U,0U);
    #line 134 
    ixgbe_ipsec_set_rx_ip(hw,(unsigned short)((int)idx),(__be32 *)(& buf));
    #line 131 
    idx = (u16)((int)idx + 1);
  }
  #line 136 
  while ((unsigned int)idx <= 1023U) {
    #line 137 
    ixgbe_ipsec_set_tx_sa(hw,(unsigned short)((int)idx),(u32 *)(& buf),0U);
    #line 138 
    ixgbe_ipsec_set_rx_sa(hw,(unsigned short)((int)idx),0U,(u32 *)(& buf),0U,0U,0U);
    #line 136 
    idx = (u16)((int)idx + 1);
  }
  #line 140 
  return;
}

#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
static void ixgbe_ipsec_stop_data(struct ixgbe_adapter *adapter)
{
  #line 150 
  u32 t_rdy;
  #line 150 
  u32 r_rdy;
  #line 151 
  u32 limit;
  #line 152 
  u32 reg;
  #line 148 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 149 
  bool link = adapter->link_up;
  #line 155 
  reg = ixgbe_read_reg(hw,34816U);
  #line 156 
  reg |= 2U;
  #line 157 
  ixgbe_write_reg_11(hw,34816U,reg);
  #line 159 
  reg = ixgbe_read_reg(hw,36096U);
  #line 160 
  reg |= 2U;
  #line 161 
  ixgbe_write_reg_11(hw,36096U,reg);
  #line 167 
  t_rdy = ixgbe_read_reg(hw,34820U) & 1U;
  #line 169 
  r_rdy = ixgbe_read_reg(hw,36100U) & 1U;
  #line 171 
  if (t_rdy != 0U && r_rdy != 0U) 
                                  #line 172 
                                  return;
  #line 178 
  if (! link) {
    #line 179 
    reg = ixgbe_read_reg(hw,17200U);
    #line 180 
    reg |= 1U;
    #line 181 
    ixgbe_write_reg_11(hw,17200U,reg);
    #line 183 
    reg = ixgbe_read_reg(hw,16960U);
    #line 184 
    reg |= 32768U;
    #line 185 
    ixgbe_write_reg_11(hw,16960U,reg);
    #line 187 
    ixgbe_read_reg(hw,8U);
    #line 188 
    __const_udelay(12885000UL);
  }
  #line 192 
  limit = 20U;
  #line 193 
  while (1) {
    {
      {
        #line 194 
        unsigned long __ms = 10UL;
        #line 194 
        while (1) {
          #line 194 
          unsigned long tmp_1;
          #line 194 
          tmp_1 = __ms;
          #line 194 
          __ms --;
          #line 194 
          ;
          #line 194 
          if (! (tmp_1 != 0UL)) 
                                #line 194 
                                break;
          #line 194 
          __const_udelay(4295000UL);
        }
      }
      #line 195 
      t_rdy = ixgbe_read_reg(hw,34820U) & 1U;
      #line 197 
      r_rdy = ixgbe_read_reg(hw,36100U) & 1U;
    }
    #line 198 
    if (t_rdy == 0U || r_rdy == 0U) {
      #line 199 
      u32 tmp_4;
      #line 199 
      tmp_4 = limit;
      #line 199 
      limit --;
      #line 199 
      ;
      #line 199 
      if (! (tmp_4 != 0U)) 
                           #line 193 
                           break;
    }
    else 
         #line 193 
         break;
  }
  #line 202 
  if (! link) {
    #line 203 
    reg = ixgbe_read_reg(hw,17200U);
    #line 204 
    reg &= 4294967294U;
    #line 205 
    ixgbe_write_reg_11(hw,17200U,reg);
    #line 207 
    reg = ixgbe_read_reg(hw,16960U);
    #line 208 
    reg &= 4294934527U;
    #line 209 
    ixgbe_write_reg_11(hw,16960U,reg);
    #line 211 
    ixgbe_read_reg(hw,8U);
  }
  #line 213 
  return;
}

#line 219  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
static void ixgbe_ipsec_stop_engine(struct ixgbe_adapter *adapter)
{
  #line 222 
  u32 reg;
  #line 221 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 224 
  ixgbe_ipsec_stop_data(adapter);
  #line 227 
  ixgbe_write_reg_11(hw,35072U,0U);
  #line 228 
  ixgbe_write_reg_11(hw,36352U,0U);
  #line 231 
  reg = ixgbe_read_reg(hw,34816U);
  #line 232 
  reg |= 1U;
  #line 233 
  reg &= 4294967291U;
  #line 234 
  ixgbe_write_reg_11(hw,34816U,reg);
  #line 236 
  reg = ixgbe_read_reg(hw,36096U);
  #line 237 
  reg |= 1U;
  #line 238 
  ixgbe_write_reg_11(hw,36096U,reg);
  #line 241 
  ixgbe_write_reg_11(hw,34824U,592U);
  #line 244 
  reg = ixgbe_read_reg(hw,34832U);
  #line 245 
  reg = (reg & 4294967280U) | 1U;
  #line 246 
  ixgbe_write_reg_11(hw,34832U,reg);
  #line 249 
  ixgbe_write_reg_11(hw,34816U,1U);
  #line 250 
  ixgbe_write_reg_11(hw,36096U,1U);
  #line 252 
  ixgbe_read_reg(hw,8U);
  #line 253 
  return;
}

#line 261  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
static void ixgbe_ipsec_start_engine(struct ixgbe_adapter *adapter)
{
  #line 264 
  u32 reg;
  #line 263 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 266 
  ixgbe_ipsec_stop_data(adapter);
  #line 269 
  reg = ixgbe_read_reg(hw,34832U);
  #line 270 
  reg = (reg & 4294967280U) | 3U;
  #line 271 
  ixgbe_write_reg_11(hw,34832U,reg);
  #line 277 
  reg = ixgbe_read_reg(hw,34824U);
  #line 278 
  reg = (reg & 4294966272U) | 21U;
  #line 279 
  ixgbe_write_reg_11(hw,34824U,reg);
  #line 282 
  ixgbe_write_reg_11(hw,36096U,0U);
  #line 283 
  ixgbe_write_reg_11(hw,34816U,4U);
  #line 286 
  ixgbe_write_reg_11(hw,35072U,1U);
  #line 287 
  ixgbe_write_reg_11(hw,36352U,1U);
  #line 289 
  ixgbe_read_reg(hw,8U);
  #line 290 
  return;
}

#line 303  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
void ixgbe_ipsec_restore(struct ixgbe_adapter *adapter)
{
  #line 307 
  int i;
  #line 305 
  struct ixgbe_ipsec *ipsec = adapter->ipsec;
  #line 306 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 309 
  if (((unsigned long)adapter->flags2 & 131072UL) == 0UL) 
                                                          #line 310 
                                                          return;
  #line 313 
  ixgbe_ipsec_stop_engine(adapter);
  #line 314 
  ixgbe_ipsec_clear_hw_tables(adapter);
  #line 315 
  ixgbe_ipsec_start_engine(adapter);
  #line 318 
  i = 0;
  #line 318 
  while (i <= 1023) {
    {
      #line 319 
      struct rx_sa *r = ipsec->rx_tbl + (unsigned long)i;
      #line 320 
      struct tx_sa *t = ipsec->tx_tbl + (unsigned long)i;
      #line 322 
      if ((int)r->used != 0) 
        #line 323 
        if ((r->mode & 32U) != 0U) 
                                   #line 324 
                                   ixgbe_ipsec_del_sa(r->xs); else 
                                                                   #line 326 
                                                                   ixgbe_ipsec_set_rx_sa(hw,(unsigned short)((int)((unsigned short)i)),(r->xs)->id.spi,(u32 *)(& r->key),r->salt,r->mode,(unsigned int)r->iptbl_ind);
      #line 331 
      if ((int)t->used != 0) 
        #line 332 
        if ((t->mode & 32U) != 0U) 
                                   #line 333 
                                   ixgbe_ipsec_del_sa(t->xs); else 
                                                                   #line 335 
                                                                   ixgbe_ipsec_set_tx_sa(hw,(unsigned short)((int)((unsigned short)i)),(u32 *)(& t->key),t->salt);
    }
    #line 318 
    i ++;
  }
  #line 340 
  i = 0;
  #line 340 
  while (i <= 127) {
    {
      #line 341 
      struct rx_ip_sa *ipsa = ipsec->ip_tbl + (unsigned long)i;
      #line 343 
      if ((int)ipsa->used != 0) 
                                #line 344 
                                ixgbe_ipsec_set_rx_ip(hw,(unsigned short)((int)((unsigned short)i)),(__be32 *)(& ipsa->ipaddr));
    }
    #line 340 
    i ++;
  }
  #line 346 
  return;
}

#line 355  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
static int ixgbe_ipsec_find_empty_idx(struct ixgbe_ipsec *ipsec, bool rxtable)
{
  #line 357 
  u32 i;
  #line 359 
  if ((int)rxtable != 0) {
    #line 360 
    if ((unsigned int)ipsec->num_rx_sa == 1024U) 
                                                 #line 361 
                                                 return -28;
    #line 364 
    i = 0U;
    #line 364 
    while (i <= 1023U) {
      #line 365 
      if (! (ipsec->rx_tbl + (unsigned long)i)->used) 
                                                      #line 366 
                                                      return (int)i;
      #line 364 
      i ++;
    }
  }
  else {
    #line 369 
    if ((unsigned int)ipsec->num_tx_sa == 1024U) 
                                                 #line 370 
                                                 return -28;
    #line 373 
    i = 0U;
    #line 373 
    while (i <= 1023U) {
      #line 374 
      if (! (ipsec->tx_tbl + (unsigned long)i)->used) 
                                                      #line 375 
                                                      return (int)i;
      #line 373 
      i ++;
    }
  }
  #line 379 
  return -28;
}

#line 392  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
static struct xfrm_state *ixgbe_ipsec_find_rx_state(struct ixgbe_ipsec *ipsec, __be32 *daddr, u8 proto, __be32 spi, bool ip4)
{
  #line 400 
  void *__mptr;
  #line 400 
  struct rx_sa *tmp_6;
  #line 396 
  struct rx_sa *rsa;
  #line 397 
  struct xfrm_state *ret = (struct xfrm_state *)0;
  #line 399 
  rcu_read_lock();
  {
    #line 400 
    bool __warned;
    #line 400 
    if (debug_lockdep_rcu_enabled() != 0) 
      #line 400 
      if (! __warned) {
        #line 400 
        if (rcu_read_lock_any_held() == 0) {
          #line 400 
          __warned = (_Bool)1;
          #line 400 
          lockdep_rcu_suspicious((char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c",400,(char *)"RCU-list traversed in non-reader section!");
        }
      }
  }
  {
    #line 400 
    struct hlist_node *________p1;
    {
      #line 401 
      union __anonunion___u_13488 __u;
      {
        #line 400 
        ;
        #line 400 
        __read_once_size((void *)(& ipsec->rx_sa_list[hash_32_generic(spi,10U)].first),(void *)(& __u.__c),8);
      }
      #line 400 
      ________p1 = (__u.__val);
      }
    #line 400 
    struct hlist_node *____ptr = ________p1;
    #line 400 
    if (____ptr != (struct hlist_node *)0) {
      #line 400 
      __mptr = (void *)____ptr;
      #line 400 
      tmp_6 = ((struct rx_sa *)__mptr);
    }
    else 
         #line 400 
         tmp_6 = (struct rx_sa *)0;
    }
  #line 403 
  rsa = tmp_6;
  #line 400 
  while (rsa != (struct rx_sa *)0) {
    #line 400 
    void *__mptr_0;
    #line 400 
    struct rx_sa *tmp_11;
    #line 402 
    if ((rsa->mode & 32U) != 0U) 
                                 #line 403 
                                 goto __Cont;
    #line 404 
    if ((rsa->xs)->id.spi == spi) 
      #line 404 
      if ((int)ip4 != 0 && *daddr == (rsa->xs)->id.daddr.a4) 
                                                             #line 404 
                                                             goto _LOR;
      else 
        #line 406 
        if (! ip4) {
          #line 406 
          if (memcmp((void *)daddr,(void *)(& (rsa->xs)->id.daddr.a6),16UL) == 0) {
            #line 404 
            _LOR: 
                  #line 407 
            ;
            #line 407 
            if ((int)(rsa->xs)->id.proto == (int)proto) {
              #line 409 
              ret = rsa->xs;
              #line 410 
              xfrm_state_hold(ret);
              #line 411 
              break;
            }
          }
        }
    #line 400 
    __Cont: { /* sequence */
              {
                #line 400 
                struct hlist_node *________p1_0;
                {
                  #line 401 
                  union __anonunion___u_13490 __u_0;
                  #line 400 
                  __read_once_size((void *)(& rsa->hlist.next),(void *)(& __u_0.__c),8);
                  #line 400 
                  ________p1_0 = (__u_0.__val);
                  }
                #line 400 
                struct hlist_node *____ptr_0 = ________p1_0;
                #line 400 
                if (____ptr_0 != (struct hlist_node *)0) {
                  #line 400 
                  __mptr_0 = (void *)____ptr_0;
                  #line 400 
                  tmp_11 = ((struct rx_sa *)__mptr_0);
                }
                else 
                     #line 400 
                     tmp_11 = (struct rx_sa *)0;
                }
              #line 400 
              rsa = tmp_11;
            }
  }
  #line 414 
  rcu_read_unlock();
  #line 415 
  return ret;
}

#line 427  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
static int ixgbe_ipsec_parse_proto_keys(struct xfrm_state *xs, u32 *mykey, u32 *mysalt)
{
  #line 431 
  unsigned char *key_data;
  #line 433 
  int key_len;
  #line 430 
  struct net_device *dev = xs->xso.dev;
  #line 432 
  char *alg_name = (char *)0;
  #line 435 
  if (xs->aead == (struct xfrm_algo_aead *)0) {
    #line 436 
    netdev_err(dev,(char *)"Unsupported IPsec algorithm\n");
    #line 437 
    return -22;
  }
  #line 440 
  if ((xs->aead)->alg_icv_len != 128U) {
    #line 441 
    netdev_err(dev,(char *)"IPsec offload requires %d bit authentication\n",128);
    #line 443 
    return -22;
  }
  #line 446 
  key_data = (unsigned char *)(& (xs->aead)->alg_key[0]);
  #line 447 
  key_len = (int)(xs->aead)->alg_key_len;
  #line 448 
  alg_name = (char *)(& (xs->aead)->alg_name);
  #line 450 
  if (cif_strcmp(alg_name,(char *)(& aes_gcm_name)) != 0) {
    #line 451 
    netdev_err(dev,(char *)"Unsupported IPsec algorithm - please use %s\n",(char *)(& aes_gcm_name));
    #line 453 
    return -22;
  }
  #line 460 
  if (key_len == 160) 
                      #line 461 
                      *mysalt = *((u32 *)key_data + 4U);
  else 
    #line 462 
    if (key_len != 128) {
      #line 463 
      netdev_err(dev,(char *)"IPsec hw offload only supports keys up to 128 bits with a 32 bit salt\n");
      #line 464 
      return -22;
    }
    else {
      #line 466 
      netdev_info(dev,(char *)"IPsec hw offload parameters missing 32 bit salt value\n");
      #line 467 
      *mysalt = 0U;
    }
  #line 469 
  memcpy((void *)mykey,(void *)key_data,16UL);
  #line 471 
  return 0;
}

#line 478  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
static int ixgbe_ipsec_check_mgmt_ip(struct xfrm_state *xs)
{
  #line 483 
  u32 mfval;
  #line 483 
  u32 manc;
  #line 483 
  u32 reg;
  #line 485 
  bool manc_ipv4;
  #line 486 
  u32 bmcipval;
  #line 487 
  int i;
  #line 487 
  int j;
  #line 480 
  struct net_device *dev = xs->xso.dev;
  #line 481 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 482 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 484 
  int num_filters = 4;
  #line 500 
  manc = ixgbe_read_reg(hw,22560U);
  #line 501 
  manc_ipv4 = (_Bool)(((unsigned long)manc & 16777216UL) != 0UL);
  #line 502 
  mfval = ixgbe_read_reg(hw,22564U);
  #line 503 
  bmcipval = ixgbe_read_reg(hw,20576U);
  #line 505 
  if ((unsigned int)xs->props.family == 2U) {
    #line 507 
    if ((int)manc_ipv4 != 0) {
      #line 509 
      i = 0;
      #line 509 
      while (i < num_filters) {
        #line 510 
        if ((((unsigned long)mfval >> (i + 16)) & 1UL) == 0UL) 
                                                               #line 511 
                                                               goto __Cont;
        #line 513 
        reg = ixgbe_read_reg(hw,(unsigned int)((i + 5688) * 4));
        #line 514 
        if (xs->id.daddr.a4 == reg) 
                                    #line 515 
                                    return 1;
        #line 509 
        __Cont: 
                #line 509 
        i ++;
      }
    }
    #line 519 
    if ((bmcipval & 3U) == 2U) {
      #line 520 
      reg = ixgbe_read_reg(hw,20572U);
      #line 521 
      if (xs->id.daddr.a4 == reg) 
                                  #line 522 
                                  return 1;
    }
  }
  else {
    #line 527 
    if ((int)manc_ipv4 != 0) 
                             #line 528 
                             num_filters = 3;
    #line 530 
    i = 0;
    #line 530 
    while (i < num_filters) {
      #line 531 
      if ((((unsigned long)mfval >> (i + 24)) & 1UL) == 0UL) 
                                                             #line 532 
                                                             goto __Cont_0;
      #line 534 
      j = 0;
      #line 534 
      while (j <= 3) {
        #line 535 
        reg = ixgbe_read_reg(hw,(unsigned int)(((i + 1419) * 4 + j) * 4));
        #line 536 
        if (xs->id.daddr.a6[j] != reg) 
                                       #line 537 
                                       break;
        #line 534 
        j ++;
      }
      #line 539 
      if (j == 4) 
                  #line 540 
                  return 1;
      #line 530 
      __Cont_0: 
                #line 530 
      i ++;
    }
    #line 543 
    if ((bmcipval & 3U) == 3U) {
      #line 544 
      j = 0;
      #line 544 
      while (j <= 3) {
        #line 545 
        reg = ixgbe_read_reg(hw,(unsigned int)((j + 5140) * 4));
        #line 546 
        if (xs->id.daddr.a6[j] != reg) 
                                       #line 547 
                                       break;
        #line 544 
        j ++;
      }
      #line 549 
      if (j == 4) 
                  #line 550 
                  return 1;
    }
  }
  #line 554 
  return 0;
}

#line 561  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
static int ixgbe_ipsec_add_sa(struct xfrm_state *xs)
{
  #line 567 
  int checked;
  #line 567 
  int match;
  #line 567 
  int first;
  #line 568 
  u16 sa_idx;
  #line 569 
  int ret;
  #line 570 
  int i;
  #line 563 
  struct net_device *dev = xs->xso.dev;
  #line 564 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 565 
  struct ixgbe_ipsec *ipsec = adapter->ipsec;
  #line 566 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 572 
  if ((unsigned int)xs->id.proto + 206U > 1U) {
    #line 573 
    netdev_err(dev,(char *)"Unsupported protocol 0x%04x for ipsec offload\n",(int)xs->id.proto);
    #line 575 
    return -22;
  }
  #line 578 
  if (ixgbe_ipsec_check_mgmt_ip(xs) != 0) {
    #line 579 
    netdev_err(dev,(char *)"IPsec IP addr clash with mgmt filters\n");
    #line 580 
    return -22;
  }
  #line 583 
  if (((int)xs->xso.flags & 2) != 0) {
    #line 584 
    struct rx_sa rsa;
    #line 586 
    if (xs->calg != (struct xfrm_algo *)0) {
      #line 587 
      netdev_err(dev,(char *)"Compression offload not supported\n");
      #line 588 
      return -22;
    }
    #line 592 
    ret = ixgbe_ipsec_find_empty_idx(ipsec,(_Bool)1);
    #line 593 
    if (ret < 0) {
      #line 594 
      netdev_err(dev,(char *)"No space for SA in Rx table!\n");
      #line 595 
      return ret;
    }
    #line 597 
    sa_idx = (unsigned short)ret;
    #line 599 
    memset((void *)(& rsa),0,72UL);
    #line 600 
    rsa.used = (_Bool)1;
    #line 601 
    rsa.xs = xs;
    #line 603 
    if (((int)(rsa.xs)->id.proto & 50) != 0) 
                                             #line 604 
                                             rsa.decrypt = (_Bool)((xs->ealg != (struct xfrm_algo *)0 || xs->aead != (struct xfrm_algo_aead *)0) != 0);
    #line 607 
    ret = ixgbe_ipsec_parse_proto_keys(xs,(u32 *)(& rsa.key),& rsa.salt);
    #line 608 
    if (ret != 0) {
      #line 609 
      netdev_err(dev,(char *)"Failed to get key data for Rx SA table\n");
      #line 610 
      return ret;
    }
    #line 614 
    if ((unsigned int)xs->props.family == 10U) 
                                               #line 615 
                                               memcpy((void *)(& rsa.ipaddr),(void *)(& xs->id.daddr.a6),16UL); else 
                                                                    #line 617 
                                                                    memcpy((void *)(& rsa.ipaddr[3]),(void *)(& xs->id.daddr.a4),4UL);
    #line 629 
    checked = 0;
    #line 630 
    match = -1;
    #line 631 
    first = -1;
    #line 632 
    i = 0;
    #line 632 
    while (i <= 127 && ((int)ipsec->num_rx_sa > checked || first < 0)) {
      #line 636 
      if ((int)(ipsec->ip_tbl + (unsigned long)i)->used != 0) {
        #line 637 
        if (memcmp((void *)(& (ipsec->ip_tbl + (unsigned long)i)->ipaddr),
               (void *)(& rsa.ipaddr),16UL) == 0) {
          #line 639 
          match = i;
          #line 640 
          break;
        }
        #line 642 
        checked ++;
      }
      else 
        #line 643 
        if (first < 0) 
                       #line 644 
                       first = i;
      #line 634 
      i ++;
    }
    #line 648 
    if ((unsigned int)ipsec->num_rx_sa == 0U) 
                                              #line 649 
                                              first = 0;
    #line 651 
    if (match >= 0) {
      #line 653 
      rsa.iptbl_ind = (unsigned char)match;
      #line 654 
      ((ipsec->ip_tbl + (unsigned long)match)->ref_cnt) ++;
    }
    else 
      #line 656 
      if (first >= 0) {
        #line 658 
        rsa.iptbl_ind = (unsigned char)first;
        #line 660 
        memcpy((void *)(& (ipsec->ip_tbl + (unsigned long)first)->ipaddr),(void *)(& rsa.ipaddr),16UL);
        #line 662 
        (ipsec->ip_tbl + (unsigned long)first)->ref_cnt = 1U;
        #line 663 
        (ipsec->ip_tbl + (unsigned long)first)->used = (_Bool)1;
        #line 665 
        ixgbe_ipsec_set_rx_ip(hw,(unsigned short)((int)rsa.iptbl_ind),(__be32 *)(& rsa.ipaddr));
      }
      else {
        #line 669 
        netdev_err(dev,(char *)"No space for SA in Rx IP SA table\n");
        #line 670 
        memset((void *)(& rsa),0,72UL);
        #line 671 
        return -28;
      }
    #line 674 
    rsa.mode = 1U;
    #line 675 
    if (((int)(rsa.xs)->id.proto & 50) != 0) 
                                             #line 676 
                                             rsa.mode |= 4U;
    #line 677 
    if ((int)rsa.decrypt != 0) 
                               #line 678 
                               rsa.mode |= 8U;
    #line 679 
    if ((unsigned int)(rsa.xs)->props.family == 10U) 
                                                     #line 680 
                                                     rsa.mode |= 16U;
    #line 683 
    memcpy((void *)(ipsec->rx_tbl + (unsigned long)sa_idx),(void *)(& rsa),72UL);
    #line 685 
    ixgbe_ipsec_set_rx_sa(hw,(unsigned short)((int)sa_idx),(rsa.xs)->id.spi,(u32 *)(& rsa.key),rsa.salt,rsa.mode,(unsigned int)rsa.iptbl_ind);
    #line 687 
    xs->xso.offload_handle = (unsigned long)sa_idx;
    #line 689 
    ipsec->num_rx_sa = (u16)((int)ipsec->num_rx_sa + 1);
    #line 692 
    ;
    #line 692 
    ;
    #line 692 
    hlist_add_head_rcu(& (ipsec->rx_tbl + (unsigned long)sa_idx)->hlist,& ipsec->rx_sa_list[hash_32_generic((rsa.xs)->id.spi,10U)]);
  }
  else {
    #line 695 
    struct tx_sa tsa;
    #line 697 
    if (adapter->num_vfs != 0U && (unsigned int)adapter->bridge_mode != 1U) 
      #line 699 
      return -95;
    #line 702 
    ret = ixgbe_ipsec_find_empty_idx(ipsec,(_Bool)0);
    #line 703 
    if (ret < 0) {
      #line 704 
      netdev_err(dev,(char *)"No space for SA in Tx table\n");
      #line 705 
      return ret;
    }
    #line 707 
    sa_idx = (unsigned short)ret;
    #line 709 
    memset((void *)(& tsa),0,40UL);
    #line 710 
    tsa.used = (_Bool)1;
    #line 711 
    tsa.xs = xs;
    #line 713 
    if (((int)xs->id.proto & 50) != 0) 
                                       #line 714 
                                       tsa.encrypt = (_Bool)((xs->ealg != (struct xfrm_algo *)0 || xs->aead != (struct xfrm_algo_aead *)0) != 0);
    #line 716 
    ret = ixgbe_ipsec_parse_proto_keys(xs,(u32 *)(& tsa.key),& tsa.salt);
    #line 717 
    if (ret != 0) {
      #line 718 
      netdev_err(dev,(char *)"Failed to get key data for Tx SA table\n");
      #line 719 
      memset((void *)(& tsa),0,40UL);
      #line 720 
      return ret;
    }
    #line 724 
    memcpy((void *)(ipsec->tx_tbl + (unsigned long)sa_idx),(void *)(& tsa),40UL);
    #line 726 
    ixgbe_ipsec_set_tx_sa(hw,(unsigned short)((int)sa_idx),(u32 *)(& tsa.key),tsa.salt);
    #line 728 
    xs->xso.offload_handle = (unsigned long)((int)sa_idx + 1024);
    #line 730 
    ipsec->num_tx_sa = (u16)((int)ipsec->num_tx_sa + 1);
  }
  #line 734 
  if (((unsigned long)adapter->flags2 & 131072UL) == 0UL) {
    #line 735 
    ixgbe_ipsec_start_engine(adapter);
    #line 736 
    adapter->flags2 |= 131072U;
  }
  #line 739 
  return 0;
}

#line 746  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
static void ixgbe_ipsec_del_sa(struct xfrm_state *xs)
{
  #line 753 
  u16 sa_idx;
  #line 748 
  struct net_device *dev = xs->xso.dev;
  #line 749 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 750 
  struct ixgbe_ipsec *ipsec = adapter->ipsec;
  #line 751 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 752 
  u32 zerobuf[4U] = {0U, 0U, 0U, 0U};
  #line 755 
  if (((int)xs->xso.flags & 2) != 0) {
    #line 756 
    struct rx_sa *rsa;
    #line 757 
    u8 ipi;
    #line 759 
    sa_idx = (unsigned short)xs->xso.offload_handle;
    #line 760 
    rsa = ipsec->rx_tbl + (unsigned long)sa_idx;
    #line 762 
    if (! rsa->used) {
      #line 763 
      netdev_err(dev,(char *)"Invalid Rx SA selected sa_idx=%d offload_handle=%lu\n",(int)sa_idx,xs->xso.offload_handle);
      #line 765 
      return;
    }
    #line 768 
    ixgbe_ipsec_set_rx_sa(hw,(unsigned short)((int)sa_idx),0U,(u32 *)(& zerobuf),0U,0U,0U);
    #line 769 
    hash_del_rcu(& rsa->hlist);
    #line 774 
    ipi = rsa->iptbl_ind;
    #line 775 
    if ((ipsec->ip_tbl + (unsigned long)ipi)->ref_cnt != 0U) {
      #line 776 
      ((ipsec->ip_tbl + (unsigned long)ipi)->ref_cnt) --;
      #line 778 
      if ((ipsec->ip_tbl + (unsigned long)ipi)->ref_cnt == 0U) {
        #line 779 
        memset((void *)(ipsec->ip_tbl + (unsigned long)ipi),0,24UL);
        #line 781 
        ixgbe_ipsec_set_rx_ip(hw,(unsigned short)((int)ipi),(__be32 *)(& zerobuf));
      }
    }
    #line 786 
    memset((void *)rsa,0,72UL);
    #line 787 
    ipsec->num_rx_sa = (u16)((int)ipsec->num_rx_sa - 1);
  }
  else {
    #line 789 
    sa_idx = (unsigned short)((unsigned int)((unsigned short)xs->xso.offload_handle) + 64512U);
    #line 791 
    if (! (ipsec->tx_tbl + (unsigned long)sa_idx)->used) {
      #line 792 
      netdev_err(dev,(char *)"Invalid Tx SA selected sa_idx=%d offload_handle=%lu\n",(int)sa_idx,xs->xso.offload_handle);
      #line 794 
      return;
    }
    #line 797 
    ixgbe_ipsec_set_tx_sa(hw,(unsigned short)((int)sa_idx),(u32 *)(& zerobuf),0U);
    #line 798 
    memset((void *)(ipsec->tx_tbl + (unsigned long)sa_idx),0,40UL);
    #line 799 
    ipsec->num_tx_sa = (u16)((int)ipsec->num_tx_sa - 1);
  }
  #line 803 
  if ((unsigned int)ipsec->num_rx_sa == 0U && (unsigned int)ipsec->num_tx_sa == 0U) {
    #line 804 
    adapter->flags2 &= 4294836223U;
    #line 805 
    ixgbe_ipsec_stop_engine(adapter);
  }
  #line 807 
  return;
}

#line 814  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
static bool ixgbe_ipsec_offload_ok(struct sk_buff *skb, struct xfrm_state *xs)
{
  #line 816 
  if ((unsigned int)xs->props.family == 2U) {
    #line 818 
    ;
    #line 818 
    if ((unsigned int)ip_hdr(skb)->ihl != 5U) 
                                              #line 819 
                                              return (_Bool)0;
  }
  else {
    #line 822 
    if ((int)ipv6_ext_hdr((unsigned char)((int)ipv6_hdr(skb)->nexthdr)) != 0) 
      #line 823 
      return (_Bool)0;
  }
  #line 826 
  return (_Bool)1;
}

#line 829  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
static struct xfrmdev_ops ixgbe_xfrmdev_ops = {.xdo_dev_state_add = & ixgbe_ipsec_add_sa, .xdo_dev_state_delete = & ixgbe_ipsec_del_sa, .xdo_dev_offload_ok = & ixgbe_ipsec_offload_ok};
#line 840  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
void ixgbe_ipsec_vf_clear(struct ixgbe_adapter *adapter, u32 vf)
{
  #line 843 
  int i;
  #line 842 
  struct ixgbe_ipsec *ipsec = adapter->ipsec;
  #line 845 
  if (ipsec == (struct ixgbe_ipsec *)0) 
                                        #line 846 
                                        return;
  #line 849 
  i = 0;
  #line 849 
  while (i <= 1023 && (unsigned int)ipsec->num_rx_sa != 0U) {
    #line 850 
    if (! (ipsec->rx_tbl + (unsigned long)i)->used) 
                                                    #line 851 
                                                    goto __Cont;
    #line 852 
    if (((ipsec->rx_tbl + (unsigned long)i)->mode & 32U) != 0U && (ipsec->rx_tbl + (unsigned long)i)->vf == vf) 
      #line 854 
      ixgbe_ipsec_del_sa((ipsec->rx_tbl + (unsigned long)i)->xs);
    #line 849 
    __Cont: 
            #line 849 
    i ++;
  }
  #line 858 
  i = 0;
  #line 858 
  while (i <= 1023 && (unsigned int)ipsec->num_tx_sa != 0U) {
    #line 859 
    if (! (ipsec->tx_tbl + (unsigned long)i)->used) 
                                                    #line 860 
                                                    goto __Cont_0;
    #line 861 
    if (((ipsec->tx_tbl + (unsigned long)i)->mode & 32U) != 0U && (ipsec->tx_tbl + (unsigned long)i)->vf == vf) 
      #line 863 
      ixgbe_ipsec_del_sa((ipsec->tx_tbl + (unsigned long)i)->xs);
    #line 858 
    __Cont_0: 
              #line 858 
    i ++;
  }
  #line 865 
  return;
}

#line 879  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
int ixgbe_ipsec_vf_add_sa(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)
{
  #line 882 
  struct xfrm_algo_desc *algo;
  #line 883 
  struct sa_mbx_msg *sam;
  #line 884 
  struct xfrm_state *xs;
  #line 885 
  size_t aead_len;
  #line 886 
  u16 sa_idx;
  #line 887 
  u32 pfsa;
  #line 888 
  int err;
  #line 881 
  struct ixgbe_ipsec *ipsec = adapter->ipsec;
  #line 890 
  sam = (struct sa_mbx_msg *)(msgbuf + 1U);
  #line 891 
  if ((unsigned int)(adapter->vfinfo + (unsigned long)vf)->trusted == 0U || ((unsigned long)adapter->flags2 & 262144UL) == 0UL) {
    #line 893 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 893 
                                             netdev_warn(adapter->netdev,(char *)"VF %d attempted to add an IPsec SA\n",vf);
    #line 894 
    err = -13;
    #line 895 
    goto err_out;
  }
  #line 901 
  if (((int)sam->flags & 2) == 0) {
    #line 902 
    err = -95;
    #line 903 
    goto err_out;
  }
  #line 906 
  xs = (struct xfrm_state *)kzalloc_2(824UL,3264U);
  #line 907 
  if ((long)(xs == (struct xfrm_state *)0) != 0L) {
    #line 908 
    err = -12;
    #line 909 
    goto err_out;
  }
  #line 912 
  xs->xso.flags = sam->flags;
  #line 913 
  xs->id.spi = sam->spi;
  #line 914 
  xs->id.proto = sam->proto;
  #line 915 
  xs->props.family = sam->family;
  #line 916 
  if ((unsigned int)xs->props.family == 10U) 
                                             #line 917 
                                             memcpy((void *)(& xs->id.daddr.a6),(void *)(& sam->addr),16UL); else 
                                                                    #line 919 
                                                                    memcpy((void *)(& xs->id.daddr.a4),(void *)(& sam->addr),4UL);
  #line 920 
  xs->xso.dev = adapter->netdev;
  #line 922 
  algo = xfrm_aead_get_byname((char *)(& aes_gcm_name),128,1);
  #line 923 
  if ((long)(algo == (struct xfrm_algo_desc *)0) != 0L) {
    #line 924 
    err = -2;
    #line 925 
    goto err_xs;
  }
  #line 928 
  aead_len = 92UL;
  #line 929 
  xs->aead = (struct xfrm_algo_aead *)kzalloc_2(aead_len,3264U);
  #line 930 
  if ((long)(xs->aead == (struct xfrm_algo_aead *)0) != 0L) {
    #line 931 
    err = -12;
    #line 932 
    goto err_xs;
  }
  #line 935 
  xs->props.ealgo = algo->desc.sadb_alg_id;
  #line 936 
  xs->geniv = algo->uinfo.aead.geniv;
  #line 937 
  (xs->aead)->alg_icv_len = 128U;
  #line 938 
  (xs->aead)->alg_key_len = 160U;
  #line 939 
  memcpy((void *)(& (xs->aead)->alg_key),(void *)(& sam->key),20UL);
  #line 940 
  memcpy((void *)(& (xs->aead)->alg_name),(void *)(& aes_gcm_name),18UL);
  #line 943 
  err = ixgbe_ipsec_add_sa(xs);
  #line 944 
  if (err != 0) 
                #line 945 
                goto err_aead;
  #line 947 
  pfsa = (unsigned int)xs->xso.offload_handle;
  #line 948 
  if (pfsa <= 1023U) {
    #line 949 
    sa_idx = (unsigned short)pfsa;
    #line 950 
    (ipsec->rx_tbl + (unsigned long)sa_idx)->vf = vf;
    #line 951 
    (ipsec->rx_tbl + (unsigned long)sa_idx)->mode |= 32U;
  }
  else {
    #line 953 
    sa_idx = (unsigned short)((unsigned int)((unsigned short)pfsa) + 64512U);
    #line 954 
    (ipsec->tx_tbl + (unsigned long)sa_idx)->vf = vf;
    #line 955 
    (ipsec->tx_tbl + (unsigned long)sa_idx)->mode |= 32U;
  }
  #line 958 
  *(msgbuf + 1U) = (unsigned int)xs->xso.offload_handle;
  #line 960 
  return 0;
  #line 962 
  err_aead: 
            #line 962 
  ;
  #line 963 
  kzfree((void *)xs->aead);
  #line 964 
  err_xs: 
          #line 964 
  ;
  #line 965 
  kzfree((void *)xs);
  #line 966 
  err_out: 
           #line 966 
  ;
  #line 967 
  *(msgbuf + 1U) = (unsigned int)err;
  #line 968 
  return err;
}

#line 989  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
int ixgbe_ipsec_vf_del_sa(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)
{
  #line 992 
  struct xfrm_state *xs;
  #line 994 
  u16 sa_idx;
  #line 991 
  struct ixgbe_ipsec *ipsec = adapter->ipsec;
  #line 993 
  u32 pfsa = *(msgbuf + 1U);
  #line 996 
  if ((unsigned int)(adapter->vfinfo + (unsigned long)vf)->trusted == 0U) {
    #line 997 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 997 
                                             netdev_err(adapter->netdev,(char *)"vf %d attempted to delete an SA\n",vf);
    #line 998 
    return -1;
  }
  #line 1001 
  if (pfsa <= 1023U) {
    #line 1002 
    struct rx_sa *rsa;
    #line 1004 
    sa_idx = (unsigned short)pfsa;
    #line 1005 
    if ((unsigned int)sa_idx > 1023U) {
      #line 1006 
      if (((int)adapter->msg_enable & 1) != 0) 
                                               #line 1006 
                                               netdev_err(adapter->netdev,(char *)"vf %d SA index %d out of range\n",vf,(int)sa_idx);
      #line 1008 
      return -22;
    }
    #line 1011 
    rsa = ipsec->rx_tbl + (unsigned long)sa_idx;
    #line 1013 
    if (! rsa->used) 
                     #line 1014 
                     return 0;
    #line 1016 
    if ((rsa->mode & 32U) == 0U || rsa->vf != vf) {
      #line 1018 
      if (((int)adapter->msg_enable & 1) != 0) 
                                               #line 1018 
                                               netdev_err(adapter->netdev,(char *)"vf %d bad Rx SA index %d\n",vf,(int)sa_idx);
      #line 1019 
      return -2;
    }
    #line 1022 
    xs = (ipsec->rx_tbl + (unsigned long)sa_idx)->xs;
  }
  else {
    #line 1024 
    struct tx_sa *tsa;
    #line 1026 
    sa_idx = (unsigned short)((unsigned int)((unsigned short)pfsa) + 64512U);
    #line 1027 
    if ((unsigned int)sa_idx > 1023U) {
      #line 1028 
      if (((int)adapter->msg_enable & 1) != 0) 
                                               #line 1028 
                                               netdev_err(adapter->netdev,(char *)"vf %d SA index %d out of range\n",vf,(int)sa_idx);
      #line 1030 
      return -22;
    }
    #line 1033 
    tsa = ipsec->tx_tbl + (unsigned long)sa_idx;
    #line 1035 
    if (! tsa->used) 
                     #line 1036 
                     return 0;
    #line 1038 
    if ((tsa->mode & 32U) == 0U || tsa->vf != vf) {
      #line 1040 
      if (((int)adapter->msg_enable & 1) != 0) 
                                               #line 1040 
                                               netdev_err(adapter->netdev,(char *)"vf %d bad Tx SA index %d\n",vf,(int)sa_idx);
      #line 1041 
      return -2;
    }
    #line 1044 
    xs = (ipsec->tx_tbl + (unsigned long)sa_idx)->xs;
  }
  #line 1047 
  ixgbe_ipsec_del_sa(xs);
  #line 1050 
  kzfree((void *)xs);
  #line 1052 
  return 0;
}

#line 1061  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
int ixgbe_ipsec_tx(struct ixgbe_ring *tx_ring, struct ixgbe_tx_buffer *first, struct ixgbe_ipsec_tx_data *itd)
{
  #line 1067 
  struct xfrm_state *xs;
  #line 1068 
  struct sec_path *sp;
  #line 1069 
  struct tx_sa *tsa;
  #line 1065 
  struct ixgbe_adapter *adapter = netdev_priv(tx_ring->netdev);
  #line 1066 
  struct ixgbe_ipsec *ipsec = adapter->ipsec;
  #line 1071 
  sp = skb_sec_path(first->__anonCompField_ixgbe_tx_buffer_217.skb);
  #line 1072 
  if ((long)(sp->len == 0) != 0L) {
    #line 1073 
    netdev_err(tx_ring->netdev,(char *)"%s: no xfrm state len = %d\n",(char *)"ixgbe_ipsec_tx",sp->len);
    #line 1075 
    return 0;
  }
  #line 1078 
  xs = xfrm_input_state(first->__anonCompField_ixgbe_tx_buffer_217.skb);
  #line 1079 
  if ((long)(xs == (struct xfrm_state *)0) != 0L) {
    #line 1080 
    netdev_err(tx_ring->netdev,(char *)"%s: no xfrm_input_state() xs = %p\n",(char *)"ixgbe_ipsec_tx",xs);
    #line 1082 
    return 0;
  }
  #line 1085 
  itd->sa_idx = (unsigned short)((unsigned int)((unsigned short)xs->xso.offload_handle) + 64512U);
  #line 1086 
  if ((long)((unsigned int)itd->sa_idx > 1023U) != 0L) {
    #line 1087 
    netdev_err(tx_ring->netdev,(char *)"%s: bad sa_idx=%d handle=%lu\n",(char *)"ixgbe_ipsec_tx",(int)itd->sa_idx,xs->xso.offload_handle);
    #line 1089 
    return 0;
  }
  #line 1092 
  tsa = ipsec->tx_tbl + (unsigned long)itd->sa_idx;
  #line 1093 
  if ((long)(! tsa->used) != 0L) {
    #line 1094 
    netdev_err(tx_ring->netdev,(char *)"%s: unused sa_idx=%d\n",(char *)"ixgbe_ipsec_tx",(int)itd->sa_idx);
    #line 1096 
    return 0;
  }
  #line 1099 
  first->tx_flags |= 72U;
  #line 1101 
  if ((unsigned int)xs->id.proto == 50U) {
    #line 1103 
    itd->flags |= 10240U;
    #line 1105 
    if ((unsigned int)first->protocol == 8U) 
                                             #line 1106 
                                             itd->flags |= 1024U;
    #line 1116 
    if (! skb_is_gso(first->__anonCompField_ixgbe_tx_buffer_217.skb)) {
      #line 1126 
      u8 padlen;
      #line 1127 
      int ret;
      #line 1124 
      int authlen = 16;
      #line 1125 
      struct sk_buff *skb = first->__anonCompField_ixgbe_tx_buffer_217.skb;
      #line 1129 
      ret = skb_copy_bits(skb,(int)(skb->len + 4294967278U),(void *)(& padlen),1);
      #line 1131 
      if ((long)(ret != 0) != 0L) 
                                  #line 1132 
                                  return 0;
      #line 1133 
      itd->trailer_len = (unsigned short)((unsigned int)((unsigned short)padlen) + 18U);
    }
  }
  #line 1136 
  if ((int)tsa->encrypt != 0) 
                              #line 1137 
                              itd->flags |= 16384U;
  #line 1139 
  return 1;
}

#line 1151  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
void ixgbe_ipsec_rx(struct ixgbe_ring *rx_ring, union ixgbe_adv_rx_desc *rx_desc, struct sk_buff *skb)
{
  #line 1164 
  struct sec_path *sp;
  #line 1165 
  void *daddr;
  #line 1166 
  __be32 spi;
  #line 1167 
  u8 *c_hdr;
  #line 1168 
  u8 proto;
  #line 1208 
  int tmp_0;
  #line 1155 
  struct ixgbe_adapter *adapter = netdev_priv(rx_ring->netdev);
  #line 1156 
  __le16 pkt_info = rx_desc->wb.lower.lo_dword.hs_rss.pkt_info;
  #line 1157 
  __le16 ipsec_pkt_types = (unsigned short)12288U;
  #line 1159 
  struct ixgbe_ipsec *ipsec = adapter->ipsec;
  #line 1160 
  struct xfrm_offload *xo = (struct xfrm_offload *)0;
  #line 1161 
  struct xfrm_state *xs = (struct xfrm_state *)0;
  #line 1162 
  struct ipv6hdr *ip6 = (struct ipv6hdr *)0;
  #line 1163 
  struct iphdr *ip4 = (struct iphdr *)0;
  #line 1175 
  if (((int)pkt_info & 16) != 0) {
    #line 1176 
    ip4 = (struct iphdr *)(skb->data + 14U);
    #line 1177 
    daddr = (void *)(& ip4->daddr);
    #line 1178 
    c_hdr = (u8 *)ip4 + (unsigned long)((int)ip4->ihl * 4);
  }
  else 
    #line 1179 
    if (((int)pkt_info & 64) != 0) {
      #line 1180 
      ip6 = (struct ipv6hdr *)(skb->data + 14U);
      #line 1181 
      daddr = (void *)(& ip6->daddr);
      #line 1182 
      c_hdr = (u8 *)ip6 + 40UL;
    }
    else 
         #line 1184 
         return;
  #line 1187 
  switch ((int)pkt_info & (int)ipsec_pkt_types) {
    #line 1188 
    case 8192: 
               #line 1188 
    ;
    #line 1189 
    spi = ((struct ip_auth_hdr *)c_hdr)->spi;
    #line 1190 
    proto = (unsigned char)51U;
    #line 1191 
    break;
    #line 1192 
    case 4096: 
               #line 1192 
    ;
    #line 1193 
    spi = ((struct ip_esp_hdr *)c_hdr)->spi;
    #line 1194 
    proto = (unsigned char)50U;
    #line 1195 
    break;
    #line 1196 
    default: 
             #line 1196 
    ;
    #line 1197 
    return;
  }
  #line 1200 
  xs = ixgbe_ipsec_find_rx_state(ipsec,(__be32 *)daddr,(unsigned char)((int)proto),spi,(_Bool)(ip4 != (struct iphdr *)0));
  #line 1201 
  if ((long)(xs == (struct xfrm_state *)0) != 0L) 
                                                  #line 1202 
                                                  return;
  #line 1204 
  sp = secpath_set(skb);
  #line 1205 
  if ((long)(sp == (struct sec_path *)0) != 0L) 
                                                #line 1206 
                                                return;
  #line 1208 
  tmp_0 = sp->len;
  #line 1208 
  (sp->len) ++;
  #line 1208 
  sp->xvec[tmp_0] = xs;
  #line 1209 
  (sp->olen) ++;
  #line 1210 
  xo = xfrm_offload(skb);
  #line 1211 
  xo->flags = 2U;
  #line 1212 
  xo->status = 1U;
  #line 1214 
  (adapter->rx_ipsec) ++;
  #line 1215 
  return;
}

#line 1221  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
void ixgbe_init_ipsec_offload(struct ixgbe_adapter *adapter)
{
  #line 1224 
  struct ixgbe_ipsec *ipsec;
  #line 1225 
  u32 t_dis;
  #line 1225 
  u32 r_dis;
  #line 1226 
  size_t size;
  #line 1223 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 1228 
  if (hw->mac.type == (unsigned int)ixgbe_mac_82598EB) 
                                                       #line 1229 
                                                       return;
  #line 1234 
  t_dis = ixgbe_read_reg(hw,34820U) & 2U;
  #line 1236 
  r_dis = ixgbe_read_reg(hw,36100U) & 2U;
  #line 1238 
  if (t_dis != 0U || r_dis != 0U) 
                                  #line 1239 
                                  return;
  #line 1241 
  ipsec = (struct ixgbe_ipsec *)kzalloc_2(8224UL,3264U);
  #line 1242 
  if (ipsec == (struct ixgbe_ipsec *)0) 
                                        #line 1243 
                                        goto err1;
  #line 1244 
  __hash_init((struct hlist_head *)(& ipsec->rx_sa_list),1024U);
  #line 1246 
  size = 73728UL;
  #line 1247 
  ipsec->rx_tbl = (struct rx_sa *)kzalloc_2(size,3264U);
  #line 1248 
  if (ipsec->rx_tbl == (struct rx_sa *)0) 
                                          #line 1249 
                                          goto err2;
  #line 1251 
  size = 40960UL;
  #line 1252 
  ipsec->tx_tbl = (struct tx_sa *)kzalloc_2(size,3264U);
  #line 1253 
  if (ipsec->tx_tbl == (struct tx_sa *)0) 
                                          #line 1254 
                                          goto err2;
  #line 1256 
  size = 3072UL;
  #line 1257 
  ipsec->ip_tbl = (struct rx_ip_sa *)kzalloc_2(size,3264U);
  #line 1258 
  if (ipsec->ip_tbl == (struct rx_ip_sa *)0) 
                                             #line 1259 
                                             goto err2;
  #line 1261 
  ipsec->num_rx_sa = (unsigned short)0U;
  #line 1262 
  ipsec->num_tx_sa = (unsigned short)0U;
  #line 1264 
  adapter->ipsec = ipsec;
  #line 1265 
  ixgbe_ipsec_stop_engine(adapter);
  #line 1266 
  ixgbe_ipsec_clear_hw_tables(adapter);
  #line 1268 
  (adapter->netdev)->xfrmdev_ops = & ixgbe_xfrmdev_ops;
  #line 1270 
  return;
  #line 1272 
  err2: 
        #line 1272 
  ;
  #line 1273 
  kfree((void *)ipsec->ip_tbl);
  #line 1274 
  kfree((void *)ipsec->rx_tbl);
  #line 1275 
  kfree((void *)ipsec->tx_tbl);
  #line 1276 
  kfree((void *)ipsec);
  #line 1277 
  err1: 
        #line 1277 
  ;
  #line 1278 
  netdev_err(adapter->netdev,(char *)"Unable to allocate memory for SA tables");
  #line 1279 
  return;
}

#line 1285  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c"
void ixgbe_stop_ipsec_offload(struct ixgbe_adapter *adapter)
{
  #line 1287 
  struct ixgbe_ipsec *ipsec = adapter->ipsec;
  #line 1289 
  adapter->ipsec = (struct ixgbe_ipsec *)0;
  #line 1290 
  if (ipsec != (struct ixgbe_ipsec *)0) {
    #line 1291 
    kfree((void *)ipsec->ip_tbl);
    #line 1292 
    kfree((void *)ipsec->rx_tbl);
    #line 1293 
    kfree((void *)ipsec->tx_tbl);
    #line 1294 
    kfree((void *)ipsec);
  }
  #line 1296 
  return;
}

#line 486  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ipsec.i.aux"
static void *kzalloc_2(size_t size, gfp_t flags)
{
  #line 489 
  return ldv_kzalloc(size,flags);
}

#line 836  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_ipsec.i.aux"
static int cif_strcmp(char *cs, char *ct)
{
  #line 839 
  return ldv_strcmp(cs,ct);
}

#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static void ixgbe_write_reg_12(struct ixgbe_hw *hw, u32 reg, u32 value)
{
  #line 147 
  union __anonunion___u_14347 __u;
  #line 146 
  __read_once_size((void *)(& hw->hw_addr),(void *)(& __u.__c),8);
  #line 146 
  u8 *reg_addr = (__u.__val);
  #line 148 
  if ((int)ixgbe_removed((void *)reg_addr) != 0) 
                                                 #line 149 
                                                 return;
  #line 150 
  writel(value,(void *)(reg_addr + (unsigned long)reg));
  #line 151 
  return;
}

#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
#line 488 
static s32 ixgbe_update_flash_X540(struct ixgbe_hw *hw);
#line 20 
#line 533 
static s32 ixgbe_poll_flash_update_done_X540(struct ixgbe_hw *hw);
#line 21 
#line 664 
static s32 ixgbe_get_swfw_sync_semaphore(struct ixgbe_hw *hw);
#line 22 
#line 710 
static void ixgbe_release_swfw_sync_semaphore(struct ixgbe_hw *hw);
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
enum ixgbe_media_type ixgbe_get_media_type_X540(struct ixgbe_hw *hw)
{
  #line 26 
  return ixgbe_media_type_copper;
}

#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
s32 ixgbe_get_invariants_X540(struct ixgbe_hw *hw)
{
  #line 31 
  struct ixgbe_mac_info *mac = & hw->mac;
  #line 32 
  struct ixgbe_phy_info *phy = & hw->phy;
  #line 35 
  phy->ops.set_phy_power = & ixgbe_set_copper_phy_power;
  #line 37 
  mac->mcft_size = 128U;
  #line 38 
  mac->vft_size = 128U;
  #line 39 
  mac->num_rar_entries = 128U;
  #line 40 
  mac->rx_pb_size = 384U;
  #line 41 
  mac->max_rx_queues = 128U;
  #line 42 
  mac->max_tx_queues = 128U;
  #line 43 
  mac->max_msix_vectors = ixgbe_get_pcie_msix_count_generic(hw);
  #line 45 
  return 0;
}

#line 54  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
s32 ixgbe_setup_mac_link_X540(struct ixgbe_hw *hw, ixgbe_link_speed speed, bool autoneg_wait_to_complete)
{
  #line 57 
  return (*(hw->phy.ops.setup_link_speed))(hw,speed,
                                        (_Bool)((bool)((int)autoneg_wait_to_complete) != 0));
}

#line 69  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
s32 ixgbe_reset_hw_X540(struct ixgbe_hw *hw)
{
  #line 71 
  s32 status;
  #line 72 
  u32 ctrl;
  #line 72 
  u32 i;
  #line 73 
  u32 swfw_mask = hw->phy.phy_semaphore_mask;
  #line 76 
  status = (*(hw->mac.ops.stop_adapter))(hw);
  #line 77 
  if (status != 0) 
                   #line 78 
                   return status;
  #line 81 
  ixgbe_clear_tx_pending(hw);
  #line 83 
  mac_reset_top: 
                 #line 83 
  ;
  #line 84 
  status = (*(hw->mac.ops.acquire_swfw_sync))(hw,swfw_mask);
  #line 85 
  if (status != 0) {
    {
      #line 86 
      bool branch;
      #line 86 
      struct _ddebug __UNIQUE_ID_ddebug443 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_reset_hw_X540", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c", .format = (char *)"semaphore failed with %d", .lineno = (unsigned int)86U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 86 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug443.key.dd_key_false.key,(_Bool)0);
      #line 86 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 86 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug443,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"semaphore failed with %d",status);
    }
    #line 87 
    return -16;
  }
  #line 90 
  ctrl = 67108864U;
  #line 91 
  ctrl = ixgbe_read_reg(hw,0U) | ctrl;
  #line 92 
  ixgbe_write_reg_12(hw,0U,ctrl);
  #line 93 
  ixgbe_read_reg(hw,8U);
  #line 94 
  (*(hw->mac.ops.release_swfw_sync))(hw,swfw_mask);
  #line 95 
  usleep_range(1000UL,1200UL);
  #line 98 
  i = 0U;
  #line 98 
  while (i <= 9U) {
    #line 99 
    ctrl = ixgbe_read_reg(hw,0U);
    #line 100 
    if ((ctrl & 67108872U) == 0U) 
                                  #line 101 
                                  break;
    #line 102 
    __const_udelay(4295UL);
    #line 98 
    i ++;
  }
  #line 105 
  if ((ctrl & 67108872U) != 0U) {
    #line 106 
    status = -15;
    {
      #line 107 
      bool branch_0;
      #line 107 
      struct _ddebug __UNIQUE_ID_ddebug444 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_reset_hw_X540", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c", .format = (char *)"Reset polling failed to complete.\n", .lineno = (unsigned int)107U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 107 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug444.key.dd_key_false.key,(_Bool)0);
      #line 107 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 107 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug444,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Reset polling failed to complete.\n");
    }
  }
  #line 109 
  msleep(100U);
  #line 116 
  if (((int)hw->mac.flags & 1) != 0) {
    #line 117 
    hw->mac.flags = (unsigned char)((unsigned int)hw->mac.flags & 254U);
    #line 118 
    goto mac_reset_top;
  }
  #line 122 
  ixgbe_write_reg_12(hw,15360U,393216U);
  #line 125 
  (*(hw->mac.ops.get_mac_addr))(hw,(u8 *)(& hw->mac.perm_addr));
  #line 132 
  hw->mac.num_rar_entries = 128U;
  #line 133 
  (*(hw->mac.ops.init_rx_addrs))(hw);
  #line 136 
  (*(hw->mac.ops.get_san_mac_addr))(hw,(u8 *)(& hw->mac.san_addr));
  #line 139 
  if ((int)is_valid_ether_addr((u8 *)(& hw->mac.san_addr)) != 0) {
    #line 141 
    hw->mac.san_mac_rar_index = (unsigned char)((unsigned int)((unsigned char)hw->mac.num_rar_entries) + 255U);
    #line 143 
    (*(hw->mac.ops.set_rar))(hw,(unsigned int)hw->mac.san_mac_rar_index,(u8 *)(& hw->mac.san_addr),0U,2147483648U);
    #line 147 
    (*(hw->mac.ops.clear_vmdq))(hw,(unsigned int)hw->mac.san_mac_rar_index,4294967295U);
    #line 151 
    (hw->mac.num_rar_entries) --;
  }
  #line 155 
  (*(hw->mac.ops.get_wwn_prefix))(hw,& hw->mac.wwnn_prefix,& hw->mac.wwpn_prefix);
  #line 158 
  return status;
}

#line 169  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
s32 ixgbe_start_hw_X540(struct ixgbe_hw *hw)
{
  #line 171 
  s32 ret_val;
  #line 173 
  ret_val = ixgbe_start_hw_generic(hw);
  #line 174 
  if (ret_val != 0) 
                    #line 175 
                    return ret_val;
  #line 177 
  return ixgbe_start_hw_gen2(hw);
}

#line 187  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
s32 ixgbe_init_eeprom_params_X540(struct ixgbe_hw *hw)
{
  #line 190 
  u32 eec;
  #line 191 
  u16 eeprom_size;
  #line 189 
  struct ixgbe_eeprom_info *eeprom = & hw->eeprom;
  #line 193 
  if (eeprom->type == (unsigned int)ixgbe_eeprom_uninitialized) {
    #line 194 
    eeprom->semaphore_delay = 10U;
    #line 195 
    eeprom->type = ixgbe_flash;
    #line 197 
    eec = ixgbe_read_reg(hw,*(hw->mvals));
    #line 198 
    eeprom_size = (unsigned short)((unsigned int)((unsigned short)(eec >> 11)) & 15U);
    #line 200 
    eeprom->word_size = (unsigned short)(1UL << ((int)eeprom_size + 6));
    {
      #line 203 
      bool branch;
      #line 203 
      struct _ddebug __UNIQUE_ID_ddebug445 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_init_eeprom_params_X540", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c", .format = (char *)"Eeprom params: type = %d, size = %d\n", .lineno = (unsigned int)203U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 203 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug445.key.dd_key_false.key,(_Bool)0);
      #line 203 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 203 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug445,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Eeprom params: type = %d, size = %d\n",(unsigned int)eeprom->type,(int)eeprom->word_size);
    }
  }
  #line 207 
  return 0;
}

#line 218  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_read_eerd_X540(struct ixgbe_hw *hw, u16 offset, u16 *data)
{
  #line 220 
  s32 status;
  #line 222 
  if ((*(hw->mac.ops.acquire_swfw_sync))(hw,1U) != 0) 
                                                      #line 223 
                                                      return -16;
  #line 225 
  status = ixgbe_read_eerd_generic(hw,(unsigned short)((int)offset),data);
  #line 227 
  (*(hw->mac.ops.release_swfw_sync))(hw,1U);
  #line 228 
  return status;
}

#line 240  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_read_eerd_buffer_X540(struct ixgbe_hw *hw, u16 offset, u16 words, u16 *data)
{
  #line 243 
  s32 status;
  #line 245 
  if ((*(hw->mac.ops.acquire_swfw_sync))(hw,1U) != 0) 
                                                      #line 246 
                                                      return -16;
  #line 248 
  status = ixgbe_read_eerd_buffer_generic(hw,(unsigned short)((int)offset),(unsigned short)((int)words),data);
  #line 250 
  (*(hw->mac.ops.release_swfw_sync))(hw,1U);
  #line 251 
  return status;
}

#line 262  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_write_eewr_X540(struct ixgbe_hw *hw, u16 offset, u16 data)
{
  #line 264 
  s32 status;
  #line 266 
  if ((*(hw->mac.ops.acquire_swfw_sync))(hw,1U) != 0) 
                                                      #line 267 
                                                      return -16;
  #line 269 
  status = ixgbe_write_eewr_generic(hw,(unsigned short)((int)offset),(unsigned short)((int)data));
  #line 271 
  (*(hw->mac.ops.release_swfw_sync))(hw,1U);
  #line 272 
  return status;
}

#line 284  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_write_eewr_buffer_X540(struct ixgbe_hw *hw, u16 offset, u16 words, u16 *data)
{
  #line 287 
  s32 status;
  #line 289 
  if ((*(hw->mac.ops.acquire_swfw_sync))(hw,1U) != 0) 
                                                      #line 290 
                                                      return -16;
  #line 292 
  status = ixgbe_write_eewr_buffer_generic(hw,(unsigned short)((int)offset),(unsigned short)((int)words),data);
  #line 294 
  (*(hw->mac.ops.release_swfw_sync))(hw,1U);
  #line 295 
  return status;
}

#line 306  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_calc_eeprom_checksum_X540(struct ixgbe_hw *hw)
{
  #line 308 
  u16 i;
  #line 309 
  u16 j;
  #line 310 
  u16 checksum = (unsigned short)0U;
  #line 311 
  u16 length = (unsigned short)0U;
  #line 312 
  u16 pointer = (unsigned short)0U;
  #line 313 
  u16 word = (unsigned short)0U;
  #line 314 
  u16 checksum_last_word = (unsigned short)63U;
  #line 315 
  u16 ptr_start = (unsigned short)3U;
  #line 324 
  i = (unsigned short)0U;
  #line 324 
  while ((int)i < (int)checksum_last_word) {
    {
      #line 325 
      if (ixgbe_read_eerd_generic(hw,(unsigned short)((int)i),& word) != 0) {
        {
          #line 326 
          bool branch;
          #line 326 
          struct _ddebug __UNIQUE_ID_ddebug446 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_calc_eeprom_checksum_X540", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c", .format = (char *)"EEPROM read failed\n", .lineno = (unsigned int)326U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
          #line 326 
          branch = arch_static_branch(& __UNIQUE_ID_ddebug446.key.dd_key_false.key,(_Bool)0);
          #line 326 
          if ((long)((long)((int)branch != 0)) != 0L) 
                                                      #line 326 
                                                      __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug446,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"EEPROM read failed\n");
        }
        #line 327 
        return -1;
      }
      #line 329 
      checksum = (unsigned short)((int)checksum + (int)word);
    }
    #line 324 
    i = (u16)((int)i + 1);
  }
  #line 336 
  i = ptr_start;
  #line 336 
  while ((unsigned int)i <= 14U) {
    {
      #line 337 
      if ((unsigned int)i + 65532U <= 1U) 
                                          #line 338 
                                          goto __Cont;
      #line 340 
      if (ixgbe_read_eerd_generic(hw,(unsigned short)((int)i),& pointer) != 0) {
        {
          #line 341 
          bool branch_0;
          #line 341 
          struct _ddebug __UNIQUE_ID_ddebug447 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_calc_eeprom_checksum_X540", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c", .format = (char *)"EEPROM read failed\n", .lineno = (unsigned int)341U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
          #line 341 
          branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug447.key.dd_key_false.key,(_Bool)0);
          #line 341 
          if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                        #line 341 
                                                        __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug447,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"EEPROM read failed\n");
        }
        #line 342 
        break;
      }
      #line 346 
      if ((unsigned int)pointer + 65535U > 65533U || (int)hw->eeprom.word_size <= (int)pointer) 
        #line 348 
        goto __Cont;
      #line 350 
      if (ixgbe_read_eerd_generic(hw,(unsigned short)((int)pointer),& length) != 0) {
        {
          #line 351 
          bool branch_1;
          #line 351 
          struct _ddebug __UNIQUE_ID_ddebug448 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_calc_eeprom_checksum_X540", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c", .format = (char *)"EEPROM read failed\n", .lineno = (unsigned int)351U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
          #line 351 
          branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug448.key.dd_key_false.key,(_Bool)0);
          #line 351 
          if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                        #line 351 
                                                        __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug448,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"EEPROM read failed\n");
        }
        #line 352 
        return -1;
      }
      #line 357 
      if ((unsigned int)length + 65535U > 65533U || (int)pointer + (int)length >= (int)hw->eeprom.word_size) 
        #line 359 
        goto __Cont;
      #line 361 
      j = (unsigned short)((unsigned int)pointer + 1U);
      #line 361 
      while ((int)j <= (int)pointer + (int)length) {
        {
          #line 362 
          if (ixgbe_read_eerd_generic(hw,(unsigned short)((int)j),& word) != 0) {
            {
              #line 363 
              bool branch_2;
              #line 363 
              struct _ddebug __UNIQUE_ID_ddebug449 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_calc_eeprom_checksum_X540", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c", .format = (char *)"EEPROM read failed\n", .lineno = (unsigned int)363U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
              #line 363 
              branch_2 = arch_static_branch(& __UNIQUE_ID_ddebug449.key.dd_key_false.key,(_Bool)0);
              #line 363 
              if ((long)((long)((int)branch_2 != 0)) != 0L) 
                                                            #line 363 
                                                            __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug449,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"EEPROM read failed\n");
            }
            #line 364 
            return -1;
          }
          #line 366 
          checksum = (unsigned short)((int)checksum + (int)word);
        }
        #line 361 
        j = (u16)((int)j + 1);
      }
    }
    #line 336 
    __Cont: 
            #line 336 
    i = (u16)((int)i + 1);
  }
  #line 370 
  checksum = (unsigned short)(47802U - (unsigned int)checksum);
  #line 372 
  return (int)checksum;
}

#line 383  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_validate_eeprom_checksum_X540(struct ixgbe_hw *hw, u16 *checksum_val)
{
  #line 386 
  s32 status;
  #line 387 
  u16 checksum;
  #line 388 
  u16 read_checksum = (unsigned short)0U;
  #line 394 
  status = (*(hw->eeprom.ops.read))(hw,(unsigned short)0,& checksum);
  #line 395 
  if (status != 0) {
    {
      #line 396 
      bool branch;
      #line 396 
      struct _ddebug __UNIQUE_ID_ddebug450 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_validate_eeprom_checksum_X540", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c", .format = (char *)"EEPROM read failed\n", .lineno = (unsigned int)396U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 396 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug450.key.dd_key_false.key,(_Bool)0);
      #line 396 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 396 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug450,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"EEPROM read failed\n");
    }
    #line 397 
    return status;
  }
  #line 400 
  if ((*(hw->mac.ops.acquire_swfw_sync))(hw,1U) != 0) 
                                                      #line 401 
                                                      return -16;
  #line 403 
  status = (*(hw->eeprom.ops.calc_checksum))(hw);
  #line 404 
  if (status < 0) 
                  #line 405 
                  goto out;
  #line 407 
  checksum = (unsigned short)status;
  #line 412 
  status = ixgbe_read_eerd_generic(hw,(unsigned short)63,& read_checksum);
  #line 414 
  if (status != 0) 
                   #line 415 
                   goto out;
  #line 420 
  if ((int)read_checksum != (int)checksum) {
    {
      #line 421 
      bool branch_0;
      #line 421 
      struct _ddebug __UNIQUE_ID_ddebug451 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_validate_eeprom_checksum_X540", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c", .format = (char *)"Invalid EEPROM checksum", .lineno = (unsigned int)421U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 421 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug451.key.dd_key_false.key,(_Bool)0);
      #line 421 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 421 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug451,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Invalid EEPROM checksum");
    }
    #line 422 
    status = -2;
  }
  #line 426 
  if (checksum_val != (u16 *)0U) 
                                 #line 427 
                                 *checksum_val = checksum;
  #line 429 
  out: 
       #line 429 
  ;
  #line 430 
  (*(hw->mac.ops.release_swfw_sync))(hw,1U);
  #line 432 
  return status;
}

#line 443  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_update_eeprom_checksum_X540(struct ixgbe_hw *hw)
{
  #line 445 
  s32 status;
  #line 446 
  u16 checksum;
  #line 452 
  status = (*(hw->eeprom.ops.read))(hw,(unsigned short)0,& checksum);
  #line 453 
  if (status != 0) {
    {
      #line 454 
      bool branch;
      #line 454 
      struct _ddebug __UNIQUE_ID_ddebug452 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_update_eeprom_checksum_X540", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c", .format = (char *)"EEPROM read failed\n", .lineno = (unsigned int)454U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 454 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug452.key.dd_key_false.key,(_Bool)0);
      #line 454 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 454 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug452,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"EEPROM read failed\n");
    }
    #line 455 
    return status;
  }
  #line 458 
  if ((*(hw->mac.ops.acquire_swfw_sync))(hw,1U) != 0) 
                                                      #line 459 
                                                      return -16;
  #line 461 
  status = (*(hw->eeprom.ops.calc_checksum))(hw);
  #line 462 
  if (status < 0) 
                  #line 463 
                  goto out;
  #line 465 
  checksum = (unsigned short)status;
  #line 470 
  status = ixgbe_write_eewr_generic(hw,(unsigned short)63,(unsigned short)((int)checksum));
  #line 471 
  if (status != 0) 
                   #line 472 
                   goto out;
  #line 474 
  status = ixgbe_update_flash_X540(hw);
  #line 476 
  out: 
       #line 476 
  ;
  #line 477 
  (*(hw->mac.ops.release_swfw_sync))(hw,1U);
  #line 478 
  return status;
}

#line 488  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_update_flash_X540(struct ixgbe_hw *hw)
{
  #line 490 
  u32 flup;
  #line 491 
  s32 status;
  #line 493 
  status = ixgbe_poll_flash_update_done_X540(hw);
  #line 494 
  if (status == -1) {
    {
      #line 495 
      bool branch;
      #line 495 
      struct _ddebug __UNIQUE_ID_ddebug453 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_update_flash_X540", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c", .format = (char *)"Flash update time out\n", .lineno = (unsigned int)495U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 495 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug453.key.dd_key_false.key,(_Bool)0);
      #line 495 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 495 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug453,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Flash update time out\n");
    }
    #line 496 
    return status;
  }
  #line 499 
  flup = ixgbe_read_reg(hw,*(hw->mvals)) | 8388608U;
  #line 500 
  ixgbe_write_reg_12(hw,*(hw->mvals),flup);
  #line 502 
  status = ixgbe_poll_flash_update_done_X540(hw);
  #line 503 
  if (status == 0) {
    #line 504 
    bool branch_0;
    #line 504 
    struct _ddebug __UNIQUE_ID_ddebug454 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_update_flash_X540", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c", .format = (char *)"Flash update complete\n", .lineno = (unsigned int)504U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 504 
    branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug454.key.dd_key_false.key,(_Bool)0);
    #line 504 
    if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                  #line 504 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug454,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Flash update complete\n");
  }
  else {
    #line 506 
    bool branch_1;
    #line 506 
    struct _ddebug __UNIQUE_ID_ddebug455 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_update_flash_X540", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c", .format = (char *)"Flash update time out\n", .lineno = (unsigned int)506U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 506 
    branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug455.key.dd_key_false.key,(_Bool)0);
    #line 506 
    if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                  #line 506 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug455,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Flash update time out\n");
  }
  #line 508 
  if ((unsigned int)hw->revision_id == 0U) {
    #line 509 
    flup = ixgbe_read_reg(hw,*(hw->mvals));
    #line 511 
    if ((flup & 33554432U) != 0U) {
      #line 512 
      flup |= 8388608U;
      #line 513 
      ixgbe_write_reg_12(hw,*(hw->mvals),flup);
    }
    #line 516 
    status = ixgbe_poll_flash_update_done_X540(hw);
    #line 517 
    if (status == 0) {
      #line 518 
      bool branch_2;
      #line 518 
      struct _ddebug __UNIQUE_ID_ddebug456 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_update_flash_X540", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c", .format = (char *)"Flash update complete\n", .lineno = (unsigned int)518U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 518 
      branch_2 = arch_static_branch(& __UNIQUE_ID_ddebug456.key.dd_key_false.key,(_Bool)0);
      #line 518 
      if ((long)((long)((int)branch_2 != 0)) != 0L) 
                                                    #line 518 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug456,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Flash update complete\n");
    }
    else {
      #line 520 
      bool branch_3;
      #line 520 
      struct _ddebug __UNIQUE_ID_ddebug457 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_update_flash_X540", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c", .format = (char *)"Flash update time out\n", .lineno = (unsigned int)520U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 520 
      branch_3 = arch_static_branch(& __UNIQUE_ID_ddebug457.key.dd_key_false.key,(_Bool)0);
      #line 520 
      if ((long)((long)((int)branch_3 != 0)) != 0L) 
                                                    #line 520 
                                                    __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug457,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Flash update time out\n");
    }
  }
  #line 523 
  return status;
}

#line 533  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_poll_flash_update_done_X540(struct ixgbe_hw *hw)
{
  #line 535 
  u32 i;
  #line 536 
  u32 reg;
  #line 538 
  i = 0U;
  #line 538 
  while (i <= 19999U) {
    #line 539 
    reg = ixgbe_read_reg(hw,*(hw->mvals));
    #line 540 
    if ((reg & 67108864U) != 0U) 
                                 #line 541 
                                 return 0;
    #line 542 
    __const_udelay(21475UL);
    #line 538 
    i ++;
  }
  #line 544 
  return -1;
}

#line 555  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
s32 ixgbe_acquire_swfw_sync_X540(struct ixgbe_hw *hw, u32 mask)
{
  #line 562 
  u32 swfw_sync;
  #line 563 
  u32 i;
  #line 557 
  u32 swmask = mask & 15U;
  #line 558 
  u32 swi2c_mask = mask & 6144U;
  #line 559 
  u32 fwmask = swmask << 5;
  #line 560 
  u32 timeout = 200U;
  #line 561 
  u32 hwmask = 0U;
  #line 565 
  if ((swmask & 1U) != 0U) 
                           #line 566 
                           hwmask = 16U;
  #line 569 
  if ((mask & 1024U) != 0U) 
                            #line 570 
                            swmask |= 1024U;
  #line 572 
  swmask |= swi2c_mask;
  #line 573 
  fwmask = (swi2c_mask << 2) | fwmask;
  #line 574 
  i = 0U;
  #line 574 
  while (i < timeout) {
    {
      #line 578 
      if (ixgbe_get_swfw_sync_semaphore(hw) != 0) 
                                                  #line 579 
                                                  return -16;
      #line 581 
      swfw_sync = ixgbe_read_reg(hw,*(hw->mvals + 5U));
      #line 582 
      if ((((fwmask | swmask) | hwmask) & swfw_sync) == 0U) {
        #line 583 
        swfw_sync |= swmask;
        #line 584 
        ixgbe_write_reg_12(hw,*(hw->mvals + 5U),swfw_sync);
        #line 585 
        ixgbe_release_swfw_sync_semaphore(hw);
        #line 586 
        usleep_range(5000UL,6000UL);
        #line 587 
        return 0;
      }
      #line 593 
      ixgbe_release_swfw_sync_semaphore(hw);
      #line 594 
      usleep_range(5000UL,10000UL);
    }
    #line 574 
    i ++;
  }
  #line 602 
  if (ixgbe_get_swfw_sync_semaphore(hw) != 0) 
                                              #line 603 
                                              return -16;
  #line 604 
  swfw_sync = ixgbe_read_reg(hw,*(hw->mvals + 5U));
  #line 605 
  if (((fwmask | hwmask) & swfw_sync) != 0U) {
    #line 606 
    swfw_sync |= swmask;
    #line 607 
    ixgbe_write_reg_12(hw,*(hw->mvals + 5U),swfw_sync);
    #line 608 
    ixgbe_release_swfw_sync_semaphore(hw);
    #line 609 
    usleep_range(5000UL,6000UL);
    #line 610 
    return 0;
  }
  #line 617 
  if ((swfw_sync & swmask) != 0U) {
    #line 618 
    u32 rmask = 1039U;
    #line 622 
    if (swi2c_mask != 0U) 
                          #line 623 
                          rmask |= 6144U;
    #line 624 
    ixgbe_release_swfw_sync_X540(hw,rmask);
    #line 625 
    ixgbe_release_swfw_sync_semaphore(hw);
    #line 626 
    return -16;
  }
  #line 628 
  ixgbe_release_swfw_sync_semaphore(hw);
  #line 630 
  return -16;
}

#line 641  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
void ixgbe_release_swfw_sync_X540(struct ixgbe_hw *hw, u32 mask)
{
  #line 644 
  u32 swfw_sync;
  #line 643 
  u32 swmask = mask & 1039U;
  #line 646 
  if ((mask & 6144U) != 0U) 
                            #line 647 
                            swmask = (mask & 6144U) | swmask;
  #line 648 
  ixgbe_get_swfw_sync_semaphore(hw);
  #line 650 
  swfw_sync = ixgbe_read_reg(hw,*(hw->mvals + 5U));
  #line 651 
  swfw_sync = ~ swmask & swfw_sync;
  #line 652 
  ixgbe_write_reg_12(hw,*(hw->mvals + 5U),swfw_sync);
  #line 654 
  ixgbe_release_swfw_sync_semaphore(hw);
  #line 655 
  usleep_range(5000UL,6000UL);
  #line 656 
  return;
}

#line 664  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_get_swfw_sync_semaphore(struct ixgbe_hw *hw)
{
  #line 667 
  u32 i;
  #line 668 
  u32 swsm;
  #line 666 
  u32 timeout = 2000U;
  #line 671 
  i = 0U;
  #line 671 
  while (i < timeout) {
    #line 675 
    swsm = ixgbe_read_reg(hw,*(hw->mvals + 4U));
    #line 676 
    if ((swsm & 1U) == 0U) 
                           #line 677 
                           break;
    #line 678 
    usleep_range(50UL,100UL);
    #line 671 
    i ++;
  }
  #line 681 
  if (i == timeout) {
    {
      #line 682 
      bool branch;
      #line 682 
      struct _ddebug __UNIQUE_ID_ddebug458 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_get_swfw_sync_semaphore", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c", .format = (char *)"Software semaphore SMBI between device drivers not granted.\n", .lineno = (unsigned int)682U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 682 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug458.key.dd_key_false.key,(_Bool)0);
      #line 682 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 682 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug458,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"Software semaphore SMBI between device drivers not granted.\n");
    }
    #line 684 
    return -1;
  }
  #line 688 
  i = 0U;
  #line 688 
  while (i < timeout) {
    #line 689 
    swsm = ixgbe_read_reg(hw,*(hw->mvals + 5U));
    #line 690 
    if ((swsm & 2147483648U) == 0U) 
                                    #line 691 
                                    return 0;
    #line 693 
    usleep_range(50UL,100UL);
    #line 688 
    i ++;
  }
  {
    #line 699 
    bool branch_0;
    #line 699 
    struct _ddebug __UNIQUE_ID_ddebug459 = {.modname = (char *)"ixgbe", .function = (char *)"ixgbe_get_swfw_sync_semaphore", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c", .format = (char *)"REGSMP Software NVM semaphore not granted\n", .lineno = (unsigned int)699U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 699 
    branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug459.key.dd_key_false.key,(_Bool)0);
    #line 699 
    if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                  #line 699 
                                                  __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug459,((struct ixgbe_adapter *)hw->back)->netdev,(char *)"REGSMP Software NVM semaphore not granted\n");
  }
  #line 700 
  ixgbe_release_swfw_sync_semaphore(hw);
  #line 701 
  return -1;
}

#line 710  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static void ixgbe_release_swfw_sync_semaphore(struct ixgbe_hw *hw)
{
  #line 712 
  u32 swsm;
  #line 716 
  swsm = ixgbe_read_reg(hw,*(hw->mvals + 5U));
  #line 717 
  swsm &= 2147483647U;
  #line 718 
  ixgbe_write_reg_12(hw,*(hw->mvals + 5U),swsm);
  #line 720 
  swsm = ixgbe_read_reg(hw,*(hw->mvals + 4U));
  #line 721 
  swsm &= 4294967294U;
  #line 722 
  ixgbe_write_reg_12(hw,*(hw->mvals + 4U),swsm);
  #line 724 
  ixgbe_read_reg(hw,8U);
  #line 725 
  return;
}

#line 734  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
void ixgbe_init_swfw_sync_X540(struct ixgbe_hw *hw)
{
  #line 736 
  u32 rmask;
  #line 744 
  ixgbe_get_swfw_sync_semaphore(hw);
  #line 745 
  ixgbe_release_swfw_sync_semaphore(hw);
  #line 748 
  rmask = 7183U;
  #line 752 
  ixgbe_acquire_swfw_sync_X540(hw,rmask);
  #line 753 
  ixgbe_release_swfw_sync_X540(hw,rmask);
  #line 754 
  return;
}

#line 764  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
s32 ixgbe_blink_led_start_X540(struct ixgbe_hw *hw, u32 index)
{
  #line 766 
  u32 macc_reg;
  #line 767 
  u32 ledctl_reg;
  #line 768 
  ixgbe_link_speed speed;
  #line 769 
  bool link_up;
  #line 771 
  if (index > 3U) 
                  #line 772 
                  return -5;
  #line 778 
  (*(hw->mac.ops.check_link))(hw,& speed,& link_up,(_Bool)0);
  #line 779 
  if (! link_up) {
    #line 780 
    macc_reg = ixgbe_read_reg(hw,17200U);
    #line 781 
    macc_reg |= 458753U;
    #line 782 
    ixgbe_write_reg_12(hw,17200U,macc_reg);
  }
  #line 785 
  ledctl_reg = ixgbe_read_reg(hw,512U);
  #line 786 
  ledctl_reg = (unsigned int)(~ (15 << index * 8U)) & ledctl_reg;
  #line 787 
  ledctl_reg = (unsigned int)(128 << index * 8U) | ledctl_reg;
  #line 788 
  ixgbe_write_reg_12(hw,512U,ledctl_reg);
  #line 789 
  ixgbe_read_reg(hw,8U);
  #line 791 
  return 0;
}

#line 802  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
s32 ixgbe_blink_led_stop_X540(struct ixgbe_hw *hw, u32 index)
{
  #line 804 
  u32 macc_reg;
  #line 805 
  u32 ledctl_reg;
  #line 807 
  if (index > 3U) 
                  #line 808 
                  return -5;
  #line 811 
  ledctl_reg = ixgbe_read_reg(hw,512U);
  #line 812 
  ledctl_reg = (unsigned int)(~ (15 << index * 8U)) & ledctl_reg;
  #line 813 
  ledctl_reg = (unsigned int)(4 << index * 8U) | ledctl_reg;
  #line 814 
  ledctl_reg = (unsigned int)(~ (128 << index * 8U)) & ledctl_reg;
  #line 815 
  ixgbe_write_reg_12(hw,512U,ledctl_reg);
  #line 818 
  macc_reg = ixgbe_read_reg(hw,17200U);
  #line 819 
  macc_reg &= 4294508542U;
  #line 820 
  ixgbe_write_reg_12(hw,17200U,macc_reg);
  #line 821 
  ixgbe_read_reg(hw,8U);
  #line 823 
  return 0;
}

#line 825  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static struct ixgbe_mac_operations mac_ops_X540 = {.init_hw = & ixgbe_init_hw_generic, .reset_hw = & ixgbe_reset_hw_X540, .start_hw = & ixgbe_start_hw_X540, .clear_hw_cntrs = & ixgbe_clear_hw_cntrs_generic, .get_media_type = & ixgbe_get_media_type_X540, .get_mac_addr = & ixgbe_get_mac_addr_generic, .get_san_mac_addr = & ixgbe_get_san_mac_addr_generic, .get_device_caps = & ixgbe_get_device_caps_generic, .get_wwn_prefix = & ixgbe_get_wwn_prefix_generic, .stop_adapter = & ixgbe_stop_adapter_generic, .get_bus_info = & ixgbe_get_bus_info_generic, .set_lan_id = & ixgbe_set_lan_id_multi_port_pcie, .disable_rx_buff = & ixgbe_disable_rx_buff_generic, .enable_rx_buff = & ixgbe_enable_rx_buff_generic, .enable_rx_dma = & ixgbe_enable_rx_dma_generic, .acquire_swfw_sync = & ixgbe_acquire_swfw_sync_X540, .release_swfw_sync = & ixgbe_release_swfw_sync_X540, .init_swfw_sync = & ixgbe_init_swfw_sync_X540, .prot_autoc_read = & prot_autoc_read_generic, .prot_autoc_write = & prot_autoc_write_generic, .setup_link = & ixgbe_setup_mac_link_X540, .check_link = & ixgbe_check_mac_link_generic, .get_link_capabilities = & ixgbe_get_copper_link_capabilities_generic, .set_rxpba = & ixgbe_set_rxpba_generic, .led_on = & ixgbe_led_on_generic, .led_off = & ixgbe_led_off_generic, .blink_led_start = & ixgbe_blink_led_start_X540, .blink_led_stop = & ixgbe_blink_led_stop_X540, .init_led_link_act = & ixgbe_init_led_link_act_generic, .set_rar = & ixgbe_set_rar_generic, .clear_rar = & ixgbe_clear_rar_generic, .set_vmdq = & ixgbe_set_vmdq_generic, .set_vmdq_san_mac = & ixgbe_set_vmdq_san_mac_generic, .clear_vmdq = & ixgbe_clear_vmdq_generic, .init_rx_addrs = & ixgbe_init_rx_addrs_generic, .update_mc_addr_list = & ixgbe_update_mc_addr_list_generic, .enable_mc = & ixgbe_enable_mc_generic, .disable_mc = & ixgbe_disable_mc_generic, .clear_vfta = & ixgbe_clear_vfta_generic, .set_vfta = & ixgbe_set_vfta_generic, .init_uta_tables = & ixgbe_init_uta_tables_generic, .set_mac_anti_spoofing = & ixgbe_set_mac_anti_spoofing, .set_vlan_anti_spoofing = & ixgbe_set_vlan_anti_spoofing, .fc_enable = & ixgbe_fc_enable_generic, .setup_fc = & ixgbe_setup_fc_generic, .fc_autoneg = & ixgbe_fc_autoneg, .set_fw_drv_ver = & ixgbe_set_fw_drv_ver_generic, .disable_rx = & ixgbe_disable_rx_generic, .enable_rx = & ixgbe_enable_rx_generic};
#line 882  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static struct ixgbe_eeprom_operations eeprom_ops_X540 = {.init_params = & ixgbe_init_eeprom_params_X540, .read = & ixgbe_read_eerd_X540, .read_buffer = & ixgbe_read_eerd_buffer_X540, .write = & ixgbe_write_eewr_X540, .write_buffer = & ixgbe_write_eewr_buffer_X540, .validate_checksum = & ixgbe_validate_eeprom_checksum_X540, .update_checksum = & ixgbe_update_eeprom_checksum_X540, .calc_checksum = & ixgbe_calc_eeprom_checksum_X540};
#line 893  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static struct ixgbe_phy_operations phy_ops_X540 = {.identify = & ixgbe_identify_phy_generic, .identify_sfp = & ixgbe_identify_sfp_module_generic, .read_reg = & ixgbe_read_phy_reg_generic, .write_reg = & ixgbe_write_phy_reg_generic, .setup_link = & ixgbe_setup_phy_link_generic, .setup_link_speed = & ixgbe_setup_phy_link_speed_generic, .read_i2c_byte = & ixgbe_read_i2c_byte_generic, .write_i2c_byte = & ixgbe_write_i2c_byte_generic, .read_i2c_sff8472 = & ixgbe_read_i2c_sff8472_generic, .read_i2c_eeprom = & ixgbe_read_i2c_eeprom_generic, .write_i2c_eeprom = & ixgbe_write_i2c_eeprom_generic, .check_overtemp = & ixgbe_tn_check_overtemp, .set_phy_power = & ixgbe_set_copper_phy_power};
#line 911  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static u32 ixgbe_mvals_X540[23U] = {65552U, 65564U, 66048U, 65872U, 65856U, 65888U, 65864U, 2U, 4U, 8U, 33554432U, 67108864U, 134217728U, 69768U, 69772U, 1U, 2U, 4U, 8U, [22] = 40U};
#line 915  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
struct ixgbe_info ixgbe_X540_info = {.mac = ixgbe_mac_X540, .get_invariants = & ixgbe_get_invariants_X540, .mac_ops = & mac_ops_X540, .eeprom_ops = & eeprom_ops_X540, .phy_ops = & phy_ops_X540, .mbx_ops = & mbx_ops_generic, .mvals = (u32 *)(& ixgbe_mvals_X540)};
#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/arch_hweight.h"
__inline static unsigned long __arch_hweight64(__u64 w)
{
  #line 45 
  unsigned long res;
  #line 46 
  ldv_inline_asm();
  #line 51 
  return res;
}

#line 70  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bitops.h"
__inline static unsigned long hweight_long(unsigned long w)
{
  #line 72 
  unsigned long tmp_0;
  #line 72 
  if (0 != 0) 
              #line 72 
              tmp_0 = (unsigned long)((((unsigned int)((((((((((unsigned long long)w & 1ULL) != 0ULL) + (((unsigned long long)w & 2ULL) != 0ULL)) + (((unsigned long long)w & 4ULL) != 0ULL)) + (((unsigned long long)w & 8ULL) != 0ULL)) + (((unsigned long long)w & 16ULL) != 0ULL)) + (((unsigned long long)w & 32ULL) != 0ULL)) + (((unsigned long long)w & 64ULL) != 0ULL)) + (((unsigned long long)w & 128ULL) != 0ULL)) + (unsigned int)(((((((((w & 256UL) != 0UL) + ((w & 512UL) != 0UL)) + ((w & 1024UL) != 0UL)) + ((w & 2048UL) != 0UL)) + ((w & 4096UL) != 0UL)) + ((w & 8192UL) != 0UL)) + ((w & 16384UL) != 0UL)) + ((w & 32768UL) != 0UL))) + ((unsigned int)(((((((((w & 65536UL) != 0UL) + ((w & 131072UL) != 0UL)) + ((w & 262144UL) != 0UL)) + ((w & 524288UL) != 0UL)) + ((w & 1048576UL) != 0UL)) + ((w & 2097152UL) != 0UL)) + ((w & 4194304UL) != 0UL)) + ((w & 8388608UL) != 0UL)) + (unsigned int)(((((((((w & 16777216UL) != 0UL) + ((w & 33554432UL) != 0UL)) + ((w & 67108864UL) != 0UL)) + ((w & 134217728UL) != 0UL)) + ((w & 268435456UL) != 0UL)) + ((w & 536870912UL) != 0UL)) + ((w & 1073741824UL) != 0UL)) + ((w & 2147483648UL) != 0UL)))) + (((unsigned int)(((((((((w & 4294967296UL) != 0UL) + ((w & 8589934592UL) != 0UL)) + ((w & 17179869184UL) != 0UL)) + ((w & 34359738368UL) != 0UL)) + ((w & 68719476736UL) != 0UL)) + ((w & 137438953472UL) != 0UL)) + ((w & 274877906944UL) != 0UL)) + ((w & 549755813888UL) != 0UL)) + (unsigned int)(((((((((w & 1099511627776UL) != 0UL) + ((w & 2199023255552UL) != 0UL)) + ((w & 4398046511104UL) != 0UL)) + ((w & 8796093022208UL) != 0UL)) + ((w & 17592186044416UL) != 0UL)) + ((w & 35184372088832UL) != 0UL)) + ((w & 70368744177664UL) != 0UL)) + ((w & 140737488355328UL) != 0UL))) + ((unsigned int)(((((((((w & 281474976710656UL) != 0UL) + ((w & 562949953421312UL) != 0UL)) + ((w & 1125899906842624UL) != 0UL)) + ((w & 2251799813685248UL) != 0UL)) + ((w & 4503599627370496UL) != 0UL)) + ((w & 9007199254740992UL) != 0UL)) + ((w & 18014398509481984UL) != 0UL)) + ((w & 36028797018963968UL) != 0UL)) + (unsigned int)(((((((((w & 72057594037927936UL) != 0UL) + ((w & 144115188075855872UL) != 0UL)) + ((w & 288230376151711744UL) != 0UL)) + ((w & 576460752303423488UL) != 0UL)) + ((w & 1152921504606846976UL) != 0UL)) + ((w & 2305843009213693952UL) != 0UL)) + ((w & 4611686018427387904UL) != 0UL)) + ((w & 9223372036854775808UL) != 0UL))))); else 
                                                                    #line 72 
                                                                    tmp_0 = __arch_hweight64((unsigned long long)w);
  #line 72 
  return tmp_0;
}

#line 26  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
#line 135  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_sriov.i.aux"
static void INIT_LIST_HEAD_1(struct list_head *list);
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
#line 33 
bool __list_add_valid(struct list_head *, struct list_head *, struct list_head *);
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next)
{
  #line 60 
  if (! __list_add_valid(new,prev,next)) 
                                         #line 61 
                                         return;
  #line 63 
  next->prev = new;
  #line 64 
  new->next = next;
  #line 65 
  new->prev = prev;
  {
    #line 67 
    union __anonunion___u_14371 __u = {.__val = new};
    #line 66 
    __write_once_size((void *)(& prev->next),(void *)(& __u.__c),8);
    #line 66 
    struct list_head *tmp_2 = __u.__val;
  }
  #line 68 
  return;
}

#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void list_add(struct list_head *new, struct list_head *head)
{
  #line 79 
  __list_add(new,head,head->next);
  #line 80 
  return;
}

#line 151  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bitmap.h"
#line 151 
int __bitmap_weight(unsigned long *, unsigned int);
#line 388  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bitmap.h"
__inline static int bitmap_weight(unsigned long *src, unsigned int nbits)
{
  #line 390 
  if (0 != 0 && nbits + 4294967295U <= 63U) {
    #line 391 
    return (int)hweight_long(*src & (18446744073709551615UL >> (- nbits & 63U)));
  }
  #line 392 
  return __bitmap_weight(src,nbits);
}

#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/cmpxchg_64.h"
__inline static int arch_atomic_read_1(atomic_t *v)
{
  #line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/atomic.h"
  union __anonunion___u_14425 __u;
  #line 31 
  __read_once_size((void *)(& v->counter),(void *)(& __u.__c),4);
  #line 31 
  return (__u.__val);
}

#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/atomic-instrumented.h"
__inline static int atomic_read_1(atomic_t *v)
{
  #line 26 
  kasan_check_read((void *)v,4U);
  #line 27 
  return arch_atomic_read_1(v);
}

#line 110  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
__inline static unsigned int num_online_cpus_1(void)
{
  #line 112 
  return (unsigned int)atomic_read_1(& __num_online_cpus);
}

#line 607  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 465  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_sriov.i.aux"
static void *kcalloc_1(size_t n, size_t size, gfp_t flags);
#line 1018  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
#line 1018 
struct pci_dev *pci_dev_get(struct pci_dev *);
#line 2029 
#line 2029 
int pci_enable_sriov(struct pci_dev *, int);
#line 2030 
#line 2030 
void pci_disable_sriov(struct pci_dev *);
#line 2033 
#line 2033 
int pci_num_vf(struct pci_dev *);
#line 2034 
#line 2034 
int pci_vfs_assigned(struct pci_dev *);
#line 249  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static void eth_zero_addr(u8 *addr)
{
  #line 251 
  memset((void *)addr,0,6UL);
  #line 252 
  return;
}

#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static void ixgbe_write_reg_13(struct ixgbe_hw *hw, u32 reg, u32 value)
{
  #line 147 
  union __anonunion___u_15339 __u;
  #line 146 
  __read_once_size((void *)(& hw->hw_addr),(void *)(& __u.__c),8);
  #line 146 
  u8 *reg_addr = (__u.__val);
  #line 148 
  if ((int)ixgbe_removed((void *)reg_addr) != 0) 
                                                 #line 149 
                                                 return;
  #line 150 
  writel(value,(void *)(reg_addr + (unsigned long)reg));
  #line 151 
  return;
}

#line 41  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.h"
__inline static void ixgbe_set_vmvir(struct ixgbe_adapter *adapter, u16 vid, u16 qos, u32 vf)
{
  #line 44 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 45 
  u32 vmvir = (unsigned int)(((int)vid | ((int)qos << 13)) | 1073741824);
  #line 47 
  ixgbe_write_reg_13(hw,(vf + 8192U) * 4U,vmvir);
  #line 48 
  return;
}

#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
__inline static void ixgbe_alloc_vf_macvlans(struct ixgbe_adapter *adapter, unsigned int num_vfs)
{
  #line 28 
  struct vf_macvlans *mv_list;
  #line 29 
  int num_vf_macvlans;
  #line 29 
  int i;
  #line 27 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 31 
  num_vf_macvlans = (int)((hw->mac.num_rar_entries - num_vfs) + 4294967280U);
  #line 33 
  if (num_vf_macvlans == 0) 
                            #line 34 
                            return;
  #line 36 
  mv_list = (struct vf_macvlans *)kcalloc_1((unsigned long)num_vf_macvlans,32UL,3264U);
  #line 38 
  if (mv_list != (struct vf_macvlans *)0) {
    #line 40 
    INIT_LIST_HEAD_1(& adapter->vf_mvs.l);
    #line 41 
    i = 0;
    #line 41 
    while (i < num_vf_macvlans) {
      #line 42 
      (mv_list + (unsigned long)i)->vf = -1;
      #line 43 
      (mv_list + (unsigned long)i)->free = (_Bool)1;
      #line 44 
      list_add(& (mv_list + (unsigned long)i)->l,& adapter->vf_mvs.l);
      #line 41 
      i ++;
    }
    #line 46 
    adapter->mv_list = mv_list;
  }
  #line 48 
  return;
}

#line 50  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int __ixgbe_enable_sriov(struct ixgbe_adapter *adapter, unsigned int num_vfs)
{
  #line 54 
  int i;
  #line 53 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 56 
  if (adapter->xdp_prog != (struct bpf_prog *)0) {
    #line 57 
    if (((int)adapter->msg_enable & 2) != 0) 
                                             #line 57 
                                             netdev_warn(adapter->netdev,(char *)"SRIOV is not supported with XDP\n");
    #line 58 
    return -22;
  }
  #line 62 
  adapter->flags |= 8404992U;
  #line 66 
  adapter->vfinfo = (struct vf_data_storage *)kcalloc_1((unsigned long)num_vfs,96UL,3264U);
  #line 68 
  if (adapter->vfinfo == (struct vf_data_storage *)0) 
                                                      #line 69 
                                                      return -12;
  #line 71 
  adapter->num_vfs = num_vfs;
  #line 73 
  ixgbe_alloc_vf_macvlans(adapter,num_vfs);
  #line 74 
  adapter->ring_feature[1].offset = (unsigned short)num_vfs;
  #line 77 
  ixgbe_write_reg_13(hw,33312U,1U);
  #line 78 
  adapter->bridge_mode = (unsigned short)0U;
  #line 81 
  if (adapter->hw.mac.type == (unsigned int)ixgbe_mac_82599EB && num_vfs <= 15U) {
    #line 82 
    adapter->dcb_cfg.num_tcs.pg_tcs = (unsigned char)8U;
    #line 83 
    adapter->dcb_cfg.num_tcs.pfc_tcs = (unsigned char)8U;
  }
  else 
    #line 84 
    if (num_vfs <= 31U) {
      #line 85 
      adapter->dcb_cfg.num_tcs.pg_tcs = (unsigned char)4U;
      #line 86 
      adapter->dcb_cfg.num_tcs.pfc_tcs = (unsigned char)4U;
    }
    else {
      #line 88 
      adapter->dcb_cfg.num_tcs.pg_tcs = (unsigned char)1U;
      #line 89 
      adapter->dcb_cfg.num_tcs.pfc_tcs = (unsigned char)1U;
    }
  #line 93 
  adapter->flags2 &= 4294967292U;
  #line 96 
  i = 0;
  #line 96 
  while ((unsigned int)i < num_vfs) {
    #line 98 
    (adapter->vfinfo + (unsigned long)i)->spoofchk_enabled = (unsigned char)1U;
    #line 105 
    (adapter->vfinfo + (unsigned long)i)->rss_query_enabled = (_Bool)0;
    #line 108 
    (adapter->vfinfo + (unsigned long)i)->trusted = (unsigned char)0U;
    #line 111 
    (adapter->vfinfo + (unsigned long)i)->xcast_mode = 0;
    #line 96 
    i ++;
  }
  #line 114 
  if (((int)adapter->msg_enable & 2) != 0) 
                                           #line 114 
                                           netdev_info(adapter->netdev,(char *)"SR-IOV enabled with %d VFs\n",num_vfs);
  #line 115 
  return 0;
}

#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static void ixgbe_get_vfs(struct ixgbe_adapter *adapter)
{
  #line 126 
  struct pci_dev *vfdev;
  #line 128 
  u16 vf_id;
  #line 129 
  int pos;
  #line 124 
  struct pci_dev *pdev = adapter->pdev;
  #line 125 
  u16 vendor = pdev->vendor;
  #line 127 
  int vf = 0;
  #line 131 
  pos = pci_find_ext_capability(pdev,16);
  #line 132 
  if (pos == 0) 
                #line 133 
                return;
  #line 134 
  pci_read_config_word(pdev,pos + 26,& vf_id);
  #line 136 
  vfdev = pci_get_device((unsigned int)vendor,(unsigned int)vf_id,(struct pci_dev *)0);
  #line 137 
  while (vfdev != (struct pci_dev *)0) {
    #line 138 
    if ((unsigned int)vfdev->is_virtfn == 0U) 
                                              #line 139 
                                              goto __Cont;
    #line 140 
    if (vfdev->__anonCompField_pci_dev_59.physfn != pdev) 
                                                          #line 141 
                                                          goto __Cont;
    #line 142 
    if (adapter->num_vfs <= (unsigned int)vf) 
                                              #line 143 
                                              goto __Cont;
    #line 144 
    pci_dev_get(vfdev);
    #line 145 
    (adapter->vfinfo + (unsigned long)vf)->vfdev = vfdev;
    #line 146 
    vf ++;
    #line 137 
    __Cont: 
            #line 137 
    vfdev = pci_get_device((unsigned int)vendor,(unsigned int)vf_id,vfdev);
  }
  #line 148 
  return;
}

#line 153  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
void ixgbe_enable_sriov(struct ixgbe_adapter *adapter, unsigned int max_vfs_0)
{
  #line 156 
  unsigned int num_vfs;
  #line 155 
  int pre_existing_vfs = 0;
  #line 158 
  pre_existing_vfs = pci_num_vf(adapter->pdev);
  #line 159 
  if (pre_existing_vfs == 0 && max_vfs_0 == 0U) 
                                                #line 160 
                                                return;
  #line 168 
  if (pre_existing_vfs != 0) {
    #line 169 
    num_vfs = (unsigned int)pre_existing_vfs;
    #line 170 
    _dev_warn(& (adapter->pdev)->dev,(char *)"Virtual Functions already enabled for this device - Please reload all VF drivers to avoid spoofed packet errors\n");
  }
  else {
    #line 181 
    unsigned int __UNIQUE_ID___x536;
    #line 181 
    unsigned int tmp;
    #line 173 
    int err;
    {
      #line 181 
      __UNIQUE_ID___x536 = max_vfs_0;
      #line 181 
      unsigned int __UNIQUE_ID___y537 = 63U;
      #line 181 
      if (__UNIQUE_ID___x536 < __UNIQUE_ID___y537) 
                                                   #line 181 
                                                   tmp = __UNIQUE_ID___x536; else 
                                                                    #line 181 
                                                                    tmp = __UNIQUE_ID___y537;
      }
    #line 181 
    num_vfs = tmp;
    #line 183 
    err = pci_enable_sriov(adapter->pdev,(int)num_vfs);
    #line 184 
    if (err != 0) {
      #line 185 
      if (((int)adapter->msg_enable & 2) != 0) 
                                               #line 185 
                                               netdev_err(adapter->netdev,(char *)"Failed to enable PCI sriov: %d\n",err);
      #line 186 
      return;
    }
  }
  #line 190 
  if (__ixgbe_enable_sriov(adapter,num_vfs) == 0) {
    #line 191 
    ixgbe_get_vfs(adapter);
    #line 192 
    return;
  }
  #line 198 
  if (((int)adapter->msg_enable & 2) != 0) 
                                           #line 198 
                                           netdev_err(adapter->netdev,(char *)"Unable to allocate memory for VF Data Storage - ");
  #line 200 
  ixgbe_disable_sriov(adapter);
  #line 201 
  return;
}

#line 204  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_disable_sriov(struct ixgbe_adapter *adapter)
{
  #line 206 
  unsigned int vf;
  #line 207 
  int rss;
  #line 206 
  unsigned int num_vfs = adapter->num_vfs;
  #line 210 
  adapter->num_vfs = 0U;
  #line 213 
  vf = 0U;
  #line 213 
  while (vf < num_vfs) {
    {
      #line 214 
      struct pci_dev *vfdev = (adapter->vfinfo + (unsigned long)vf)->vfdev;
      #line 216 
      if (vfdev == (struct pci_dev *)0) 
                                        #line 217 
                                        goto __Cont;
      #line 218 
      (adapter->vfinfo + (unsigned long)vf)->vfdev = (struct pci_dev *)0;
      #line 219 
      pci_dev_put(vfdev);
    }
    #line 213 
    __Cont: 
            #line 213 
    vf ++;
  }
  #line 223 
  kfree((void *)adapter->vfinfo);
  #line 224 
  adapter->vfinfo = (struct vf_data_storage *)0;
  #line 227 
  kfree((void *)adapter->mv_list);
  #line 228 
  adapter->mv_list = (struct vf_macvlans *)0;
  #line 231 
  if (((unsigned long)adapter->flags & 8388608UL) == 0UL) 
                                                          #line 232 
                                                          return 0;
  #line 240 
  if (pci_vfs_assigned(adapter->pdev) != 0) {
    #line 241 
    _dev_warn(& (adapter->pdev)->dev,(char *)"Unloading driver while VFs are assigned - VFs will not be deallocated\n");
    #line 242 
    return -1;
  }
  #line 245 
  pci_disable_sriov(adapter->pdev);
  #line 249 
  if (bitmap_weight((unsigned long *)(& adapter->fwd_bitmask),
                      (unsigned int)adapter->num_rx_pools) == 1) {
    #line 252 
    int __UNIQUE_ID___x538;
    #line 252 
    int tmp_2;
    #line 250 
    adapter->flags &= 4294950911U;
    #line 251 
    adapter->flags &= 4286578687U;
    {
      #line 252 
      __UNIQUE_ID___x538 = (int)ixgbe_max_rss_indices(adapter);
      #line 252 
      int __UNIQUE_ID___y539 = (int)num_online_cpus_1();
      #line 252 
      if (__UNIQUE_ID___x538 < __UNIQUE_ID___y539) 
                                                   #line 252 
                                                   tmp_2 = __UNIQUE_ID___x538; else 
                                                                    #line 252 
                                                                    tmp_2 = __UNIQUE_ID___y539;
      }
    #line 252 
    rss = tmp_2;
  }
  else {
    #line 255 
    int __UNIQUE_ID___x540;
    #line 255 
    int tmp_5;
    {
      #line 255 
      __UNIQUE_ID___x540 = 4;
      #line 255 
      int __UNIQUE_ID___y541 = (int)num_online_cpus_1();
      #line 255 
      if (__UNIQUE_ID___x540 < __UNIQUE_ID___y541) 
                                                   #line 255 
                                                   tmp_5 = __UNIQUE_ID___x540; else 
                                                                    #line 255 
                                                                    tmp_5 = __UNIQUE_ID___y541;
      }
    #line 255 
    rss = tmp_5;
  }
  #line 258 
  adapter->ring_feature[1].offset = (unsigned short)0U;
  #line 259 
  adapter->ring_feature[2].limit = (unsigned short)rss;
  #line 262 
  msleep(100U);
  #line 263 
  return 0;
}

#line 266  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_pci_sriov_enable(struct pci_dev *dev, int num_vfs)
{
  #line 271 
  int num_rx_pools;
  #line 271 
  int i;
  #line 271 
  int limit;
  #line 272 
  u8 num_tc;
  #line 269 
  struct ixgbe_adapter *adapter = pci_get_drvdata(dev);
  #line 270 
  int pre_existing_vfs = pci_num_vf(dev);
  #line 271 
  int err = 0;
  #line 274 
  if (pre_existing_vfs != 0 && pre_existing_vfs != num_vfs) 
                                                            #line 275 
                                                            err = ixgbe_disable_sriov(adapter);
  else 
    #line 276 
    if (pre_existing_vfs != 0 && pre_existing_vfs == num_vfs) 
                                                              #line 277 
                                                              return num_vfs;
  #line 279 
  if (err != 0) 
                #line 280 
                return err;
  #line 294 
  num_tc = adapter->hw_tcs;
  #line 295 
  num_rx_pools = bitmap_weight((unsigned long *)(& adapter->fwd_bitmask),(unsigned int)adapter->num_rx_pools);
  #line 297 
  if ((unsigned int)num_tc <= 4U) {
    #line 297 
    int tmp_1;
    #line 297 
    if ((unsigned int)num_tc > 1U) 
                                   #line 297 
                                   tmp_1 = 32; else 
                                                    #line 297 
                                                    tmp_1 = 64;
    #line 297 
    limit = tmp_1;
  }
  else 
       #line 297 
       limit = 16;
  #line 300 
  if (limit - num_rx_pools < num_vfs) {
    #line 301 
    _dev_err(& (adapter->pdev)->dev,(char *)"Currently configured with %d TCs, and %d offloaded macvlans. Creating more than %d VFs is not allowed\n",(int)num_tc,num_rx_pools + -1,limit - num_rx_pools);
    #line 303 
    return -1;
  }
  #line 306 
  err = __ixgbe_enable_sriov(adapter,(unsigned int)num_vfs);
  #line 307 
  if (err != 0) 
                #line 308 
                return err;
  #line 310 
  i = 0;
  #line 310 
  while (i < num_vfs) {
    #line 311 
    ixgbe_vf_configuration(dev,(unsigned int)(i | 268435456));
    #line 310 
    i ++;
  }
  #line 314 
  ixgbe_sriov_reinit(adapter);
  #line 316 
  err = pci_enable_sriov(dev,num_vfs);
  #line 317 
  if (err != 0) {
    #line 318 
    _dev_warn(& (adapter->pdev)->dev,(char *)"Failed to enable PCI sriov: %d\n",err);
    #line 319 
    return err;
  }
  #line 321 
  ixgbe_get_vfs(adapter);
  #line 323 
  return num_vfs;
}

#line 329  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_pci_sriov_disable(struct pci_dev *dev)
{
  #line 332 
  int err;
  #line 331 
  struct ixgbe_adapter *adapter = pci_get_drvdata(dev);
  #line 334 
  u32 current_flags = adapter->flags;
  #line 335 
  int prev_num_vf = pci_num_vf(dev);
  #line 338 
  err = ixgbe_disable_sriov(adapter);
  #line 342 
  if (err == 0) 
    #line 342 
    if (adapter->flags != current_flags) 
                                         #line 344 
                                         ixgbe_sriov_reinit(adapter);
    else {
      #line 342 
      ;
      #line 342 
      if (pci_num_vf(dev) != prev_num_vf) 
                                          #line 344 
                                          ixgbe_sriov_reinit(adapter);
    }
  #line 347 
  return err;
}

#line 350  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_pci_sriov_configure(struct pci_dev *dev, int num_vfs)
{
  #line 352 
  if (num_vfs == 0) {
    #line 353 
    return ixgbe_pci_sriov_disable(dev);
  }
  else {
    #line 355 
    return ixgbe_pci_sriov_enable(dev,num_vfs);
  }
}

#line 358  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_set_vf_multicasts(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)
{
  #line 373 
  int __UNIQUE_ID___x542;
  #line 373 
  int tmp_0;
  #line 366 
  int i;
  #line 367 
  u32 vector_bit;
  #line 368 
  u32 vector_reg;
  #line 369 
  u32 mta_reg;
  #line 361 
  int entries = (int)(*msgbuf >> 16) & 255;
  #line 363 
  u16 *hash_list = (u16 *)(msgbuf + 1U);
  #line 364 
  struct vf_data_storage *vfinfo = adapter->vfinfo + (unsigned long)vf;
  #line 365 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 370 
  u32 vmolr = ixgbe_read_reg(hw,(vf + 15360U) * 4U);
  {
    #line 373 
    __UNIQUE_ID___x542 = entries;
    #line 373 
    int __UNIQUE_ID___y543 = 30;
    #line 373 
    if (__UNIQUE_ID___x542 < __UNIQUE_ID___y543) 
                                                 #line 373 
                                                 tmp_0 = __UNIQUE_ID___x542; else 
                                                                    #line 373 
                                                                    tmp_0 = __UNIQUE_ID___y543;
    }
  #line 373 
  entries = tmp_0;
  #line 380 
  vfinfo->num_vf_mc_hashes = (unsigned short)entries;
  #line 386 
  i = 0;
  #line 386 
  while (i < entries) {
    #line 387 
    vfinfo->vf_mc_hashes[i] = *(hash_list + (unsigned long)i);
    #line 386 
    i ++;
  }
  #line 390 
  i = 0;
  #line 390 
  while ((int)vfinfo->num_vf_mc_hashes > i) {
    #line 391 
    vector_reg = (unsigned int)((int)vfinfo->vf_mc_hashes[i] >> 5) & 127U;
    #line 392 
    vector_bit = (unsigned int)vfinfo->vf_mc_hashes[i] & 31U;
    #line 393 
    mta_reg = ixgbe_read_reg(hw,(vector_reg + 5248U) * 4U);
    #line 394 
    mta_reg = (unsigned int)(1UL << vector_bit) | mta_reg;
    #line 395 
    ixgbe_write_reg_13(hw,(vector_reg + 5248U) * 4U,mta_reg);
    #line 390 
    i ++;
  }
  #line 397 
  vmolr |= 33554432U;
  #line 398 
  ixgbe_write_reg_13(hw,(vf + 15360U) * 4U,vmolr);
  #line 400 
  return 0;
}

#line 404  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
void ixgbe_restore_vf_multicasts(struct ixgbe_adapter *adapter)
{
  #line 407 
  struct vf_data_storage *vfinfo;
  #line 408 
  int i;
  #line 408 
  int j;
  #line 409 
  u32 vector_bit;
  #line 410 
  u32 vector_reg;
  #line 411 
  u32 mta_reg;
  #line 406 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 413 
  i = 0;
  #line 413 
  while (adapter->num_vfs > (unsigned int)i) {
    {
      #line 414 
      u32 vmolr = ixgbe_read_reg(hw,(unsigned int)((i + 15360) * 4));
      #line 415 
      vfinfo = adapter->vfinfo + (unsigned long)i;
      #line 416 
      j = 0;
      #line 416 
      while ((int)vfinfo->num_vf_mc_hashes > j) {
        #line 417 
        (hw->addr_ctrl.mta_in_use) ++;
        #line 418 
        vector_reg = (unsigned int)((int)vfinfo->vf_mc_hashes[j] >> 5) & 127U;
        #line 419 
        vector_bit = (unsigned int)vfinfo->vf_mc_hashes[j] & 31U;
        #line 420 
        mta_reg = ixgbe_read_reg(hw,(vector_reg + 5248U) * 4U);
        #line 421 
        mta_reg = (unsigned int)(1UL << vector_bit) | mta_reg;
        #line 422 
        ixgbe_write_reg_13(hw,(vector_reg + 5248U) * 4U,mta_reg);
        #line 416 
        j ++;
      }
      #line 425 
      if ((unsigned int)vfinfo->num_vf_mc_hashes != 0U) 
                                                        #line 426 
                                                        vmolr |= 33554432U; else 
                                                                    #line 428 
                                                                    vmolr &= 4261412863U;
      #line 429 
      ixgbe_write_reg_13(hw,(unsigned int)((i + 15360) * 4),vmolr);
    }
    #line 413 
    i ++;
  }
  #line 433 
  ixgbe_full_sync_mac_table(adapter);
  #line 434 
  return;
}

#line 437  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_set_vf_vlan(struct ixgbe_adapter *adapter, int add, int vid, u32 vf)
{
  #line 441 
  int err;
  #line 440 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 448 
  if (add != 0) {
    #line 448 
    if ((int)test_bit((long)vid,(unsigned long *)(& adapter->active_vlans)) != 0) {
      #line 449 
      err = (*(hw->mac.ops.set_vfta))(hw,(unsigned int)vid,(unsigned int)adapter->ring_feature[1].offset,(_Bool)1,(_Bool)0);
      #line 450 
      if (err != 0) 
                    #line 451 
                    return err;
    }
  }
  #line 454 
  err = (*(hw->mac.ops.set_vfta))(hw,(unsigned int)vid,vf,(_Bool)(add != 0),(_Bool)0);
  #line 456 
  if (add != 0 && err == 0) 
                            #line 457 
                            return err;
  #line 463 
  if ((int)test_bit((long)vid,(unsigned long *)(& adapter->active_vlans)) != 0) 
    #line 465 
    ixgbe_update_pf_promisc_vlvf(adapter,(unsigned int)vid);
  else 
    #line 463 
    if (((unsigned long)adapter->flags2 & 8192UL) != 0UL) 
                                                          #line 465 
                                                          ixgbe_update_pf_promisc_vlvf(adapter,(unsigned int)vid);
  #line 467 
  return err;
}

#line 470  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static s32 ixgbe_set_vf_lpe(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)
{
  #line 474 
  u32 max_frs;
  #line 472 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 473 
  int max_frame = (int)*(msgbuf + 1U);
  #line 483 
  if (adapter->hw.mac.type == (unsigned int)ixgbe_mac_82599EB) {
    #line 486 
    u32 reg_offset;
    #line 486 
    u32 vf_shift;
    #line 486 
    u32 vfre;
    #line 484 
    struct net_device *dev = adapter->netdev;
    #line 485 
    int pf_max_frame = (int)(dev->mtu + 14U);
    #line 487 
    s32 err = 0;
    #line 495 
    switch ((adapter->vfinfo + (unsigned long)vf)->vf_api) {
      #line 496 
      case (unsigned int)2: 
                            #line 496 
      ;
      #line 497 
      case (unsigned int)3: 
                            #line 497 
      ;
      #line 498 
      case (unsigned int)4: 
                            #line 498 
      ;
      #line 499 
      case (unsigned int)5: 
                            #line 499 
      ;
      #line 504 
      if (pf_max_frame > 1514) 
                               #line 505 
                               break;
      #line 507 
      default: 
               #line 507 
      ;
      #line 512 
      if (pf_max_frame > 1514 || max_frame > 1518) 
                                                   #line 514 
                                                   err = -22;
      #line 515 
      break;
    }
    #line 519 
    vf_shift = vf & 31U;
    #line 520 
    reg_offset = vf / 32U;
    #line 523 
    vfre = ixgbe_read_reg(hw,(reg_offset + 5240U) * 4U);
    #line 524 
    if (err != 0) 
                  #line 525 
                  vfre = ~ ((unsigned int)(1UL << vf_shift)) & vfre; else 
                                                                    #line 527 
                                                                    vfre = (unsigned int)(1UL << vf_shift) | vfre;
    #line 528 
    ixgbe_write_reg_13(hw,(reg_offset + 5240U) * 4U,vfre);
    #line 530 
    if (err != 0) {
      #line 531 
      if (((int)adapter->msg_enable & 1) != 0) 
                                               #line 531 
                                               netdev_err(adapter->netdev,(char *)"VF max_frame %d out of range\n",max_frame);
      #line 532 
      return err;
    }
  }
  #line 537 
  if (max_frame > 9728) {
    #line 538 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 538 
                                             netdev_err(adapter->netdev,(char *)"VF max_frame %d out of range\n",max_frame);
    #line 539 
    return -22;
  }
  #line 543 
  max_frs = ixgbe_read_reg(hw,17000U);
  #line 544 
  max_frs &= 4294901760U;
  #line 545 
  max_frs >>= 16;
  #line 547 
  if (max_frs < (unsigned int)max_frame) {
    #line 548 
    max_frs = (unsigned int)(max_frame << 16);
    #line 549 
    ixgbe_write_reg_13(hw,17000U,max_frs);
  }
  #line 552 
  if (((int)adapter->msg_enable & 8192) != 0) 
                                              #line 552 
                                              netdev_info(adapter->netdev,(char *)"VF requests change max MTU to %d\n",max_frame);
  #line 554 
  return 0;
}

#line 557  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static void ixgbe_set_vmolr(struct ixgbe_hw *hw, u32 vf, bool aupe)
{
  #line 559 
  u32 vmolr = ixgbe_read_reg(hw,(vf + 15360U) * 4U);
  #line 560 
  vmolr |= 134217728U;
  #line 561 
  if ((int)aupe != 0) 
                      #line 562 
                      vmolr |= 16777216U; else 
                                               #line 564 
                                               vmolr &= 4278190079U;
  #line 565 
  ixgbe_write_reg_13(hw,(vf + 15360U) * 4U,vmolr);
  #line 566 
  return;
}

#line 568  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static void ixgbe_clear_vmvir(struct ixgbe_adapter *adapter, u32 vf)
{
  #line 570 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 572 
  ixgbe_write_reg_13(hw,(vf + 8192U) * 4U,0U);
  #line 573 
  return;
}

#line 575  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static void ixgbe_clear_vf_vlans(struct ixgbe_adapter *adapter, u32 vf)
{
  #line 578 
  u32 vlvfb_mask;
  #line 578 
  u32 pool_mask;
  #line 578 
  u32 i;
  #line 577 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 581 
  pool_mask = ~ ((unsigned int)(1UL << ((int)adapter->ring_feature[1].offset & 31)));
  #line 582 
  vlvfb_mask = (unsigned int)(1UL << (vf & 31U));
  #line 585 
  i = 64U;
  #line 585 
  while (1) {
    #line 585 
    u32 tmp;
    #line 585 
    tmp = i;
    #line 585 
    i --;
    #line 585 
    ;
    #line 585 
    if (! (tmp != 0U)) 
                       #line 585 
                       break;
    {
      #line 586 
      u32 bits[2U];
      #line 586 
      u32 vlvfb;
      #line 586 
      u32 vid;
      #line 586 
      u32 vfta;
      #line 586 
      u32 vlvf;
      #line 588 
      u32 mask;
      #line 587 
      u32 word = i * 2U + vf / 32U;
      #line 590 
      vlvfb = ixgbe_read_reg(hw,(word + 15488U) * 4U);
      #line 593 
      if ((vlvfb & vlvfb_mask) == 0U) 
                                      #line 594 
                                      goto __Cont;
      #line 597 
      vlvfb ^= vlvfb_mask;
      #line 600 
      bits[word & 1U] = vlvfb;
      #line 601 
      bits[(word & 1U) == 0U] = ixgbe_read_reg(hw,((word ^ 1U) + 15488U) * 4U);
      #line 604 
      if (bits[(int)adapter->ring_feature[1].offset / 32 ^ 1] != 0U || (bits[(int)adapter->ring_feature[1].offset / 32] & pool_mask) != 0U) 
        #line 606 
        goto update_vlvfb;
      #line 609 
      if (bits[0] != 0U || bits[1] != 0U) 
                                          #line 610 
                                          goto update_vlvf;
      #line 613 
      vlvf = ixgbe_read_reg(hw,(i + 15424U) * 4U);
      #line 614 
      if (vlvf == 0U) 
                      #line 615 
                      goto update_vlvfb;
      #line 617 
      vid = vlvf & 4095U;
      #line 618 
      mask = (unsigned int)(1UL << (vid & 31U));
      #line 621 
      vfta = ixgbe_read_reg(hw,(vid / 32U + 10240U) * 4U);
      #line 622 
      if ((vfta & mask) != 0U) 
                               #line 623 
                               ixgbe_write_reg_13(hw,(vid / 32U + 10240U) * 4U,vfta ^ mask);
      #line 624 
      update_vlvf: 
                   #line 624 
      ;
      #line 626 
      ixgbe_write_reg_13(hw,(i + 15424U) * 4U,0U);
      #line 628 
      if (((unsigned long)adapter->flags2 & 8192UL) == 0UL) 
                                                            #line 629 
                                                            vlvfb = 0U;
      #line 630 
      update_vlvfb: 
                    #line 630 
      ;
      #line 632 
      ixgbe_write_reg_13(hw,(word + 15488U) * 4U,vlvfb);
    }
    #line 585 
    __Cont: 
            #line 585 
    ;
  }
  #line 634 
  return;
}

#line 636  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_set_vf_macvlan(struct ixgbe_adapter *adapter, int vf, int index, unsigned char *mac_addr)
{
  #line 639 
  struct vf_macvlans *entry;
  #line 640 
  struct list_head *pos;
  #line 641 
  int retval = 0;
  #line 643 
  if (index <= 1) {
    #line 644 
    pos = adapter->vf_mvs.l.next;
    #line 644 
    while (& adapter->vf_mvs.l != pos) {
      {
        #line 645 
        void *__mptr;
        #line 645 
        __mptr = (void *)pos;
        #line 645 
        entry = ((struct vf_macvlans *)__mptr);
        #line 646 
        if (entry->vf == vf) {
          #line 647 
          entry->vf = -1;
          #line 648 
          entry->free = (_Bool)1;
          #line 649 
          entry->is_macvlan = (_Bool)0;
          #line 650 
          ixgbe_del_mac_filter(adapter,(u8 *)(& entry->vf_macvlan),(unsigned short)((int)((unsigned short)vf)));
        }
      }
      #line 644 
      pos = pos->next;
    }
  }
  #line 660 
  if (index == 0) 
                  #line 661 
                  return 0;
  #line 663 
  entry = (struct vf_macvlans *)0;
  #line 665 
  pos = adapter->vf_mvs.l.next;
  #line 665 
  while (& adapter->vf_mvs.l != pos) {
    {
      #line 666 
      void *__mptr_0;
      #line 666 
      __mptr_0 = (void *)pos;
      #line 666 
      entry = ((struct vf_macvlans *)__mptr_0);
      #line 667 
      if ((int)entry->free != 0) 
                                 #line 668 
                                 break;
    }
    #line 665 
    pos = pos->next;
  }
  #line 679 
  if (entry == (struct vf_macvlans *)0 || ! entry->free) 
                                                         #line 680 
                                                         return -28;
  #line 682 
  retval = ixgbe_add_mac_filter(adapter,mac_addr,(unsigned short)((int)((unsigned short)vf)));
  #line 683 
  if (retval < 0) 
                  #line 684 
                  return retval;
  #line 686 
  entry->free = (_Bool)0;
  #line 687 
  entry->is_macvlan = (_Bool)1;
  #line 688 
  entry->vf = vf;
  #line 689 
  memcpy((void *)(& entry->vf_macvlan),(void *)mac_addr,6UL);
  #line 691 
  return 0;
}

#line 694  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
__inline static void ixgbe_vf_reset_event(struct ixgbe_adapter *adapter, u32 vf)
{
  #line 701 
  u32 reg_val;
  #line 702 
  u32 queue;
  #line 696 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 697 
  struct ixgbe_ring_feature *vmdq = & adapter->ring_feature[1];
  #line 698 
  struct vf_data_storage *vfinfo = adapter->vfinfo + (unsigned long)vf;
  #line 699 
  u32 q_per_pool = (unsigned int)(- ((int)vmdq->mask) & (int)vmdq->mask);
  #line 700 
  u8 num_tcs = adapter->hw_tcs;
  #line 705 
  ixgbe_clear_vf_vlans(adapter,vf);
  #line 708 
  ixgbe_set_vf_vlan(adapter,1,(int)vfinfo->pf_vlan,vf);
  #line 711 
  ixgbe_set_vmolr(hw,vf,(_Bool)((unsigned int)vfinfo->pf_vlan == 0U));
  #line 714 
  if (((unsigned int)vfinfo->pf_vlan == 0U && (unsigned int)vfinfo->pf_qos == 0U) && (unsigned int)num_tcs == 0U) 
    #line 715 
    ixgbe_clear_vmvir(adapter,vf);
  else {
    #line 717 
    if ((unsigned int)vfinfo->pf_qos != 0U || (unsigned int)num_tcs == 0U) 
      #line 718 
      ixgbe_set_vmvir(adapter,(unsigned short)((int)vfinfo->pf_vlan),(unsigned short)((int)vfinfo->pf_qos),vf); else 
                                                                    #line 721 
                                                                    ixgbe_set_vmvir(adapter,(unsigned short)((int)vfinfo->pf_vlan),(unsigned short)((int)adapter->default_up),vf);
    #line 724 
    if ((unsigned int)vfinfo->spoofchk_enabled != 0U) {
      #line 725 
      (*(hw->mac.ops.set_vlan_anti_spoofing))(hw,(_Bool)1,(int)vf);
      #line 726 
      (*(hw->mac.ops.set_mac_anti_spoofing))(hw,(_Bool)1,(int)vf);
    }
  }
  #line 731 
  (adapter->vfinfo + (unsigned long)vf)->num_vf_mc_hashes = (unsigned short)0U;
  #line 734 
  ixgbe_ipsec_vf_clear(adapter,vf);
  #line 737 
  ixgbe_set_rx_mode(adapter->netdev);
  #line 739 
  ixgbe_del_mac_filter(adapter,(u8 *)(& (adapter->vfinfo + (unsigned long)vf)->vf_mac_addresses),(unsigned short)((int)((unsigned short)vf)));
  #line 740 
  ixgbe_set_vf_macvlan(adapter,(int)vf,0,(unsigned char *)0U);
  #line 743 
  (adapter->vfinfo + (unsigned long)vf)->vf_api = 0U;
  #line 746 
  queue = 0U;
  #line 746 
  while (queue < q_per_pool) {
    {
      #line 747 
      unsigned int reg_idx = vf * q_per_pool + queue;
      #line 749 
      reg_val = ixgbe_read_reg(hw,reg_idx * 64U + 24616U);
      #line 752 
      if (reg_val != 0U) {
        #line 753 
        reg_val |= 33554432U;
        #line 754 
        ixgbe_write_reg_13(hw,reg_idx * 64U + 24616U,reg_val);
        #line 755 
        reg_val &= 4261412863U;
        #line 756 
        ixgbe_write_reg_13(hw,reg_idx * 64U + 24616U,reg_val);
      }
    }
    #line 746 
    queue ++;
  }
  #line 760 
  ixgbe_read_reg(hw,8U);
  #line 761 
  return;
}

#line 763  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static void ixgbe_vf_clear_mbx(struct ixgbe_adapter *adapter, u32 vf)
{
  #line 766 
  u32 word;
  #line 765 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 769 
  word = 0U;
  #line 769 
  while (word <= 15U) {
    #line 770 
    ixgbe_write_reg_13(hw,(vf + 1216U) * 64U + (word << 2),0U);
    #line 769 
    word ++;
  }
  #line 772 
  ixgbe_read_reg(hw,8U);
  #line 773 
  return;
}

#line 775  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_set_vf_mac(struct ixgbe_adapter *adapter, int vf, unsigned char *mac_addr)
{
  #line 778 
  s32 retval;
  #line 780 
  ixgbe_del_mac_filter(adapter,(u8 *)(& (adapter->vfinfo + (unsigned long)vf)->vf_mac_addresses),(unsigned short)((int)((unsigned short)vf)));
  #line 781 
  retval = ixgbe_add_mac_filter(adapter,mac_addr,(unsigned short)((int)((unsigned short)vf)));
  #line 782 
  if (retval >= 0) 
                   #line 783 
                   memcpy((void *)(& (adapter->vfinfo + (unsigned long)vf)->vf_mac_addresses),(void *)mac_addr,6UL); else 
                                                                    #line 786 
                                                                    memset((void *)(& (adapter->vfinfo + (unsigned long)vf)->vf_mac_addresses),0,6UL);
  #line 788 
  return retval;
}

#line 791  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_vf_configuration(struct pci_dev *pdev, unsigned int event_mask)
{
  #line 793 
  struct ixgbe_adapter *adapter = pci_get_drvdata(pdev);
  #line 794 
  unsigned int vfn = event_mask & 63U;
  #line 796 
  bool enable = (_Bool)((event_mask & 268435456U) != 0U);
  #line 798 
  if ((int)enable != 0) 
                        #line 799 
                        eth_zero_addr((u8 *)(& (adapter->vfinfo + (unsigned long)vfn)->vf_mac_addresses));
  #line 801 
  return 0;
}

#line 804  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
__inline static void ixgbe_write_qde(struct ixgbe_adapter *adapter, u32 vf, u32 qde)
{
  #line 810 
  int i;
  #line 807 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 808 
  struct ixgbe_ring_feature *vmdq = & adapter->ring_feature[1];
  #line 809 
  u32 q_per_pool = (unsigned int)(- ((int)vmdq->mask) & (int)vmdq->mask);
  #line 812 
  i = (int)(vf * q_per_pool);
  #line 812 
  while ((vf + 1U) * q_per_pool > (unsigned int)i) {
    {
      #line 813 
      u32 reg;
      #line 816 
      ixgbe_read_reg(hw,8U);
      #line 819 
      reg = qde | 65536U;
      #line 820 
      reg = (unsigned int)(i << 8) | reg;
      #line 821 
      ixgbe_write_reg_13(hw,12036U,reg);
    }
    #line 812 
    i ++;
  }
  #line 823 
  return;
}

#line 825  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_vf_reset_msg(struct ixgbe_adapter *adapter, u32 vf)
{
  #line 830 
  u32 reg;
  #line 830 
  u32 reg_offset;
  #line 830 
  u32 vf_shift;
  #line 834 
  int i;
  #line 827 
  struct ixgbe_ring_feature *vmdq = & adapter->ring_feature[1];
  #line 828 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 829 
  unsigned char *vf_mac = (unsigned char *)(& (adapter->vfinfo + (unsigned long)vf)->vf_mac_addresses);
  #line 831 
  u32 msgbuf[4U] = {0U, 0U, 0U, 0U};
  #line 832 
  u8 *addr = (u8 *)(& msgbuf[1]);
  #line 833 
  u32 q_per_pool = (unsigned int)(- ((int)vmdq->mask) & (int)vmdq->mask);
  #line 836 
  if (((int)adapter->msg_enable & 2) != 0) 
                                           #line 836 
                                           netdev_info(adapter->netdev,(char *)"VF Reset msg received from vf %d\n",vf);
  #line 839 
  ixgbe_vf_reset_event(adapter,vf);
  #line 841 
  ixgbe_vf_clear_mbx(adapter,vf);
  #line 844 
  if (! is_zero_ether_addr(vf_mac)) 
                                    #line 845 
                                    ixgbe_set_vf_mac(adapter,(int)vf,vf_mac);
  #line 847 
  vf_shift = vf & 31U;
  #line 848 
  reg_offset = vf / 32U;
  #line 851 
  reg = ixgbe_read_reg(hw,(reg_offset + 8260U) * 4U);
  #line 852 
  reg = (unsigned int)(1UL << vf_shift) | reg;
  #line 853 
  ixgbe_write_reg_13(hw,(reg_offset + 8260U) * 4U,reg);
  #line 856 
  reg = 1U;
  #line 857 
  if ((unsigned int)(adapter->vfinfo + (unsigned long)vf)->pf_vlan != 0U) 
    #line 858 
    reg |= 2U;
  #line 860 
  ixgbe_write_qde(adapter,vf,reg);
  #line 863 
  reg = ixgbe_read_reg(hw,(reg_offset + 5240U) * 4U);
  #line 864 
  reg = (unsigned int)(1UL << vf_shift) | reg;
  #line 869 
  if (adapter->hw.mac.type == (unsigned int)ixgbe_mac_82599EB) {
    #line 870 
    struct net_device *dev = adapter->netdev;
    #line 871 
    int pf_max_frame = (int)(dev->mtu + 14U);
    #line 879 
    if (pf_max_frame > 1514) 
                             #line 880 
                             reg = ~ ((unsigned int)(1UL << vf_shift)) & reg;
  }
  #line 882 
  ixgbe_write_reg_13(hw,(reg_offset + 5240U) * 4U,reg);
  #line 885 
  (adapter->vfinfo + (unsigned long)vf)->clear_to_send = (_Bool)1;
  #line 888 
  reg = ixgbe_read_reg(hw,(reg_offset + 8676U) * 4U);
  #line 889 
  reg = (unsigned int)(1UL << vf_shift) | reg;
  #line 890 
  ixgbe_write_reg_13(hw,(reg_offset + 8676U) * 4U,reg);
  #line 896 
  i = 0;
  #line 896 
  while ((unsigned int)i < q_per_pool) {
    #line 897 
    ixgbe_write_reg_13(hw,(q_per_pool * vf + (unsigned int)i) * 64U + 24636U,0U);
    #line 898 
    ixgbe_write_reg_13(hw,(q_per_pool * vf + (unsigned int)i) * 64U + 24632U,0U);
    #line 896 
    i ++;
  }
  #line 902 
  msgbuf[0] = 1U;
  #line 903 
  if (is_zero_ether_addr(vf_mac)) 
                                  #line 907 
                                  msgbuf[0] |= 1073741824U;
  else 
    #line 903 
    if ((int)(adapter->vfinfo + (unsigned long)vf)->pf_set_mac != 0) {
      #line 904 
      msgbuf[0] |= 2147483648U;
      #line 905 
      memcpy((void *)addr,(void *)vf_mac,6UL);
    }
    else 
         #line 907 
         msgbuf[0] |= 1073741824U;
  #line 914 
  msgbuf[3] = (unsigned int)hw->mac.mc_filter_type;
  #line 915 
  ixgbe_write_mbx(hw,(u32 *)(& msgbuf),(unsigned short)4,(unsigned short)((int)((unsigned short)vf)));
  #line 917 
  return 0;
}

#line 920  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_set_vf_mac_addr(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)
{
  #line 923 
  u8 *new_mac = (u8 *)(msgbuf + 1U);
  #line 925 
  if (! is_valid_ether_addr(new_mac)) {
    #line 926 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 926 
                                             netdev_warn(adapter->netdev,(char *)"VF %d attempted to set invalid mac\n",vf);
    #line 927 
    return -1;
  }
  #line 930 
  if ((int)(adapter->vfinfo + (unsigned long)vf)->pf_set_mac != 0 && (unsigned int)(adapter->vfinfo + (unsigned long)vf)->trusted == 0U) {
    #line 931 
    if (! ether_addr_equal((u8 *)(& (adapter->vfinfo + (unsigned long)vf)->vf_mac_addresses),
                         new_mac)) {
      #line 932 
      if (((int)adapter->msg_enable & 1) != 0) 
                                               #line 932 
                                               netdev_warn(adapter->netdev,(char *)"VF %d attempted to override administratively set MAC address\n",vf);
      #line 936 
      return -1;
    }
  }
  #line 939 
  return ixgbe_set_vf_mac(adapter,(int)vf,new_mac) < 0;
}

#line 942  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_set_vf_vlan_msg(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)
{
  #line 945 
  u32 add = (*msgbuf >> 16) & 255U;
  #line 946 
  u32 vid = *(msgbuf + 1U) & 4095U;
  #line 947 
  u8 tcs = adapter->hw_tcs;
  #line 949 
  if ((unsigned int)(adapter->vfinfo + (unsigned long)vf)->pf_vlan != 0U || (unsigned int)tcs != 0U) {
    #line 950 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 950 
                                             netdev_warn(adapter->netdev,(char *)"VF %d attempted to override administratively set VLAN configuration\n",vf);
    #line 954 
    return -1;
  }
  #line 958 
  if (vid == 0U && add == 0U) 
                              #line 959 
                              return 0;
  #line 961 
  return ixgbe_set_vf_vlan(adapter,(int)add,(int)vid,vf);
}

#line 964  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_set_vf_macvlan_msg(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)
{
  #line 970 
  int err;
  #line 967 
  u8 *new_mac = (u8 *)(msgbuf + 1U);
  #line 968 
  int index = (int)(*msgbuf >> 16) & 255;
  #line 972 
  if (((int)(adapter->vfinfo + (unsigned long)vf)->pf_set_mac != 0 && (unsigned int)(adapter->vfinfo + (unsigned long)vf)->trusted == 0U) && index > 0) {
    #line 974 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 974 
                                             netdev_warn(adapter->netdev,(char *)"VF %d requested MACVLAN filter but is administratively denied\n",vf);
    #line 977 
    return -1;
  }
  #line 981 
  if (index != 0) {
    #line 982 
    if (! is_valid_ether_addr(new_mac)) {
      #line 983 
      if (((int)adapter->msg_enable & 1) != 0) 
                                               #line 983 
                                               netdev_warn(adapter->netdev,(char *)"VF %d attempted to set invalid mac\n",vf);
      #line 984 
      return -1;
    }
    #line 991 
    if ((unsigned int)(adapter->vfinfo + (unsigned long)vf)->spoofchk_enabled != 0U) {
      #line 992 
      struct ixgbe_hw *hw = & adapter->hw;
      #line 994 
      (*(hw->mac.ops.set_mac_anti_spoofing))(hw,(_Bool)0,(int)vf);
      #line 995 
      (*(hw->mac.ops.set_vlan_anti_spoofing))(hw,(_Bool)0,(int)vf);
    }
  }
  #line 999 
  err = ixgbe_set_vf_macvlan(adapter,(int)vf,index,new_mac);
  #line 1000 
  if (err == -28) 
    #line 1001 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 1001 
                                             netdev_warn(adapter->netdev,(char *)"VF %d has requested a MACVLAN filter but there is no space for it\n",vf);
  #line 1005 
  return err < 0;
}

#line 1008  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_negotiate_vf_api(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)
{
  #line 1011 
  int api = (int)*(msgbuf + 1U);
  #line 1013 
  switch (api) {
    #line 1014 
    case 0: 
            #line 1014 
    ;
    #line 1015 
    case 2: 
            #line 1015 
    ;
    #line 1016 
    case 3: 
            #line 1016 
    ;
    #line 1017 
    case 4: 
            #line 1017 
    ;
    #line 1018 
    case 5: 
            #line 1018 
    ;
    #line 1019 
    (adapter->vfinfo + (unsigned long)vf)->vf_api = (unsigned int)api;
    #line 1020 
    return 0;
    #line 1021 
    default: 
             #line 1021 
    ;
    #line 1022 
    break;
  }
  #line 1025 
  if (((int)adapter->msg_enable & 1) != 0) 
                                           #line 1025 
                                           netdev_info(adapter->netdev,(char *)"VF %d requested invalid api version %u\n",vf,api);
  #line 1027 
  return -1;
}

#line 1030  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_get_vf_queues(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)
{
  #line 1033 
  struct net_device *dev = adapter->netdev;
  #line 1034 
  struct ixgbe_ring_feature *vmdq = & adapter->ring_feature[1];
  #line 1035 
  unsigned int default_tc = 0U;
  #line 1036 
  u8 num_tcs = adapter->hw_tcs;
  #line 1039 
  switch ((adapter->vfinfo + (unsigned long)vf)->vf_api) {
    #line 1040 
    case (unsigned int)1: 
                          #line 1040 
    ;
    #line 1041 
    case (unsigned int)2: 
                          #line 1041 
    ;
    #line 1042 
    case (unsigned int)3: 
                          #line 1042 
    ;
    #line 1043 
    case (unsigned int)4: 
                          #line 1043 
    ;
    #line 1044 
    case (unsigned int)5: 
                          #line 1044 
    ;
    #line 1045 
    break;
    #line 1046 
    default: 
             #line 1046 
    ;
    #line 1047 
    return -1;
  }
  #line 1051 
  *(msgbuf + 1U) = (unsigned int)(- ((int)vmdq->mask) & (int)vmdq->mask);
  #line 1052 
  *(msgbuf + 2U) = (unsigned int)(- ((int)vmdq->mask) & (int)vmdq->mask);
  #line 1055 
  if ((unsigned int)num_tcs > 1U) {
    #line 1056 
    default_tc = (unsigned int)netdev_get_prio_tc_map(dev,(unsigned int)adapter->default_up);
  }
  #line 1059 
  if ((unsigned int)num_tcs != 0U) 
                                   #line 1060 
                                   *(msgbuf + 3U) = (unsigned int)num_tcs;
  else 
    #line 1061 
    if ((unsigned int)(adapter->vfinfo + (unsigned long)vf)->pf_vlan != 0U || (unsigned int)(adapter->vfinfo + (unsigned long)vf)->pf_qos != 0U) 
      #line 1062 
      *(msgbuf + 3U) = 1U; else 
                                #line 1064 
                                *(msgbuf + 3U) = 0U;
  #line 1067 
  *(msgbuf + 4U) = default_tc;
  #line 1069 
  return 0;
}

#line 1072  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_get_vf_reta(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)
{
  #line 1074 
  u32 i;
  #line 1074 
  u32 j;
  #line 1075 
  u32 *out_buf = msgbuf + 1U;
  #line 1076 
  u8 *reta = (u8 *)(& adapter->rss_indir_tbl);
  #line 1077 
  u32 reta_size = ixgbe_rss_indir_tbl_entries(adapter);
  #line 1080 
  if (! (adapter->vfinfo + (unsigned long)vf)->rss_query_enabled) 
                                                                  #line 1081 
                                                                  return -1;
  #line 1084 
  switch ((adapter->vfinfo + (unsigned long)vf)->vf_api) {
    #line 1085 
    case (unsigned int)5: 
                          #line 1085 
    ;
    #line 1086 
    case (unsigned int)4: 
                          #line 1086 
    ;
    #line 1087 
    case (unsigned int)3: 
                          #line 1087 
    ;
    #line 1088 
    break;
    #line 1089 
    default: 
             #line 1089 
    ;
    #line 1090 
    return -95;
  }
  #line 1098 
  i = 0U;
  #line 1098 
  while (reta_size / 16U > i) {
    #line 1099 
    *(out_buf + (unsigned long)i) = 0U;
    #line 1100 
    j = 0U;
    #line 1100 
    while (j <= 15U) {
      #line 1101 
      *(out_buf + (unsigned long)i) |= ((unsigned int)*(reta + (unsigned long)(i * 16U + j)) & 3U) << j * 2U;
      #line 1100 
      j ++;
    }
    #line 1098 
    i ++;
  }
  #line 1104 
  return 0;
}

#line 1107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_get_vf_rss_key(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)
{
  #line 1110 
  u32 *rss_key = msgbuf + 1U;
  #line 1113 
  if (! (adapter->vfinfo + (unsigned long)vf)->rss_query_enabled) 
                                                                  #line 1114 
                                                                  return -1;
  #line 1117 
  switch ((adapter->vfinfo + (unsigned long)vf)->vf_api) {
    #line 1118 
    case (unsigned int)5: 
                          #line 1118 
    ;
    #line 1119 
    case (unsigned int)4: 
                          #line 1119 
    ;
    #line 1120 
    case (unsigned int)3: 
                          #line 1120 
    ;
    #line 1121 
    break;
    #line 1122 
    default: 
             #line 1122 
    ;
    #line 1123 
    return -95;
  }
  #line 1126 
  memcpy((void *)rss_key,(void *)adapter->rss_key,40UL);
  #line 1128 
  return 0;
}

#line 1131  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_update_vf_xcast_mode(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)
{
  #line 1136 
  u32 vmolr;
  #line 1136 
  u32 fctrl;
  #line 1136 
  u32 disable;
  #line 1136 
  u32 enable;
  #line 1134 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 1135 
  int xcast_mode = (int)*(msgbuf + 1U);
  #line 1139 
  switch ((adapter->vfinfo + (unsigned long)vf)->vf_api) {
    #line 1140 
    case (unsigned int)3: 
                          #line 1140 
    ;
    #line 1142 
    if (xcast_mode == 3) 
                         #line 1143 
                         return -95;
    #line 1145 
    case (unsigned int)4: 
                          #line 1145 
    ;
    #line 1146 
    case (unsigned int)5: 
                          #line 1146 
    ;
    #line 1147 
    break;
    #line 1148 
    default: 
             #line 1148 
    ;
    #line 1149 
    return -95;
  }
  #line 1152 
  if (xcast_mode > 1 && (unsigned int)(adapter->vfinfo + (unsigned long)vf)->trusted == 0U) 
    #line 1154 
    xcast_mode = 1;
  #line 1157 
  if ((adapter->vfinfo + (unsigned long)vf)->xcast_mode == xcast_mode) 
    #line 1158 
    goto out;
  #line 1160 
  switch (xcast_mode) {
    #line 1161 
    case 0: 
            #line 1161 
    ;
    #line 1162 
    disable = 448790528U;
    #line 1164 
    enable = 0U;
    #line 1165 
    break;
    #line 1166 
    case 1: 
            #line 1166 
    ;
    #line 1167 
    disable = 281018368U;
    #line 1168 
    enable = 167772160U;
    #line 1169 
    break;
    #line 1170 
    case 2: 
            #line 1170 
    ;
    #line 1171 
    disable = 12582912U;
    #line 1172 
    enable = 436207616U;
    #line 1173 
    break;
    #line 1174 
    case 3: 
            #line 1174 
    ;
    #line 1175 
    if (hw->mac.type <= (unsigned int)ixgbe_mac_82599EB) 
                                                         #line 1176 
                                                         return -95;
    #line 1178 
    fctrl = ixgbe_read_reg(hw,20608U);
    #line 1179 
    if ((fctrl & 512U) == 0U) {
      #line 1181 
      if (((int)adapter->msg_enable & 1) != 0) 
                                               #line 1181 
                                               netdev_warn(adapter->netdev,(char *)"Enabling VF promisc requires PF in promisc\n");
      #line 1183 
      return -1;
    }
    #line 1186 
    disable = 0U;
    #line 1187 
    enable = 448790528U;
    #line 1189 
    break;
    #line 1190 
    default: 
             #line 1190 
    ;
    #line 1191 
    return -95;
  }
  #line 1194 
  vmolr = ixgbe_read_reg(hw,(vf + 15360U) * 4U);
  #line 1195 
  vmolr = ~ disable & vmolr;
  #line 1196 
  vmolr |= enable;
  #line 1197 
  ixgbe_write_reg_13(hw,(vf + 15360U) * 4U,vmolr);
  #line 1199 
  (adapter->vfinfo + (unsigned long)vf)->xcast_mode = xcast_mode;
  #line 1201 
  out: 
       #line 1201 
  ;
  #line 1202 
  *(msgbuf + 1U) = (unsigned int)xcast_mode;
  #line 1204 
  return 0;
}

#line 1207  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_rcv_msg_from_vf(struct ixgbe_adapter *adapter, u32 vf)
{
  #line 1210 
  u32 msgbuf[16U];
  #line 1212 
  s32 retval;
  #line 1209 
  u32 mbx_size = 16U;
  #line 1211 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 1214 
  retval = ixgbe_read_mbx(hw,(u32 *)(& msgbuf),(unsigned short)((int)((unsigned short)mbx_size)),(unsigned short)((int)((unsigned short)vf)));
  #line 1216 
  if (retval != 0) {
    #line 1217 
    printk((char *)"\001");
    #line 1218 
    return retval;
  }
  #line 1222 
  if ((msgbuf[0] & 3221225472U) != 0U) 
                                       #line 1223 
                                       return 0;
  #line 1226 
  ixgbe_read_reg(hw,8U);
  #line 1228 
  if (msgbuf[0] == 1U) {
    #line 1229 
    return ixgbe_vf_reset_msg(adapter,vf);
  }
  #line 1235 
  if (! (adapter->vfinfo + (unsigned long)vf)->clear_to_send) {
    #line 1236 
    msgbuf[0] |= 1073741824U;
    #line 1237 
    ixgbe_write_mbx(hw,(u32 *)(& msgbuf),(unsigned short)1,(unsigned short)((int)((unsigned short)vf)));
    #line 1238 
    return 0;
  }
  #line 1241 
  switch (msgbuf[0] & 65535U) {
    #line 1242 
    case (unsigned int)2: 
                          #line 1242 
    ;
    #line 1243 
    retval = ixgbe_set_vf_mac_addr(adapter,(u32 *)(& msgbuf),vf);
    #line 1244 
    break;
    #line 1245 
    case (unsigned int)3: 
                          #line 1245 
    ;
    #line 1246 
    retval = ixgbe_set_vf_multicasts(adapter,(u32 *)(& msgbuf),vf);
    #line 1247 
    break;
    #line 1248 
    case (unsigned int)4: 
                          #line 1248 
    ;
    #line 1249 
    retval = ixgbe_set_vf_vlan_msg(adapter,(u32 *)(& msgbuf),vf);
    #line 1250 
    break;
    #line 1251 
    case (unsigned int)5: 
                          #line 1251 
    ;
    #line 1252 
    retval = ixgbe_set_vf_lpe(adapter,(u32 *)(& msgbuf),vf);
    #line 1253 
    break;
    #line 1254 
    case (unsigned int)6: 
                          #line 1254 
    ;
    #line 1255 
    retval = ixgbe_set_vf_macvlan_msg(adapter,(u32 *)(& msgbuf),vf);
    #line 1256 
    break;
    #line 1257 
    case (unsigned int)8: 
                          #line 1257 
    ;
    #line 1258 
    retval = ixgbe_negotiate_vf_api(adapter,(u32 *)(& msgbuf),vf);
    #line 1259 
    break;
    #line 1260 
    case (unsigned int)9: 
                          #line 1260 
    ;
    #line 1261 
    retval = ixgbe_get_vf_queues(adapter,(u32 *)(& msgbuf),vf);
    #line 1262 
    break;
    #line 1263 
    case (unsigned int)10: 
                           #line 1263 
    ;
    #line 1264 
    retval = ixgbe_get_vf_reta(adapter,(u32 *)(& msgbuf),vf);
    #line 1265 
    break;
    #line 1266 
    case (unsigned int)11: 
                           #line 1266 
    ;
    #line 1267 
    retval = ixgbe_get_vf_rss_key(adapter,(u32 *)(& msgbuf),vf);
    #line 1268 
    break;
    #line 1269 
    case (unsigned int)12: 
                           #line 1269 
    ;
    #line 1270 
    retval = ixgbe_update_vf_xcast_mode(adapter,(u32 *)(& msgbuf),vf);
    #line 1271 
    break;
    #line 1272 
    case (unsigned int)13: 
                           #line 1272 
    ;
    #line 1273 
    retval = ixgbe_ipsec_vf_add_sa(adapter,(u32 *)(& msgbuf),vf);
    #line 1274 
    break;
    #line 1275 
    case (unsigned int)14: 
                           #line 1275 
    ;
    #line 1276 
    retval = ixgbe_ipsec_vf_del_sa(adapter,(u32 *)(& msgbuf),vf);
    #line 1277 
    break;
    #line 1278 
    default: 
             #line 1278 
    ;
    #line 1279 
    if (((int)adapter->msg_enable & 1) != 0) 
                                             #line 1279 
                                             netdev_err(adapter->netdev,(char *)"Unhandled Msg %8.8x\n",msgbuf[0]);
    #line 1280 
    retval = -100;
    #line 1281 
    break;
  }
  #line 1285 
  if (retval != 0) 
                   #line 1286 
                   msgbuf[0] |= 1073741824U; else 
                                                  #line 1288 
                                                  msgbuf[0] |= 2147483648U;
  #line 1290 
  msgbuf[0] |= 536870912U;
  #line 1292 
  ixgbe_write_mbx(hw,(u32 *)(& msgbuf),(unsigned short)((int)((unsigned short)mbx_size)),(unsigned short)((int)((unsigned short)vf)));
  #line 1294 
  return retval;
}

#line 1297  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static void ixgbe_rcv_ack_from_vf(struct ixgbe_adapter *adapter, u32 vf)
{
  #line 1299 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 1300 
  u32 msg = 1073741824U;
  #line 1303 
  if (! (adapter->vfinfo + (unsigned long)vf)->clear_to_send) 
                                                              #line 1304 
                                                              ixgbe_write_mbx(hw,& msg,(unsigned short)1,(unsigned short)((int)((unsigned short)vf)));
  #line 1305 
  return;
}

#line 1307  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
void ixgbe_msg_task(struct ixgbe_adapter *adapter)
{
  #line 1310 
  u32 vf;
  #line 1309 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 1312 
  vf = 0U;
  #line 1312 
  while (adapter->num_vfs > vf) {
    {
      #line 1314 
      if (ixgbe_check_for_rst(hw,(unsigned short)((int)((unsigned short)vf))) == 0) 
        #line 1315 
        ixgbe_vf_reset_event(adapter,vf);
      #line 1318 
      if (ixgbe_check_for_msg(hw,(unsigned short)((int)((unsigned short)vf))) == 0) 
        #line 1319 
        ixgbe_rcv_msg_from_vf(adapter,vf);
      #line 1322 
      if (ixgbe_check_for_ack(hw,(unsigned short)((int)((unsigned short)vf))) == 0) 
        #line 1323 
        ixgbe_rcv_ack_from_vf(adapter,vf);
    }
    #line 1312 
    vf ++;
  }
  #line 1325 
  return;
}

#line 1327  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
void ixgbe_disable_tx_rx(struct ixgbe_adapter *adapter)
{
  #line 1329 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 1332 
  ixgbe_write_reg_13(hw,33040U,0U);
  #line 1333 
  ixgbe_write_reg_13(hw,33044U,0U);
  #line 1335 
  ixgbe_write_reg_13(hw,20960U,0U);
  #line 1336 
  ixgbe_write_reg_13(hw,20964U,0U);
  #line 1337 
  return;
}

#line 1339  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
__inline static void ixgbe_ping_vf(struct ixgbe_adapter *adapter, int vf)
{
  #line 1342 
  u32 ping;
  #line 1341 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 1344 
  ping = 256U;
  #line 1345 
  if ((int)(adapter->vfinfo + (unsigned long)vf)->clear_to_send != 0) 
    #line 1346 
    ping |= 536870912U;
  #line 1347 
  ixgbe_write_mbx(hw,& ping,(unsigned short)1,(unsigned short)((int)((unsigned short)vf)));
  #line 1348 
  return;
}

#line 1350  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
void ixgbe_ping_all_vfs(struct ixgbe_adapter *adapter)
{
  #line 1353 
  u32 ping;
  #line 1354 
  int i;
  #line 1352 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 1356 
  i = 0;
  #line 1356 
  while (adapter->num_vfs > (unsigned int)i) {
    #line 1357 
    ping = 256U;
    #line 1358 
    if ((int)(adapter->vfinfo + (unsigned long)i)->clear_to_send != 0) 
      #line 1359 
      ping |= 536870912U;
    #line 1360 
    ixgbe_write_mbx(hw,& ping,(unsigned short)1,(unsigned short)((int)((unsigned short)i)));
    #line 1356 
    i ++;
  }
  #line 1362 
  return;
}

#line 1364  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_ndo_set_vf_mac(struct net_device *netdev, int vf, u8 *mac)
{
  #line 1367 
  s32 retval;
  #line 1366 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 1369 
  if (adapter->num_vfs <= (unsigned int)vf) 
                                            #line 1370 
                                            return -22;
  #line 1372 
  if ((int)is_valid_ether_addr(mac) != 0) {
    #line 1373 
    _dev_info(& (adapter->pdev)->dev,(char *)"setting MAC %pM on VF %d\n",mac,vf);
    #line 1375 
    _dev_info(& (adapter->pdev)->dev,(char *)"Reload the VF driver to make this change effective.");
    #line 1377 
    retval = ixgbe_set_vf_mac(adapter,vf,mac);
    #line 1378 
    if (retval >= 0) {
      #line 1379 
      (adapter->vfinfo + (unsigned long)vf)->pf_set_mac = (_Bool)1;
      #line 1381 
      if ((int)test_bit(2L,& adapter->state) != 0) {
        #line 1382 
        _dev_warn(& (adapter->pdev)->dev,(char *)"The VF MAC address has been set, but the PF device is not up.\n");
        #line 1383 
        _dev_warn(& (adapter->pdev)->dev,(char *)"Bring the PF device up before attempting to use the VF device.\n");
      }
    }
    else 
         #line 1386 
         _dev_warn(& (adapter->pdev)->dev,(char *)"The VF MAC address was NOT set due to invalid or duplicate MAC address.\n");
  }
  else {
    #line 1388 
    if ((int)is_zero_ether_addr(mac) != 0) {
      #line 1389 
      unsigned char *vf_mac_addr = (unsigned char *)(& (adapter->vfinfo + (unsigned long)vf)->vf_mac_addresses);
      #line 1393 
      if ((int)is_zero_ether_addr(vf_mac_addr) != 0) 
                                                     #line 1394 
                                                     return 0;
      #line 1396 
      _dev_info(& (adapter->pdev)->dev,(char *)"removing MAC on VF %d\n",vf);
      #line 1398 
      retval = ixgbe_del_mac_filter(adapter,vf_mac_addr,(unsigned short)((int)((unsigned short)vf)));
      #line 1399 
      if (retval >= 0) {
        #line 1400 
        (adapter->vfinfo + (unsigned long)vf)->pf_set_mac = (_Bool)0;
        #line 1401 
        memcpy((void *)vf_mac_addr,(void *)mac,6UL);
      }
      else 
           #line 1403 
           _dev_warn(& (adapter->pdev)->dev,(char *)"Could NOT remove the VF MAC address.\n");
    }
    else 
         #line 1406 
         retval = -22;
  }
  #line 1409 
  return retval;
}

#line 1412  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_enable_port_vlan(struct ixgbe_adapter *adapter, int vf, u16 vlan, u8 qos)
{
  #line 1416 
  int err;
  #line 1415 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 1418 
  err = ixgbe_set_vf_vlan(adapter,1,(int)vlan,(unsigned int)vf);
  #line 1419 
  if (err != 0) 
                #line 1420 
                goto out;
  #line 1423 
  ixgbe_set_vf_vlan(adapter,0,0,(unsigned int)vf);
  #line 1425 
  ixgbe_set_vmvir(adapter,(unsigned short)((int)vlan),(unsigned short)((int)qos),(unsigned int)vf);
  #line 1426 
  ixgbe_set_vmolr(hw,(unsigned int)vf,(_Bool)0);
  #line 1429 
  if (hw->mac.type > (unsigned int)ixgbe_mac_X540) 
                                                   #line 1430 
                                                   ixgbe_write_qde(adapter,(unsigned int)vf,3U);
  #line 1433 
  (adapter->vfinfo + (unsigned long)vf)->pf_vlan = vlan;
  #line 1434 
  (adapter->vfinfo + (unsigned long)vf)->pf_qos = (unsigned short)qos;
  #line 1435 
  _dev_info(& (adapter->pdev)->dev,(char *)"Setting VLAN %d, QOS 0x%x on VF %d\n",(int)vlan,(int)qos,vf);
  #line 1437 
  if ((int)test_bit(2L,& adapter->state) != 0) {
    #line 1438 
    _dev_warn(& (adapter->pdev)->dev,(char *)"The VF VLAN has been set, but the PF device is not up.\n");
    #line 1440 
    _dev_warn(& (adapter->pdev)->dev,(char *)"Bring the PF device up before attempting to use the VF device.\n");
  }
  #line 1444 
  out: 
       #line 1444 
  ;
  #line 1445 
  return err;
}

#line 1448  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_disable_port_vlan(struct ixgbe_adapter *adapter, int vf)
{
  #line 1451 
  int err;
  #line 1450 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 1453 
  err = ixgbe_set_vf_vlan(adapter,0,(int)(adapter->vfinfo + (unsigned long)vf)->pf_vlan,(unsigned int)vf);
  #line 1456 
  ixgbe_set_vf_vlan(adapter,1,0,(unsigned int)vf);
  #line 1457 
  ixgbe_clear_vmvir(adapter,(unsigned int)vf);
  #line 1458 
  ixgbe_set_vmolr(hw,(unsigned int)vf,(_Bool)1);
  #line 1461 
  if (hw->mac.type > (unsigned int)ixgbe_mac_X540) 
                                                   #line 1462 
                                                   ixgbe_write_qde(adapter,(unsigned int)vf,1U);
  #line 1464 
  (adapter->vfinfo + (unsigned long)vf)->pf_vlan = (unsigned short)0U;
  #line 1465 
  (adapter->vfinfo + (unsigned long)vf)->pf_qos = (unsigned short)0U;
  #line 1467 
  return err;
}

#line 1470  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_ndo_set_vf_vlan(struct net_device *netdev, int vf, u16 vlan, u8 qos, __be16 vlan_proto)
{
  #line 1473 
  int err = 0;
  #line 1474 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 1476 
  if (adapter->num_vfs <= (unsigned int)vf || ((unsigned int)vlan > 4095U || (unsigned int)qos > 7U)) 
    #line 1477 
    return -22;
  #line 1478 
  if ((unsigned int)vlan_proto != 129U) 
                                        #line 1479 
                                        return -93;
  #line 1480 
  if ((unsigned int)vlan != 0U || (unsigned int)qos != 0U) {
    #line 1488 
    if ((unsigned int)(adapter->vfinfo + (unsigned long)vf)->pf_vlan != 0U) 
      #line 1489 
      err = ixgbe_disable_port_vlan(adapter,vf);
    #line 1490 
    if (err != 0) 
                  #line 1491 
                  goto out;
    #line 1492 
    err = ixgbe_enable_port_vlan(adapter,vf,(unsigned short)((int)vlan),(unsigned char)((int)qos));
  }
  else 
       #line 1494 
       err = ixgbe_disable_port_vlan(adapter,vf);
  #line 1497 
  out: 
       #line 1497 
  ;
  #line 1498 
  return err;
}

#line 1501  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_link_mbps(struct ixgbe_adapter *adapter)
{
  #line 1503 
  switch (adapter->link_speed) {
    #line 1504 
    case (u32)8: 
                 #line 1504 
    ;
    #line 1505 
    return 100;
    #line 1506 
    case (u32)32: 
                  #line 1506 
    ;
    #line 1507 
    return 1000;
    #line 1508 
    case (u32)128: 
                   #line 1508 
    ;
    #line 1509 
    return 10000;
    #line 1510 
    default: 
             #line 1510 
    ;
    #line 1511 
    return 0;
  }
}

#line 1515  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static void ixgbe_set_vf_rate_limit(struct ixgbe_adapter *adapter, int vf)
{
  #line 1520 
  u16 queue;
  #line 1520 
  u16 queues_per_pool;
  #line 1517 
  struct ixgbe_ring_feature *vmdq = & adapter->ring_feature[1];
  #line 1518 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 1519 
  u32 bcnrc_val = 0U;
  #line 1521 
  u16 tx_rate = (adapter->vfinfo + (unsigned long)vf)->tx_rate;
  #line 1523 
  if ((unsigned int)tx_rate != 0U) {
    #line 1525 
    bcnrc_val = (unsigned int)adapter->vf_rate_link_speed;
    #line 1528 
    bcnrc_val <<= 14;
    #line 1529 
    bcnrc_val /= (unsigned int)tx_rate;
    #line 1532 
    bcnrc_val &= 268435455U;
    #line 1536 
    bcnrc_val |= 2147483648U;
  }
  #line 1544 
  switch ((unsigned int)hw->mac.type) {
    #line 1545 
    case (unsigned int)2: 
                          #line 1545 
    ;
    #line 1546 
    ixgbe_write_reg_13(hw,18816U,4U);
    #line 1547 
    break;
    #line 1548 
    case (unsigned int)3: 
                          #line 1548 
    ;
    #line 1549 
    ixgbe_write_reg_13(hw,18816U,20U);
    #line 1550 
    break;
    #line 1551 
    default: 
             #line 1551 
    ;
    #line 1552 
    break;
  }
  #line 1556 
  queues_per_pool = (unsigned short)(- ((int)vmdq->mask) & (int)vmdq->mask);
  #line 1559 
  queue = (unsigned short)0U;
  #line 1559 
  while ((int)queue < (int)queues_per_pool) {
    {
      #line 1560 
      unsigned int reg_idx = (unsigned int)((int)queues_per_pool * vf + (int)queue);
      #line 1562 
      ixgbe_write_reg_13(hw,18692U,reg_idx);
      #line 1563 
      ixgbe_write_reg_13(hw,18820U,bcnrc_val);
    }
    #line 1559 
    queue = (u16)((int)queue + 1);
  }
  #line 1565 
  return;
}

#line 1567  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
void ixgbe_check_vf_rate_limit(struct ixgbe_adapter *adapter)
{
  #line 1569 
  int i;
  #line 1572 
  if (adapter->vf_rate_link_speed == 0) 
                                        #line 1573 
                                        return;
  #line 1575 
  ;
  #line 1575 
  if (ixgbe_link_mbps(adapter) != adapter->vf_rate_link_speed) {
    #line 1576 
    adapter->vf_rate_link_speed = 0;
    #line 1577 
    _dev_info(& (adapter->pdev)->dev,(char *)"Link speed has been changed. VF Transmit rate is disabled\n");
  }
  #line 1581 
  i = 0;
  #line 1581 
  while (adapter->num_vfs > (unsigned int)i) {
    #line 1582 
    if (adapter->vf_rate_link_speed == 0) 
                                          #line 1583 
                                          (adapter->vfinfo + (unsigned long)i)->tx_rate = (unsigned short)0U;
    #line 1585 
    ixgbe_set_vf_rate_limit(adapter,i);
    #line 1581 
    i ++;
  }
  #line 1587 
  return;
}

#line 1589  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_ndo_set_vf_bw(struct net_device *netdev, int vf, int min_tx_rate, int max_tx_rate)
{
  #line 1593 
  int link_speed;
  #line 1592 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 1596 
  if (adapter->num_vfs <= (unsigned int)vf) 
                                            #line 1597 
                                            return -22;
  #line 1600 
  if (! adapter->link_up) 
                          #line 1601 
                          return -22;
  #line 1604 
  link_speed = ixgbe_link_mbps(adapter);
  #line 1605 
  if (link_speed != 10000) 
                           #line 1606 
                           return -22;
  #line 1608 
  if (min_tx_rate != 0) 
                        #line 1609 
                        return -22;
  #line 1612 
  if (max_tx_rate != 0 && (max_tx_rate <= 10 || max_tx_rate > link_speed)) 
    #line 1613 
    return -22;
  #line 1616 
  adapter->vf_rate_link_speed = link_speed;
  #line 1617 
  (adapter->vfinfo + (unsigned long)vf)->tx_rate = (unsigned short)max_tx_rate;
  #line 1620 
  ixgbe_set_vf_rate_limit(adapter,vf);
  #line 1622 
  return 0;
}

#line 1625  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_ndo_set_vf_spoofchk(struct net_device *netdev, int vf, bool setting)
{
  #line 1627 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 1628 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 1630 
  if (adapter->num_vfs <= (unsigned int)vf) 
                                            #line 1631 
                                            return -22;
  #line 1633 
  (adapter->vfinfo + (unsigned long)vf)->spoofchk_enabled = (unsigned char)setting;
  #line 1636 
  (*(hw->mac.ops.set_mac_anti_spoofing))(hw,(_Bool)((bool)((int)setting) != 0),vf);
  #line 1639 
  (*(hw->mac.ops.set_vlan_anti_spoofing))(hw,(_Bool)((bool)((int)setting) != 0),vf);
  #line 1644 
  if (hw->mac.ops.set_ethertype_anti_spoofing != (void (*)(struct ixgbe_hw *, bool , int ))0) {
    #line 1645 
    ixgbe_write_reg_13(hw,20796U,2684389580U);
    #line 1650 
    ixgbe_write_reg_13(hw,20804U,2684389384U);
    #line 1655 
    (*(hw->mac.ops.set_ethertype_anti_spoofing))(hw,(_Bool)((bool)((int)setting) != 0),vf);
  }
  #line 1658 
  return 0;
}

#line 1661  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_ndo_set_vf_rss_query_en(struct net_device *netdev, int vf, bool setting)
{
  #line 1664 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 1669 
  if ((unsigned int)adapter->hw.mac.type + 4294967294U > 1U) 
                                                             #line 1671 
                                                             return -95;
  #line 1673 
  if (adapter->num_vfs <= (unsigned int)vf) 
                                            #line 1674 
                                            return -22;
  #line 1676 
  (adapter->vfinfo + (unsigned long)vf)->rss_query_enabled = setting;
  #line 1678 
  return 0;
}

#line 1681  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_ndo_set_vf_trust(struct net_device *netdev, int vf, bool setting)
{
  #line 1683 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 1685 
  if (adapter->num_vfs <= (unsigned int)vf) 
                                            #line 1686 
                                            return -22;
  #line 1689 
  if ((int)(adapter->vfinfo + (unsigned long)vf)->trusted == (int)((unsigned char)setting)) 
    #line 1690 
    return 0;
  #line 1692 
  (adapter->vfinfo + (unsigned long)vf)->trusted = (unsigned char)setting;
  #line 1695 
  (adapter->vfinfo + (unsigned long)vf)->clear_to_send = (_Bool)0;
  #line 1696 
  ixgbe_ping_vf(adapter,vf);
  #line 1698 
  if (((int)adapter->msg_enable & 1) != 0) {
    #line 1698 
    char *tmp_0;
    #line 1698 
    if ((int)setting != 0) 
                           #line 1698 
                           tmp_0 = (char *)""; else 
                                                    #line 1698 
                                                    tmp_0 = (char *)"not ";
    #line 1698 
    ;
    #line 1698 
    ;
    #line 1698 
    netdev_info(adapter->netdev,(char *)"VF %u is %strusted\n",vf,tmp_0);
  }
  #line 1700 
  return 0;
}

#line 1703  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_ndo_get_vf_config(struct net_device *netdev, int vf, struct ifla_vf_info *ivi)
{
  #line 1706 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 1707 
  if (adapter->num_vfs <= (unsigned int)vf) 
                                            #line 1708 
                                            return -22;
  #line 1709 
  ivi->vf = (unsigned int)vf;
  #line 1710 
  memcpy((void *)(& ivi->mac),(void *)(& (adapter->vfinfo + (unsigned long)vf)->vf_mac_addresses),6UL);
  #line 1711 
  ivi->max_tx_rate = (unsigned int)(adapter->vfinfo + (unsigned long)vf)->tx_rate;
  #line 1712 
  ivi->min_tx_rate = 0U;
  #line 1713 
  ivi->vlan = (unsigned int)(adapter->vfinfo + (unsigned long)vf)->pf_vlan;
  #line 1714 
  ivi->qos = (unsigned int)(adapter->vfinfo + (unsigned long)vf)->pf_qos;
  #line 1715 
  ivi->spoofchk = (unsigned int)(adapter->vfinfo + (unsigned long)vf)->spoofchk_enabled;
  #line 1716 
  ivi->rss_query_en = (unsigned int)(adapter->vfinfo + (unsigned long)vf)->rss_query_enabled;
  #line 1717 
  ivi->trusted = (unsigned int)(adapter->vfinfo + (unsigned long)vf)->trusted;
  #line 1718 
  return 0;
}

#line 135  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_sriov.i.aux"
static void INIT_LIST_HEAD_1(struct list_head *list)
{
  #line 138 
  ldv_init_list_head(list);
  #line 139 
  return;
}

#line 465  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_sriov.i.aux"
static void *kcalloc_1(size_t n, size_t size, gfp_t flags)
{
  #line 468 
  return ldv_kcalloc(n,size,flags);
}

#line 480  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernel.h"
#line 480 
char *kasprintf(gfp_t, char * , ...);
#line 487 
#line 487 
int sscanf(char *, char * , ...);
#line 52  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/string.h"
#line 170  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_debugfs.i.aux"
static int cif_strncmp(char *cs, char *ct, __kernel_size_t count);
#line 88  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/string.h"
#line 177  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_debugfs.i.aux"
static size_t cif_strlen(char *s);
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/string.h"
#line 25 
size_t ldv_strlen(char *s);
#line 27 
#line 27 
int ldv_strncmp(char *cs, char *ct, __kernel_size_t count);
#line 3300  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
#line 3300 
int simple_open(struct inode *, struct file *);
#line 3337 
#line 3337 
ssize_t simple_read_from_buffer(void *, size_t, loff_t *, void *, size_t);
#line 3339 
#line 3339 
ssize_t simple_write_to_buffer(void *, size_t, loff_t *, void *, size_t);
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/debugfs.h"
#line 723  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_debugfs.i.aux"
static struct dentry *cif_debugfs_create_file(char *name, umode_t mode, struct dentry *parent, void *data, struct file_operations *fops);
#line 76  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/debugfs.h"
#line 715  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_debugfs.i.aux"
static struct dentry *cif_debugfs_create_dir(char *name, struct dentry *parent);
#line 85  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/debugfs.h"
#line 85 
void debugfs_remove_recursive(struct dentry *);
#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static void ixgbe_write_reg_14(struct ixgbe_hw *hw, u32 reg, u32 value)
{
  #line 147 
  union __anonunion___u_16070 __u;
  #line 146 
  __read_once_size((void *)(& hw->hw_addr),(void *)(& __u.__c),8);
  #line 146 
  u8 *reg_addr = (__u.__val);
  #line 148 
  if ((int)ixgbe_removed((void *)reg_addr) != 0) 
                                                 #line 149 
                                                 return;
  #line 150 
  writel(value,(void *)(reg_addr + (unsigned long)reg));
  #line 151 
  return;
}

#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static struct dentry *ixgbe_dbg_root;
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static char ixgbe_dbg_reg_ops_buf[256U] = {(char)'\000'};
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static ssize_t ixgbe_dbg_common_ops_read(struct file *filp, char *buffer, size_t count, loff_t *ppos, char *dbg_buf)
{
  #line 18 
  char *buf;
  #line 19 
  int len;
  #line 17 
  struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)filp->private_data;
  #line 22 
  if (*ppos != 0LL) 
                    #line 23 
                    return 0L;
  #line 25 
  buf = kasprintf(3264U,(char *)"%s: %s\n",(char *)(& (adapter->netdev)->name),dbg_buf);
  #line 27 
  if (buf == (char *)0) 
                        #line 28 
                        return -12L;
  #line 30 
  ;
  #line 30 
  if (cif_strlen(buf) > count) {
    #line 31 
    kfree((void *)buf);
    #line 32 
    return -28L;
  }
  #line 35 
  ;
  #line 35 
  ;
  #line 35 
  ;
  #line 35 
  ;
  #line 35 
  len = (int)simple_read_from_buffer((void *)buffer,count,ppos,(void *)buf,
                                cif_strlen(buf));
  #line 37 
  kfree((void *)buf);
  #line 38 
  return (long)len;
}

#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static ssize_t ixgbe_dbg_reg_ops_read(struct file *filp, char *buffer, size_t count, loff_t *ppos)
{
  #line 51 
  return ixgbe_dbg_common_ops_read(filp,buffer,count,ppos,
                                (char *)(& ixgbe_dbg_reg_ops_buf));
}

#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static ssize_t ixgbe_dbg_reg_ops_write(struct file *filp, char *buffer, size_t count, loff_t *ppos)
{
  #line 67 
  int len;
  #line 66 
  struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)filp->private_data;
  #line 70 
  if (*ppos != 0LL) 
                    #line 71 
                    return 0L;
  #line 72 
  if (count > 255UL) 
                     #line 73 
                     return -28L;
  #line 75 
  len = (int)simple_write_to_buffer((void *)(& ixgbe_dbg_reg_ops_buf),255UL,ppos,
                             (void *)buffer,count);
  #line 80 
  if (len < 0) 
               #line 81 
               return (long)len;
  #line 83 
  ixgbe_dbg_reg_ops_buf[len] = (char)0;
  #line 85 
  if (cif_strncmp((char *)(& ixgbe_dbg_reg_ops_buf),(char *)"write",5UL) == 0) {
    #line 86 
    u32 reg;
    #line 86 
    u32 value;
    #line 87 
    int cnt;
    #line 88 
    cnt = sscanf(& ixgbe_dbg_reg_ops_buf[5],(char *)"%x %x",& reg,& value);
    #line 89 
    if (cnt == 2) {
      #line 90 
      ixgbe_write_reg_14(& adapter->hw,reg,value);
      #line 91 
      value = ixgbe_read_reg(& adapter->hw,reg);
      #line 92 
      _dev_info(& (adapter->pdev)->dev,(char *)"write: 0x%08x = 0x%08x\n",reg,value);
    }
    else 
         #line 94 
         _dev_info(& (adapter->pdev)->dev,(char *)"write <reg> <value>\n");
  }
  else {
    #line 96 
    if (cif_strncmp((char *)(& ixgbe_dbg_reg_ops_buf),(char *)"read",4UL) == 0) {
      #line 97 
      u32 reg_0;
      #line 97 
      u32 value_0;
      #line 98 
      int cnt_0;
      #line 99 
      cnt_0 = sscanf(& ixgbe_dbg_reg_ops_buf[4],(char *)"%x",& reg_0);
      #line 100 
      if (cnt_0 == 1) {
        #line 101 
        value_0 = ixgbe_read_reg(& adapter->hw,reg_0);
        #line 102 
        _dev_info(& (adapter->pdev)->dev,(char *)"read 0x%08x = 0x%08x\n",reg_0,value_0);
      }
      else 
           #line 104 
           _dev_info(& (adapter->pdev)->dev,(char *)"read <reg>\n");
    }
    else {
      #line 107 
      _dev_info(& (adapter->pdev)->dev,(char *)"Unknown command %s\n",(char *)(& ixgbe_dbg_reg_ops_buf));
      #line 108 
      _dev_info(& (adapter->pdev)->dev,(char *)"Available commands:\n");
      #line 109 
      _dev_info(& (adapter->pdev)->dev,(char *)"   read <reg>\n");
      #line 110 
      _dev_info(& (adapter->pdev)->dev,(char *)"   write <reg> <value>\n");
    }
  }
  #line 112 
  return (long)count;
}

#line 115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static struct file_operations ixgbe_dbg_reg_ops_fops = {.owner = & __this_module, .read = & ixgbe_dbg_reg_ops_read, .write = & ixgbe_dbg_reg_ops_write, .open = & simple_open};
#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static char ixgbe_dbg_netdev_ops_buf[256U] = {(char)'\000'};
#line 131  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static ssize_t ixgbe_dbg_netdev_ops_read(struct file *filp, char *buffer, size_t count, loff_t *ppos)
{
  #line 134 
  return ixgbe_dbg_common_ops_read(filp,buffer,count,ppos,
                                (char *)(& ixgbe_dbg_netdev_ops_buf));
}

#line 145  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static ssize_t ixgbe_dbg_netdev_ops_write(struct file *filp, char *buffer, size_t count, loff_t *ppos)
{
  #line 150 
  int len;
  #line 149 
  struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)filp->private_data;
  #line 153 
  if (*ppos != 0LL) 
                    #line 154 
                    return 0L;
  #line 155 
  if (count > 255UL) 
                     #line 156 
                     return -28L;
  #line 158 
  len = (int)simple_write_to_buffer((void *)(& ixgbe_dbg_netdev_ops_buf),255UL,ppos,
                             (void *)buffer,count);
  #line 163 
  if (len < 0) 
               #line 164 
               return (long)len;
  #line 166 
  ixgbe_dbg_netdev_ops_buf[len] = (char)0;
  #line 168 
  if (cif_strncmp((char *)(& ixgbe_dbg_netdev_ops_buf),
                    (char *)"tx_timeout",10UL) == 0) {
    #line 169 
    (*(((adapter->netdev)->netdev_ops)->ndo_tx_timeout))(adapter->netdev);
    #line 170 
    _dev_info(& (adapter->pdev)->dev,(char *)"tx_timeout called\n");
  }
  else {
    #line 172 
    _dev_info(& (adapter->pdev)->dev,(char *)"Unknown command: %s\n",(char *)(& ixgbe_dbg_netdev_ops_buf));
    #line 173 
    _dev_info(& (adapter->pdev)->dev,(char *)"Available commands:\n");
    #line 174 
    _dev_info(& (adapter->pdev)->dev,(char *)"    tx_timeout\n");
  }
  #line 176 
  return (long)count;
}

#line 179  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static struct file_operations ixgbe_dbg_netdev_ops_fops = {.owner = & __this_module, .read = & ixgbe_dbg_netdev_ops_read, .write = & ixgbe_dbg_netdev_ops_write, .open = & simple_open};
#line 190  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
void ixgbe_dbg_adapter_init(struct ixgbe_adapter *adapter)
{
  #line 192 
  char *name = pci_name(adapter->pdev);
  #line 194 
  adapter->ixgbe_dbg_adapter = cif_debugfs_create_dir(name,ixgbe_dbg_root);
  #line 195 
  cif_debugfs_create_file((char *)"reg_ops",(unsigned short)384,adapter->ixgbe_dbg_adapter,(void *)adapter,& ixgbe_dbg_reg_ops_fops);
  #line 197 
  cif_debugfs_create_file((char *)"netdev_ops",(unsigned short)384,adapter->ixgbe_dbg_adapter,(void *)adapter,& ixgbe_dbg_netdev_ops_fops);
  #line 199 
  return;
}

#line 205  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
void ixgbe_dbg_adapter_exit(struct ixgbe_adapter *adapter)
{
  #line 207 
  debugfs_remove_recursive(adapter->ixgbe_dbg_adapter);
  #line 208 
  adapter->ixgbe_dbg_adapter = (struct dentry *)0;
  #line 209 
  return;
}

#line 214  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
void ixgbe_dbg_init(void)
{
  #line 216 
  ixgbe_dbg_root = cif_debugfs_create_dir((char *)(& ixgbe_driver_name),(struct dentry *)0);
  #line 217 
  return;
}

#line 222  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
void ixgbe_dbg_exit(void)
{
  #line 224 
  debugfs_remove_recursive(ixgbe_dbg_root);
  #line 225 
  return;
}

#line 93  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_debugfs.i.aux"
struct file_operations *emg_alias_ixgbe_dbg_netdev_ops_fops = & ixgbe_dbg_netdev_ops_fops;
#line 94  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_debugfs.i.aux"
struct file_operations *emg_alias_ixgbe_dbg_reg_ops_fops = & ixgbe_dbg_reg_ops_fops;
#line 99 
#line 99 
struct dentry *emg_debugfs_create_dir(char *arg0, struct dentry *arg1);
#line 100 
#line 100 
struct dentry *emg_debugfs_create_file(char *arg0, unsigned short arg1, struct dentry *arg2, void *arg3, struct file_operations *arg4);
#line 114  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_debugfs.i.aux"
long emg_wrapper_ixgbe_dbg_netdev_ops_read(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  #line 115 
  return ixgbe_dbg_netdev_ops_read(arg0,arg1,arg2,arg3);
}

#line 119  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_debugfs.i.aux"
long emg_wrapper_ixgbe_dbg_netdev_ops_write(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  #line 120 
  return ixgbe_dbg_netdev_ops_write(arg0,arg1,arg2,arg3);
}

#line 124  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_debugfs.i.aux"
long emg_wrapper_ixgbe_dbg_reg_ops_read(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  #line 125 
  return ixgbe_dbg_reg_ops_read(arg0,arg1,arg2,arg3);
}

#line 129  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_debugfs.i.aux"
long emg_wrapper_ixgbe_dbg_reg_ops_write(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  #line 130 
  return ixgbe_dbg_reg_ops_write(arg0,arg1,arg2,arg3);
}

#line 170  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_debugfs.i.aux"
static int cif_strncmp(char *cs, char *ct, __kernel_size_t count)
{
  #line 173 
  return ldv_strncmp(cs,ct,count);
}

#line 177  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_debugfs.i.aux"
static size_t cif_strlen(char *s)
{
  #line 180 
  return ldv_strlen(s);
}

#line 715  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_debugfs.i.aux"
static struct dentry *cif_debugfs_create_dir(char *name, struct dentry *parent)
{
  #line 719 
  return emg_debugfs_create_dir(name,parent);
}

#line 723  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_debugfs.i.aux"
static struct dentry *cif_debugfs_create_file(char *name, umode_t mode, struct dentry *parent, void *data, struct file_operations *fops)
{
  #line 727 
  return emg_debugfs_create_file(name,(unsigned short)((int)mode),parent,data,
                              fops);
}

#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
#line 121  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_xsk.i.aux"
static void cif_set_bit_4(long nr, unsigned long *addr);
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
#line 128  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_xsk.i.aux"
static void cif_clear_bit_1(long nr, unsigned long *addr);
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/cmpxchg.h"
#line 15 
void __cmpxchg_wrong_size(void);
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/err.h"
#line 205  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_xsk.i.aux"
static void *ERR_PTR_0(long error);
#line 545  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static bool napi_if_scheduled_mark_missed(struct napi_struct *n)
{
  #line 547 
  unsigned long val;
  #line 547 
  unsigned long new;
  #line 549 
  while (1) {
    #line 558 
    unsigned long __ret;
    {
      #line 551 
      union __anonunion___u_16754 __u;
      #line 550 
      __read_once_size((void *)(& n->state),(void *)(& __u.__c),8);
      #line 550 
      val = (__u.__val);
      #line 551 
      if ((val & 4UL) != 0UL) 
                              #line 552 
                              return (_Bool)1;
      #line 554 
      if ((val & 1UL) == 0UL) 
                              #line 555 
                              return (_Bool)0;
      #line 557 
      new = val | 2UL;
    }
    {
      #line 558 
      unsigned long *__ai_ptr = & n->state;
      #line 558 
      kasan_check_read((void *)__ai_ptr,8U);
      {
        #line 558 
        unsigned long __old = val;
        #line 558 
        unsigned long __new = new;
        #line 558 
        switch (8UL) {
          #line 558 
          case (unsigned long)1: 
                                 #line 558 
          ;
          {
            #line 558 
            u8 *__ptr = (u8 *)__ai_ptr;
            #line 559 
            ldv_inline_asm();
            #line 558 
            break;
          }
          #line 558 
          case (unsigned long)2: 
                                 #line 558 
          ;
          {
            #line 558 
            u16 *__ptr_0 = (u16 *)__ai_ptr;
            #line 559 
            ldv_inline_asm();
            #line 558 
            break;
          }
          #line 558 
          case (unsigned long)4: 
                                 #line 558 
          ;
          {
            #line 558 
            u32 *__ptr_1 = (u32 *)__ai_ptr;
            #line 559 
            ldv_inline_asm();
            #line 558 
            break;
          }
          #line 558 
          case (unsigned long)8: 
                                 #line 558 
          ;
          {
            #line 558 
            u64 *__ptr_2 = (u64 *)__ai_ptr;
            #line 559 
            ldv_inline_asm();
            #line 558 
            break;
          }
          #line 558 
          default: 
                   #line 558 
          ;
          #line 558 
          __cmpxchg_wrong_size();
        }
        }
      }
    #line 558 
    ;
    #line 558 
    if (! (__ret != val)) 
                          #line 549 
                          break;
  }
  #line 560 
  return (_Bool)1;
}

#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/trace/events/xdp.h"
__inline static void trace_xdp_exception_0(struct net_device *dev, struct bpf_prog *xdp, u32 act)
{
  #line 28 
  int pscr_ret___0;
  #line 28 
  if ((int)static_key_false(& __tracepoint_xdp_exception.key) != 0) {
    #line 28 
    int pscr_ret__;
    #line 28 
    struct tracepoint_func *________p1;
    #line 28 
    struct tracepoint_func *it_func_ptr;
    #line 28 
    void *it_func;
    #line 28 
    void *__data;
    #line 28 
    int __idx = 0;
    {
      #line 28 
      void *__vpp_verify = (void *)0;
      #line 28 
      void *tmp = __vpp_verify;
    }
    #line 28 
    switch (4UL) {
      #line 28 
      int pfo_ret___2;
      #line 28 
      int pfo_ret__;
      #line 28 
      int pfo_ret___0;
      #line 28 
      int pfo_ret___1;
      #line 28 
      case (unsigned long)1: 
                             #line 28 
      ;
      #line 28 
      switch (4UL) {
        #line 28 
        case (unsigned long)1: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)2: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)4: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)8: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        default: 
                 #line 28 
        ;
        #line 28 
        __bad_percpu_size();
      }
      #line 28 
      pscr_ret__ = pfo_ret__;
      #line 28 
      break;
      #line 28 
      case (unsigned long)2: 
                             #line 28 
      ;
      #line 28 
      switch (4UL) {
        #line 28 
        case (unsigned long)1: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)2: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)4: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)8: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        default: 
                 #line 28 
        ;
        #line 28 
        __bad_percpu_size();
      }
      #line 28 
      pscr_ret__ = pfo_ret___0;
      #line 28 
      break;
      #line 28 
      case (unsigned long)4: 
                             #line 28 
      ;
      #line 28 
      switch (4UL) {
        #line 28 
        case (unsigned long)1: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)2: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)4: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)8: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        default: 
                 #line 28 
        ;
        #line 28 
        __bad_percpu_size();
      }
      #line 28 
      pscr_ret__ = pfo_ret___1;
      #line 28 
      break;
      #line 28 
      case (unsigned long)8: 
                             #line 28 
      ;
      #line 28 
      switch (4UL) {
        #line 28 
        case (unsigned long)1: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)2: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)4: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)8: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        default: 
                 #line 28 
        ;
        #line 28 
        __bad_percpu_size();
      }
      #line 28 
      pscr_ret__ = pfo_ret___2;
      #line 28 
      break;
      #line 28 
      default: 
               #line 28 
      ;
      #line 28 
      __bad_size_call_parameter();
      #line 28 
      break;
    }
    #line 28 
    if (cpumask_test_cpu(pscr_ret__,& __cpu_online_mask) == 0) 
                                                               #line 28 
                                                               return;
    {
      #line 28 
      int __ret_warn_on = 0;
      #line 28 
      if ((long)(__ret_warn_on != 0) != 0L) {
        #line 29 
        ldv_inline_asm();
        #line 30 
        ldv_inline_asm();
      }
      #line 28 
      long tmp_5 = (long)(__ret_warn_on != 0);
    }
    #line 28 
    __preempt_count_add(1);
    #line 29 
    ldv_inline_asm();
    {
      #line 29 
      union __anonunion___u_16876 __u;
      #line 28 
      __read_once_size((void *)(& __tracepoint_xdp_exception.funcs),(void *)(& __u.__c),8);
      #line 28 
      ________p1 = (__u.__val);
      }
    #line 28 
    it_func_ptr = ________p1;
    #line 28 
    if (it_func_ptr != (struct tracepoint_func *)0) 
      #line 28 
      while (1) {
        #line 28 
        it_func = it_func_ptr->func;
        #line 28 
        __data = it_func_ptr->data;
        #line 28 
        (*((void (*)(void *, struct net_device *, struct bpf_prog *, u32 ))it_func))(__data,dev,xdp,act);
        #line 28 
        it_func_ptr ++;
        #line 29 
        ;
        #line 29 
        if (! (it_func_ptr->func != (void *)0)) 
                                                #line 28 
                                                break;
      }
    #line 30 
    ldv_inline_asm();
    #line 28 
    __preempt_count_sub(1);
  }
  {
    #line 28 
    void *__vpp_verify_0 = (void *)0;
    #line 28 
    void *tmp_13 = __vpp_verify_0;
  }
  #line 28 
  switch (4UL) {
    #line 28 
    int pfo_ret___3;
    #line 28 
    int pfo_ret___4;
    #line 28 
    int pfo_ret___5;
    #line 28 
    int pfo_ret___6;
    #line 28 
    case (unsigned long)1: 
                           #line 28 
    ;
    #line 28 
    switch (4UL) {
      #line 28 
      case (unsigned long)1: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)2: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)4: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)8: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      default: 
               #line 28 
      ;
      #line 28 
      __bad_percpu_size();
    }
    #line 28 
    pscr_ret___0 = pfo_ret___3;
    #line 28 
    break;
    #line 28 
    case (unsigned long)2: 
                           #line 28 
    ;
    #line 28 
    switch (4UL) {
      #line 28 
      case (unsigned long)1: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)2: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)4: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)8: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      default: 
               #line 28 
      ;
      #line 28 
      __bad_percpu_size();
    }
    #line 28 
    pscr_ret___0 = pfo_ret___4;
    #line 28 
    break;
    #line 28 
    case (unsigned long)4: 
                           #line 28 
    ;
    #line 28 
    switch (4UL) {
      #line 28 
      case (unsigned long)1: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)2: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)4: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)8: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      default: 
               #line 28 
      ;
      #line 28 
      __bad_percpu_size();
    }
    #line 28 
    pscr_ret___0 = pfo_ret___5;
    #line 28 
    break;
    #line 28 
    case (unsigned long)8: 
                           #line 28 
    ;
    #line 28 
    switch (4UL) {
      #line 28 
      case (unsigned long)1: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)2: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)4: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)8: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      default: 
               #line 28 
      ;
      #line 28 
      __bad_percpu_size();
    }
    #line 28 
    pscr_ret___0 = pfo_ret___6;
    #line 28 
    break;
    #line 28 
    default: 
             #line 28 
    ;
    #line 28 
    __bad_size_call_parameter();
    #line 28 
    break;
  }
  #line 28 
  if (cpumask_test_cpu(pscr_ret___0,& __cpu_online_mask) != 0) {
    #line 28 
    __rcu_read_lock();
    {
      #line 29 
      union __anonunion___u_16878 __u_0;
      #line 28 
      __read_once_size((void *)(& __tracepoint_xdp_exception.funcs),(void *)(& __u_0.__c),8);
      #line 28 
      struct tracepoint_func *________p1_0 = (__u_0.__val);
      {
        #line 28 
        bool __warned;
        #line 28 
        if (debug_lockdep_rcu_enabled() != 0) 
          #line 28 
          if (! __warned) {
            #line 28 
            if (rcu_read_lock_sched_held() == 0) {
              #line 28 
              __warned = (_Bool)1;
              #line 28 
              lockdep_rcu_suspicious((char *)"./include/trace/events/xdp.h",28,(char *)"suspicious rcu_dereference_check() usage");
            }
          }
      }
      #line 28 
      struct tracepoint_func *tmp_11 = ________p1_0;
    }
    #line 28 
    __rcu_read_unlock();
  }
  #line 30 
  return;
}

#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
#line 122 
u64 *xsk_umem_peek_addr(struct xdp_umem *, u64 *);
#line 123 
#line 123 
void xsk_umem_discard_addr(struct xdp_umem *);
#line 124 
#line 124 
void xsk_umem_complete_tx(struct xdp_umem *, u32);
#line 125 
#line 125 
bool xsk_umem_consume_tx(struct xdp_umem *, struct xdp_desc *);
#line 126 
#line 126 
void xsk_umem_consume_tx_done(struct xdp_umem *);
#line 127 
#line 127 
struct xdp_umem_fq_reuse *xsk_reuseq_prepare(u32);
#line 128 
#line 128 
struct xdp_umem_fq_reuse *xsk_reuseq_swap(struct xdp_umem *, struct xdp_umem_fq_reuse *);
#line 130 
#line 130 
void xsk_reuseq_free(struct xdp_umem_fq_reuse *);
#line 131 
#line 131 
struct xdp_umem *xdp_get_umem_from_qid(struct net_device *, u16);
#line 132 
#line 132 
void xsk_set_rx_need_wakeup(struct xdp_umem *);
#line 133 
#line 133 
void xsk_set_tx_need_wakeup(struct xdp_umem *);
#line 134 
#line 134 
void xsk_clear_rx_need_wakeup(struct xdp_umem *);
#line 136 
#line 136 
bool xsk_umem_uses_need_wakeup(struct xdp_umem *);
#line 159  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
__inline static u64 xsk_umem_extract_addr(u64 addr)
{
  #line 161 
  return addr & 281474976710655ULL;
}

#line 164  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
__inline static u64 xsk_umem_extract_offset(u64 addr)
{
  #line 166 
  return addr >> 48;
}

#line 169  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
__inline static u64 xsk_umem_add_offset_to_addr(u64 addr)
{
  #line 171 
  return xsk_umem_extract_addr(addr) + xsk_umem_extract_offset(addr);
}

#line 174  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
__inline static char *xdp_umem_get_data(struct xdp_umem *umem, u64 addr)
{
  #line 176 
  unsigned long page_addr;
  #line 178 
  addr = xsk_umem_add_offset_to_addr(addr);
  #line 179 
  page_addr = (unsigned long)(umem->pages + (addr >> 12))->addr;
  #line 181 
  return (char *)(((unsigned long)addr & (unsigned long)4095U) | (page_addr & 18446744073709547520U));
}

#line 184  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
__inline static dma_addr_t xdp_umem_get_dma(struct xdp_umem *umem, u64 addr)
{
  #line 186 
  addr = xsk_umem_add_offset_to_addr(addr);
  #line 188 
  return (umem->pages + (addr >> 12))->dma + (addr & 4095ULL);
}

#line 202  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
__inline static u64 *xsk_umem_peek_addr_rq(struct xdp_umem *umem, u64 *addr)
{
  #line 204 
  struct xdp_umem_fq_reuse *rq = umem->fq_reuse;
  #line 206 
  if (rq->length == 0U) {
    #line 207 
    return xsk_umem_peek_addr(umem,addr);
  }
  #line 209 
  *addr = rq->handles[rq->length + 4294967295U];
  #line 210 
  return addr;
}

#line 213  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
__inline static void xsk_umem_discard_addr_rq(struct xdp_umem *umem)
{
  #line 215 
  struct xdp_umem_fq_reuse *rq = umem->fq_reuse;
  #line 217 
  if (rq->length == 0U) 
                        #line 218 
                        xsk_umem_discard_addr(umem); else 
                                                          #line 220 
                                                          (rq->length) --;
  #line 221 
  return;
}

#line 223  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
__inline static void xsk_umem_fq_reuse(struct xdp_umem *umem, u64 addr)
{
  #line 227 
  u32 tmp;
  #line 225 
  struct xdp_umem_fq_reuse *rq = umem->fq_reuse;
  #line 227 
  tmp = rq->length;
  #line 227 
  (rq->length) ++;
  #line 227 
  rq->handles[tmp] = addr;
  #line 228 
  return;
}

#line 234  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
__inline static u64 xsk_umem_adjust_offset(struct xdp_umem *umem, u64 address, u64 offset)
{
  #line 237 
  if (((int)umem->flags & 1) != 0) 
                                   #line 238 
                                   return (offset << 48) + address; else 
                                                                    #line 240 
                                                                    return address + offset;
}

#line 1037  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static bool ixgbe_enabled_xdp_adapter(struct ixgbe_adapter *adapter)
{
  #line 1039 
  return (_Bool)(adapter->xdp_prog != (struct bpf_prog *)0);
}

#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
struct xdp_umem *ixgbe_xsk_umem(struct ixgbe_adapter *adapter, struct ixgbe_ring *ring)
{
  #line 15 
  union __anonunion___u_17102 __u;
  #line 14 
  __read_once_size((void *)(& adapter->xdp_prog),(void *)(& __u.__c),8);
  #line 14 
  bool xdp_on = (_Bool)((__u.__val) != (struct bpf_prog *)0);
  #line 15 
  int qid = (int)ring->ring_idx;
  #line 17 
  if (! xdp_on) 
                #line 18 
                return (struct xdp_umem *)0;
  else {
    #line 17 
    if (! test_bit((long)qid,adapter->af_xdp_zc_qps)) 
                                                      #line 18 
                                                      return (struct xdp_umem *)0;
  }
  #line 20 
  return xdp_get_umem_from_qid(adapter->netdev,
                              (unsigned short)((int)((unsigned short)qid)));
}

#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
static int ixgbe_xsk_umem_dma_map(struct ixgbe_adapter *adapter, struct xdp_umem *umem)
{
  #line 27 
  unsigned int i;
  #line 27 
  unsigned int j;
  #line 28 
  dma_addr_t dma;
  #line 26 
  struct device *dev = & (adapter->pdev)->dev;
  #line 30 
  i = 0U;
  #line 30 
  while (umem->npgs > i) {
    {
      #line 31 
      dma = dma_map_page_attrs(dev,*(umem->pgs + (unsigned long)i),0UL,4096UL,(enum dma_data_direction)DMA_BIDIRECTIONAL,34UL);
      #line 33 
      if (dma_mapping_error(dev,dma) != 0) 
                                           #line 34 
                                           goto out_unmap;
      #line 36 
      (umem->pages + (unsigned long)i)->dma = dma;
    }
    #line 30 
    i ++;
  }
  #line 39 
  return 0;
  #line 41 
  out_unmap: 
             #line 41 
  ;
  #line 42 
  j = 0U;
  #line 42 
  while (j < i) {
    #line 43 
    dma_unmap_page_attrs(dev,(umem->pages + (unsigned long)i)->dma,4096UL,(enum dma_data_direction)DMA_BIDIRECTIONAL,34UL);
    #line 45 
    (umem->pages + (unsigned long)i)->dma = 0ULL;
    #line 42 
    j ++;
  }
  #line 48 
  return -1;
}

#line 51  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
static void ixgbe_xsk_umem_dma_unmap(struct ixgbe_adapter *adapter, struct xdp_umem *umem)
{
  #line 55 
  unsigned int i;
  #line 54 
  struct device *dev = & (adapter->pdev)->dev;
  #line 57 
  i = 0U;
  #line 57 
  while (umem->npgs > i) {
    #line 58 
    dma_unmap_page_attrs(dev,(umem->pages + (unsigned long)i)->dma,4096UL,(enum dma_data_direction)DMA_BIDIRECTIONAL,34UL);
    #line 61 
    (umem->pages + (unsigned long)i)->dma = 0ULL;
    #line 57 
    i ++;
  }
  #line 63 
  return;
}

#line 65  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
static int ixgbe_xsk_umem_enable(struct ixgbe_adapter *adapter, struct xdp_umem *umem, u16 qid)
{
  #line 70 
  struct xdp_umem_fq_reuse *reuseq;
  #line 71 
  bool if_running;
  #line 72 
  int err;
  #line 91 
  int tmp_2;
  #line 69 
  struct net_device *netdev = adapter->netdev;
  #line 74 
  if ((int)qid >= adapter->num_rx_queues) 
                                          #line 75 
                                          return -22;
  #line 77 
  if ((unsigned int)qid >= netdev->real_num_rx_queues || (unsigned int)qid >= netdev->real_num_tx_queues) 
    #line 79 
    return -22;
  #line 81 
  reuseq = xsk_reuseq_prepare((unsigned int)(adapter->rx_ring[0])->count);
  #line 82 
  if (reuseq == (struct xdp_umem_fq_reuse *)0) 
                                               #line 83 
                                               return -12;
  #line 85 
  xsk_reuseq_free(xsk_reuseq_swap(umem,reuseq));
  #line 87 
  err = ixgbe_xsk_umem_dma_map(adapter,umem);
  #line 88 
  if (err != 0) 
                #line 89 
                return err;
  #line 91 
  if ((int)netif_running(adapter->netdev) != 0) {
    #line 91 
    if ((int)ixgbe_enabled_xdp_adapter(adapter) != 0) 
                                                      #line 91 
                                                      tmp_2 = 1; else 
                                                                   #line 91 
                                                                   tmp_2 = 0;
  }
  else 
       #line 91 
       tmp_2 = 0;
  #line 91 
  if_running = (_Bool)(tmp_2 != 0);
  #line 94 
  if ((int)if_running != 0) 
                            #line 95 
                            ixgbe_txrx_ring_disable(adapter,(int)qid);
  #line 97 
  cif_set_bit_4((long)qid,adapter->af_xdp_zc_qps);
  #line 99 
  if ((int)if_running != 0) {
    #line 100 
    ixgbe_txrx_ring_enable(adapter,(int)qid);
    #line 103 
    err = ixgbe_xsk_wakeup(adapter->netdev,(unsigned int)qid,1U);
    #line 104 
    if (err != 0) 
                  #line 105 
                  return err;
  }
  #line 108 
  return 0;
}

#line 111  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
static int ixgbe_xsk_umem_disable(struct ixgbe_adapter *adapter, u16 qid)
{
  #line 113 
  struct xdp_umem *umem;
  #line 114 
  bool if_running;
  #line 120 
  int tmp_1;
  #line 116 
  umem = xdp_get_umem_from_qid(adapter->netdev,(unsigned short)((int)qid));
  #line 117 
  if (umem == (struct xdp_umem *)0) 
                                    #line 118 
                                    return -22;
  #line 120 
  if ((int)netif_running(adapter->netdev) != 0) {
    #line 120 
    if ((int)ixgbe_enabled_xdp_adapter(adapter) != 0) 
                                                      #line 120 
                                                      tmp_1 = 1; else 
                                                                   #line 120 
                                                                   tmp_1 = 0;
  }
  else 
       #line 120 
       tmp_1 = 0;
  #line 120 
  if_running = (_Bool)(tmp_1 != 0);
  #line 123 
  if ((int)if_running != 0) 
                            #line 124 
                            ixgbe_txrx_ring_disable(adapter,(int)qid);
  #line 126 
  cif_clear_bit_1((long)qid,adapter->af_xdp_zc_qps);
  #line 127 
  ixgbe_xsk_umem_dma_unmap(adapter,umem);
  #line 129 
  if ((int)if_running != 0) 
                            #line 130 
                            ixgbe_txrx_ring_enable(adapter,(int)qid);
  #line 132 
  return 0;
}

#line 135  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
int ixgbe_xsk_umem_setup(struct ixgbe_adapter *adapter, struct xdp_umem *umem, u16 qid)
{
  #line 138 
  int tmp_1;
  #line 138 
  if (umem != (struct xdp_umem *)0) 
                                    #line 138 
                                    tmp_1 = ixgbe_xsk_umem_enable(adapter,umem,(unsigned short)((int)qid)); else 
                                                                    #line 138 
                                                                    tmp_1 = ixgbe_xsk_umem_disable(adapter,(unsigned short)((int)qid));
  #line 138 
  return tmp_1;
}

#line 142  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
static int ixgbe_run_xdp_zc(struct ixgbe_adapter *adapter, struct ixgbe_ring *rx_ring, struct xdp_buff *xdp)
{
  #line 155 
  union __anonunion___u_17104 __u;
  #line 147 
  int err;
  #line 148 
  struct bpf_prog *xdp_prog;
  #line 149 
  struct xdp_frame *xdpf;
  #line 150 
  u64 offset;
  #line 151 
  u32 act;
  #line 146 
  struct xdp_umem *umem = rx_ring->xsk_umem;
  #line 147 
  int result = 0;
  #line 153 
  rcu_read_lock();
  #line 154 
  __read_once_size((void *)(& rx_ring->xdp_prog),(void *)(& __u.__c),8);
  #line 154 
  xdp_prog = (__u.__val);
  #line 155 
  act = bpf_prog_run_xdp(xdp_prog,xdp);
  #line 156 
  offset = (unsigned long long)(xdp->data - xdp->data_hard_start);
  #line 158 
  xdp->handle = (unsigned long)xsk_umem_adjust_offset(umem,(unsigned long long)xdp->handle,offset);
  #line 160 
  switch (act) {
    #line 161 
    case (u32)2: 
                 #line 161 
    ;
    #line 162 
    break;
    #line 163 
    case (u32)3: 
                 #line 163 
    ;
    #line 164 
    xdpf = convert_to_xdp_frame(xdp);
    #line 165 
    if ((long)(xdpf == (struct xdp_frame *)0) != 0L) {
      #line 166 
      result = 1;
      #line 167 
      break;
    }
    #line 169 
    result = ixgbe_xmit_xdp_ring(adapter,xdpf);
    #line 170 
    break;
    #line 171 
    case (u32)4: 
                 #line 171 
    ;
    #line 172 
    err = xdp_do_redirect(rx_ring->netdev,xdp,xdp_prog);
    #line 173 
    if (err == 0) 
                  #line 173 
                  result = 4; else 
                                   #line 173 
                                   result = 1;
    #line 174 
    break;
    #line 175 
    default: 
             #line 175 
    ;
    #line 176 
    bpf_warn_invalid_xdp_action(act);
    #line 178 
    case (u32)0: 
                 #line 178 
    ;
    #line 179 
    trace_xdp_exception_0(rx_ring->netdev,xdp_prog,act);
    #line 181 
    case (u32)1: 
                 #line 181 
    ;
    #line 182 
    result = 1;
    #line 183 
    break;
  }
  #line 185 
  rcu_read_unlock();
  #line 186 
  return result;
}

#line 190  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
static struct ixgbe_rx_buffer *ixgbe_get_rx_buffer_zc(struct ixgbe_ring *rx_ring, unsigned int size)
{
  #line 193 
  struct ixgbe_rx_buffer *bi;
  #line 195 
  bi = rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info + (unsigned long)rx_ring->next_to_clean;
  #line 198 
  dma_sync_single_range_for_cpu(rx_ring->dev,bi->dma,0UL,(unsigned long)size,(enum dma_data_direction)DMA_BIDIRECTIONAL);
  #line 203 
  return bi;
}

#line 206  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
static void ixgbe_reuse_rx_buffer_zc(struct ixgbe_ring *rx_ring, struct ixgbe_rx_buffer *obi)
{
  #line 210 
  struct ixgbe_rx_buffer *nbi;
  #line 209 
  u16 nta = rx_ring->__anonCompField_ixgbe_ring_223.next_to_alloc;
  #line 212 
  nbi = rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info + (unsigned long)rx_ring->__anonCompField_ixgbe_ring_223.next_to_alloc;
  #line 214 
  nta = (u16)((int)nta + 1);
  #line 215 
  if ((int)rx_ring->count > (int)nta) 
                                      #line 215 
                                      rx_ring->__anonCompField_ixgbe_ring_223.next_to_alloc = nta; else 
                                                                    #line 215 
                                                                    rx_ring->__anonCompField_ixgbe_ring_223.next_to_alloc = (unsigned short)0U;
  #line 218 
  nbi->dma = obi->dma;
  #line 219 
  nbi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_219.addr = obi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_219.addr;
  #line 220 
  nbi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_219.handle = obi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_219.handle;
  #line 222 
  obi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_219.addr = (void *)0;
  #line 223 
  obi->skb = (struct sk_buff *)0;
  #line 224 
  return;
}

#line 226  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
void ixgbe_zca_free(struct zero_copy_allocator *alloc, unsigned long handle)
{
  #line 233 
  void *__mptr;
  #line 228 
  struct ixgbe_rx_buffer *bi;
  #line 229 
  struct ixgbe_ring *rx_ring;
  #line 230 
  u64 hr;
  #line 230 
  u64 mask;
  #line 231 
  u16 nta;
  #line 233 
  __mptr = (void *)alloc;
  #line 233 
  rx_ring = ((struct ixgbe_ring *)(__mptr + 18446744073709551352U));
  #line 234 
  hr = (unsigned long long)((rx_ring->xsk_umem)->headroom + 256U);
  #line 235 
  mask = (rx_ring->xsk_umem)->chunk_mask;
  #line 237 
  nta = rx_ring->__anonCompField_ixgbe_ring_223.next_to_alloc;
  #line 238 
  bi = rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info;
  #line 240 
  nta = (u16)((int)nta + 1);
  #line 241 
  if ((int)rx_ring->count > (int)nta) 
                                      #line 241 
                                      rx_ring->__anonCompField_ixgbe_ring_223.next_to_alloc = nta; else 
                                                                    #line 241 
                                                                    rx_ring->__anonCompField_ixgbe_ring_223.next_to_alloc = (unsigned short)0U;
  #line 243 
  handle = (unsigned long)((unsigned long long)handle & mask);
  #line 245 
  bi->dma = xdp_umem_get_dma(rx_ring->xsk_umem,(unsigned long long)handle);
  #line 246 
  bi->dma += hr;
  #line 248 
  bi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_219.addr = (void *)xdp_umem_get_data(rx_ring->xsk_umem,(unsigned long long)handle);
  #line 249 
  bi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_219.addr += hr;
  #line 251 
  bi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_219.handle = xsk_umem_adjust_offset(rx_ring->xsk_umem,(unsigned long long)handle,(unsigned long long)(rx_ring->xsk_umem)->headroom);
  #line 253 
  return;
}

#line 255  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
static bool ixgbe_alloc_buffer_zc(struct ixgbe_ring *rx_ring, struct ixgbe_rx_buffer *bi)
{
  #line 260 
  u64 handle;
  #line 260 
  u64 hr;
  #line 258 
  struct xdp_umem *umem = rx_ring->xsk_umem;
  #line 259 
  void *addr = bi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_219.addr;
  #line 262 
  if (addr != (void *)0) 
                         #line 263 
                         return (_Bool)1;
  #line 265 
  if (xsk_umem_peek_addr(umem,& handle) == (u64 *)0ULL) {
    #line 266 
    (rx_ring->__anonCompField_ixgbe_ring_224.rx_stats.alloc_rx_page_failed) ++;
    #line 267 
    return (_Bool)0;
  }
  #line 270 
  hr = (unsigned long long)(umem->headroom + 256U);
  #line 272 
  bi->dma = xdp_umem_get_dma(umem,handle);
  #line 273 
  bi->dma += hr;
  #line 275 
  bi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_219.addr = (void *)xdp_umem_get_data(umem,handle);
  #line 276 
  bi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_219.addr += hr;
  #line 278 
  bi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_219.handle = xsk_umem_adjust_offset(umem,handle,(unsigned long long)umem->headroom);
  #line 280 
  xsk_umem_discard_addr(umem);
  #line 281 
  return (_Bool)1;
}

#line 284  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
static bool ixgbe_alloc_buffer_slow_zc(struct ixgbe_ring *rx_ring, struct ixgbe_rx_buffer *bi)
{
  #line 288 
  u64 handle;
  #line 288 
  u64 hr;
  #line 287 
  struct xdp_umem *umem = rx_ring->xsk_umem;
  #line 290 
  if (xsk_umem_peek_addr_rq(umem,& handle) == (u64 *)0ULL) {
    #line 291 
    (rx_ring->__anonCompField_ixgbe_ring_224.rx_stats.alloc_rx_page_failed) ++;
    #line 292 
    return (_Bool)0;
  }
  #line 295 
  handle = (rx_ring->xsk_umem)->chunk_mask & handle;
  #line 297 
  hr = (unsigned long long)(umem->headroom + 256U);
  #line 299 
  bi->dma = xdp_umem_get_dma(umem,handle);
  #line 300 
  bi->dma += hr;
  #line 302 
  bi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_219.addr = (void *)xdp_umem_get_data(umem,handle);
  #line 303 
  bi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_219.addr += hr;
  #line 305 
  bi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_219.handle = xsk_umem_adjust_offset(umem,handle,(unsigned long long)umem->headroom);
  #line 307 
  xsk_umem_discard_addr_rq(umem);
  #line 308 
  return (_Bool)1;
}

#line 312  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
__inline static bool __ixgbe_alloc_rx_buffers_zc(struct ixgbe_ring *rx_ring, u16 cleaned_count, bool (*alloc)(struct ixgbe_ring *, struct ixgbe_rx_buffer *))
{
  #line 316 
  union ixgbe_adv_rx_desc *rx_desc;
  #line 317 
  struct ixgbe_rx_buffer *bi;
  #line 318 
  u16 i = rx_ring->next_to_use;
  #line 319 
  bool ok = (_Bool)1;
  #line 322 
  if ((unsigned int)cleaned_count == 0U) 
                                         #line 323 
                                         return (_Bool)1;
  #line 325 
  rx_desc = (union ixgbe_adv_rx_desc *)rx_ring->desc + (unsigned long)i;
  #line 326 
  bi = rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info + (unsigned long)i;
  #line 327 
  i = (unsigned short)((int)i - (int)rx_ring->count);
  #line 329 
  while (1) {
    {
      #line 330 
      if (! (*alloc)(rx_ring,bi)) {
        #line 331 
        ok = (_Bool)0;
        #line 332 
        break;
      }
      #line 336 
      dma_sync_single_range_for_device(rx_ring->dev,bi->dma,(unsigned long)bi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_218.page_offset,(unsigned long)rx_ring->rx_buf_len,(enum dma_data_direction)DMA_BIDIRECTIONAL);
      #line 344 
      rx_desc->read.pkt_addr = bi->dma;
      #line 346 
      rx_desc ++;
      #line 347 
      bi ++;
      #line 348 
      i = (u16)((int)i + 1);
      #line 349 
      if ((long)((unsigned int)i == 0U) != 0L) {
        #line 350 
        rx_desc = (union ixgbe_adv_rx_desc *)rx_ring->desc;
        #line 351 
        bi = rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info;
        #line 352 
        i = (unsigned short)((int)i - (int)rx_ring->count);
      }
      #line 356 
      rx_desc->wb.upper.length = (unsigned short)0U;
      #line 358 
      cleaned_count = (u16)((int)cleaned_count - 1);
    }
    #line 359 
    if (! ((unsigned int)cleaned_count != 0U)) 
                                               #line 329 
                                               break;
  }
  #line 361 
  i = (unsigned short)((int)rx_ring->count + (int)i);
  #line 363 
  if ((int)rx_ring->next_to_use != (int)i) {
    #line 364 
    rx_ring->next_to_use = i;
    #line 367 
    rx_ring->__anonCompField_ixgbe_ring_223.next_to_alloc = i;
    #line 368 
    ldv_inline_asm();
    #line 375 
    writel((unsigned int)i,(void *)rx_ring->tail);
  }
  #line 378 
  return ok;
}

#line 381  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
void ixgbe_alloc_rx_buffers_zc(struct ixgbe_ring *rx_ring, u16 count)
{
  #line 383 
  __ixgbe_alloc_rx_buffers_zc(rx_ring,(unsigned short)((int)count),& ixgbe_alloc_buffer_slow_zc);
  #line 385 
  return;
}

#line 387  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
static bool ixgbe_alloc_rx_buffers_fast_zc(struct ixgbe_ring *rx_ring, u16 count)
{
  #line 390 
  return __ixgbe_alloc_rx_buffers_zc(rx_ring,(unsigned short)((int)count),
                                  & ixgbe_alloc_buffer_zc);
}

#line 394  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
static struct sk_buff *ixgbe_construct_skb_zc(struct ixgbe_ring *rx_ring, struct ixgbe_rx_buffer *bi, struct xdp_buff *xdp)
{
  #line 400 
  struct sk_buff *skb;
  #line 398 
  unsigned int metasize = (unsigned int)(xdp->data - xdp->data_meta);
  #line 399 
  unsigned int datasize = (unsigned int)(xdp->data_end - xdp->data);
  #line 403 
  skb = __napi_alloc_skb(& (rx_ring->q_vector)->napi,(unsigned int)(xdp->data_end - xdp->data_hard_start),10784U);
  #line 406 
  if ((long)(skb == (struct sk_buff *)0) != 0L) 
                                                #line 407 
                                                return (struct sk_buff *)0;
  #line 409 
  skb_reserve(skb,(int)(xdp->data - xdp->data_hard_start));
  #line 410 
  ;
  #line 410 
  ;
  #line 410 
  memcpy(__skb_put(skb,datasize),xdp->data,(unsigned long)datasize);
  #line 411 
  if (metasize != 0U) 
                      #line 412 
                      skb_metadata_set(skb,(unsigned char)((int)((unsigned char)metasize)));
  #line 414 
  ixgbe_reuse_rx_buffer_zc(rx_ring,bi);
  #line 415 
  return skb;
}

#line 418  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
static void ixgbe_inc_ntc(struct ixgbe_ring *rx_ring)
{
  #line 420 
  u32 ntc = (unsigned int)((int)rx_ring->next_to_clean + 1);
  #line 422 
  if ((unsigned int)rx_ring->count > ntc) 
                                          #line 422 
                                          ntc = ntc; else 
                                                          #line 422 
                                                          ntc = 0U;
  #line 423 
  rx_ring->next_to_clean = (unsigned short)ntc;
  #line 424 
  __builtin_prefetch((void const *)((void *)((union ixgbe_adv_rx_desc *)rx_ring->desc + (unsigned long)ntc)));
  #line 425 
  return;
}

#line 427  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
int ixgbe_clean_rx_irq_zc(struct ixgbe_q_vector *q_vector, struct ixgbe_ring *rx_ring, int budget)
{
  #line 434 
  unsigned int xdp_res;
  #line 436 
  struct sk_buff *skb;
  #line 437 
  struct xdp_buff xdp;
  #line 557 
  int tmp_13;
  #line 431 
  unsigned int total_rx_bytes = 0U;
  #line 431 
  unsigned int total_rx_packets = 0U;
  #line 432 
  struct ixgbe_adapter *adapter = q_vector->adapter;
  #line 433 
  u16 cleaned_count = ixgbe_desc_unused(rx_ring);
  #line 434 
  unsigned int xdp_xmit = 0U;
  #line 435 
  bool failure = (_Bool)0;
  #line 439 
  xdp.rxq = & rx_ring->xdp_rxq;
  #line 441 
  while ((long)(total_rx_packets < (unsigned int)budget) != 0L) {
    #line 442 
    union ixgbe_adv_rx_desc *rx_desc;
    #line 443 
    struct ixgbe_rx_buffer *bi;
    #line 444 
    unsigned int size;
    #line 447 
    if ((unsigned int)cleaned_count > 15U) {
      #line 448 
      int tmp_1;
      #line 448 
      if ((int)failure != 0) 
                             #line 448 
                             tmp_1 = 1;
      else {
        #line 449 
        if (ixgbe_alloc_rx_buffers_fast_zc(rx_ring,
                                       (unsigned short)((int)cleaned_count))) 
          #line 448 
          tmp_1 = 0; else 
                          #line 448 
                          tmp_1 = 1;
      }
      #line 448 
      failure = (_Bool)(tmp_1 != 0);
      #line 451 
      cleaned_count = (unsigned short)0U;
    }
    #line 454 
    rx_desc = (union ixgbe_adv_rx_desc *)rx_ring->desc + (unsigned long)rx_ring->next_to_clean;
    #line 455 
    size = (unsigned int)rx_desc->wb.upper.length;
    #line 456 
    if (size == 0U) 
                    #line 457 
                    break;
    #line 458 
    ldv_inline_asm();
    #line 465 
    bi = ixgbe_get_rx_buffer_zc(rx_ring,size);
    #line 467 
    if ((long)(ixgbe_test_staterr(rx_desc,2U) == 0U) != 0L) {
      #line 469 
      struct ixgbe_rx_buffer *next_bi;
      #line 471 
      ixgbe_reuse_rx_buffer_zc(rx_ring,bi);
      #line 472 
      ixgbe_inc_ntc(rx_ring);
      #line 473 
      next_bi = rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info + (unsigned long)rx_ring->next_to_clean;
      #line 475 
      next_bi->skb = (struct sk_buff *)ERR_PTR_0(-22L);
      #line 476 
      continue;
    }
    #line 479 
    if ((long)(bi->skb != (struct sk_buff *)0) != 0L) {
      #line 480 
      ixgbe_reuse_rx_buffer_zc(rx_ring,bi);
      #line 481 
      ixgbe_inc_ntc(rx_ring);
      #line 482 
      continue;
    }
    #line 485 
    xdp.data = bi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_219.addr;
    #line 486 
    xdp.data_meta = xdp.data;
    #line 487 
    xdp.data_hard_start = xdp.data + 18446744073709551360U;
    #line 488 
    xdp.data_end = xdp.data + (unsigned long)size;
    #line 489 
    xdp.handle = (unsigned long)bi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_219.handle;
    #line 491 
    xdp_res = (unsigned int)ixgbe_run_xdp_zc(adapter,rx_ring,& xdp);
    #line 493 
    if (xdp_res != 0U) {
      #line 494 
      if (((unsigned long)xdp_res & 6UL) != 0UL) {
        #line 495 
        xdp_xmit |= xdp_res;
        #line 496 
        bi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_219.addr = (void *)0;
        #line 497 
        bi->skb = (struct sk_buff *)0;
      }
      else 
           #line 499 
           ixgbe_reuse_rx_buffer_zc(rx_ring,bi);
      #line 501 
      total_rx_packets ++;
      #line 502 
      total_rx_bytes += size;
      #line 504 
      cleaned_count = (u16)((int)cleaned_count + 1);
      #line 505 
      ixgbe_inc_ntc(rx_ring);
      #line 506 
      continue;
    }
    #line 510 
    skb = ixgbe_construct_skb_zc(rx_ring,bi,& xdp);
    #line 511 
    if (skb == (struct sk_buff *)0) {
      #line 512 
      (rx_ring->__anonCompField_ixgbe_ring_224.rx_stats.alloc_rx_buff_failed) ++;
      #line 513 
      break;
    }
    #line 516 
    cleaned_count = (u16)((int)cleaned_count + 1);
    #line 517 
    ixgbe_inc_ntc(rx_ring);
    #line 519 
    if (eth_skb_pad(skb) != 0) 
                               #line 520 
                               continue;
    #line 522 
    total_rx_bytes = skb->len + total_rx_bytes;
    #line 523 
    total_rx_packets ++;
    #line 525 
    ixgbe_process_skb_fields(rx_ring,rx_desc,skb);
    #line 526 
    ixgbe_rx_skb(q_vector,skb);
  }
  #line 529 
  if (((unsigned long)xdp_xmit & 4UL) != 0UL) 
                                              #line 530 
                                              xdp_do_flush_map();
  #line 532 
  if (((unsigned long)xdp_xmit & 2UL) != 0UL) {
    #line 533 
    int pscr_ret__;
    #line 533 
    __this_cpu_preempt_check((char *)"read");
    {
      #line 533 
      void *__vpp_verify = (void *)0;
      #line 533 
      void *tmp_6 = __vpp_verify;
    }
    #line 533 
    switch (4UL) {
      #line 533 
      int pfo_ret__;
      #line 533 
      int pfo_ret___0;
      #line 533 
      int pfo_ret___1;
      #line 533 
      int pfo_ret___2;
      #line 533 
      case (unsigned long)1: 
                             #line 533 
      ;
      #line 533 
      switch (4UL) {
        #line 533 
        case (unsigned long)1: 
                               #line 533 
        ;
        #line 534 
        ldv_inline_asm();
        #line 533 
        break;
        #line 533 
        case (unsigned long)2: 
                               #line 533 
        ;
        #line 534 
        ldv_inline_asm();
        #line 533 
        break;
        #line 533 
        case (unsigned long)4: 
                               #line 533 
        ;
        #line 534 
        ldv_inline_asm();
        #line 533 
        break;
        #line 533 
        case (unsigned long)8: 
                               #line 533 
        ;
        #line 534 
        ldv_inline_asm();
        #line 533 
        break;
        #line 533 
        default: 
                 #line 533 
        ;
        #line 533 
        __bad_percpu_size();
      }
      #line 533 
      pscr_ret__ = pfo_ret__;
      #line 533 
      break;
      #line 533 
      case (unsigned long)2: 
                             #line 533 
      ;
      #line 533 
      switch (4UL) {
        #line 533 
        case (unsigned long)1: 
                               #line 533 
        ;
        #line 534 
        ldv_inline_asm();
        #line 533 
        break;
        #line 533 
        case (unsigned long)2: 
                               #line 533 
        ;
        #line 534 
        ldv_inline_asm();
        #line 533 
        break;
        #line 533 
        case (unsigned long)4: 
                               #line 533 
        ;
        #line 534 
        ldv_inline_asm();
        #line 533 
        break;
        #line 533 
        case (unsigned long)8: 
                               #line 533 
        ;
        #line 534 
        ldv_inline_asm();
        #line 533 
        break;
        #line 533 
        default: 
                 #line 533 
        ;
        #line 533 
        __bad_percpu_size();
      }
      #line 533 
      pscr_ret__ = pfo_ret___0;
      #line 533 
      break;
      #line 533 
      case (unsigned long)4: 
                             #line 533 
      ;
      #line 533 
      switch (4UL) {
        #line 533 
        case (unsigned long)1: 
                               #line 533 
        ;
        #line 534 
        ldv_inline_asm();
        #line 533 
        break;
        #line 533 
        case (unsigned long)2: 
                               #line 533 
        ;
        #line 534 
        ldv_inline_asm();
        #line 533 
        break;
        #line 533 
        case (unsigned long)4: 
                               #line 533 
        ;
        #line 534 
        ldv_inline_asm();
        #line 533 
        break;
        #line 533 
        case (unsigned long)8: 
                               #line 533 
        ;
        #line 534 
        ldv_inline_asm();
        #line 533 
        break;
        #line 533 
        default: 
                 #line 533 
        ;
        #line 533 
        __bad_percpu_size();
      }
      #line 533 
      pscr_ret__ = pfo_ret___1;
      #line 533 
      break;
      #line 533 
      case (unsigned long)8: 
                             #line 533 
      ;
      #line 533 
      switch (4UL) {
        #line 533 
        case (unsigned long)1: 
                               #line 533 
        ;
        #line 534 
        ldv_inline_asm();
        #line 533 
        break;
        #line 533 
        case (unsigned long)2: 
                               #line 533 
        ;
        #line 534 
        ldv_inline_asm();
        #line 533 
        break;
        #line 533 
        case (unsigned long)4: 
                               #line 533 
        ;
        #line 534 
        ldv_inline_asm();
        #line 533 
        break;
        #line 533 
        case (unsigned long)8: 
                               #line 533 
        ;
        #line 534 
        ldv_inline_asm();
        #line 533 
        break;
        #line 533 
        default: 
                 #line 533 
        ;
        #line 533 
        __bad_percpu_size();
      }
      #line 533 
      pscr_ret__ = pfo_ret___2;
      #line 533 
      break;
      #line 533 
      default: 
               #line 533 
      ;
      #line 533 
      __bad_size_call_parameter();
      #line 533 
      break;
    }
    #line 533 
    struct ixgbe_ring *ring = adapter->xdp_ring[pscr_ret__];
    #line 536 
    ldv_inline_asm();
    #line 539 
    writel((unsigned int)ring->next_to_use,(void *)ring->tail);
  }
  #line 542 
  u64_stats_init(& rx_ring->syncp);
  #line 543 
  rx_ring->stats.packets += (unsigned long long)total_rx_packets;
  #line 544 
  rx_ring->stats.bytes += (unsigned long long)total_rx_bytes;
  #line 545 
  u64_stats_init(& rx_ring->syncp);
  #line 546 
  q_vector->rx.total_packets += total_rx_packets;
  #line 547 
  q_vector->rx.total_bytes += total_rx_bytes;
  #line 549 
  if ((int)xsk_umem_uses_need_wakeup(rx_ring->xsk_umem) != 0) {
    #line 550 
    if ((int)failure != 0 || (int)rx_ring->next_to_clean == (int)rx_ring->next_to_use) 
      #line 551 
      xsk_set_rx_need_wakeup(rx_ring->xsk_umem); else 
                                                      #line 553 
                                                      xsk_clear_rx_need_wakeup(rx_ring->xsk_umem);
    #line 555 
    return (int)total_rx_packets;
  }
  #line 557 
  if ((int)failure != 0) 
                         #line 557 
                         tmp_13 = budget; else 
                                               #line 557 
                                               tmp_13 = (int)total_rx_packets;
  #line 557 
  return tmp_13;
}

#line 560  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
void ixgbe_xsk_clean_rx_ring(struct ixgbe_ring *rx_ring)
{
  #line 562 
  u16 i = rx_ring->next_to_clean;
  #line 563 
  struct ixgbe_rx_buffer *bi = rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info + (unsigned long)i;
  #line 565 
  while ((int)rx_ring->__anonCompField_ixgbe_ring_223.next_to_alloc != (int)i) {
    #line 566 
    xsk_umem_fq_reuse(rx_ring->xsk_umem,bi->__anonCompField_ixgbe_rx_buffer_220.__anonCompField___anonunion_2620_219.handle);
    #line 567 
    i = (u16)((int)i + 1);
    #line 568 
    bi ++;
    #line 569 
    if ((int)rx_ring->count == (int)i) {
      #line 570 
      i = (unsigned short)0U;
      #line 571 
      bi = rx_ring->__anonCompField_ixgbe_ring_221.rx_buffer_info;
    }
  }
  #line 574 
  return;
}

#line 576  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
static bool ixgbe_xmit_zc(struct ixgbe_ring *xdp_ring, unsigned int budget)
{
  #line 579 
  struct ixgbe_tx_buffer *tx_bi;
  #line 581 
  struct xdp_desc desc;
  #line 582 
  dma_addr_t dma;
  #line 583 
  u32 cmd_type;
  #line 578 
  union ixgbe_adv_tx_desc *tx_desc = (union ixgbe_adv_tx_desc *)0;
  #line 580 
  bool work_done = (_Bool)1;
  #line 585 
  while (1) {
    #line 585 
    unsigned int tmp_2;
    #line 585 
    tmp_2 = budget;
    #line 585 
    budget --;
    #line 585 
    ;
    #line 585 
    if (! (tmp_2 != 0U)) 
                         #line 585 
                         break;
    {
      #line 586 
      if ((long)((unsigned int)ixgbe_desc_unused(xdp_ring) == 0U) != 0L) 
        #line 586 
        goto _LOR;
      else {
        #line 587 
        if (! netif_carrier_ok(xdp_ring->netdev)) {
          #line 586 
          _LOR: {
                  #line 588 
                  work_done = (_Bool)0;
                  #line 589 
                  break;
                }
        }
      }
      #line 592 
      if (! xsk_umem_consume_tx(xdp_ring->xsk_umem,& desc)) 
                                                            #line 593 
                                                            break;
      #line 595 
      dma = xdp_umem_get_dma(xdp_ring->xsk_umem,desc.addr);
      #line 597 
      dma_sync_single_for_device(xdp_ring->dev,dma,(unsigned long)desc.len,(enum dma_data_direction)DMA_BIDIRECTIONAL);
      #line 600 
      tx_bi = xdp_ring->__anonCompField_ixgbe_ring_221.tx_buffer_info + (unsigned long)xdp_ring->next_to_use;
      #line 601 
      tx_bi->bytecount = desc.len;
      #line 602 
      tx_bi->__anonCompField_ixgbe_tx_buffer_217.xdpf = (struct xdp_frame *)0;
      #line 603 
      tx_bi->gso_segs = (unsigned short)1U;
      #line 605 
      tx_desc = (union ixgbe_adv_tx_desc *)xdp_ring->desc + (unsigned long)xdp_ring->next_to_use;
      #line 606 
      tx_desc->read.buffer_addr = dma;
      #line 609 
      cmd_type = 573571072U;
      #line 612 
      cmd_type = (desc.len | cmd_type) | 150994944U;
      #line 613 
      tx_desc->read.cmd_type_len = cmd_type;
      #line 614 
      tx_desc->read.olinfo_status = desc.len << 14;
      #line 617 
      xdp_ring->next_to_use = (u16)((int)xdp_ring->next_to_use + 1);
      #line 618 
      if ((int)xdp_ring->next_to_use == (int)xdp_ring->count) 
                                                              #line 619 
                                                              xdp_ring->next_to_use = (unsigned short)0U;
    }
  }
  #line 622 
  if (tx_desc != (union ixgbe_adv_tx_desc *)0) {
    #line 623 
    ixgbe_xdp_ring_update_tail(xdp_ring);
    #line 624 
    xsk_umem_consume_tx_done(xdp_ring->xsk_umem);
  }
  #line 627 
  return (_Bool)((budget != 0U && (int)work_done != 0) != 0);
}

#line 630  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
static void ixgbe_clean_xdp_tx_buffer(struct ixgbe_ring *tx_ring, struct ixgbe_tx_buffer *tx_bi)
{
  #line 633 
  xdp_return_frame(tx_bi->__anonCompField_ixgbe_tx_buffer_217.xdpf);
  #line 634 
  dma_unmap_single_attrs(tx_ring->dev,tx_bi->dma,(unsigned long)tx_bi->len,(enum dma_data_direction)DMA_TO_DEVICE,0UL);
  #line 637 
  tx_bi->len = 0U;
  #line 638 
  return;
}

#line 640  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
bool ixgbe_clean_xdp_tx_irq(struct ixgbe_q_vector *q_vector, struct ixgbe_ring *tx_ring, int napi_budget)
{
  #line 646 
  union ixgbe_adv_tx_desc *tx_desc;
  #line 647 
  struct ixgbe_tx_buffer *tx_bi;
  #line 643 
  u16 ntc = tx_ring->next_to_clean;
  #line 643 
  u16 ntu = tx_ring->next_to_use;
  #line 644 
  unsigned int total_packets = 0U;
  #line 644 
  unsigned int total_bytes = 0U;
  #line 645 
  struct xdp_umem *umem = tx_ring->xsk_umem;
  #line 648 
  u32 xsk_frames = 0U;
  #line 650 
  tx_bi = tx_ring->__anonCompField_ixgbe_ring_221.tx_buffer_info + (unsigned long)ntc;
  #line 651 
  tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc + (unsigned long)ntc;
  #line 653 
  while ((int)ntc != (int)ntu) {
    #line 654 
    if ((tx_desc->wb.status & 1U) == 0U) 
                                         #line 655 
                                         break;
    #line 657 
    total_bytes = tx_bi->bytecount + total_bytes;
    #line 658 
    total_packets = (unsigned int)tx_bi->gso_segs + total_packets;
    #line 660 
    if (tx_bi->__anonCompField_ixgbe_tx_buffer_217.xdpf != (struct xdp_frame *)0) 
      #line 661 
      ixgbe_clean_xdp_tx_buffer(tx_ring,tx_bi); else 
                                                     #line 663 
                                                     xsk_frames ++;
    #line 665 
    tx_bi->__anonCompField_ixgbe_tx_buffer_217.xdpf = (struct xdp_frame *)0;
    #line 667 
    tx_bi ++;
    #line 668 
    tx_desc ++;
    #line 669 
    ntc = (u16)((int)ntc + 1);
    #line 670 
    if ((long)((int)tx_ring->count == (int)ntc) != 0L) {
      #line 671 
      ntc = (unsigned short)0U;
      #line 672 
      tx_bi = tx_ring->__anonCompField_ixgbe_ring_221.tx_buffer_info;
      #line 673 
      tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc;
    }
    #line 677 
    __builtin_prefetch((void const *)((void *)tx_desc));
  }
  #line 680 
  tx_ring->next_to_clean = ntc;
  #line 682 
  u64_stats_init(& tx_ring->syncp);
  #line 683 
  tx_ring->stats.bytes += (unsigned long long)total_bytes;
  #line 684 
  tx_ring->stats.packets += (unsigned long long)total_packets;
  #line 685 
  u64_stats_init(& tx_ring->syncp);
  #line 686 
  q_vector->tx.total_bytes += total_bytes;
  #line 687 
  q_vector->tx.total_packets += total_packets;
  #line 689 
  if (xsk_frames != 0U) 
                        #line 690 
                        xsk_umem_complete_tx(umem,xsk_frames);
  #line 692 
  if ((int)xsk_umem_uses_need_wakeup(tx_ring->xsk_umem) != 0) 
                                                              #line 693 
                                                              xsk_set_tx_need_wakeup(tx_ring->xsk_umem);
  #line 695 
  return ixgbe_xmit_zc(tx_ring,(unsigned int)q_vector->tx.work_limit);
}

#line 698  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
int ixgbe_xsk_wakeup(struct net_device *dev, u32 qid, u32 flags)
{
  #line 707 
  union __anonunion___u_17106 __u;
  #line 701 
  struct ixgbe_ring *ring;
  #line 700 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 703 
  if ((int)test_bit(2L,& adapter->state) != 0) 
                                               #line 704 
                                               return -100;
  #line 706 
  __read_once_size((void *)(& adapter->xdp_prog),(void *)(& __u.__c),8);
  #line 706 
  if ((__u.__val) == (struct bpf_prog *)0) 
                                           #line 707 
                                           return -6;
  #line 709 
  if ((unsigned int)adapter->num_xdp_queues <= qid) 
                                                    #line 710 
                                                    return -6;
  #line 712 
  ring = adapter->xdp_ring[qid];
  #line 714 
  if ((int)test_bit(10L,& ring->state) != 0) 
                                             #line 715 
                                             return -100;
  #line 717 
  if (ring->xsk_umem == (struct xdp_umem *)0) 
                                              #line 718 
                                              return -6;
  #line 720 
  if (! napi_if_scheduled_mark_missed(& (ring->q_vector)->napi)) {
    #line 721 
    u64 eics = 1ULL << (int)(ring->q_vector)->v_idx;
    #line 723 
    ixgbe_irq_rearm_queues(adapter,eics);
  }
  #line 726 
  return 0;
}

#line 729  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c"
void ixgbe_xsk_clean_tx_ring(struct ixgbe_ring *tx_ring)
{
  #line 733 
  struct ixgbe_tx_buffer *tx_bi;
  #line 731 
  u16 ntc = tx_ring->next_to_clean;
  #line 731 
  u16 ntu = tx_ring->next_to_use;
  #line 732 
  struct xdp_umem *umem = tx_ring->xsk_umem;
  #line 734 
  u32 xsk_frames = 0U;
  #line 736 
  while ((int)ntc != (int)ntu) {
    #line 737 
    tx_bi = tx_ring->__anonCompField_ixgbe_ring_221.tx_buffer_info + (unsigned long)ntc;
    #line 739 
    if (tx_bi->__anonCompField_ixgbe_tx_buffer_217.xdpf != (struct xdp_frame *)0) 
      #line 740 
      ixgbe_clean_xdp_tx_buffer(tx_ring,tx_bi); else 
                                                     #line 742 
                                                     xsk_frames ++;
    #line 744 
    tx_bi->__anonCompField_ixgbe_tx_buffer_217.xdpf = (struct xdp_frame *)0;
    #line 746 
    ntc = (u16)((int)ntc + 1);
    #line 747 
    if ((int)tx_ring->count == (int)ntc) 
                                         #line 748 
                                         ntc = (unsigned short)0U;
  }
  #line 751 
  if (xsk_frames != 0U) 
                        #line 752 
                        xsk_umem_complete_tx(umem,xsk_frames);
  #line 753 
  return;
}

#line 121  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_xsk.i.aux"
static void cif_set_bit_4(long nr, unsigned long *addr)
{
  #line 124 
  ldv_set_bit(nr,addr);
  #line 125 
  return;
}

#line 128  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_xsk.i.aux"
static void cif_clear_bit_1(long nr, unsigned long *addr)
{
  #line 131 
  ldv_clear_bit(nr,addr);
  #line 132 
  return;
}

#line 205  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_xsk.i.aux"
static void *ERR_PTR_0(long error)
{
  #line 208 
  return ldv_err_ptr(error);
}

#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/find.h"
#line 156  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_dcb_nl.i.aux"
static unsigned long cif_find_first_bit(unsigned long *addr, unsigned long size);
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
#line 128  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_dcb_nl.i.aux"
static void cif_clear_bit_2(long nr, unsigned long *addr);
#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/find_bit.h"
#line 21 
unsigned long ldv_find_first_bit(unsigned long *addr, unsigned long size);
#line 542  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 451  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_dcb_nl.i.aux"
static void *kmalloc_1(size_t size, gfp_t flags);
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/dcbnl.h"
#line 21 
u8 dcb_getapp(struct net_device *, struct dcb_app *);
#line 22 
#line 22 
int dcb_ieee_setapp(struct net_device *, struct dcb_app *);
#line 23 
#line 23 
int dcb_ieee_delapp(struct net_device *, struct dcb_app *);
#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static void ixgbe_write_reg_15(struct ixgbe_hw *hw, u32 reg, u32 value)
{
  #line 147 
  union __anonunion___u_17826 __u;
  #line 146 
  __read_once_size((void *)(& hw->hw_addr),(void *)(& __u.__c),8);
  #line 146 
  u8 *reg_addr = (__u.__val);
  #line 148 
  if ((int)ixgbe_removed((void *)reg_addr) != 0) 
                                                 #line 149 
                                                 return;
  #line 150 
  writel(value,(void *)(reg_addr + (unsigned long)reg));
  #line 151 
  return;
}

#line 41  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.h"
__inline static void ixgbe_set_vmvir_0(struct ixgbe_adapter *adapter, u16 vid, u16 qos, u32 vf)
{
  #line 44 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 45 
  u32 vmvir = (unsigned int)(((int)vid | ((int)qos << 13)) | 1073741824);
  #line 47 
  ixgbe_write_reg_15(hw,(vf + 8192U) * 4U,vmvir);
  #line 48 
  return;
}

#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_copy_dcb_cfg(struct ixgbe_adapter *adapter, int tc_max)
{
  #line 29 
  int i;
  #line 29 
  int j;
  #line 25 
  struct ixgbe_dcb_config *scfg = & adapter->temp_dcb_cfg;
  #line 26 
  struct ixgbe_dcb_config *dcfg = & adapter->dcb_cfg;
  #line 27 
  struct tc_configuration *src = (struct tc_configuration *)0;
  #line 28 
  struct tc_configuration *dst = (struct tc_configuration *)0;
  #line 30 
  int tx = 0;
  #line 31 
  int rx = 1;
  #line 32 
  int changes = 0;
  #line 34 
  struct dcb_app app = {.selector = (unsigned char)0U, .priority = (unsigned char)0, .protocol = (unsigned short)35078U};
  #line 38 
  u8 up = dcb_getapp(adapter->netdev,& app);
  #line 40 
  if ((unsigned int)up != 0U && (((unsigned long)up >> (int)adapter->fcoe.up) & 1UL) == 0UL) 
    #line 41 
    changes |= 16;
  #line 44 
  i = 1;
  #line 44 
  while (tc_max >= i) {
    #line 45 
    src = & scfg->tc_config[i + -1];
    #line 46 
    dst = & dcfg->tc_config[i + -1];
    #line 48 
    if (dst->path[tx].prio_type != src->path[tx].prio_type) {
      #line 49 
      dst->path[tx].prio_type = src->path[tx].prio_type;
      #line 50 
      changes |= 8;
    }
    #line 53 
    if ((int)dst->path[tx].bwg_id != (int)src->path[tx].bwg_id) {
      #line 54 
      dst->path[tx].bwg_id = src->path[tx].bwg_id;
      #line 55 
      changes |= 8;
    }
    #line 58 
    if ((int)dst->path[tx].bwg_percent != (int)src->path[tx].bwg_percent) {
      #line 59 
      dst->path[tx].bwg_percent = src->path[tx].bwg_percent;
      #line 60 
      changes |= 8;
    }
    #line 63 
    if ((int)dst->path[tx].up_to_tc_bitmap != (int)src->path[tx].up_to_tc_bitmap) {
      #line 65 
      dst->path[tx].up_to_tc_bitmap = src->path[tx].up_to_tc_bitmap;
      #line 67 
      changes |= 26;
    }
    #line 70 
    if (dst->path[rx].prio_type != src->path[rx].prio_type) {
      #line 71 
      dst->path[rx].prio_type = src->path[rx].prio_type;
      #line 72 
      changes |= 4;
    }
    #line 75 
    if ((int)dst->path[rx].bwg_id != (int)src->path[rx].bwg_id) {
      #line 76 
      dst->path[rx].bwg_id = src->path[rx].bwg_id;
      #line 77 
      changes |= 4;
    }
    #line 80 
    if ((int)dst->path[rx].bwg_percent != (int)src->path[rx].bwg_percent) {
      #line 81 
      dst->path[rx].bwg_percent = src->path[rx].bwg_percent;
      #line 82 
      changes |= 4;
    }
    #line 85 
    if ((int)dst->path[rx].up_to_tc_bitmap != (int)src->path[rx].up_to_tc_bitmap) {
      #line 87 
      dst->path[rx].up_to_tc_bitmap = src->path[rx].up_to_tc_bitmap;
      #line 89 
      changes |= 22;
    }
    #line 44 
    i ++;
  }
  #line 93 
  i = 11;
  #line 93 
  while (i <= 18) {
    #line 94 
    j = i + -11;
    #line 95 
    if ((int)dcfg->bw_percentage[tx][j] != (int)scfg->bw_percentage[tx][j]) {
      #line 96 
      dcfg->bw_percentage[tx][j] = scfg->bw_percentage[tx][j];
      #line 97 
      changes |= 8;
    }
    #line 99 
    if ((int)dcfg->bw_percentage[rx][j] != (int)scfg->bw_percentage[rx][j]) {
      #line 100 
      dcfg->bw_percentage[rx][j] = scfg->bw_percentage[rx][j];
      #line 101 
      changes |= 4;
    }
    #line 93 
    i ++;
  }
  #line 105 
  i = 1;
  #line 105 
  while (i <= 8) {
    #line 106 
    j = i + -1;
    #line 107 
    if (dcfg->tc_config[j].dcb_pfc != scfg->tc_config[j].dcb_pfc) {
      #line 108 
      dcfg->tc_config[j].dcb_pfc = scfg->tc_config[j].dcb_pfc;
      #line 109 
      changes |= 2;
    }
    #line 105 
    i ++;
  }
  #line 113 
  if ((int)dcfg->pfc_mode_enable != (int)scfg->pfc_mode_enable) {
    #line 114 
    dcfg->pfc_mode_enable = scfg->pfc_mode_enable;
    #line 115 
    changes |= 2;
  }
  #line 118 
  return changes;
}

#line 121  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static u8 ixgbe_dcbnl_get_state(struct net_device *netdev)
{
  #line 123 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 125 
  return (unsigned char)(((unsigned long)adapter->flags & 4096UL) != 0UL);
}

#line 128  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static u8 ixgbe_dcbnl_set_state(struct net_device *netdev, u8 state)
{
  #line 140 
  int tmp_0;
  #line 130 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 133 
  if (((int)adapter->dcbx_cap & 4) == 0) 
                                         #line 134 
                                         return (unsigned char)1U;
  #line 137 
  if (((unsigned int)state != 0U) ^ (((unsigned long)adapter->flags & 4096UL) == 0UL)) 
    #line 138 
    return (unsigned char)0U;
  #line 140 
  if ((unsigned int)state != 0U) 
                                 #line 140 
                                 tmp_0 = (int)adapter->dcb_cfg.num_tcs.pg_tcs; else 
                                                                    #line 140 
                                                                    tmp_0 = 0;
  #line 140 
  ;
  #line 140 
  return (unsigned char)(ixgbe_setup_tc(netdev,(unsigned char)tmp_0) != 0);
}

#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_get_perm_hw_addr(struct net_device *netdev, u8 *perm_addr)
{
  #line 148 
  int i;
  #line 148 
  int j;
  #line 147 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 150 
  memset((void *)perm_addr,255,32UL);
  #line 152 
  i = 0;
  #line 152 
  while ((int)netdev->addr_len > i) {
    #line 153 
    *(perm_addr + (unsigned long)i) = adapter->hw.mac.perm_addr[i];
    #line 152 
    i ++;
  }
  #line 155 
  switch ((unsigned int)adapter->hw.mac.type) {
    #line 156 
    case (unsigned int)2: 
                          #line 156 
    ;
    #line 157 
    case (unsigned int)3: 
                          #line 157 
    ;
    #line 158 
    case (unsigned int)4: 
                          #line 158 
    ;
    #line 159 
    j = 0;
    #line 159 
    while ((int)netdev->addr_len > j) {
      #line 160 
      *(perm_addr + (unsigned long)i) = adapter->hw.mac.san_addr[j];
      #line 159 
      j ++;
      #line 159 
      i ++;
    }
    #line 161 
    break;
    #line 162 
    default: 
             #line 162 
    ;
    #line 163 
    break;
  }
  #line 165 
  return;
}

#line 167  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_set_pg_tc_cfg_tx(struct net_device *netdev, int tc, u8 prio, u8 bwg_id, u8 bw_pct, u8 up_map)
{
  #line 171 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 173 
  if ((unsigned int)prio != 255U) 
                                  #line 174 
                                  adapter->temp_dcb_cfg.tc_config[tc].path[0].prio_type = (enum strict_prio_type)prio;
  #line 175 
  if ((unsigned int)bwg_id != 255U) 
                                    #line 176 
                                    adapter->temp_dcb_cfg.tc_config[tc].path[0].bwg_id = bwg_id;
  #line 177 
  if ((unsigned int)bw_pct != 255U) 
                                    #line 178 
                                    adapter->temp_dcb_cfg.tc_config[tc].path[0].bwg_percent = bw_pct;
  #line 180 
  if ((unsigned int)up_map != 255U) 
                                    #line 181 
                                    adapter->temp_dcb_cfg.tc_config[tc].path[0].up_to_tc_bitmap = up_map;
  #line 182 
  return;
}

#line 185  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_set_pg_bwg_cfg_tx(struct net_device *netdev, int bwg_id, u8 bw_pct)
{
  #line 188 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 190 
  adapter->temp_dcb_cfg.bw_percentage[0][bwg_id] = bw_pct;
  #line 191 
  return;
}

#line 193  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_set_pg_tc_cfg_rx(struct net_device *netdev, int tc, u8 prio, u8 bwg_id, u8 bw_pct, u8 up_map)
{
  #line 197 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 199 
  if ((unsigned int)prio != 255U) 
                                  #line 200 
                                  adapter->temp_dcb_cfg.tc_config[tc].path[1].prio_type = (enum strict_prio_type)prio;
  #line 201 
  if ((unsigned int)bwg_id != 255U) 
                                    #line 202 
                                    adapter->temp_dcb_cfg.tc_config[tc].path[1].bwg_id = bwg_id;
  #line 203 
  if ((unsigned int)bw_pct != 255U) 
                                    #line 204 
                                    adapter->temp_dcb_cfg.tc_config[tc].path[1].bwg_percent = bw_pct;
  #line 206 
  if ((unsigned int)up_map != 255U) 
                                    #line 207 
                                    adapter->temp_dcb_cfg.tc_config[tc].path[1].up_to_tc_bitmap = up_map;
  #line 208 
  return;
}

#line 211  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_set_pg_bwg_cfg_rx(struct net_device *netdev, int bwg_id, u8 bw_pct)
{
  #line 214 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 216 
  adapter->temp_dcb_cfg.bw_percentage[1][bwg_id] = bw_pct;
  #line 217 
  return;
}

#line 219  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_get_pg_tc_cfg_tx(struct net_device *netdev, int tc, u8 *prio, u8 *bwg_id, u8 *bw_pct, u8 *up_map)
{
  #line 223 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 225 
  *prio = (unsigned char)adapter->dcb_cfg.tc_config[tc].path[0].prio_type;
  #line 226 
  *bwg_id = adapter->dcb_cfg.tc_config[tc].path[0].bwg_id;
  #line 227 
  *bw_pct = adapter->dcb_cfg.tc_config[tc].path[0].bwg_percent;
  #line 228 
  *up_map = adapter->dcb_cfg.tc_config[tc].path[0].up_to_tc_bitmap;
  #line 229 
  return;
}

#line 231  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_get_pg_bwg_cfg_tx(struct net_device *netdev, int bwg_id, u8 *bw_pct)
{
  #line 234 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 236 
  *bw_pct = adapter->dcb_cfg.bw_percentage[0][bwg_id];
  #line 237 
  return;
}

#line 239  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_get_pg_tc_cfg_rx(struct net_device *netdev, int tc, u8 *prio, u8 *bwg_id, u8 *bw_pct, u8 *up_map)
{
  #line 243 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 245 
  *prio = (unsigned char)adapter->dcb_cfg.tc_config[tc].path[1].prio_type;
  #line 246 
  *bwg_id = adapter->dcb_cfg.tc_config[tc].path[1].bwg_id;
  #line 247 
  *bw_pct = adapter->dcb_cfg.tc_config[tc].path[1].bwg_percent;
  #line 248 
  *up_map = adapter->dcb_cfg.tc_config[tc].path[1].up_to_tc_bitmap;
  #line 249 
  return;
}

#line 251  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_get_pg_bwg_cfg_rx(struct net_device *netdev, int bwg_id, u8 *bw_pct)
{
  #line 254 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 256 
  *bw_pct = adapter->dcb_cfg.bw_percentage[1][bwg_id];
  #line 257 
  return;
}

#line 259  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_set_pfc_cfg(struct net_device *netdev, int priority, u8 setting)
{
  #line 262 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 264 
  adapter->temp_dcb_cfg.tc_config[priority].dcb_pfc = (enum dcb_pfc_type)setting;
  #line 265 
  if (adapter->temp_dcb_cfg.tc_config[priority].dcb_pfc != adapter->dcb_cfg.tc_config[priority].dcb_pfc) 
    #line 267 
    adapter->temp_dcb_cfg.pfc_mode_enable = (_Bool)1;
  #line 268 
  return;
}

#line 270  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_get_pfc_cfg(struct net_device *netdev, int priority, u8 *setting)
{
  #line 273 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 275 
  *setting = (unsigned char)adapter->dcb_cfg.tc_config[priority].dcb_pfc;
  #line 276 
  return;
}

#line 278  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_devreset(struct net_device *dev)
{
  #line 280 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 282 
  while (1) {
    #line 282 
    if (! ((int)test_and_set_bit(1L,& adapter->state) != 0)) 
                                                             #line 282 
                                                             break;
    #line 283 
    usleep_range(1000UL,2000UL);
  }
  #line 285 
  if ((int)netif_running(dev) != 0) 
                                    #line 286 
                                    (*((dev->netdev_ops)->ndo_stop))(dev);
  #line 288 
  ixgbe_clear_interrupt_scheme(adapter);
  #line 289 
  ixgbe_init_interrupt_scheme(adapter);
  #line 291 
  if ((int)netif_running(dev) != 0) 
                                    #line 292 
                                    (*((dev->netdev_ops)->ndo_open))(dev);
  #line 294 
  cif_clear_bit_2(1L,& adapter->state);
  #line 295 
  return;
}

#line 297  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static u8 ixgbe_dcbnl_set_all(struct net_device *netdev)
{
  #line 303 
  int i;
  #line 299 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 300 
  struct ixgbe_dcb_config *dcb_cfg = & adapter->dcb_cfg;
  #line 301 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 302 
  int ret = 1;
  #line 306 
  if (((int)adapter->dcbx_cap & 4) == 0) 
                                         #line 307 
                                         return (unsigned char)1U;
  #line 310 
  adapter->dcb_set_bitmap = (unsigned char)((int)adapter->dcb_set_bitmap | ixgbe_copy_dcb_cfg(adapter,8));
  #line 311 
  if ((unsigned int)adapter->dcb_set_bitmap == 0U) 
                                                   #line 312 
                                                   return (unsigned char)1U;
  #line 314 
  if (((int)adapter->dcb_set_bitmap & 12) != 0) {
    #line 315 
    u16 refill[8U];
    #line 315 
    u16 max[8U];
    #line 316 
    u8 bwg_id[8U];
    #line 316 
    u8 prio_type[8U];
    #line 318 
    u8 prio_tc[8U];
    #line 319 
    int max_frame = (int)((adapter->netdev)->mtu + 18U);
    #line 322 
    if (((adapter->netdev)->features & 68719476736ULL) != 0ULL) {
      #line 323 
      int __UNIQUE_ID___x443;
      #line 323 
      int tmp_1;
      {
        #line 323 
        __UNIQUE_ID___x443 = max_frame;
        #line 323 
        int __UNIQUE_ID___y444 = 3072;
        #line 323 
        if (__UNIQUE_ID___x443 > __UNIQUE_ID___y444) 
                                                     #line 323 
                                                     tmp_1 = __UNIQUE_ID___x443; else 
                                                                    #line 323 
                                                                    tmp_1 = __UNIQUE_ID___y444;
        }
      #line 323 
      max_frame = tmp_1;
    }
    #line 326 
    ixgbe_dcb_calculate_tc_credits(hw,dcb_cfg,max_frame,(unsigned char)0);
    #line 328 
    ixgbe_dcb_calculate_tc_credits(hw,dcb_cfg,max_frame,(unsigned char)1);
    #line 331 
    ixgbe_dcb_unpack_refill(dcb_cfg,0,(u16 *)(& refill));
    #line 332 
    ixgbe_dcb_unpack_max(dcb_cfg,(u16 *)(& max));
    #line 333 
    ixgbe_dcb_unpack_bwgid(dcb_cfg,0,(u8 *)(& bwg_id));
    #line 334 
    ixgbe_dcb_unpack_prio(dcb_cfg,0,(u8 *)(& prio_type));
    #line 335 
    ixgbe_dcb_unpack_map(dcb_cfg,0,(u8 *)(& prio_tc));
    #line 337 
    ixgbe_dcb_hw_ets_config(hw,(u16 *)(& refill),(u16 *)(& max),(u8 *)(& bwg_id),(u8 *)(& prio_type),(u8 *)(& prio_tc));
    #line 340 
    i = 0;
    #line 340 
    while (i <= 7) {
      #line 341 
      netdev_set_prio_tc_map(netdev,(unsigned char)((int)((unsigned char)i)),(unsigned char)((int)prio_tc[i]));
      #line 340 
      i ++;
    }
    #line 343 
    ret = 0;
  }
  #line 346 
  if (((int)adapter->dcb_set_bitmap & 2) != 0) {
    #line 347 
    if ((int)dcb_cfg->pfc_mode_enable != 0) {
      #line 348 
      u8 pfc_en;
      #line 349 
      u8 prio_tc_0[8U];
      #line 351 
      ixgbe_dcb_unpack_map(dcb_cfg,0,(u8 *)(& prio_tc_0));
      #line 352 
      ixgbe_dcb_unpack_pfc(dcb_cfg,& pfc_en);
      #line 353 
      ixgbe_dcb_hw_pfc_config(hw,(unsigned char)((int)pfc_en),(u8 *)(& prio_tc_0));
    }
    else 
         #line 355 
         (*(hw->mac.ops.fc_enable))(hw);
    #line 358 
    ixgbe_set_rx_drop_en(adapter);
    #line 360 
    ret = 2;
  }
  #line 368 
  if (((int)adapter->dcb_set_bitmap & 16) != 0) {
    #line 369 
    struct dcb_app app = {.selector = (unsigned char)0U, .priority = (unsigned char)0, .protocol = (unsigned short)35078U};
    #line 373 
    u8 up = dcb_getapp(netdev,& app);
    #line 375 
    adapter->fcoe.up = (unsigned char)((unsigned int)((unsigned char)ffs((int)up)) + 255U);
    #line 376 
    ixgbe_dcbnl_devreset(netdev);
    #line 377 
    ret = 0;
  }
  #line 381 
  adapter->dcb_set_bitmap = (unsigned char)0U;
  #line 382 
  return (unsigned char)ret;
}

#line 385  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static u8 ixgbe_dcbnl_getcap(struct net_device *netdev, int capid, u8 *cap)
{
  #line 387 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 389 
  switch (capid) {
    #line 390 
    case 2: 
            #line 390 
    ;
    #line 391 
    *cap = (unsigned char)1U;
    #line 392 
    break;
    #line 393 
    case 3: 
            #line 393 
    ;
    #line 394 
    *cap = (unsigned char)1U;
    #line 395 
    break;
    #line 396 
    case 4: 
            #line 396 
    ;
    #line 397 
    *cap = (unsigned char)0U;
    #line 398 
    break;
    #line 399 
    case 5: 
            #line 399 
    ;
    #line 400 
    *cap = (unsigned char)128U;
    #line 401 
    break;
    #line 402 
    case 6: 
            #line 402 
    ;
    #line 403 
    *cap = (unsigned char)128U;
    #line 404 
    break;
    #line 405 
    case 7: 
            #line 405 
    ;
    #line 406 
    *cap = (unsigned char)1U;
    #line 407 
    break;
    #line 408 
    case 8: 
            #line 408 
    ;
    #line 409 
    *cap = (unsigned char)0U;
    #line 410 
    break;
    #line 411 
    case 9: 
            #line 411 
    ;
    #line 412 
    *cap = adapter->dcbx_cap;
    #line 413 
    break;
    #line 414 
    default: 
             #line 414 
    ;
    #line 415 
    *cap = (unsigned char)0U;
    #line 416 
    break;
  }
  #line 419 
  return (unsigned char)0U;
}

#line 422  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_getnumtcs(struct net_device *netdev, int tcid, u8 *num)
{
  #line 424 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 426 
  if (((unsigned long)adapter->flags & 4096UL) != 0UL) 
    #line 427 
    switch (tcid) {
      #line 428 
      case 2: 
              #line 428 
      ;
      #line 429 
      *num = adapter->dcb_cfg.num_tcs.pg_tcs;
      #line 430 
      break;
      #line 431 
      case 3: 
              #line 431 
      ;
      #line 432 
      *num = adapter->dcb_cfg.num_tcs.pfc_tcs;
      #line 433 
      break;
      #line 434 
      default: 
               #line 434 
      ;
      #line 435 
      return -22;
    }
  else 
       #line 438 
       return -22;
  #line 441 
  return 0;
}

#line 444  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_setnumtcs(struct net_device *netdev, int tcid, u8 num)
{
  #line 446 
  return -22;
}

#line 449  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static u8 ixgbe_dcbnl_getpfcstate(struct net_device *netdev)
{
  #line 451 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 453 
  return (unsigned char)adapter->dcb_cfg.pfc_mode_enable;
}

#line 456  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_setpfcstate(struct net_device *netdev, u8 state)
{
  #line 458 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 460 
  adapter->temp_dcb_cfg.pfc_mode_enable = (_Bool)((unsigned int)state != 0U);
  #line 461 
  return;
}

#line 473  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_getapp(struct net_device *netdev, u8 idtype, u16 id)
{
  #line 475 
  struct ixgbe_adapter *adapter = netdev_priv(netdev);
  #line 476 
  struct dcb_app app = {.selector = idtype, .priority = (unsigned char)0, .protocol = id};
  #line 481 
  if (((int)adapter->dcbx_cap & 4) == 0) 
                                         #line 482 
                                         return -22;
  #line 484 
  return (int)dcb_getapp(netdev,& app);
}

#line 487  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_ieee_getets(struct net_device *dev, struct ieee_ets *ets)
{
  #line 490 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 491 
  struct ieee_ets *my_ets = adapter->ixgbe_ieee_ets;
  #line 493 
  ets->ets_cap = adapter->dcb_cfg.num_tcs.pg_tcs;
  #line 496 
  if (my_ets == (struct ieee_ets *)0) 
                                      #line 497 
                                      return 0;
  #line 499 
  ets->cbs = my_ets->cbs;
  #line 500 
  memcpy((void *)(& ets->tc_tx_bw),(void *)(& my_ets->tc_tx_bw),8UL);
  #line 501 
  memcpy((void *)(& ets->tc_rx_bw),(void *)(& my_ets->tc_rx_bw),8UL);
  #line 502 
  memcpy((void *)(& ets->tc_tsa),(void *)(& my_ets->tc_tsa),8UL);
  #line 503 
  memcpy((void *)(& ets->prio_tc),(void *)(& my_ets->prio_tc),8UL);
  #line 504 
  return 0;
}

#line 507  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_ieee_setets(struct net_device *dev, struct ieee_ets *ets)
{
  #line 512 
  int i;
  #line 512 
  int err;
  #line 510 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 511 
  int max_frame = (int)(dev->mtu + 18U);
  #line 513 
  __u8 max_tc = (unsigned char)0U;
  #line 514 
  __u8 map_chg = (unsigned char)0U;
  #line 516 
  if (((int)adapter->dcbx_cap & 8) == 0) 
                                         #line 517 
                                         return -22;
  #line 519 
  if (adapter->ixgbe_ieee_ets == (struct ieee_ets *)0) {
    #line 520 
    adapter->ixgbe_ieee_ets = (struct ieee_ets *)kmalloc_1(59UL,3264U);
    #line 522 
    if (adapter->ixgbe_ieee_ets == (struct ieee_ets *)0) 
                                                         #line 523 
                                                         return -12;
    #line 526 
    i = 0;
    #line 526 
    while (i <= 7) {
      #line 527 
      (adapter->ixgbe_ieee_ets)->prio_tc[i] = (unsigned char)8U;
      #line 526 
      i ++;
    }
    #line 530 
    ixgbe_dcb_read_rtrup2tc(& adapter->hw,(u8 *)(& (adapter->ixgbe_ieee_ets)->prio_tc));
  }
  #line 534 
  i = 0;
  #line 534 
  while (i <= 7) {
    #line 535 
    if ((int)ets->prio_tc[i] > (int)max_tc) 
                                            #line 536 
                                            max_tc = ets->prio_tc[i];
    #line 537 
    if ((int)ets->prio_tc[i] != (int)(adapter->ixgbe_ieee_ets)->prio_tc[i]) 
      #line 538 
      map_chg = (unsigned char)1U;
    #line 534 
    i ++;
  }
  #line 541 
  memcpy((void *)adapter->ixgbe_ieee_ets,(void *)ets,59UL);
  #line 543 
  if ((unsigned int)max_tc != 0U) 
                                  #line 544 
                                  max_tc = (__u8)((int)max_tc + 1);
  #line 546 
  if ((int)adapter->dcb_cfg.num_tcs.pg_tcs < (int)max_tc) 
                                                          #line 547 
                                                          return -22;
  #line 549 
  if ((int)adapter->hw_tcs != (int)max_tc) {
    #line 550 
    err = ixgbe_setup_tc(dev,(unsigned char)((int)max_tc));
    #line 551 
    if (err != 0) 
                  #line 552 
                  return err;
  }
  else 
    #line 553 
    if ((unsigned int)map_chg != 0U) 
                                     #line 554 
                                     ixgbe_dcbnl_devreset(dev);
  #line 557 
  return ixgbe_dcb_hw_ets(& adapter->hw,ets,max_frame);
}

#line 560  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_ieee_getpfc(struct net_device *dev, struct ieee_pfc *pfc)
{
  #line 565 
  int i;
  #line 563 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 564 
  struct ieee_pfc *my_pfc = adapter->ixgbe_ieee_pfc;
  #line 567 
  pfc->pfc_cap = adapter->dcb_cfg.num_tcs.pfc_tcs;
  #line 570 
  if (my_pfc == (struct ieee_pfc *)0) 
                                      #line 571 
                                      return 0;
  #line 573 
  pfc->pfc_en = my_pfc->pfc_en;
  #line 574 
  pfc->mbc = my_pfc->mbc;
  #line 575 
  pfc->delay = my_pfc->delay;
  #line 577 
  i = 0;
  #line 577 
  while (i <= 7) {
    #line 578 
    pfc->requests[i] = adapter->stats.pxoffrxc[i];
    #line 579 
    pfc->indications[i] = adapter->stats.pxofftxc[i];
    #line 577 
    i ++;
  }
  #line 582 
  return 0;
}

#line 585  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_ieee_setpfc(struct net_device *dev, struct ieee_pfc *pfc)
{
  #line 590 
  u8 *prio_tc;
  #line 591 
  int err;
  #line 588 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 589 
  struct ixgbe_hw *hw = & adapter->hw;
  #line 593 
  if (((int)adapter->dcbx_cap & 8) == 0) 
                                         #line 594 
                                         return -22;
  #line 596 
  if (adapter->ixgbe_ieee_pfc == (struct ieee_pfc *)0) {
    #line 597 
    adapter->ixgbe_ieee_pfc = (struct ieee_pfc *)kmalloc_1(136UL,3264U);
    #line 599 
    if (adapter->ixgbe_ieee_pfc == (struct ieee_pfc *)0) 
                                                         #line 600 
                                                         return -12;
  }
  #line 603 
  prio_tc = (u8 *)(& (adapter->ixgbe_ieee_ets)->prio_tc);
  #line 604 
  memcpy((void *)adapter->ixgbe_ieee_pfc,(void *)pfc,136UL);
  #line 607 
  if ((unsigned int)pfc->pfc_en != 0U) 
                                       #line 608 
                                       err = ixgbe_dcb_hw_pfc_config(hw,(unsigned char)((int)pfc->pfc_en),prio_tc); else 
                                                                    #line 610 
                                                                    err = (*(hw->mac.ops.fc_enable))(hw);
  #line 612 
  ixgbe_set_rx_drop_en(adapter);
  #line 614 
  return err;
}

#line 617  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_ieee_setapp(struct net_device *dev, struct dcb_app *app)
{
  #line 621 
  int err;
  #line 620 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 623 
  if (((int)adapter->dcbx_cap & 8) == 0) 
                                         #line 624 
                                         return -22;
  #line 626 
  err = dcb_ieee_setapp(dev,app);
  #line 627 
  if (err != 0) 
                #line 628 
                return err;
  #line 631 
  if ((unsigned int)app->selector == 1U && (unsigned int)app->protocol == 35078U) {
    #line 633 
    u8 app_mask = dcb_ieee_getapp_mask(dev,app);
    #line 635 
    if ((((unsigned long)app_mask >> (int)adapter->fcoe.up) & 1UL) != 0UL) 
      #line 636 
      return 0;
    #line 638 
    adapter->fcoe.up = app->priority;
    #line 639 
    ixgbe_dcbnl_devreset(dev);
  }
  #line 644 
  if ((unsigned int)app->selector == 1U && (unsigned int)app->protocol == 0U) {
    #line 646 
    int vf;
    #line 648 
    adapter->default_up = app->priority;
    #line 650 
    vf = 0;
    #line 650 
    while (adapter->num_vfs > (unsigned int)vf) {
      {
        #line 651 
        struct vf_data_storage *vfinfo = adapter->vfinfo + (unsigned long)vf;
        #line 653 
        if ((unsigned int)vfinfo->pf_qos == 0U) 
                                                #line 654 
                                                ixgbe_set_vmvir_0(adapter,(unsigned short)((int)vfinfo->pf_vlan),(unsigned short)((int)app->priority),(unsigned int)vf);
      }
      #line 650 
      vf ++;
    }
  }
  #line 659 
  return 0;
}

#line 662  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_ieee_delapp(struct net_device *dev, struct dcb_app *app)
{
  #line 666 
  int err;
  #line 665 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 668 
  if (((int)adapter->dcbx_cap & 8) == 0) 
                                         #line 669 
                                         return -22;
  #line 671 
  err = dcb_ieee_delapp(dev,app);
  #line 674 
  if ((err == 0 && (unsigned int)app->selector == 1U) && (unsigned int)app->protocol == 35078U) {
    #line 676 
    u8 app_mask = dcb_ieee_getapp_mask(dev,app);
    #line 678 
    if ((((unsigned long)app_mask >> (int)adapter->fcoe.up) & 1UL) != 0UL) 
      #line 679 
      return 0;
    #line 681 
    if ((unsigned int)app_mask != 0U) {
      #line 681 
      adapter->fcoe.up = (unsigned char)((unsigned int)((unsigned char)ffs((int)app_mask)) + 255U);
    }
    else 
         #line 681 
         adapter->fcoe.up = (unsigned char)3U;
    #line 683 
    ixgbe_dcbnl_devreset(dev);
  }
  #line 687 
  if (((unsigned int)app->selector == 1U && (unsigned int)app->protocol == 0U) && (int)adapter->default_up == (int)app->priority) {
    #line 689 
    int vf;
    #line 691 
    int tmp_4;
    #line 690 
    unsigned long app_mask_0 = (unsigned long)dcb_ieee_getapp_mask(dev,app);
    #line 691 
    if (app_mask_0 != 0UL) {
      #line 691 
      tmp_4 = (int)cif_find_first_bit(& app_mask_0,8UL);
    }
    else 
         #line 691 
         tmp_4 = 0;
    #line 691 
    int qos = tmp_4;
    #line 693 
    adapter->default_up = (unsigned char)qos;
    #line 695 
    vf = 0;
    #line 695 
    while (adapter->num_vfs > (unsigned int)vf) {
      {
        #line 696 
        struct vf_data_storage *vfinfo = adapter->vfinfo + (unsigned long)vf;
        #line 698 
        if ((unsigned int)vfinfo->pf_qos == 0U) 
                                                #line 699 
                                                ixgbe_set_vmvir_0(adapter,(unsigned short)((int)vfinfo->pf_vlan),(unsigned short)((int)((unsigned short)qos)),(unsigned int)vf);
      }
      #line 695 
      vf ++;
    }
  }
  #line 704 
  return err;
}

#line 707  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static u8 ixgbe_dcbnl_getdcbx(struct net_device *dev)
{
  #line 709 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 710 
  return adapter->dcbx_cap;
}

#line 713  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static u8 ixgbe_dcbnl_setdcbx(struct net_device *dev, u8 mode)
{
  #line 715 
  struct ixgbe_adapter *adapter = netdev_priv(dev);
  #line 716 
  struct ieee_ets ets = {.willing = (unsigned char)0U, .ets_cap = (unsigned char)0, .cbs = (unsigned char)0, .tc_tx_bw = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, .tc_rx_bw = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, .tc_tsa = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, .prio_tc = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, .tc_reco_bw = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, .tc_reco_tsa = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, .reco_prio_tc = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}};
  #line 717 
  struct ieee_pfc pfc = {.pfc_cap = (unsigned char)0U, .pfc_en = (unsigned char)0, .mbc = (unsigned char)0, .delay = (unsigned short)0, .requests = {0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL}, .indications = {0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL}};
  #line 718 
  int err = 0;
  #line 721 
  if ((((int)mode & 2) != 0 || ((int)mode & 8) != 0 && ((int)mode & 4) != 0) || ((int)mode & 1) == 0) 
    #line 724 
    return (unsigned char)1U;
  #line 726 
  if ((int)adapter->dcbx_cap == (int)mode) 
                                           #line 727 
                                           return (unsigned char)0U;
  #line 729 
  adapter->dcbx_cap = mode;
  #line 732 
  ets.ets_cap = (unsigned char)8U;
  #line 733 
  pfc.pfc_cap = (unsigned char)8U;
  #line 735 
  if (((int)mode & 8) != 0) {
    #line 736 
    ixgbe_dcbnl_ieee_setets(dev,& ets);
    #line 737 
    ixgbe_dcbnl_ieee_setpfc(dev,& pfc);
  }
  else 
    #line 738 
    if (((int)mode & 4) != 0) {
      #line 739 
      u8 mask = (unsigned char)30U;
      #line 741 
      adapter->dcb_set_bitmap = (unsigned char)((int)adapter->dcb_set_bitmap | (int)mask);
      #line 742 
      ixgbe_dcbnl_set_all(dev);
    }
    else {
      #line 747 
      ixgbe_dcbnl_ieee_setets(dev,& ets);
      #line 748 
      ixgbe_dcbnl_ieee_setpfc(dev,& pfc);
      #line 749 
      err = ixgbe_setup_tc(dev,(unsigned char)0);
    }
  #line 752 
  return (unsigned char)(err != 0);
}

#line 755  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
struct dcbnl_rtnl_ops ixgbe_dcbnl_ops = {.ieee_getets = & ixgbe_dcbnl_ieee_getets, .ieee_setets = & ixgbe_dcbnl_ieee_setets, .ieee_getpfc = & ixgbe_dcbnl_ieee_getpfc, .ieee_setpfc = & ixgbe_dcbnl_ieee_setpfc, .ieee_setapp = & ixgbe_dcbnl_ieee_setapp, .ieee_delapp = & ixgbe_dcbnl_ieee_delapp, .getstate = & ixgbe_dcbnl_get_state, .setstate = & ixgbe_dcbnl_set_state, .getpermhwaddr = & ixgbe_dcbnl_get_perm_hw_addr, .setpgtccfgtx = & ixgbe_dcbnl_set_pg_tc_cfg_tx, .setpgbwgcfgtx = & ixgbe_dcbnl_set_pg_bwg_cfg_tx, .setpgtccfgrx = & ixgbe_dcbnl_set_pg_tc_cfg_rx, .setpgbwgcfgrx = & ixgbe_dcbnl_set_pg_bwg_cfg_rx, .getpgtccfgtx = & ixgbe_dcbnl_get_pg_tc_cfg_tx, .getpgbwgcfgtx = & ixgbe_dcbnl_get_pg_bwg_cfg_tx, .getpgtccfgrx = & ixgbe_dcbnl_get_pg_tc_cfg_rx, .getpgbwgcfgrx = & ixgbe_dcbnl_get_pg_bwg_cfg_rx, .setpfccfg = & ixgbe_dcbnl_set_pfc_cfg, .getpfccfg = & ixgbe_dcbnl_get_pfc_cfg, .setall = & ixgbe_dcbnl_set_all, .getcap = & ixgbe_dcbnl_getcap, .getnumtcs = & ixgbe_dcbnl_getnumtcs, .setnumtcs = & ixgbe_dcbnl_setnumtcs, .getpfcstate = & ixgbe_dcbnl_getpfcstate, .setpfcstate = & ixgbe_dcbnl_setpfcstate, .getapp = & ixgbe_dcbnl_getapp, .getdcbx = & ixgbe_dcbnl_getdcbx, .setdcbx = & ixgbe_dcbnl_setdcbx};
#line 128  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_dcb_nl.i.aux"
static void cif_clear_bit_2(long nr, unsigned long *addr)
{
  #line 131 
  ldv_clear_bit(nr,addr);
  #line 132 
  return;
}

#line 156  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_dcb_nl.i.aux"
static unsigned long cif_find_first_bit(unsigned long *addr, unsigned long size)
{
  #line 159 
  return ldv_find_first_bit(addr,size);
}

#line 451  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/0/concurrency safety/weaver/ixgbe_dcb_nl.i.aux"
static void *kmalloc_1(size_t size, gfp_t flags)
{
  #line 454 
  return ldv_kmalloc(size,flags);
}

#line 20  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/common/inline_asm.c"
void ldv_inline_asm(void)
{
  #line 24 
  return;
}

#line 20  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
void ldv_atomic_add(int i, atomic_t *v)
{
  #line 22 
  v->counter += i;
  #line 23 
  return;
}

#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
void ldv_atomic_sub(int i, atomic_t *v)
{
  #line 27 
  v->counter -= i;
  #line 28 
  return;
}

#line 30  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
int ldv_atomic_sub_and_test(int i, atomic_t *v)
{
  #line 32 
  v->counter -= i;
  #line 33 
  if (v->counter != 0) 
                       #line 34 
                       return 0;
  #line 36 
  return 1;
}

#line 39  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
void ldv_atomic_inc(atomic_t *v)
{
  #line 41 
  (v->counter) ++;
  #line 42 
  return;
}

#line 44  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
void ldv_atomic_dec(atomic_t *v)
{
  #line 46 
  (v->counter) --;
  #line 47 
  return;
}

#line 49  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
int ldv_atomic_dec_and_test(atomic_t *v)
{
  #line 51 
  (v->counter) --;
  #line 52 
  if (v->counter != 0) 
                       #line 53 
                       return 0;
  #line 55 
  return 1;
}

#line 58  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
int ldv_atomic_inc_and_test(atomic_t *v)
{
  #line 60 
  (v->counter) ++;
  #line 61 
  if (v->counter != 0) 
                       #line 62 
                       return 0;
  #line 64 
  return 1;
}

#line 67  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
int ldv_atomic_add_return(int i, atomic_t *v)
{
  #line 69 
  v->counter += i;
  #line 70 
  return v->counter;
}

#line 73  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
int ldv_atomic_add_negative(int i, atomic_t *v)
{
  #line 75 
  v->counter += i;
  #line 76 
  return v->counter < 0;
}

#line 79  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
int ldv_atomic_inc_short(short *v)
{
  #line 81 
  *v = (short)((unsigned int)*v + 1U);
  #line 82 
  return (int)*v;
}

#line 20  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/current.c"
static struct task_struct ldv_current;
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/current.c"
struct task_struct *ldv_get_current(void)
{
  #line 28 
  ldv_current.pid = 1;
  #line 29 
  return & ldv_current;
}

#line 32  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 28  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
void ldv_switch_to_interrupt_context(void);
#line 42  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 34  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
void ldv_switch_to_process_context(void);
#line 50  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 40  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
bool ldv_in_interrupt_context(void);
#line 112  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 55  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
int ldv_post_init(int init_ret_val);
#line 132  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 61  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
int ldv_post_probe(int probe_ret_val);
#line 133  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 133 
void ldv_check_return_value_probe(int);
#line 141 
#line 68  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
int ldv_filter_err_code(int ret_val);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/common.h"
#line 23 
void __VERIFIER_assume(int);
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
static bool __ldv_in_interrupt_context = (_Bool)0;
#line 28  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
void ldv_switch_to_interrupt_context(void)
{
  #line 31 
  __ldv_in_interrupt_context = (_Bool)1;
  #line 32 
  return;
}

#line 34  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
void ldv_switch_to_process_context(void)
{
  #line 37 
  __ldv_in_interrupt_context = (_Bool)0;
  #line 38 
  return;
}

#line 40  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
bool ldv_in_interrupt_context(void)
{
  #line 42 
  return __ldv_in_interrupt_context;
}

#line 45  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
static int ldv_filter_positive_int(int val)
{
  #line 47 
  __VERIFIER_assume(val <= 0);
  #line 48 
  return val;
}

#line 55  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
int ldv_post_init(int init_ret_val)
{
  #line 57 
  return ldv_filter_positive_int(init_ret_val);
}

#line 61  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
int ldv_post_probe(int probe_ret_val)
{
  #line 63 
  ldv_check_return_value_probe(probe_ret_val);
  #line 64 
  return ldv_filter_positive_int(probe_ret_val);
}

#line 68  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
int ldv_filter_err_code(int ret_val)
{
  #line 70 
  return ldv_filter_positive_int(ret_val);
}

#line 28  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/common/list.h"
#line 28 
void ldv_save_allocated_memory_to_list(void *);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/device.h"
#line 29  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device *dev);
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/device.h"
#line 43  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev, void *data);
#line 57  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 57 
void *ldv_xzalloc(size_t size);
#line 29  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device *dev)
{
  #line 31 
  if (dev != (struct device *)0 && dev->p != (struct device_private *)0) 
    #line 32 
    return (dev->p)->driver_data;
  #line 34 
  return (void *)0;
}

#line 43  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev, void *data)
{
  #line 45 
  dev->p = (struct device_private *)ldv_xzalloc(8UL);
  #line 46 
  ldv_save_allocated_memory_to_list((void *)dev->p);
  #line 47 
  (dev->p)->driver_data = data;
  #line 49 
  return 0;
}

#line 156  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 156 
void ldv_check_alloc_flags(gfp_t);
#line 48  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 48 
void *ldv_malloc(size_t size);
#line 49 
#line 49 
void *ldv_calloc(size_t nmemb, size_t size);
#line 50 
#line 50 
void *ldv_zalloc(size_t size);
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/devres.c"
void *ldv_devm_kmalloc(size_t size, gfp_t flags)
{
  #line 26 
  void *res;
  #line 28 
  ldv_check_alloc_flags(flags);
  #line 29 
  res = ldv_malloc(size);
  #line 30 
  ldv_save_allocated_memory_to_list(res);
  #line 32 
  return res;
}

#line 35  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/devres.c"
void *ldv_devm_kzalloc(size_t size, gfp_t flags)
{
  #line 37 
  void *res;
  #line 39 
  ldv_check_alloc_flags(flags);
  #line 40 
  res = ldv_zalloc(size);
  #line 41 
  ldv_save_allocated_memory_to_list(res);
  #line 43 
  return res;
}

#line 46  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/devres.c"
void *ldv_devm_kmalloc_array(size_t n, size_t size, gfp_t flags)
{
  #line 48 
  void *res;
  #line 50 
  ldv_check_alloc_flags(flags);
  #line 51 
  res = ldv_malloc(n * size);
  #line 52 
  ldv_save_allocated_memory_to_list(res);
  #line 54 
  return res;
}

#line 57  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/devres.c"
void *ldv_devm_kcalloc(size_t n, size_t size, gfp_t flags)
{
  #line 59 
  void *res;
  #line 61 
  ldv_check_alloc_flags(flags);
  #line 62 
  res = ldv_calloc(n,size);
  #line 63 
  ldv_save_allocated_memory_to_list(res);
  #line 65 
  return res;
}

#line 51  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 51 
void ldv_free(void *s);
#line 59 
#line 59 
void *ldv_malloc_unknown_size(void);
#line 31  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 31 
int ldv_undef_int_positive(void);
#line 40 
#line 40 
int ldv_undef_int_nonpositive(void);
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/firmware_loader.c"
int ldv_request_firmware(struct firmware **fw)
{
  #line 27 
  int retval;
  #line 26 
  struct firmware *_fw = (struct firmware *)0;
  #line 29 
  retval = ldv_undef_int_nonpositive();
  #line 31 
  if (retval == 0) {
    #line 33 
    _fw = (struct firmware *)ldv_xzalloc(32UL);
    #line 34 
    _fw->data = (u8 *)ldv_malloc_unknown_size();
    #line 35 
    __VERIFIER_assume(_fw->data != (u8 *)0U);
    #line 36 
    _fw->size = (unsigned long)ldv_undef_int_positive();
  }
  #line 39 
  *fw = _fw;
  #line 41 
  return retval;
}

#line 44  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/firmware_loader.c"
void ldv_release_firmware(struct firmware *fw)
{
  #line 46 
  if (fw != (struct firmware *)0) {
    #line 48 
    ldv_free((void *)fw->data);
    #line 49 
    ldv_free((void *)fw);
  }
  #line 51 
  return;
}

#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/i2c.h"
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/i2c/i2c-core-smbus.c"
s32 ldv_i2c_smbus_read_block_data(u8 *values);
#line 55  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 55 
void *ldv_xmalloc(size_t size);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 23 
int ldv_undef_int(void);
#line 34 
#line 34 
int ldv_undef_int_negative(void);
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/i2c/i2c-core-smbus.c"
s32 ldv_i2c_smbus_read_block_data(u8 *values)
{
  #line 27 
  __u8 size;
  #line 28 
  char *bytes;
  #line 30 
  if (ldv_undef_int() != 0) {
    #line 33 
    size = (unsigned char)ldv_undef_int_positive();
    #line 35 
    __VERIFIER_assume((unsigned int)size <= 32U);
    #line 37 
    bytes = (char *)ldv_xmalloc((unsigned long)size);
    #line 39 
    memcpy((void *)values,(void *)bytes,(unsigned long)size);
    #line 40 
    ldv_free((void *)bytes);
    #line 42 
    return (int)size;
  }
  else {
    #line 46 
    return ldv_undef_int_negative();
  }
}

#line 988  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
__inline static void v4l2_set_subdevdata(struct v4l2_subdev *sd, void *p)
{
  #line 990 
  sd->dev_priv = p;
  #line 991 
  return;
}

#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/media/v4l2-common.h"
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/media/v4l2-core/v4l2-i2c.c"
void ldv_v4l2_i2c_subdev_init(struct v4l2_subdev *sd, struct i2c_client *client, struct v4l2_subdev_ops *ops);
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/media/v4l2-core/v4l2-i2c.c"
void ldv_v4l2_i2c_subdev_init(struct v4l2_subdev *sd, struct i2c_client *client, struct v4l2_subdev_ops *ops)
{
  #line 26 
  sd->ops = ops;
  #line 27 
  v4l2_set_subdevdata(sd,(void *)client);
  #line 28 
  ldv_dev_set_drvdata(& client->dev,(void *)sd);
  #line 29 
  return;
}

#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/spi.c"
struct spi_controller *ldv_spi_alloc_master(struct device *host, unsigned int size)
{
  #line 25 
  struct spi_controller *master;
  #line 27 
  master = (struct spi_controller *)ldv_zalloc((unsigned long)size + 2936UL);
  #line 29 
  if (master == (struct spi_controller *)0) 
                                            #line 30 
                                            return (struct spi_controller *)0;
  #line 32 
  ldv_dev_set_drvdata(& master->dev,(void *)(master + 1U));
  #line 34 
  return master;
}

#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/fb.h"
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/video/fbdev/core/fbsysfs.c"
struct fb_info *ldv_framebuffer_alloc(size_t size);
#line 26  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/fb.h"
#line 38  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/video/fbdev/core/fbsysfs.c"
void ldv_framebuffer_release(struct fb_info *info);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/video/fbdev/core/fbsysfs.c"
struct fb_info *ldv_framebuffer_alloc(size_t size)
{
  #line 25 
  struct fb_info *info;
  #line 27 
  info = (struct fb_info *)ldv_zalloc(size + 1568UL);
  #line 29 
  if (info == (struct fb_info *)0) 
                                   #line 30 
                                   return (struct fb_info *)0;
  #line 32 
  if (size != 0UL) 
                   #line 33 
                   info->par = (void *)((char *)info + 1568UL);
  #line 35 
  return info;
}

#line 38  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/video/fbdev/core/fbsysfs.c"
void ldv_framebuffer_release(struct fb_info *info)
{
  #line 40 
  if (info == (struct fb_info *)0) 
                                   #line 41 
                                   return;
  #line 44 
  ldv_free((void *)info->apertures);
  #line 46 
  ldv_free((void *)info);
  #line 47 
  return;
}

#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/err.c"
bool ldv_is_err(void *ptr)
{
  #line 29 
  if ((unsigned long)ptr > 18446744073709547520UL) 
                                                   #line 30 
                                                   return (_Bool)1; else 
                                                                    #line 32 
                                                                    return (_Bool)0;
}

#line 35  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/err.c"
void *ldv_err_ptr(long error)
{
  #line 37 
  unsigned long result;
  #line 39 
  __VERIFIER_assume(error < 0L);
  #line 40 
  __VERIFIER_assume(error >= -4095L);
  #line 41 
  result = 18446744073709547520UL - (unsigned long)error;
  #line 42 
  __VERIFIER_assume(result > 18446744073709547520UL);
  #line 44 
  return (void *)result;
}

#line 47  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_ptr_err(void *ptr)
{
  #line 49 
  long result;
  #line 51 
  __VERIFIER_assume((unsigned long)ptr > 18446744073709547520UL);
  #line 52 
  result = (long)(18446744073709547520UL - (unsigned long)ptr);
  #line 53 
  __VERIFIER_assume(result < 0L);
  #line 54 
  __VERIFIER_assume(result >= -4095L);
  #line 56 
  return result;
}

#line 59  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/err.c"
bool ldv_is_err_or_null(void *ptr)
{
  #line 61 
  int tmp_0;
  #line 61 
  if (ptr == (void *)0) 
                        #line 61 
                        tmp_0 = 1;
  else {
    #line 61 
    if ((int)ldv_is_err(ptr) != 0) 
                                   #line 61 
                                   tmp_0 = 1; else 
                                                   #line 61 
                                                   tmp_0 = 0;
  }
  #line 61 
  return (_Bool)(tmp_0 != 0);
}

#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/panic.h"
#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/kernel/panic.c"
void ldv_panic(void);
#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/kernel/panic.c"
void ldv_panic(void)
{
  #line 23 
  __VERIFIER_assume(0);
  #line 24 
  return;
}

#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/bitmap.h"
#line 32  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
void ldv_bitmap_set(unsigned long *map, unsigned int start, int nbits);
#line 27  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/bitmap.h"
#line 72  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
void ldv_bitmap_zero(unsigned long *dst, unsigned int nbits);
#line 29  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/bitmap.h"
#line 78  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
unsigned long ldv_bitmap_find_next_zero_area(unsigned long *map, unsigned long size, unsigned long start, unsigned int nr, unsigned long align_mask);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/find_bit.h"
#line 23 
unsigned long ldv_find_next_zero_bit(unsigned long *addr, unsigned long size, unsigned long offset);
#line 22  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
void ldv_set_bit(long nr, unsigned long *addr)
{
  #line 24 
  *(addr + (unsigned long)nr / 64UL) |= 1UL << ((unsigned long)nr & 63UL);
  #line 25 
  return;
}

#line 27  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
void ldv_clear_bit(long nr, unsigned long *addr)
{
  #line 29 
  *(addr + (unsigned long)nr / 64UL) &= ~ (1UL << ((unsigned long)nr & 63UL));
  #line 30 
  return;
}

#line 32  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
void ldv_bitmap_set(unsigned long *map, unsigned int start, int nbits)
{
  #line 34 
  unsigned long *p = map + (unsigned long)(start / 64U);
  #line 35 
  unsigned int size = start + (unsigned int)nbits;
  #line 36 
  int bits_to_set = (int)(64U - (start & 63U));
  #line 37 
  unsigned long mask_to_set = 18446744073709551615UL << ((unsigned long)start & 63UL);
  #line 39 
  while (nbits - bits_to_set >= 0) {
    #line 40 
    *p |= mask_to_set;
    #line 41 
    nbits -= bits_to_set;
    #line 42 
    bits_to_set = 64;
    #line 43 
    mask_to_set = 18446744073709551615UL;
    #line 44 
    p ++;
  }
  #line 46 
  if (nbits != 0) {
    #line 47 
    mask_to_set = (18446744073709551615UL >> ((unsigned long)(- size) & 63UL)) & mask_to_set;
    #line 48 
    *p |= mask_to_set;
  }
  #line 50 
  return;
}

#line 52  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
void ldv_bitmap_clear(unsigned long *map, unsigned int start, int nbits)
{
  #line 54 
  unsigned long *p = map + (unsigned long)(start / 64U);
  #line 55 
  unsigned int size = start + (unsigned int)nbits;
  #line 56 
  int bits_to_clear = (int)(64U - (start & 63U));
  #line 57 
  unsigned long mask_to_clear = 18446744073709551615UL << ((unsigned long)start & 63UL);
  #line 59 
  while (nbits - bits_to_clear >= 0) {
    #line 60 
    *p &= ~ mask_to_clear;
    #line 61 
    nbits -= bits_to_clear;
    #line 62 
    bits_to_clear = 64;
    #line 63 
    mask_to_clear = 18446744073709551615UL;
    #line 64 
    p ++;
  }
  #line 66 
  if (nbits != 0) {
    #line 67 
    mask_to_clear = (18446744073709551615UL >> ((unsigned long)(- size) & 63UL)) & mask_to_clear;
    #line 68 
    *p &= ~ mask_to_clear;
  }
  #line 70 
  return;
}

#line 72  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
void ldv_bitmap_zero(unsigned long *dst, unsigned int nbits)
{
  #line 74 
  unsigned int len = (unsigned int)(((unsigned long)nbits + 63UL) / 64UL) * 8U;
  #line 75 
  memset((void *)dst,0,(unsigned long)len);
  #line 76 
  return;
}

#line 78  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
unsigned long ldv_bitmap_find_next_zero_area(unsigned long *map, unsigned long size, unsigned long start, unsigned int nr, unsigned long align_mask)
{
  #line 80 
  unsigned long index;
  #line 80 
  unsigned long end;
  #line 80 
  unsigned long i;
  #line 82 
  again: 
         #line 82 
  ;
  #line 83 
  index = ldv_find_next_zero_bit(map,size,start);
  #line 84 
  index = (index + align_mask) & ~ align_mask;
  #line 85 
  end = (unsigned long)nr + index;
  #line 87 
  if (end > size) 
                  #line 88 
                  return end;
  #line 90 
  i = ldv_find_next_bit(map,end,index);
  #line 92 
  if (i < end) {
    #line 93 
    start = i + 1UL;
    #line 94 
    goto again;
  }
  #line 97 
  return index;
}

#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/find_bit.h"
#line 25 
void ldv_check_find_bit_offset(unsigned long, unsigned long);
#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/find_bit.common.c"
static unsigned long ldv_ffs(unsigned long word)
{
  #line 23 
  int num = 0;
  #line 25 
  if ((word & 4294967295UL) == 0UL) {
    #line 26 
    num += 32;
    #line 27 
    word >>= 32;
  }
  #line 29 
  if ((word & 65535UL) == 0UL) {
    #line 30 
    num += 16;
    #line 31 
    word >>= 16;
  }
  #line 33 
  if ((word & 255UL) == 0UL) {
    #line 34 
    num += 8;
    #line 35 
    word >>= 8;
  }
  #line 37 
  if ((word & 15UL) == 0UL) {
    #line 38 
    num += 4;
    #line 39 
    word >>= 4;
  }
  #line 41 
  if ((word & 3UL) == 0UL) {
    #line 42 
    num += 2;
    #line 43 
    word >>= 2;
  }
  #line 45 
  if ((word & 1UL) == 0UL) 
                           #line 46 
                           num ++;
  #line 48 
  return (unsigned long)num;
}

#line 51  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/find_bit.common.c"
static unsigned long ldv_min(unsigned long a, unsigned long b)
{
  #line 53 
  if (a < b) 
             #line 54 
             return a;
  #line 56 
  return b;
}

#line 59  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/find_bit.common.c"
static unsigned long ldv_restrict_find_bit_res(unsigned long res, unsigned long size)
{
  #line 62 
  __VERIFIER_assume(1);
  #line 63 
  __VERIFIER_assume(res <= size);
  #line 65 
  return res;
}

#line 68  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/find_bit.common.c"
unsigned long ldv_find_first_bit(unsigned long *addr, unsigned long size)
{
  #line 70 
  unsigned long i;
  #line 72 
  i = 0UL;
  #line 72 
  while (i * 64UL < size) {
    #line 73 
    if (*(addr + i) != 0UL) {
      #line 74 
      ;
      #line 74 
      ;
      #line 74 
      ;
      #line 74 
      return ldv_restrict_find_bit_res(ldv_min(i * 64UL + ldv_ffs(*(addr + i)),size),
                                  size);
    }
    #line 72 
    i ++;
  }
  #line 76 
  return size;
}

#line 79  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/find_bit.common.c"
unsigned long ldv_find_next_bit(unsigned long *addr, unsigned long size, unsigned long offset)
{
  #line 81 
  unsigned long tmp;
  #line 83 
  ldv_check_find_bit_offset(size,offset);
  #line 85 
  tmp = *(addr + offset / 64UL);
  #line 86 
  tmp = (unsigned long)((18446744073709551615ULL << (offset & 63UL)) & (unsigned long long)tmp);
  #line 87 
  offset &= 18446744073709551552UL;
  #line 89 
  while (tmp == 0UL) {
    #line 90 
    offset += 64UL;
    #line 91 
    if (offset >= size) 
                        #line 92 
                        return size;
    #line 94 
    tmp = *(addr + offset / 64UL);
  }
  #line 97 
  ;
  #line 97 
  ;
  #line 97 
  ;
  #line 97 
  return ldv_restrict_find_bit_res(ldv_min(ldv_ffs(tmp) + offset,size),size);
}

#line 100  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/find_bit.common.c"
unsigned long ldv_find_next_zero_bit(unsigned long *addr, unsigned long size, unsigned long offset)
{
  #line 102 
  unsigned long tmp;
  #line 104 
  ldv_check_find_bit_offset(size,offset);
  #line 106 
  tmp = *(addr + offset / 64UL);
  #line 107 
  tmp = ~ tmp;
  #line 108 
  tmp = (unsigned long)((18446744073709551615ULL << (offset & 63UL)) & (unsigned long long)tmp);
  #line 109 
  offset &= 18446744073709551552UL;
  #line 111 
  while (tmp == 0UL) {
    #line 112 
    offset += 64UL;
    #line 113 
    if (offset >= size) 
                        #line 114 
                        return size;
    #line 116 
    tmp = *(addr + offset / 64UL);
    #line 117 
    tmp = ~ tmp;
  }
  #line 120 
  ;
  #line 120 
  ;
  #line 120 
  ;
  #line 120 
  return ldv_restrict_find_bit_res(ldv_min(ldv_ffs(tmp) + offset,size),size);
}

#line 28  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/string.h"
#line 70  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/string.c"
char *ldv_strstr(char *cs, char *ct);
#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/string.c"
size_t ldv_strlen(char *s)
{
  #line 23 
  unsigned int len = 0U;
  #line 25 
  while ((int)*s != 0) {
    #line 26 
    len ++;
    #line 25 
    s ++;
  }
  #line 28 
  return (unsigned long)len;
}

#line 31  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/string.c"
int ldv_strcmp(char *cs, char *ct)
{
  #line 33 
  while ((int)*cs != 0 && (int)*ct != 0) {
    #line 34 
    if ((int)*cs != (int)*ct) 
                              #line 35 
                              break;
    #line 33 
    cs ++;
    #line 33 
    ct ++;
  }
  #line 37 
  return (int)*cs - (int)*ct;
}

#line 40  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/string.c"
int ldv_strncmp(char *cs, char *ct, __kernel_size_t count)
{
  #line 42 
  if (count == 0UL) 
                    #line 43 
                    return 0;
  #line 45 
  while ((int)*cs != 0 && (int)*ct != 0) {
    #line 46 
    if ((int)*cs != (int)*ct) 
                              #line 47 
                              break;
    #line 49 
    count --;
    #line 51 
    if (count == 0UL) 
                      #line 52 
                      break;
    #line 45 
    cs ++;
    #line 45 
    ct ++;
  }
  #line 55 
  return (int)*cs - (int)*ct;
}

#line 58  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/string.c"
int ldv_memcmp(void *cs, void *ct, size_t count)
{
  #line 60 
  unsigned char *su1;
  #line 60 
  unsigned char *su2;
  #line 61 
  int res = 0;
  #line 63 
  su1 = (unsigned char *)cs;
  #line 63 
  su2 = (unsigned char *)ct;
  #line 63 
  while (count != 0UL) {
    #line 64 
    res = (int)*su1 - (int)*su2;
    #line 64 
    if (res != 0) 
                  #line 65 
                  break;
    #line 63 
    su1 ++;
    #line 63 
    su2 ++;
    #line 63 
    count --;
  }
  #line 67 
  return res;
}

#line 70  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/string.c"
char *ldv_strstr(char *cs, char *ct)
{
  #line 72 
  size_t cs_len;
  #line 72 
  size_t ct_len;
  #line 74 
  cs_len = ldv_strlen(cs);
  #line 75 
  ct_len = ldv_strlen(ct);
  #line 77 
  while (cs_len >= ct_len) {
    #line 78 
    if (ldv_memcmp((void *)cs,(void *)ct,ct_len) == 0) 
                                                       #line 79 
                                                       return cs;
    #line 81 
    cs_len --;
    #line 82 
    cs ++;
  }
  #line 85 
  return (char *)0;
}

#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/list.c"
void ldv_init_list_head(struct list_head *list)
{
  #line 23 
  list->next = list;
  #line 24 
  list->prev = list;
  #line 25 
  return;
}

#line 30  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
#line 69  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
struct kmem_cache *ldv_kmem_cache_create(char *name, unsigned int size);
#line 31  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
#line 85  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags);
#line 32  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
#line 90  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmem_cache_zalloc(struct kmem_cache *cachep, gfp_t flags);
#line 33  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
#line 95  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void ldv_kmem_cache_free(struct kmem_cache *cachep, void *objp);
#line 34  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
#line 100  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void ldv_kmem_cache_destroy(struct kmem_cache *cachep);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc(size_t size, gfp_t flags)
{
  #line 25 
  void *res;
  #line 27 
  ldv_check_alloc_flags(flags);
  #line 28 
  res = ldv_malloc(size);
  #line 30 
  return res;
}

#line 33  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kzalloc(size_t size, gfp_t flags)
{
  #line 35 
  void *res;
  #line 37 
  ldv_check_alloc_flags(flags);
  #line 38 
  res = ldv_zalloc(size);
  #line 40 
  return res;
}

#line 43  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags)
{
  #line 45 
  void *res;
  #line 47 
  ldv_check_alloc_flags(flags);
  #line 48 
  res = ldv_malloc(n * size);
  #line 50 
  return res;
}

#line 53  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags)
{
  #line 55 
  void *res;
  #line 57 
  ldv_check_alloc_flags(flags);
  #line 58 
  res = ldv_calloc(n,size);
  #line 60 
  return res;
}

#line 69  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
struct kmem_cache *ldv_kmem_cache_create(char *name, unsigned int size)
{
  #line 71 
  struct kmem_cache *res;
  #line 72 
  struct ldv_kmem_cache *ldv_res;
  #line 74 
  res = (struct kmem_cache *)ldv_zalloc(16UL);
  #line 76 
  if (res != (struct kmem_cache *)0) {
    #line 77 
    ldv_res = (struct ldv_kmem_cache *)res;
    #line 78 
    ldv_res->name = name;
    #line 79 
    ldv_res->size = size;
  }
  #line 82 
  return res;
}

#line 85  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)
{
  #line 87 
  return ldv_kmalloc((unsigned long)((struct ldv_kmem_cache *)cachep)->size,
                  flags);
}

#line 90  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmem_cache_zalloc(struct kmem_cache *cachep, gfp_t flags)
{
  #line 92 
  return ldv_kzalloc((unsigned long)((struct ldv_kmem_cache *)cachep)->size,
                  flags);
}

#line 95  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void ldv_kmem_cache_free(struct kmem_cache *cachep, void *objp)
{
  #line 97 
  ldv_free(objp);
  #line 98 
  return;
}

#line 100  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void ldv_kmem_cache_destroy(struct kmem_cache *cachep)
{
  #line 102 
  ldv_free((void *)cachep);
  #line 103 
  return;
}

#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/string.h"
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/util.c"
void *ldv_kmemdup(void *src, size_t len, gfp_t gfp);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/util.c"
void *ldv_kmemdup(void *src, size_t len, gfp_t gfp)
{
  #line 25 
  void *res;
  #line 27 
  ldv_check_alloc_flags(gfp);
  #line 28 
  res = ldv_malloc(len);
  #line 30 
  if (res != (void *)0) 
                        #line 31 
                        memcpy(res,src,len);
  #line 33 
  return res;
}

#line 162  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 162 
void ldv_check_alloc_nonatomic(void);
#line 22  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/vmalloc.h"
#line 33  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/vmalloc.c"
void *ldv_vzalloc(unsigned long size);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/vmalloc.c"
void *ldv_vmalloc(unsigned long size)
{
  #line 25 
  void *res;
  #line 27 
  ldv_check_alloc_nonatomic();
  #line 28 
  res = ldv_malloc(size);
  #line 30 
  return res;
}

#line 33  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/vmalloc.c"
void *ldv_vzalloc(unsigned long size)
{
  #line 35 
  void *res;
  #line 37 
  ldv_check_alloc_nonatomic();
  #line 38 
  res = ldv_zalloc(size);
  #line 40 
  return res;
}

#line 43  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/vmalloc.c"
void ldv_vfree(void *addr)
{
  #line 45 
  ldv_free(addr);
  #line 46 
  return;
}

#line 28  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 28 
void *malloc(size_t);
#line 29 
#line 29 
void *calloc(size_t, size_t);
#line 30 
#line 30 
void free(void *);
#line 45 
#line 22  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
unsigned int ldv_is_memory_alloc_failures;
#line 56  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 63  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xcalloc(size_t nmemb, size_t size);
#line 60  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 88  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc_unknown_size(void);
#line 61  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 97  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc_unknown_size(void);
#line 64  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc(size_t size);
#line 65  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 37  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc(size_t nmemb, size_t size);
#line 66  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 42  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc(size_t size);
#line 67  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 47  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void ldv_reference_free(void *s);
#line 69  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 52  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_realloc(void *ptr, size_t size);
#line 71  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 80  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc(size_t size);
#line 72  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 90  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xcalloc(size_t nmemb, size_t size);
#line 73  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 100  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xzalloc(size_t size);
#line 75  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 110  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc_unknown_size(void);
#line 76  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 124  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc_unknown_size(void);
#line 77  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 139  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc_unknown_size(void);
#line 83  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 106  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size);
#line 85  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 144  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size);
#line 87  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 87 
void *external_allocated_data(void);
#line 22  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
unsigned int ldv_is_memory_alloc_failures = 1U;
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc(size_t size)
{
  #line 26 
  void *res;
  #line 28 
  if (ldv_is_memory_alloc_failures != 0U) {
    #line 28 
    if (ldv_undef_int() != 0) 
                              #line 29 
                              return (void *)0;
  }
  #line 32 
  res = malloc(size);
  #line 33 
  __VERIFIER_assume(res != (void *)0);
  #line 34 
  return res;
}

#line 37  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc(size_t nmemb, size_t size)
{
  #line 39 
  return calloc(nmemb,size);
}

#line 42  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc(size_t size)
{
  #line 44 
  return calloc(1UL,size);
}

#line 47  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void ldv_reference_free(void *s)
{
  #line 49 
  free(s);
  #line 50 
  return;
}

#line 52  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_realloc(void *ptr, size_t size)
{
  #line 54 
  void *res;
  #line 56 
  if (ptr != (void *)0 && size == 0UL) {
    #line 57 
    free(ptr);
    #line 58 
    return (void *)0;
  }
  #line 61 
  if (ptr == (void *)0) {
    #line 62 
    res = malloc(size);
    #line 63 
    return res;
  }
  #line 66 
  if (ldv_undef_int() != 0) {
    #line 68 
    res = malloc(size);
    #line 69 
    __VERIFIER_assume(res != (void *)0);
    #line 71 
    memcpy(res,ptr,size);
    #line 72 
    free(ptr);
    #line 74 
    return res;
  }
  else 
       #line 77 
       return (void *)0;
}

#line 80  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc(size_t size)
{
  #line 82 
  void *res;
  #line 84 
  res = malloc(size);
  #line 85 
  __VERIFIER_assume(res != (void *)0);
  #line 87 
  return res;
}

#line 90  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xcalloc(size_t nmemb, size_t size)
{
  #line 92 
  void *res;
  #line 94 
  res = calloc(nmemb,size);
  #line 95 
  __VERIFIER_assume(res != (void *)0);
  #line 97 
  return res;
}

#line 100  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xzalloc(size_t size)
{
  #line 102 
  void *res;
  #line 104 
  res = calloc(1UL,size);
  #line 105 
  __VERIFIER_assume(res != (void *)0);
  #line 107 
  return res;
}

#line 110  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc_unknown_size(void)
{
  #line 112 
  void *res;
  #line 114 
  if (ldv_undef_int() != 0) {
    #line 116 
    res = external_allocated_data();
    #line 117 
    __VERIFIER_assume(res != (void *)0);
    #line 118 
    return res;
  }
  else 
       #line 121 
       return (void *)0;
}

#line 124  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc_unknown_size(void)
{
  #line 126 
  void *res;
  #line 128 
  if (ldv_undef_int() != 0) {
    #line 130 
    res = external_allocated_data();
    #line 131 
    memset(res,0,8UL);
    #line 132 
    __VERIFIER_assume(res != (void *)0);
    #line 133 
    return res;
  }
  else 
       #line 136 
       return (void *)0;
}

#line 139  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc_unknown_size(void)
{
  #line 141 
  return ldv_reference_calloc_unknown_size();
}

#line 144  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size)
{
  #line 146 
  void *res;
  #line 149 
  res = external_allocated_data();
  #line 150 
  __VERIFIER_assume(res != (void *)0);
  #line 152 
  return res;
}

#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc(size_t size)
{
  #line 25 
  void *res;
  #line 26 
  res = ldv_reference_malloc(size);
  #line 27 
  if (res != (void *)0) {
    #line 28 
    int tmp_0;
    #line 28 
    if (ldv_is_err(res)) 
                         #line 28 
                         tmp_0 = 0; else 
                                         #line 28 
                                         tmp_0 = 1;
    #line 28 
    __VERIFIER_assume(tmp_0);
  }
  #line 29 
  return res;
}

#line 32  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc(size_t nmemb, size_t size)
{
  #line 34 
  void *res;
  #line 35 
  res = ldv_reference_calloc(nmemb,size);
  #line 36 
  if (res != (void *)0) {
    #line 37 
    int tmp_0;
    #line 37 
    if (ldv_is_err(res)) 
                         #line 37 
                         tmp_0 = 0; else 
                                         #line 37 
                                         tmp_0 = 1;
    #line 37 
    __VERIFIER_assume(tmp_0);
  }
  #line 38 
  return res;
}

#line 41  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc(size_t size)
{
  #line 43 
  void *res;
  #line 44 
  res = ldv_reference_zalloc(size);
  #line 45 
  if (res != (void *)0) {
    #line 46 
    int tmp_0;
    #line 46 
    if (ldv_is_err(res)) 
                         #line 46 
                         tmp_0 = 0; else 
                                         #line 46 
                                         tmp_0 = 1;
    #line 46 
    __VERIFIER_assume(tmp_0);
  }
  #line 47 
  return res;
}

#line 50  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void ldv_free(void *s)
{
  #line 52 
  ldv_reference_free(s);
  #line 53 
  return;
}

#line 55  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc(size_t size)
{
  #line 57 
  void *res;
  #line 59 
  int tmp_0;
  #line 58 
  res = ldv_reference_xmalloc(size);
  #line 59 
  if (ldv_is_err(res)) 
                       #line 59 
                       tmp_0 = 0; else 
                                       #line 59 
                                       tmp_0 = 1;
  #line 59 
  __VERIFIER_assume(tmp_0);
  #line 60 
  return res;
}

#line 63  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xcalloc(size_t nmemb, size_t size)
{
  #line 65 
  void *res;
  #line 67 
  int tmp_0;
  #line 66 
  res = ldv_reference_xcalloc(nmemb,size);
  #line 67 
  if (ldv_is_err(res)) 
                       #line 67 
                       tmp_0 = 0; else 
                                       #line 67 
                                       tmp_0 = 1;
  #line 67 
  __VERIFIER_assume(tmp_0);
  #line 68 
  return res;
}

#line 71  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xzalloc(size_t size)
{
  #line 73 
  void *res;
  #line 75 
  int tmp_0;
  #line 74 
  res = ldv_reference_xzalloc(size);
  #line 75 
  if (ldv_is_err(res)) 
                       #line 75 
                       tmp_0 = 0; else 
                                       #line 75 
                                       tmp_0 = 1;
  #line 75 
  __VERIFIER_assume(tmp_0);
  #line 76 
  return res;
}

#line 79  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc_unknown_size(void)
{
  #line 81 
  void *res;
  #line 82 
  res = ldv_reference_malloc_unknown_size();
  #line 83 
  if (res != (void *)0) {
    #line 84 
    int tmp_0;
    #line 84 
    if (ldv_is_err(res)) 
                         #line 84 
                         tmp_0 = 0; else 
                                         #line 84 
                                         tmp_0 = 1;
    #line 84 
    __VERIFIER_assume(tmp_0);
  }
  #line 85 
  return res;
}

#line 88  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc_unknown_size(void)
{
  #line 90 
  void *res;
  #line 91 
  res = ldv_reference_calloc_unknown_size();
  #line 92 
  if (res != (void *)0) {
    #line 93 
    int tmp_0;
    #line 93 
    if (ldv_is_err(res)) 
                         #line 93 
                         tmp_0 = 0; else 
                                         #line 93 
                                         tmp_0 = 1;
    #line 93 
    __VERIFIER_assume(tmp_0);
  }
  #line 94 
  return res;
}

#line 97  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc_unknown_size(void)
{
  #line 99 
  void *res;
  #line 100 
  res = ldv_reference_zalloc_unknown_size();
  #line 101 
  if (res != (void *)0) {
    #line 102 
    int tmp_0;
    #line 102 
    if (ldv_is_err(res)) 
                         #line 102 
                         tmp_0 = 0; else 
                                         #line 102 
                                         tmp_0 = 1;
    #line 102 
    __VERIFIER_assume(tmp_0);
  }
  #line 103 
  return res;
}

#line 106  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size)
{
  #line 108 
  void *res;
  #line 110 
  int tmp_0;
  #line 109 
  res = ldv_reference_xmalloc_unknown_size(size);
  #line 110 
  if (ldv_is_err(res)) 
                       #line 110 
                       tmp_0 = 0; else 
                                       #line 110 
                                       tmp_0 = 1;
  #line 110 
  __VERIFIER_assume(tmp_0);
  #line 111 
  return res;
}

/* compiler builtin: 
   long __builtin_expect(long exp, long c);   */
#line 22  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/common.h"
#line 22 
void __VERIFIER_error(void);
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/common.h"
long __builtin_expect(long exp, long c)
{
  #line 26 
  return exp;
}

#line 35  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
void __builtin_trap(void)
{
  #line 37 
  __VERIFIER_error();
  #line 38 
  return;
}

#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 53  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
long ldv_undef_long(void);
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 61  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned int ldv_undef_uint(void);
#line 26  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 77  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long ldv_undef_ulong(void);
#line 27  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 85  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long long ldv_undef_ulonglong(void);
#line 28  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 69  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr(void);
#line 37  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 111  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_nonnegative(void);
#line 43  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 129  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr_non_null(void);
#line 54  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 139  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int __ldv_undef_int_range(int begin, int end);
#line 56  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 151  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int __ldv_undef_int_range2(int begin, int end);
#line 29 
#line 29 
int __VERIFIER_nondet_int(void);
#line 31 
#line 31 
long __VERIFIER_nondet_long(void);
#line 38 
#line 38 
unsigned int __VERIFIER_nondet_uint(void);
#line 41 
#line 41 
unsigned long __VERIFIER_nondet_ulong(void);
#line 42 
#line 42 
unsigned long long __VERIFIER_nondet_ulonglong(void);
#line 43 
#line 43 
void *__VERIFIER_nondet_pointer(void);
#line 45  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int(void)
{
  #line 48 
  int undef_int = __VERIFIER_nondet_int();
  #line 50 
  return undef_int;
}

#line 53  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
long ldv_undef_long(void)
{
  #line 56 
  long undef_long = __VERIFIER_nondet_long();
  #line 58 
  return undef_long;
}

#line 61  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned int ldv_undef_uint(void)
{
  #line 64 
  unsigned int undef_uint = __VERIFIER_nondet_uint();
  #line 66 
  return undef_uint;
}

#line 69  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr(void)
{
  #line 72 
  void *undef_ptr = __VERIFIER_nondet_pointer();
  #line 74 
  return undef_ptr;
}

#line 77  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long ldv_undef_ulong(void)
{
  #line 80 
  unsigned long undef_ulong = __VERIFIER_nondet_ulong();
  #line 82 
  return undef_ulong;
}

#line 85  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long long ldv_undef_ulonglong(void)
{
  #line 88 
  unsigned long long undef_ulonglong = __VERIFIER_nondet_ulonglong();
  #line 90 
  return undef_ulonglong;
}

#line 93  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_positive(void)
{
  #line 95 
  int ret = ldv_undef_int();
  #line 97 
  __VERIFIER_assume(ret > 0);
  #line 99 
  return ret;
}

#line 102  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_negative(void)
{
  #line 104 
  int ret = ldv_undef_int();
  #line 106 
  __VERIFIER_assume(ret < 0);
  #line 108 
  return ret;
}

#line 111  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_nonnegative(void)
{
  #line 113 
  int ret = ldv_undef_int();
  #line 115 
  __VERIFIER_assume(ret >= 0);
  #line 117 
  return ret;
}

#line 120  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_nonpositive(void)
{
  #line 122 
  int ret = ldv_undef_int();
  #line 124 
  __VERIFIER_assume(ret <= 0);
  #line 126 
  return ret;
}

#line 129  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr_non_null(void)
{
  #line 131 
  void *ret = ldv_undef_ptr();
  #line 133 
  __VERIFIER_assume(ret != (void *)0);
  #line 135 
  return ret;
}

#line 139  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int __ldv_undef_int_range(int begin, int end)
{
  #line 141 
  int ret;
  #line 143 
  ret = ldv_undef_int();
  #line 144 
  __VERIFIER_assume(ret >= begin);
  #line 145 
  __VERIFIER_assume(ret <= end);
  #line 147 
  return ret;
}

#line 151  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int __ldv_undef_int_range2(int begin, int end)
{
  #line 153 
  int ret;
  #line 155 
  ret = begin;
  #line 155 
  while (ret < end) {
    #line 156 
    if (ldv_undef_int() != 0) 
                              #line 157 
                              break;
    #line 155 
    ret ++;
  }
  #line 159 
  return ret;
}

#line 62  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 62 
void ldv_initialize(void);
#line 97 
#line 97 
void ldv_failed_register_netdev(void);
#line 123 
#line 123 
void ldv_pre_probe(void);
#line 35  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/thread.h"
#line 35 
int pthread_create(pthread_t *, pthread_attr_t *, void *(*)(void *), void *);
#line 39 
#line 39 
int pthread_join(pthread_t, void **);
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/err.h"
__inline static void *ERR_PTR_1(long error)
{
  #line 26 
  return (void *)error;
}

#line 164  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
#line 291 
void emg_dispatch_deregister_10(struct pci_driver *arg0);
#line 165 
#line 364 
void emg_dispatch_deregister_15(struct net_device *arg0);
#line 166 
#line 238 
void emg_dispatch_instance_deregister_6(struct timer_list *arg0);
#line 167 
#line 280 
void emg_dispatch_instance_register_9(struct timer_list *arg0);
#line 168 
#line 247 
void emg_dispatch_irq_deregister_7(int arg0);
#line 169 
#line 311 
void emg_dispatch_irq_register_13(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3);
#line 170 
#line 300 
void emg_dispatch_register_12(struct net_device *arg0);
#line 171 
#line 207 
void emg_dispatch_register_2(struct pci_driver *arg0);
#line 172 
#line 218 
void emg_dispatch_register_5(struct file_operations *arg0);
#line 173 
#line 2619 
void *emg_entry_point_insmod(void *arg0);
#line 174 
#line 373 
void *emg_file_operations_character_driver_scenario_ixgbe_dbg_netdev_ops_fops(void *arg0);
#line 175 
#line 536 
void *emg_file_operations_character_driver_scenario_ixgbe_dbg_reg_ops_fops(void *arg0);
#line 178 
#line 699 
void *emg_interrupt_interrupt_scenario_ixgbe_intr(void *arg0);
#line 179 
#line 762 
void *emg_interrupt_interrupt_scenario_ixgbe_msix_clean_rings(void *arg0);
#line 180 
#line 825 
void *emg_interrupt_interrupt_scenario_ixgbe_msix_other(void *arg0);
#line 181 
#line 888 
void *emg_interrupt_interrupt_scenario_ixgbe_test_intr(void *arg0);
#line 183 
#line 951 
void *emg_net_random_allocationless_scenario_ixgbe_get_channels(void *arg0);
#line 184 
#line 2037 
void *emg_pci_pci_scenario_ixgbe_driver(void *arg0);
#line 190 
#line 2208 
void *emg_timer_timer_scenario_8(void *arg0);
#line 192 
#line 2648 
int main(void);
#line 195  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
pthread_t emg_thread_16;
#line 196  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
pthread_t emg_thread_17;
#line 197  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
pthread_t emg_thread_18;
#line 198  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
pthread_t emg_thread_19;
#line 199  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
pthread_t emg_thread_20;
#line 200  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
pthread_t emg_thread_21;
#line 201  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
pthread_t emg_thread_22;
#line 202  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
pthread_t emg_thread_23;
#line 203  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
pthread_t emg_thread_24;
#line 207  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
void emg_dispatch_register_2(struct pci_driver *arg0)
{
  #line 208 
  int ret;
  #line 209 
  struct emg_struct_pci_scenario_ixgbe_driver_23 *cf_arg_23;
  #line 210 
  cf_arg_23 = (struct emg_struct_pci_scenario_ixgbe_driver_23 *)ldv_xmalloc(16UL);
  #line 211 
  cf_arg_23->arg0 = arg0;
  #line 212 
  ret = pthread_create(& emg_thread_23,(pthread_attr_t *)0,& emg_pci_pci_scenario_ixgbe_driver,(void *)cf_arg_23);
  #line 213 
  __VERIFIER_assume(ret == 0);
  #line 214 
  return;
}

#line 218  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
void emg_dispatch_register_5(struct file_operations *arg0)
{
  #line 219 
  int ret;
  #line 220 
  struct emg_struct_character_driver_scenario_ixgbe_dbg_netdev_ops_fops_16 *cf_arg_16;
  #line 221 
  struct emg_struct_character_driver_scenario_ixgbe_dbg_netdev_ops_fops_16 *cf_arg_17;
  #line 222 
  if (ldv_undef_int() != 0) {
    #line 223 
    cf_arg_16 = (struct emg_struct_character_driver_scenario_ixgbe_dbg_netdev_ops_fops_16 *)ldv_xmalloc(16UL);
    #line 224 
    cf_arg_16->arg0 = arg0;
    #line 225 
    ret = pthread_create(& emg_thread_16,(pthread_attr_t *)0,& emg_file_operations_character_driver_scenario_ixgbe_dbg_netdev_ops_fops,(void *)cf_arg_16);
    #line 226 
    __VERIFIER_assume(ret == 0);
  }
  else {
    #line 229 
    cf_arg_17 = (struct emg_struct_character_driver_scenario_ixgbe_dbg_netdev_ops_fops_16 *)ldv_xmalloc(16UL);
    #line 230 
    cf_arg_17->arg0 = arg0;
    #line 231 
    ret = pthread_create(& emg_thread_17,(pthread_attr_t *)0,& emg_file_operations_character_driver_scenario_ixgbe_dbg_reg_ops_fops,(void *)cf_arg_17);
    #line 232 
    __VERIFIER_assume(ret == 0);
  }
  #line 234 
  return;
}

#line 238  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
void emg_dispatch_instance_deregister_6(struct timer_list *arg0)
{
  #line 239 
  int ret;
  #line 240 
  struct emg_struct_timer_scenario_8_24 *cf_arg_24;
  #line 241 
  ret = pthread_join(emg_thread_24,(void **)0);
  #line 242 
  __VERIFIER_assume(ret == 0);
  #line 243 
  return;
}

#line 247  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
void emg_dispatch_irq_deregister_7(int arg0)
{
  #line 248 
  int ret;
  #line 249 
  struct emg_struct_free_irq_7 *cf_arg_18;
  #line 250 
  struct emg_struct_free_irq_7 *cf_arg_19;
  #line 251 
  struct emg_struct_free_irq_7 *cf_arg_20;
  #line 252 
  struct emg_struct_free_irq_7 *cf_arg_21;
  #line 253 
  switch (ldv_undef_int()) {
    #line 254 
    case 0: 
            #line 254 
    ;
    #line 255 
    ret = pthread_join(emg_thread_18,(void **)0);
    #line 256 
    __VERIFIER_assume(ret == 0);
    #line 257 
    break;
    #line 259 
    case 1: 
            #line 259 
    ;
    #line 260 
    ret = pthread_join(emg_thread_19,(void **)0);
    #line 261 
    __VERIFIER_assume(ret == 0);
    #line 262 
    break;
    #line 264 
    case 2: 
            #line 264 
    ;
    #line 265 
    ret = pthread_join(emg_thread_20,(void **)0);
    #line 266 
    __VERIFIER_assume(ret == 0);
    #line 267 
    break;
    #line 269 
    case 3: 
            #line 269 
    ;
    #line 270 
    ret = pthread_join(emg_thread_21,(void **)0);
    #line 271 
    __VERIFIER_assume(ret == 0);
    #line 272 
    break;
    #line 274 
    default: 
             #line 274 
    ;
    #line 274 
    __VERIFIER_assume(0);
  }
  #line 276 
  return;
}

#line 280  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
void emg_dispatch_instance_register_9(struct timer_list *arg0)
{
  #line 281 
  int ret;
  #line 282 
  struct emg_struct_timer_scenario_8_24 *cf_arg_24;
  #line 283 
  cf_arg_24 = (struct emg_struct_timer_scenario_8_24 *)ldv_xmalloc(16UL);
  #line 284 
  cf_arg_24->arg0 = arg0;
  #line 285 
  ret = pthread_create(& emg_thread_24,(pthread_attr_t *)0,& emg_timer_timer_scenario_8,(void *)cf_arg_24);
  #line 286 
  __VERIFIER_assume(ret == 0);
  #line 287 
  return;
}

#line 291  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
void emg_dispatch_deregister_10(struct pci_driver *arg0)
{
  #line 292 
  int ret;
  #line 293 
  struct emg_struct_pci_scenario_ixgbe_driver_23 *cf_arg_23;
  #line 294 
  ret = pthread_join(emg_thread_23,(void **)0);
  #line 295 
  __VERIFIER_assume(ret == 0);
  #line 296 
  return;
}

#line 300  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
void emg_dispatch_register_12(struct net_device *arg0)
{
  #line 301 
  int ret;
  #line 302 
  struct emg_struct_random_allocationless_scenario_ixgbe_get_channels_22 *cf_arg_22;
  #line 303 
  cf_arg_22 = (struct emg_struct_random_allocationless_scenario_ixgbe_get_channels_22 *)ldv_xmalloc(16UL);
  #line 304 
  cf_arg_22->arg0 = arg0;
  #line 305 
  ret = pthread_create(& emg_thread_22,(pthread_attr_t *)0,& emg_net_random_allocationless_scenario_ixgbe_get_channels,(void *)cf_arg_22);
  #line 306 
  __VERIFIER_assume(ret == 0);
  #line 307 
  return;
}

#line 311  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
void emg_dispatch_irq_register_13(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3)
{
  #line 312 
  int ret;
  #line 313 
  struct emg_struct_interrupt_scenario_ixgbe_intr_18 *cf_arg_18;
  #line 314 
  struct emg_struct_interrupt_scenario_ixgbe_intr_18 *cf_arg_19;
  #line 315 
  struct emg_struct_interrupt_scenario_ixgbe_intr_18 *cf_arg_20;
  #line 316 
  struct emg_struct_interrupt_scenario_ixgbe_intr_18 *cf_arg_21;
  #line 317 
  switch (ldv_undef_int()) {
    #line 318 
    case 0: 
            #line 318 
    ;
    #line 319 
    cf_arg_18 = (struct emg_struct_interrupt_scenario_ixgbe_intr_18 *)ldv_xmalloc(40UL);
    #line 320 
    cf_arg_18->arg0 = arg0;
    #line 321 
    cf_arg_18->arg1 = arg1;
    #line 322 
    cf_arg_18->arg2 = arg2;
    #line 323 
    cf_arg_18->arg3 = arg3;
    #line 324 
    ret = pthread_create(& emg_thread_18,(pthread_attr_t *)0,& emg_interrupt_interrupt_scenario_ixgbe_intr,(void *)cf_arg_18);
    #line 325 
    __VERIFIER_assume(ret == 0);
    #line 326 
    break;
    #line 328 
    case 1: 
            #line 328 
    ;
    #line 329 
    cf_arg_19 = (struct emg_struct_interrupt_scenario_ixgbe_intr_18 *)ldv_xmalloc(40UL);
    #line 330 
    cf_arg_19->arg0 = arg0;
    #line 331 
    cf_arg_19->arg1 = arg1;
    #line 332 
    cf_arg_19->arg2 = arg2;
    #line 333 
    cf_arg_19->arg3 = arg3;
    #line 334 
    ret = pthread_create(& emg_thread_19,(pthread_attr_t *)0,& emg_interrupt_interrupt_scenario_ixgbe_msix_clean_rings,(void *)cf_arg_19);
    #line 335 
    __VERIFIER_assume(ret == 0);
    #line 336 
    break;
    #line 338 
    case 2: 
            #line 338 
    ;
    #line 339 
    cf_arg_20 = (struct emg_struct_interrupt_scenario_ixgbe_intr_18 *)ldv_xmalloc(40UL);
    #line 340 
    cf_arg_20->arg0 = arg0;
    #line 341 
    cf_arg_20->arg1 = arg1;
    #line 342 
    cf_arg_20->arg2 = arg2;
    #line 343 
    cf_arg_20->arg3 = arg3;
    #line 344 
    ret = pthread_create(& emg_thread_20,(pthread_attr_t *)0,& emg_interrupt_interrupt_scenario_ixgbe_msix_other,(void *)cf_arg_20);
    #line 345 
    __VERIFIER_assume(ret == 0);
    #line 346 
    break;
    #line 348 
    case 3: 
            #line 348 
    ;
    #line 349 
    cf_arg_21 = (struct emg_struct_interrupt_scenario_ixgbe_intr_18 *)ldv_xmalloc(40UL);
    #line 350 
    cf_arg_21->arg0 = arg0;
    #line 351 
    cf_arg_21->arg1 = arg1;
    #line 352 
    cf_arg_21->arg2 = arg2;
    #line 353 
    cf_arg_21->arg3 = arg3;
    #line 354 
    ret = pthread_create(& emg_thread_21,(pthread_attr_t *)0,& emg_interrupt_interrupt_scenario_ixgbe_test_intr,(void *)cf_arg_21);
    #line 355 
    __VERIFIER_assume(ret == 0);
    #line 356 
    break;
    #line 358 
    default: 
             #line 358 
    ;
    #line 358 
    __VERIFIER_assume(0);
  }
  #line 360 
  return;
}

#line 364  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
void emg_dispatch_deregister_15(struct net_device *arg0)
{
  #line 365 
  int ret;
  #line 366 
  struct emg_struct_random_allocationless_scenario_ixgbe_get_channels_22 *cf_arg_22;
  #line 367 
  ret = pthread_join(emg_thread_22,(void **)0);
  #line 368 
  __VERIFIER_assume(ret == 0);
  #line 369 
  return;
}

#line 373  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
void *emg_file_operations_character_driver_scenario_ixgbe_dbg_netdev_ops_fops(void *arg0)
{
  #line 376 
  struct file_operations *emg_16_container;
  #line 377 
  char *emg_16_emg_param_1_0;
  #line 378 
  char *emg_16_emg_param_1_2;
  #line 379 
  long long *emg_16_emg_param_3_1;
  #line 380 
  long long *emg_16_emg_param_3_3;
  #line 381 
  struct file *emg_16_resource_0;
  #line 382 
  struct inode *emg_16_resource_1;
  #line 383 
  int emg_16_ret;
  #line 384 
  unsigned long emg_16_size_cnt;
  #line 385 
  int emg_repeat_cnt_main_16_0 = 1;
  #line 386 
  int emg_repeat_cnt_call_16 = 1;
  #line 387 
  int emg_repeat_cnt_main_16_1 = 1;
  #line 389 
  struct emg_struct_character_driver_scenario_ixgbe_dbg_netdev_ops_fops_16 *data = (struct emg_struct_character_driver_scenario_ixgbe_dbg_netdev_ops_fops_16 *)arg0;
  #line 393 
  emg_16_ret = ldv_undef_int();
  #line 394 
  emg_16_container = emg_alias_ixgbe_dbg_netdev_ops_fops;
  #line 395 
  emg_16_ret = ldv_undef_int();
  #line 397 
  __VERIFIER_assume(data->arg0 == emg_alias_ixgbe_dbg_netdev_ops_fops);
  #line 399 
  if (data != (struct emg_struct_character_driver_scenario_ixgbe_dbg_netdev_ops_fops_16 *)0) {
    #line 400 
    emg_16_container = data->arg0;
    #line 401 
    ldv_free((void *)data);
  }
  #line 406 
  emg_16_resource_0 = (struct file *)ldv_xmalloc(520UL);
  #line 407 
  emg_16_size_cnt = (unsigned long)ldv_undef_int();
  #line 411 
  goto emg_main_16;
  #line 415 
  return (void *)0;
  #line 418 
  emg_call_16: 
               #line 418 
  ;
  #line 419 
  if (ldv_undef_int() != 0) {
    #line 420 
    if (ldv_undef_int() != 0) {
      #line 422 
      emg_16_emg_param_1_0 = (char *)ldv_xmalloc_unknown_size(0UL);
      #line 422 
      emg_16_emg_param_1_0 = emg_16_emg_param_1_0;
      #line 423 
      emg_16_emg_param_3_1 = (long long *)ldv_xmalloc_unknown_size(0UL);
      #line 423 
      emg_16_emg_param_3_1 = emg_16_emg_param_3_1;
      #line 427 
      emg_wrapper_ixgbe_dbg_netdev_ops_read(emg_16_resource_0,emg_16_emg_param_1_0,emg_16_size_cnt,emg_16_emg_param_3_1);
      #line 431 
      ldv_free((void *)emg_16_emg_param_1_0);
      #line 432 
      ldv_free((void *)emg_16_emg_param_3_1);
    }
    else {
      #line 441 
      __VERIFIER_assume(emg_16_size_cnt <= 2147479552UL);
      #line 442 
      emg_16_emg_param_1_2 = (char *)ldv_xmalloc_unknown_size(0UL);
      #line 442 
      emg_16_emg_param_1_2 = emg_16_emg_param_1_2;
      #line 443 
      emg_16_emg_param_3_3 = (long long *)ldv_xmalloc_unknown_size(0UL);
      #line 443 
      emg_16_emg_param_3_3 = emg_16_emg_param_3_3;
      #line 447 
      emg_wrapper_ixgbe_dbg_netdev_ops_write(emg_16_resource_0,emg_16_emg_param_1_2,emg_16_size_cnt,emg_16_emg_param_3_3);
      #line 451 
      ldv_free((void *)emg_16_emg_param_1_2);
      #line 452 
      ldv_free((void *)emg_16_emg_param_3_3);
    }
    #line 456 
    if (emg_repeat_cnt_call_16 > 0) {
      #line 457 
      emg_repeat_cnt_call_16 --;
      #line 459 
      goto emg_call_16;
    }
    else 
         #line 461 
         __VERIFIER_assume(0);
  }
  else {
    #line 467 
    if (emg_16_container->release != (int (*)(struct inode *, struct file *))0) 
      #line 468 
      (*(emg_16_container->release))(emg_16_resource_1,emg_16_resource_0);
    #line 472 
    if (emg_repeat_cnt_main_16_0 > 0) {
      #line 473 
      emg_repeat_cnt_main_16_0 --;
      #line 475 
      goto emg_main_16;
    }
    else 
         #line 477 
         __VERIFIER_assume(0);
  }
  #line 483 
  return (void *)0;
  #line 486 
  emg_main_16: 
               #line 486 
  ;
  #line 487 
  if (ldv_undef_int() != 0) {
    #line 489 
    emg_16_ret = simple_open(emg_16_resource_1,emg_16_resource_0);
    #line 494 
    emg_16_ret = ldv_filter_err_code(emg_16_ret);
    #line 497 
    if (ldv_undef_int() != 0) {
      #line 499 
      __VERIFIER_assume(emg_16_ret == 0);
      #line 503 
      goto emg_call_16;
    }
    else {
      #line 508 
      __VERIFIER_assume(emg_16_ret != 0);
      #line 511 
      if (emg_repeat_cnt_main_16_1 > 0) {
        #line 512 
        emg_repeat_cnt_main_16_1 --;
        #line 514 
        goto emg_main_16;
      }
      else 
           #line 516 
           __VERIFIER_assume(0);
    }
  }
  else 
       #line 523 
       ldv_free((void *)emg_16_resource_0);
  #line 531 
  return (void *)0;
}

#line 536  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
void *emg_file_operations_character_driver_scenario_ixgbe_dbg_reg_ops_fops(void *arg0)
{
  #line 539 
  struct file_operations *emg_17_container;
  #line 540 
  char *emg_17_emg_param_1_0;
  #line 541 
  char *emg_17_emg_param_1_2;
  #line 542 
  long long *emg_17_emg_param_3_1;
  #line 543 
  long long *emg_17_emg_param_3_3;
  #line 544 
  struct file *emg_17_resource_0;
  #line 545 
  struct inode *emg_17_resource_1;
  #line 546 
  int emg_17_ret;
  #line 547 
  unsigned long emg_17_size_cnt;
  #line 548 
  int emg_repeat_cnt_main_17_1 = 1;
  #line 549 
  int emg_repeat_cnt_main_17_0 = 1;
  #line 550 
  int emg_repeat_cnt_call_17 = 1;
  #line 552 
  struct emg_struct_character_driver_scenario_ixgbe_dbg_netdev_ops_fops_16 *data = (struct emg_struct_character_driver_scenario_ixgbe_dbg_netdev_ops_fops_16 *)arg0;
  #line 556 
  emg_17_ret = ldv_undef_int();
  #line 557 
  emg_17_container = emg_alias_ixgbe_dbg_reg_ops_fops;
  #line 558 
  emg_17_ret = ldv_undef_int();
  #line 560 
  __VERIFIER_assume(data->arg0 == emg_alias_ixgbe_dbg_reg_ops_fops);
  #line 562 
  if (data != (struct emg_struct_character_driver_scenario_ixgbe_dbg_netdev_ops_fops_16 *)0) {
    #line 563 
    emg_17_container = data->arg0;
    #line 564 
    ldv_free((void *)data);
  }
  #line 569 
  emg_17_resource_0 = (struct file *)ldv_xmalloc(520UL);
  #line 570 
  emg_17_size_cnt = (unsigned long)ldv_undef_int();
  #line 574 
  goto emg_main_17;
  #line 578 
  return (void *)0;
  #line 581 
  emg_call_17: 
               #line 581 
  ;
  #line 582 
  if (ldv_undef_int() != 0) {
    #line 583 
    if (ldv_undef_int() != 0) {
      #line 585 
      emg_17_emg_param_1_0 = (char *)ldv_xmalloc_unknown_size(0UL);
      #line 585 
      emg_17_emg_param_1_0 = emg_17_emg_param_1_0;
      #line 586 
      emg_17_emg_param_3_1 = (long long *)ldv_xmalloc_unknown_size(0UL);
      #line 586 
      emg_17_emg_param_3_1 = emg_17_emg_param_3_1;
      #line 590 
      emg_wrapper_ixgbe_dbg_reg_ops_read(emg_17_resource_0,emg_17_emg_param_1_0,emg_17_size_cnt,emg_17_emg_param_3_1);
      #line 594 
      ldv_free((void *)emg_17_emg_param_1_0);
      #line 595 
      ldv_free((void *)emg_17_emg_param_3_1);
    }
    else {
      #line 604 
      __VERIFIER_assume(emg_17_size_cnt <= 2147479552UL);
      #line 605 
      emg_17_emg_param_1_2 = (char *)ldv_xmalloc_unknown_size(0UL);
      #line 605 
      emg_17_emg_param_1_2 = emg_17_emg_param_1_2;
      #line 606 
      emg_17_emg_param_3_3 = (long long *)ldv_xmalloc_unknown_size(0UL);
      #line 606 
      emg_17_emg_param_3_3 = emg_17_emg_param_3_3;
      #line 610 
      emg_wrapper_ixgbe_dbg_reg_ops_write(emg_17_resource_0,emg_17_emg_param_1_2,emg_17_size_cnt,emg_17_emg_param_3_3);
      #line 614 
      ldv_free((void *)emg_17_emg_param_1_2);
      #line 615 
      ldv_free((void *)emg_17_emg_param_3_3);
    }
    #line 619 
    if (emg_repeat_cnt_call_17 > 0) {
      #line 620 
      emg_repeat_cnt_call_17 --;
      #line 622 
      goto emg_call_17;
    }
    else 
         #line 624 
         __VERIFIER_assume(0);
  }
  else {
    #line 630 
    if (emg_17_container->release != (int (*)(struct inode *, struct file *))0) 
      #line 631 
      (*(emg_17_container->release))(emg_17_resource_1,emg_17_resource_0);
    #line 635 
    if (emg_repeat_cnt_main_17_0 > 0) {
      #line 636 
      emg_repeat_cnt_main_17_0 --;
      #line 638 
      goto emg_main_17;
    }
    else 
         #line 640 
         __VERIFIER_assume(0);
  }
  #line 646 
  return (void *)0;
  #line 649 
  emg_main_17: 
               #line 649 
  ;
  #line 650 
  if (ldv_undef_int() != 0) {
    #line 652 
    emg_17_ret = simple_open(emg_17_resource_1,emg_17_resource_0);
    #line 657 
    emg_17_ret = ldv_filter_err_code(emg_17_ret);
    #line 660 
    if (ldv_undef_int() != 0) {
      #line 662 
      __VERIFIER_assume(emg_17_ret == 0);
      #line 666 
      goto emg_call_17;
    }
    else {
      #line 671 
      __VERIFIER_assume(emg_17_ret != 0);
      #line 674 
      if (emg_repeat_cnt_main_17_1 > 0) {
        #line 675 
        emg_repeat_cnt_main_17_1 --;
        #line 677 
        goto emg_main_17;
      }
      else 
           #line 679 
           __VERIFIER_assume(0);
    }
  }
  else 
       #line 686 
       ldv_free((void *)emg_17_resource_0);
  #line 694 
  return (void *)0;
}

#line 699  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
void *emg_interrupt_interrupt_scenario_ixgbe_intr(void *arg0)
{
  #line 702 
  enum irqreturn (*emg_18_callback)(int , void *);
  #line 703 
  void *emg_18_data;
  #line 704 
  int emg_18_line;
  #line 705 
  enum irqreturn emg_18_ret_val;
  #line 706 
  enum irqreturn (*emg_18_thread)(int , void *);
  #line 708 
  struct emg_struct_interrupt_scenario_ixgbe_intr_18 *data = (struct emg_struct_interrupt_scenario_ixgbe_intr_18 *)arg0;
  #line 711 
  emg_18_callback = & emg_wrapper_ixgbe_intr;
  #line 714 
  if (data != (struct emg_struct_interrupt_scenario_ixgbe_intr_18 *)0) {
    #line 715 
    emg_18_line = data->arg0;
    #line 716 
    emg_18_callback = data->arg1;
    #line 717 
    emg_18_thread = data->arg2;
    #line 718 
    emg_18_data = data->arg3;
    #line 719 
    ldv_free((void *)data);
  }
  #line 725 
  ldv_switch_to_interrupt_context();
  #line 729 
  emg_18_ret_val = emg_wrapper_ixgbe_intr(emg_18_line,emg_18_data);
  #line 734 
  ldv_switch_to_process_context();
  #line 737 
  if (ldv_undef_int() != 0) {
    #line 739 
    __VERIFIER_assume(emg_18_ret_val == (unsigned int)IRQ_WAKE_THREAD);
    #line 743 
    if (emg_18_thread != (enum irqreturn (*)(int , void *))0) 
                                                              #line 744 
                                                              (*emg_18_thread)(emg_18_line,emg_18_data);
  }
  else 
       #line 749 
       __VERIFIER_assume(emg_18_ret_val != (unsigned int)IRQ_WAKE_THREAD);
  #line 757 
  return (void *)0;
}

#line 762  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
void *emg_interrupt_interrupt_scenario_ixgbe_msix_clean_rings(void *arg0)
{
  #line 765 
  enum irqreturn (*emg_19_callback)(int , void *);
  #line 766 
  void *emg_19_data;
  #line 767 
  int emg_19_line;
  #line 768 
  enum irqreturn emg_19_ret_val;
  #line 769 
  enum irqreturn (*emg_19_thread)(int , void *);
  #line 771 
  struct emg_struct_interrupt_scenario_ixgbe_intr_18 *data = (struct emg_struct_interrupt_scenario_ixgbe_intr_18 *)arg0;
  #line 774 
  emg_19_callback = & emg_wrapper_ixgbe_msix_clean_rings;
  #line 777 
  if (data != (struct emg_struct_interrupt_scenario_ixgbe_intr_18 *)0) {
    #line 778 
    emg_19_line = data->arg0;
    #line 779 
    emg_19_callback = data->arg1;
    #line 780 
    emg_19_thread = data->arg2;
    #line 781 
    emg_19_data = data->arg3;
    #line 782 
    ldv_free((void *)data);
  }
  #line 788 
  ldv_switch_to_interrupt_context();
  #line 792 
  emg_19_ret_val = emg_wrapper_ixgbe_msix_clean_rings(emg_19_line,emg_19_data);
  #line 797 
  ldv_switch_to_process_context();
  #line 800 
  if (ldv_undef_int() != 0) {
    #line 802 
    __VERIFIER_assume(emg_19_ret_val == (unsigned int)IRQ_WAKE_THREAD);
    #line 806 
    if (emg_19_thread != (enum irqreturn (*)(int , void *))0) 
                                                              #line 807 
                                                              (*emg_19_thread)(emg_19_line,emg_19_data);
  }
  else 
       #line 812 
       __VERIFIER_assume(emg_19_ret_val != (unsigned int)IRQ_WAKE_THREAD);
  #line 820 
  return (void *)0;
}

#line 825  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
void *emg_interrupt_interrupt_scenario_ixgbe_msix_other(void *arg0)
{
  #line 828 
  enum irqreturn (*emg_20_callback)(int , void *);
  #line 829 
  void *emg_20_data;
  #line 830 
  int emg_20_line;
  #line 831 
  enum irqreturn emg_20_ret_val;
  #line 832 
  enum irqreturn (*emg_20_thread)(int , void *);
  #line 834 
  struct emg_struct_interrupt_scenario_ixgbe_intr_18 *data = (struct emg_struct_interrupt_scenario_ixgbe_intr_18 *)arg0;
  #line 837 
  emg_20_callback = & emg_wrapper_ixgbe_msix_other;
  #line 840 
  if (data != (struct emg_struct_interrupt_scenario_ixgbe_intr_18 *)0) {
    #line 841 
    emg_20_line = data->arg0;
    #line 842 
    emg_20_callback = data->arg1;
    #line 843 
    emg_20_thread = data->arg2;
    #line 844 
    emg_20_data = data->arg3;
    #line 845 
    ldv_free((void *)data);
  }
  #line 851 
  ldv_switch_to_interrupt_context();
  #line 855 
  emg_20_ret_val = emg_wrapper_ixgbe_msix_other(emg_20_line,emg_20_data);
  #line 860 
  ldv_switch_to_process_context();
  #line 863 
  if (ldv_undef_int() != 0) {
    #line 865 
    __VERIFIER_assume(emg_20_ret_val == (unsigned int)IRQ_WAKE_THREAD);
    #line 869 
    if (emg_20_thread != (enum irqreturn (*)(int , void *))0) 
                                                              #line 870 
                                                              (*emg_20_thread)(emg_20_line,emg_20_data);
  }
  else 
       #line 875 
       __VERIFIER_assume(emg_20_ret_val != (unsigned int)IRQ_WAKE_THREAD);
  #line 883 
  return (void *)0;
}

#line 888  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
void *emg_interrupt_interrupt_scenario_ixgbe_test_intr(void *arg0)
{
  #line 891 
  enum irqreturn (*emg_21_callback)(int , void *);
  #line 892 
  void *emg_21_data;
  #line 893 
  int emg_21_line;
  #line 894 
  enum irqreturn emg_21_ret_val;
  #line 895 
  enum irqreturn (*emg_21_thread)(int , void *);
  #line 897 
  struct emg_struct_interrupt_scenario_ixgbe_intr_18 *data = (struct emg_struct_interrupt_scenario_ixgbe_intr_18 *)arg0;
  #line 900 
  emg_21_callback = & emg_wrapper_ixgbe_test_intr;
  #line 903 
  if (data != (struct emg_struct_interrupt_scenario_ixgbe_intr_18 *)0) {
    #line 904 
    emg_21_line = data->arg0;
    #line 905 
    emg_21_callback = data->arg1;
    #line 906 
    emg_21_thread = data->arg2;
    #line 907 
    emg_21_data = data->arg3;
    #line 908 
    ldv_free((void *)data);
  }
  #line 914 
  ldv_switch_to_interrupt_context();
  #line 918 
  emg_21_ret_val = emg_wrapper_ixgbe_test_intr(emg_21_line,emg_21_data);
  #line 923 
  ldv_switch_to_process_context();
  #line 926 
  if (ldv_undef_int() != 0) {
    #line 928 
    __VERIFIER_assume(emg_21_ret_val == (unsigned int)IRQ_WAKE_THREAD);
    #line 932 
    if (emg_21_thread != (enum irqreturn (*)(int , void *))0) 
                                                              #line 933 
                                                              (*emg_21_thread)(emg_21_line,emg_21_data);
  }
  else 
       #line 938 
       __VERIFIER_assume(emg_21_ret_val != (unsigned int)IRQ_WAKE_THREAD);
  #line 946 
  return (void *)0;
}

#line 951  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
void *emg_net_random_allocationless_scenario_ixgbe_get_channels(void *arg0)
{
  #line 954 
  struct net_device *emg_22_container;
  #line 955 
  struct sk_buff *emg_22_emg_param_0_27;
  #line 956 
  struct ndmsg *emg_22_emg_param_0_50;
  #line 957 
  struct sk_buff *emg_22_emg_param_0_56;
  #line 958 
  struct sk_buff *emg_22_emg_param_0_85;
  #line 959 
  struct ethtool_channels *emg_22_emg_param_1_0;
  #line 960 
  struct ethtool_coalesce *emg_22_emg_param_1_1;
  #line 961 
  struct ethtool_coalesce *emg_22_emg_param_1_100;
  #line 962 
  struct ethtool_eee *emg_22_emg_param_1_101;
  #line 963 
  struct ethtool_eeprom *emg_22_emg_param_1_102;
  #line 964 
  struct ethtool_link_ksettings *emg_22_emg_param_1_104;
  #line 965 
  unsigned int emg_22_emg_param_1_105;
  #line 966 
  struct ethtool_pauseparam *emg_22_emg_param_1_106;
  #line 967 
  enum ethtool_phys_id_state *emg_22_emg_param_1_107;
  #line 968 
  unsigned int emg_22_emg_param_1_108;
  #line 969 
  struct ethtool_ringparam *emg_22_emg_param_1_109;
  #line 970 
  struct ethtool_modinfo *emg_22_emg_param_1_11;
  #line 971 
  unsigned int *emg_22_emg_param_1_110;
  #line 972 
  struct ethtool_rxnfc *emg_22_emg_param_1_113;
  #line 973 
  struct ethtool_wolinfo *emg_22_emg_param_1_114;
  #line 974 
  struct ethtool_pauseparam *emg_22_emg_param_1_12;
  #line 975 
  struct ethtool_regs *emg_22_emg_param_1_13;
  #line 976 
  struct ethtool_ringparam *emg_22_emg_param_1_15;
  #line 977 
  unsigned int *emg_22_emg_param_1_16;
  #line 978 
  struct ethtool_rxnfc *emg_22_emg_param_1_19;
  #line 979 
  struct ethtool_drvinfo *emg_22_emg_param_1_2;
  #line 980 
  int emg_22_emg_param_1_21;
  #line 981 
  unsigned int emg_22_emg_param_1_22;
  #line 982 
  struct ethtool_ts_info *emg_22_emg_param_1_24;
  #line 983 
  struct ethtool_wolinfo *emg_22_emg_param_1_25;
  #line 984 
  struct netdev_bpf *emg_22_emg_param_1_26;
  #line 985 
  unsigned int emg_22_emg_param_1_28;
  #line 986 
  struct ethtool_eee *emg_22_emg_param_1_3;
  #line 987 
  struct nlmsghdr *emg_22_emg_param_1_32;
  #line 988 
  int emg_22_emg_param_1_35;
  #line 989 
  struct net_device *emg_22_emg_param_1_36;
  #line 990 
  void *emg_22_emg_param_1_37;
  #line 991 
  struct ifreq *emg_22_emg_param_1_38;
  #line 992 
  struct ethtool_eeprom *emg_22_emg_param_1_4;
  #line 993 
  unsigned short emg_22_emg_param_1_40;
  #line 994 
  unsigned short emg_22_emg_param_1_41;
  #line 995 
  unsigned short emg_22_emg_param_1_44;
  #line 996 
  struct netdev_fcoe_hbainfo *emg_22_emg_param_1_47;
  #line 997 
  unsigned long long *emg_22_emg_param_1_48;
  #line 998 
  struct nlattr **emg_22_emg_param_1_51;
  #line 999 
  unsigned long long emg_22_emg_param_1_58;
  #line 1000 
  struct rtnl_link_stats64 *emg_22_emg_param_1_59;
  #line 1001 
  struct ethtool_stats *emg_22_emg_param_1_6;
  #line 1002 
  int emg_22_emg_param_1_60;
  #line 1003 
  struct sk_buff *emg_22_emg_param_1_62;
  #line 1004 
  unsigned long long emg_22_emg_param_1_64;
  #line 1005 
  void *emg_22_emg_param_1_65;
  #line 1006 
  int emg_22_emg_param_1_66;
  #line 1007 
  int emg_22_emg_param_1_68;
  #line 1008 
  int emg_22_emg_param_1_70;
  #line 1009 
  int emg_22_emg_param_1_73;
  #line 1010 
  int emg_22_emg_param_1_75;
  #line 1011 
  int emg_22_emg_param_1_77;
  #line 1012 
  int emg_22_emg_param_1_79;
  #line 1013 
  struct ethtool_link_ksettings *emg_22_emg_param_1_8;
  #line 1014 
  enum tc_setup_type *emg_22_emg_param_1_83;
  #line 1015 
  struct udp_tunnel_info *emg_22_emg_param_1_86;
  #line 1016 
  struct udp_tunnel_info *emg_22_emg_param_1_87;
  #line 1017 
  unsigned short emg_22_emg_param_1_88;
  #line 1018 
  struct ethtool_eeprom *emg_22_emg_param_1_9;
  #line 1019 
  unsigned short emg_22_emg_param_1_90;
  #line 1020 
  int emg_22_emg_param_1_92;
  #line 1021 
  unsigned int emg_22_emg_param_1_95;
  #line 1022 
  struct ethtool_test *emg_22_emg_param_1_97;
  #line 1023 
  struct ethtool_channels *emg_22_emg_param_1_99;
  #line 1024 
  unsigned char *emg_22_emg_param_2_10;
  #line 1025 
  unsigned char *emg_22_emg_param_2_103;
  #line 1026 
  unsigned char *emg_22_emg_param_2_111;
  #line 1027 
  void *emg_22_emg_param_2_14;
  #line 1028 
  unsigned char *emg_22_emg_param_2_17;
  #line 1029 
  unsigned int *emg_22_emg_param_2_20;
  #line 1030 
  unsigned char *emg_22_emg_param_2_23;
  #line 1031 
  unsigned int emg_22_emg_param_2_29;
  #line 1032 
  unsigned short emg_22_emg_param_2_33;
  #line 1033 
  int emg_22_emg_param_2_39;
  #line 1034 
  struct scatterlist *emg_22_emg_param_2_42;
  #line 1035 
  struct scatterlist *emg_22_emg_param_2_45;
  #line 1036 
  int emg_22_emg_param_2_49;
  #line 1037 
  unsigned char *emg_22_emg_param_2_5;
  #line 1038 
  unsigned long long emg_22_emg_param_2_57;
  #line 1039 
  struct ifla_vf_info *emg_22_emg_param_2_61;
  #line 1040 
  struct net_device *emg_22_emg_param_2_63;
  #line 1041 
  unsigned int emg_22_emg_param_2_67;
  #line 1042 
  unsigned char *emg_22_emg_param_2_69;
  #line 1043 
  unsigned long long *emg_22_emg_param_2_7;
  #line 1044 
  int emg_22_emg_param_2_71;
  #line 1045 
  _Bool emg_22_emg_param_2_74;
  #line 1046 
  _Bool emg_22_emg_param_2_76;
  #line 1047 
  _Bool emg_22_emg_param_2_78;
  #line 1048 
  unsigned short emg_22_emg_param_2_80;
  #line 1049 
  void *emg_22_emg_param_2_84;
  #line 1050 
  unsigned short emg_22_emg_param_2_89;
  #line 1051 
  unsigned short emg_22_emg_param_2_91;
  #line 1052 
  struct xdp_frame **emg_22_emg_param_2_93;
  #line 1053 
  unsigned int emg_22_emg_param_2_96;
  #line 1054 
  unsigned long long *emg_22_emg_param_2_98;
  #line 1055 
  unsigned char emg_22_emg_param_3_112;
  #line 1056 
  unsigned char *emg_22_emg_param_3_18;
  #line 1057 
  struct netlink_ext_ack *emg_22_emg_param_3_34;
  #line 1058 
  unsigned int emg_22_emg_param_3_43;
  #line 1059 
  unsigned int emg_22_emg_param_3_46;
  #line 1060 
  unsigned char *emg_22_emg_param_3_52;
  #line 1061 
  int emg_22_emg_param_3_72;
  #line 1062 
  unsigned char emg_22_emg_param_3_81;
  #line 1063 
  unsigned int emg_22_emg_param_3_94;
  #line 1064 
  unsigned int emg_22_emg_param_4_30;
  #line 1065 
  unsigned short emg_22_emg_param_4_53;
  #line 1066 
  unsigned short emg_22_emg_param_4_82;
  #line 1067 
  int emg_22_emg_param_5_31;
  #line 1068 
  unsigned short emg_22_emg_param_5_54;
  #line 1069 
  struct netlink_ext_ack *emg_22_emg_param_6_55;
  #line 1070 
  int emg_repeat_cnt_call_22 = 1;
  #line 1072 
  struct emg_struct_random_allocationless_scenario_ixgbe_get_channels_22 *data = (struct emg_struct_random_allocationless_scenario_ixgbe_get_channels_22 *)arg0;
  #line 1077 
  if (data != (struct emg_struct_random_allocationless_scenario_ixgbe_get_channels_22 *)0) {
    #line 1078 
    emg_22_container = data->arg0;
    #line 1079 
    ldv_free((void *)data);
  }
  #line 1084 
  goto emg_call_22;
  #line 1088 
  return (void *)0;
  #line 1091 
  emg_call_22: 
               #line 1091 
  ;
  #line 1092 
  switch (ldv_undef_int()) {
    #line 1093 
    case 0: 
            #line 1093 
    ;
    #line 1095 
    emg_22_emg_param_1_114 = (struct ethtool_wolinfo *)ldv_xmalloc_unknown_size(0UL);
    #line 1095 
    emg_22_emg_param_1_114 = emg_22_emg_param_1_114;
    #line 1099 
    emg_wrapper_ixgbe_set_wol(emg_22_container,emg_22_emg_param_1_114);
    #line 1103 
    ldv_free((void *)emg_22_emg_param_1_114);
    #line 1105 
    break;
    #line 1107 
    case 1: 
            #line 1107 
    ;
    #line 1109 
    emg_22_emg_param_1_113 = (struct ethtool_rxnfc *)ldv_xmalloc_unknown_size(0UL);
    #line 1109 
    emg_22_emg_param_1_113 = emg_22_emg_param_1_113;
    #line 1113 
    emg_wrapper_ixgbe_set_rxnfc(emg_22_container,emg_22_emg_param_1_113);
    #line 1117 
    ldv_free((void *)emg_22_emg_param_1_113);
    #line 1119 
    break;
    #line 1121 
    case 2: 
            #line 1121 
    ;
    #line 1123 
    emg_22_emg_param_1_110 = (unsigned int *)ldv_xmalloc_unknown_size(0UL);
    #line 1123 
    emg_22_emg_param_1_110 = emg_22_emg_param_1_110;
    #line 1124 
    emg_22_emg_param_2_111 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
    #line 1124 
    emg_22_emg_param_2_111 = emg_22_emg_param_2_111;
    #line 1128 
    emg_wrapper_ixgbe_set_rxfh(emg_22_container,emg_22_emg_param_1_110,emg_22_emg_param_2_111,(unsigned char)((int)emg_22_emg_param_3_112));
    #line 1132 
    ldv_free((void *)emg_22_emg_param_1_110);
    #line 1133 
    ldv_free((void *)emg_22_emg_param_2_111);
    #line 1135 
    break;
    #line 1137 
    case 3: 
            #line 1137 
    ;
    #line 1139 
    emg_22_emg_param_1_109 = (struct ethtool_ringparam *)ldv_xmalloc_unknown_size(0UL);
    #line 1139 
    emg_22_emg_param_1_109 = emg_22_emg_param_1_109;
    #line 1143 
    emg_wrapper_ixgbe_set_ringparam(emg_22_container,emg_22_emg_param_1_109);
    #line 1147 
    ldv_free((void *)emg_22_emg_param_1_109);
    #line 1149 
    break;
    #line 1151 
    case 4: 
            #line 1151 
    ;
    #line 1153 
    emg_wrapper_ixgbe_set_priv_flags(emg_22_container,emg_22_emg_param_1_108);
    #line 1155 
    break;
    #line 1157 
    case 5: 
            #line 1157 
    ;
    #line 1159 
    emg_22_emg_param_1_107 = (enum ethtool_phys_id_state *)ldv_xmalloc_unknown_size(0UL);
    #line 1159 
    emg_22_emg_param_1_107 = emg_22_emg_param_1_107;
    #line 1163 
    emg_wrapper_ixgbe_set_phys_id(emg_22_container,*emg_22_emg_param_1_107);
    #line 1167 
    ldv_free((void *)emg_22_emg_param_1_107);
    #line 1169 
    break;
    #line 1171 
    case 6: 
            #line 1171 
    ;
    #line 1173 
    emg_22_emg_param_1_106 = (struct ethtool_pauseparam *)ldv_xmalloc_unknown_size(0UL);
    #line 1173 
    emg_22_emg_param_1_106 = emg_22_emg_param_1_106;
    #line 1177 
    emg_wrapper_ixgbe_set_pauseparam(emg_22_container,emg_22_emg_param_1_106);
    #line 1181 
    ldv_free((void *)emg_22_emg_param_1_106);
    #line 1183 
    break;
    #line 1185 
    case 7: 
            #line 1185 
    ;
    #line 1187 
    emg_wrapper_ixgbe_set_msglevel(emg_22_container,emg_22_emg_param_1_105);
    #line 1189 
    break;
    #line 1191 
    case 8: 
            #line 1191 
    ;
    #line 1193 
    emg_22_emg_param_1_104 = (struct ethtool_link_ksettings *)ldv_xmalloc_unknown_size(0UL);
    #line 1193 
    emg_22_emg_param_1_104 = emg_22_emg_param_1_104;
    #line 1197 
    emg_wrapper_ixgbe_set_link_ksettings(emg_22_container,emg_22_emg_param_1_104);
    #line 1201 
    ldv_free((void *)emg_22_emg_param_1_104);
    #line 1203 
    break;
    #line 1205 
    case 9: 
            #line 1205 
    ;
    #line 1207 
    emg_22_emg_param_1_102 = (struct ethtool_eeprom *)ldv_xmalloc_unknown_size(0UL);
    #line 1207 
    emg_22_emg_param_1_102 = emg_22_emg_param_1_102;
    #line 1208 
    emg_22_emg_param_2_103 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
    #line 1208 
    emg_22_emg_param_2_103 = emg_22_emg_param_2_103;
    #line 1212 
    emg_wrapper_ixgbe_set_eeprom(emg_22_container,emg_22_emg_param_1_102,emg_22_emg_param_2_103);
    #line 1216 
    ldv_free((void *)emg_22_emg_param_1_102);
    #line 1217 
    ldv_free((void *)emg_22_emg_param_2_103);
    #line 1219 
    break;
    #line 1221 
    case 10: 
             #line 1221 
    ;
    #line 1223 
    emg_22_emg_param_1_101 = (struct ethtool_eee *)ldv_xmalloc_unknown_size(0UL);
    #line 1223 
    emg_22_emg_param_1_101 = emg_22_emg_param_1_101;
    #line 1227 
    emg_wrapper_ixgbe_set_eee(emg_22_container,emg_22_emg_param_1_101);
    #line 1231 
    ldv_free((void *)emg_22_emg_param_1_101);
    #line 1233 
    break;
    #line 1235 
    case 11: 
             #line 1235 
    ;
    #line 1237 
    emg_22_emg_param_1_100 = (struct ethtool_coalesce *)ldv_xmalloc_unknown_size(0UL);
    #line 1237 
    emg_22_emg_param_1_100 = emg_22_emg_param_1_100;
    #line 1241 
    emg_wrapper_ixgbe_set_coalesce(emg_22_container,emg_22_emg_param_1_100);
    #line 1245 
    ldv_free((void *)emg_22_emg_param_1_100);
    #line 1247 
    break;
    #line 1249 
    case 12: 
             #line 1249 
    ;
    #line 1251 
    emg_22_emg_param_1_99 = (struct ethtool_channels *)ldv_xmalloc_unknown_size(0UL);
    #line 1251 
    emg_22_emg_param_1_99 = emg_22_emg_param_1_99;
    #line 1255 
    emg_wrapper_ixgbe_set_channels(emg_22_container,emg_22_emg_param_1_99);
    #line 1259 
    ldv_free((void *)emg_22_emg_param_1_99);
    #line 1261 
    break;
    #line 1263 
    case 13: 
             #line 1263 
    ;
    #line 1265 
    emg_22_emg_param_1_97 = (struct ethtool_test *)ldv_xmalloc_unknown_size(0UL);
    #line 1265 
    emg_22_emg_param_1_97 = emg_22_emg_param_1_97;
    #line 1266 
    emg_22_emg_param_2_98 = (unsigned long long *)ldv_xmalloc_unknown_size(0UL);
    #line 1266 
    emg_22_emg_param_2_98 = emg_22_emg_param_2_98;
    #line 1270 
    emg_wrapper_ixgbe_diag_test(emg_22_container,emg_22_emg_param_1_97,emg_22_emg_param_2_98);
    #line 1274 
    ldv_free((void *)emg_22_emg_param_1_97);
    #line 1275 
    ldv_free((void *)emg_22_emg_param_2_98);
    #line 1277 
    break;
    #line 1279 
    case 14: 
             #line 1279 
    ;
    #line 1281 
    emg_wrapper_ixgbe_nway_reset(emg_22_container);
    #line 1283 
    break;
    #line 1285 
    case 15: 
             #line 1285 
    ;
    #line 1287 
    ixgbe_xsk_wakeup(emg_22_container,emg_22_emg_param_1_95,emg_22_emg_param_2_96);
    #line 1289 
    break;
    #line 1291 
    case 16: 
             #line 1291 
    ;
    #line 1293 
    emg_22_emg_param_2_93 = (struct xdp_frame **)ldv_xmalloc_unknown_size(0UL);
    #line 1293 
    emg_22_emg_param_2_93 = emg_22_emg_param_2_93;
    #line 1297 
    emg_wrapper_ixgbe_xdp_xmit(emg_22_container,emg_22_emg_param_1_92,emg_22_emg_param_2_93,emg_22_emg_param_3_94);
    #line 1301 
    ldv_free((void *)emg_22_emg_param_2_93);
    #line 1303 
    break;
    #line 1305 
    case 17: 
             #line 1305 
    ;
    #line 1307 
    emg_wrapper_ixgbe_vlan_rx_kill_vid(emg_22_container,(unsigned short)((int)emg_22_emg_param_1_90),(unsigned short)((int)emg_22_emg_param_2_91));
    #line 1309 
    break;
    #line 1311 
    case 18: 
             #line 1311 
    ;
    #line 1313 
    emg_wrapper_ixgbe_vlan_rx_add_vid(emg_22_container,(unsigned short)((int)emg_22_emg_param_1_88),(unsigned short)((int)emg_22_emg_param_2_89));
    #line 1315 
    break;
    #line 1317 
    case 19: 
             #line 1317 
    ;
    #line 1319 
    (*emg_alias_eth_validate_addr)(emg_22_container);
    #line 1321 
    break;
    #line 1323 
    case 20: 
             #line 1323 
    ;
    #line 1325 
    emg_22_emg_param_1_87 = (struct udp_tunnel_info *)ldv_xmalloc_unknown_size(0UL);
    #line 1325 
    emg_22_emg_param_1_87 = emg_22_emg_param_1_87;
    #line 1329 
    emg_wrapper_ixgbe_del_udp_tunnel_port(emg_22_container,emg_22_emg_param_1_87);
    #line 1333 
    ldv_free((void *)emg_22_emg_param_1_87);
    #line 1335 
    break;
    #line 1337 
    case 21: 
             #line 1337 
    ;
    #line 1339 
    emg_22_emg_param_1_86 = (struct udp_tunnel_info *)ldv_xmalloc_unknown_size(0UL);
    #line 1339 
    emg_22_emg_param_1_86 = emg_22_emg_param_1_86;
    #line 1343 
    emg_wrapper_ixgbe_add_udp_tunnel_port(emg_22_container,emg_22_emg_param_1_86);
    #line 1347 
    ldv_free((void *)emg_22_emg_param_1_86);
    #line 1349 
    break;
    #line 1351 
    case 22: 
             #line 1351 
    ;
    #line 1353 
    emg_wrapper_ixgbe_tx_timeout(emg_22_container);
    #line 1355 
    break;
    #line 1357 
    case 23: 
             #line 1357 
    ;
    #line 1359 
    emg_22_emg_param_0_85 = (struct sk_buff *)ldv_xmalloc_unknown_size(0UL);
    #line 1359 
    emg_22_emg_param_0_85 = emg_22_emg_param_0_85;
    #line 1363 
    emg_wrapper_ixgbe_xmit_frame(emg_22_emg_param_0_85,emg_22_container);
    #line 1367 
    ldv_free((void *)emg_22_emg_param_0_85);
    #line 1369 
    break;
    #line 1371 
    case 24: 
             #line 1371 
    ;
    #line 1373 
    emg_22_emg_param_1_83 = (enum tc_setup_type *)ldv_xmalloc_unknown_size(0UL);
    #line 1373 
    emg_22_emg_param_1_83 = emg_22_emg_param_1_83;
    #line 1374 
    emg_22_emg_param_2_84 = ldv_xmalloc_unknown_size(0UL);
    #line 1374 
    emg_22_emg_param_2_84 = emg_22_emg_param_2_84;
    #line 1378 
    emg_wrapper___ixgbe_setup_tc(emg_22_container,*emg_22_emg_param_1_83,emg_22_emg_param_2_84);
    #line 1382 
    ldv_free((void *)emg_22_emg_param_1_83);
    #line 1383 
    ldv_free(emg_22_emg_param_2_84);
    #line 1385 
    break;
    #line 1387 
    case 25: 
             #line 1387 
    ;
    #line 1389 
    ixgbe_ndo_set_vf_vlan(emg_22_container,emg_22_emg_param_1_79,(unsigned short)((int)emg_22_emg_param_2_80),(unsigned char)((int)emg_22_emg_param_3_81),(unsigned short)((int)emg_22_emg_param_4_82));
    #line 1391 
    break;
    #line 1393 
    case 26: 
             #line 1393 
    ;
    #line 1395 
    ixgbe_ndo_set_vf_trust(emg_22_container,emg_22_emg_param_1_77,(_Bool)((bool)((int)emg_22_emg_param_2_78) != 0));
    #line 1397 
    break;
    #line 1399 
    case 27: 
             #line 1399 
    ;
    #line 1401 
    ixgbe_ndo_set_vf_spoofchk(emg_22_container,emg_22_emg_param_1_75,(_Bool)((bool)((int)emg_22_emg_param_2_76) != 0));
    #line 1403 
    break;
    #line 1405 
    case 28: 
             #line 1405 
    ;
    #line 1407 
    ixgbe_ndo_set_vf_rss_query_en(emg_22_container,emg_22_emg_param_1_73,(_Bool)((bool)((int)emg_22_emg_param_2_74) != 0));
    #line 1409 
    break;
    #line 1411 
    case 29: 
             #line 1411 
    ;
    #line 1413 
    ixgbe_ndo_set_vf_bw(emg_22_container,emg_22_emg_param_1_70,emg_22_emg_param_2_71,emg_22_emg_param_3_72);
    #line 1415 
    break;
    #line 1417 
    case 30: 
             #line 1417 
    ;
    #line 1419 
    emg_22_emg_param_2_69 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
    #line 1419 
    emg_22_emg_param_2_69 = emg_22_emg_param_2_69;
    #line 1423 
    ixgbe_ndo_set_vf_mac(emg_22_container,emg_22_emg_param_1_68,emg_22_emg_param_2_69);
    #line 1427 
    ldv_free((void *)emg_22_emg_param_2_69);
    #line 1429 
    break;
    #line 1431 
    case 31: 
             #line 1431 
    ;
    #line 1433 
    emg_wrapper_ixgbe_tx_maxrate(emg_22_container,emg_22_emg_param_1_66,emg_22_emg_param_2_67);
    #line 1435 
    break;
    #line 1437 
    case 32: 
             #line 1437 
    ;
    #line 1439 
    ixgbe_set_rx_mode(emg_22_container);
    #line 1441 
    break;
    #line 1443 
    case 33: 
             #line 1443 
    ;
    #line 1445 
    emg_22_emg_param_1_65 = ldv_xmalloc_unknown_size(0UL);
    #line 1445 
    emg_22_emg_param_1_65 = emg_22_emg_param_1_65;
    #line 1449 
    emg_wrapper_ixgbe_set_mac(emg_22_container,emg_22_emg_param_1_65);
    #line 1453 
    ldv_free(emg_22_emg_param_1_65);
    #line 1455 
    break;
    #line 1457 
    case 34: 
             #line 1457 
    ;
    #line 1459 
    emg_wrapper_ixgbe_set_features(emg_22_container,emg_22_emg_param_1_64);
    #line 1461 
    break;
    #line 1463 
    case 35: 
             #line 1463 
    ;
    #line 1465 
    emg_22_emg_param_1_62 = (struct sk_buff *)ldv_xmalloc_unknown_size(0UL);
    #line 1465 
    emg_22_emg_param_1_62 = emg_22_emg_param_1_62;
    #line 1466 
    emg_22_emg_param_2_63 = (struct net_device *)ldv_xmalloc_unknown_size(0UL);
    #line 1466 
    emg_22_emg_param_2_63 = emg_22_emg_param_2_63;
    #line 1470 
    emg_wrapper_ixgbe_select_queue(emg_22_container,emg_22_emg_param_1_62,emg_22_emg_param_2_63);
    #line 1474 
    ldv_free((void *)emg_22_emg_param_1_62);
    #line 1475 
    ldv_free((void *)emg_22_emg_param_2_63);
    #line 1477 
    break;
    #line 1479 
    case 36: 
             #line 1479 
    ;
    #line 1481 
    emg_22_emg_param_2_61 = (struct ifla_vf_info *)ldv_xmalloc_unknown_size(0UL);
    #line 1481 
    emg_22_emg_param_2_61 = emg_22_emg_param_2_61;
    #line 1485 
    ixgbe_ndo_get_vf_config(emg_22_container,emg_22_emg_param_1_60,emg_22_emg_param_2_61);
    #line 1489 
    ldv_free((void *)emg_22_emg_param_2_61);
    #line 1491 
    break;
    #line 1493 
    case 37: 
             #line 1493 
    ;
    #line 1495 
    emg_22_emg_param_1_59 = (struct rtnl_link_stats64 *)ldv_xmalloc_unknown_size(0UL);
    #line 1495 
    emg_22_emg_param_1_59 = emg_22_emg_param_1_59;
    #line 1499 
    emg_wrapper_ixgbe_get_stats64(emg_22_container,emg_22_emg_param_1_59);
    #line 1503 
    ldv_free((void *)emg_22_emg_param_1_59);
    #line 1505 
    break;
    #line 1507 
    case 38: 
             #line 1507 
    ;
    #line 1509 
    emg_wrapper_ixgbe_fix_features(emg_22_container,emg_22_emg_param_1_58);
    #line 1511 
    break;
    #line 1513 
    case 39: 
             #line 1513 
    ;
    #line 1515 
    emg_22_emg_param_0_56 = (struct sk_buff *)ldv_xmalloc_unknown_size(0UL);
    #line 1515 
    emg_22_emg_param_0_56 = emg_22_emg_param_0_56;
    #line 1519 
    emg_wrapper_ixgbe_features_check(emg_22_emg_param_0_56,emg_22_container,emg_22_emg_param_2_57);
    #line 1523 
    ldv_free((void *)emg_22_emg_param_0_56);
    #line 1525 
    break;
    #line 1527 
    case 40: 
             #line 1527 
    ;
    #line 1529 
    emg_22_emg_param_0_50 = (struct ndmsg *)ldv_xmalloc_unknown_size(0UL);
    #line 1529 
    emg_22_emg_param_0_50 = emg_22_emg_param_0_50;
    #line 1530 
    emg_22_emg_param_1_51 = (struct nlattr **)ldv_xmalloc_unknown_size(0UL);
    #line 1530 
    emg_22_emg_param_1_51 = emg_22_emg_param_1_51;
    #line 1531 
    emg_22_emg_param_3_52 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
    #line 1531 
    emg_22_emg_param_3_52 = emg_22_emg_param_3_52;
    #line 1532 
    emg_22_emg_param_6_55 = (struct netlink_ext_ack *)ldv_xmalloc_unknown_size(0UL);
    #line 1532 
    emg_22_emg_param_6_55 = emg_22_emg_param_6_55;
    #line 1536 
    emg_wrapper_ixgbe_ndo_fdb_add(emg_22_emg_param_0_50,emg_22_emg_param_1_51,emg_22_container,emg_22_emg_param_3_52,(unsigned short)((int)emg_22_emg_param_4_53),(unsigned short)((int)emg_22_emg_param_5_54),emg_22_emg_param_6_55);
    #line 1540 
    ldv_free((void *)emg_22_emg_param_0_50);
    #line 1541 
    ldv_free((void *)emg_22_emg_param_1_51);
    #line 1542 
    ldv_free((void *)emg_22_emg_param_3_52);
    #line 1543 
    ldv_free((void *)emg_22_emg_param_6_55);
    #line 1545 
    break;
    #line 1547 
    case 41: 
             #line 1547 
    ;
    #line 1549 
    emg_22_emg_param_1_48 = (unsigned long long *)ldv_xmalloc_unknown_size(0UL);
    #line 1549 
    emg_22_emg_param_1_48 = emg_22_emg_param_1_48;
    #line 1553 
    ixgbe_fcoe_get_wwn(emg_22_container,emg_22_emg_param_1_48,emg_22_emg_param_2_49);
    #line 1557 
    ldv_free((void *)emg_22_emg_param_1_48);
    #line 1559 
    break;
    #line 1561 
    case 42: 
             #line 1561 
    ;
    #line 1563 
    emg_22_emg_param_1_47 = (struct netdev_fcoe_hbainfo *)ldv_xmalloc_unknown_size(0UL);
    #line 1563 
    emg_22_emg_param_1_47 = emg_22_emg_param_1_47;
    #line 1567 
    ixgbe_fcoe_get_hbainfo(emg_22_container,emg_22_emg_param_1_47);
    #line 1571 
    ldv_free((void *)emg_22_emg_param_1_47);
    #line 1573 
    break;
    #line 1575 
    case 43: 
             #line 1575 
    ;
    #line 1577 
    emg_wrapper_ixgbe_fcoe_enable(emg_22_container);
    #line 1579 
    break;
    #line 1581 
    case 44: 
             #line 1581 
    ;
    #line 1583 
    emg_wrapper_ixgbe_fcoe_disable(emg_22_container);
    #line 1585 
    break;
    #line 1587 
    case 45: 
             #line 1587 
    ;
    #line 1589 
    emg_22_emg_param_2_45 = (struct scatterlist *)ldv_xmalloc_unknown_size(0UL);
    #line 1589 
    emg_22_emg_param_2_45 = emg_22_emg_param_2_45;
    #line 1593 
    ixgbe_fcoe_ddp_target(emg_22_container,(unsigned short)((int)emg_22_emg_param_1_44),emg_22_emg_param_2_45,emg_22_emg_param_3_46);
    #line 1597 
    ldv_free((void *)emg_22_emg_param_2_45);
    #line 1599 
    break;
    #line 1601 
    case 46: 
             #line 1601 
    ;
    #line 1603 
    emg_22_emg_param_2_42 = (struct scatterlist *)ldv_xmalloc_unknown_size(0UL);
    #line 1603 
    emg_22_emg_param_2_42 = emg_22_emg_param_2_42;
    #line 1607 
    ixgbe_fcoe_ddp_get(emg_22_container,(unsigned short)((int)emg_22_emg_param_1_41),emg_22_emg_param_2_42,emg_22_emg_param_3_43);
    #line 1611 
    ldv_free((void *)emg_22_emg_param_2_42);
    #line 1613 
    break;
    #line 1615 
    case 47: 
             #line 1615 
    ;
    #line 1617 
    ixgbe_fcoe_ddp_put(emg_22_container,(unsigned short)((int)emg_22_emg_param_1_40));
    #line 1619 
    break;
    #line 1621 
    case 48: 
             #line 1621 
    ;
    #line 1623 
    emg_22_emg_param_1_38 = (struct ifreq *)ldv_xmalloc_unknown_size(0UL);
    #line 1623 
    emg_22_emg_param_1_38 = emg_22_emg_param_1_38;
    #line 1627 
    emg_wrapper_ixgbe_ioctl(emg_22_container,emg_22_emg_param_1_38,emg_22_emg_param_2_39);
    #line 1631 
    ldv_free((void *)emg_22_emg_param_1_38);
    #line 1633 
    break;
    #line 1635 
    case 49: 
             #line 1635 
    ;
    #line 1637 
    emg_22_emg_param_1_37 = ldv_xmalloc_unknown_size(0UL);
    #line 1637 
    emg_22_emg_param_1_37 = emg_22_emg_param_1_37;
    #line 1641 
    emg_wrapper_ixgbe_fwd_del(emg_22_container,emg_22_emg_param_1_37);
    #line 1645 
    ldv_free(emg_22_emg_param_1_37);
    #line 1647 
    break;
    #line 1649 
    case 50: 
             #line 1649 
    ;
    #line 1651 
    emg_22_emg_param_1_36 = (struct net_device *)ldv_xmalloc_unknown_size(0UL);
    #line 1651 
    emg_22_emg_param_1_36 = emg_22_emg_param_1_36;
    #line 1655 
    emg_wrapper_ixgbe_fwd_add(emg_22_container,emg_22_emg_param_1_36);
    #line 1659 
    ldv_free((void *)emg_22_emg_param_1_36);
    #line 1661 
    break;
    #line 1663 
    case 51: 
             #line 1663 
    ;
    #line 1665 
    emg_wrapper_ixgbe_change_mtu(emg_22_container,emg_22_emg_param_1_35);
    #line 1667 
    break;
    #line 1669 
    case 52: 
             #line 1669 
    ;
    #line 1671 
    emg_22_emg_param_1_32 = (struct nlmsghdr *)ldv_xmalloc_unknown_size(0UL);
    #line 1671 
    emg_22_emg_param_1_32 = emg_22_emg_param_1_32;
    #line 1672 
    emg_22_emg_param_3_34 = (struct netlink_ext_ack *)ldv_xmalloc_unknown_size(0UL);
    #line 1672 
    emg_22_emg_param_3_34 = emg_22_emg_param_3_34;
    #line 1676 
    emg_wrapper_ixgbe_ndo_bridge_setlink(emg_22_container,emg_22_emg_param_1_32,(unsigned short)((int)emg_22_emg_param_2_33),emg_22_emg_param_3_34);
    #line 1680 
    ldv_free((void *)emg_22_emg_param_1_32);
    #line 1681 
    ldv_free((void *)emg_22_emg_param_3_34);
    #line 1683 
    break;
    #line 1685 
    case 53: 
             #line 1685 
    ;
    #line 1687 
    emg_22_emg_param_0_27 = (struct sk_buff *)ldv_xmalloc_unknown_size(0UL);
    #line 1687 
    emg_22_emg_param_0_27 = emg_22_emg_param_0_27;
    #line 1691 
    emg_wrapper_ixgbe_ndo_bridge_getlink(emg_22_emg_param_0_27,emg_22_emg_param_1_28,emg_22_emg_param_2_29,emg_22_container,emg_22_emg_param_4_30,emg_22_emg_param_5_31);
    #line 1695 
    ldv_free((void *)emg_22_emg_param_0_27);
    #line 1697 
    break;
    #line 1699 
    case 54: 
             #line 1699 
    ;
    #line 1701 
    emg_22_emg_param_1_26 = (struct netdev_bpf *)ldv_xmalloc_unknown_size(0UL);
    #line 1701 
    emg_22_emg_param_1_26 = emg_22_emg_param_1_26;
    #line 1705 
    emg_wrapper_ixgbe_xdp(emg_22_container,emg_22_emg_param_1_26);
    #line 1709 
    ldv_free((void *)emg_22_emg_param_1_26);
    #line 1711 
    break;
    #line 1713 
    case 55: 
             #line 1713 
    ;
    #line 1715 
    emg_22_emg_param_1_25 = (struct ethtool_wolinfo *)ldv_xmalloc_unknown_size(0UL);
    #line 1715 
    emg_22_emg_param_1_25 = emg_22_emg_param_1_25;
    #line 1719 
    emg_wrapper_ixgbe_get_wol(emg_22_container,emg_22_emg_param_1_25);
    #line 1723 
    ldv_free((void *)emg_22_emg_param_1_25);
    #line 1725 
    break;
    #line 1727 
    case 56: 
             #line 1727 
    ;
    #line 1729 
    emg_22_emg_param_1_24 = (struct ethtool_ts_info *)ldv_xmalloc_unknown_size(0UL);
    #line 1729 
    emg_22_emg_param_1_24 = emg_22_emg_param_1_24;
    #line 1733 
    emg_wrapper_ixgbe_get_ts_info(emg_22_container,emg_22_emg_param_1_24);
    #line 1737 
    ldv_free((void *)emg_22_emg_param_1_24);
    #line 1739 
    break;
    #line 1741 
    case 57: 
             #line 1741 
    ;
    #line 1743 
    emg_22_emg_param_2_23 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
    #line 1743 
    emg_22_emg_param_2_23 = emg_22_emg_param_2_23;
    #line 1747 
    emg_wrapper_ixgbe_get_strings(emg_22_container,emg_22_emg_param_1_22,emg_22_emg_param_2_23);
    #line 1751 
    ldv_free((void *)emg_22_emg_param_2_23);
    #line 1753 
    break;
    #line 1755 
    case 58: 
             #line 1755 
    ;
    #line 1757 
    emg_wrapper_ixgbe_get_sset_count(emg_22_container,emg_22_emg_param_1_21);
    #line 1759 
    break;
    #line 1761 
    case 59: 
             #line 1761 
    ;
    #line 1763 
    emg_22_emg_param_1_19 = (struct ethtool_rxnfc *)ldv_xmalloc_unknown_size(0UL);
    #line 1763 
    emg_22_emg_param_1_19 = emg_22_emg_param_1_19;
    #line 1764 
    emg_22_emg_param_2_20 = (unsigned int *)ldv_xmalloc_unknown_size(0UL);
    #line 1764 
    emg_22_emg_param_2_20 = emg_22_emg_param_2_20;
    #line 1768 
    emg_wrapper_ixgbe_get_rxnfc(emg_22_container,emg_22_emg_param_1_19,emg_22_emg_param_2_20);
    #line 1772 
    ldv_free((void *)emg_22_emg_param_1_19);
    #line 1773 
    ldv_free((void *)emg_22_emg_param_2_20);
    #line 1775 
    break;
    #line 1777 
    case 60: 
             #line 1777 
    ;
    #line 1779 
    emg_wrapper_ixgbe_get_rxfh_key_size(emg_22_container);
    #line 1781 
    break;
    #line 1783 
    case 61: 
             #line 1783 
    ;
    #line 1785 
    emg_wrapper_ixgbe_rss_indir_size(emg_22_container);
    #line 1787 
    break;
    #line 1789 
    case 62: 
             #line 1789 
    ;
    #line 1791 
    emg_22_emg_param_1_16 = (unsigned int *)ldv_xmalloc_unknown_size(0UL);
    #line 1791 
    emg_22_emg_param_1_16 = emg_22_emg_param_1_16;
    #line 1792 
    emg_22_emg_param_2_17 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
    #line 1792 
    emg_22_emg_param_2_17 = emg_22_emg_param_2_17;
    #line 1793 
    emg_22_emg_param_3_18 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
    #line 1793 
    emg_22_emg_param_3_18 = emg_22_emg_param_3_18;
    #line 1797 
    emg_wrapper_ixgbe_get_rxfh(emg_22_container,emg_22_emg_param_1_16,emg_22_emg_param_2_17,emg_22_emg_param_3_18);
    #line 1801 
    ldv_free((void *)emg_22_emg_param_1_16);
    #line 1802 
    ldv_free((void *)emg_22_emg_param_2_17);
    #line 1803 
    ldv_free((void *)emg_22_emg_param_3_18);
    #line 1805 
    break;
    #line 1807 
    case 63: 
             #line 1807 
    ;
    #line 1809 
    emg_22_emg_param_1_15 = (struct ethtool_ringparam *)ldv_xmalloc_unknown_size(0UL);
    #line 1809 
    emg_22_emg_param_1_15 = emg_22_emg_param_1_15;
    #line 1813 
    emg_wrapper_ixgbe_get_ringparam(emg_22_container,emg_22_emg_param_1_15);
    #line 1817 
    ldv_free((void *)emg_22_emg_param_1_15);
    #line 1819 
    break;
    #line 1821 
    case 64: 
             #line 1821 
    ;
    #line 1823 
    emg_wrapper_ixgbe_get_regs_len(emg_22_container);
    #line 1825 
    break;
    #line 1827 
    case 65: 
             #line 1827 
    ;
    #line 1829 
    emg_22_emg_param_1_13 = (struct ethtool_regs *)ldv_xmalloc_unknown_size(0UL);
    #line 1829 
    emg_22_emg_param_1_13 = emg_22_emg_param_1_13;
    #line 1830 
    emg_22_emg_param_2_14 = ldv_xmalloc_unknown_size(0UL);
    #line 1830 
    emg_22_emg_param_2_14 = emg_22_emg_param_2_14;
    #line 1834 
    emg_wrapper_ixgbe_get_regs(emg_22_container,emg_22_emg_param_1_13,emg_22_emg_param_2_14);
    #line 1838 
    ldv_free((void *)emg_22_emg_param_1_13);
    #line 1839 
    ldv_free(emg_22_emg_param_2_14);
    #line 1841 
    break;
    #line 1843 
    case 66: 
             #line 1843 
    ;
    #line 1845 
    emg_wrapper_ixgbe_get_priv_flags(emg_22_container);
    #line 1847 
    break;
    #line 1849 
    case 67: 
             #line 1849 
    ;
    #line 1851 
    emg_22_emg_param_1_12 = (struct ethtool_pauseparam *)ldv_xmalloc_unknown_size(0UL);
    #line 1851 
    emg_22_emg_param_1_12 = emg_22_emg_param_1_12;
    #line 1855 
    emg_wrapper_ixgbe_get_pauseparam(emg_22_container,emg_22_emg_param_1_12);
    #line 1859 
    ldv_free((void *)emg_22_emg_param_1_12);
    #line 1861 
    break;
    #line 1863 
    case 68: 
             #line 1863 
    ;
    #line 1865 
    emg_wrapper_ixgbe_get_msglevel(emg_22_container);
    #line 1867 
    break;
    #line 1869 
    case 69: 
             #line 1869 
    ;
    #line 1871 
    emg_22_emg_param_1_11 = (struct ethtool_modinfo *)ldv_xmalloc_unknown_size(0UL);
    #line 1871 
    emg_22_emg_param_1_11 = emg_22_emg_param_1_11;
    #line 1875 
    emg_wrapper_ixgbe_get_module_info(emg_22_container,emg_22_emg_param_1_11);
    #line 1879 
    ldv_free((void *)emg_22_emg_param_1_11);
    #line 1881 
    break;
    #line 1883 
    case 70: 
             #line 1883 
    ;
    #line 1885 
    emg_22_emg_param_1_9 = (struct ethtool_eeprom *)ldv_xmalloc_unknown_size(0UL);
    #line 1885 
    emg_22_emg_param_1_9 = emg_22_emg_param_1_9;
    #line 1886 
    emg_22_emg_param_2_10 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
    #line 1886 
    emg_22_emg_param_2_10 = emg_22_emg_param_2_10;
    #line 1890 
    emg_wrapper_ixgbe_get_module_eeprom(emg_22_container,emg_22_emg_param_1_9,emg_22_emg_param_2_10);
    #line 1894 
    ldv_free((void *)emg_22_emg_param_1_9);
    #line 1895 
    ldv_free((void *)emg_22_emg_param_2_10);
    #line 1897 
    break;
    #line 1899 
    case 71: 
             #line 1899 
    ;
    #line 1901 
    emg_22_emg_param_1_8 = (struct ethtool_link_ksettings *)ldv_xmalloc_unknown_size(0UL);
    #line 1901 
    emg_22_emg_param_1_8 = emg_22_emg_param_1_8;
    #line 1905 
    emg_wrapper_ixgbe_get_link_ksettings(emg_22_container,emg_22_emg_param_1_8);
    #line 1909 
    ldv_free((void *)emg_22_emg_param_1_8);
    #line 1911 
    break;
    #line 1913 
    case 72: 
             #line 1913 
    ;
    #line 1915 
    ethtool_op_get_link(emg_22_container);
    #line 1917 
    break;
    #line 1919 
    case 73: 
             #line 1919 
    ;
    #line 1921 
    emg_22_emg_param_1_6 = (struct ethtool_stats *)ldv_xmalloc_unknown_size(0UL);
    #line 1921 
    emg_22_emg_param_1_6 = emg_22_emg_param_1_6;
    #line 1922 
    emg_22_emg_param_2_7 = (unsigned long long *)ldv_xmalloc_unknown_size(0UL);
    #line 1922 
    emg_22_emg_param_2_7 = emg_22_emg_param_2_7;
    #line 1926 
    emg_wrapper_ixgbe_get_ethtool_stats(emg_22_container,emg_22_emg_param_1_6,emg_22_emg_param_2_7);
    #line 1930 
    ldv_free((void *)emg_22_emg_param_1_6);
    #line 1931 
    ldv_free((void *)emg_22_emg_param_2_7);
    #line 1933 
    break;
    #line 1935 
    case 74: 
             #line 1935 
    ;
    #line 1937 
    emg_wrapper_ixgbe_get_eeprom_len(emg_22_container);
    #line 1939 
    break;
    #line 1941 
    case 75: 
             #line 1941 
    ;
    #line 1943 
    emg_22_emg_param_1_4 = (struct ethtool_eeprom *)ldv_xmalloc_unknown_size(0UL);
    #line 1943 
    emg_22_emg_param_1_4 = emg_22_emg_param_1_4;
    #line 1944 
    emg_22_emg_param_2_5 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
    #line 1944 
    emg_22_emg_param_2_5 = emg_22_emg_param_2_5;
    #line 1948 
    emg_wrapper_ixgbe_get_eeprom(emg_22_container,emg_22_emg_param_1_4,emg_22_emg_param_2_5);
    #line 1952 
    ldv_free((void *)emg_22_emg_param_1_4);
    #line 1953 
    ldv_free((void *)emg_22_emg_param_2_5);
    #line 1955 
    break;
    #line 1957 
    case 76: 
             #line 1957 
    ;
    #line 1959 
    emg_22_emg_param_1_3 = (struct ethtool_eee *)ldv_xmalloc_unknown_size(0UL);
    #line 1959 
    emg_22_emg_param_1_3 = emg_22_emg_param_1_3;
    #line 1963 
    emg_wrapper_ixgbe_get_eee(emg_22_container,emg_22_emg_param_1_3);
    #line 1967 
    ldv_free((void *)emg_22_emg_param_1_3);
    #line 1969 
    break;
    #line 1971 
    case 77: 
             #line 1971 
    ;
    #line 1973 
    emg_22_emg_param_1_2 = (struct ethtool_drvinfo *)ldv_xmalloc_unknown_size(0UL);
    #line 1973 
    emg_22_emg_param_1_2 = emg_22_emg_param_1_2;
    #line 1977 
    emg_wrapper_ixgbe_get_drvinfo(emg_22_container,emg_22_emg_param_1_2);
    #line 1981 
    ldv_free((void *)emg_22_emg_param_1_2);
    #line 1983 
    break;
    #line 1985 
    case 78: 
             #line 1985 
    ;
    #line 1987 
    emg_22_emg_param_1_1 = (struct ethtool_coalesce *)ldv_xmalloc_unknown_size(0UL);
    #line 1987 
    emg_22_emg_param_1_1 = emg_22_emg_param_1_1;
    #line 1991 
    emg_wrapper_ixgbe_get_coalesce(emg_22_container,emg_22_emg_param_1_1);
    #line 1995 
    ldv_free((void *)emg_22_emg_param_1_1);
    #line 1997 
    break;
    #line 1999 
    case 79: 
             #line 1999 
    ;
    #line 2001 
    emg_22_emg_param_1_0 = (struct ethtool_channels *)ldv_xmalloc_unknown_size(0UL);
    #line 2001 
    emg_22_emg_param_1_0 = emg_22_emg_param_1_0;
    #line 2005 
    emg_wrapper_ixgbe_get_channels(emg_22_container,emg_22_emg_param_1_0);
    #line 2009 
    ldv_free((void *)emg_22_emg_param_1_0);
    #line 2012 
    if (emg_repeat_cnt_call_22 > 0) {
      #line 2013 
      emg_repeat_cnt_call_22 --;
      #line 2015 
      goto emg_call_22;
    }
    else 
         #line 2017 
         __VERIFIER_assume(0);
    #line 2021 
    break;
    #line 2023 
    case 80: 
             #line 2023 
    ;
    #line 2027 
    break;
    #line 2029 
    default: 
             #line 2029 
    ;
    #line 2029 
    __VERIFIER_assume(0);
  }
  #line 2032 
  return (void *)0;
}

#line 2037  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
void *emg_pci_pci_scenario_ixgbe_driver(void *arg0)
{
  #line 2040 
  int emg_23_choice;
  #line 2041 
  struct pci_driver *emg_23_container;
  #line 2042 
  struct pci_device_id *emg_23_device_id;
  #line 2043 
  int emg_23_emg_param_1_0;
  #line 2044 
  struct pci_dev *emg_23_resource_0;
  #line 2045 
  struct pm_message emg_23_resource_1;
  #line 2046 
  int emg_23_ret;
  #line 2047 
  int emg_repeat_cnt_call_23_0 = 1;
  #line 2048 
  int emg_repeat_cnt_call_23_1 = 1;
  #line 2049 
  int emg_repeat_cnt_main_23_0 = 1;
  #line 2050 
  int emg_repeat_cnt_main_23_1 = 1;
  #line 2052 
  struct emg_struct_pci_scenario_ixgbe_driver_23 *data = (struct emg_struct_pci_scenario_ixgbe_driver_23 *)arg0;
  #line 2056 
  emg_23_choice = 0;
  #line 2057 
  emg_23_ret = ldv_undef_int();
  #line 2058 
  emg_23_choice = 0;
  #line 2059 
  emg_23_container = emg_alias_ixgbe_driver;
  #line 2060 
  emg_23_ret = ldv_undef_int();
  #line 2062 
  __VERIFIER_assume(data->arg0 == emg_alias_ixgbe_driver);
  #line 2064 
  if (data != (struct emg_struct_pci_scenario_ixgbe_driver_23 *)0) {
    #line 2065 
    emg_23_container = data->arg0;
    #line 2066 
    ldv_free((void *)data);
  }
  #line 2071 
  emg_23_resource_0 = (struct pci_dev *)ldv_xmalloc(3312UL);
  #line 2072 
  emg_23_choice = __ldv_undef_int_range(0,47);
  #line 2073 
  emg_23_device_id = emg_23_container->id_table + (unsigned long)emg_23_choice;
  #line 2077 
  goto emg_main_23;
  #line 2081 
  return (void *)0;
  #line 2084 
  emg_call_23: 
               #line 2084 
  ;
  #line 2085 
  switch (ldv_undef_int()) {
    #line 2086 
    case 0: 
            #line 2086 
    ;
    #line 2088 
    ixgbe_pci_sriov_configure(emg_23_resource_0,emg_23_emg_param_1_0);
    #line 2091 
    if (emg_repeat_cnt_call_23_1 > 0) {
      #line 2092 
      emg_repeat_cnt_call_23_1 --;
      #line 2094 
      goto emg_call_23;
    }
    else 
         #line 2096 
         __VERIFIER_assume(0);
    #line 2100 
    break;
    #line 2102 
    case 1: 
            #line 2102 
    ;
    #line 2104 
    emg_23_ret = emg_wrapper_ixgbe_suspend(emg_23_resource_0,emg_23_resource_1);
    #line 2109 
    emg_23_ret = ldv_filter_err_code(emg_23_ret);
    #line 2113 
    emg_wrapper_ixgbe_resume(emg_23_resource_0);
    #line 2116 
    if (emg_repeat_cnt_call_23_0 > 0) {
      #line 2117 
      emg_repeat_cnt_call_23_0 --;
      #line 2119 
      goto emg_call_23;
    }
    else 
         #line 2121 
         __VERIFIER_assume(0);
    #line 2125 
    break;
    #line 2127 
    case 2: 
            #line 2127 
    ;
    #line 2129 
    emg_wrapper_ixgbe_shutdown(emg_23_resource_0);
    #line 2133 
    emg_wrapper_ixgbe_remove(emg_23_resource_0);
    #line 2136 
    if (emg_repeat_cnt_main_23_0 > 0) {
      #line 2137 
      emg_repeat_cnt_main_23_0 --;
      #line 2139 
      goto emg_main_23;
    }
    else 
         #line 2141 
         __VERIFIER_assume(0);
    #line 2145 
    break;
    #line 2147 
    default: 
             #line 2147 
    ;
    #line 2147 
    __VERIFIER_assume(0);
  }
  #line 2150 
  return (void *)0;
  #line 2153 
  emg_main_23: 
               #line 2153 
  ;
  #line 2154 
  if (ldv_undef_int() != 0) {
    #line 2157 
    ldv_pre_probe();
    #line 2161 
    emg_23_ret = emg_wrapper_ixgbe_probe(emg_23_resource_0,emg_23_device_id);
    #line 2166 
    emg_23_ret = ldv_post_probe(emg_23_ret);
    #line 2169 
    if (ldv_undef_int() != 0) {
      #line 2171 
      __VERIFIER_assume(emg_23_ret == 0);
      #line 2175 
      goto emg_call_23;
    }
    else 
         #line 2180 
         __VERIFIER_assume(emg_23_ret != 0);
    #line 2184 
    if (emg_repeat_cnt_main_23_1 > 0) {
      #line 2185 
      emg_repeat_cnt_main_23_1 --;
      #line 2187 
      goto emg_main_23;
    }
    else 
         #line 2189 
         __VERIFIER_assume(0);
  }
  else 
       #line 2195 
       ldv_free((void *)emg_23_resource_0);
  #line 2203 
  return (void *)0;
}

#line 2208  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
void *emg_timer_timer_scenario_8(void *arg0)
{
  #line 2211 
  struct timer_list *emg_24_container;
  #line 2212 
  unsigned long emg_24_emg_param_0_0;
  #line 2214 
  struct emg_struct_timer_scenario_8_24 *data = (struct emg_struct_timer_scenario_8_24 *)arg0;
  #line 2219 
  if (data != (struct emg_struct_timer_scenario_8_24 *)0) {
    #line 2220 
    emg_24_container = data->arg0;
    #line 2221 
    ldv_free((void *)data);
  }
  #line 2227 
  ldv_switch_to_interrupt_context();
  #line 2231 
  if (emg_24_container->function != (void (*)(struct timer_list *))0) 
    #line 2232 
    (*(emg_24_container->function))((struct timer_list *)emg_24_emg_param_0_0);
  #line 2238 
  ldv_switch_to_process_context();
  #line 2245 
  return (void *)0;
}

#line 2250  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
int emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2)
{
  #line 2253 
  struct pci_driver *emg_2_pci_driver;
  #line 2255 
  emg_2_pci_driver = emg_alias_ixgbe_driver;
  #line 2256 
  if (ldv_undef_int() != 0) {
    #line 2258 
    emg_2_pci_driver = arg0;
    #line 2262 
    emg_dispatch_register_2(emg_2_pci_driver);
    #line 2266 
    return 0;
  }
  else {
    #line 2270 
    return ldv_undef_int_negative();
  }
}

#line 2278  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
struct net_device *emg_alloc_etherdev_mqs(int arg0, unsigned int arg1, unsigned int arg2)
{
  #line 2281 
  struct net_device *emg_3_netdev;
  #line 2283 
  if (ldv_undef_int() != 0) {
    #line 2285 
    emg_3_netdev = (struct net_device *)ldv_xmalloc(3328UL);
    #line 2289 
    return emg_3_netdev;
  }
  else 
       #line 2293 
       return (struct net_device *)0;
}

#line 2301  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
struct dentry *emg_debugfs_create_dir(char *arg0, struct dentry *arg1)
{
  #line 2304 
  struct dentry *emg_4_dentry;
  #line 2305 
  struct inode *emg_4_inode;
  #line 2307 
  if (ldv_undef_int() != 0) {
    #line 2309 
    emg_4_dentry = (struct dentry *)ldv_xmalloc(320UL);
    #line 2310 
    emg_4_inode = (struct inode *)ldv_xmalloc(1072UL);
    #line 2311 
    emg_4_inode->i_mode = (unsigned short)16877U;
    #line 2312 
    emg_4_dentry->d_parent = arg1;
    #line 2313 
    emg_4_dentry->d_inode = emg_4_inode;
    #line 2314 
    return emg_4_dentry;
  }
  else {
    #line 2318 
    return (struct dentry *)ERR_PTR_1(-19L);
  }
}

#line 2326  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
struct dentry *emg_debugfs_create_file(char *arg0, unsigned short arg1, struct dentry *arg2, void *arg3, struct file_operations *arg4)
{
  #line 2329 
  struct dentry *emg_5_dentry;
  #line 2330 
  struct file_operations *emg_5_file_operations;
  #line 2331 
  struct inode *emg_5_inode;
  #line 2333 
  if (ldv_undef_int() != 0) {
    #line 2335 
    emg_5_dentry = (struct dentry *)ldv_xmalloc(320UL);
    #line 2336 
    emg_5_inode = (struct inode *)ldv_xmalloc(1072UL);
    #line 2337 
    emg_5_inode->i_mode = arg1;
    #line 2338 
    emg_5_dentry->d_parent = arg2;
    #line 2339 
    emg_5_inode->i_private = arg3;
    #line 2340 
    emg_5_file_operations = arg4;
    #line 2341 
    emg_5_dentry->d_inode = emg_5_inode;
    #line 2342 
    ldv_save_allocated_memory_to_list((void *)emg_5_dentry);
    #line 2346 
    emg_dispatch_register_5(emg_5_file_operations);
    #line 2350 
    return emg_5_dentry;
  }
  else {
    #line 2354 
    return (struct dentry *)ERR_PTR_1(-19L);
  }
}

#line 2362  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
int emg_del_timer_sync(struct timer_list *arg0)
{
  #line 2365 
  struct timer_list *emg_6_timer_list;
  #line 2368 
  emg_6_timer_list = arg0;
  #line 2372 
  emg_dispatch_instance_deregister_6(emg_6_timer_list);
  #line 2373 
  ;
  #line 2373 
  return 0;
}

#line 2379  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
void *emg_free_irq(unsigned int arg0, void *arg1)
{
  #line 2382 
  int emg_7_line;
  #line 2385 
  emg_7_line = (int)arg0;
  #line 2389 
  emg_dispatch_irq_deregister_7(emg_7_line);
  #line 2390 
  ;
  #line 2390 
  return (void *)0;
}

#line 2396  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
void emg_free_netdev(struct net_device *arg0)
{
  #line 2399 
  struct net_device *emg_8_netdev;
  #line 2402 
  emg_8_netdev = arg0;
  #line 2403 
  ldv_free((void *)emg_8_netdev);
  #line 2406 
  return;
}

#line 2411  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
int emg_mod_timer(struct timer_list *arg0, unsigned long arg1)
{
  #line 2414 
  struct timer_list *emg_9_timer_list;
  #line 2416 
  if (ldv_undef_int() != 0) {
    #line 2418 
    emg_9_timer_list = arg0;
    #line 2422 
    emg_dispatch_instance_register_9(emg_9_timer_list);
    #line 2426 
    return 1;
  }
  else 
       #line 2430 
       return 0;
}

#line 2438  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
void emg_pci_unregister_driver(struct pci_driver *arg0)
{
  #line 2441 
  struct pci_driver *emg_10_pci_driver;
  #line 2443 
  emg_10_pci_driver = emg_alias_ixgbe_driver;
  #line 2445 
  emg_10_pci_driver = arg0;
  #line 2449 
  emg_dispatch_deregister_10(emg_10_pci_driver);
  #line 2452 
  return;
}

#line 2457  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
_Bool emg_queue_work(struct workqueue_struct *arg0, struct work_struct *arg1)
{
  #line 2460 
  struct work_struct *emg_11_work_struct;
  #line 2462 
  if (ldv_undef_int() != 0) {
    #line 2464 
    emg_11_work_struct = arg1;
    #line 2468 
    if (emg_11_work_struct->func != (void (*)(struct work_struct *))0) 
      #line 2469 
      (*(emg_11_work_struct->func))(emg_11_work_struct);
    #line 2474 
    return (_Bool)1;
  }
  else 
       #line 2478 
       return (_Bool)0;
}

#line 2486  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
int emg_register_netdev(struct net_device *arg0)
{
  #line 2489 
  struct net_device *emg_12_netdev;
  #line 2490 
  int emg_12_ret;
  #line 2493 
  emg_12_ret = ldv_undef_int();
  #line 2494 
  emg_12_ret = ldv_undef_int();
  #line 2495 
  if (ldv_undef_int() != 0) {
    #line 2497 
    emg_12_netdev = arg0;
    #line 2501 
    emg_12_ret = emg_wrapper_ixgbe_open(emg_12_netdev);
    #line 2504 
    if (ldv_undef_int() != 0) {
      #line 2506 
      __VERIFIER_assume(emg_12_ret == 0);
      #line 2510 
      emg_dispatch_register_12(emg_12_netdev);
      #line 2514 
      return 0;
    }
    else {
      #line 2518 
      __VERIFIER_assume(emg_12_ret != 0);
      #line 2519 
      ldv_failed_register_netdev();
      #line 2520 
      return ldv_undef_int_negative();
    }
  }
  else {
    #line 2525 
    ldv_failed_register_netdev();
    #line 2526 
    return ldv_undef_int_negative();
  }
}

#line 2534  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
int emg_request_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), unsigned long arg2, char *arg3, void *arg4)
{
  #line 2537 
  enum irqreturn (*emg_13_callback)(int , void *);
  #line 2538 
  void *emg_13_data;
  #line 2539 
  int emg_13_line;
  #line 2540 
  enum irqreturn (*emg_13_thread)(int , void *);
  #line 2542 
  emg_13_callback = & emg_wrapper_ixgbe_intr;
  #line 2543 
  if (ldv_undef_int() != 0) {
    #line 2545 
    emg_13_line = (int)arg0;
    #line 2546 
    emg_13_callback = arg1;
    #line 2547 
    emg_13_thread = (enum irqreturn (*)(int , void *))0;
    #line 2548 
    emg_13_data = arg4;
    #line 2552 
    emg_dispatch_irq_register_13(emg_13_line,emg_13_callback,emg_13_thread,emg_13_data);
    #line 2556 
    return 0;
  }
  else {
    #line 2560 
    return ldv_undef_int_negative();
  }
}

#line 2568  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
_Bool emg_schedule_work(struct work_struct *arg0)
{
  #line 2571 
  struct work_struct *emg_14_work_struct;
  #line 2573 
  if (ldv_undef_int() != 0) {
    #line 2575 
    emg_14_work_struct = arg0;
    #line 2579 
    if (emg_14_work_struct->func != (void (*)(struct work_struct *))0) 
      #line 2580 
      (*(emg_14_work_struct->func))(emg_14_work_struct);
    #line 2585 
    return (_Bool)1;
  }
  else 
       #line 2589 
       return (_Bool)0;
}

#line 2597  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
void emg_unregister_netdev(struct net_device *arg0)
{
  #line 2600 
  struct net_device *emg_15_netdev;
  #line 2603 
  emg_15_netdev = arg0;
  #line 2607 
  emg_wrapper_ixgbe_close(emg_15_netdev);
  #line 2611 
  emg_dispatch_deregister_15(emg_15_netdev);
  #line 2614 
  return;
}

#line 2619  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
void *emg_entry_point_insmod(void *arg0)
{
  #line 2622 
  int emg_1_ret;
  #line 2625 
  emg_1_ret = emg_ixgbe_init_module();
  #line 2626 
  emg_1_ret = ldv_post_init(emg_1_ret);
  #line 2629 
  if (ldv_undef_int() != 0) {
    #line 2631 
    __VERIFIER_assume(emg_1_ret == 0);
    #line 2635 
    emg_ixgbe_exit_module();
  }
  else 
       #line 2639 
       __VERIFIER_assume(emg_1_ret != 0);
  #line 2643 
  return (void *)0;
}

#line 2648  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/concurrency safety/emg/0/environment_model.c"
int main(void)
{
  #line 2650 
  ldv_initialize();
  #line 2652 
  emg_entry_point_insmod((void *)0);
  #line 2654 
  return 0;
}

